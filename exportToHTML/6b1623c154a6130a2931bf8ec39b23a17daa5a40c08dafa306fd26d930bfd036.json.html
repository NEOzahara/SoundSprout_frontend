<html>
<head>
<title>6b1623c154a6130a2931bf8ec39b23a17daa5a40c08dafa306fd26d930bfd036.json</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #cf8e6d;}
.s3 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
6b1623c154a6130a2931bf8ec39b23a17daa5a40c08dafa306fd26d930bfd036.json</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;ast&quot;</span><span class="s0">:</span><span class="s2">null</span><span class="s0">,</span><span class="s1">&quot;code&quot;</span><span class="s0">:</span><span class="s1">&quot;</span><span class="s2">\&quot;</span><span class="s1">use strict</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s2">\&quot;</span><span class="s1">__esModule</span><span class="s2">\&quot;</span><span class="s1">, {</span><span class="s2">\n  </span><span class="s1">value: true</span><span class="s2">\n</span><span class="s1">});</span><span class="s2">\n</span><span class="s1">exports.parse = parse;</span><span class="s2">\n</span><span class="s1">exports.serialize = serialize;</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* RegExp to match cookie-name in RFC 6265 sec 4.1.1</span><span class="s2">\n </span><span class="s1">* This refers out to the obsoleted definition of token in RFC 2616 sec 2.2</span><span class="s2">\n </span><span class="s1">* which has been replaced by the token definition in RFC 7230 appendix B.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* cookie-name       = token</span><span class="s2">\n </span><span class="s1">* token             = 1*tchar</span><span class="s2">\n </span><span class="s1">* tchar             = </span><span class="s2">\&quot;</span><span class="s1">!</span><span class="s2">\&quot; </span><span class="s1">/ </span><span class="s2">\&quot;</span><span class="s1">#</span><span class="s2">\&quot; </span><span class="s1">/ </span><span class="s2">\&quot;</span><span class="s1">$</span><span class="s2">\&quot; </span><span class="s1">/ </span><span class="s2">\&quot;</span><span class="s1">%</span><span class="s2">\&quot; </span><span class="s1">/ </span><span class="s2">\&quot;</span><span class="s1">&amp;</span><span class="s2">\&quot; </span><span class="s1">/ </span><span class="s2">\&quot;</span><span class="s1">'</span><span class="s2">\&quot; </span><span class="s1">/</span><span class="s2">\n </span><span class="s1">*                     </span><span class="s2">\&quot;</span><span class="s1">*</span><span class="s2">\&quot; </span><span class="s1">/ </span><span class="s2">\&quot;</span><span class="s1">+</span><span class="s2">\&quot; </span><span class="s1">/ </span><span class="s2">\&quot;</span><span class="s1">-</span><span class="s2">\&quot; </span><span class="s1">/ </span><span class="s2">\&quot;</span><span class="s1">.</span><span class="s2">\&quot; </span><span class="s1">/ </span><span class="s2">\&quot;</span><span class="s1">^</span><span class="s2">\&quot; </span><span class="s1">/ </span><span class="s2">\&quot;</span><span class="s1">_</span><span class="s2">\&quot; </span><span class="s1">/</span><span class="s2">\n </span><span class="s1">*                     </span><span class="s2">\&quot;</span><span class="s1">`</span><span class="s2">\&quot; </span><span class="s1">/ </span><span class="s2">\&quot;</span><span class="s1">|</span><span class="s2">\&quot; </span><span class="s1">/ </span><span class="s2">\&quot;</span><span class="s1">~</span><span class="s2">\&quot; </span><span class="s1">/ DIGIT / ALPHA</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* Note: Allowing more characters - https://github.com/jshttp/cookie/issues/191</span><span class="s2">\n </span><span class="s1">* Allow same range as cookie value, except `=`, which delimits end of name.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const cookieNameRegExp = /^[</span><span class="s2">\\</span><span class="s1">u0021-</span><span class="s2">\\</span><span class="s1">u003A</span><span class="s2">\\</span><span class="s1">u003C</span><span class="s2">\\</span><span class="s1">u003E-</span><span class="s2">\\</span><span class="s1">u007E]+$/;</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* RegExp to match cookie-value in RFC 6265 sec 4.1.1</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )</span><span class="s2">\n </span><span class="s1">* cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E</span><span class="s2">\n </span><span class="s1">*                     ; US-ASCII characters excluding CTLs,</span><span class="s2">\n </span><span class="s1">*                     ; whitespace DQUOTE, comma, semicolon,</span><span class="s2">\n </span><span class="s1">*                     ; and backslash</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* Allowing more characters: https://github.com/jshttp/cookie/issues/191</span><span class="s2">\n </span><span class="s1">* Comma, backslash, and DQUOTE are not part of the parsing algorithm.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const cookieValueRegExp = /^[</span><span class="s2">\\</span><span class="s1">u0021-</span><span class="s2">\\</span><span class="s1">u003A</span><span class="s2">\\</span><span class="s1">u003C-</span><span class="s2">\\</span><span class="s1">u007E]*$/;</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* RegExp to match domain-value in RFC 6265 sec 4.1.1</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* domain-value      = &lt;subdomain&gt;</span><span class="s2">\n </span><span class="s1">*                     ; defined in [RFC1034], Section 3.5, as</span><span class="s2">\n </span><span class="s1">*                     ; enhanced by [RFC1123], Section 2.1</span><span class="s2">\n </span><span class="s1">* &lt;subdomain&gt;       = &lt;label&gt; | &lt;subdomain&gt; </span><span class="s2">\&quot;</span><span class="s1">.</span><span class="s2">\&quot; </span><span class="s1">&lt;label&gt;</span><span class="s2">\n </span><span class="s1">* &lt;label&gt;           = &lt;let-dig&gt; [ [ &lt;ldh-str&gt; ] &lt;let-dig&gt; ]</span><span class="s2">\n </span><span class="s1">*                     Labels must be 63 characters or less.</span><span class="s2">\n </span><span class="s1">*                     'let-dig' not 'letter' in the first char, per RFC1123</span><span class="s2">\n </span><span class="s1">* &lt;ldh-str&gt;         = &lt;let-dig-hyp&gt; | &lt;let-dig-hyp&gt; &lt;ldh-str&gt;</span><span class="s2">\n </span><span class="s1">* &lt;let-dig-hyp&gt;     = &lt;let-dig&gt; | </span><span class="s2">\&quot;</span><span class="s1">-</span><span class="s2">\&quot;\n </span><span class="s1">* &lt;let-dig&gt;         = &lt;letter&gt; | &lt;digit&gt;</span><span class="s2">\n </span><span class="s1">* &lt;letter&gt;          = any one of the 52 alphabetic characters A through Z in</span><span class="s2">\n </span><span class="s1">*                     upper case and a through z in lower case</span><span class="s2">\n </span><span class="s1">* &lt;digit&gt;           = any one of the ten digits 0 through 9</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* Keep support for leading dot: https://github.com/jshttp/cookie/issues/173</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* &gt; (Note that a leading %x2E (</span><span class="s2">\&quot;</span><span class="s1">.</span><span class="s2">\&quot;</span><span class="s1">), if present, is ignored even though that</span><span class="s2">\n </span><span class="s1">* character is not permitted, but a trailing %x2E (</span><span class="s2">\&quot;</span><span class="s1">.</span><span class="s2">\&quot;</span><span class="s1">), if present, will</span><span class="s2">\n </span><span class="s1">* cause the user agent to ignore the attribute.)</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* RegExp to match path-value in RFC 6265 sec 4.1.1</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* path-value        = &lt;any CHAR except CTLs or </span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\&quot;</span><span class="s1">&gt;</span><span class="s2">\n </span><span class="s1">* CHAR              = %x01-7F</span><span class="s2">\n </span><span class="s1">*                     ; defined in RFC 5234 appendix B.1</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const pathValueRegExp = /^[</span><span class="s2">\\</span><span class="s1">u0020-</span><span class="s2">\\</span><span class="s1">u003A</span><span class="s2">\\</span><span class="s1">u003D-</span><span class="s2">\\</span><span class="s1">u007E]*$/;</span><span class="s2">\n</span><span class="s1">const __toString = Object.prototype.toString;</span><span class="s2">\n</span><span class="s1">const NullObject = /* @__PURE__ */(() =&gt; {</span><span class="s2">\n  </span><span class="s1">const C = function () {};</span><span class="s2">\n  </span><span class="s1">C.prototype = Object.create(null);</span><span class="s2">\n  </span><span class="s1">return C;</span><span class="s2">\n</span><span class="s1">})();</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Parse a cookie header.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* Parse the given cookie header string into an object</span><span class="s2">\n </span><span class="s1">* The object has the various cookies as keys(names) =&gt; values</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function parse(str, options) {</span><span class="s2">\n  </span><span class="s1">const obj = new NullObject();</span><span class="s2">\n  </span><span class="s1">const len = str.length;</span><span class="s2">\n  </span><span class="s1">// RFC 6265 sec 4.1.1, RFC 2616 2.2 defines a cookie name consists of one char minimum, plus '='.</span><span class="s2">\n  </span><span class="s1">if (len &lt; 2) return obj;</span><span class="s2">\n  </span><span class="s1">const dec = options?.decode || decode;</span><span class="s2">\n  </span><span class="s1">let index = 0;</span><span class="s2">\n  </span><span class="s1">do {</span><span class="s2">\n    </span><span class="s1">const eqIdx = str.indexOf(</span><span class="s2">\&quot;</span><span class="s1">=</span><span class="s2">\&quot;</span><span class="s1">, index);</span><span class="s2">\n    </span><span class="s1">if (eqIdx === -1) break; // No more cookie pairs.</span><span class="s2">\n    </span><span class="s1">const colonIdx = str.indexOf(</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\&quot;</span><span class="s1">, index);</span><span class="s2">\n    </span><span class="s1">const endIdx = colonIdx === -1 ? len : colonIdx;</span><span class="s2">\n    </span><span class="s1">if (eqIdx &gt; endIdx) {</span><span class="s2">\n      </span><span class="s1">// backtrack on prior semicolon</span><span class="s2">\n      </span><span class="s1">index = str.lastIndexOf(</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\&quot;</span><span class="s1">, eqIdx - 1) + 1;</span><span class="s2">\n      </span><span class="s1">continue;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">const keyStartIdx = startIndex(str, index, eqIdx);</span><span class="s2">\n    </span><span class="s1">const keyEndIdx = endIndex(str, eqIdx, keyStartIdx);</span><span class="s2">\n    </span><span class="s1">const key = str.slice(keyStartIdx, keyEndIdx);</span><span class="s2">\n    </span><span class="s1">// only assign once</span><span class="s2">\n    </span><span class="s1">if (obj[key] === undefined) {</span><span class="s2">\n      </span><span class="s1">let valStartIdx = startIndex(str, eqIdx + 1, endIdx);</span><span class="s2">\n      </span><span class="s1">let valEndIdx = endIndex(str, endIdx, valStartIdx);</span><span class="s2">\n      </span><span class="s1">const value = dec(str.slice(valStartIdx, valEndIdx));</span><span class="s2">\n      </span><span class="s1">obj[key] = value;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">index = endIdx + 1;</span><span class="s2">\n  </span><span class="s1">} while (index &lt; len);</span><span class="s2">\n  </span><span class="s1">return obj;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function startIndex(str, index, max) {</span><span class="s2">\n  </span><span class="s1">do {</span><span class="s2">\n    </span><span class="s1">const code = str.charCodeAt(index);</span><span class="s2">\n    </span><span class="s1">if (code !== 0x20 /*   */ &amp;&amp; code !== 0x09 /* </span><span class="s2">\\</span><span class="s1">t */) return index;</span><span class="s2">\n  </span><span class="s1">} while (++index &lt; max);</span><span class="s2">\n  </span><span class="s1">return max;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function endIndex(str, index, min) {</span><span class="s2">\n  </span><span class="s1">while (index &gt; min) {</span><span class="s2">\n    </span><span class="s1">const code = str.charCodeAt(--index);</span><span class="s2">\n    </span><span class="s1">if (code !== 0x20 /*   */ &amp;&amp; code !== 0x09 /* </span><span class="s2">\\</span><span class="s1">t */) return index + 1;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return min;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Serialize data into a cookie header.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* Serialize a name value pair into a cookie string suitable for</span><span class="s2">\n </span><span class="s1">* http headers. An optional options object specifies cookie parameters.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* serialize('foo', 'bar', { httpOnly: true })</span><span class="s2">\n </span><span class="s1">*   =&gt; </span><span class="s2">\&quot;</span><span class="s1">foo=bar; httpOnly</span><span class="s2">\&quot;\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function serialize(name, val, options) {</span><span class="s2">\n  </span><span class="s1">const enc = options?.encode || encodeURIComponent;</span><span class="s2">\n  </span><span class="s1">if (!cookieNameRegExp.test(name)) {</span><span class="s2">\n    </span><span class="s1">throw new TypeError(`argument name is invalid: ${name}`);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">const value = enc(val);</span><span class="s2">\n  </span><span class="s1">if (!cookieValueRegExp.test(value)) {</span><span class="s2">\n    </span><span class="s1">throw new TypeError(`argument val is invalid: ${val}`);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let str = name + </span><span class="s2">\&quot;</span><span class="s1">=</span><span class="s2">\&quot; </span><span class="s1">+ value;</span><span class="s2">\n  </span><span class="s1">if (!options) return str;</span><span class="s2">\n  </span><span class="s1">if (options.maxAge !== undefined) {</span><span class="s2">\n    </span><span class="s1">if (!Number.isInteger(options.maxAge)) {</span><span class="s2">\n      </span><span class="s1">throw new TypeError(`option maxAge is invalid: ${options.maxAge}`);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">str += </span><span class="s2">\&quot;</span><span class="s1">; Max-Age=</span><span class="s2">\&quot; </span><span class="s1">+ options.maxAge;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (options.domain) {</span><span class="s2">\n    </span><span class="s1">if (!domainValueRegExp.test(options.domain)) {</span><span class="s2">\n      </span><span class="s1">throw new TypeError(`option domain is invalid: ${options.domain}`);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">str += </span><span class="s2">\&quot;</span><span class="s1">; Domain=</span><span class="s2">\&quot; </span><span class="s1">+ options.domain;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (options.path) {</span><span class="s2">\n    </span><span class="s1">if (!pathValueRegExp.test(options.path)) {</span><span class="s2">\n      </span><span class="s1">throw new TypeError(`option path is invalid: ${options.path}`);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">str += </span><span class="s2">\&quot;</span><span class="s1">; Path=</span><span class="s2">\&quot; </span><span class="s1">+ options.path;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (options.expires) {</span><span class="s2">\n    </span><span class="s1">if (!isDate(options.expires) || !Number.isFinite(options.expires.valueOf())) {</span><span class="s2">\n      </span><span class="s1">throw new TypeError(`option expires is invalid: ${options.expires}`);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">str += </span><span class="s2">\&quot;</span><span class="s1">; Expires=</span><span class="s2">\&quot; </span><span class="s1">+ options.expires.toUTCString();</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (options.httpOnly) {</span><span class="s2">\n    </span><span class="s1">str += </span><span class="s2">\&quot;</span><span class="s1">; HttpOnly</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (options.secure) {</span><span class="s2">\n    </span><span class="s1">str += </span><span class="s2">\&quot;</span><span class="s1">; Secure</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (options.partitioned) {</span><span class="s2">\n    </span><span class="s1">str += </span><span class="s2">\&quot;</span><span class="s1">; Partitioned</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (options.priority) {</span><span class="s2">\n    </span><span class="s1">const priority = typeof options.priority === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">? options.priority.toLowerCase() : undefined;</span><span class="s2">\n    </span><span class="s1">switch (priority) {</span><span class="s2">\n      </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">low</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n        </span><span class="s1">str += </span><span class="s2">\&quot;</span><span class="s1">; Priority=Low</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n        </span><span class="s1">break;</span><span class="s2">\n      </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">medium</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n        </span><span class="s1">str += </span><span class="s2">\&quot;</span><span class="s1">; Priority=Medium</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n        </span><span class="s1">break;</span><span class="s2">\n      </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">high</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n        </span><span class="s1">str += </span><span class="s2">\&quot;</span><span class="s1">; Priority=High</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n        </span><span class="s1">break;</span><span class="s2">\n      </span><span class="s1">default:</span><span class="s2">\n        </span><span class="s1">throw new TypeError(`option priority is invalid: ${options.priority}`);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (options.sameSite) {</span><span class="s2">\n    </span><span class="s1">const sameSite = typeof options.sameSite === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">? options.sameSite.toLowerCase() : options.sameSite;</span><span class="s2">\n    </span><span class="s1">switch (sameSite) {</span><span class="s2">\n      </span><span class="s1">case true:</span><span class="s2">\n      </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">strict</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n        </span><span class="s1">str += </span><span class="s2">\&quot;</span><span class="s1">; SameSite=Strict</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n        </span><span class="s1">break;</span><span class="s2">\n      </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">lax</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n        </span><span class="s1">str += </span><span class="s2">\&quot;</span><span class="s1">; SameSite=Lax</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n        </span><span class="s1">break;</span><span class="s2">\n      </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">none</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n        </span><span class="s1">str += </span><span class="s2">\&quot;</span><span class="s1">; SameSite=None</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n        </span><span class="s1">break;</span><span class="s2">\n      </span><span class="s1">default:</span><span class="s2">\n        </span><span class="s1">throw new TypeError(`option sameSite is invalid: ${options.sameSite}`);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return str;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* URL-decode string value. Optimized to skip native call when no %.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function decode(str) {</span><span class="s2">\n  </span><span class="s1">if (str.indexOf(</span><span class="s2">\&quot;</span><span class="s1">%</span><span class="s2">\&quot;</span><span class="s1">) === -1) return str;</span><span class="s2">\n  </span><span class="s1">try {</span><span class="s2">\n    </span><span class="s1">return decodeURIComponent(str);</span><span class="s2">\n  </span><span class="s1">} catch (e) {</span><span class="s2">\n    </span><span class="s1">return str;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Determine if value is a Date.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function isDate(val) {</span><span class="s2">\n  </span><span class="s1">return __toString.call(val) === </span><span class="s2">\&quot;</span><span class="s1">[object Date]</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">}&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">:{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s3">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;exports&quot;</span><span class="s0">,</span><span class="s1">&quot;parse&quot;</span><span class="s0">,</span><span class="s1">&quot;serialize&quot;</span><span class="s0">,</span><span class="s1">&quot;cookieNameRegExp&quot;</span><span class="s0">,</span><span class="s1">&quot;cookieValueRegExp&quot;</span><span class="s0">,</span><span class="s1">&quot;domainValueRegExp&quot;</span><span class="s0">,</span><span class="s1">&quot;pathValueRegExp&quot;</span><span class="s0">,</span><span class="s1">&quot;__toString&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;prototype&quot;</span><span class="s0">,</span><span class="s1">&quot;toString&quot;</span><span class="s0">,</span><span class="s1">&quot;NullObject&quot;</span><span class="s0">,</span><span class="s1">&quot;C&quot;</span><span class="s0">,</span><span class="s1">&quot;create&quot;</span><span class="s0">,</span><span class="s1">&quot;str&quot;</span><span class="s0">,</span><span class="s1">&quot;options&quot;</span><span class="s0">,</span><span class="s1">&quot;obj&quot;</span><span class="s0">,</span><span class="s1">&quot;len&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;dec&quot;</span><span class="s0">,</span><span class="s1">&quot;decode&quot;</span><span class="s0">,</span><span class="s1">&quot;index&quot;</span><span class="s0">,</span><span class="s1">&quot;eqIdx&quot;</span><span class="s0">,</span><span class="s1">&quot;indexOf&quot;</span><span class="s0">,</span><span class="s1">&quot;colonIdx&quot;</span><span class="s0">,</span><span class="s1">&quot;endIdx&quot;</span><span class="s0">,</span><span class="s1">&quot;lastIndexOf&quot;</span><span class="s0">,</span><span class="s1">&quot;keyStartIdx&quot;</span><span class="s0">,</span><span class="s1">&quot;startIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;keyEndIdx&quot;</span><span class="s0">,</span><span class="s1">&quot;endIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;valStartIdx&quot;</span><span class="s0">,</span><span class="s1">&quot;valEndIdx&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;max&quot;</span><span class="s0">,</span><span class="s1">&quot;code&quot;</span><span class="s0">,</span><span class="s1">&quot;charCodeAt&quot;</span><span class="s0">,</span><span class="s1">&quot;min&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;val&quot;</span><span class="s0">,</span><span class="s1">&quot;enc&quot;</span><span class="s0">,</span><span class="s1">&quot;encode&quot;</span><span class="s0">,</span><span class="s1">&quot;encodeURIComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;test&quot;</span><span class="s0">,</span><span class="s1">&quot;TypeError&quot;</span><span class="s0">,</span><span class="s1">&quot;maxAge&quot;</span><span class="s0">,</span><span class="s1">&quot;Number&quot;</span><span class="s0">,</span><span class="s1">&quot;isInteger&quot;</span><span class="s0">,</span><span class="s1">&quot;domain&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;expires&quot;</span><span class="s0">,</span><span class="s1">&quot;isDate&quot;</span><span class="s0">,</span><span class="s1">&quot;isFinite&quot;</span><span class="s0">,</span><span class="s1">&quot;valueOf&quot;</span><span class="s0">,</span><span class="s1">&quot;toUTCString&quot;</span><span class="s0">,</span><span class="s1">&quot;httpOnly&quot;</span><span class="s0">,</span><span class="s1">&quot;secure&quot;</span><span class="s0">,</span><span class="s1">&quot;partitioned&quot;</span><span class="s0">,</span><span class="s1">&quot;priority&quot;</span><span class="s0">,</span><span class="s1">&quot;toLowerCase&quot;</span><span class="s0">,</span><span class="s1">&quot;sameSite&quot;</span><span class="s0">,</span><span class="s1">&quot;decodeURIComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;e&quot;</span><span class="s0">,</span><span class="s1">&quot;call&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;C:</span><span class="s2">\\</span><span class="s1">School</span><span class="s2">\\</span><span class="s1">LEIM</span><span class="s2">\\</span><span class="s1">10Sem</span><span class="s2">\\</span><span class="s1">Proj_Final</span><span class="s2">\\</span><span class="s1">soundsprout_front_end</span><span class="s2">\\</span><span class="s1">node_modules</span><span class="s2">\\</span><span class="s1">react-router</span><span class="s2">\\</span><span class="s1">node_modules</span><span class="s2">\\</span><span class="s1">cookie</span><span class="s2">\\</span><span class="s1">src</span><span class="s2">\\</span><span class="s1">index.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;/**</span><span class="s2">\n </span><span class="s1">* RegExp to match cookie-name in RFC 6265 sec 4.1.1</span><span class="s2">\n </span><span class="s1">* This refers out to the obsoleted definition of token in RFC 2616 sec 2.2</span><span class="s2">\n </span><span class="s1">* which has been replaced by the token definition in RFC 7230 appendix B.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* cookie-name       = token</span><span class="s2">\n </span><span class="s1">* token             = 1*tchar</span><span class="s2">\n </span><span class="s1">* tchar             = </span><span class="s2">\&quot;</span><span class="s1">!</span><span class="s2">\&quot; </span><span class="s1">/ </span><span class="s2">\&quot;</span><span class="s1">#</span><span class="s2">\&quot; </span><span class="s1">/ </span><span class="s2">\&quot;</span><span class="s1">$</span><span class="s2">\&quot; </span><span class="s1">/ </span><span class="s2">\&quot;</span><span class="s1">%</span><span class="s2">\&quot; </span><span class="s1">/ </span><span class="s2">\&quot;</span><span class="s1">&amp;</span><span class="s2">\&quot; </span><span class="s1">/ </span><span class="s2">\&quot;</span><span class="s1">'</span><span class="s2">\&quot; </span><span class="s1">/</span><span class="s2">\n </span><span class="s1">*                     </span><span class="s2">\&quot;</span><span class="s1">*</span><span class="s2">\&quot; </span><span class="s1">/ </span><span class="s2">\&quot;</span><span class="s1">+</span><span class="s2">\&quot; </span><span class="s1">/ </span><span class="s2">\&quot;</span><span class="s1">-</span><span class="s2">\&quot; </span><span class="s1">/ </span><span class="s2">\&quot;</span><span class="s1">.</span><span class="s2">\&quot; </span><span class="s1">/ </span><span class="s2">\&quot;</span><span class="s1">^</span><span class="s2">\&quot; </span><span class="s1">/ </span><span class="s2">\&quot;</span><span class="s1">_</span><span class="s2">\&quot; </span><span class="s1">/</span><span class="s2">\n </span><span class="s1">*                     </span><span class="s2">\&quot;</span><span class="s1">`</span><span class="s2">\&quot; </span><span class="s1">/ </span><span class="s2">\&quot;</span><span class="s1">|</span><span class="s2">\&quot; </span><span class="s1">/ </span><span class="s2">\&quot;</span><span class="s1">~</span><span class="s2">\&quot; </span><span class="s1">/ DIGIT / ALPHA</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* Note: Allowing more characters - https://github.com/jshttp/cookie/issues/191</span><span class="s2">\n </span><span class="s1">* Allow same range as cookie value, except `=`, which delimits end of name.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const cookieNameRegExp = /^[</span><span class="s2">\\</span><span class="s1">u0021-</span><span class="s2">\\</span><span class="s1">u003A</span><span class="s2">\\</span><span class="s1">u003C</span><span class="s2">\\</span><span class="s1">u003E-</span><span class="s2">\\</span><span class="s1">u007E]+$/;</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* RegExp to match cookie-value in RFC 6265 sec 4.1.1</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )</span><span class="s2">\n </span><span class="s1">* cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E</span><span class="s2">\n </span><span class="s1">*                     ; US-ASCII characters excluding CTLs,</span><span class="s2">\n </span><span class="s1">*                     ; whitespace DQUOTE, comma, semicolon,</span><span class="s2">\n </span><span class="s1">*                     ; and backslash</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* Allowing more characters: https://github.com/jshttp/cookie/issues/191</span><span class="s2">\n </span><span class="s1">* Comma, backslash, and DQUOTE are not part of the parsing algorithm.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const cookieValueRegExp = /^[</span><span class="s2">\\</span><span class="s1">u0021-</span><span class="s2">\\</span><span class="s1">u003A</span><span class="s2">\\</span><span class="s1">u003C-</span><span class="s2">\\</span><span class="s1">u007E]*$/;</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* RegExp to match domain-value in RFC 6265 sec 4.1.1</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* domain-value      = &lt;subdomain&gt;</span><span class="s2">\n </span><span class="s1">*                     ; defined in [RFC1034], Section 3.5, as</span><span class="s2">\n </span><span class="s1">*                     ; enhanced by [RFC1123], Section 2.1</span><span class="s2">\n </span><span class="s1">* &lt;subdomain&gt;       = &lt;label&gt; | &lt;subdomain&gt; </span><span class="s2">\&quot;</span><span class="s1">.</span><span class="s2">\&quot; </span><span class="s1">&lt;label&gt;</span><span class="s2">\n </span><span class="s1">* &lt;label&gt;           = &lt;let-dig&gt; [ [ &lt;ldh-str&gt; ] &lt;let-dig&gt; ]</span><span class="s2">\n </span><span class="s1">*                     Labels must be 63 characters or less.</span><span class="s2">\n </span><span class="s1">*                     'let-dig' not 'letter' in the first char, per RFC1123</span><span class="s2">\n </span><span class="s1">* &lt;ldh-str&gt;         = &lt;let-dig-hyp&gt; | &lt;let-dig-hyp&gt; &lt;ldh-str&gt;</span><span class="s2">\n </span><span class="s1">* &lt;let-dig-hyp&gt;     = &lt;let-dig&gt; | </span><span class="s2">\&quot;</span><span class="s1">-</span><span class="s2">\&quot;\n </span><span class="s1">* &lt;let-dig&gt;         = &lt;letter&gt; | &lt;digit&gt;</span><span class="s2">\n </span><span class="s1">* &lt;letter&gt;          = any one of the 52 alphabetic characters A through Z in</span><span class="s2">\n </span><span class="s1">*                     upper case and a through z in lower case</span><span class="s2">\n </span><span class="s1">* &lt;digit&gt;           = any one of the ten digits 0 through 9</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* Keep support for leading dot: https://github.com/jshttp/cookie/issues/173</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* &gt; (Note that a leading %x2E (</span><span class="s2">\&quot;</span><span class="s1">.</span><span class="s2">\&quot;</span><span class="s1">), if present, is ignored even though that</span><span class="s2">\n </span><span class="s1">* character is not permitted, but a trailing %x2E (</span><span class="s2">\&quot;</span><span class="s1">.</span><span class="s2">\&quot;</span><span class="s1">), if present, will</span><span class="s2">\n </span><span class="s1">* cause the user agent to ignore the attribute.)</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const domainValueRegExp =</span><span class="s2">\n  </span><span class="s1">/^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* RegExp to match path-value in RFC 6265 sec 4.1.1</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* path-value        = &lt;any CHAR except CTLs or </span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\&quot;</span><span class="s1">&gt;</span><span class="s2">\n </span><span class="s1">* CHAR              = %x01-7F</span><span class="s2">\n </span><span class="s1">*                     ; defined in RFC 5234 appendix B.1</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const pathValueRegExp = /^[</span><span class="s2">\\</span><span class="s1">u0020-</span><span class="s2">\\</span><span class="s1">u003A</span><span class="s2">\\</span><span class="s1">u003D-</span><span class="s2">\\</span><span class="s1">u007E]*$/;</span><span class="s2">\n\n</span><span class="s1">const __toString = Object.prototype.toString;</span><span class="s2">\n\n</span><span class="s1">const NullObject = /* @__PURE__ */ (() =&gt; {</span><span class="s2">\n  </span><span class="s1">const C = function () {};</span><span class="s2">\n  </span><span class="s1">C.prototype = Object.create(null);</span><span class="s2">\n  </span><span class="s1">return C;</span><span class="s2">\n</span><span class="s1">})() as unknown as { new (): any };</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Parse options.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">export interface ParseOptions {</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* Specifies a function that will be used to decode a [cookie-value](https://datatracker.ietf.org/doc/html/rfc6265#section-4.1.1).</span><span class="s2">\n   </span><span class="s1">* Since the value of a cookie has a limited character set (and must be a simple string), this function can be used to decode</span><span class="s2">\n   </span><span class="s1">* a previously-encoded cookie value into a JavaScript string.</span><span class="s2">\n   </span><span class="s1">*</span><span class="s2">\n   </span><span class="s1">* The default function is the global `decodeURIComponent`, wrapped in a `try..catch`. If an error</span><span class="s2">\n   </span><span class="s1">* is thrown it will return the cookie's original value. If you provide your own encode/decode</span><span class="s2">\n   </span><span class="s1">* scheme you must ensure errors are appropriately handled.</span><span class="s2">\n   </span><span class="s1">*</span><span class="s2">\n   </span><span class="s1">* @default decode</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">decode?: (str: string) =&gt; string | undefined;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Parse a cookie header.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* Parse the given cookie header string into an object</span><span class="s2">\n </span><span class="s1">* The object has the various cookies as keys(names) =&gt; values</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">export function parse(</span><span class="s2">\n  </span><span class="s1">str: string,</span><span class="s2">\n  </span><span class="s1">options?: ParseOptions,</span><span class="s2">\n</span><span class="s1">): Record&lt;string, string | undefined&gt; {</span><span class="s2">\n  </span><span class="s1">const obj: Record&lt;string, string | undefined&gt; = new NullObject();</span><span class="s2">\n  </span><span class="s1">const len = str.length;</span><span class="s2">\n  </span><span class="s1">// RFC 6265 sec 4.1.1, RFC 2616 2.2 defines a cookie name consists of one char minimum, plus '='.</span><span class="s2">\n  </span><span class="s1">if (len &lt; 2) return obj;</span><span class="s2">\n\n  </span><span class="s1">const dec = options?.decode || decode;</span><span class="s2">\n  </span><span class="s1">let index = 0;</span><span class="s2">\n\n  </span><span class="s1">do {</span><span class="s2">\n    </span><span class="s1">const eqIdx = str.indexOf(</span><span class="s2">\&quot;</span><span class="s1">=</span><span class="s2">\&quot;</span><span class="s1">, index);</span><span class="s2">\n    </span><span class="s1">if (eqIdx === -1) break; // No more cookie pairs.</span><span class="s2">\n\n    </span><span class="s1">const colonIdx = str.indexOf(</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\&quot;</span><span class="s1">, index);</span><span class="s2">\n    </span><span class="s1">const endIdx = colonIdx === -1 ? len : colonIdx;</span><span class="s2">\n\n    </span><span class="s1">if (eqIdx &gt; endIdx) {</span><span class="s2">\n      </span><span class="s1">// backtrack on prior semicolon</span><span class="s2">\n      </span><span class="s1">index = str.lastIndexOf(</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\&quot;</span><span class="s1">, eqIdx - 1) + 1;</span><span class="s2">\n      </span><span class="s1">continue;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">const keyStartIdx = startIndex(str, index, eqIdx);</span><span class="s2">\n    </span><span class="s1">const keyEndIdx = endIndex(str, eqIdx, keyStartIdx);</span><span class="s2">\n    </span><span class="s1">const key = str.slice(keyStartIdx, keyEndIdx);</span><span class="s2">\n\n    </span><span class="s1">// only assign once</span><span class="s2">\n    </span><span class="s1">if (obj[key] === undefined) {</span><span class="s2">\n      </span><span class="s1">let valStartIdx = startIndex(str, eqIdx + 1, endIdx);</span><span class="s2">\n      </span><span class="s1">let valEndIdx = endIndex(str, endIdx, valStartIdx);</span><span class="s2">\n\n      </span><span class="s1">const value = dec(str.slice(valStartIdx, valEndIdx));</span><span class="s2">\n      </span><span class="s1">obj[key] = value;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">index = endIdx + 1;</span><span class="s2">\n  </span><span class="s1">} while (index &lt; len);</span><span class="s2">\n\n  </span><span class="s1">return obj;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function startIndex(str: string, index: number, max: number) {</span><span class="s2">\n  </span><span class="s1">do {</span><span class="s2">\n    </span><span class="s1">const code = str.charCodeAt(index);</span><span class="s2">\n    </span><span class="s1">if (code !== 0x20 /*   */ &amp;&amp; code !== 0x09 /* </span><span class="s2">\\</span><span class="s1">t */) return index;</span><span class="s2">\n  </span><span class="s1">} while (++index &lt; max);</span><span class="s2">\n  </span><span class="s1">return max;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function endIndex(str: string, index: number, min: number) {</span><span class="s2">\n  </span><span class="s1">while (index &gt; min) {</span><span class="s2">\n    </span><span class="s1">const code = str.charCodeAt(--index);</span><span class="s2">\n    </span><span class="s1">if (code !== 0x20 /*   */ &amp;&amp; code !== 0x09 /* </span><span class="s2">\\</span><span class="s1">t */) return index + 1;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return min;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Serialize options.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">export interface SerializeOptions {</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* Specifies a function that will be used to encode a [cookie-value](https://datatracker.ietf.org/doc/html/rfc6265#section-4.1.1).</span><span class="s2">\n   </span><span class="s1">* Since value of a cookie has a limited character set (and must be a simple string), this function can be used to encode</span><span class="s2">\n   </span><span class="s1">* a value into a string suited for a cookie's value, and should mirror `decode` when parsing.</span><span class="s2">\n   </span><span class="s1">*</span><span class="s2">\n   </span><span class="s1">* @default encodeURIComponent</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">encode?: (str: string) =&gt; string;</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* Specifies the `number` (in seconds) to be the value for the [`Max-Age` `Set-Cookie` attribute](https://tools.ietf.org/html/rfc6265#section-5.2.2).</span><span class="s2">\n   </span><span class="s1">*</span><span class="s2">\n   </span><span class="s1">* The [cookie storage model specification](https://tools.ietf.org/html/rfc6265#section-5.3) states that if both `expires` and</span><span class="s2">\n   </span><span class="s1">* `maxAge` are set, then `maxAge` takes precedence, but it is possible not all clients by obey this,</span><span class="s2">\n   </span><span class="s1">* so if both are set, they should point to the same date and time.</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">maxAge?: number;</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* Specifies the `Date` object to be the value for the [`Expires` `Set-Cookie` attribute](https://tools.ietf.org/html/rfc6265#section-5.2.1).</span><span class="s2">\n   </span><span class="s1">* When no expiration is set clients consider this a </span><span class="s2">\&quot;</span><span class="s1">non-persistent cookie</span><span class="s2">\&quot; </span><span class="s1">and delete it the current session is over.</span><span class="s2">\n   </span><span class="s1">*</span><span class="s2">\n   </span><span class="s1">* The [cookie storage model specification](https://tools.ietf.org/html/rfc6265#section-5.3) states that if both `expires` and</span><span class="s2">\n   </span><span class="s1">* `maxAge` are set, then `maxAge` takes precedence, but it is possible not all clients by obey this,</span><span class="s2">\n   </span><span class="s1">* so if both are set, they should point to the same date and time.</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">expires?: Date;</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* Specifies the value for the [`Domain` `Set-Cookie` attribute](https://tools.ietf.org/html/rfc6265#section-5.2.3).</span><span class="s2">\n   </span><span class="s1">* When no domain is set clients consider the cookie to apply to the current domain only.</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">domain?: string;</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* Specifies the value for the [`Path` `Set-Cookie` attribute](https://tools.ietf.org/html/rfc6265#section-5.2.4).</span><span class="s2">\n   </span><span class="s1">* When no path is set, the path is considered the [</span><span class="s2">\&quot;</span><span class="s1">default path</span><span class="s2">\&quot;</span><span class="s1">](https://tools.ietf.org/html/rfc6265#section-5.1.4).</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">path?: string;</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* Enables the [`HttpOnly` `Set-Cookie` attribute](https://tools.ietf.org/html/rfc6265#section-5.2.6).</span><span class="s2">\n   </span><span class="s1">* When enabled, clients will not allow client-side JavaScript to see the cookie in `document.cookie`.</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">httpOnly?: boolean;</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* Enables the [`Secure` `Set-Cookie` attribute](https://tools.ietf.org/html/rfc6265#section-5.2.5).</span><span class="s2">\n   </span><span class="s1">* When enabled, clients will only send the cookie back if the browser has a HTTPS connection.</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">secure?: boolean;</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* Enables the [`Partitioned` `Set-Cookie` attribute](https://tools.ietf.org/html/draft-cutler-httpbis-partitioned-cookies/).</span><span class="s2">\n   </span><span class="s1">* When enabled, clients will only send the cookie back when the current domain _and_ top-level domain matches.</span><span class="s2">\n   </span><span class="s1">*</span><span class="s2">\n   </span><span class="s1">* This is an attribute that has not yet been fully standardized, and may change in the future.</span><span class="s2">\n   </span><span class="s1">* This also means clients may ignore this attribute until they understand it. More information</span><span class="s2">\n   </span><span class="s1">* about can be found in [the proposal](https://github.com/privacycg/CHIPS).</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">partitioned?: boolean;</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* Specifies the value for the [`Priority` `Set-Cookie` attribute](https://tools.ietf.org/html/draft-west-cookie-priority-00#section-4.1).</span><span class="s2">\n   </span><span class="s1">*</span><span class="s2">\n   </span><span class="s1">* - `'low'` will set the `Priority` attribute to `Low`.</span><span class="s2">\n   </span><span class="s1">* - `'medium'` will set the `Priority` attribute to `Medium`, the default priority when not set.</span><span class="s2">\n   </span><span class="s1">* - `'high'` will set the `Priority` attribute to `High`.</span><span class="s2">\n   </span><span class="s1">*</span><span class="s2">\n   </span><span class="s1">* More information about priority levels can be found in [the specification](https://tools.ietf.org/html/draft-west-cookie-priority-00#section-4.1).</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">priority?: </span><span class="s2">\&quot;</span><span class="s1">low</span><span class="s2">\&quot; </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">medium</span><span class="s2">\&quot; </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">high</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* Specifies the value for the [`SameSite` `Set-Cookie` attribute](https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-09#section-5.4.7).</span><span class="s2">\n   </span><span class="s1">*</span><span class="s2">\n   </span><span class="s1">* - `true` will set the `SameSite` attribute to `Strict` for strict same site enforcement.</span><span class="s2">\n   </span><span class="s1">* - `'lax'` will set the `SameSite` attribute to `Lax` for lax same site enforcement.</span><span class="s2">\n   </span><span class="s1">* - `'none'` will set the `SameSite` attribute to `None` for an explicit cross-site cookie.</span><span class="s2">\n   </span><span class="s1">* - `'strict'` will set the `SameSite` attribute to `Strict` for strict same site enforcement.</span><span class="s2">\n   </span><span class="s1">*</span><span class="s2">\n   </span><span class="s1">* More information about enforcement levels can be found in [the specification](https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-09#section-5.4.7).</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">sameSite?: boolean | </span><span class="s2">\&quot;</span><span class="s1">lax</span><span class="s2">\&quot; </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">strict</span><span class="s2">\&quot; </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">none</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Serialize data into a cookie header.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* Serialize a name value pair into a cookie string suitable for</span><span class="s2">\n </span><span class="s1">* http headers. An optional options object specifies cookie parameters.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* serialize('foo', 'bar', { httpOnly: true })</span><span class="s2">\n </span><span class="s1">*   =&gt; </span><span class="s2">\&quot;</span><span class="s1">foo=bar; httpOnly</span><span class="s2">\&quot;\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">export function serialize(</span><span class="s2">\n  </span><span class="s1">name: string,</span><span class="s2">\n  </span><span class="s1">val: string,</span><span class="s2">\n  </span><span class="s1">options?: SerializeOptions,</span><span class="s2">\n</span><span class="s1">): string {</span><span class="s2">\n  </span><span class="s1">const enc = options?.encode || encodeURIComponent;</span><span class="s2">\n\n  </span><span class="s1">if (!cookieNameRegExp.test(name)) {</span><span class="s2">\n    </span><span class="s1">throw new TypeError(`argument name is invalid: ${name}`);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">const value = enc(val);</span><span class="s2">\n\n  </span><span class="s1">if (!cookieValueRegExp.test(value)) {</span><span class="s2">\n    </span><span class="s1">throw new TypeError(`argument val is invalid: ${val}`);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">let str = name + </span><span class="s2">\&quot;</span><span class="s1">=</span><span class="s2">\&quot; </span><span class="s1">+ value;</span><span class="s2">\n  </span><span class="s1">if (!options) return str;</span><span class="s2">\n\n  </span><span class="s1">if (options.maxAge !== undefined) {</span><span class="s2">\n    </span><span class="s1">if (!Number.isInteger(options.maxAge)) {</span><span class="s2">\n      </span><span class="s1">throw new TypeError(`option maxAge is invalid: ${options.maxAge}`);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">str += </span><span class="s2">\&quot;</span><span class="s1">; Max-Age=</span><span class="s2">\&quot; </span><span class="s1">+ options.maxAge;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">if (options.domain) {</span><span class="s2">\n    </span><span class="s1">if (!domainValueRegExp.test(options.domain)) {</span><span class="s2">\n      </span><span class="s1">throw new TypeError(`option domain is invalid: ${options.domain}`);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">str += </span><span class="s2">\&quot;</span><span class="s1">; Domain=</span><span class="s2">\&quot; </span><span class="s1">+ options.domain;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">if (options.path) {</span><span class="s2">\n    </span><span class="s1">if (!pathValueRegExp.test(options.path)) {</span><span class="s2">\n      </span><span class="s1">throw new TypeError(`option path is invalid: ${options.path}`);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">str += </span><span class="s2">\&quot;</span><span class="s1">; Path=</span><span class="s2">\&quot; </span><span class="s1">+ options.path;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">if (options.expires) {</span><span class="s2">\n    </span><span class="s1">if (</span><span class="s2">\n      </span><span class="s1">!isDate(options.expires) ||</span><span class="s2">\n      </span><span class="s1">!Number.isFinite(options.expires.valueOf())</span><span class="s2">\n    </span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">throw new TypeError(`option expires is invalid: ${options.expires}`);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">str += </span><span class="s2">\&quot;</span><span class="s1">; Expires=</span><span class="s2">\&quot; </span><span class="s1">+ options.expires.toUTCString();</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">if (options.httpOnly) {</span><span class="s2">\n    </span><span class="s1">str += </span><span class="s2">\&quot;</span><span class="s1">; HttpOnly</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">if (options.secure) {</span><span class="s2">\n    </span><span class="s1">str += </span><span class="s2">\&quot;</span><span class="s1">; Secure</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">if (options.partitioned) {</span><span class="s2">\n    </span><span class="s1">str += </span><span class="s2">\&quot;</span><span class="s1">; Partitioned</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">if (options.priority) {</span><span class="s2">\n    </span><span class="s1">const priority =</span><span class="s2">\n      </span><span class="s1">typeof options.priority === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot;\n        </span><span class="s1">? options.priority.toLowerCase()</span><span class="s2">\n        </span><span class="s1">: undefined;</span><span class="s2">\n    </span><span class="s1">switch (priority) {</span><span class="s2">\n      </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">low</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n        </span><span class="s1">str += </span><span class="s2">\&quot;</span><span class="s1">; Priority=Low</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n        </span><span class="s1">break;</span><span class="s2">\n      </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">medium</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n        </span><span class="s1">str += </span><span class="s2">\&quot;</span><span class="s1">; Priority=Medium</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n        </span><span class="s1">break;</span><span class="s2">\n      </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">high</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n        </span><span class="s1">str += </span><span class="s2">\&quot;</span><span class="s1">; Priority=High</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n        </span><span class="s1">break;</span><span class="s2">\n      </span><span class="s1">default:</span><span class="s2">\n        </span><span class="s1">throw new TypeError(`option priority is invalid: ${options.priority}`);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">if (options.sameSite) {</span><span class="s2">\n    </span><span class="s1">const sameSite =</span><span class="s2">\n      </span><span class="s1">typeof options.sameSite === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot;\n        </span><span class="s1">? options.sameSite.toLowerCase()</span><span class="s2">\n        </span><span class="s1">: options.sameSite;</span><span class="s2">\n    </span><span class="s1">switch (sameSite) {</span><span class="s2">\n      </span><span class="s1">case true:</span><span class="s2">\n      </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">strict</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n        </span><span class="s1">str += </span><span class="s2">\&quot;</span><span class="s1">; SameSite=Strict</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n        </span><span class="s1">break;</span><span class="s2">\n      </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">lax</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n        </span><span class="s1">str += </span><span class="s2">\&quot;</span><span class="s1">; SameSite=Lax</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n        </span><span class="s1">break;</span><span class="s2">\n      </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">none</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n        </span><span class="s1">str += </span><span class="s2">\&quot;</span><span class="s1">; SameSite=None</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n        </span><span class="s1">break;</span><span class="s2">\n      </span><span class="s1">default:</span><span class="s2">\n        </span><span class="s1">throw new TypeError(`option sameSite is invalid: ${options.sameSite}`);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">return str;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* URL-decode string value. Optimized to skip native call when no %.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function decode(str: string): string {</span><span class="s2">\n  </span><span class="s1">if (str.indexOf(</span><span class="s2">\&quot;</span><span class="s1">%</span><span class="s2">\&quot;</span><span class="s1">) === -1) return str;</span><span class="s2">\n\n  </span><span class="s1">try {</span><span class="s2">\n    </span><span class="s1">return decodeURIComponent(str);</span><span class="s2">\n  </span><span class="s1">} catch (e) {</span><span class="s2">\n    </span><span class="s1">return str;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Determine if value is a Date.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function isDate(val: any): val is Date {</span><span class="s2">\n  </span><span class="s1">return __toString.call(val) === </span><span class="s2">\&quot;</span><span class="s1">[object Date]</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[]},</span><span class="s1">&quot;metadata&quot;</span><span class="s0">:{},</span><span class="s1">&quot;sourceType&quot;</span><span class="s0">:</span><span class="s1">&quot;script&quot;</span><span class="s0">,</span><span class="s1">&quot;externalDependencies&quot;</span><span class="s0">:[]}</span></pre>
</body>
</html>