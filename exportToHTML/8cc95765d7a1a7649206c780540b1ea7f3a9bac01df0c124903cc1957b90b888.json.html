<html>
<head>
<title>8cc95765d7a1a7649206c780540b1ea7f3a9bac01df0c124903cc1957b90b888.json</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #cf8e6d;}
.s3 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
8cc95765d7a1a7649206c780540b1ea7f3a9bac01df0c124903cc1957b90b888.json</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;ast&quot;</span><span class="s0">:</span><span class="s2">null</span><span class="s0">,</span><span class="s1">&quot;code&quot;</span><span class="s0">:</span><span class="s1">&quot;/** @license React vundefined</span><span class="s2">\n </span><span class="s1">* react-refresh-runtime.development.js</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* Copyright (c) Facebook, Inc. and its affiliates.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* This source code is licensed under the MIT license found in the</span><span class="s2">\n </span><span class="s1">* LICENSE file in the root directory of this source tree.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n\n</span><span class="s1">'use strict';</span><span class="s2">\n\n</span><span class="s1">if (process.env.NODE_ENV !== </span><span class="s2">\&quot;</span><span class="s1">production</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n  </span><span class="s1">(function () {</span><span class="s2">\n    </span><span class="s1">'use strict';</span><span class="s2">\n\n    </span><span class="s1">// ATTENTION</span><span class="s2">\n    </span><span class="s1">// When adding new symbols to this file,</span><span class="s2">\n    </span><span class="s1">// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'</span><span class="s2">\n    </span><span class="s1">// The Symbol used to tag the ReactElement-like types. If there is no native Symbol</span><span class="s2">\n    </span><span class="s1">// nor polyfill, then a plain number is used for performance.</span><span class="s2">\n    </span><span class="s1">var REACT_ELEMENT_TYPE = 0xeac7;</span><span class="s2">\n    </span><span class="s1">var REACT_PORTAL_TYPE = 0xeaca;</span><span class="s2">\n    </span><span class="s1">var REACT_FRAGMENT_TYPE = 0xeacb;</span><span class="s2">\n    </span><span class="s1">var REACT_STRICT_MODE_TYPE = 0xeacc;</span><span class="s2">\n    </span><span class="s1">var REACT_PROFILER_TYPE = 0xead2;</span><span class="s2">\n    </span><span class="s1">var REACT_PROVIDER_TYPE = 0xeacd;</span><span class="s2">\n    </span><span class="s1">var REACT_CONTEXT_TYPE = 0xeace;</span><span class="s2">\n    </span><span class="s1">var REACT_FORWARD_REF_TYPE = 0xead0;</span><span class="s2">\n    </span><span class="s1">var REACT_SUSPENSE_TYPE = 0xead1;</span><span class="s2">\n    </span><span class="s1">var REACT_SUSPENSE_LIST_TYPE = 0xead8;</span><span class="s2">\n    </span><span class="s1">var REACT_MEMO_TYPE = 0xead3;</span><span class="s2">\n    </span><span class="s1">var REACT_LAZY_TYPE = 0xead4;</span><span class="s2">\n    </span><span class="s1">var REACT_SCOPE_TYPE = 0xead7;</span><span class="s2">\n    </span><span class="s1">var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;</span><span class="s2">\n    </span><span class="s1">var REACT_OFFSCREEN_TYPE = 0xeae2;</span><span class="s2">\n    </span><span class="s1">var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;</span><span class="s2">\n    </span><span class="s1">var REACT_CACHE_TYPE = 0xeae4;</span><span class="s2">\n    </span><span class="s1">if (typeof Symbol === 'function' &amp;&amp; Symbol.for) {</span><span class="s2">\n      </span><span class="s1">var symbolFor = Symbol.for;</span><span class="s2">\n      </span><span class="s1">REACT_ELEMENT_TYPE = symbolFor('react.element');</span><span class="s2">\n      </span><span class="s1">REACT_PORTAL_TYPE = symbolFor('react.portal');</span><span class="s2">\n      </span><span class="s1">REACT_FRAGMENT_TYPE = symbolFor('react.fragment');</span><span class="s2">\n      </span><span class="s1">REACT_STRICT_MODE_TYPE = symbolFor('react.strict_mode');</span><span class="s2">\n      </span><span class="s1">REACT_PROFILER_TYPE = symbolFor('react.profiler');</span><span class="s2">\n      </span><span class="s1">REACT_PROVIDER_TYPE = symbolFor('react.provider');</span><span class="s2">\n      </span><span class="s1">REACT_CONTEXT_TYPE = symbolFor('react.context');</span><span class="s2">\n      </span><span class="s1">REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');</span><span class="s2">\n      </span><span class="s1">REACT_SUSPENSE_TYPE = symbolFor('react.suspense');</span><span class="s2">\n      </span><span class="s1">REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');</span><span class="s2">\n      </span><span class="s1">REACT_MEMO_TYPE = symbolFor('react.memo');</span><span class="s2">\n      </span><span class="s1">REACT_LAZY_TYPE = symbolFor('react.lazy');</span><span class="s2">\n      </span><span class="s1">REACT_SCOPE_TYPE = symbolFor('react.scope');</span><span class="s2">\n      </span><span class="s1">REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');</span><span class="s2">\n      </span><span class="s1">REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');</span><span class="s2">\n      </span><span class="s1">REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');</span><span class="s2">\n      </span><span class="s1">REACT_CACHE_TYPE = symbolFor('react.cache');</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map; // We never remove these associations.</span><span class="s2">\n    </span><span class="s1">// It's OK to reference families, but use WeakMap/Set for types.</span><span class="s2">\n\n    </span><span class="s1">var allFamiliesByID = new Map();</span><span class="s2">\n    </span><span class="s1">var allFamiliesByType = new PossiblyWeakMap();</span><span class="s2">\n    </span><span class="s1">var allSignaturesByType = new PossiblyWeakMap(); // This WeakMap is read by React, so we only put families</span><span class="s2">\n    </span><span class="s1">// that have actually been edited here. This keeps checks fast.</span><span class="s2">\n    </span><span class="s1">// $FlowIssue</span><span class="s2">\n\n    </span><span class="s1">var updatedFamiliesByType = new PossiblyWeakMap(); // This is cleared on every performReactRefresh() call.</span><span class="s2">\n    </span><span class="s1">// It is an array of [Family, NextType] tuples.</span><span class="s2">\n\n    </span><span class="s1">var pendingUpdates = []; // This is injected by the renderer via DevTools global hook.</span><span class="s2">\n\n    </span><span class="s1">var helpersByRendererID = new Map();</span><span class="s2">\n    </span><span class="s1">var helpersByRoot = new Map(); // We keep track of mounted roots so we can schedule updates.</span><span class="s2">\n\n    </span><span class="s1">var mountedRoots = new Set(); // If a root captures an error, we remember it so we can retry on edit.</span><span class="s2">\n\n    </span><span class="s1">var failedRoots = new Set(); // In environments that support WeakMap, we also remember the last element for every root.</span><span class="s2">\n    </span><span class="s1">// It needs to be weak because we do this even for roots that failed to mount.</span><span class="s2">\n    </span><span class="s1">// If there is no WeakMap, we won't attempt to do retrying.</span><span class="s2">\n    </span><span class="s1">// $FlowIssue</span><span class="s2">\n\n    </span><span class="s1">var rootElements =</span><span class="s2">\n    </span><span class="s1">// $FlowIssue</span><span class="s2">\n    </span><span class="s1">typeof WeakMap === 'function' ? new WeakMap() : null;</span><span class="s2">\n    </span><span class="s1">var isPerformingRefresh = false;</span><span class="s2">\n    </span><span class="s1">function computeFullKey(signature) {</span><span class="s2">\n      </span><span class="s1">if (signature.fullKey !== null) {</span><span class="s2">\n        </span><span class="s1">return signature.fullKey;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">var fullKey = signature.ownKey;</span><span class="s2">\n      </span><span class="s1">var hooks;</span><span class="s2">\n      </span><span class="s1">try {</span><span class="s2">\n        </span><span class="s1">hooks = signature.getCustomHooks();</span><span class="s2">\n      </span><span class="s1">} catch (err) {</span><span class="s2">\n        </span><span class="s1">// This can happen in an edge case, e.g. if expression like Foo.useSomething</span><span class="s2">\n        </span><span class="s1">// depends on Foo which is lazily initialized during rendering.</span><span class="s2">\n        </span><span class="s1">// In that case just assume we'll have to remount.</span><span class="s2">\n        </span><span class="s1">signature.forceReset = true;</span><span class="s2">\n        </span><span class="s1">signature.fullKey = fullKey;</span><span class="s2">\n        </span><span class="s1">return fullKey;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">for (var i = 0; i &lt; hooks.length; i++) {</span><span class="s2">\n        </span><span class="s1">var hook = hooks[i];</span><span class="s2">\n        </span><span class="s1">if (typeof hook !== 'function') {</span><span class="s2">\n          </span><span class="s1">// Something's wrong. Assume we need to remount.</span><span class="s2">\n          </span><span class="s1">signature.forceReset = true;</span><span class="s2">\n          </span><span class="s1">signature.fullKey = fullKey;</span><span class="s2">\n          </span><span class="s1">return fullKey;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">var nestedHookSignature = allSignaturesByType.get(hook);</span><span class="s2">\n        </span><span class="s1">if (nestedHookSignature === undefined) {</span><span class="s2">\n          </span><span class="s1">// No signature means Hook wasn't in the source code, e.g. in a library.</span><span class="s2">\n          </span><span class="s1">// We'll skip it because we can assume it won't change during this session.</span><span class="s2">\n          </span><span class="s1">continue;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">var nestedHookKey = computeFullKey(nestedHookSignature);</span><span class="s2">\n        </span><span class="s1">if (nestedHookSignature.forceReset) {</span><span class="s2">\n          </span><span class="s1">signature.forceReset = true;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">fullKey += '</span><span class="s2">\\</span><span class="s1">n---</span><span class="s2">\\</span><span class="s1">n' + nestedHookKey;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">signature.fullKey = fullKey;</span><span class="s2">\n      </span><span class="s1">return fullKey;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">function haveEqualSignatures(prevType, nextType) {</span><span class="s2">\n      </span><span class="s1">var prevSignature = allSignaturesByType.get(prevType);</span><span class="s2">\n      </span><span class="s1">var nextSignature = allSignaturesByType.get(nextType);</span><span class="s2">\n      </span><span class="s1">if (prevSignature === undefined &amp;&amp; nextSignature === undefined) {</span><span class="s2">\n        </span><span class="s1">return true;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (prevSignature === undefined || nextSignature === undefined) {</span><span class="s2">\n        </span><span class="s1">return false;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (computeFullKey(prevSignature) !== computeFullKey(nextSignature)) {</span><span class="s2">\n        </span><span class="s1">return false;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (nextSignature.forceReset) {</span><span class="s2">\n        </span><span class="s1">return false;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return true;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">function isReactClass(type) {</span><span class="s2">\n      </span><span class="s1">return type.prototype &amp;&amp; type.prototype.isReactComponent;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">function canPreserveStateBetween(prevType, nextType) {</span><span class="s2">\n      </span><span class="s1">if (isReactClass(prevType) || isReactClass(nextType)) {</span><span class="s2">\n        </span><span class="s1">return false;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (haveEqualSignatures(prevType, nextType)) {</span><span class="s2">\n        </span><span class="s1">return true;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return false;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">function resolveFamily(type) {</span><span class="s2">\n      </span><span class="s1">// Only check updated types to keep lookups fast.</span><span class="s2">\n      </span><span class="s1">return updatedFamiliesByType.get(type);</span><span class="s2">\n    </span><span class="s1">} // If we didn't care about IE11, we could use new Map/Set(iterable).</span><span class="s2">\n\n    </span><span class="s1">function cloneMap(map) {</span><span class="s2">\n      </span><span class="s1">var clone = new Map();</span><span class="s2">\n      </span><span class="s1">map.forEach(function (value, key) {</span><span class="s2">\n        </span><span class="s1">clone.set(key, value);</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">return clone;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">function cloneSet(set) {</span><span class="s2">\n      </span><span class="s1">var clone = new Set();</span><span class="s2">\n      </span><span class="s1">set.forEach(function (value) {</span><span class="s2">\n        </span><span class="s1">clone.add(value);</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">return clone;</span><span class="s2">\n    </span><span class="s1">} // This is a safety mechanism to protect against rogue getters and Proxies.</span><span class="s2">\n\n    </span><span class="s1">function getProperty(object, property) {</span><span class="s2">\n      </span><span class="s1">try {</span><span class="s2">\n        </span><span class="s1">return object[property];</span><span class="s2">\n      </span><span class="s1">} catch (err) {</span><span class="s2">\n        </span><span class="s1">// Intentionally ignore.</span><span class="s2">\n        </span><span class="s1">return undefined;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">function performReactRefresh() {</span><span class="s2">\n      </span><span class="s1">if (pendingUpdates.length === 0) {</span><span class="s2">\n        </span><span class="s1">return null;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (isPerformingRefresh) {</span><span class="s2">\n        </span><span class="s1">return null;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">isPerformingRefresh = true;</span><span class="s2">\n      </span><span class="s1">try {</span><span class="s2">\n        </span><span class="s1">var staleFamilies = new Set();</span><span class="s2">\n        </span><span class="s1">var updatedFamilies = new Set();</span><span class="s2">\n        </span><span class="s1">var updates = pendingUpdates;</span><span class="s2">\n        </span><span class="s1">pendingUpdates = [];</span><span class="s2">\n        </span><span class="s1">updates.forEach(function (_ref) {</span><span class="s2">\n          </span><span class="s1">var family = _ref[0],</span><span class="s2">\n            </span><span class="s1">nextType = _ref[1];</span><span class="s2">\n          </span><span class="s1">// Now that we got a real edit, we can create associations</span><span class="s2">\n          </span><span class="s1">// that will be read by the React reconciler.</span><span class="s2">\n          </span><span class="s1">var prevType = family.current;</span><span class="s2">\n          </span><span class="s1">updatedFamiliesByType.set(prevType, family);</span><span class="s2">\n          </span><span class="s1">updatedFamiliesByType.set(nextType, family);</span><span class="s2">\n          </span><span class="s1">family.current = nextType; // Determine whether this should be a re-render or a re-mount.</span><span class="s2">\n\n          </span><span class="s1">if (canPreserveStateBetween(prevType, nextType)) {</span><span class="s2">\n            </span><span class="s1">updatedFamilies.add(family);</span><span class="s2">\n          </span><span class="s1">} else {</span><span class="s2">\n            </span><span class="s1">staleFamilies.add(family);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}); // TODO: rename these fields to something more meaningful.</span><span class="s2">\n\n        </span><span class="s1">var update = {</span><span class="s2">\n          </span><span class="s1">updatedFamilies: updatedFamilies,</span><span class="s2">\n          </span><span class="s1">// Families that will re-render preserving state</span><span class="s2">\n          </span><span class="s1">staleFamilies: staleFamilies // Families that will be remounted</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n        </span><span class="s1">helpersByRendererID.forEach(function (helpers) {</span><span class="s2">\n          </span><span class="s1">// Even if there are no roots, set the handler on first update.</span><span class="s2">\n          </span><span class="s1">// This ensures that if *new* roots are mounted, they'll use the resolve handler.</span><span class="s2">\n          </span><span class="s1">helpers.setRefreshHandler(resolveFamily);</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">var didError = false;</span><span class="s2">\n        </span><span class="s1">var firstError = null; // We snapshot maps and sets that are mutated during commits.</span><span class="s2">\n        </span><span class="s1">// If we don't do this, there is a risk they will be mutated while</span><span class="s2">\n        </span><span class="s1">// we iterate over them. For example, trying to recover a failed root</span><span class="s2">\n        </span><span class="s1">// may cause another root to be added to the failed list -- an infinite loop.</span><span class="s2">\n\n        </span><span class="s1">var failedRootsSnapshot = cloneSet(failedRoots);</span><span class="s2">\n        </span><span class="s1">var mountedRootsSnapshot = cloneSet(mountedRoots);</span><span class="s2">\n        </span><span class="s1">var helpersByRootSnapshot = cloneMap(helpersByRoot);</span><span class="s2">\n        </span><span class="s1">failedRootsSnapshot.forEach(function (root) {</span><span class="s2">\n          </span><span class="s1">var helpers = helpersByRootSnapshot.get(root);</span><span class="s2">\n          </span><span class="s1">if (helpers === undefined) {</span><span class="s2">\n            </span><span class="s1">throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">if (!failedRoots.has(root)) {// No longer failed.</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">if (rootElements === null) {</span><span class="s2">\n            </span><span class="s1">return;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">if (!rootElements.has(root)) {</span><span class="s2">\n            </span><span class="s1">return;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">var element = rootElements.get(root);</span><span class="s2">\n          </span><span class="s1">try {</span><span class="s2">\n            </span><span class="s1">helpers.scheduleRoot(root, element);</span><span class="s2">\n          </span><span class="s1">} catch (err) {</span><span class="s2">\n            </span><span class="s1">if (!didError) {</span><span class="s2">\n              </span><span class="s1">didError = true;</span><span class="s2">\n              </span><span class="s1">firstError = err;</span><span class="s2">\n            </span><span class="s1">} // Keep trying other roots.</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">mountedRootsSnapshot.forEach(function (root) {</span><span class="s2">\n          </span><span class="s1">var helpers = helpersByRootSnapshot.get(root);</span><span class="s2">\n          </span><span class="s1">if (helpers === undefined) {</span><span class="s2">\n            </span><span class="s1">throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">if (!mountedRoots.has(root)) {// No longer mounted.</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">try {</span><span class="s2">\n            </span><span class="s1">helpers.scheduleRefresh(root, update);</span><span class="s2">\n          </span><span class="s1">} catch (err) {</span><span class="s2">\n            </span><span class="s1">if (!didError) {</span><span class="s2">\n              </span><span class="s1">didError = true;</span><span class="s2">\n              </span><span class="s1">firstError = err;</span><span class="s2">\n            </span><span class="s1">} // Keep trying other roots.</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">if (didError) {</span><span class="s2">\n          </span><span class="s1">throw firstError;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return update;</span><span class="s2">\n      </span><span class="s1">} finally {</span><span class="s2">\n        </span><span class="s1">isPerformingRefresh = false;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">function register(type, id) {</span><span class="s2">\n      </span><span class="s1">{</span><span class="s2">\n        </span><span class="s1">if (type === null) {</span><span class="s2">\n          </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (typeof type !== 'function' &amp;&amp; typeof type !== 'object') {</span><span class="s2">\n          </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">} // This can happen in an edge case, e.g. if we register</span><span class="s2">\n        </span><span class="s1">// return value of a HOC but it returns a cached component.</span><span class="s2">\n        </span><span class="s1">// Ignore anything but the first registration for each type.</span><span class="s2">\n\n        </span><span class="s1">if (allFamiliesByType.has(type)) {</span><span class="s2">\n          </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">} // Create family or remember to update it.</span><span class="s2">\n        </span><span class="s1">// None of this bookkeeping affects reconciliation</span><span class="s2">\n        </span><span class="s1">// until the first performReactRefresh() call above.</span><span class="s2">\n\n        </span><span class="s1">var family = allFamiliesByID.get(id);</span><span class="s2">\n        </span><span class="s1">if (family === undefined) {</span><span class="s2">\n          </span><span class="s1">family = {</span><span class="s2">\n            </span><span class="s1">current: type</span><span class="s2">\n          </span><span class="s1">};</span><span class="s2">\n          </span><span class="s1">allFamiliesByID.set(id, family);</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">pendingUpdates.push([family, type]);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">allFamiliesByType.set(type, family); // Visit inner types because we might not have registered them.</span><span class="s2">\n\n        </span><span class="s1">if (typeof type === 'object' &amp;&amp; type !== null) {</span><span class="s2">\n          </span><span class="s1">switch (getProperty(type, '$$typeof')) {</span><span class="s2">\n            </span><span class="s1">case REACT_FORWARD_REF_TYPE:</span><span class="s2">\n              </span><span class="s1">register(type.render, id + '$render');</span><span class="s2">\n              </span><span class="s1">break;</span><span class="s2">\n            </span><span class="s1">case REACT_MEMO_TYPE:</span><span class="s2">\n              </span><span class="s1">register(type.type, id + '$type');</span><span class="s2">\n              </span><span class="s1">break;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">function setSignature(type, key) {</span><span class="s2">\n      </span><span class="s1">var forceReset = arguments.length &gt; 2 &amp;&amp; arguments[2] !== undefined ? arguments[2] : false;</span><span class="s2">\n      </span><span class="s1">var getCustomHooks = arguments.length &gt; 3 ? arguments[3] : undefined;</span><span class="s2">\n      </span><span class="s1">{</span><span class="s2">\n        </span><span class="s1">if (!allSignaturesByType.has(type)) {</span><span class="s2">\n          </span><span class="s1">allSignaturesByType.set(type, {</span><span class="s2">\n            </span><span class="s1">forceReset: forceReset,</span><span class="s2">\n            </span><span class="s1">ownKey: key,</span><span class="s2">\n            </span><span class="s1">fullKey: null,</span><span class="s2">\n            </span><span class="s1">getCustomHooks: getCustomHooks || function () {</span><span class="s2">\n              </span><span class="s1">return [];</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">} // Visit inner types because we might not have signed them.</span><span class="s2">\n\n        </span><span class="s1">if (typeof type === 'object' &amp;&amp; type !== null) {</span><span class="s2">\n          </span><span class="s1">switch (getProperty(type, '$$typeof')) {</span><span class="s2">\n            </span><span class="s1">case REACT_FORWARD_REF_TYPE:</span><span class="s2">\n              </span><span class="s1">setSignature(type.render, key, forceReset, getCustomHooks);</span><span class="s2">\n              </span><span class="s1">break;</span><span class="s2">\n            </span><span class="s1">case REACT_MEMO_TYPE:</span><span class="s2">\n              </span><span class="s1">setSignature(type.type, key, forceReset, getCustomHooks);</span><span class="s2">\n              </span><span class="s1">break;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} // This is lazily called during first render for a type.</span><span class="s2">\n    </span><span class="s1">// It captures Hook list at that time so inline requires don't break comparisons.</span><span class="s2">\n\n    </span><span class="s1">function collectCustomHooksForSignature(type) {</span><span class="s2">\n      </span><span class="s1">{</span><span class="s2">\n        </span><span class="s1">var signature = allSignaturesByType.get(type);</span><span class="s2">\n        </span><span class="s1">if (signature !== undefined) {</span><span class="s2">\n          </span><span class="s1">computeFullKey(signature);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">function getFamilyByID(id) {</span><span class="s2">\n      </span><span class="s1">{</span><span class="s2">\n        </span><span class="s1">return allFamiliesByID.get(id);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">function getFamilyByType(type) {</span><span class="s2">\n      </span><span class="s1">{</span><span class="s2">\n        </span><span class="s1">return allFamiliesByType.get(type);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">function findAffectedHostInstances(families) {</span><span class="s2">\n      </span><span class="s1">{</span><span class="s2">\n        </span><span class="s1">var affectedInstances = new Set();</span><span class="s2">\n        </span><span class="s1">mountedRoots.forEach(function (root) {</span><span class="s2">\n          </span><span class="s1">var helpers = helpersByRoot.get(root);</span><span class="s2">\n          </span><span class="s1">if (helpers === undefined) {</span><span class="s2">\n            </span><span class="s1">throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">var instancesForRoot = helpers.findHostInstancesForRefresh(root, families);</span><span class="s2">\n          </span><span class="s1">instancesForRoot.forEach(function (inst) {</span><span class="s2">\n            </span><span class="s1">affectedInstances.add(inst);</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">return affectedInstances;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">function injectIntoGlobalHook(globalObject) {</span><span class="s2">\n      </span><span class="s1">{</span><span class="s2">\n        </span><span class="s1">// For React Native, the global hook will be set up by require('react-devtools-core').</span><span class="s2">\n        </span><span class="s1">// That code will run before us. So we need to monkeypatch functions on existing hook.</span><span class="s2">\n        </span><span class="s1">// For React Web, the global hook will be set up by the extension.</span><span class="s2">\n        </span><span class="s1">// This will also run before us.</span><span class="s2">\n        </span><span class="s1">var hook = globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__;</span><span class="s2">\n        </span><span class="s1">if (hook === undefined) {</span><span class="s2">\n          </span><span class="s1">// However, if there is no DevTools extension, we'll need to set up the global hook ourselves.</span><span class="s2">\n          </span><span class="s1">// Note that in this case it's important that renderer code runs *after* this method call.</span><span class="s2">\n          </span><span class="s1">// Otherwise, the renderer will think that there is no global hook, and won't do the injection.</span><span class="s2">\n          </span><span class="s1">var nextID = 0;</span><span class="s2">\n          </span><span class="s1">globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__ = hook = {</span><span class="s2">\n            </span><span class="s1">renderers: new Map(),</span><span class="s2">\n            </span><span class="s1">supportsFiber: true,</span><span class="s2">\n            </span><span class="s1">inject: function (injected) {</span><span class="s2">\n              </span><span class="s1">return nextID++;</span><span class="s2">\n            </span><span class="s1">},</span><span class="s2">\n            </span><span class="s1">onScheduleFiberRoot: function (id, root, children) {},</span><span class="s2">\n            </span><span class="s1">onCommitFiberRoot: function (id, root, maybePriorityLevel, didError) {},</span><span class="s2">\n            </span><span class="s1">onCommitFiberUnmount: function () {}</span><span class="s2">\n          </span><span class="s1">};</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (hook.isDisabled) {</span><span class="s2">\n          </span><span class="s1">// This isn't a real property on the hook, but it can be set to opt out</span><span class="s2">\n          </span><span class="s1">// of DevTools integration and associated warnings and logs.</span><span class="s2">\n          </span><span class="s1">// Using console['warn'] to evade Babel and ESLint</span><span class="s2">\n          </span><span class="s1">console['warn']('Something has shimmed the React DevTools global hook (__REACT_DEVTOOLS_GLOBAL_HOOK__). ' + 'Fast Refresh is not compatible with this shim and will be disabled.');</span><span class="s2">\n          </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">} // Here, we just want to get a reference to scheduleRefresh.</span><span class="s2">\n\n        </span><span class="s1">var oldInject = hook.inject;</span><span class="s2">\n        </span><span class="s1">hook.inject = function (injected) {</span><span class="s2">\n          </span><span class="s1">var id = oldInject.apply(this, arguments);</span><span class="s2">\n          </span><span class="s1">if (typeof injected.scheduleRefresh === 'function' &amp;&amp; typeof injected.setRefreshHandler === 'function') {</span><span class="s2">\n            </span><span class="s1">// This version supports React Refresh.</span><span class="s2">\n            </span><span class="s1">helpersByRendererID.set(id, injected);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">return id;</span><span class="s2">\n        </span><span class="s1">}; // Do the same for any already injected roots.</span><span class="s2">\n        </span><span class="s1">// This is useful if ReactDOM has already been initialized.</span><span class="s2">\n        </span><span class="s1">// https://github.com/facebook/react/issues/17626</span><span class="s2">\n\n        </span><span class="s1">hook.renderers.forEach(function (injected, id) {</span><span class="s2">\n          </span><span class="s1">if (typeof injected.scheduleRefresh === 'function' &amp;&amp; typeof injected.setRefreshHandler === 'function') {</span><span class="s2">\n            </span><span class="s1">// This version supports React Refresh.</span><span class="s2">\n            </span><span class="s1">helpersByRendererID.set(id, injected);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}); // We also want to track currently mounted roots.</span><span class="s2">\n\n        </span><span class="s1">var oldOnCommitFiberRoot = hook.onCommitFiberRoot;</span><span class="s2">\n        </span><span class="s1">var oldOnScheduleFiberRoot = hook.onScheduleFiberRoot || function () {};</span><span class="s2">\n        </span><span class="s1">hook.onScheduleFiberRoot = function (id, root, children) {</span><span class="s2">\n          </span><span class="s1">if (!isPerformingRefresh) {</span><span class="s2">\n            </span><span class="s1">// If it was intentionally scheduled, don't attempt to restore.</span><span class="s2">\n            </span><span class="s1">// This includes intentionally scheduled unmounts.</span><span class="s2">\n            </span><span class="s1">failedRoots.delete(root);</span><span class="s2">\n            </span><span class="s1">if (rootElements !== null) {</span><span class="s2">\n              </span><span class="s1">rootElements.set(root, children);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">return oldOnScheduleFiberRoot.apply(this, arguments);</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n        </span><span class="s1">hook.onCommitFiberRoot = function (id, root, maybePriorityLevel, didError) {</span><span class="s2">\n          </span><span class="s1">var helpers = helpersByRendererID.get(id);</span><span class="s2">\n          </span><span class="s1">if (helpers !== undefined) {</span><span class="s2">\n            </span><span class="s1">helpersByRoot.set(root, helpers);</span><span class="s2">\n            </span><span class="s1">var current = root.current;</span><span class="s2">\n            </span><span class="s1">var alternate = current.alternate; // We need to determine whether this root has just (un)mounted.</span><span class="s2">\n            </span><span class="s1">// This logic is copy-pasted from similar logic in the DevTools backend.</span><span class="s2">\n            </span><span class="s1">// If this breaks with some refactoring, you'll want to update DevTools too.</span><span class="s2">\n\n            </span><span class="s1">if (alternate !== null) {</span><span class="s2">\n              </span><span class="s1">var wasMounted = alternate.memoizedState != null &amp;&amp; alternate.memoizedState.element != null;</span><span class="s2">\n              </span><span class="s1">var isMounted = current.memoizedState != null &amp;&amp; current.memoizedState.element != null;</span><span class="s2">\n              </span><span class="s1">if (!wasMounted &amp;&amp; isMounted) {</span><span class="s2">\n                </span><span class="s1">// Mount a new root.</span><span class="s2">\n                </span><span class="s1">mountedRoots.add(root);</span><span class="s2">\n                </span><span class="s1">failedRoots.delete(root);</span><span class="s2">\n              </span><span class="s1">} else if (wasMounted &amp;&amp; isMounted) ;else if (wasMounted &amp;&amp; !isMounted) {</span><span class="s2">\n                </span><span class="s1">// Unmount an existing root.</span><span class="s2">\n                </span><span class="s1">mountedRoots.delete(root);</span><span class="s2">\n                </span><span class="s1">if (didError) {</span><span class="s2">\n                  </span><span class="s1">// We'll remount it on future edits.</span><span class="s2">\n                  </span><span class="s1">failedRoots.add(root);</span><span class="s2">\n                </span><span class="s1">} else {</span><span class="s2">\n                  </span><span class="s1">helpersByRoot.delete(root);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n              </span><span class="s1">} else if (!wasMounted &amp;&amp; !isMounted) {</span><span class="s2">\n                </span><span class="s1">if (didError) {</span><span class="s2">\n                  </span><span class="s1">// We'll remount it on future edits.</span><span class="s2">\n                  </span><span class="s1">failedRoots.add(root);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n              </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">} else {</span><span class="s2">\n              </span><span class="s1">// Mount a new root.</span><span class="s2">\n              </span><span class="s1">mountedRoots.add(root);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">} // Always call the decorated DevTools hook.</span><span class="s2">\n\n          </span><span class="s1">return oldOnCommitFiberRoot.apply(this, arguments);</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">function hasUnrecoverableErrors() {</span><span class="s2">\n      </span><span class="s1">// TODO: delete this after removing dependency in RN.</span><span class="s2">\n      </span><span class="s1">return false;</span><span class="s2">\n    </span><span class="s1">} // Exposed for testing.</span><span class="s2">\n\n    </span><span class="s1">function _getMountedRootCount() {</span><span class="s2">\n      </span><span class="s1">{</span><span class="s2">\n        </span><span class="s1">return mountedRoots.size;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} // This is a wrapper over more primitive functions for setting signature.</span><span class="s2">\n    </span><span class="s1">// Signatures let us decide whether the Hook order has changed on refresh.</span><span class="s2">\n    </span><span class="s1">//</span><span class="s2">\n    </span><span class="s1">// This function is intended to be used as a transform target, e.g.:</span><span class="s2">\n    </span><span class="s1">// var _s = createSignatureFunctionForTransform()</span><span class="s2">\n    </span><span class="s1">//</span><span class="s2">\n    </span><span class="s1">// function Hello() {</span><span class="s2">\n    </span><span class="s1">//   const [foo, setFoo] = useState(0);</span><span class="s2">\n    </span><span class="s1">//   const value = useCustomHook();</span><span class="s2">\n    </span><span class="s1">//   _s(); /* Call without arguments triggers collecting the custom Hook list.</span><span class="s2">\n    </span><span class="s1">//          * This doesn't happen during the module evaluation because we</span><span class="s2">\n    </span><span class="s1">//          * don't want to change the module order with inline requires.</span><span class="s2">\n    </span><span class="s1">//          * Next calls are noops. */</span><span class="s2">\n    </span><span class="s1">//   return &lt;h1&gt;Hi&lt;/h1&gt;;</span><span class="s2">\n    </span><span class="s1">// }</span><span class="s2">\n    </span><span class="s1">//</span><span class="s2">\n    </span><span class="s1">// /* Call with arguments attaches the signature to the type: */</span><span class="s2">\n    </span><span class="s1">// _s(</span><span class="s2">\n    </span><span class="s1">//   Hello,</span><span class="s2">\n    </span><span class="s1">//   'useState{[foo, setFoo]}(0)',</span><span class="s2">\n    </span><span class="s1">//   () =&gt; [useCustomHook], /* Lazy to avoid triggering inline requires */</span><span class="s2">\n    </span><span class="s1">// );</span><span class="s2">\n\n    </span><span class="s1">function createSignatureFunctionForTransform() {</span><span class="s2">\n      </span><span class="s1">{</span><span class="s2">\n        </span><span class="s1">var savedType;</span><span class="s2">\n        </span><span class="s1">var hasCustomHooks;</span><span class="s2">\n        </span><span class="s1">var didCollectHooks = false;</span><span class="s2">\n        </span><span class="s1">return function (type, key, forceReset, getCustomHooks) {</span><span class="s2">\n          </span><span class="s1">if (typeof key === 'string') {</span><span class="s2">\n            </span><span class="s1">// We're in the initial phase that associates signatures</span><span class="s2">\n            </span><span class="s1">// with the functions. Note this may be called multiple times</span><span class="s2">\n            </span><span class="s1">// in HOC chains like _s(hoc1(_s(hoc2(_s(actualFunction))))).</span><span class="s2">\n            </span><span class="s1">if (!savedType) {</span><span class="s2">\n              </span><span class="s1">// We're in the innermost call, so this is the actual type.</span><span class="s2">\n              </span><span class="s1">savedType = type;</span><span class="s2">\n              </span><span class="s1">hasCustomHooks = typeof getCustomHooks === 'function';</span><span class="s2">\n            </span><span class="s1">} // Set the signature for all types (even wrappers!) in case</span><span class="s2">\n            </span><span class="s1">// they have no signatures of their own. This is to prevent</span><span class="s2">\n            </span><span class="s1">// problems like https://github.com/facebook/react/issues/20417.</span><span class="s2">\n\n            </span><span class="s1">if (type != null &amp;&amp; (typeof type === 'function' || typeof type === 'object')) {</span><span class="s2">\n              </span><span class="s1">setSignature(type, key, forceReset, getCustomHooks);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">return type;</span><span class="s2">\n          </span><span class="s1">} else {</span><span class="s2">\n            </span><span class="s1">// We're in the _s() call without arguments, which means</span><span class="s2">\n            </span><span class="s1">// this is the time to collect custom Hook signatures.</span><span class="s2">\n            </span><span class="s1">// Only do this once. This path is hot and runs *inside* every render!</span><span class="s2">\n            </span><span class="s1">if (!didCollectHooks &amp;&amp; hasCustomHooks) {</span><span class="s2">\n              </span><span class="s1">didCollectHooks = true;</span><span class="s2">\n              </span><span class="s1">collectCustomHooksForSignature(savedType);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">function isLikelyComponentType(type) {</span><span class="s2">\n      </span><span class="s1">{</span><span class="s2">\n        </span><span class="s1">switch (typeof type) {</span><span class="s2">\n          </span><span class="s1">case 'function':</span><span class="s2">\n            </span><span class="s1">{</span><span class="s2">\n              </span><span class="s1">// First, deal with classes.</span><span class="s2">\n              </span><span class="s1">if (type.prototype != null) {</span><span class="s2">\n                </span><span class="s1">if (type.prototype.isReactComponent) {</span><span class="s2">\n                  </span><span class="s1">// React class.</span><span class="s2">\n                  </span><span class="s1">return true;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">var ownNames = Object.getOwnPropertyNames(type.prototype);</span><span class="s2">\n                </span><span class="s1">if (ownNames.length &gt; 1 || ownNames[0] !== 'constructor') {</span><span class="s2">\n                  </span><span class="s1">// This looks like a class.</span><span class="s2">\n                  </span><span class="s1">return false;</span><span class="s2">\n                </span><span class="s1">} // eslint-disable-next-line no-proto</span><span class="s2">\n\n                </span><span class="s1">if (type.prototype.__proto__ !== Object.prototype) {</span><span class="s2">\n                  </span><span class="s1">// It has a superclass.</span><span class="s2">\n                  </span><span class="s1">return false;</span><span class="s2">\n                </span><span class="s1">} // Pass through.</span><span class="s2">\n                </span><span class="s1">// This looks like a regular function with empty prototype.</span><span class="s2">\n              </span><span class="s1">} // For plain functions and arrows, use name as a heuristic.</span><span class="s2">\n\n              </span><span class="s1">var name = type.name || type.displayName;</span><span class="s2">\n              </span><span class="s1">return typeof name === 'string' &amp;&amp; /^[A-Z]/.test(name);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">case 'object':</span><span class="s2">\n            </span><span class="s1">{</span><span class="s2">\n              </span><span class="s1">if (type != null) {</span><span class="s2">\n                </span><span class="s1">switch (getProperty(type, '$$typeof')) {</span><span class="s2">\n                  </span><span class="s1">case REACT_FORWARD_REF_TYPE:</span><span class="s2">\n                  </span><span class="s1">case REACT_MEMO_TYPE:</span><span class="s2">\n                    </span><span class="s1">// Definitely React components.</span><span class="s2">\n                    </span><span class="s1">return true;</span><span class="s2">\n                  </span><span class="s1">default:</span><span class="s2">\n                    </span><span class="s1">return false;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n              </span><span class="s1">}</span><span class="s2">\n              </span><span class="s1">return false;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">default:</span><span class="s2">\n            </span><span class="s1">{</span><span class="s2">\n              </span><span class="s1">return false;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">exports._getMountedRootCount = _getMountedRootCount;</span><span class="s2">\n    </span><span class="s1">exports.collectCustomHooksForSignature = collectCustomHooksForSignature;</span><span class="s2">\n    </span><span class="s1">exports.createSignatureFunctionForTransform = createSignatureFunctionForTransform;</span><span class="s2">\n    </span><span class="s1">exports.findAffectedHostInstances = findAffectedHostInstances;</span><span class="s2">\n    </span><span class="s1">exports.getFamilyByID = getFamilyByID;</span><span class="s2">\n    </span><span class="s1">exports.getFamilyByType = getFamilyByType;</span><span class="s2">\n    </span><span class="s1">exports.hasUnrecoverableErrors = hasUnrecoverableErrors;</span><span class="s2">\n    </span><span class="s1">exports.injectIntoGlobalHook = injectIntoGlobalHook;</span><span class="s2">\n    </span><span class="s1">exports.isLikelyComponentType = isLikelyComponentType;</span><span class="s2">\n    </span><span class="s1">exports.performReactRefresh = performReactRefresh;</span><span class="s2">\n    </span><span class="s1">exports.register = register;</span><span class="s2">\n    </span><span class="s1">exports.setSignature = setSignature;</span><span class="s2">\n  </span><span class="s1">})();</span><span class="s2">\n</span><span class="s1">}&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">:{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s3">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;NODE_ENV&quot;</span><span class="s0">,</span><span class="s1">&quot;REACT_ELEMENT_TYPE&quot;</span><span class="s0">,</span><span class="s1">&quot;REACT_PORTAL_TYPE&quot;</span><span class="s0">,</span><span class="s1">&quot;REACT_FRAGMENT_TYPE&quot;</span><span class="s0">,</span><span class="s1">&quot;REACT_STRICT_MODE_TYPE&quot;</span><span class="s0">,</span><span class="s1">&quot;REACT_PROFILER_TYPE&quot;</span><span class="s0">,</span><span class="s1">&quot;REACT_PROVIDER_TYPE&quot;</span><span class="s0">,</span><span class="s1">&quot;REACT_CONTEXT_TYPE&quot;</span><span class="s0">,</span><span class="s1">&quot;REACT_FORWARD_REF_TYPE&quot;</span><span class="s0">,</span><span class="s1">&quot;REACT_SUSPENSE_TYPE&quot;</span><span class="s0">,</span><span class="s1">&quot;REACT_SUSPENSE_LIST_TYPE&quot;</span><span class="s0">,</span><span class="s1">&quot;REACT_MEMO_TYPE&quot;</span><span class="s0">,</span><span class="s1">&quot;REACT_LAZY_TYPE&quot;</span><span class="s0">,</span><span class="s1">&quot;REACT_SCOPE_TYPE&quot;</span><span class="s0">,</span><span class="s1">&quot;REACT_DEBUG_TRACING_MODE_TYPE&quot;</span><span class="s0">,</span><span class="s1">&quot;REACT_OFFSCREEN_TYPE&quot;</span><span class="s0">,</span><span class="s1">&quot;REACT_LEGACY_HIDDEN_TYPE&quot;</span><span class="s0">,</span><span class="s1">&quot;REACT_CACHE_TYPE&quot;</span><span class="s0">,</span><span class="s1">&quot;Symbol&quot;</span><span class="s0">,</span><span class="s1">&quot;for&quot;</span><span class="s0">,</span><span class="s1">&quot;symbolFor&quot;</span><span class="s0">,</span><span class="s1">&quot;PossiblyWeakMap&quot;</span><span class="s0">,</span><span class="s1">&quot;WeakMap&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;allFamiliesByID&quot;</span><span class="s0">,</span><span class="s1">&quot;allFamiliesByType&quot;</span><span class="s0">,</span><span class="s1">&quot;allSignaturesByType&quot;</span><span class="s0">,</span><span class="s1">&quot;updatedFamiliesByType&quot;</span><span class="s0">,</span><span class="s1">&quot;pendingUpdates&quot;</span><span class="s0">,</span><span class="s1">&quot;helpersByRendererID&quot;</span><span class="s0">,</span><span class="s1">&quot;helpersByRoot&quot;</span><span class="s0">,</span><span class="s1">&quot;mountedRoots&quot;</span><span class="s0">,</span><span class="s1">&quot;Set&quot;</span><span class="s0">,</span><span class="s1">&quot;failedRoots&quot;</span><span class="s0">,</span><span class="s1">&quot;rootElements&quot;</span><span class="s0">,</span><span class="s1">&quot;isPerformingRefresh&quot;</span><span class="s0">,</span><span class="s1">&quot;computeFullKey&quot;</span><span class="s0">,</span><span class="s1">&quot;signature&quot;</span><span class="s0">,</span><span class="s1">&quot;fullKey&quot;</span><span class="s0">,</span><span class="s1">&quot;ownKey&quot;</span><span class="s0">,</span><span class="s1">&quot;hooks&quot;</span><span class="s0">,</span><span class="s1">&quot;getCustomHooks&quot;</span><span class="s0">,</span><span class="s1">&quot;err&quot;</span><span class="s0">,</span><span class="s1">&quot;forceReset&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;hook&quot;</span><span class="s0">,</span><span class="s1">&quot;nestedHookSignature&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;nestedHookKey&quot;</span><span class="s0">,</span><span class="s1">&quot;haveEqualSignatures&quot;</span><span class="s0">,</span><span class="s1">&quot;prevType&quot;</span><span class="s0">,</span><span class="s1">&quot;nextType&quot;</span><span class="s0">,</span><span class="s1">&quot;prevSignature&quot;</span><span class="s0">,</span><span class="s1">&quot;nextSignature&quot;</span><span class="s0">,</span><span class="s1">&quot;isReactClass&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;prototype&quot;</span><span class="s0">,</span><span class="s1">&quot;isReactComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;canPreserveStateBetween&quot;</span><span class="s0">,</span><span class="s1">&quot;resolveFamily&quot;</span><span class="s0">,</span><span class="s1">&quot;cloneMap&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;clone&quot;</span><span class="s0">,</span><span class="s1">&quot;forEach&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;cloneSet&quot;</span><span class="s0">,</span><span class="s1">&quot;add&quot;</span><span class="s0">,</span><span class="s1">&quot;getProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;object&quot;</span><span class="s0">,</span><span class="s1">&quot;property&quot;</span><span class="s0">,</span><span class="s1">&quot;performReactRefresh&quot;</span><span class="s0">,</span><span class="s1">&quot;staleFamilies&quot;</span><span class="s0">,</span><span class="s1">&quot;updatedFamilies&quot;</span><span class="s0">,</span><span class="s1">&quot;updates&quot;</span><span class="s0">,</span><span class="s1">&quot;_ref&quot;</span><span class="s0">,</span><span class="s1">&quot;family&quot;</span><span class="s0">,</span><span class="s1">&quot;current&quot;</span><span class="s0">,</span><span class="s1">&quot;update&quot;</span><span class="s0">,</span><span class="s1">&quot;helpers&quot;</span><span class="s0">,</span><span class="s1">&quot;setRefreshHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;didError&quot;</span><span class="s0">,</span><span class="s1">&quot;firstError&quot;</span><span class="s0">,</span><span class="s1">&quot;failedRootsSnapshot&quot;</span><span class="s0">,</span><span class="s1">&quot;mountedRootsSnapshot&quot;</span><span class="s0">,</span><span class="s1">&quot;helpersByRootSnapshot&quot;</span><span class="s0">,</span><span class="s1">&quot;root&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;has&quot;</span><span class="s0">,</span><span class="s1">&quot;element&quot;</span><span class="s0">,</span><span class="s1">&quot;scheduleRoot&quot;</span><span class="s0">,</span><span class="s1">&quot;scheduleRefresh&quot;</span><span class="s0">,</span><span class="s1">&quot;register&quot;</span><span class="s0">,</span><span class="s1">&quot;id&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;render&quot;</span><span class="s0">,</span><span class="s1">&quot;setSignature&quot;</span><span class="s0">,</span><span class="s1">&quot;arguments&quot;</span><span class="s0">,</span><span class="s1">&quot;collectCustomHooksForSignature&quot;</span><span class="s0">,</span><span class="s1">&quot;getFamilyByID&quot;</span><span class="s0">,</span><span class="s1">&quot;getFamilyByType&quot;</span><span class="s0">,</span><span class="s1">&quot;findAffectedHostInstances&quot;</span><span class="s0">,</span><span class="s1">&quot;families&quot;</span><span class="s0">,</span><span class="s1">&quot;affectedInstances&quot;</span><span class="s0">,</span><span class="s1">&quot;instancesForRoot&quot;</span><span class="s0">,</span><span class="s1">&quot;findHostInstancesForRefresh&quot;</span><span class="s0">,</span><span class="s1">&quot;inst&quot;</span><span class="s0">,</span><span class="s1">&quot;injectIntoGlobalHook&quot;</span><span class="s0">,</span><span class="s1">&quot;globalObject&quot;</span><span class="s0">,</span><span class="s1">&quot;__REACT_DEVTOOLS_GLOBAL_HOOK__&quot;</span><span class="s0">,</span><span class="s1">&quot;nextID&quot;</span><span class="s0">,</span><span class="s1">&quot;renderers&quot;</span><span class="s0">,</span><span class="s1">&quot;supportsFiber&quot;</span><span class="s0">,</span><span class="s1">&quot;inject&quot;</span><span class="s0">,</span><span class="s1">&quot;injected&quot;</span><span class="s0">,</span><span class="s1">&quot;onScheduleFiberRoot&quot;</span><span class="s0">,</span><span class="s1">&quot;children&quot;</span><span class="s0">,</span><span class="s1">&quot;onCommitFiberRoot&quot;</span><span class="s0">,</span><span class="s1">&quot;maybePriorityLevel&quot;</span><span class="s0">,</span><span class="s1">&quot;onCommitFiberUnmount&quot;</span><span class="s0">,</span><span class="s1">&quot;isDisabled&quot;</span><span class="s0">,</span><span class="s1">&quot;console&quot;</span><span class="s0">,</span><span class="s1">&quot;oldInject&quot;</span><span class="s0">,</span><span class="s1">&quot;apply&quot;</span><span class="s0">,</span><span class="s1">&quot;oldOnCommitFiberRoot&quot;</span><span class="s0">,</span><span class="s1">&quot;oldOnScheduleFiberRoot&quot;</span><span class="s0">,</span><span class="s1">&quot;delete&quot;</span><span class="s0">,</span><span class="s1">&quot;alternate&quot;</span><span class="s0">,</span><span class="s1">&quot;wasMounted&quot;</span><span class="s0">,</span><span class="s1">&quot;memoizedState&quot;</span><span class="s0">,</span><span class="s1">&quot;isMounted&quot;</span><span class="s0">,</span><span class="s1">&quot;hasUnrecoverableErrors&quot;</span><span class="s0">,</span><span class="s1">&quot;_getMountedRootCount&quot;</span><span class="s0">,</span><span class="s1">&quot;size&quot;</span><span class="s0">,</span><span class="s1">&quot;createSignatureFunctionForTransform&quot;</span><span class="s0">,</span><span class="s1">&quot;savedType&quot;</span><span class="s0">,</span><span class="s1">&quot;hasCustomHooks&quot;</span><span class="s0">,</span><span class="s1">&quot;didCollectHooks&quot;</span><span class="s0">,</span><span class="s1">&quot;isLikelyComponentType&quot;</span><span class="s0">,</span><span class="s1">&quot;ownNames&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;getOwnPropertyNames&quot;</span><span class="s0">,</span><span class="s1">&quot;__proto__&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;displayName&quot;</span><span class="s0">,</span><span class="s1">&quot;test&quot;</span><span class="s0">,</span><span class="s1">&quot;exports&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;C:/School/LEIM/10Sem/Proj_Final/soundsprout_front_end/node_modules/react-refresh/cjs/react-refresh-runtime.development.js&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;/** @license React vundefined</span><span class="s2">\n </span><span class="s1">* react-refresh-runtime.development.js</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* Copyright (c) Facebook, Inc. and its affiliates.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* This source code is licensed under the MIT license found in the</span><span class="s2">\n </span><span class="s1">* LICENSE file in the root directory of this source tree.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n\n</span><span class="s1">'use strict';</span><span class="s2">\n\n</span><span class="s1">if (process.env.NODE_ENV !== </span><span class="s2">\&quot;</span><span class="s1">production</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n  </span><span class="s1">(function() {</span><span class="s2">\n</span><span class="s1">'use strict';</span><span class="s2">\n\n</span><span class="s1">// ATTENTION</span><span class="s2">\n</span><span class="s1">// When adding new symbols to this file,</span><span class="s2">\n</span><span class="s1">// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'</span><span class="s2">\n</span><span class="s1">// The Symbol used to tag the ReactElement-like types. If there is no native Symbol</span><span class="s2">\n</span><span class="s1">// nor polyfill, then a plain number is used for performance.</span><span class="s2">\n</span><span class="s1">var REACT_ELEMENT_TYPE = 0xeac7;</span><span class="s2">\n</span><span class="s1">var REACT_PORTAL_TYPE = 0xeaca;</span><span class="s2">\n</span><span class="s1">var REACT_FRAGMENT_TYPE = 0xeacb;</span><span class="s2">\n</span><span class="s1">var REACT_STRICT_MODE_TYPE = 0xeacc;</span><span class="s2">\n</span><span class="s1">var REACT_PROFILER_TYPE = 0xead2;</span><span class="s2">\n</span><span class="s1">var REACT_PROVIDER_TYPE = 0xeacd;</span><span class="s2">\n</span><span class="s1">var REACT_CONTEXT_TYPE = 0xeace;</span><span class="s2">\n</span><span class="s1">var REACT_FORWARD_REF_TYPE = 0xead0;</span><span class="s2">\n</span><span class="s1">var REACT_SUSPENSE_TYPE = 0xead1;</span><span class="s2">\n</span><span class="s1">var REACT_SUSPENSE_LIST_TYPE = 0xead8;</span><span class="s2">\n</span><span class="s1">var REACT_MEMO_TYPE = 0xead3;</span><span class="s2">\n</span><span class="s1">var REACT_LAZY_TYPE = 0xead4;</span><span class="s2">\n</span><span class="s1">var REACT_SCOPE_TYPE = 0xead7;</span><span class="s2">\n</span><span class="s1">var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;</span><span class="s2">\n</span><span class="s1">var REACT_OFFSCREEN_TYPE = 0xeae2;</span><span class="s2">\n</span><span class="s1">var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;</span><span class="s2">\n</span><span class="s1">var REACT_CACHE_TYPE = 0xeae4;</span><span class="s2">\n\n</span><span class="s1">if (typeof Symbol === 'function' &amp;&amp; Symbol.for) {</span><span class="s2">\n  </span><span class="s1">var symbolFor = Symbol.for;</span><span class="s2">\n  </span><span class="s1">REACT_ELEMENT_TYPE = symbolFor('react.element');</span><span class="s2">\n  </span><span class="s1">REACT_PORTAL_TYPE = symbolFor('react.portal');</span><span class="s2">\n  </span><span class="s1">REACT_FRAGMENT_TYPE = symbolFor('react.fragment');</span><span class="s2">\n  </span><span class="s1">REACT_STRICT_MODE_TYPE = symbolFor('react.strict_mode');</span><span class="s2">\n  </span><span class="s1">REACT_PROFILER_TYPE = symbolFor('react.profiler');</span><span class="s2">\n  </span><span class="s1">REACT_PROVIDER_TYPE = symbolFor('react.provider');</span><span class="s2">\n  </span><span class="s1">REACT_CONTEXT_TYPE = symbolFor('react.context');</span><span class="s2">\n  </span><span class="s1">REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');</span><span class="s2">\n  </span><span class="s1">REACT_SUSPENSE_TYPE = symbolFor('react.suspense');</span><span class="s2">\n  </span><span class="s1">REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');</span><span class="s2">\n  </span><span class="s1">REACT_MEMO_TYPE = symbolFor('react.memo');</span><span class="s2">\n  </span><span class="s1">REACT_LAZY_TYPE = symbolFor('react.lazy');</span><span class="s2">\n  </span><span class="s1">REACT_SCOPE_TYPE = symbolFor('react.scope');</span><span class="s2">\n  </span><span class="s1">REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');</span><span class="s2">\n  </span><span class="s1">REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');</span><span class="s2">\n  </span><span class="s1">REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');</span><span class="s2">\n  </span><span class="s1">REACT_CACHE_TYPE = symbolFor('react.cache');</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map; // We never remove these associations.</span><span class="s2">\n</span><span class="s1">// It's OK to reference families, but use WeakMap/Set for types.</span><span class="s2">\n\n</span><span class="s1">var allFamiliesByID = new Map();</span><span class="s2">\n</span><span class="s1">var allFamiliesByType = new PossiblyWeakMap();</span><span class="s2">\n</span><span class="s1">var allSignaturesByType = new PossiblyWeakMap(); // This WeakMap is read by React, so we only put families</span><span class="s2">\n</span><span class="s1">// that have actually been edited here. This keeps checks fast.</span><span class="s2">\n</span><span class="s1">// $FlowIssue</span><span class="s2">\n\n</span><span class="s1">var updatedFamiliesByType = new PossiblyWeakMap(); // This is cleared on every performReactRefresh() call.</span><span class="s2">\n</span><span class="s1">// It is an array of [Family, NextType] tuples.</span><span class="s2">\n\n</span><span class="s1">var pendingUpdates = []; // This is injected by the renderer via DevTools global hook.</span><span class="s2">\n\n</span><span class="s1">var helpersByRendererID = new Map();</span><span class="s2">\n</span><span class="s1">var helpersByRoot = new Map(); // We keep track of mounted roots so we can schedule updates.</span><span class="s2">\n\n</span><span class="s1">var mountedRoots = new Set(); // If a root captures an error, we remember it so we can retry on edit.</span><span class="s2">\n\n</span><span class="s1">var failedRoots = new Set(); // In environments that support WeakMap, we also remember the last element for every root.</span><span class="s2">\n</span><span class="s1">// It needs to be weak because we do this even for roots that failed to mount.</span><span class="s2">\n</span><span class="s1">// If there is no WeakMap, we won't attempt to do retrying.</span><span class="s2">\n</span><span class="s1">// $FlowIssue</span><span class="s2">\n\n</span><span class="s1">var rootElements = // $FlowIssue</span><span class="s2">\n</span><span class="s1">typeof WeakMap === 'function' ? new WeakMap() : null;</span><span class="s2">\n</span><span class="s1">var isPerformingRefresh = false;</span><span class="s2">\n\n</span><span class="s1">function computeFullKey(signature) {</span><span class="s2">\n  </span><span class="s1">if (signature.fullKey !== null) {</span><span class="s2">\n    </span><span class="s1">return signature.fullKey;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">var fullKey = signature.ownKey;</span><span class="s2">\n  </span><span class="s1">var hooks;</span><span class="s2">\n\n  </span><span class="s1">try {</span><span class="s2">\n    </span><span class="s1">hooks = signature.getCustomHooks();</span><span class="s2">\n  </span><span class="s1">} catch (err) {</span><span class="s2">\n    </span><span class="s1">// This can happen in an edge case, e.g. if expression like Foo.useSomething</span><span class="s2">\n    </span><span class="s1">// depends on Foo which is lazily initialized during rendering.</span><span class="s2">\n    </span><span class="s1">// In that case just assume we'll have to remount.</span><span class="s2">\n    </span><span class="s1">signature.forceReset = true;</span><span class="s2">\n    </span><span class="s1">signature.fullKey = fullKey;</span><span class="s2">\n    </span><span class="s1">return fullKey;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">for (var i = 0; i &lt; hooks.length; i++) {</span><span class="s2">\n    </span><span class="s1">var hook = hooks[i];</span><span class="s2">\n\n    </span><span class="s1">if (typeof hook !== 'function') {</span><span class="s2">\n      </span><span class="s1">// Something's wrong. Assume we need to remount.</span><span class="s2">\n      </span><span class="s1">signature.forceReset = true;</span><span class="s2">\n      </span><span class="s1">signature.fullKey = fullKey;</span><span class="s2">\n      </span><span class="s1">return fullKey;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">var nestedHookSignature = allSignaturesByType.get(hook);</span><span class="s2">\n\n    </span><span class="s1">if (nestedHookSignature === undefined) {</span><span class="s2">\n      </span><span class="s1">// No signature means Hook wasn't in the source code, e.g. in a library.</span><span class="s2">\n      </span><span class="s1">// We'll skip it because we can assume it won't change during this session.</span><span class="s2">\n      </span><span class="s1">continue;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">var nestedHookKey = computeFullKey(nestedHookSignature);</span><span class="s2">\n\n    </span><span class="s1">if (nestedHookSignature.forceReset) {</span><span class="s2">\n      </span><span class="s1">signature.forceReset = true;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">fullKey += '</span><span class="s2">\\</span><span class="s1">n---</span><span class="s2">\\</span><span class="s1">n' + nestedHookKey;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">signature.fullKey = fullKey;</span><span class="s2">\n  </span><span class="s1">return fullKey;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function haveEqualSignatures(prevType, nextType) {</span><span class="s2">\n  </span><span class="s1">var prevSignature = allSignaturesByType.get(prevType);</span><span class="s2">\n  </span><span class="s1">var nextSignature = allSignaturesByType.get(nextType);</span><span class="s2">\n\n  </span><span class="s1">if (prevSignature === undefined &amp;&amp; nextSignature === undefined) {</span><span class="s2">\n    </span><span class="s1">return true;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">if (prevSignature === undefined || nextSignature === undefined) {</span><span class="s2">\n    </span><span class="s1">return false;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">if (computeFullKey(prevSignature) !== computeFullKey(nextSignature)) {</span><span class="s2">\n    </span><span class="s1">return false;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">if (nextSignature.forceReset) {</span><span class="s2">\n    </span><span class="s1">return false;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">return true;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function isReactClass(type) {</span><span class="s2">\n  </span><span class="s1">return type.prototype &amp;&amp; type.prototype.isReactComponent;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function canPreserveStateBetween(prevType, nextType) {</span><span class="s2">\n  </span><span class="s1">if (isReactClass(prevType) || isReactClass(nextType)) {</span><span class="s2">\n    </span><span class="s1">return false;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">if (haveEqualSignatures(prevType, nextType)) {</span><span class="s2">\n    </span><span class="s1">return true;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">return false;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function resolveFamily(type) {</span><span class="s2">\n  </span><span class="s1">// Only check updated types to keep lookups fast.</span><span class="s2">\n  </span><span class="s1">return updatedFamiliesByType.get(type);</span><span class="s2">\n</span><span class="s1">} // If we didn't care about IE11, we could use new Map/Set(iterable).</span><span class="s2">\n\n\n</span><span class="s1">function cloneMap(map) {</span><span class="s2">\n  </span><span class="s1">var clone = new Map();</span><span class="s2">\n  </span><span class="s1">map.forEach(function (value, key) {</span><span class="s2">\n    </span><span class="s1">clone.set(key, value);</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">return clone;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function cloneSet(set) {</span><span class="s2">\n  </span><span class="s1">var clone = new Set();</span><span class="s2">\n  </span><span class="s1">set.forEach(function (value) {</span><span class="s2">\n    </span><span class="s1">clone.add(value);</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">return clone;</span><span class="s2">\n</span><span class="s1">} // This is a safety mechanism to protect against rogue getters and Proxies.</span><span class="s2">\n\n\n</span><span class="s1">function getProperty(object, property) {</span><span class="s2">\n  </span><span class="s1">try {</span><span class="s2">\n    </span><span class="s1">return object[property];</span><span class="s2">\n  </span><span class="s1">} catch (err) {</span><span class="s2">\n    </span><span class="s1">// Intentionally ignore.</span><span class="s2">\n    </span><span class="s1">return undefined;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function performReactRefresh() {</span><span class="s2">\n\n  </span><span class="s1">if (pendingUpdates.length === 0) {</span><span class="s2">\n    </span><span class="s1">return null;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">if (isPerformingRefresh) {</span><span class="s2">\n    </span><span class="s1">return null;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">isPerformingRefresh = true;</span><span class="s2">\n\n  </span><span class="s1">try {</span><span class="s2">\n    </span><span class="s1">var staleFamilies = new Set();</span><span class="s2">\n    </span><span class="s1">var updatedFamilies = new Set();</span><span class="s2">\n    </span><span class="s1">var updates = pendingUpdates;</span><span class="s2">\n    </span><span class="s1">pendingUpdates = [];</span><span class="s2">\n    </span><span class="s1">updates.forEach(function (_ref) {</span><span class="s2">\n      </span><span class="s1">var family = _ref[0],</span><span class="s2">\n          </span><span class="s1">nextType = _ref[1];</span><span class="s2">\n      </span><span class="s1">// Now that we got a real edit, we can create associations</span><span class="s2">\n      </span><span class="s1">// that will be read by the React reconciler.</span><span class="s2">\n      </span><span class="s1">var prevType = family.current;</span><span class="s2">\n      </span><span class="s1">updatedFamiliesByType.set(prevType, family);</span><span class="s2">\n      </span><span class="s1">updatedFamiliesByType.set(nextType, family);</span><span class="s2">\n      </span><span class="s1">family.current = nextType; // Determine whether this should be a re-render or a re-mount.</span><span class="s2">\n\n      </span><span class="s1">if (canPreserveStateBetween(prevType, nextType)) {</span><span class="s2">\n        </span><span class="s1">updatedFamilies.add(family);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">staleFamilies.add(family);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}); // TODO: rename these fields to something more meaningful.</span><span class="s2">\n\n    </span><span class="s1">var update = {</span><span class="s2">\n      </span><span class="s1">updatedFamilies: updatedFamilies,</span><span class="s2">\n      </span><span class="s1">// Families that will re-render preserving state</span><span class="s2">\n      </span><span class="s1">staleFamilies: staleFamilies // Families that will be remounted</span><span class="s2">\n\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">helpersByRendererID.forEach(function (helpers) {</span><span class="s2">\n      </span><span class="s1">// Even if there are no roots, set the handler on first update.</span><span class="s2">\n      </span><span class="s1">// This ensures that if *new* roots are mounted, they'll use the resolve handler.</span><span class="s2">\n      </span><span class="s1">helpers.setRefreshHandler(resolveFamily);</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">var didError = false;</span><span class="s2">\n    </span><span class="s1">var firstError = null; // We snapshot maps and sets that are mutated during commits.</span><span class="s2">\n    </span><span class="s1">// If we don't do this, there is a risk they will be mutated while</span><span class="s2">\n    </span><span class="s1">// we iterate over them. For example, trying to recover a failed root</span><span class="s2">\n    </span><span class="s1">// may cause another root to be added to the failed list -- an infinite loop.</span><span class="s2">\n\n    </span><span class="s1">var failedRootsSnapshot = cloneSet(failedRoots);</span><span class="s2">\n    </span><span class="s1">var mountedRootsSnapshot = cloneSet(mountedRoots);</span><span class="s2">\n    </span><span class="s1">var helpersByRootSnapshot = cloneMap(helpersByRoot);</span><span class="s2">\n    </span><span class="s1">failedRootsSnapshot.forEach(function (root) {</span><span class="s2">\n      </span><span class="s1">var helpers = helpersByRootSnapshot.get(root);</span><span class="s2">\n\n      </span><span class="s1">if (helpers === undefined) {</span><span class="s2">\n        </span><span class="s1">throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">if (!failedRoots.has(root)) {// No longer failed.</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">if (rootElements === null) {</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">if (!rootElements.has(root)) {</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">var element = rootElements.get(root);</span><span class="s2">\n\n      </span><span class="s1">try {</span><span class="s2">\n        </span><span class="s1">helpers.scheduleRoot(root, element);</span><span class="s2">\n      </span><span class="s1">} catch (err) {</span><span class="s2">\n        </span><span class="s1">if (!didError) {</span><span class="s2">\n          </span><span class="s1">didError = true;</span><span class="s2">\n          </span><span class="s1">firstError = err;</span><span class="s2">\n        </span><span class="s1">} // Keep trying other roots.</span><span class="s2">\n\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">mountedRootsSnapshot.forEach(function (root) {</span><span class="s2">\n      </span><span class="s1">var helpers = helpersByRootSnapshot.get(root);</span><span class="s2">\n\n      </span><span class="s1">if (helpers === undefined) {</span><span class="s2">\n        </span><span class="s1">throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">if (!mountedRoots.has(root)) {// No longer mounted.</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">try {</span><span class="s2">\n        </span><span class="s1">helpers.scheduleRefresh(root, update);</span><span class="s2">\n      </span><span class="s1">} catch (err) {</span><span class="s2">\n        </span><span class="s1">if (!didError) {</span><span class="s2">\n          </span><span class="s1">didError = true;</span><span class="s2">\n          </span><span class="s1">firstError = err;</span><span class="s2">\n        </span><span class="s1">} // Keep trying other roots.</span><span class="s2">\n\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n\n    </span><span class="s1">if (didError) {</span><span class="s2">\n      </span><span class="s1">throw firstError;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">return update;</span><span class="s2">\n  </span><span class="s1">} finally {</span><span class="s2">\n    </span><span class="s1">isPerformingRefresh = false;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function register(type, id) {</span><span class="s2">\n  </span><span class="s1">{</span><span class="s2">\n    </span><span class="s1">if (type === null) {</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">if (typeof type !== 'function' &amp;&amp; typeof type !== 'object') {</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">} // This can happen in an edge case, e.g. if we register</span><span class="s2">\n    </span><span class="s1">// return value of a HOC but it returns a cached component.</span><span class="s2">\n    </span><span class="s1">// Ignore anything but the first registration for each type.</span><span class="s2">\n\n\n    </span><span class="s1">if (allFamiliesByType.has(type)) {</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">} // Create family or remember to update it.</span><span class="s2">\n    </span><span class="s1">// None of this bookkeeping affects reconciliation</span><span class="s2">\n    </span><span class="s1">// until the first performReactRefresh() call above.</span><span class="s2">\n\n\n    </span><span class="s1">var family = allFamiliesByID.get(id);</span><span class="s2">\n\n    </span><span class="s1">if (family === undefined) {</span><span class="s2">\n      </span><span class="s1">family = {</span><span class="s2">\n        </span><span class="s1">current: type</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">allFamiliesByID.set(id, family);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">pendingUpdates.push([family, type]);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">allFamiliesByType.set(type, family); // Visit inner types because we might not have registered them.</span><span class="s2">\n\n    </span><span class="s1">if (typeof type === 'object' &amp;&amp; type !== null) {</span><span class="s2">\n      </span><span class="s1">switch (getProperty(type, '$$typeof')) {</span><span class="s2">\n        </span><span class="s1">case REACT_FORWARD_REF_TYPE:</span><span class="s2">\n          </span><span class="s1">register(type.render, id + '$render');</span><span class="s2">\n          </span><span class="s1">break;</span><span class="s2">\n\n        </span><span class="s1">case REACT_MEMO_TYPE:</span><span class="s2">\n          </span><span class="s1">register(type.type, id + '$type');</span><span class="s2">\n          </span><span class="s1">break;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function setSignature(type, key) {</span><span class="s2">\n  </span><span class="s1">var forceReset = arguments.length &gt; 2 &amp;&amp; arguments[2] !== undefined ? arguments[2] : false;</span><span class="s2">\n  </span><span class="s1">var getCustomHooks = arguments.length &gt; 3 ? arguments[3] : undefined;</span><span class="s2">\n\n  </span><span class="s1">{</span><span class="s2">\n    </span><span class="s1">if (!allSignaturesByType.has(type)) {</span><span class="s2">\n      </span><span class="s1">allSignaturesByType.set(type, {</span><span class="s2">\n        </span><span class="s1">forceReset: forceReset,</span><span class="s2">\n        </span><span class="s1">ownKey: key,</span><span class="s2">\n        </span><span class="s1">fullKey: null,</span><span class="s2">\n        </span><span class="s1">getCustomHooks: getCustomHooks || function () {</span><span class="s2">\n          </span><span class="s1">return [];</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">} // Visit inner types because we might not have signed them.</span><span class="s2">\n\n\n    </span><span class="s1">if (typeof type === 'object' &amp;&amp; type !== null) {</span><span class="s2">\n      </span><span class="s1">switch (getProperty(type, '$$typeof')) {</span><span class="s2">\n        </span><span class="s1">case REACT_FORWARD_REF_TYPE:</span><span class="s2">\n          </span><span class="s1">setSignature(type.render, key, forceReset, getCustomHooks);</span><span class="s2">\n          </span><span class="s1">break;</span><span class="s2">\n\n        </span><span class="s1">case REACT_MEMO_TYPE:</span><span class="s2">\n          </span><span class="s1">setSignature(type.type, key, forceReset, getCustomHooks);</span><span class="s2">\n          </span><span class="s1">break;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">} // This is lazily called during first render for a type.</span><span class="s2">\n</span><span class="s1">// It captures Hook list at that time so inline requires don't break comparisons.</span><span class="s2">\n\n</span><span class="s1">function collectCustomHooksForSignature(type) {</span><span class="s2">\n  </span><span class="s1">{</span><span class="s2">\n    </span><span class="s1">var signature = allSignaturesByType.get(type);</span><span class="s2">\n\n    </span><span class="s1">if (signature !== undefined) {</span><span class="s2">\n      </span><span class="s1">computeFullKey(signature);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getFamilyByID(id) {</span><span class="s2">\n  </span><span class="s1">{</span><span class="s2">\n    </span><span class="s1">return allFamiliesByID.get(id);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getFamilyByType(type) {</span><span class="s2">\n  </span><span class="s1">{</span><span class="s2">\n    </span><span class="s1">return allFamiliesByType.get(type);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function findAffectedHostInstances(families) {</span><span class="s2">\n  </span><span class="s1">{</span><span class="s2">\n    </span><span class="s1">var affectedInstances = new Set();</span><span class="s2">\n    </span><span class="s1">mountedRoots.forEach(function (root) {</span><span class="s2">\n      </span><span class="s1">var helpers = helpersByRoot.get(root);</span><span class="s2">\n\n      </span><span class="s1">if (helpers === undefined) {</span><span class="s2">\n        </span><span class="s1">throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">var instancesForRoot = helpers.findHostInstancesForRefresh(root, families);</span><span class="s2">\n      </span><span class="s1">instancesForRoot.forEach(function (inst) {</span><span class="s2">\n        </span><span class="s1">affectedInstances.add(inst);</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">return affectedInstances;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function injectIntoGlobalHook(globalObject) {</span><span class="s2">\n  </span><span class="s1">{</span><span class="s2">\n    </span><span class="s1">// For React Native, the global hook will be set up by require('react-devtools-core').</span><span class="s2">\n    </span><span class="s1">// That code will run before us. So we need to monkeypatch functions on existing hook.</span><span class="s2">\n    </span><span class="s1">// For React Web, the global hook will be set up by the extension.</span><span class="s2">\n    </span><span class="s1">// This will also run before us.</span><span class="s2">\n    </span><span class="s1">var hook = globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__;</span><span class="s2">\n\n    </span><span class="s1">if (hook === undefined) {</span><span class="s2">\n      </span><span class="s1">// However, if there is no DevTools extension, we'll need to set up the global hook ourselves.</span><span class="s2">\n      </span><span class="s1">// Note that in this case it's important that renderer code runs *after* this method call.</span><span class="s2">\n      </span><span class="s1">// Otherwise, the renderer will think that there is no global hook, and won't do the injection.</span><span class="s2">\n      </span><span class="s1">var nextID = 0;</span><span class="s2">\n      </span><span class="s1">globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__ = hook = {</span><span class="s2">\n        </span><span class="s1">renderers: new Map(),</span><span class="s2">\n        </span><span class="s1">supportsFiber: true,</span><span class="s2">\n        </span><span class="s1">inject: function (injected) {</span><span class="s2">\n          </span><span class="s1">return nextID++;</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">onScheduleFiberRoot: function (id, root, children) {},</span><span class="s2">\n        </span><span class="s1">onCommitFiberRoot: function (id, root, maybePriorityLevel, didError) {},</span><span class="s2">\n        </span><span class="s1">onCommitFiberUnmount: function () {}</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">if (hook.isDisabled) {</span><span class="s2">\n      </span><span class="s1">// This isn't a real property on the hook, but it can be set to opt out</span><span class="s2">\n      </span><span class="s1">// of DevTools integration and associated warnings and logs.</span><span class="s2">\n      </span><span class="s1">// Using console['warn'] to evade Babel and ESLint</span><span class="s2">\n      </span><span class="s1">console['warn']('Something has shimmed the React DevTools global hook (__REACT_DEVTOOLS_GLOBAL_HOOK__). ' + 'Fast Refresh is not compatible with this shim and will be disabled.');</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">} // Here, we just want to get a reference to scheduleRefresh.</span><span class="s2">\n\n\n    </span><span class="s1">var oldInject = hook.inject;</span><span class="s2">\n\n    </span><span class="s1">hook.inject = function (injected) {</span><span class="s2">\n      </span><span class="s1">var id = oldInject.apply(this, arguments);</span><span class="s2">\n\n      </span><span class="s1">if (typeof injected.scheduleRefresh === 'function' &amp;&amp; typeof injected.setRefreshHandler === 'function') {</span><span class="s2">\n        </span><span class="s1">// This version supports React Refresh.</span><span class="s2">\n        </span><span class="s1">helpersByRendererID.set(id, injected);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">return id;</span><span class="s2">\n    </span><span class="s1">}; // Do the same for any already injected roots.</span><span class="s2">\n    </span><span class="s1">// This is useful if ReactDOM has already been initialized.</span><span class="s2">\n    </span><span class="s1">// https://github.com/facebook/react/issues/17626</span><span class="s2">\n\n\n    </span><span class="s1">hook.renderers.forEach(function (injected, id) {</span><span class="s2">\n      </span><span class="s1">if (typeof injected.scheduleRefresh === 'function' &amp;&amp; typeof injected.setRefreshHandler === 'function') {</span><span class="s2">\n        </span><span class="s1">// This version supports React Refresh.</span><span class="s2">\n        </span><span class="s1">helpersByRendererID.set(id, injected);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}); // We also want to track currently mounted roots.</span><span class="s2">\n\n    </span><span class="s1">var oldOnCommitFiberRoot = hook.onCommitFiberRoot;</span><span class="s2">\n\n    </span><span class="s1">var oldOnScheduleFiberRoot = hook.onScheduleFiberRoot || function () {};</span><span class="s2">\n\n    </span><span class="s1">hook.onScheduleFiberRoot = function (id, root, children) {</span><span class="s2">\n      </span><span class="s1">if (!isPerformingRefresh) {</span><span class="s2">\n        </span><span class="s1">// If it was intentionally scheduled, don't attempt to restore.</span><span class="s2">\n        </span><span class="s1">// This includes intentionally scheduled unmounts.</span><span class="s2">\n        </span><span class="s1">failedRoots.delete(root);</span><span class="s2">\n\n        </span><span class="s1">if (rootElements !== null) {</span><span class="s2">\n          </span><span class="s1">rootElements.set(root, children);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">return oldOnScheduleFiberRoot.apply(this, arguments);</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n\n    </span><span class="s1">hook.onCommitFiberRoot = function (id, root, maybePriorityLevel, didError) {</span><span class="s2">\n      </span><span class="s1">var helpers = helpersByRendererID.get(id);</span><span class="s2">\n\n      </span><span class="s1">if (helpers !== undefined) {</span><span class="s2">\n        </span><span class="s1">helpersByRoot.set(root, helpers);</span><span class="s2">\n        </span><span class="s1">var current = root.current;</span><span class="s2">\n        </span><span class="s1">var alternate = current.alternate; // We need to determine whether this root has just (un)mounted.</span><span class="s2">\n        </span><span class="s1">// This logic is copy-pasted from similar logic in the DevTools backend.</span><span class="s2">\n        </span><span class="s1">// If this breaks with some refactoring, you'll want to update DevTools too.</span><span class="s2">\n\n        </span><span class="s1">if (alternate !== null) {</span><span class="s2">\n          </span><span class="s1">var wasMounted = alternate.memoizedState != null &amp;&amp; alternate.memoizedState.element != null;</span><span class="s2">\n          </span><span class="s1">var isMounted = current.memoizedState != null &amp;&amp; current.memoizedState.element != null;</span><span class="s2">\n\n          </span><span class="s1">if (!wasMounted &amp;&amp; isMounted) {</span><span class="s2">\n            </span><span class="s1">// Mount a new root.</span><span class="s2">\n            </span><span class="s1">mountedRoots.add(root);</span><span class="s2">\n            </span><span class="s1">failedRoots.delete(root);</span><span class="s2">\n          </span><span class="s1">} else if (wasMounted &amp;&amp; isMounted) ; else if (wasMounted &amp;&amp; !isMounted) {</span><span class="s2">\n            </span><span class="s1">// Unmount an existing root.</span><span class="s2">\n            </span><span class="s1">mountedRoots.delete(root);</span><span class="s2">\n\n            </span><span class="s1">if (didError) {</span><span class="s2">\n              </span><span class="s1">// We'll remount it on future edits.</span><span class="s2">\n              </span><span class="s1">failedRoots.add(root);</span><span class="s2">\n            </span><span class="s1">} else {</span><span class="s2">\n              </span><span class="s1">helpersByRoot.delete(root);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">} else if (!wasMounted &amp;&amp; !isMounted) {</span><span class="s2">\n            </span><span class="s1">if (didError) {</span><span class="s2">\n              </span><span class="s1">// We'll remount it on future edits.</span><span class="s2">\n              </span><span class="s1">failedRoots.add(root);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">// Mount a new root.</span><span class="s2">\n          </span><span class="s1">mountedRoots.add(root);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">} // Always call the decorated DevTools hook.</span><span class="s2">\n\n\n      </span><span class="s1">return oldOnCommitFiberRoot.apply(this, arguments);</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function hasUnrecoverableErrors() {</span><span class="s2">\n  </span><span class="s1">// TODO: delete this after removing dependency in RN.</span><span class="s2">\n  </span><span class="s1">return false;</span><span class="s2">\n</span><span class="s1">} // Exposed for testing.</span><span class="s2">\n\n</span><span class="s1">function _getMountedRootCount() {</span><span class="s2">\n  </span><span class="s1">{</span><span class="s2">\n    </span><span class="s1">return mountedRoots.size;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">} // This is a wrapper over more primitive functions for setting signature.</span><span class="s2">\n</span><span class="s1">// Signatures let us decide whether the Hook order has changed on refresh.</span><span class="s2">\n</span><span class="s1">//</span><span class="s2">\n</span><span class="s1">// This function is intended to be used as a transform target, e.g.:</span><span class="s2">\n</span><span class="s1">// var _s = createSignatureFunctionForTransform()</span><span class="s2">\n</span><span class="s1">//</span><span class="s2">\n</span><span class="s1">// function Hello() {</span><span class="s2">\n</span><span class="s1">//   const [foo, setFoo] = useState(0);</span><span class="s2">\n</span><span class="s1">//   const value = useCustomHook();</span><span class="s2">\n</span><span class="s1">//   _s(); /* Call without arguments triggers collecting the custom Hook list.</span><span class="s2">\n</span><span class="s1">//          * This doesn't happen during the module evaluation because we</span><span class="s2">\n</span><span class="s1">//          * don't want to change the module order with inline requires.</span><span class="s2">\n</span><span class="s1">//          * Next calls are noops. */</span><span class="s2">\n</span><span class="s1">//   return &lt;h1&gt;Hi&lt;/h1&gt;;</span><span class="s2">\n</span><span class="s1">// }</span><span class="s2">\n</span><span class="s1">//</span><span class="s2">\n</span><span class="s1">// /* Call with arguments attaches the signature to the type: */</span><span class="s2">\n</span><span class="s1">// _s(</span><span class="s2">\n</span><span class="s1">//   Hello,</span><span class="s2">\n</span><span class="s1">//   'useState{[foo, setFoo]}(0)',</span><span class="s2">\n</span><span class="s1">//   () =&gt; [useCustomHook], /* Lazy to avoid triggering inline requires */</span><span class="s2">\n</span><span class="s1">// );</span><span class="s2">\n\n</span><span class="s1">function createSignatureFunctionForTransform() {</span><span class="s2">\n  </span><span class="s1">{</span><span class="s2">\n    </span><span class="s1">var savedType;</span><span class="s2">\n    </span><span class="s1">var hasCustomHooks;</span><span class="s2">\n    </span><span class="s1">var didCollectHooks = false;</span><span class="s2">\n    </span><span class="s1">return function (type, key, forceReset, getCustomHooks) {</span><span class="s2">\n      </span><span class="s1">if (typeof key === 'string') {</span><span class="s2">\n        </span><span class="s1">// We're in the initial phase that associates signatures</span><span class="s2">\n        </span><span class="s1">// with the functions. Note this may be called multiple times</span><span class="s2">\n        </span><span class="s1">// in HOC chains like _s(hoc1(_s(hoc2(_s(actualFunction))))).</span><span class="s2">\n        </span><span class="s1">if (!savedType) {</span><span class="s2">\n          </span><span class="s1">// We're in the innermost call, so this is the actual type.</span><span class="s2">\n          </span><span class="s1">savedType = type;</span><span class="s2">\n          </span><span class="s1">hasCustomHooks = typeof getCustomHooks === 'function';</span><span class="s2">\n        </span><span class="s1">} // Set the signature for all types (even wrappers!) in case</span><span class="s2">\n        </span><span class="s1">// they have no signatures of their own. This is to prevent</span><span class="s2">\n        </span><span class="s1">// problems like https://github.com/facebook/react/issues/20417.</span><span class="s2">\n\n\n        </span><span class="s1">if (type != null &amp;&amp; (typeof type === 'function' || typeof type === 'object')) {</span><span class="s2">\n          </span><span class="s1">setSignature(type, key, forceReset, getCustomHooks);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">return type;</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">// We're in the _s() call without arguments, which means</span><span class="s2">\n        </span><span class="s1">// this is the time to collect custom Hook signatures.</span><span class="s2">\n        </span><span class="s1">// Only do this once. This path is hot and runs *inside* every render!</span><span class="s2">\n        </span><span class="s1">if (!didCollectHooks &amp;&amp; hasCustomHooks) {</span><span class="s2">\n          </span><span class="s1">didCollectHooks = true;</span><span class="s2">\n          </span><span class="s1">collectCustomHooksForSignature(savedType);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isLikelyComponentType(type) {</span><span class="s2">\n  </span><span class="s1">{</span><span class="s2">\n    </span><span class="s1">switch (typeof type) {</span><span class="s2">\n      </span><span class="s1">case 'function':</span><span class="s2">\n        </span><span class="s1">{</span><span class="s2">\n          </span><span class="s1">// First, deal with classes.</span><span class="s2">\n          </span><span class="s1">if (type.prototype != null) {</span><span class="s2">\n            </span><span class="s1">if (type.prototype.isReactComponent) {</span><span class="s2">\n              </span><span class="s1">// React class.</span><span class="s2">\n              </span><span class="s1">return true;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n\n            </span><span class="s1">var ownNames = Object.getOwnPropertyNames(type.prototype);</span><span class="s2">\n\n            </span><span class="s1">if (ownNames.length &gt; 1 || ownNames[0] !== 'constructor') {</span><span class="s2">\n              </span><span class="s1">// This looks like a class.</span><span class="s2">\n              </span><span class="s1">return false;</span><span class="s2">\n            </span><span class="s1">} // eslint-disable-next-line no-proto</span><span class="s2">\n\n\n            </span><span class="s1">if (type.prototype.__proto__ !== Object.prototype) {</span><span class="s2">\n              </span><span class="s1">// It has a superclass.</span><span class="s2">\n              </span><span class="s1">return false;</span><span class="s2">\n            </span><span class="s1">} // Pass through.</span><span class="s2">\n            </span><span class="s1">// This looks like a regular function with empty prototype.</span><span class="s2">\n\n          </span><span class="s1">} // For plain functions and arrows, use name as a heuristic.</span><span class="s2">\n\n\n          </span><span class="s1">var name = type.name || type.displayName;</span><span class="s2">\n          </span><span class="s1">return typeof name === 'string' &amp;&amp; /^[A-Z]/.test(name);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">case 'object':</span><span class="s2">\n        </span><span class="s1">{</span><span class="s2">\n          </span><span class="s1">if (type != null) {</span><span class="s2">\n            </span><span class="s1">switch (getProperty(type, '$$typeof')) {</span><span class="s2">\n              </span><span class="s1">case REACT_FORWARD_REF_TYPE:</span><span class="s2">\n              </span><span class="s1">case REACT_MEMO_TYPE:</span><span class="s2">\n                </span><span class="s1">// Definitely React components.</span><span class="s2">\n                </span><span class="s1">return true;</span><span class="s2">\n\n              </span><span class="s1">default:</span><span class="s2">\n                </span><span class="s1">return false;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n\n          </span><span class="s1">return false;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">default:</span><span class="s2">\n        </span><span class="s1">{</span><span class="s2">\n          </span><span class="s1">return false;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">exports._getMountedRootCount = _getMountedRootCount;</span><span class="s2">\n</span><span class="s1">exports.collectCustomHooksForSignature = collectCustomHooksForSignature;</span><span class="s2">\n</span><span class="s1">exports.createSignatureFunctionForTransform = createSignatureFunctionForTransform;</span><span class="s2">\n</span><span class="s1">exports.findAffectedHostInstances = findAffectedHostInstances;</span><span class="s2">\n</span><span class="s1">exports.getFamilyByID = getFamilyByID;</span><span class="s2">\n</span><span class="s1">exports.getFamilyByType = getFamilyByType;</span><span class="s2">\n</span><span class="s1">exports.hasUnrecoverableErrors = hasUnrecoverableErrors;</span><span class="s2">\n</span><span class="s1">exports.injectIntoGlobalHook = injectIntoGlobalHook;</span><span class="s2">\n</span><span class="s1">exports.isLikelyComponentType = isLikelyComponentType;</span><span class="s2">\n</span><span class="s1">exports.performReactRefresh = performReactRefresh;</span><span class="s2">\n</span><span class="s1">exports.register = register;</span><span class="s2">\n</span><span class="s1">exports.setSignature = setSignature;</span><span class="s2">\n  </span><span class="s1">})();</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[]},</span><span class="s1">&quot;metadata&quot;</span><span class="s0">:{},</span><span class="s1">&quot;sourceType&quot;</span><span class="s0">:</span><span class="s1">&quot;script&quot;</span><span class="s0">,</span><span class="s1">&quot;externalDependencies&quot;</span><span class="s0">:[]}</span></pre>
</body>
</html>