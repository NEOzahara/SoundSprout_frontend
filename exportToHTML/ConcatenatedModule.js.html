<html>
<head>
<title>ConcatenatedModule.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #6aab73;}
.s3 { color: #bcbec4;}
.s4 { color: #cf8e6d;}
.s5 { color: #5f826b; font-style: italic;}
.s6 { color: #67a37c; font-style: italic;}
.s7 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
ConcatenatedModule.js</font>
</center></td></tr></table>
<pre><span class="s0">/* 
    MIT License http://www.opensource.org/licenses/mit-license.php 
    Author Tobias Koppers @sokra 
*/</span>

<span class="s2">&quot;use strict&quot;</span><span class="s3">;</span>

<span class="s4">const </span><span class="s1">eslintScope </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;eslint-scope&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s1">Referencer </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;eslint-scope/lib/referencer&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s3">{ </span><span class="s1">SyncBailHook </span><span class="s3">} = </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;tapable&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s3">{</span>
	<span class="s1">CachedSource</span><span class="s3">,</span>
	<span class="s1">ConcatSource</span><span class="s3">,</span>
	<span class="s1">ReplaceSource</span>
<span class="s3">} = </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;webpack-sources&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s1">ConcatenationScope </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;../ConcatenationScope&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s3">{ </span><span class="s1">UsageState </span><span class="s3">} = </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;../ExportsInfo&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s1">Module </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;../Module&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s3">{ </span><span class="s1">JS_TYPES </span><span class="s3">} = </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;../ModuleSourceTypesConstants&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s3">{ </span><span class="s1">JAVASCRIPT_MODULE_TYPE_ESM </span><span class="s3">} = </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;../ModuleTypeConstants&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s1">RuntimeGlobals </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;../RuntimeGlobals&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s1">Template </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;../Template&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s3">{ </span><span class="s1">DEFAULTS </span><span class="s3">} = </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;../config/defaults&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s1">HarmonyImportDependency </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;../dependencies/HarmonyImportDependency&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s1">JavascriptParser </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;../javascript/JavascriptParser&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s3">{ </span><span class="s1">equals </span><span class="s3">} = </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;../util/ArrayHelpers&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s1">LazySet </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;../util/LazySet&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s3">{ </span><span class="s1">concatComparators </span><span class="s3">} = </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;../util/comparators&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s3">{</span>
	<span class="s1">RESERVED_NAMES</span><span class="s3">,</span>
	<span class="s1">findNewName</span><span class="s3">,</span>
	<span class="s1">addScopeSymbols</span><span class="s3">,</span>
	<span class="s1">getAllReferences</span><span class="s3">,</span>
	<span class="s1">getPathInAst</span><span class="s3">,</span>
	<span class="s1">getUsedNamesInScopeInfo</span>
<span class="s3">} = </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;../util/concatenate&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s1">createHash </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;../util/createHash&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s3">{ </span><span class="s1">makePathsRelative </span><span class="s3">} = </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;../util/identifier&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s1">makeSerializable </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;../util/makeSerializable&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s1">propertyAccess </span><span class="s3">= </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;../util/propertyAccess&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s3">{ </span><span class="s1">propertyName </span><span class="s3">} = </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;../util/propertyName&quot;</span><span class="s3">);</span>
<span class="s4">const </span><span class="s3">{</span>
	<span class="s1">filterRuntime</span><span class="s3">,</span>
	<span class="s1">intersectRuntime</span><span class="s3">,</span>
	<span class="s1">mergeRuntimeCondition</span><span class="s3">,</span>
	<span class="s1">mergeRuntimeConditionNonFalse</span><span class="s3">,</span>
	<span class="s1">runtimeConditionToString</span><span class="s3">,</span>
	<span class="s1">subtractRuntimeCondition</span>
<span class="s3">} = </span><span class="s1">require</span><span class="s3">(</span><span class="s2">&quot;../util/runtime&quot;</span><span class="s3">);</span>

<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;eslint-scope&quot;).Reference} Reference */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;eslint-scope&quot;).Scope} Scope */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;eslint-scope&quot;).Variable} Variable */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;webpack-sources&quot;).Source} Source */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;../../declarations/WebpackOptions&quot;).WebpackOptionsNormalized} WebpackOptions */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;../ChunkGraph&quot;)} ChunkGraph */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;../CodeGenerationResults&quot;)} CodeGenerationResults */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;../Compilation&quot;)} Compilation */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;../Dependency&quot;)} Dependency */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;../Dependency&quot;).UpdateHashContext} UpdateHashContext */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;../DependencyTemplate&quot;).DependencyTemplateContext} DependencyTemplateContext */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;../DependencyTemplates&quot;)} DependencyTemplates */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;../ExportsInfo&quot;).ExportInfo} ExportInfo */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;../Module&quot;).BuildCallback} BuildCallback */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;../Module&quot;).BuildInfo} BuildInfo */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;../Module&quot;).BuildMeta} BuildMeta */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;../Module&quot;).CodeGenerationContext} CodeGenerationContext */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;../Module&quot;).CodeGenerationResult} CodeGenerationResult */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;../Module&quot;).LibIdentOptions} LibIdentOptions */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;../Module&quot;).ReadOnlyRuntimeRequirements} ReadOnlyRuntimeRequirements */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;../Module&quot;).RuntimeRequirements} RuntimeRequirements */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;../Module&quot;).SourceTypes} SourceTypes */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;../ModuleGraph&quot;)} ModuleGraph */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;../ModuleGraphConnection&quot;)} ModuleGraphConnection */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;../ModuleGraphConnection&quot;).ConnectionState} ConnectionState */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;../ModuleParseError&quot;)} ModuleParseError */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;../RequestShortener&quot;)} RequestShortener */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;../ResolverFactory&quot;).ResolverWithOptions} ResolverWithOptions */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;../RuntimeTemplate&quot;)} RuntimeTemplate */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;../WebpackError&quot;)} WebpackError */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;../javascript/JavascriptModulesPlugin&quot;).ChunkRenderContext} ChunkRenderContext */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;../javascript/JavascriptParser&quot;).Program} Program */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;../javascript/JavascriptParser&quot;).Range} Range */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;../serialization/ObjectMiddleware&quot;).ObjectDeserializerContext} ObjectDeserializerContext */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;../util/Hash&quot;)} Hash */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{typeof import(&quot;../util/Hash&quot;)} HashConstructor */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;../util/concatenate&quot;).UsedNames} UsedNames */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;../util/fs&quot;).InputFileSystem} InputFileSystem */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;../util/identifier&quot;).AssociatedObjectForCache} AssociatedObjectForCache */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{import(&quot;../util/runtime&quot;).RuntimeSpec} RuntimeSpec */</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@template </span><span class="s5">T</span>
 <span class="s5">* </span><span class="s6">@typedef </span><span class="s5">{import(&quot;../InitFragment&quot;)&lt;T&gt;} InitFragment</span>
 <span class="s5">*/</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@template </span><span class="s5">T</span>
 <span class="s5">* </span><span class="s6">@typedef </span><span class="s5">{import(&quot;../util/comparators&quot;).Comparator&lt;T&gt;} Comparator</span>
 <span class="s5">*/</span>

<span class="s0">// fix eslint-scope to support class properties correctly</span>
<span class="s0">// cspell:word Referencer</span>
<span class="s4">const </span><span class="s1">ReferencerClass </span><span class="s3">= </span><span class="s5">/** </span><span class="s6">@type </span><span class="s5">{EXPECTED_ANY} */ </span><span class="s3">(</span><span class="s1">Referencer</span><span class="s3">);</span>
<span class="s4">if </span><span class="s3">(!</span><span class="s1">ReferencerClass</span><span class="s3">.</span><span class="s1">prototype</span><span class="s3">.</span><span class="s1">PropertyDefinition</span><span class="s3">) {</span>
	<span class="s1">ReferencerClass</span><span class="s3">.</span><span class="s1">prototype</span><span class="s3">.</span><span class="s1">PropertyDefinition </span><span class="s3">=</span>
		<span class="s1">ReferencerClass</span><span class="s3">.</span><span class="s1">prototype</span><span class="s3">.</span><span class="s1">Property</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@typedef </span><span class="s5">{object} ReexportInfo</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{Module} module</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{string[]} export</span>
 <span class="s5">*/</span>

<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{RawBinding | SymbolBinding} Binding */</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@typedef </span><span class="s5">{object} RawBinding</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{ModuleInfo} info</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{string} rawName</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{string=} comment</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{string[]} ids</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{string[]} exportName</span>
 <span class="s5">*/</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@typedef </span><span class="s5">{object} SymbolBinding</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{ConcatenatedModuleInfo} info</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{string} name</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{string=} comment</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{string[]} ids</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{string[]} exportName</span>
 <span class="s5">*/</span>

<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{ConcatenatedModuleInfo | ExternalModuleInfo } ModuleInfo */</span>
<span class="s5">/** </span><span class="s6">@typedef </span><span class="s5">{ConcatenatedModuleInfo | ExternalModuleInfo | ReferenceToModuleInfo } ModuleInfoOrReference */</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@typedef </span><span class="s5">{object} ConcatenatedModuleInfo</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{&quot;concatenated&quot;} type</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{Module} module</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{number} index</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{Program | undefined} ast</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{Source | undefined} internalSource</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{ReplaceSource | undefined} source</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{InitFragment&lt;ChunkRenderContext&gt;[]=} chunkInitFragments</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{ReadOnlyRuntimeRequirements | undefined} runtimeRequirements</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{Scope | undefined} globalScope</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{Scope | undefined} moduleScope</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{Map&lt;string, string&gt;} internalNames</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{Map&lt;string, string&gt; | undefined} exportMap</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{Map&lt;string, string&gt; | undefined} rawExportMap</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{string=} namespaceExportSymbol</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{string | undefined} namespaceObjectName</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{boolean} interopNamespaceObjectUsed</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{string | undefined} interopNamespaceObjectName</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{boolean} interopNamespaceObject2Used</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{string | undefined} interopNamespaceObject2Name</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{boolean} interopDefaultAccessUsed</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{string | undefined} interopDefaultAccessName</span>
 <span class="s5">*/</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@typedef </span><span class="s5">{object} ExternalModuleInfo</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{&quot;external&quot;} type</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{Module} module</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{RuntimeSpec | boolean} runtimeCondition</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{number} index</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{string | undefined} name</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{boolean} interopNamespaceObjectUsed</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{string | undefined} interopNamespaceObjectName</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{boolean} interopNamespaceObject2Used</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{string | undefined} interopNamespaceObject2Name</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{boolean} interopDefaultAccessUsed</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{string | undefined} interopDefaultAccessName</span>
 <span class="s5">*/</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@typedef </span><span class="s5">{object} ReferenceToModuleInfo</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{&quot;reference&quot;} type</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{RuntimeSpec | boolean} runtimeCondition</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{ModuleInfo} target</span>
 <span class="s5">*/</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@template </span><span class="s5">T</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string} property property</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{function(T[keyof T], T[keyof T]): 0 | 1 | -1} comparator comparator</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{Comparator&lt;T&gt;} comparator</span>
 <span class="s5">*/</span>

<span class="s4">const </span><span class="s1">createComparator </span><span class="s3">= (</span><span class="s1">property</span><span class="s3">, </span><span class="s1">comparator</span><span class="s3">) =&gt; (</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">) =&gt;</span>
	<span class="s1">comparator</span><span class="s3">(</span>
		<span class="s1">a</span><span class="s3">[</span><span class="s5">/** </span><span class="s6">@type </span><span class="s5">{keyof T} */ </span><span class="s3">(</span><span class="s1">property</span><span class="s3">)],</span>
		<span class="s1">b</span><span class="s3">[</span><span class="s5">/** </span><span class="s6">@type </span><span class="s5">{keyof T} */ </span><span class="s3">(</span><span class="s1">property</span><span class="s3">)]</span>
	<span class="s3">);</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{number} a a</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{number} b b</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{0 | 1 | -1} result</span>
 <span class="s5">*/</span>
<span class="s4">const </span><span class="s1">compareNumbers </span><span class="s3">= (</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">) =&gt; {</span>
	<span class="s4">if </span><span class="s3">(</span><span class="s1">Number</span><span class="s3">.</span><span class="s1">isNaN</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)) {</span>
		<span class="s4">if </span><span class="s3">(!</span><span class="s1">Number</span><span class="s3">.</span><span class="s1">isNaN</span><span class="s3">(</span><span class="s1">b</span><span class="s3">)) {</span>
			<span class="s4">return </span><span class="s7">1</span><span class="s3">;</span>
		<span class="s3">}</span>
	<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">Number</span><span class="s3">.</span><span class="s1">isNaN</span><span class="s3">(</span><span class="s1">b</span><span class="s3">)) {</span>
			<span class="s4">return </span><span class="s3">-</span><span class="s7">1</span><span class="s3">;</span>
		<span class="s3">}</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">a </span><span class="s3">!== </span><span class="s1">b</span><span class="s3">) {</span>
			<span class="s4">return </span><span class="s1">a </span><span class="s3">&lt; </span><span class="s1">b </span><span class="s3">? -</span><span class="s7">1 </span><span class="s3">: </span><span class="s7">1</span><span class="s3">;</span>
		<span class="s3">}</span>
	<span class="s3">}</span>
	<span class="s4">return </span><span class="s7">0</span><span class="s3">;</span>
<span class="s3">};</span>
<span class="s4">const </span><span class="s1">bySourceOrder </span><span class="s3">= </span><span class="s1">createComparator</span><span class="s3">(</span><span class="s2">&quot;sourceOrder&quot;</span><span class="s3">, </span><span class="s1">compareNumbers</span><span class="s3">);</span>
<span class="s4">const </span><span class="s1">byRangeStart </span><span class="s3">= </span><span class="s1">createComparator</span><span class="s3">(</span><span class="s2">&quot;rangeStart&quot;</span><span class="s3">, </span><span class="s1">compareNumbers</span><span class="s3">);</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Iterable&lt;string&gt;} iterable iterable object</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{string} joined iterable object</span>
 <span class="s5">*/</span>
<span class="s4">const </span><span class="s1">joinIterableWithComma </span><span class="s3">= </span><span class="s1">iterable </span><span class="s3">=&gt; {</span>
	<span class="s0">// This is more performant than Array.from().join(&quot;, &quot;)</span>
	<span class="s0">// as it doesn't create an array</span>
	<span class="s4">let </span><span class="s1">str </span><span class="s3">= </span><span class="s2">&quot;&quot;</span><span class="s3">;</span>
	<span class="s4">let </span><span class="s1">first </span><span class="s3">= </span><span class="s4">true</span><span class="s3">;</span>
	<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">item of iterable</span><span class="s3">) {</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">first</span><span class="s3">) {</span>
			<span class="s1">first </span><span class="s3">= </span><span class="s4">false</span><span class="s3">;</span>
		<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
			<span class="s1">str </span><span class="s3">+= </span><span class="s2">&quot;, &quot;</span><span class="s3">;</span>
		<span class="s3">}</span>
		<span class="s1">str </span><span class="s3">+= </span><span class="s1">item</span><span class="s3">;</span>
	<span class="s3">}</span>
	<span class="s4">return </span><span class="s1">str</span><span class="s3">;</span>
<span class="s3">};</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@typedef </span><span class="s5">{object} ConcatenationEntry</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{&quot;concatenated&quot; | &quot;external&quot;} type</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{Module} module</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{RuntimeSpec | boolean} runtimeCondition</span>
 <span class="s5">*/</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{ModuleGraph} moduleGraph the module graph</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{ModuleInfo} info module info</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string[]} exportName exportName</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Map&lt;Module, ModuleInfo&gt;} moduleToInfoMap moduleToInfoMap</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{RuntimeSpec} runtime for which runtime</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{RequestShortener} requestShortener the request shortener</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{RuntimeTemplate} runtimeTemplate the runtime template</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Set&lt;ConcatenatedModuleInfo&gt;} neededNamespaceObjects modules for which a namespace object should be generated</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{boolean} asCall asCall</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{boolean | undefined} strictHarmonyModule strictHarmonyModule</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{boolean | undefined} asiSafe asiSafe</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Set&lt;ExportInfo&gt;} alreadyVisited alreadyVisited</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{Binding} the final variable</span>
 <span class="s5">*/</span>
<span class="s4">const </span><span class="s1">getFinalBinding </span><span class="s3">= (</span>
	<span class="s1">moduleGraph</span><span class="s3">,</span>
	<span class="s1">info</span><span class="s3">,</span>
	<span class="s1">exportName</span><span class="s3">,</span>
	<span class="s1">moduleToInfoMap</span><span class="s3">,</span>
	<span class="s1">runtime</span><span class="s3">,</span>
	<span class="s1">requestShortener</span><span class="s3">,</span>
	<span class="s1">runtimeTemplate</span><span class="s3">,</span>
	<span class="s1">neededNamespaceObjects</span><span class="s3">,</span>
	<span class="s1">asCall</span><span class="s3">,</span>
	<span class="s1">strictHarmonyModule</span><span class="s3">,</span>
	<span class="s1">asiSafe</span><span class="s3">,</span>
	<span class="s1">alreadyVisited </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">()</span>
<span class="s3">) =&gt; {</span>
	<span class="s4">const </span><span class="s1">exportsType </span><span class="s3">= </span><span class="s1">info</span><span class="s3">.</span><span class="s1">module</span><span class="s3">.</span><span class="s1">getExportsType</span><span class="s3">(</span>
		<span class="s1">moduleGraph</span><span class="s3">,</span>
		<span class="s1">strictHarmonyModule</span>
	<span class="s3">);</span>
	<span class="s4">if </span><span class="s3">(</span><span class="s1">exportName</span><span class="s3">.</span><span class="s1">length </span><span class="s3">=== </span><span class="s7">0</span><span class="s3">) {</span>
		<span class="s4">switch </span><span class="s3">(</span><span class="s1">exportsType</span><span class="s3">) {</span>
			<span class="s4">case </span><span class="s2">&quot;default-only&quot;</span><span class="s3">:</span>
				<span class="s1">info</span><span class="s3">.</span><span class="s1">interopNamespaceObject2Used </span><span class="s3">= </span><span class="s4">true</span><span class="s3">;</span>
				<span class="s4">return </span><span class="s3">{</span>
					<span class="s1">info</span><span class="s3">,</span>
					<span class="s1">rawName</span><span class="s3">: </span><span class="s5">/** </span><span class="s6">@type </span><span class="s5">{string} */ </span><span class="s3">(</span><span class="s1">info</span><span class="s3">.</span><span class="s1">interopNamespaceObject2Name</span><span class="s3">),</span>
					<span class="s1">ids</span><span class="s3">: </span><span class="s1">exportName</span><span class="s3">,</span>
					<span class="s1">exportName</span>
				<span class="s3">};</span>
			<span class="s4">case </span><span class="s2">&quot;default-with-named&quot;</span><span class="s3">:</span>
				<span class="s1">info</span><span class="s3">.</span><span class="s1">interopNamespaceObjectUsed </span><span class="s3">= </span><span class="s4">true</span><span class="s3">;</span>
				<span class="s4">return </span><span class="s3">{</span>
					<span class="s1">info</span><span class="s3">,</span>
					<span class="s1">rawName</span><span class="s3">: </span><span class="s5">/** </span><span class="s6">@type </span><span class="s5">{string} */ </span><span class="s3">(</span><span class="s1">info</span><span class="s3">.</span><span class="s1">interopNamespaceObjectName</span><span class="s3">),</span>
					<span class="s1">ids</span><span class="s3">: </span><span class="s1">exportName</span><span class="s3">,</span>
					<span class="s1">exportName</span>
				<span class="s3">};</span>
			<span class="s4">case </span><span class="s2">&quot;namespace&quot;</span><span class="s3">:</span>
			<span class="s4">case </span><span class="s2">&quot;dynamic&quot;</span><span class="s3">:</span>
				<span class="s4">break</span><span class="s3">;</span>
			<span class="s4">default</span><span class="s3">:</span>
				<span class="s4">throw new </span><span class="s1">Error</span><span class="s3">(</span><span class="s2">`Unexpected exportsType </span><span class="s1">$</span><span class="s3">{</span><span class="s1">exportsType</span><span class="s3">}</span><span class="s2">`</span><span class="s3">);</span>
		<span class="s3">}</span>
	<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
		<span class="s4">switch </span><span class="s3">(</span><span class="s1">exportsType</span><span class="s3">) {</span>
			<span class="s4">case </span><span class="s2">&quot;namespace&quot;</span><span class="s3">:</span>
				<span class="s4">break</span><span class="s3">;</span>
			<span class="s4">case </span><span class="s2">&quot;default-with-named&quot;</span><span class="s3">:</span>
				<span class="s4">switch </span><span class="s3">(</span><span class="s1">exportName</span><span class="s3">[</span><span class="s7">0</span><span class="s3">]) {</span>
					<span class="s4">case </span><span class="s2">&quot;default&quot;</span><span class="s3">:</span>
						<span class="s1">exportName </span><span class="s3">= </span><span class="s1">exportName</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span><span class="s7">1</span><span class="s3">);</span>
						<span class="s4">break</span><span class="s3">;</span>
					<span class="s4">case </span><span class="s2">&quot;__esModule&quot;</span><span class="s3">:</span>
						<span class="s4">return </span><span class="s3">{</span>
							<span class="s1">info</span><span class="s3">,</span>
							<span class="s1">rawName</span><span class="s3">: </span><span class="s2">&quot;/* __esModule */true&quot;</span><span class="s3">,</span>
							<span class="s1">ids</span><span class="s3">: </span><span class="s1">exportName</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span><span class="s7">1</span><span class="s3">),</span>
							<span class="s1">exportName</span>
						<span class="s3">};</span>
				<span class="s3">}</span>
				<span class="s4">break</span><span class="s3">;</span>
			<span class="s4">case </span><span class="s2">&quot;default-only&quot;</span><span class="s3">: {</span>
				<span class="s4">const </span><span class="s1">exportId </span><span class="s3">= </span><span class="s1">exportName</span><span class="s3">[</span><span class="s7">0</span><span class="s3">];</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">exportId </span><span class="s3">=== </span><span class="s2">&quot;__esModule&quot;</span><span class="s3">) {</span>
					<span class="s4">return </span><span class="s3">{</span>
						<span class="s1">info</span><span class="s3">,</span>
						<span class="s1">rawName</span><span class="s3">: </span><span class="s2">&quot;/* __esModule */true&quot;</span><span class="s3">,</span>
						<span class="s1">ids</span><span class="s3">: </span><span class="s1">exportName</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span><span class="s7">1</span><span class="s3">),</span>
						<span class="s1">exportName</span>
					<span class="s3">};</span>
				<span class="s3">}</span>
				<span class="s1">exportName </span><span class="s3">= </span><span class="s1">exportName</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span><span class="s7">1</span><span class="s3">);</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">exportId </span><span class="s3">!== </span><span class="s2">&quot;default&quot;</span><span class="s3">) {</span>
					<span class="s4">return </span><span class="s3">{</span>
						<span class="s1">info</span><span class="s3">,</span>
						<span class="s1">rawName</span><span class="s3">:</span>
							<span class="s2">&quot;/* non-default import from default-exporting module */undefined&quot;</span><span class="s3">,</span>
						<span class="s1">ids</span><span class="s3">: </span><span class="s1">exportName</span><span class="s3">,</span>
						<span class="s1">exportName</span>
					<span class="s3">};</span>
				<span class="s3">}</span>
				<span class="s4">break</span><span class="s3">;</span>
			<span class="s3">}</span>
			<span class="s4">case </span><span class="s2">&quot;dynamic&quot;</span><span class="s3">:</span>
				<span class="s4">switch </span><span class="s3">(</span><span class="s1">exportName</span><span class="s3">[</span><span class="s7">0</span><span class="s3">]) {</span>
					<span class="s4">case </span><span class="s2">&quot;default&quot;</span><span class="s3">: {</span>
						<span class="s1">exportName </span><span class="s3">= </span><span class="s1">exportName</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span><span class="s7">1</span><span class="s3">);</span>
						<span class="s1">info</span><span class="s3">.</span><span class="s1">interopDefaultAccessUsed </span><span class="s3">= </span><span class="s4">true</span><span class="s3">;</span>
						<span class="s4">const </span><span class="s1">defaultExport </span><span class="s3">= </span><span class="s1">asCall</span>
							<span class="s3">? </span><span class="s2">`</span><span class="s1">$</span><span class="s3">{</span><span class="s1">info</span><span class="s3">.</span><span class="s1">interopDefaultAccessName</span><span class="s3">}</span><span class="s2">()`</span>
							<span class="s3">: </span><span class="s1">asiSafe</span>
								<span class="s3">? </span><span class="s2">`(</span><span class="s1">$</span><span class="s3">{</span><span class="s1">info</span><span class="s3">.</span><span class="s1">interopDefaultAccessName</span><span class="s3">}</span><span class="s2">())`</span>
								<span class="s3">: </span><span class="s1">asiSafe </span><span class="s3">=== </span><span class="s4">false</span>
									<span class="s3">? </span><span class="s2">`;(</span><span class="s1">$</span><span class="s3">{</span><span class="s1">info</span><span class="s3">.</span><span class="s1">interopDefaultAccessName</span><span class="s3">}</span><span class="s2">())`</span>
									<span class="s3">: </span><span class="s2">`</span><span class="s1">$</span><span class="s3">{</span><span class="s1">info</span><span class="s3">.</span><span class="s1">interopDefaultAccessName</span><span class="s3">}</span><span class="s2">.a`</span><span class="s3">;</span>
						<span class="s4">return </span><span class="s3">{</span>
							<span class="s1">info</span><span class="s3">,</span>
							<span class="s1">rawName</span><span class="s3">: </span><span class="s1">defaultExport</span><span class="s3">,</span>
							<span class="s1">ids</span><span class="s3">: </span><span class="s1">exportName</span><span class="s3">,</span>
							<span class="s1">exportName</span>
						<span class="s3">};</span>
					<span class="s3">}</span>
					<span class="s4">case </span><span class="s2">&quot;__esModule&quot;</span><span class="s3">:</span>
						<span class="s4">return </span><span class="s3">{</span>
							<span class="s1">info</span><span class="s3">,</span>
							<span class="s1">rawName</span><span class="s3">: </span><span class="s2">&quot;/* __esModule */true&quot;</span><span class="s3">,</span>
							<span class="s1">ids</span><span class="s3">: </span><span class="s1">exportName</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span><span class="s7">1</span><span class="s3">),</span>
							<span class="s1">exportName</span>
						<span class="s3">};</span>
				<span class="s3">}</span>
				<span class="s4">break</span><span class="s3">;</span>
			<span class="s4">default</span><span class="s3">:</span>
				<span class="s4">throw new </span><span class="s1">Error</span><span class="s3">(</span><span class="s2">`Unexpected exportsType </span><span class="s1">$</span><span class="s3">{</span><span class="s1">exportsType</span><span class="s3">}</span><span class="s2">`</span><span class="s3">);</span>
		<span class="s3">}</span>
	<span class="s3">}</span>
	<span class="s4">if </span><span class="s3">(</span><span class="s1">exportName</span><span class="s3">.</span><span class="s1">length </span><span class="s3">=== </span><span class="s7">0</span><span class="s3">) {</span>
		<span class="s4">switch </span><span class="s3">(</span><span class="s1">info</span><span class="s3">.</span><span class="s1">type</span><span class="s3">) {</span>
			<span class="s4">case </span><span class="s2">&quot;concatenated&quot;</span><span class="s3">:</span>
				<span class="s1">neededNamespaceObjects</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">info</span><span class="s3">);</span>
				<span class="s4">return </span><span class="s3">{</span>
					<span class="s1">info</span><span class="s3">,</span>
					<span class="s1">rawName</span><span class="s3">:</span>
						<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{NonNullable&lt;ConcatenatedModuleInfo[&quot;namespaceObjectName&quot;]&gt;} */</span>
						<span class="s3">(</span><span class="s1">info</span><span class="s3">.</span><span class="s1">namespaceObjectName</span><span class="s3">),</span>
					<span class="s1">ids</span><span class="s3">: </span><span class="s1">exportName</span><span class="s3">,</span>
					<span class="s1">exportName</span>
				<span class="s3">};</span>
			<span class="s4">case </span><span class="s2">&quot;external&quot;</span><span class="s3">:</span>
				<span class="s4">return </span><span class="s3">{</span>
					<span class="s1">info</span><span class="s3">,</span>
					<span class="s1">rawName</span><span class="s3">:</span>
						<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{NonNullable&lt;ExternalModuleInfo[&quot;name&quot;]&gt;} */</span>
						<span class="s3">(</span><span class="s1">info</span><span class="s3">.</span><span class="s1">name</span><span class="s3">),</span>
					<span class="s1">ids</span><span class="s3">: </span><span class="s1">exportName</span><span class="s3">,</span>
					<span class="s1">exportName</span>
				<span class="s3">};</span>
		<span class="s3">}</span>
	<span class="s3">}</span>
	<span class="s4">const </span><span class="s1">exportsInfo </span><span class="s3">= </span><span class="s1">moduleGraph</span><span class="s3">.</span><span class="s1">getExportsInfo</span><span class="s3">(</span><span class="s1">info</span><span class="s3">.</span><span class="s1">module</span><span class="s3">);</span>
	<span class="s4">const </span><span class="s1">exportInfo </span><span class="s3">= </span><span class="s1">exportsInfo</span><span class="s3">.</span><span class="s1">getExportInfo</span><span class="s3">(</span><span class="s1">exportName</span><span class="s3">[</span><span class="s7">0</span><span class="s3">]);</span>
	<span class="s4">if </span><span class="s3">(</span><span class="s1">alreadyVisited</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s1">exportInfo</span><span class="s3">)) {</span>
		<span class="s4">return </span><span class="s3">{</span>
			<span class="s1">info</span><span class="s3">,</span>
			<span class="s1">rawName</span><span class="s3">: </span><span class="s2">&quot;/* circular reexport */ Object(function x() { x() }())&quot;</span><span class="s3">,</span>
			<span class="s1">ids</span><span class="s3">: [],</span>
			<span class="s1">exportName</span>
		<span class="s3">};</span>
	<span class="s3">}</span>
	<span class="s1">alreadyVisited</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">exportInfo</span><span class="s3">);</span>
	<span class="s4">switch </span><span class="s3">(</span><span class="s1">info</span><span class="s3">.</span><span class="s1">type</span><span class="s3">) {</span>
		<span class="s4">case </span><span class="s2">&quot;concatenated&quot;</span><span class="s3">: {</span>
			<span class="s4">const </span><span class="s1">exportId </span><span class="s3">= </span><span class="s1">exportName</span><span class="s3">[</span><span class="s7">0</span><span class="s3">];</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">exportInfo</span><span class="s3">.</span><span class="s1">provided </span><span class="s3">=== </span><span class="s4">false</span><span class="s3">) {</span>
				<span class="s0">// It's not provided, but it could be on the prototype</span>
				<span class="s1">neededNamespaceObjects</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">info</span><span class="s3">);</span>
				<span class="s4">return </span><span class="s3">{</span>
					<span class="s1">info</span><span class="s3">,</span>
					<span class="s1">rawName</span><span class="s3">: </span><span class="s5">/** </span><span class="s6">@type </span><span class="s5">{string} */ </span><span class="s3">(</span><span class="s1">info</span><span class="s3">.</span><span class="s1">namespaceObjectName</span><span class="s3">),</span>
					<span class="s1">ids</span><span class="s3">: </span><span class="s1">exportName</span><span class="s3">,</span>
					<span class="s1">exportName</span>
				<span class="s3">};</span>
			<span class="s3">}</span>
			<span class="s4">const </span><span class="s1">directExport </span><span class="s3">= </span><span class="s1">info</span><span class="s3">.</span><span class="s1">exportMap </span><span class="s3">&amp;&amp; </span><span class="s1">info</span><span class="s3">.</span><span class="s1">exportMap</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">exportId</span><span class="s3">);</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">directExport</span><span class="s3">) {</span>
				<span class="s4">const </span><span class="s1">usedName </span><span class="s3">= </span><span class="s5">/** </span><span class="s6">@type </span><span class="s5">{string[]} */ </span><span class="s3">(</span>
					<span class="s1">exportsInfo</span><span class="s3">.</span><span class="s1">getUsedName</span><span class="s3">(</span><span class="s1">exportName</span><span class="s3">, </span><span class="s1">runtime</span><span class="s3">)</span>
				<span class="s3">);</span>
				<span class="s4">if </span><span class="s3">(!</span><span class="s1">usedName</span><span class="s3">) {</span>
					<span class="s4">return </span><span class="s3">{</span>
						<span class="s1">info</span><span class="s3">,</span>
						<span class="s1">rawName</span><span class="s3">: </span><span class="s2">&quot;/* unused export */ undefined&quot;</span><span class="s3">,</span>
						<span class="s1">ids</span><span class="s3">: </span><span class="s1">exportName</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span><span class="s7">1</span><span class="s3">),</span>
						<span class="s1">exportName</span>
					<span class="s3">};</span>
				<span class="s3">}</span>
				<span class="s4">return </span><span class="s3">{</span>
					<span class="s1">info</span><span class="s3">,</span>
					<span class="s1">name</span><span class="s3">: </span><span class="s1">directExport</span><span class="s3">,</span>
					<span class="s1">ids</span><span class="s3">: </span><span class="s1">usedName</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span><span class="s7">1</span><span class="s3">),</span>
					<span class="s1">exportName</span>
				<span class="s3">};</span>
			<span class="s3">}</span>
			<span class="s4">const </span><span class="s1">rawExport </span><span class="s3">= </span><span class="s1">info</span><span class="s3">.</span><span class="s1">rawExportMap </span><span class="s3">&amp;&amp; </span><span class="s1">info</span><span class="s3">.</span><span class="s1">rawExportMap</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">exportId</span><span class="s3">);</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">rawExport</span><span class="s3">) {</span>
				<span class="s4">return </span><span class="s3">{</span>
					<span class="s1">info</span><span class="s3">,</span>
					<span class="s1">rawName</span><span class="s3">: </span><span class="s1">rawExport</span><span class="s3">,</span>
					<span class="s1">ids</span><span class="s3">: </span><span class="s1">exportName</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span><span class="s7">1</span><span class="s3">),</span>
					<span class="s1">exportName</span>
				<span class="s3">};</span>
			<span class="s3">}</span>
			<span class="s4">const </span><span class="s1">reexport </span><span class="s3">= </span><span class="s1">exportInfo</span><span class="s3">.</span><span class="s1">findTarget</span><span class="s3">(</span><span class="s1">moduleGraph</span><span class="s3">, </span><span class="s1">module </span><span class="s3">=&gt;</span>
				<span class="s1">moduleToInfoMap</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s1">module</span><span class="s3">)</span>
			<span class="s3">);</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">reexport </span><span class="s3">=== </span><span class="s4">false</span><span class="s3">) {</span>
				<span class="s4">throw new </span><span class="s1">Error</span><span class="s3">(</span>
					<span class="s2">`Target module of reexport from '</span><span class="s1">$</span><span class="s3">{</span><span class="s1">info</span><span class="s3">.</span><span class="s1">module</span><span class="s3">.</span><span class="s1">readableIdentifier</span><span class="s3">(</span>
						<span class="s1">requestShortener</span>
					<span class="s3">)}</span><span class="s2">' is not part of the concatenation (export '</span><span class="s1">$</span><span class="s3">{</span><span class="s1">exportId</span><span class="s3">}</span><span class="s2">')</span><span class="s4">\n</span><span class="s2">Modules in the concatenation:</span><span class="s4">\n</span><span class="s1">$</span><span class="s3">{</span><span class="s1">Array</span><span class="s3">.</span><span class="s1">from</span><span class="s3">(</span>
						<span class="s1">moduleToInfoMap</span><span class="s3">,</span>
						<span class="s3">([</span><span class="s1">m</span><span class="s3">, </span><span class="s1">info</span><span class="s3">]) =&gt;</span>
							<span class="s2">` * </span><span class="s1">$</span><span class="s3">{</span><span class="s1">info</span><span class="s3">.</span><span class="s1">type</span><span class="s3">} </span><span class="s1">$</span><span class="s3">{</span><span class="s1">m</span><span class="s3">.</span><span class="s1">readableIdentifier</span><span class="s3">(</span><span class="s1">requestShortener</span><span class="s3">)}</span><span class="s2">`</span>
					<span class="s3">).</span><span class="s1">join</span><span class="s3">(</span><span class="s2">&quot;</span><span class="s4">\n</span><span class="s2">&quot;</span><span class="s3">)}</span><span class="s2">`</span>
				<span class="s3">);</span>
			<span class="s3">}</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">reexport</span><span class="s3">) {</span>
				<span class="s4">const </span><span class="s1">refInfo </span><span class="s3">= </span><span class="s1">moduleToInfoMap</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">reexport</span><span class="s3">.</span><span class="s1">module</span><span class="s3">);</span>
				<span class="s4">return </span><span class="s1">getFinalBinding</span><span class="s3">(</span>
					<span class="s1">moduleGraph</span><span class="s3">,</span>
					<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{ModuleInfo} */ </span><span class="s3">(</span><span class="s1">refInfo</span><span class="s3">),</span>
					<span class="s1">reexport</span><span class="s3">.</span><span class="s1">export</span>
						<span class="s3">? [</span><span class="s1">...reexport</span><span class="s3">.</span><span class="s1">export</span><span class="s3">, </span><span class="s1">...exportName</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span><span class="s7">1</span><span class="s3">)]</span>
						<span class="s3">: </span><span class="s1">exportName</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span><span class="s7">1</span><span class="s3">),</span>
					<span class="s1">moduleToInfoMap</span><span class="s3">,</span>
					<span class="s1">runtime</span><span class="s3">,</span>
					<span class="s1">requestShortener</span><span class="s3">,</span>
					<span class="s1">runtimeTemplate</span><span class="s3">,</span>
					<span class="s1">neededNamespaceObjects</span><span class="s3">,</span>
					<span class="s1">asCall</span><span class="s3">,</span>
					<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{BuildMeta} */</span>
					<span class="s3">(</span><span class="s1">info</span><span class="s3">.</span><span class="s1">module</span><span class="s3">.</span><span class="s1">buildMeta</span><span class="s3">).</span><span class="s1">strictHarmonyModule</span><span class="s3">,</span>
					<span class="s1">asiSafe</span><span class="s3">,</span>
					<span class="s1">alreadyVisited</span>
				<span class="s3">);</span>
			<span class="s3">}</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">info</span><span class="s3">.</span><span class="s1">namespaceExportSymbol</span><span class="s3">) {</span>
				<span class="s4">const </span><span class="s1">usedName </span><span class="s3">= </span><span class="s5">/** </span><span class="s6">@type </span><span class="s5">{string[]} */ </span><span class="s3">(</span>
					<span class="s1">exportsInfo</span><span class="s3">.</span><span class="s1">getUsedName</span><span class="s3">(</span><span class="s1">exportName</span><span class="s3">, </span><span class="s1">runtime</span><span class="s3">)</span>
				<span class="s3">);</span>
				<span class="s4">return </span><span class="s3">{</span>
					<span class="s1">info</span><span class="s3">,</span>
					<span class="s1">rawName</span><span class="s3">: </span><span class="s5">/** </span><span class="s6">@type </span><span class="s5">{string} */ </span><span class="s3">(</span><span class="s1">info</span><span class="s3">.</span><span class="s1">namespaceObjectName</span><span class="s3">),</span>
					<span class="s1">ids</span><span class="s3">: </span><span class="s1">usedName</span><span class="s3">,</span>
					<span class="s1">exportName</span>
				<span class="s3">};</span>
			<span class="s3">}</span>
			<span class="s4">throw new </span><span class="s1">Error</span><span class="s3">(</span>
				<span class="s2">`Cannot get final name for export '</span><span class="s1">$</span><span class="s3">{</span><span class="s1">exportName</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span>
					<span class="s2">&quot;.&quot;</span>
				<span class="s3">)}</span><span class="s2">' of </span><span class="s1">$</span><span class="s3">{</span><span class="s1">info</span><span class="s3">.</span><span class="s1">module</span><span class="s3">.</span><span class="s1">readableIdentifier</span><span class="s3">(</span><span class="s1">requestShortener</span><span class="s3">)}</span><span class="s2">`</span>
			<span class="s3">);</span>
		<span class="s3">}</span>

		<span class="s4">case </span><span class="s2">&quot;external&quot;</span><span class="s3">: {</span>
			<span class="s4">const </span><span class="s1">used </span><span class="s3">= </span><span class="s5">/** </span><span class="s6">@type </span><span class="s5">{string[]} */ </span><span class="s3">(</span>
				<span class="s1">exportsInfo</span><span class="s3">.</span><span class="s1">getUsedName</span><span class="s3">(</span><span class="s1">exportName</span><span class="s3">, </span><span class="s1">runtime</span><span class="s3">)</span>
			<span class="s3">);</span>
			<span class="s4">if </span><span class="s3">(!</span><span class="s1">used</span><span class="s3">) {</span>
				<span class="s4">return </span><span class="s3">{</span>
					<span class="s1">info</span><span class="s3">,</span>
					<span class="s1">rawName</span><span class="s3">: </span><span class="s2">&quot;/* unused export */ undefined&quot;</span><span class="s3">,</span>
					<span class="s1">ids</span><span class="s3">: </span><span class="s1">exportName</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span><span class="s7">1</span><span class="s3">),</span>
					<span class="s1">exportName</span>
				<span class="s3">};</span>
			<span class="s3">}</span>
			<span class="s4">const </span><span class="s1">comment </span><span class="s3">= </span><span class="s1">equals</span><span class="s3">(</span><span class="s1">used</span><span class="s3">, </span><span class="s1">exportName</span><span class="s3">)</span>
				<span class="s3">? </span><span class="s2">&quot;&quot;</span>
				<span class="s3">: </span><span class="s1">Template</span><span class="s3">.</span><span class="s1">toNormalComment</span><span class="s3">(</span><span class="s2">`</span><span class="s1">$</span><span class="s3">{</span><span class="s1">exportName</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s2">&quot;.&quot;</span><span class="s3">)}</span><span class="s2">`</span><span class="s3">);</span>
			<span class="s4">return </span><span class="s3">{ </span><span class="s1">info</span><span class="s3">, </span><span class="s1">rawName</span><span class="s3">: </span><span class="s1">info</span><span class="s3">.</span><span class="s1">name </span><span class="s3">+ </span><span class="s1">comment</span><span class="s3">, </span><span class="s1">ids</span><span class="s3">: </span><span class="s1">used</span><span class="s3">, </span><span class="s1">exportName </span><span class="s3">};</span>
		<span class="s3">}</span>
	<span class="s3">}</span>
<span class="s3">};</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{ModuleGraph} moduleGraph the module graph</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{ModuleInfo} info module info</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string[]} exportName exportName</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Map&lt;Module, ModuleInfo&gt;} moduleToInfoMap moduleToInfoMap</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{RuntimeSpec} runtime for which runtime</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{RequestShortener} requestShortener the request shortener</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{RuntimeTemplate} runtimeTemplate the runtime template</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Set&lt;ConcatenatedModuleInfo&gt;} neededNamespaceObjects modules for which a namespace object should be generated</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{boolean} asCall asCall</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{boolean | undefined} callContext callContext</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{boolean | undefined} strictHarmonyModule strictHarmonyModule</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{boolean | undefined} asiSafe asiSafe</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{string} the final name</span>
 <span class="s5">*/</span>
<span class="s4">const </span><span class="s1">getFinalName </span><span class="s3">= (</span>
	<span class="s1">moduleGraph</span><span class="s3">,</span>
	<span class="s1">info</span><span class="s3">,</span>
	<span class="s1">exportName</span><span class="s3">,</span>
	<span class="s1">moduleToInfoMap</span><span class="s3">,</span>
	<span class="s1">runtime</span><span class="s3">,</span>
	<span class="s1">requestShortener</span><span class="s3">,</span>
	<span class="s1">runtimeTemplate</span><span class="s3">,</span>
	<span class="s1">neededNamespaceObjects</span><span class="s3">,</span>
	<span class="s1">asCall</span><span class="s3">,</span>
	<span class="s1">callContext</span><span class="s3">,</span>
	<span class="s1">strictHarmonyModule</span><span class="s3">,</span>
	<span class="s1">asiSafe</span>
<span class="s3">) =&gt; {</span>
	<span class="s4">const </span><span class="s1">binding </span><span class="s3">= </span><span class="s1">getFinalBinding</span><span class="s3">(</span>
		<span class="s1">moduleGraph</span><span class="s3">,</span>
		<span class="s1">info</span><span class="s3">,</span>
		<span class="s1">exportName</span><span class="s3">,</span>
		<span class="s1">moduleToInfoMap</span><span class="s3">,</span>
		<span class="s1">runtime</span><span class="s3">,</span>
		<span class="s1">requestShortener</span><span class="s3">,</span>
		<span class="s1">runtimeTemplate</span><span class="s3">,</span>
		<span class="s1">neededNamespaceObjects</span><span class="s3">,</span>
		<span class="s1">asCall</span><span class="s3">,</span>
		<span class="s1">strictHarmonyModule</span><span class="s3">,</span>
		<span class="s1">asiSafe</span>
	<span class="s3">);</span>
	<span class="s3">{</span>
		<span class="s4">const </span><span class="s3">{ </span><span class="s1">ids</span><span class="s3">, </span><span class="s1">comment </span><span class="s3">} = </span><span class="s1">binding</span><span class="s3">;</span>
		<span class="s4">let </span><span class="s1">reference</span><span class="s3">;</span>
		<span class="s4">let </span><span class="s1">isPropertyAccess</span><span class="s3">;</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s2">&quot;rawName&quot; </span><span class="s4">in </span><span class="s1">binding</span><span class="s3">) {</span>
			<span class="s1">reference </span><span class="s3">= </span><span class="s2">`</span><span class="s1">$</span><span class="s3">{</span><span class="s1">binding</span><span class="s3">.</span><span class="s1">rawName</span><span class="s3">}</span><span class="s1">$</span><span class="s3">{</span><span class="s1">comment </span><span class="s3">|| </span><span class="s2">&quot;&quot;</span><span class="s3">}</span><span class="s1">$</span><span class="s3">{</span><span class="s1">propertyAccess</span><span class="s3">(</span><span class="s1">ids</span><span class="s3">)}</span><span class="s2">`</span><span class="s3">;</span>
			<span class="s1">isPropertyAccess </span><span class="s3">= </span><span class="s1">ids</span><span class="s3">.</span><span class="s1">length </span><span class="s3">&gt; </span><span class="s7">0</span><span class="s3">;</span>
		<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
			<span class="s4">const </span><span class="s3">{ </span><span class="s1">info</span><span class="s3">, </span><span class="s1">name</span><span class="s3">: </span><span class="s1">exportId </span><span class="s3">} = </span><span class="s1">binding</span><span class="s3">;</span>
			<span class="s4">const </span><span class="s1">name </span><span class="s3">= </span><span class="s1">info</span><span class="s3">.</span><span class="s1">internalNames</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">exportId</span><span class="s3">);</span>
			<span class="s4">if </span><span class="s3">(!</span><span class="s1">name</span><span class="s3">) {</span>
				<span class="s4">throw new </span><span class="s1">Error</span><span class="s3">(</span>
					<span class="s2">`The export &quot;</span><span class="s1">$</span><span class="s3">{</span><span class="s1">exportId</span><span class="s3">}</span><span class="s2">&quot; in &quot;</span><span class="s1">$</span><span class="s3">{</span><span class="s1">info</span><span class="s3">.</span><span class="s1">module</span><span class="s3">.</span><span class="s1">readableIdentifier</span><span class="s3">(</span>
						<span class="s1">requestShortener</span>
					<span class="s3">)}</span><span class="s2">&quot; has no internal name (existing names: </span><span class="s1">$</span><span class="s3">{</span>
						<span class="s1">Array</span><span class="s3">.</span><span class="s1">from</span><span class="s3">(</span>
							<span class="s1">info</span><span class="s3">.</span><span class="s1">internalNames</span><span class="s3">,</span>
							<span class="s3">([</span><span class="s1">name</span><span class="s3">, </span><span class="s1">symbol</span><span class="s3">]) =&gt; </span><span class="s2">`</span><span class="s1">$</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s2">: </span><span class="s1">$</span><span class="s3">{</span><span class="s1">symbol</span><span class="s3">}</span><span class="s2">`</span>
						<span class="s3">).</span><span class="s1">join</span><span class="s3">(</span><span class="s2">&quot;, &quot;</span><span class="s3">) || </span><span class="s2">&quot;none&quot;</span>
					<span class="s3">}</span><span class="s2">)`</span>
				<span class="s3">);</span>
			<span class="s3">}</span>
			<span class="s1">reference </span><span class="s3">= </span><span class="s2">`</span><span class="s1">$</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s1">$</span><span class="s3">{</span><span class="s1">comment </span><span class="s3">|| </span><span class="s2">&quot;&quot;</span><span class="s3">}</span><span class="s1">$</span><span class="s3">{</span><span class="s1">propertyAccess</span><span class="s3">(</span><span class="s1">ids</span><span class="s3">)}</span><span class="s2">`</span><span class="s3">;</span>
			<span class="s1">isPropertyAccess </span><span class="s3">= </span><span class="s1">ids</span><span class="s3">.</span><span class="s1">length </span><span class="s3">&gt; </span><span class="s7">1</span><span class="s3">;</span>
		<span class="s3">}</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">isPropertyAccess </span><span class="s3">&amp;&amp; </span><span class="s1">asCall </span><span class="s3">&amp;&amp; </span><span class="s1">callContext </span><span class="s3">=== </span><span class="s4">false</span><span class="s3">) {</span>
			<span class="s4">return </span><span class="s1">asiSafe</span>
				<span class="s3">? </span><span class="s2">`(0,</span><span class="s1">$</span><span class="s3">{</span><span class="s1">reference</span><span class="s3">}</span><span class="s2">)`</span>
				<span class="s3">: </span><span class="s1">asiSafe </span><span class="s3">=== </span><span class="s4">false</span>
					<span class="s3">? </span><span class="s2">`;(0,</span><span class="s1">$</span><span class="s3">{</span><span class="s1">reference</span><span class="s3">}</span><span class="s2">)`</span>
					<span class="s3">: </span><span class="s2">`/*#__PURE__*/Object(</span><span class="s1">$</span><span class="s3">{</span><span class="s1">reference</span><span class="s3">}</span><span class="s2">)`</span><span class="s3">;</span>
		<span class="s3">}</span>
		<span class="s4">return </span><span class="s1">reference</span><span class="s3">;</span>
	<span class="s3">}</span>
<span class="s3">};</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@typedef </span><span class="s5">{object} ConcatenateModuleHooks</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{SyncBailHook&lt;[Record&lt;string, string&gt;, ConcatenatedModule], boolean | void&gt;} exportsDefinitions</span>
 <span class="s5">*/</span>

<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{WeakMap&lt;Compilation, ConcatenateModuleHooks&gt;} */</span>
<span class="s4">const </span><span class="s1">compilationHooksMap </span><span class="s3">= </span><span class="s4">new </span><span class="s1">WeakMap</span><span class="s3">();</span>

<span class="s4">class </span><span class="s1">ConcatenatedModule </span><span class="s4">extends </span><span class="s1">Module </span><span class="s3">{</span>
	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} rootModule the root module of the concatenation</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Set&lt;Module&gt;} modules all modules in the concatenation (including the root module)</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{RuntimeSpec} runtime the runtime</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Compilation} compilation the compilation</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{AssociatedObjectForCache=} associatedObjectForCache object for caching</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string | HashConstructor=} hashFunction hash function to use</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{ConcatenatedModule} the module</span>
	 <span class="s5">*/</span>
	<span class="s4">static </span><span class="s1">create</span><span class="s3">(</span>
		<span class="s1">rootModule</span><span class="s3">,</span>
		<span class="s1">modules</span><span class="s3">,</span>
		<span class="s1">runtime</span><span class="s3">,</span>
		<span class="s1">compilation</span><span class="s3">,</span>
		<span class="s1">associatedObjectForCache</span><span class="s3">,</span>
		<span class="s1">hashFunction </span><span class="s3">= </span><span class="s1">DEFAULTS</span><span class="s3">.</span><span class="s1">HASH_FUNCTION</span>
	<span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">identifier </span><span class="s3">= </span><span class="s1">ConcatenatedModule</span><span class="s3">.</span><span class="s1">_createIdentifier</span><span class="s3">(</span>
			<span class="s1">rootModule</span><span class="s3">,</span>
			<span class="s1">modules</span><span class="s3">,</span>
			<span class="s1">associatedObjectForCache</span><span class="s3">,</span>
			<span class="s1">hashFunction</span>
		<span class="s3">);</span>
		<span class="s4">return new </span><span class="s1">ConcatenatedModule</span><span class="s3">({</span>
			<span class="s1">identifier</span><span class="s3">,</span>
			<span class="s1">rootModule</span><span class="s3">,</span>
			<span class="s1">modules</span><span class="s3">,</span>
			<span class="s1">runtime</span><span class="s3">,</span>
			<span class="s1">compilation</span>
		<span class="s3">});</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Compilation} compilation the compilation</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{ConcatenateModuleHooks} the attached hooks</span>
	 <span class="s5">*/</span>
	<span class="s4">static </span><span class="s1">getCompilationHooks</span><span class="s3">(</span><span class="s1">compilation</span><span class="s3">) {</span>
		<span class="s4">let </span><span class="s1">hooks </span><span class="s3">= </span><span class="s1">compilationHooksMap</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">compilation</span><span class="s3">);</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">hooks </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) {</span>
			<span class="s1">hooks </span><span class="s3">= {</span>
				<span class="s1">exportsDefinitions</span><span class="s3">: </span><span class="s4">new </span><span class="s1">SyncBailHook</span><span class="s3">([</span><span class="s2">&quot;definitions&quot;</span><span class="s3">, </span><span class="s2">&quot;module&quot;</span><span class="s3">])</span>
			<span class="s3">};</span>
			<span class="s1">compilationHooksMap</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">compilation</span><span class="s3">, </span><span class="s1">hooks</span><span class="s3">);</span>
		<span class="s3">}</span>
		<span class="s4">return </span><span class="s1">hooks</span><span class="s3">;</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{object} options options</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string} options.identifier the identifier of the module</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} options.rootModule the root module of the concatenation</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{RuntimeSpec} options.runtime the selected runtime</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Set&lt;Module&gt;} options.modules all concatenated modules</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Compilation} options.compilation the compilation</span>
	 <span class="s5">*/</span>
	<span class="s1">constructor</span><span class="s3">({ </span><span class="s1">identifier</span><span class="s3">, </span><span class="s1">rootModule</span><span class="s3">, </span><span class="s1">modules</span><span class="s3">, </span><span class="s1">runtime</span><span class="s3">, </span><span class="s1">compilation </span><span class="s3">}) {</span>
		<span class="s4">super</span><span class="s3">(</span><span class="s1">JAVASCRIPT_MODULE_TYPE_ESM</span><span class="s3">, </span><span class="s4">null</span><span class="s3">, </span><span class="s1">rootModule </span><span class="s3">&amp;&amp; </span><span class="s1">rootModule</span><span class="s3">.</span><span class="s1">layer</span><span class="s3">);</span>

		<span class="s0">// Info from Factory</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{string} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">_identifier </span><span class="s3">= </span><span class="s1">identifier</span><span class="s3">;</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Module} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">rootModule </span><span class="s3">= </span><span class="s1">rootModule</span><span class="s3">;</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Set&lt;Module&gt;} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">_modules </span><span class="s3">= </span><span class="s1">modules</span><span class="s3">;</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">_runtime </span><span class="s3">= </span><span class="s1">runtime</span><span class="s3">;</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">factoryMeta </span><span class="s3">= </span><span class="s1">rootModule </span><span class="s3">&amp;&amp; </span><span class="s1">rootModule</span><span class="s3">.</span><span class="s1">factoryMeta</span><span class="s3">;</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Compilation | undefined} */</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">compilation </span><span class="s3">= </span><span class="s1">compilation</span><span class="s3">;</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* Assuming this module is in the cache. Update the (cached) module with</span>
	 <span class="s5">* the fresh module from the factory. Usually updates internal references</span>
	 <span class="s5">* and properties.</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} module fresh module</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
	 <span class="s5">*/</span>
	<span class="s1">updateCacheModule</span><span class="s3">(</span><span class="s1">module</span><span class="s3">) {</span>
		<span class="s4">throw new </span><span class="s1">Error</span><span class="s3">(</span><span class="s2">&quot;Must not be called&quot;</span><span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{SourceTypes} types available (do not mutate)</span>
	 <span class="s5">*/</span>
	<span class="s1">getSourceTypes</span><span class="s3">() {</span>
		<span class="s4">return </span><span class="s1">JS_TYPES</span><span class="s3">;</span>
	<span class="s3">}</span>

	<span class="s1">get modules</span><span class="s3">() {</span>
		<span class="s4">return </span><span class="s1">Array</span><span class="s3">.</span><span class="s1">from</span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">_modules</span><span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{string} a unique identifier of the module</span>
	 <span class="s5">*/</span>
	<span class="s1">identifier</span><span class="s3">() {</span>
		<span class="s4">return this</span><span class="s3">.</span><span class="s1">_identifier</span><span class="s3">;</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{RequestShortener} requestShortener the request shortener</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{string} a user readable identifier of the module</span>
	 <span class="s5">*/</span>
	<span class="s1">readableIdentifier</span><span class="s3">(</span><span class="s1">requestShortener</span><span class="s3">) {</span>
		<span class="s4">return </span><span class="s2">`</span><span class="s1">$</span><span class="s3">{</span><span class="s4">this</span><span class="s3">.</span><span class="s1">rootModule</span><span class="s3">.</span><span class="s1">readableIdentifier</span><span class="s3">(</span>
			<span class="s1">requestShortener</span>
		<span class="s3">)} </span><span class="s2">+ </span><span class="s1">$</span><span class="s3">{</span><span class="s4">this</span><span class="s3">.</span><span class="s1">_modules</span><span class="s3">.</span><span class="s1">size </span><span class="s3">- </span><span class="s7">1</span><span class="s3">} </span><span class="s2">modules`</span><span class="s3">;</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{LibIdentOptions} options options</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{string | null} an identifier for library inclusion</span>
	 <span class="s5">*/</span>
	<span class="s1">libIdent</span><span class="s3">(</span><span class="s1">options</span><span class="s3">) {</span>
		<span class="s4">return this</span><span class="s3">.</span><span class="s1">rootModule</span><span class="s3">.</span><span class="s1">libIdent</span><span class="s3">(</span><span class="s1">options</span><span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{string | null} absolute path which should be used for condition matching (usually the resource path)</span>
	 <span class="s5">*/</span>
	<span class="s1">nameForCondition</span><span class="s3">() {</span>
		<span class="s4">return this</span><span class="s3">.</span><span class="s1">rootModule</span><span class="s3">.</span><span class="s1">nameForCondition</span><span class="s3">();</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{ModuleGraph} moduleGraph the module graph</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{ConnectionState} how this module should be connected to referencing modules when consumed for side-effects only</span>
	 <span class="s5">*/</span>
	<span class="s1">getSideEffectsConnectionState</span><span class="s3">(</span><span class="s1">moduleGraph</span><span class="s3">) {</span>
		<span class="s4">return this</span><span class="s3">.</span><span class="s1">rootModule</span><span class="s3">.</span><span class="s1">getSideEffectsConnectionState</span><span class="s3">(</span><span class="s1">moduleGraph</span><span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{WebpackOptions} options webpack options</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Compilation} compilation the compilation</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{ResolverWithOptions} resolver the resolver</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{InputFileSystem} fs the file system</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{BuildCallback} callback callback function</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
	 <span class="s5">*/</span>
	<span class="s1">build</span><span class="s3">(</span><span class="s1">options</span><span class="s3">, </span><span class="s1">compilation</span><span class="s3">, </span><span class="s1">resolver</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s3">{ </span><span class="s1">rootModule </span><span class="s3">} = </span><span class="s4">this</span><span class="s3">;</span>
		<span class="s4">const </span><span class="s3">{ </span><span class="s1">moduleArgument</span><span class="s3">, </span><span class="s1">exportsArgument </span><span class="s3">} =</span>
			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{BuildInfo} */</span>
			<span class="s3">(</span><span class="s1">rootModule</span><span class="s3">.</span><span class="s1">buildInfo</span><span class="s3">);</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">buildInfo </span><span class="s3">= {</span>
			<span class="s1">strict</span><span class="s3">: </span><span class="s4">true</span><span class="s3">,</span>
			<span class="s1">cacheable</span><span class="s3">: </span><span class="s4">true</span><span class="s3">,</span>
			<span class="s1">moduleArgument</span><span class="s3">,</span>
			<span class="s1">exportsArgument</span><span class="s3">,</span>
			<span class="s1">fileDependencies</span><span class="s3">: </span><span class="s4">new </span><span class="s1">LazySet</span><span class="s3">(),</span>
			<span class="s1">contextDependencies</span><span class="s3">: </span><span class="s4">new </span><span class="s1">LazySet</span><span class="s3">(),</span>
			<span class="s1">missingDependencies</span><span class="s3">: </span><span class="s4">new </span><span class="s1">LazySet</span><span class="s3">(),</span>
			<span class="s1">topLevelDeclarations</span><span class="s3">: </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">(),</span>
			<span class="s1">assets</span><span class="s3">: </span><span class="s1">undefined</span>
		<span class="s3">};</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">buildMeta </span><span class="s3">= </span><span class="s1">rootModule</span><span class="s3">.</span><span class="s1">buildMeta</span><span class="s3">;</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">clearDependenciesAndBlocks</span><span class="s3">();</span>
		<span class="s4">this</span><span class="s3">.</span><span class="s1">clearWarningsAndErrors</span><span class="s3">();</span>

		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">m of </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_modules</span><span class="s3">) {</span>
			<span class="s0">// populate cacheable</span>
			<span class="s4">if </span><span class="s3">(!(</span><span class="s5">/** </span><span class="s6">@type </span><span class="s5">{BuildInfo} */ </span><span class="s3">(</span><span class="s1">m</span><span class="s3">.</span><span class="s1">buildInfo</span><span class="s3">).</span><span class="s1">cacheable</span><span class="s3">)) {</span>
				<span class="s4">this</span><span class="s3">.</span><span class="s1">buildInfo</span><span class="s3">.</span><span class="s1">cacheable </span><span class="s3">= </span><span class="s4">false</span><span class="s3">;</span>
			<span class="s3">}</span>

			<span class="s0">// populate dependencies</span>
			<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">d of m</span><span class="s3">.</span><span class="s1">dependencies</span><span class="s3">.</span><span class="s1">filter</span><span class="s3">(</span>
				<span class="s1">dep </span><span class="s3">=&gt;</span>
					<span class="s3">!(</span><span class="s1">dep </span><span class="s4">instanceof </span><span class="s1">HarmonyImportDependency</span><span class="s3">) ||</span>
					<span class="s3">!</span><span class="s4">this</span><span class="s3">.</span><span class="s1">_modules</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span>
						<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Module} */ </span><span class="s3">(</span><span class="s1">compilation</span><span class="s3">.</span><span class="s1">moduleGraph</span><span class="s3">.</span><span class="s1">getModule</span><span class="s3">(</span><span class="s1">dep</span><span class="s3">))</span>
					<span class="s3">)</span>
			<span class="s3">)) {</span>
				<span class="s4">this</span><span class="s3">.</span><span class="s1">dependencies</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">d</span><span class="s3">);</span>
			<span class="s3">}</span>
			<span class="s0">// populate blocks</span>
			<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">d of m</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">) {</span>
				<span class="s4">this</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">d</span><span class="s3">);</span>
			<span class="s3">}</span>

			<span class="s0">// populate warnings</span>
			<span class="s4">const </span><span class="s1">warnings </span><span class="s3">= </span><span class="s1">m</span><span class="s3">.</span><span class="s1">getWarnings</span><span class="s3">();</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">warnings </span><span class="s3">!== </span><span class="s1">undefined</span><span class="s3">) {</span>
				<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">warning of warnings</span><span class="s3">) {</span>
					<span class="s4">this</span><span class="s3">.</span><span class="s1">addWarning</span><span class="s3">(</span><span class="s1">warning</span><span class="s3">);</span>
				<span class="s3">}</span>
			<span class="s3">}</span>

			<span class="s0">// populate errors</span>
			<span class="s4">const </span><span class="s1">errors </span><span class="s3">= </span><span class="s1">m</span><span class="s3">.</span><span class="s1">getErrors</span><span class="s3">();</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">errors </span><span class="s3">!== </span><span class="s1">undefined</span><span class="s3">) {</span>
				<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">error of errors</span><span class="s3">) {</span>
					<span class="s4">this</span><span class="s3">.</span><span class="s1">addError</span><span class="s3">(</span><span class="s1">error</span><span class="s3">);</span>
				<span class="s3">}</span>
			<span class="s3">}</span>

			<span class="s4">const </span><span class="s3">{ </span><span class="s1">assets</span><span class="s3">, </span><span class="s1">assetsInfo</span><span class="s3">, </span><span class="s1">topLevelDeclarations </span><span class="s3">} =</span>
				<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{BuildInfo} */ </span><span class="s3">(</span><span class="s1">m</span><span class="s3">.</span><span class="s1">buildInfo</span><span class="s3">);</span>

			<span class="s0">// populate topLevelDeclarations</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">topLevelDeclarations</span><span class="s3">) {</span>
				<span class="s4">const </span><span class="s1">topLevelDeclarations </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">buildInfo</span><span class="s3">.</span><span class="s1">topLevelDeclarations</span><span class="s3">;</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">topLevelDeclarations </span><span class="s3">!== </span><span class="s1">undefined</span><span class="s3">) {</span>
					<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">decl of topLevelDeclarations</span><span class="s3">) {</span>
						<span class="s1">topLevelDeclarations</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">decl</span><span class="s3">);</span>
					<span class="s3">}</span>
				<span class="s3">}</span>
			<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
				<span class="s4">this</span><span class="s3">.</span><span class="s1">buildInfo</span><span class="s3">.</span><span class="s1">topLevelDeclarations </span><span class="s3">= </span><span class="s1">undefined</span><span class="s3">;</span>
			<span class="s3">}</span>

			<span class="s0">// populate assets</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">assets</span><span class="s3">) {</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">buildInfo</span><span class="s3">.</span><span class="s1">assets </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) {</span>
					<span class="s4">this</span><span class="s3">.</span><span class="s1">buildInfo</span><span class="s3">.</span><span class="s1">assets </span><span class="s3">= </span><span class="s1">Object</span><span class="s3">.</span><span class="s1">create</span><span class="s3">(</span><span class="s4">null</span><span class="s3">);</span>
				<span class="s3">}</span>
				<span class="s1">Object</span><span class="s3">.</span><span class="s1">assign</span><span class="s3">(</span>
					<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{NonNullable&lt;BuildInfo[&quot;assets&quot;]&gt;} */</span>
					<span class="s3">(</span>
						<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{BuildInfo} */</span>
						<span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">buildInfo</span><span class="s3">).</span><span class="s1">assets</span>
					<span class="s3">),</span>
					<span class="s1">assets</span>
				<span class="s3">);</span>
			<span class="s3">}</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">assetsInfo</span><span class="s3">) {</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">buildInfo</span><span class="s3">.</span><span class="s1">assetsInfo </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) {</span>
					<span class="s4">this</span><span class="s3">.</span><span class="s1">buildInfo</span><span class="s3">.</span><span class="s1">assetsInfo </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Map</span><span class="s3">();</span>
				<span class="s3">}</span>
				<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s3">[</span><span class="s1">key</span><span class="s3">, </span><span class="s1">value</span><span class="s3">] </span><span class="s1">of assetsInfo</span><span class="s3">) {</span>
					<span class="s4">this</span><span class="s3">.</span><span class="s1">buildInfo</span><span class="s3">.</span><span class="s1">assetsInfo</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">key</span><span class="s3">, </span><span class="s1">value</span><span class="s3">);</span>
				<span class="s3">}</span>
			<span class="s3">}</span>
		<span class="s3">}</span>
		<span class="s1">callback</span><span class="s3">();</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string=} type the source type for which the size should be estimated</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{number} the estimated size of the module (must be non-zero)</span>
	 <span class="s5">*/</span>
	<span class="s1">size</span><span class="s3">(</span><span class="s1">type</span><span class="s3">) {</span>
		<span class="s0">// Guess size from embedded modules</span>
		<span class="s4">let </span><span class="s1">size </span><span class="s3">= </span><span class="s7">0</span><span class="s3">;</span>
		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">module of </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_modules</span><span class="s3">) {</span>
			<span class="s1">size </span><span class="s3">+= </span><span class="s1">module</span><span class="s3">.</span><span class="s1">size</span><span class="s3">(</span><span class="s1">type</span><span class="s3">);</span>
		<span class="s3">}</span>
		<span class="s4">return </span><span class="s1">size</span><span class="s3">;</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@private</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} rootModule the root of the concatenation</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Set&lt;Module&gt;} modulesSet a set of modules which should be concatenated</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{RuntimeSpec} runtime for this runtime</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{ModuleGraph} moduleGraph the module graph</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{ConcatenationEntry[]} concatenation list</span>
	 <span class="s5">*/</span>
	<span class="s1">_createConcatenationList</span><span class="s3">(</span><span class="s1">rootModule</span><span class="s3">, </span><span class="s1">modulesSet</span><span class="s3">, </span><span class="s1">runtime</span><span class="s3">, </span><span class="s1">moduleGraph</span><span class="s3">) {</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{ConcatenationEntry[]} */</span>
		<span class="s4">const </span><span class="s1">list </span><span class="s3">= [];</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Map&lt;Module, RuntimeSpec | true&gt;} */</span>
		<span class="s4">const </span><span class="s1">existingEntries </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Map</span><span class="s3">();</span>

		<span class="s5">/**</span>
		 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} module a module</span>
		 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{Iterable&lt;{ connection: ModuleGraphConnection, runtimeCondition: RuntimeSpec | true }&gt;} imported modules in order</span>
		 <span class="s5">*/</span>
		<span class="s4">const </span><span class="s1">getConcatenatedImports </span><span class="s3">= </span><span class="s1">module </span><span class="s3">=&gt; {</span>
			<span class="s4">const </span><span class="s1">connections </span><span class="s3">= </span><span class="s1">Array</span><span class="s3">.</span><span class="s1">from</span><span class="s3">(</span>
				<span class="s1">moduleGraph</span><span class="s3">.</span><span class="s1">getOutgoingConnections</span><span class="s3">(</span><span class="s1">module</span><span class="s3">)</span>
			<span class="s3">);</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">module </span><span class="s3">=== </span><span class="s1">rootModule</span><span class="s3">) {</span>
				<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">c of moduleGraph</span><span class="s3">.</span><span class="s1">getOutgoingConnections</span><span class="s3">(</span><span class="s4">this</span><span class="s3">))</span>
					<span class="s1">connections</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">c</span><span class="s3">);</span>
			<span class="s3">}</span>
			<span class="s5">/**</span>
			 <span class="s5">* </span><span class="s6">@type </span><span class="s5">{Array&lt;{ connection: ModuleGraphConnection, sourceOrder: number, rangeStart: number }&gt;}</span>
			 <span class="s5">*/</span>
			<span class="s4">const </span><span class="s1">references </span><span class="s3">= </span><span class="s1">connections</span>
				<span class="s3">.</span><span class="s1">filter</span><span class="s3">(</span><span class="s1">connection </span><span class="s3">=&gt; {</span>
					<span class="s4">if </span><span class="s3">(!(</span><span class="s1">connection</span><span class="s3">.</span><span class="s1">dependency </span><span class="s4">instanceof </span><span class="s1">HarmonyImportDependency</span><span class="s3">))</span>
						<span class="s4">return false</span><span class="s3">;</span>
					<span class="s4">return </span><span class="s3">(</span>
						<span class="s1">connection </span><span class="s3">&amp;&amp;</span>
						<span class="s1">connection</span><span class="s3">.</span><span class="s1">resolvedOriginModule </span><span class="s3">=== </span><span class="s1">module </span><span class="s3">&amp;&amp;</span>
						<span class="s1">connection</span><span class="s3">.</span><span class="s1">module </span><span class="s3">&amp;&amp;</span>
						<span class="s1">connection</span><span class="s3">.</span><span class="s1">isTargetActive</span><span class="s3">(</span><span class="s1">runtime</span><span class="s3">)</span>
					<span class="s3">);</span>
				<span class="s3">})</span>
				<span class="s3">.</span><span class="s1">map</span><span class="s3">(</span><span class="s1">connection </span><span class="s3">=&gt; {</span>
					<span class="s4">const </span><span class="s1">dep </span><span class="s3">= </span><span class="s5">/** </span><span class="s6">@type </span><span class="s5">{HarmonyImportDependency} */ </span><span class="s3">(</span>
						<span class="s1">connection</span><span class="s3">.</span><span class="s1">dependency</span>
					<span class="s3">);</span>
					<span class="s4">return </span><span class="s3">{</span>
						<span class="s1">connection</span><span class="s3">,</span>
						<span class="s1">sourceOrder</span><span class="s3">: </span><span class="s1">dep</span><span class="s3">.</span><span class="s1">sourceOrder</span><span class="s3">,</span>
						<span class="s1">rangeStart</span><span class="s3">: </span><span class="s1">dep</span><span class="s3">.</span><span class="s1">range </span><span class="s3">&amp;&amp; </span><span class="s1">dep</span><span class="s3">.</span><span class="s1">range</span><span class="s3">[</span><span class="s7">0</span><span class="s3">]</span>
					<span class="s3">};</span>
				<span class="s3">});</span>
			<span class="s5">/**</span>
			 <span class="s5">* bySourceOrder</span>
			 <span class="s5">* </span><span class="s6">@example</span>
			 <span class="s5">* import a from &quot;a&quot;; // sourceOrder=1</span>
			 <span class="s5">* import b from &quot;b&quot;; // sourceOrder=2</span>
			 <span class="s5">*</span>
			 <span class="s5">* byRangeStart</span>
			 <span class="s5">* </span><span class="s6">@example</span>
			 <span class="s5">* import {a, b} from &quot;a&quot;; // sourceOrder=1</span>
			 <span class="s5">* a.a(); // first range</span>
			 <span class="s5">* b.b(); // second range</span>
			 <span class="s5">*</span>
			 <span class="s5">* If there is no reexport, we have the same source.</span>
			 <span class="s5">* If there is reexport, but module has side effects, this will lead to reexport module only.</span>
			 <span class="s5">* If there is side-effects-free reexport, we can get simple deterministic result with range start comparison.</span>
			 <span class="s5">*/</span>
			<span class="s1">references</span><span class="s3">.</span><span class="s1">sort</span><span class="s3">(</span><span class="s1">concatComparators</span><span class="s3">(</span><span class="s1">bySourceOrder</span><span class="s3">, </span><span class="s1">byRangeStart</span><span class="s3">));</span>
			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Map&lt;Module, { connection: ModuleGraphConnection, runtimeCondition: RuntimeSpec | true }&gt;} */</span>
			<span class="s4">const </span><span class="s1">referencesMap </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Map</span><span class="s3">();</span>
			<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s3">{ </span><span class="s1">connection </span><span class="s3">} </span><span class="s1">of references</span><span class="s3">) {</span>
				<span class="s4">const </span><span class="s1">runtimeCondition </span><span class="s3">= </span><span class="s1">filterRuntime</span><span class="s3">(</span><span class="s1">runtime</span><span class="s3">, </span><span class="s1">r </span><span class="s3">=&gt;</span>
					<span class="s1">connection</span><span class="s3">.</span><span class="s1">isTargetActive</span><span class="s3">(</span><span class="s1">r</span><span class="s3">)</span>
				<span class="s3">);</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">runtimeCondition </span><span class="s3">=== </span><span class="s4">false</span><span class="s3">) </span><span class="s4">continue</span><span class="s3">;</span>
				<span class="s4">const </span><span class="s1">module </span><span class="s3">= </span><span class="s1">connection</span><span class="s3">.</span><span class="s1">module</span><span class="s3">;</span>
				<span class="s4">const </span><span class="s1">entry </span><span class="s3">= </span><span class="s1">referencesMap</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">entry </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) {</span>
					<span class="s1">referencesMap</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, { </span><span class="s1">connection</span><span class="s3">, </span><span class="s1">runtimeCondition </span><span class="s3">});</span>
					<span class="s4">continue</span><span class="s3">;</span>
				<span class="s3">}</span>
				<span class="s1">entry</span><span class="s3">.</span><span class="s1">runtimeCondition </span><span class="s3">= </span><span class="s1">mergeRuntimeConditionNonFalse</span><span class="s3">(</span>
					<span class="s1">entry</span><span class="s3">.</span><span class="s1">runtimeCondition</span><span class="s3">,</span>
					<span class="s1">runtimeCondition</span><span class="s3">,</span>
					<span class="s1">runtime</span>
				<span class="s3">);</span>
			<span class="s3">}</span>
			<span class="s4">return </span><span class="s1">referencesMap</span><span class="s3">.</span><span class="s1">values</span><span class="s3">();</span>
		<span class="s3">};</span>

		<span class="s5">/**</span>
		 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{ModuleGraphConnection} connection graph connection</span>
		 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{RuntimeSpec | true} runtimeCondition runtime condition</span>
		 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
		 <span class="s5">*/</span>
		<span class="s4">const </span><span class="s1">enterModule </span><span class="s3">= (</span><span class="s1">connection</span><span class="s3">, </span><span class="s1">runtimeCondition</span><span class="s3">) =&gt; {</span>
			<span class="s4">const </span><span class="s1">module </span><span class="s3">= </span><span class="s1">connection</span><span class="s3">.</span><span class="s1">module</span><span class="s3">;</span>
			<span class="s4">if </span><span class="s3">(!</span><span class="s1">module</span><span class="s3">) </span><span class="s4">return</span><span class="s3">;</span>
			<span class="s4">const </span><span class="s1">existingEntry </span><span class="s3">= </span><span class="s1">existingEntries</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">existingEntry </span><span class="s3">=== </span><span class="s4">true</span><span class="s3">) {</span>
				<span class="s4">return</span><span class="s3">;</span>
			<span class="s3">}</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">modulesSet</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s1">module</span><span class="s3">)) {</span>
				<span class="s1">existingEntries</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s4">true</span><span class="s3">);</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">runtimeCondition </span><span class="s3">!== </span><span class="s4">true</span><span class="s3">) {</span>
					<span class="s4">throw new </span><span class="s1">Error</span><span class="s3">(</span>
						<span class="s2">`Cannot runtime-conditional concatenate a module (</span><span class="s1">$</span><span class="s3">{</span><span class="s1">module</span><span class="s3">.</span><span class="s1">identifier</span><span class="s3">()} </span><span class="s2">in </span><span class="s1">$</span><span class="s3">{</span><span class="s4">this</span><span class="s3">.</span><span class="s1">rootModule</span><span class="s3">.</span><span class="s1">identifier</span><span class="s3">()}</span><span class="s2">, </span><span class="s1">$</span><span class="s3">{</span><span class="s1">runtimeConditionToString</span><span class="s3">(</span>
							<span class="s1">runtimeCondition</span>
						<span class="s3">)}</span><span class="s2">). This should not happen.`</span>
					<span class="s3">);</span>
				<span class="s3">}</span>
				<span class="s4">const </span><span class="s1">imports </span><span class="s3">= </span><span class="s1">getConcatenatedImports</span><span class="s3">(</span><span class="s1">module</span><span class="s3">);</span>
				<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s3">{ </span><span class="s1">connection</span><span class="s3">, </span><span class="s1">runtimeCondition </span><span class="s3">} </span><span class="s1">of imports</span><span class="s3">)</span>
					<span class="s1">enterModule</span><span class="s3">(</span><span class="s1">connection</span><span class="s3">, </span><span class="s1">runtimeCondition</span><span class="s3">);</span>
				<span class="s1">list</span><span class="s3">.</span><span class="s1">push</span><span class="s3">({</span>
					<span class="s1">type</span><span class="s3">: </span><span class="s2">&quot;concatenated&quot;</span><span class="s3">,</span>
					<span class="s1">module</span><span class="s3">: </span><span class="s1">connection</span><span class="s3">.</span><span class="s1">module</span><span class="s3">,</span>
					<span class="s1">runtimeCondition</span>
				<span class="s3">});</span>
			<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">existingEntry </span><span class="s3">!== </span><span class="s1">undefined</span><span class="s3">) {</span>
					<span class="s4">const </span><span class="s1">reducedRuntimeCondition </span><span class="s3">= </span><span class="s1">subtractRuntimeCondition</span><span class="s3">(</span>
						<span class="s1">runtimeCondition</span><span class="s3">,</span>
						<span class="s1">existingEntry</span><span class="s3">,</span>
						<span class="s1">runtime</span>
					<span class="s3">);</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">reducedRuntimeCondition </span><span class="s3">=== </span><span class="s4">false</span><span class="s3">) </span><span class="s4">return</span><span class="s3">;</span>
					<span class="s1">runtimeCondition </span><span class="s3">= </span><span class="s1">reducedRuntimeCondition</span><span class="s3">;</span>
					<span class="s1">existingEntries</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span>
						<span class="s1">connection</span><span class="s3">.</span><span class="s1">module</span><span class="s3">,</span>
						<span class="s1">mergeRuntimeConditionNonFalse</span><span class="s3">(</span>
							<span class="s1">existingEntry</span><span class="s3">,</span>
							<span class="s1">runtimeCondition</span><span class="s3">,</span>
							<span class="s1">runtime</span>
						<span class="s3">)</span>
					<span class="s3">);</span>
				<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
					<span class="s1">existingEntries</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">connection</span><span class="s3">.</span><span class="s1">module</span><span class="s3">, </span><span class="s1">runtimeCondition</span><span class="s3">);</span>
				<span class="s3">}</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">list</span><span class="s3">.</span><span class="s1">length </span><span class="s3">&gt; </span><span class="s7">0</span><span class="s3">) {</span>
					<span class="s4">const </span><span class="s1">lastItem </span><span class="s3">= </span><span class="s1">list</span><span class="s3">[</span><span class="s1">list</span><span class="s3">.</span><span class="s1">length </span><span class="s3">- </span><span class="s7">1</span><span class="s3">];</span>
					<span class="s4">if </span><span class="s3">(</span>
						<span class="s1">lastItem</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">&quot;external&quot; </span><span class="s3">&amp;&amp;</span>
						<span class="s1">lastItem</span><span class="s3">.</span><span class="s1">module </span><span class="s3">=== </span><span class="s1">connection</span><span class="s3">.</span><span class="s1">module</span>
					<span class="s3">) {</span>
						<span class="s1">lastItem</span><span class="s3">.</span><span class="s1">runtimeCondition </span><span class="s3">= </span><span class="s1">mergeRuntimeCondition</span><span class="s3">(</span>
							<span class="s1">lastItem</span><span class="s3">.</span><span class="s1">runtimeCondition</span><span class="s3">,</span>
							<span class="s1">runtimeCondition</span><span class="s3">,</span>
							<span class="s1">runtime</span>
						<span class="s3">);</span>
						<span class="s4">return</span><span class="s3">;</span>
					<span class="s3">}</span>
				<span class="s3">}</span>
				<span class="s1">list</span><span class="s3">.</span><span class="s1">push</span><span class="s3">({</span>
					<span class="s1">type</span><span class="s3">: </span><span class="s2">&quot;external&quot;</span><span class="s3">,</span>
					<span class="s1">get module</span><span class="s3">() {</span>
						<span class="s0">// We need to use a getter here, because the module in the dependency</span>
						<span class="s0">// could be replaced by some other process (i. e. also replaced with a</span>
						<span class="s0">// concatenated module)</span>
						<span class="s4">return </span><span class="s1">connection</span><span class="s3">.</span><span class="s1">module</span><span class="s3">;</span>
					<span class="s3">},</span>
					<span class="s1">runtimeCondition</span>
				<span class="s3">});</span>
			<span class="s3">}</span>
		<span class="s3">};</span>

		<span class="s1">existingEntries</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">rootModule</span><span class="s3">, </span><span class="s4">true</span><span class="s3">);</span>
		<span class="s4">const </span><span class="s1">imports </span><span class="s3">= </span><span class="s1">getConcatenatedImports</span><span class="s3">(</span><span class="s1">rootModule</span><span class="s3">);</span>
		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s3">{ </span><span class="s1">connection</span><span class="s3">, </span><span class="s1">runtimeCondition </span><span class="s3">} </span><span class="s1">of imports</span><span class="s3">)</span>
			<span class="s1">enterModule</span><span class="s3">(</span><span class="s1">connection</span><span class="s3">, </span><span class="s1">runtimeCondition</span><span class="s3">);</span>
		<span class="s1">list</span><span class="s3">.</span><span class="s1">push</span><span class="s3">({</span>
			<span class="s1">type</span><span class="s3">: </span><span class="s2">&quot;concatenated&quot;</span><span class="s3">,</span>
			<span class="s1">module</span><span class="s3">: </span><span class="s1">rootModule</span><span class="s3">,</span>
			<span class="s1">runtimeCondition</span><span class="s3">: </span><span class="s4">true</span>
		<span class="s3">});</span>

		<span class="s4">return </span><span class="s1">list</span><span class="s3">;</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Module} rootModule the root module of the concatenation</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Set&lt;Module&gt;} modules all modules in the concatenation (including the root module)</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{AssociatedObjectForCache=} associatedObjectForCache object for caching</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string | HashConstructor=} hashFunction hash function to use</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{string} the identifier</span>
	 <span class="s5">*/</span>
	<span class="s4">static </span><span class="s1">_createIdentifier</span><span class="s3">(</span>
		<span class="s1">rootModule</span><span class="s3">,</span>
		<span class="s1">modules</span><span class="s3">,</span>
		<span class="s1">associatedObjectForCache</span><span class="s3">,</span>
		<span class="s1">hashFunction </span><span class="s3">= </span><span class="s1">DEFAULTS</span><span class="s3">.</span><span class="s1">HASH_FUNCTION</span>
	<span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">cachedMakePathsRelative </span><span class="s3">= </span><span class="s1">makePathsRelative</span><span class="s3">.</span><span class="s1">bindContextCache</span><span class="s3">(</span>
			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{string} */ </span><span class="s3">(</span><span class="s1">rootModule</span><span class="s3">.</span><span class="s1">context</span><span class="s3">),</span>
			<span class="s1">associatedObjectForCache</span>
		<span class="s3">);</span>
		<span class="s4">const </span><span class="s1">identifiers </span><span class="s3">= [];</span>
		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">module of modules</span><span class="s3">) {</span>
			<span class="s1">identifiers</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">cachedMakePathsRelative</span><span class="s3">(</span><span class="s1">module</span><span class="s3">.</span><span class="s1">identifier</span><span class="s3">()));</span>
		<span class="s3">}</span>
		<span class="s1">identifiers</span><span class="s3">.</span><span class="s1">sort</span><span class="s3">();</span>
		<span class="s4">const </span><span class="s1">hash </span><span class="s3">= </span><span class="s1">createHash</span><span class="s3">(</span><span class="s1">hashFunction</span><span class="s3">);</span>
		<span class="s1">hash</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">identifiers</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s2">&quot; &quot;</span><span class="s3">));</span>
		<span class="s4">return </span><span class="s2">`</span><span class="s1">$</span><span class="s3">{</span><span class="s1">rootModule</span><span class="s3">.</span><span class="s1">identifier</span><span class="s3">()}</span><span class="s2">|</span><span class="s1">$</span><span class="s3">{</span><span class="s1">hash</span><span class="s3">.</span><span class="s1">digest</span><span class="s3">(</span><span class="s2">&quot;hex&quot;</span><span class="s3">)}</span><span class="s2">`</span><span class="s3">;</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{LazySet&lt;string&gt;} fileDependencies set where file dependencies are added to</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{LazySet&lt;string&gt;} contextDependencies set where context dependencies are added to</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{LazySet&lt;string&gt;} missingDependencies set where missing dependencies are added to</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{LazySet&lt;string&gt;} buildDependencies set where build dependencies are added to</span>
	 <span class="s5">*/</span>
	<span class="s1">addCacheDependencies</span><span class="s3">(</span>
		<span class="s1">fileDependencies</span><span class="s3">,</span>
		<span class="s1">contextDependencies</span><span class="s3">,</span>
		<span class="s1">missingDependencies</span><span class="s3">,</span>
		<span class="s1">buildDependencies</span>
	<span class="s3">) {</span>
		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">module of </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_modules</span><span class="s3">) {</span>
			<span class="s1">module</span><span class="s3">.</span><span class="s1">addCacheDependencies</span><span class="s3">(</span>
				<span class="s1">fileDependencies</span><span class="s3">,</span>
				<span class="s1">contextDependencies</span><span class="s3">,</span>
				<span class="s1">missingDependencies</span><span class="s3">,</span>
				<span class="s1">buildDependencies</span>
			<span class="s3">);</span>
		<span class="s3">}</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{CodeGenerationContext} context context for code generation</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{CodeGenerationResult} result</span>
	 <span class="s5">*/</span>
	<span class="s1">codeGeneration</span><span class="s3">({</span>
		<span class="s1">dependencyTemplates</span><span class="s3">,</span>
		<span class="s1">runtimeTemplate</span><span class="s3">,</span>
		<span class="s1">moduleGraph</span><span class="s3">,</span>
		<span class="s1">chunkGraph</span><span class="s3">,</span>
		<span class="s1">runtime</span><span class="s3">: </span><span class="s1">generationRuntime</span><span class="s3">,</span>
		<span class="s1">codeGenerationResults</span>
	<span class="s3">}) {</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{RuntimeRequirements} */</span>
		<span class="s4">const </span><span class="s1">runtimeRequirements </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">();</span>
		<span class="s4">const </span><span class="s1">runtime </span><span class="s3">= </span><span class="s1">intersectRuntime</span><span class="s3">(</span><span class="s1">generationRuntime</span><span class="s3">, </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_runtime</span><span class="s3">);</span>

		<span class="s4">const </span><span class="s1">requestShortener </span><span class="s3">= </span><span class="s1">runtimeTemplate</span><span class="s3">.</span><span class="s1">requestShortener</span><span class="s3">;</span>
		<span class="s0">// Meta info for each module</span>
		<span class="s4">const </span><span class="s3">[</span><span class="s1">modulesWithInfo</span><span class="s3">, </span><span class="s1">moduleToInfoMap</span><span class="s3">] = </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_getModulesWithInfo</span><span class="s3">(</span>
			<span class="s1">moduleGraph</span><span class="s3">,</span>
			<span class="s1">runtime</span>
		<span class="s3">);</span>

		<span class="s0">// Set with modules that need a generated namespace object</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Set&lt;ConcatenatedModuleInfo&gt;} */</span>
		<span class="s4">const </span><span class="s1">neededNamespaceObjects </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">();</span>

		<span class="s0">// Generate source code and analyse scopes</span>
		<span class="s0">// Prepare a ReplaceSource for the final source</span>
		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">info of moduleToInfoMap</span><span class="s3">.</span><span class="s1">values</span><span class="s3">()) {</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">_analyseModule</span><span class="s3">(</span>
				<span class="s1">moduleToInfoMap</span><span class="s3">,</span>
				<span class="s1">info</span><span class="s3">,</span>
				<span class="s1">dependencyTemplates</span><span class="s3">,</span>
				<span class="s1">runtimeTemplate</span><span class="s3">,</span>
				<span class="s1">moduleGraph</span><span class="s3">,</span>
				<span class="s1">chunkGraph</span><span class="s3">,</span>
				<span class="s1">runtime</span><span class="s3">,</span>
				<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{CodeGenerationResults} */</span>
				<span class="s3">(</span><span class="s1">codeGenerationResults</span><span class="s3">)</span>
			<span class="s3">);</span>
		<span class="s3">}</span>

		<span class="s0">// List of all used names to avoid conflicts</span>
		<span class="s4">const </span><span class="s1">allUsedNames </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">(</span><span class="s1">RESERVED_NAMES</span><span class="s3">);</span>
		<span class="s0">// Updated Top level declarations are created by renaming</span>
		<span class="s4">const </span><span class="s1">topLevelDeclarations </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">();</span>

		<span class="s0">// List of additional names in scope for module references</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Map&lt;string, { usedNames: UsedNames, alreadyCheckedScopes: Set&lt;TODO&gt; }&gt;} */</span>
		<span class="s4">const </span><span class="s1">usedNamesInScopeInfo </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Map</span><span class="s3">();</span>
		<span class="s5">/**</span>
		 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string} module module identifier</span>
		 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string} id export id</span>
		 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{{ usedNames: UsedNames, alreadyCheckedScopes: Set&lt;TODO&gt; }} info</span>
		 <span class="s5">*/</span>

		<span class="s0">// Set of already checked scopes</span>
		<span class="s4">const </span><span class="s1">ignoredScopes </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">();</span>

		<span class="s0">// get all global names</span>
		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">info of modulesWithInfo</span><span class="s3">) {</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">info</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">&quot;concatenated&quot;</span><span class="s3">) {</span>
				<span class="s0">// ignore symbols from moduleScope</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">info</span><span class="s3">.</span><span class="s1">moduleScope</span><span class="s3">) {</span>
					<span class="s1">ignoredScopes</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">info</span><span class="s3">.</span><span class="s1">moduleScope</span><span class="s3">);</span>
				<span class="s3">}</span>

				<span class="s0">// The super class expression in class scopes behaves weird</span>
				<span class="s0">// We get ranges of all super class expressions to make</span>
				<span class="s0">// renaming to work correctly</span>
				<span class="s4">const </span><span class="s1">superClassCache </span><span class="s3">= </span><span class="s4">new </span><span class="s1">WeakMap</span><span class="s3">();</span>
				<span class="s5">/**</span>
				 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Scope} scope scope</span>
				 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{TODO} result</span>
				 <span class="s5">*/</span>
				<span class="s4">const </span><span class="s1">getSuperClassExpressions </span><span class="s3">= </span><span class="s1">scope </span><span class="s3">=&gt; {</span>
					<span class="s4">const </span><span class="s1">cacheEntry </span><span class="s3">= </span><span class="s1">superClassCache</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">scope</span><span class="s3">);</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">cacheEntry </span><span class="s3">!== </span><span class="s1">undefined</span><span class="s3">) </span><span class="s4">return </span><span class="s1">cacheEntry</span><span class="s3">;</span>
					<span class="s4">const </span><span class="s1">superClassExpressions </span><span class="s3">= [];</span>
					<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">childScope of scope</span><span class="s3">.</span><span class="s1">childScopes</span><span class="s3">) {</span>
						<span class="s4">if </span><span class="s3">(</span><span class="s1">childScope</span><span class="s3">.</span><span class="s1">type </span><span class="s3">!== </span><span class="s2">&quot;class&quot;</span><span class="s3">) </span><span class="s4">continue</span><span class="s3">;</span>
						<span class="s4">const </span><span class="s1">block </span><span class="s3">= </span><span class="s1">childScope</span><span class="s3">.</span><span class="s1">block</span><span class="s3">;</span>
						<span class="s4">if </span><span class="s3">(</span>
							<span class="s3">(</span><span class="s1">block</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">&quot;ClassDeclaration&quot; </span><span class="s3">||</span>
								<span class="s1">block</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">&quot;ClassExpression&quot;</span><span class="s3">) &amp;&amp;</span>
							<span class="s1">block</span><span class="s3">.</span><span class="s1">superClass</span>
						<span class="s3">) {</span>
							<span class="s1">superClassExpressions</span><span class="s3">.</span><span class="s1">push</span><span class="s3">({</span>
								<span class="s1">range</span><span class="s3">: </span><span class="s1">block</span><span class="s3">.</span><span class="s1">superClass</span><span class="s3">.</span><span class="s1">range</span><span class="s3">,</span>
								<span class="s1">variables</span><span class="s3">: </span><span class="s1">childScope</span><span class="s3">.</span><span class="s1">variables</span>
							<span class="s3">});</span>
						<span class="s3">}</span>
					<span class="s3">}</span>
					<span class="s1">superClassCache</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">scope</span><span class="s3">, </span><span class="s1">superClassExpressions</span><span class="s3">);</span>
					<span class="s4">return </span><span class="s1">superClassExpressions</span><span class="s3">;</span>
				<span class="s3">};</span>

				<span class="s0">// add global symbols</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">info</span><span class="s3">.</span><span class="s1">globalScope</span><span class="s3">) {</span>
					<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">reference of info</span><span class="s3">.</span><span class="s1">globalScope</span><span class="s3">.</span><span class="s1">through</span><span class="s3">) {</span>
						<span class="s4">const </span><span class="s1">name </span><span class="s3">= </span><span class="s1">reference</span><span class="s3">.</span><span class="s1">identifier</span><span class="s3">.</span><span class="s1">name</span><span class="s3">;</span>
						<span class="s4">if </span><span class="s3">(</span><span class="s1">ConcatenationScope</span><span class="s3">.</span><span class="s1">isModuleReference</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)) {</span>
							<span class="s4">const </span><span class="s1">match </span><span class="s3">= </span><span class="s1">ConcatenationScope</span><span class="s3">.</span><span class="s1">matchModuleReference</span><span class="s3">(</span><span class="s1">name</span><span class="s3">);</span>
							<span class="s4">if </span><span class="s3">(!</span><span class="s1">match</span><span class="s3">) </span><span class="s4">continue</span><span class="s3">;</span>
							<span class="s4">const </span><span class="s1">referencedInfo </span><span class="s3">= </span><span class="s1">modulesWithInfo</span><span class="s3">[</span><span class="s1">match</span><span class="s3">.</span><span class="s1">index</span><span class="s3">];</span>
							<span class="s4">if </span><span class="s3">(</span><span class="s1">referencedInfo</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">&quot;reference&quot;</span><span class="s3">)</span>
								<span class="s4">throw new </span><span class="s1">Error</span><span class="s3">(</span><span class="s2">&quot;Module reference can't point to a reference&quot;</span><span class="s3">);</span>
							<span class="s4">const </span><span class="s1">binding </span><span class="s3">= </span><span class="s1">getFinalBinding</span><span class="s3">(</span>
								<span class="s1">moduleGraph</span><span class="s3">,</span>
								<span class="s1">referencedInfo</span><span class="s3">,</span>
								<span class="s1">match</span><span class="s3">.</span><span class="s1">ids</span><span class="s3">,</span>
								<span class="s1">moduleToInfoMap</span><span class="s3">,</span>
								<span class="s1">runtime</span><span class="s3">,</span>
								<span class="s1">requestShortener</span><span class="s3">,</span>
								<span class="s1">runtimeTemplate</span><span class="s3">,</span>
								<span class="s1">neededNamespaceObjects</span><span class="s3">,</span>
								<span class="s4">false</span><span class="s3">,</span>
								<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{BuildMeta} */</span>
								<span class="s3">(</span><span class="s1">info</span><span class="s3">.</span><span class="s1">module</span><span class="s3">.</span><span class="s1">buildMeta</span><span class="s3">).</span><span class="s1">strictHarmonyModule</span><span class="s3">,</span>
								<span class="s4">true</span>
							<span class="s3">);</span>
							<span class="s4">if </span><span class="s3">(!</span><span class="s1">binding</span><span class="s3">.</span><span class="s1">ids</span><span class="s3">) </span><span class="s4">continue</span><span class="s3">;</span>
							<span class="s4">const </span><span class="s3">{ </span><span class="s1">usedNames</span><span class="s3">, </span><span class="s1">alreadyCheckedScopes </span><span class="s3">} =</span>
								<span class="s1">getUsedNamesInScopeInfo</span><span class="s3">(</span>
									<span class="s1">usedNamesInScopeInfo</span><span class="s3">,</span>
									<span class="s1">binding</span><span class="s3">.</span><span class="s1">info</span><span class="s3">.</span><span class="s1">module</span><span class="s3">.</span><span class="s1">identifier</span><span class="s3">(),</span>
									<span class="s2">&quot;name&quot; </span><span class="s4">in </span><span class="s1">binding </span><span class="s3">? </span><span class="s1">binding</span><span class="s3">.</span><span class="s1">name </span><span class="s3">: </span><span class="s2">&quot;&quot;</span>
								<span class="s3">);</span>
							<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">expr of getSuperClassExpressions</span><span class="s3">(</span><span class="s1">reference</span><span class="s3">.</span><span class="s1">from</span><span class="s3">)) {</span>
								<span class="s4">if </span><span class="s3">(</span>
									<span class="s1">expr</span><span class="s3">.</span><span class="s1">range</span><span class="s3">[</span><span class="s7">0</span><span class="s3">] &lt;=</span>
										<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Range} */ </span><span class="s3">(</span><span class="s1">reference</span><span class="s3">.</span><span class="s1">identifier</span><span class="s3">.</span><span class="s1">range</span><span class="s3">)[</span><span class="s7">0</span><span class="s3">] &amp;&amp;</span>
									<span class="s1">expr</span><span class="s3">.</span><span class="s1">range</span><span class="s3">[</span><span class="s7">1</span><span class="s3">] &gt;=</span>
										<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Range} */ </span><span class="s3">(</span><span class="s1">reference</span><span class="s3">.</span><span class="s1">identifier</span><span class="s3">.</span><span class="s1">range</span><span class="s3">)[</span><span class="s7">1</span><span class="s3">]</span>
								<span class="s3">) {</span>
									<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">variable of expr</span><span class="s3">.</span><span class="s1">variables</span><span class="s3">) {</span>
										<span class="s1">usedNames</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">variable</span><span class="s3">.</span><span class="s1">name</span><span class="s3">);</span>
									<span class="s3">}</span>
								<span class="s3">}</span>
							<span class="s3">}</span>
							<span class="s1">addScopeSymbols</span><span class="s3">(</span>
								<span class="s1">reference</span><span class="s3">.</span><span class="s1">from</span><span class="s3">,</span>
								<span class="s1">usedNames</span><span class="s3">,</span>
								<span class="s1">alreadyCheckedScopes</span><span class="s3">,</span>
								<span class="s1">ignoredScopes</span>
							<span class="s3">);</span>
						<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
							<span class="s1">allUsedNames</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">name</span><span class="s3">);</span>
						<span class="s3">}</span>
					<span class="s3">}</span>
				<span class="s3">}</span>
			<span class="s3">}</span>
		<span class="s3">}</span>

		<span class="s0">// generate names for symbols</span>
		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">info of moduleToInfoMap</span><span class="s3">.</span><span class="s1">values</span><span class="s3">()) {</span>
			<span class="s4">const </span><span class="s3">{ </span><span class="s1">usedNames</span><span class="s3">: </span><span class="s1">namespaceObjectUsedNames </span><span class="s3">} = </span><span class="s1">getUsedNamesInScopeInfo</span><span class="s3">(</span>
				<span class="s1">usedNamesInScopeInfo</span><span class="s3">,</span>
				<span class="s1">info</span><span class="s3">.</span><span class="s1">module</span><span class="s3">.</span><span class="s1">identifier</span><span class="s3">(),</span>
				<span class="s2">&quot;&quot;</span>
			<span class="s3">);</span>
			<span class="s4">switch </span><span class="s3">(</span><span class="s1">info</span><span class="s3">.</span><span class="s1">type</span><span class="s3">) {</span>
				<span class="s4">case </span><span class="s2">&quot;concatenated&quot;</span><span class="s3">: {</span>
					<span class="s4">const </span><span class="s1">variables </span><span class="s3">= </span><span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Scope} */ </span><span class="s3">(</span><span class="s1">info</span><span class="s3">.</span><span class="s1">moduleScope</span><span class="s3">).</span><span class="s1">variables</span><span class="s3">;</span>
					<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">variable of variables</span><span class="s3">) {</span>
						<span class="s4">const </span><span class="s1">name </span><span class="s3">= </span><span class="s1">variable</span><span class="s3">.</span><span class="s1">name</span><span class="s3">;</span>
						<span class="s4">const </span><span class="s3">{ </span><span class="s1">usedNames</span><span class="s3">, </span><span class="s1">alreadyCheckedScopes </span><span class="s3">} = </span><span class="s1">getUsedNamesInScopeInfo</span><span class="s3">(</span>
							<span class="s1">usedNamesInScopeInfo</span><span class="s3">,</span>
							<span class="s1">info</span><span class="s3">.</span><span class="s1">module</span><span class="s3">.</span><span class="s1">identifier</span><span class="s3">(),</span>
							<span class="s1">name</span>
						<span class="s3">);</span>
						<span class="s4">if </span><span class="s3">(</span><span class="s1">allUsedNames</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s1">name</span><span class="s3">) || </span><span class="s1">usedNames</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)) {</span>
							<span class="s4">const </span><span class="s1">references </span><span class="s3">= </span><span class="s1">getAllReferences</span><span class="s3">(</span><span class="s1">variable</span><span class="s3">);</span>
							<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">ref of references</span><span class="s3">) {</span>
								<span class="s1">addScopeSymbols</span><span class="s3">(</span>
									<span class="s1">ref</span><span class="s3">.</span><span class="s1">from</span><span class="s3">,</span>
									<span class="s1">usedNames</span><span class="s3">,</span>
									<span class="s1">alreadyCheckedScopes</span><span class="s3">,</span>
									<span class="s1">ignoredScopes</span>
								<span class="s3">);</span>
							<span class="s3">}</span>
							<span class="s4">const </span><span class="s1">newName </span><span class="s3">= </span><span class="s1">findNewName</span><span class="s3">(</span>
								<span class="s1">name</span><span class="s3">,</span>
								<span class="s1">allUsedNames</span><span class="s3">,</span>
								<span class="s1">usedNames</span><span class="s3">,</span>
								<span class="s1">info</span><span class="s3">.</span><span class="s1">module</span><span class="s3">.</span><span class="s1">readableIdentifier</span><span class="s3">(</span><span class="s1">requestShortener</span><span class="s3">)</span>
							<span class="s3">);</span>
							<span class="s1">allUsedNames</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">newName</span><span class="s3">);</span>
							<span class="s1">info</span><span class="s3">.</span><span class="s1">internalNames</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">newName</span><span class="s3">);</span>
							<span class="s1">topLevelDeclarations</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">newName</span><span class="s3">);</span>
							<span class="s4">const </span><span class="s1">source </span><span class="s3">= </span><span class="s5">/** </span><span class="s6">@type </span><span class="s5">{ReplaceSource} */ </span><span class="s3">(</span><span class="s1">info</span><span class="s3">.</span><span class="s1">source</span><span class="s3">);</span>
							<span class="s4">const </span><span class="s1">allIdentifiers </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">(</span>
								<span class="s1">references</span><span class="s3">.</span><span class="s1">map</span><span class="s3">(</span><span class="s1">r </span><span class="s3">=&gt; </span><span class="s1">r</span><span class="s3">.</span><span class="s1">identifier</span><span class="s3">).</span><span class="s1">concat</span><span class="s3">(</span><span class="s1">variable</span><span class="s3">.</span><span class="s1">identifiers</span><span class="s3">)</span>
							<span class="s3">);</span>
							<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">identifier of allIdentifiers</span><span class="s3">) {</span>
								<span class="s4">const </span><span class="s1">r </span><span class="s3">= </span><span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Range} */ </span><span class="s3">(</span><span class="s1">identifier</span><span class="s3">.</span><span class="s1">range</span><span class="s3">);</span>
								<span class="s4">const </span><span class="s1">path </span><span class="s3">= </span><span class="s1">getPathInAst</span><span class="s3">(</span>
									<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{NonNullable&lt;ConcatenatedModuleInfo[&quot;ast&quot;]&gt;} */</span>
									<span class="s3">(</span><span class="s1">info</span><span class="s3">.</span><span class="s1">ast</span><span class="s3">),</span>
									<span class="s1">identifier</span>
								<span class="s3">);</span>
								<span class="s4">if </span><span class="s3">(</span><span class="s1">path </span><span class="s3">&amp;&amp; </span><span class="s1">path</span><span class="s3">.</span><span class="s1">length </span><span class="s3">&gt; </span><span class="s7">1</span><span class="s3">) {</span>
									<span class="s4">const </span><span class="s1">maybeProperty </span><span class="s3">=</span>
										<span class="s1">path</span><span class="s3">[</span><span class="s7">1</span><span class="s3">].</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">&quot;AssignmentPattern&quot; </span><span class="s3">&amp;&amp;</span>
										<span class="s1">path</span><span class="s3">[</span><span class="s7">1</span><span class="s3">].</span><span class="s1">left </span><span class="s3">=== </span><span class="s1">path</span><span class="s3">[</span><span class="s7">0</span><span class="s3">]</span>
											<span class="s3">? </span><span class="s1">path</span><span class="s3">[</span><span class="s7">2</span><span class="s3">]</span>
											<span class="s3">: </span><span class="s1">path</span><span class="s3">[</span><span class="s7">1</span><span class="s3">];</span>
									<span class="s4">if </span><span class="s3">(</span>
										<span class="s1">maybeProperty</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">&quot;Property&quot; </span><span class="s3">&amp;&amp;</span>
										<span class="s1">maybeProperty</span><span class="s3">.</span><span class="s1">shorthand</span>
									<span class="s3">) {</span>
										<span class="s1">source</span><span class="s3">.</span><span class="s1">insert</span><span class="s3">(</span><span class="s1">r</span><span class="s3">[</span><span class="s7">1</span><span class="s3">], </span><span class="s2">`: </span><span class="s1">$</span><span class="s3">{</span><span class="s1">newName</span><span class="s3">}</span><span class="s2">`</span><span class="s3">);</span>
										<span class="s4">continue</span><span class="s3">;</span>
									<span class="s3">}</span>
								<span class="s3">}</span>
								<span class="s1">source</span><span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span><span class="s1">r</span><span class="s3">[</span><span class="s7">0</span><span class="s3">], </span><span class="s1">r</span><span class="s3">[</span><span class="s7">1</span><span class="s3">] - </span><span class="s7">1</span><span class="s3">, </span><span class="s1">newName</span><span class="s3">);</span>
							<span class="s3">}</span>
						<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
							<span class="s1">allUsedNames</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">name</span><span class="s3">);</span>
							<span class="s1">info</span><span class="s3">.</span><span class="s1">internalNames</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">name</span><span class="s3">);</span>
							<span class="s1">topLevelDeclarations</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">name</span><span class="s3">);</span>
						<span class="s3">}</span>
					<span class="s3">}</span>
					<span class="s4">let </span><span class="s1">namespaceObjectName</span><span class="s3">;</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">info</span><span class="s3">.</span><span class="s1">namespaceExportSymbol</span><span class="s3">) {</span>
						<span class="s1">namespaceObjectName </span><span class="s3">= </span><span class="s1">info</span><span class="s3">.</span><span class="s1">internalNames</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span>
							<span class="s1">info</span><span class="s3">.</span><span class="s1">namespaceExportSymbol</span>
						<span class="s3">);</span>
					<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
						<span class="s1">namespaceObjectName </span><span class="s3">= </span><span class="s1">findNewName</span><span class="s3">(</span>
							<span class="s2">&quot;namespaceObject&quot;</span><span class="s3">,</span>
							<span class="s1">allUsedNames</span><span class="s3">,</span>
							<span class="s1">namespaceObjectUsedNames</span><span class="s3">,</span>
							<span class="s1">info</span><span class="s3">.</span><span class="s1">module</span><span class="s3">.</span><span class="s1">readableIdentifier</span><span class="s3">(</span><span class="s1">requestShortener</span><span class="s3">)</span>
						<span class="s3">);</span>
						<span class="s1">allUsedNames</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">namespaceObjectName</span><span class="s3">);</span>
					<span class="s3">}</span>
					<span class="s1">info</span><span class="s3">.</span><span class="s1">namespaceObjectName </span><span class="s3">=</span>
						<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{string} */</span>
						<span class="s3">(</span><span class="s1">namespaceObjectName</span><span class="s3">);</span>
					<span class="s1">topLevelDeclarations</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">namespaceObjectName</span><span class="s3">);</span>
					<span class="s4">break</span><span class="s3">;</span>
				<span class="s3">}</span>
				<span class="s4">case </span><span class="s2">&quot;external&quot;</span><span class="s3">: {</span>
					<span class="s4">const </span><span class="s1">externalName </span><span class="s3">= </span><span class="s1">findNewName</span><span class="s3">(</span>
						<span class="s2">&quot;&quot;</span><span class="s3">,</span>
						<span class="s1">allUsedNames</span><span class="s3">,</span>
						<span class="s1">namespaceObjectUsedNames</span><span class="s3">,</span>
						<span class="s1">info</span><span class="s3">.</span><span class="s1">module</span><span class="s3">.</span><span class="s1">readableIdentifier</span><span class="s3">(</span><span class="s1">requestShortener</span><span class="s3">)</span>
					<span class="s3">);</span>
					<span class="s1">allUsedNames</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">externalName</span><span class="s3">);</span>
					<span class="s1">info</span><span class="s3">.</span><span class="s1">name </span><span class="s3">= </span><span class="s1">externalName</span><span class="s3">;</span>
					<span class="s1">topLevelDeclarations</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">externalName</span><span class="s3">);</span>
					<span class="s4">break</span><span class="s3">;</span>
				<span class="s3">}</span>
			<span class="s3">}</span>
			<span class="s4">const </span><span class="s1">buildMeta </span><span class="s3">= </span><span class="s5">/** </span><span class="s6">@type </span><span class="s5">{BuildMeta} */ </span><span class="s3">(</span><span class="s1">info</span><span class="s3">.</span><span class="s1">module</span><span class="s3">.</span><span class="s1">buildMeta</span><span class="s3">);</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">buildMeta</span><span class="s3">.</span><span class="s1">exportsType </span><span class="s3">!== </span><span class="s2">&quot;namespace&quot;</span><span class="s3">) {</span>
				<span class="s4">const </span><span class="s1">externalNameInterop </span><span class="s3">= </span><span class="s1">findNewName</span><span class="s3">(</span>
					<span class="s2">&quot;namespaceObject&quot;</span><span class="s3">,</span>
					<span class="s1">allUsedNames</span><span class="s3">,</span>
					<span class="s1">namespaceObjectUsedNames</span><span class="s3">,</span>
					<span class="s1">info</span><span class="s3">.</span><span class="s1">module</span><span class="s3">.</span><span class="s1">readableIdentifier</span><span class="s3">(</span><span class="s1">requestShortener</span><span class="s3">)</span>
				<span class="s3">);</span>
				<span class="s1">allUsedNames</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">externalNameInterop</span><span class="s3">);</span>
				<span class="s1">info</span><span class="s3">.</span><span class="s1">interopNamespaceObjectName </span><span class="s3">= </span><span class="s1">externalNameInterop</span><span class="s3">;</span>
				<span class="s1">topLevelDeclarations</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">externalNameInterop</span><span class="s3">);</span>
			<span class="s3">}</span>
			<span class="s4">if </span><span class="s3">(</span>
				<span class="s1">buildMeta</span><span class="s3">.</span><span class="s1">exportsType </span><span class="s3">=== </span><span class="s2">&quot;default&quot; </span><span class="s3">&amp;&amp;</span>
				<span class="s1">buildMeta</span><span class="s3">.</span><span class="s1">defaultObject </span><span class="s3">!== </span><span class="s2">&quot;redirect&quot;</span>
			<span class="s3">) {</span>
				<span class="s4">const </span><span class="s1">externalNameInterop </span><span class="s3">= </span><span class="s1">findNewName</span><span class="s3">(</span>
					<span class="s2">&quot;namespaceObject2&quot;</span><span class="s3">,</span>
					<span class="s1">allUsedNames</span><span class="s3">,</span>
					<span class="s1">namespaceObjectUsedNames</span><span class="s3">,</span>
					<span class="s1">info</span><span class="s3">.</span><span class="s1">module</span><span class="s3">.</span><span class="s1">readableIdentifier</span><span class="s3">(</span><span class="s1">requestShortener</span><span class="s3">)</span>
				<span class="s3">);</span>
				<span class="s1">allUsedNames</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">externalNameInterop</span><span class="s3">);</span>
				<span class="s1">info</span><span class="s3">.</span><span class="s1">interopNamespaceObject2Name </span><span class="s3">= </span><span class="s1">externalNameInterop</span><span class="s3">;</span>
				<span class="s1">topLevelDeclarations</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">externalNameInterop</span><span class="s3">);</span>
			<span class="s3">}</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">buildMeta</span><span class="s3">.</span><span class="s1">exportsType </span><span class="s3">=== </span><span class="s2">&quot;dynamic&quot; </span><span class="s3">|| !</span><span class="s1">buildMeta</span><span class="s3">.</span><span class="s1">exportsType</span><span class="s3">) {</span>
				<span class="s4">const </span><span class="s1">externalNameInterop </span><span class="s3">= </span><span class="s1">findNewName</span><span class="s3">(</span>
					<span class="s2">&quot;default&quot;</span><span class="s3">,</span>
					<span class="s1">allUsedNames</span><span class="s3">,</span>
					<span class="s1">namespaceObjectUsedNames</span><span class="s3">,</span>
					<span class="s1">info</span><span class="s3">.</span><span class="s1">module</span><span class="s3">.</span><span class="s1">readableIdentifier</span><span class="s3">(</span><span class="s1">requestShortener</span><span class="s3">)</span>
				<span class="s3">);</span>
				<span class="s1">allUsedNames</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">externalNameInterop</span><span class="s3">);</span>
				<span class="s1">info</span><span class="s3">.</span><span class="s1">interopDefaultAccessName </span><span class="s3">= </span><span class="s1">externalNameInterop</span><span class="s3">;</span>
				<span class="s1">topLevelDeclarations</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">externalNameInterop</span><span class="s3">);</span>
			<span class="s3">}</span>
		<span class="s3">}</span>

		<span class="s0">// Find and replace references to modules</span>
		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">info of moduleToInfoMap</span><span class="s3">.</span><span class="s1">values</span><span class="s3">()) {</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">info</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">&quot;concatenated&quot;</span><span class="s3">) {</span>
				<span class="s4">const </span><span class="s1">globalScope </span><span class="s3">= </span><span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Scope} */ </span><span class="s3">(</span><span class="s1">info</span><span class="s3">.</span><span class="s1">globalScope</span><span class="s3">);</span>
				<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">reference of globalScope</span><span class="s3">.</span><span class="s1">through</span><span class="s3">) {</span>
					<span class="s4">const </span><span class="s1">name </span><span class="s3">= </span><span class="s1">reference</span><span class="s3">.</span><span class="s1">identifier</span><span class="s3">.</span><span class="s1">name</span><span class="s3">;</span>
					<span class="s4">const </span><span class="s1">match </span><span class="s3">= </span><span class="s1">ConcatenationScope</span><span class="s3">.</span><span class="s1">matchModuleReference</span><span class="s3">(</span><span class="s1">name</span><span class="s3">);</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">match</span><span class="s3">) {</span>
						<span class="s4">const </span><span class="s1">referencedInfo </span><span class="s3">= </span><span class="s1">modulesWithInfo</span><span class="s3">[</span><span class="s1">match</span><span class="s3">.</span><span class="s1">index</span><span class="s3">];</span>
						<span class="s4">if </span><span class="s3">(</span><span class="s1">referencedInfo</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">&quot;reference&quot;</span><span class="s3">)</span>
							<span class="s4">throw new </span><span class="s1">Error</span><span class="s3">(</span><span class="s2">&quot;Module reference can't point to a reference&quot;</span><span class="s3">);</span>
						<span class="s4">const </span><span class="s1">finalName </span><span class="s3">= </span><span class="s1">getFinalName</span><span class="s3">(</span>
							<span class="s1">moduleGraph</span><span class="s3">,</span>
							<span class="s1">referencedInfo</span><span class="s3">,</span>
							<span class="s1">match</span><span class="s3">.</span><span class="s1">ids</span><span class="s3">,</span>
							<span class="s1">moduleToInfoMap</span><span class="s3">,</span>
							<span class="s1">runtime</span><span class="s3">,</span>
							<span class="s1">requestShortener</span><span class="s3">,</span>
							<span class="s1">runtimeTemplate</span><span class="s3">,</span>
							<span class="s1">neededNamespaceObjects</span><span class="s3">,</span>
							<span class="s1">match</span><span class="s3">.</span><span class="s1">call</span><span class="s3">,</span>
							<span class="s3">!</span><span class="s1">match</span><span class="s3">.</span><span class="s1">directImport</span><span class="s3">,</span>
							<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{BuildMeta} */</span>
							<span class="s3">(</span><span class="s1">info</span><span class="s3">.</span><span class="s1">module</span><span class="s3">.</span><span class="s1">buildMeta</span><span class="s3">).</span><span class="s1">strictHarmonyModule</span><span class="s3">,</span>
							<span class="s1">match</span><span class="s3">.</span><span class="s1">asiSafe</span>
						<span class="s3">);</span>
						<span class="s4">const </span><span class="s1">r </span><span class="s3">= </span><span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Range} */ </span><span class="s3">(</span><span class="s1">reference</span><span class="s3">.</span><span class="s1">identifier</span><span class="s3">.</span><span class="s1">range</span><span class="s3">);</span>
						<span class="s4">const </span><span class="s1">source </span><span class="s3">= </span><span class="s5">/** </span><span class="s6">@type </span><span class="s5">{ReplaceSource} */ </span><span class="s3">(</span><span class="s1">info</span><span class="s3">.</span><span class="s1">source</span><span class="s3">);</span>
						<span class="s0">// range is extended by 2 chars to cover the appended &quot;._&quot;</span>
						<span class="s1">source</span><span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span><span class="s1">r</span><span class="s3">[</span><span class="s7">0</span><span class="s3">], </span><span class="s1">r</span><span class="s3">[</span><span class="s7">1</span><span class="s3">] + </span><span class="s7">1</span><span class="s3">, </span><span class="s1">finalName</span><span class="s3">);</span>
					<span class="s3">}</span>
				<span class="s3">}</span>
			<span class="s3">}</span>
		<span class="s3">}</span>

		<span class="s0">// Map with all root exposed used exports</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Map&lt;string, (requestShortener: RequestShortener) =&gt; string&gt;} */</span>
		<span class="s4">const </span><span class="s1">exportsMap </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Map</span><span class="s3">();</span>

		<span class="s0">// Set with all root exposed unused exports</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Set&lt;string&gt;} */</span>
		<span class="s4">const </span><span class="s1">unusedExports </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Set</span><span class="s3">();</span>

		<span class="s4">const </span><span class="s1">rootInfo </span><span class="s3">= </span><span class="s5">/** </span><span class="s6">@type </span><span class="s5">{ConcatenatedModuleInfo} */ </span><span class="s3">(</span>
			<span class="s1">moduleToInfoMap</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">rootModule</span><span class="s3">)</span>
		<span class="s3">);</span>
		<span class="s4">const </span><span class="s1">strictHarmonyModule </span><span class="s3">=</span>
			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{BuildMeta} */</span>
			<span class="s3">(</span><span class="s1">rootInfo</span><span class="s3">.</span><span class="s1">module</span><span class="s3">.</span><span class="s1">buildMeta</span><span class="s3">).</span><span class="s1">strictHarmonyModule</span><span class="s3">;</span>
		<span class="s4">const </span><span class="s1">exportsInfo </span><span class="s3">= </span><span class="s1">moduleGraph</span><span class="s3">.</span><span class="s1">getExportsInfo</span><span class="s3">(</span><span class="s1">rootInfo</span><span class="s3">.</span><span class="s1">module</span><span class="s3">);</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Record&lt;string, string&gt;} */</span>
		<span class="s4">const </span><span class="s1">exportsFinalName </span><span class="s3">= {};</span>
		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">exportInfo of exportsInfo</span><span class="s3">.</span><span class="s1">orderedExports</span><span class="s3">) {</span>
			<span class="s4">const </span><span class="s1">name </span><span class="s3">= </span><span class="s1">exportInfo</span><span class="s3">.</span><span class="s1">name</span><span class="s3">;</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">exportInfo</span><span class="s3">.</span><span class="s1">provided </span><span class="s3">=== </span><span class="s4">false</span><span class="s3">) </span><span class="s4">continue</span><span class="s3">;</span>
			<span class="s4">const </span><span class="s1">used </span><span class="s3">= </span><span class="s1">exportInfo</span><span class="s3">.</span><span class="s1">getUsedName</span><span class="s3">(</span><span class="s1">undefined</span><span class="s3">, </span><span class="s1">runtime</span><span class="s3">);</span>
			<span class="s4">if </span><span class="s3">(!</span><span class="s1">used</span><span class="s3">) {</span>
				<span class="s1">unusedExports</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">name</span><span class="s3">);</span>
				<span class="s4">continue</span><span class="s3">;</span>
			<span class="s3">}</span>
			<span class="s1">exportsMap</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">used</span><span class="s3">, </span><span class="s1">requestShortener </span><span class="s3">=&gt; {</span>
				<span class="s4">try </span><span class="s3">{</span>
					<span class="s4">const </span><span class="s1">finalName </span><span class="s3">= </span><span class="s1">getFinalName</span><span class="s3">(</span>
						<span class="s1">moduleGraph</span><span class="s3">,</span>
						<span class="s1">rootInfo</span><span class="s3">,</span>
						<span class="s3">[</span><span class="s1">name</span><span class="s3">],</span>
						<span class="s1">moduleToInfoMap</span><span class="s3">,</span>
						<span class="s1">runtime</span><span class="s3">,</span>
						<span class="s1">requestShortener</span><span class="s3">,</span>
						<span class="s1">runtimeTemplate</span><span class="s3">,</span>
						<span class="s1">neededNamespaceObjects</span><span class="s3">,</span>
						<span class="s4">false</span><span class="s3">,</span>
						<span class="s4">false</span><span class="s3">,</span>
						<span class="s1">strictHarmonyModule</span><span class="s3">,</span>
						<span class="s4">true</span>
					<span class="s3">);</span>
					<span class="s1">exportsFinalName</span><span class="s3">[</span><span class="s1">used</span><span class="s3">] = </span><span class="s1">finalName</span><span class="s3">;</span>
					<span class="s4">return </span><span class="s2">`/* </span><span class="s1">$</span><span class="s3">{</span>
						<span class="s1">exportInfo</span><span class="s3">.</span><span class="s1">isReexport</span><span class="s3">() ? </span><span class="s2">&quot;reexport&quot; </span><span class="s3">: </span><span class="s2">&quot;binding&quot;</span>
					<span class="s3">} </span><span class="s2">*/ </span><span class="s1">$</span><span class="s3">{</span><span class="s1">finalName</span><span class="s3">}</span><span class="s2">`</span><span class="s3">;</span>
				<span class="s3">} </span><span class="s4">catch </span><span class="s3">(</span><span class="s1">err</span><span class="s3">) {</span>
					<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Error} */</span>
					<span class="s3">(</span><span class="s1">err</span><span class="s3">).</span><span class="s1">message </span><span class="s3">+=</span>
						<span class="s2">`</span><span class="s4">\n</span><span class="s2">while generating the root export '</span><span class="s1">$</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s2">' (used name: '</span><span class="s1">$</span><span class="s3">{</span><span class="s1">used</span><span class="s3">}</span><span class="s2">')`</span><span class="s3">;</span>
					<span class="s4">throw </span><span class="s1">err</span><span class="s3">;</span>
				<span class="s3">}</span>
			<span class="s3">});</span>
		<span class="s3">}</span>

		<span class="s4">const </span><span class="s1">result </span><span class="s3">= </span><span class="s4">new </span><span class="s1">ConcatSource</span><span class="s3">();</span>

		<span class="s0">// add harmony compatibility flag (must be first because of possible circular dependencies)</span>
		<span class="s4">let </span><span class="s1">shouldAddHarmonyFlag </span><span class="s3">= </span><span class="s4">false</span><span class="s3">;</span>
		<span class="s4">if </span><span class="s3">(</span>
			<span class="s1">moduleGraph</span><span class="s3">.</span><span class="s1">getExportsInfo</span><span class="s3">(</span><span class="s4">this</span><span class="s3">).</span><span class="s1">otherExportsInfo</span><span class="s3">.</span><span class="s1">getUsed</span><span class="s3">(</span><span class="s1">runtime</span><span class="s3">) !==</span>
			<span class="s1">UsageState</span><span class="s3">.</span><span class="s1">Unused</span>
		<span class="s3">) {</span>
			<span class="s1">shouldAddHarmonyFlag </span><span class="s3">= </span><span class="s4">true</span><span class="s3">;</span>
		<span class="s3">}</span>

		<span class="s0">// define exports</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">exportsMap</span><span class="s3">.</span><span class="s1">size </span><span class="s3">&gt; </span><span class="s7">0</span><span class="s3">) {</span>
			<span class="s4">const </span><span class="s3">{ </span><span class="s1">exportsDefinitions </span><span class="s3">} = </span><span class="s1">ConcatenatedModule</span><span class="s3">.</span><span class="s1">getCompilationHooks</span><span class="s3">(</span>
				<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Compilation} */</span>
				<span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">compilation</span><span class="s3">)</span>
			<span class="s3">);</span>

			<span class="s4">const </span><span class="s1">definitions </span><span class="s3">= [];</span>
			<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s3">[</span><span class="s1">key</span><span class="s3">, </span><span class="s1">value</span><span class="s3">] </span><span class="s1">of exportsMap</span><span class="s3">) {</span>
				<span class="s1">definitions</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span>
					<span class="s2">`</span><span class="s4">\n  </span><span class="s1">$</span><span class="s3">{</span><span class="s1">propertyName</span><span class="s3">(</span><span class="s1">key</span><span class="s3">)}</span><span class="s2">: </span><span class="s1">$</span><span class="s3">{</span><span class="s1">runtimeTemplate</span><span class="s3">.</span><span class="s1">returningFunction</span><span class="s3">(</span>
						<span class="s1">value</span><span class="s3">(</span><span class="s1">requestShortener</span><span class="s3">)</span>
					<span class="s3">)}</span><span class="s2">`</span>
				<span class="s3">);</span>
			<span class="s3">}</span>

			<span class="s4">const </span><span class="s1">shouldSkipRenderDefinitions </span><span class="s3">= </span><span class="s1">exportsDefinitions</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span>
				<span class="s1">exportsFinalName</span><span class="s3">,</span>
				<span class="s4">this</span>
			<span class="s3">);</span>

			<span class="s4">if </span><span class="s3">(!</span><span class="s1">shouldSkipRenderDefinitions</span><span class="s3">) {</span>
				<span class="s1">runtimeRequirements</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">RuntimeGlobals</span><span class="s3">.</span><span class="s1">exports</span><span class="s3">);</span>
				<span class="s1">runtimeRequirements</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">RuntimeGlobals</span><span class="s3">.</span><span class="s1">definePropertyGetters</span><span class="s3">);</span>

				<span class="s4">if </span><span class="s3">(</span><span class="s1">shouldAddHarmonyFlag</span><span class="s3">) {</span>
					<span class="s1">result</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s2">&quot;// ESM COMPAT FLAG</span><span class="s4">\n</span><span class="s2">&quot;</span><span class="s3">);</span>
					<span class="s1">result</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span>
						<span class="s1">runtimeTemplate</span><span class="s3">.</span><span class="s1">defineEsModuleFlagStatement</span><span class="s3">({</span>
							<span class="s1">exportsArgument</span><span class="s3">: </span><span class="s4">this</span><span class="s3">.</span><span class="s1">exportsArgument</span><span class="s3">,</span>
							<span class="s1">runtimeRequirements</span>
						<span class="s3">})</span>
					<span class="s3">);</span>
				<span class="s3">}</span>

				<span class="s1">result</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s2">&quot;</span><span class="s4">\n</span><span class="s2">// EXPORTS</span><span class="s4">\n</span><span class="s2">&quot;</span><span class="s3">);</span>
				<span class="s1">result</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span>
					<span class="s2">`</span><span class="s1">$</span><span class="s3">{</span><span class="s1">RuntimeGlobals</span><span class="s3">.</span><span class="s1">definePropertyGetters</span><span class="s3">}</span><span class="s2">(</span><span class="s1">$</span><span class="s3">{</span>
						<span class="s4">this</span><span class="s3">.</span><span class="s1">exportsArgument</span>
					<span class="s3">}</span><span class="s2">, {</span><span class="s1">$</span><span class="s3">{</span><span class="s1">definitions</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s2">&quot;,&quot;</span><span class="s3">)}</span><span class="s4">\n</span><span class="s2">});</span><span class="s4">\n</span><span class="s2">`</span>
				<span class="s3">);</span>
			<span class="s3">} </span><span class="s4">else </span><span class="s3">{</span>
				<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{BuildMeta} */</span>
				<span class="s3">(</span><span class="s4">this</span><span class="s3">.</span><span class="s1">buildMeta</span><span class="s3">).</span><span class="s1">exportsFinalName </span><span class="s3">= </span><span class="s1">exportsFinalName</span><span class="s3">;</span>
			<span class="s3">}</span>
		<span class="s3">}</span>

		<span class="s0">// list unused exports</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">unusedExports</span><span class="s3">.</span><span class="s1">size </span><span class="s3">&gt; </span><span class="s7">0</span><span class="s3">) {</span>
			<span class="s1">result</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span>
				<span class="s2">`</span><span class="s4">\n</span><span class="s2">// UNUSED EXPORTS: </span><span class="s1">$</span><span class="s3">{</span><span class="s1">joinIterableWithComma</span><span class="s3">(</span><span class="s1">unusedExports</span><span class="s3">)}</span><span class="s4">\n</span><span class="s2">`</span>
			<span class="s3">);</span>
		<span class="s3">}</span>

		<span class="s0">// generate namespace objects</span>
		<span class="s4">const </span><span class="s1">namespaceObjectSources </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Map</span><span class="s3">();</span>
		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">info of neededNamespaceObjects</span><span class="s3">) {</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">info</span><span class="s3">.</span><span class="s1">namespaceExportSymbol</span><span class="s3">) </span><span class="s4">continue</span><span class="s3">;</span>
			<span class="s4">const </span><span class="s1">nsObj </span><span class="s3">= [];</span>
			<span class="s4">const </span><span class="s1">exportsInfo </span><span class="s3">= </span><span class="s1">moduleGraph</span><span class="s3">.</span><span class="s1">getExportsInfo</span><span class="s3">(</span><span class="s1">info</span><span class="s3">.</span><span class="s1">module</span><span class="s3">);</span>
			<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">exportInfo of exportsInfo</span><span class="s3">.</span><span class="s1">orderedExports</span><span class="s3">) {</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">exportInfo</span><span class="s3">.</span><span class="s1">provided </span><span class="s3">=== </span><span class="s4">false</span><span class="s3">) </span><span class="s4">continue</span><span class="s3">;</span>
				<span class="s4">const </span><span class="s1">usedName </span><span class="s3">= </span><span class="s1">exportInfo</span><span class="s3">.</span><span class="s1">getUsedName</span><span class="s3">(</span><span class="s1">undefined</span><span class="s3">, </span><span class="s1">runtime</span><span class="s3">);</span>
				<span class="s4">if </span><span class="s3">(</span><span class="s1">usedName</span><span class="s3">) {</span>
					<span class="s4">const </span><span class="s1">finalName </span><span class="s3">= </span><span class="s1">getFinalName</span><span class="s3">(</span>
						<span class="s1">moduleGraph</span><span class="s3">,</span>
						<span class="s1">info</span><span class="s3">,</span>
						<span class="s3">[</span><span class="s1">exportInfo</span><span class="s3">.</span><span class="s1">name</span><span class="s3">],</span>
						<span class="s1">moduleToInfoMap</span><span class="s3">,</span>
						<span class="s1">runtime</span><span class="s3">,</span>
						<span class="s1">requestShortener</span><span class="s3">,</span>
						<span class="s1">runtimeTemplate</span><span class="s3">,</span>
						<span class="s1">neededNamespaceObjects</span><span class="s3">,</span>
						<span class="s4">false</span><span class="s3">,</span>
						<span class="s1">undefined</span><span class="s3">,</span>
						<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{BuildMeta} */</span>
						<span class="s3">(</span><span class="s1">info</span><span class="s3">.</span><span class="s1">module</span><span class="s3">.</span><span class="s1">buildMeta</span><span class="s3">).</span><span class="s1">strictHarmonyModule</span><span class="s3">,</span>
						<span class="s4">true</span>
					<span class="s3">);</span>
					<span class="s1">nsObj</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span>
						<span class="s2">`</span><span class="s4">\n  </span><span class="s1">$</span><span class="s3">{</span><span class="s1">propertyName</span><span class="s3">(</span><span class="s1">usedName</span><span class="s3">)}</span><span class="s2">: </span><span class="s1">$</span><span class="s3">{</span><span class="s1">runtimeTemplate</span><span class="s3">.</span><span class="s1">returningFunction</span><span class="s3">(</span>
							<span class="s1">finalName</span>
						<span class="s3">)}</span><span class="s2">`</span>
					<span class="s3">);</span>
				<span class="s3">}</span>
			<span class="s3">}</span>
			<span class="s4">const </span><span class="s1">name </span><span class="s3">= </span><span class="s1">info</span><span class="s3">.</span><span class="s1">namespaceObjectName</span><span class="s3">;</span>
			<span class="s4">const </span><span class="s1">defineGetters </span><span class="s3">=</span>
				<span class="s1">nsObj</span><span class="s3">.</span><span class="s1">length </span><span class="s3">&gt; </span><span class="s7">0</span>
					<span class="s3">? </span><span class="s2">`</span><span class="s1">$</span><span class="s3">{</span><span class="s1">RuntimeGlobals</span><span class="s3">.</span><span class="s1">definePropertyGetters</span><span class="s3">}</span><span class="s2">(</span><span class="s1">$</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s2">, {</span><span class="s1">$</span><span class="s3">{</span><span class="s1">nsObj</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span>
							<span class="s2">&quot;,&quot;</span>
						<span class="s3">)}</span><span class="s4">\n</span><span class="s2">});</span><span class="s4">\n</span><span class="s2">`</span>
					<span class="s3">: </span><span class="s2">&quot;&quot;</span><span class="s3">;</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">nsObj</span><span class="s3">.</span><span class="s1">length </span><span class="s3">&gt; </span><span class="s7">0</span><span class="s3">)</span>
				<span class="s1">runtimeRequirements</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">RuntimeGlobals</span><span class="s3">.</span><span class="s1">definePropertyGetters</span><span class="s3">);</span>
			<span class="s1">namespaceObjectSources</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span>
				<span class="s1">info</span><span class="s3">,</span>
				<span class="s2">`</span>
<span class="s2">// NAMESPACE OBJECT: </span><span class="s1">$</span><span class="s3">{</span><span class="s1">info</span><span class="s3">.</span><span class="s1">module</span><span class="s3">.</span><span class="s1">readableIdentifier</span><span class="s3">(</span><span class="s1">requestShortener</span><span class="s3">)}</span>
<span class="s2">var </span><span class="s1">$</span><span class="s3">{</span><span class="s1">name</span><span class="s3">} </span><span class="s2">= {}; 
</span><span class="s1">$</span><span class="s3">{</span><span class="s1">RuntimeGlobals</span><span class="s3">.</span><span class="s1">makeNamespaceObject</span><span class="s3">}</span><span class="s2">(</span><span class="s1">$</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s2">); 
</span><span class="s1">$</span><span class="s3">{</span><span class="s1">defineGetters</span><span class="s3">}</span><span class="s2">`</span>
			<span class="s3">);</span>
			<span class="s1">runtimeRequirements</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">RuntimeGlobals</span><span class="s3">.</span><span class="s1">makeNamespaceObject</span><span class="s3">);</span>
		<span class="s3">}</span>

		<span class="s0">// define required namespace objects (must be before evaluation modules)</span>
		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">info of modulesWithInfo</span><span class="s3">) {</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">info</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">&quot;concatenated&quot;</span><span class="s3">) {</span>
				<span class="s4">const </span><span class="s1">source </span><span class="s3">= </span><span class="s1">namespaceObjectSources</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">info</span><span class="s3">);</span>
				<span class="s4">if </span><span class="s3">(!</span><span class="s1">source</span><span class="s3">) </span><span class="s4">continue</span><span class="s3">;</span>
				<span class="s1">result</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">source</span><span class="s3">);</span>
			<span class="s3">}</span>
		<span class="s3">}</span>

		<span class="s4">const </span><span class="s1">chunkInitFragments </span><span class="s3">= [];</span>

		<span class="s0">// evaluate modules in order</span>
		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">rawInfo of modulesWithInfo</span><span class="s3">) {</span>
			<span class="s4">let </span><span class="s1">name</span><span class="s3">;</span>
			<span class="s4">let </span><span class="s1">isConditional </span><span class="s3">= </span><span class="s4">false</span><span class="s3">;</span>
			<span class="s4">const </span><span class="s1">info </span><span class="s3">= </span><span class="s1">rawInfo</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">&quot;reference&quot; </span><span class="s3">? </span><span class="s1">rawInfo</span><span class="s3">.</span><span class="s1">target </span><span class="s3">: </span><span class="s1">rawInfo</span><span class="s3">;</span>
			<span class="s4">switch </span><span class="s3">(</span><span class="s1">info</span><span class="s3">.</span><span class="s1">type</span><span class="s3">) {</span>
				<span class="s4">case </span><span class="s2">&quot;concatenated&quot;</span><span class="s3">: {</span>
					<span class="s1">result</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span>
						<span class="s2">`</span><span class="s4">\n</span><span class="s2">;// </span><span class="s1">$</span><span class="s3">{</span><span class="s1">info</span><span class="s3">.</span><span class="s1">module</span><span class="s3">.</span><span class="s1">readableIdentifier</span><span class="s3">(</span><span class="s1">requestShortener</span><span class="s3">)}</span><span class="s4">\n</span><span class="s2">`</span>
					<span class="s3">);</span>
					<span class="s1">result</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s5">/** </span><span class="s6">@type </span><span class="s5">{ReplaceSource} */ </span><span class="s3">(</span><span class="s1">info</span><span class="s3">.</span><span class="s1">source</span><span class="s3">));</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">info</span><span class="s3">.</span><span class="s1">chunkInitFragments</span><span class="s3">) {</span>
						<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">f of info</span><span class="s3">.</span><span class="s1">chunkInitFragments</span><span class="s3">) </span><span class="s1">chunkInitFragments</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">f</span><span class="s3">);</span>
					<span class="s3">}</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">info</span><span class="s3">.</span><span class="s1">runtimeRequirements</span><span class="s3">) {</span>
						<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">r of info</span><span class="s3">.</span><span class="s1">runtimeRequirements</span><span class="s3">) {</span>
							<span class="s1">runtimeRequirements</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">r</span><span class="s3">);</span>
						<span class="s3">}</span>
					<span class="s3">}</span>
					<span class="s1">name </span><span class="s3">= </span><span class="s1">info</span><span class="s3">.</span><span class="s1">namespaceObjectName</span><span class="s3">;</span>
					<span class="s4">break</span><span class="s3">;</span>
				<span class="s3">}</span>
				<span class="s4">case </span><span class="s2">&quot;external&quot;</span><span class="s3">: {</span>
					<span class="s1">result</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span>
						<span class="s2">`</span><span class="s4">\n</span><span class="s2">// EXTERNAL MODULE: </span><span class="s1">$</span><span class="s3">{</span><span class="s1">info</span><span class="s3">.</span><span class="s1">module</span><span class="s3">.</span><span class="s1">readableIdentifier</span><span class="s3">(</span>
							<span class="s1">requestShortener</span>
						<span class="s3">)}</span><span class="s4">\n</span><span class="s2">`</span>
					<span class="s3">);</span>
					<span class="s1">runtimeRequirements</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">RuntimeGlobals</span><span class="s3">.</span><span class="s1">require</span><span class="s3">);</span>
					<span class="s4">const </span><span class="s3">{ </span><span class="s1">runtimeCondition </span><span class="s3">} =</span>
						<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{ExternalModuleInfo | ReferenceToModuleInfo} */ </span><span class="s3">(</span><span class="s1">rawInfo</span><span class="s3">);</span>
					<span class="s4">const </span><span class="s1">condition </span><span class="s3">= </span><span class="s1">runtimeTemplate</span><span class="s3">.</span><span class="s1">runtimeConditionExpression</span><span class="s3">({</span>
						<span class="s1">chunkGraph</span><span class="s3">,</span>
						<span class="s1">runtimeCondition</span><span class="s3">,</span>
						<span class="s1">runtime</span><span class="s3">,</span>
						<span class="s1">runtimeRequirements</span>
					<span class="s3">});</span>
					<span class="s4">if </span><span class="s3">(</span><span class="s1">condition </span><span class="s3">!== </span><span class="s2">&quot;true&quot;</span><span class="s3">) {</span>
						<span class="s1">isConditional </span><span class="s3">= </span><span class="s4">true</span><span class="s3">;</span>
						<span class="s1">result</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s2">`if (</span><span class="s1">$</span><span class="s3">{</span><span class="s1">condition</span><span class="s3">}</span><span class="s2">) {</span><span class="s4">\n</span><span class="s2">`</span><span class="s3">);</span>
					<span class="s3">}</span>
					<span class="s1">result</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span>
						<span class="s2">`var </span><span class="s1">$</span><span class="s3">{</span><span class="s1">info</span><span class="s3">.</span><span class="s1">name</span><span class="s3">} </span><span class="s2">= </span><span class="s1">$</span><span class="s3">{</span><span class="s1">RuntimeGlobals</span><span class="s3">.</span><span class="s1">require</span><span class="s3">}</span><span class="s2">(</span><span class="s1">$</span><span class="s3">{</span><span class="s1">JSON</span><span class="s3">.</span><span class="s1">stringify</span><span class="s3">(</span>
							<span class="s1">chunkGraph</span><span class="s3">.</span><span class="s1">getModuleId</span><span class="s3">(</span><span class="s1">info</span><span class="s3">.</span><span class="s1">module</span><span class="s3">)</span>
						<span class="s3">)}</span><span class="s2">);`</span>
					<span class="s3">);</span>
					<span class="s1">name </span><span class="s3">= </span><span class="s1">info</span><span class="s3">.</span><span class="s1">name</span><span class="s3">;</span>
					<span class="s4">break</span><span class="s3">;</span>
				<span class="s3">}</span>
				<span class="s4">default</span><span class="s3">:</span>
					<span class="s0">// @ts-expect-error never is expected here</span>
					<span class="s4">throw new </span><span class="s1">Error</span><span class="s3">(</span><span class="s2">`Unsupported concatenation entry type </span><span class="s1">$</span><span class="s3">{</span><span class="s1">info</span><span class="s3">.</span><span class="s1">type</span><span class="s3">}</span><span class="s2">`</span><span class="s3">);</span>
			<span class="s3">}</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">info</span><span class="s3">.</span><span class="s1">interopNamespaceObjectUsed</span><span class="s3">) {</span>
				<span class="s1">runtimeRequirements</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">RuntimeGlobals</span><span class="s3">.</span><span class="s1">createFakeNamespaceObject</span><span class="s3">);</span>
				<span class="s1">result</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span>
					<span class="s2">`</span><span class="s4">\n</span><span class="s2">var </span><span class="s1">$</span><span class="s3">{</span><span class="s1">info</span><span class="s3">.</span><span class="s1">interopNamespaceObjectName</span><span class="s3">} </span><span class="s2">= /*#__PURE__*/</span><span class="s1">$</span><span class="s3">{</span><span class="s1">RuntimeGlobals</span><span class="s3">.</span><span class="s1">createFakeNamespaceObject</span><span class="s3">}</span><span class="s2">(</span><span class="s1">$</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s2">, 2);`</span>
				<span class="s3">);</span>
			<span class="s3">}</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">info</span><span class="s3">.</span><span class="s1">interopNamespaceObject2Used</span><span class="s3">) {</span>
				<span class="s1">runtimeRequirements</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">RuntimeGlobals</span><span class="s3">.</span><span class="s1">createFakeNamespaceObject</span><span class="s3">);</span>
				<span class="s1">result</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span>
					<span class="s2">`</span><span class="s4">\n</span><span class="s2">var </span><span class="s1">$</span><span class="s3">{</span><span class="s1">info</span><span class="s3">.</span><span class="s1">interopNamespaceObject2Name</span><span class="s3">} </span><span class="s2">= /*#__PURE__*/</span><span class="s1">$</span><span class="s3">{</span><span class="s1">RuntimeGlobals</span><span class="s3">.</span><span class="s1">createFakeNamespaceObject</span><span class="s3">}</span><span class="s2">(</span><span class="s1">$</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s2">);`</span>
				<span class="s3">);</span>
			<span class="s3">}</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">info</span><span class="s3">.</span><span class="s1">interopDefaultAccessUsed</span><span class="s3">) {</span>
				<span class="s1">runtimeRequirements</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">RuntimeGlobals</span><span class="s3">.</span><span class="s1">compatGetDefaultExport</span><span class="s3">);</span>
				<span class="s1">result</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span>
					<span class="s2">`</span><span class="s4">\n</span><span class="s2">var </span><span class="s1">$</span><span class="s3">{</span><span class="s1">info</span><span class="s3">.</span><span class="s1">interopDefaultAccessName</span><span class="s3">} </span><span class="s2">= /*#__PURE__*/</span><span class="s1">$</span><span class="s3">{</span><span class="s1">RuntimeGlobals</span><span class="s3">.</span><span class="s1">compatGetDefaultExport</span><span class="s3">}</span><span class="s2">(</span><span class="s1">$</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s2">);`</span>
				<span class="s3">);</span>
			<span class="s3">}</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">isConditional</span><span class="s3">) {</span>
				<span class="s1">result</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s2">&quot;</span><span class="s4">\n</span><span class="s2">}&quot;</span><span class="s3">);</span>
			<span class="s3">}</span>
		<span class="s3">}</span>

		<span class="s4">const </span><span class="s1">data </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Map</span><span class="s3">();</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">chunkInitFragments</span><span class="s3">.</span><span class="s1">length </span><span class="s3">&gt; </span><span class="s7">0</span><span class="s3">)</span>
			<span class="s1">data</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s2">&quot;chunkInitFragments&quot;</span><span class="s3">, </span><span class="s1">chunkInitFragments</span><span class="s3">);</span>
		<span class="s1">data</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s2">&quot;topLevelDeclarations&quot;</span><span class="s3">, </span><span class="s1">topLevelDeclarations</span><span class="s3">);</span>

		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{CodeGenerationResult} */</span>
		<span class="s4">const </span><span class="s1">resultEntry </span><span class="s3">= {</span>
			<span class="s1">sources</span><span class="s3">: </span><span class="s4">new </span><span class="s1">Map</span><span class="s3">([[</span><span class="s2">&quot;javascript&quot;</span><span class="s3">, </span><span class="s4">new </span><span class="s1">CachedSource</span><span class="s3">(</span><span class="s1">result</span><span class="s3">)]]),</span>
			<span class="s1">data</span><span class="s3">,</span>
			<span class="s1">runtimeRequirements</span>
		<span class="s3">};</span>

		<span class="s4">return </span><span class="s1">resultEntry</span><span class="s3">;</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Map&lt;Module, ModuleInfo&gt;} modulesMap modulesMap</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{ModuleInfo} info info</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{DependencyTemplates} dependencyTemplates dependencyTemplates</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{RuntimeTemplate} runtimeTemplate runtimeTemplate</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{ModuleGraph} moduleGraph moduleGraph</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{ChunkGraph} chunkGraph chunkGraph</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{RuntimeSpec} runtime runtime</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{CodeGenerationResults} codeGenerationResults codeGenerationResults</span>
	 <span class="s5">*/</span>
	<span class="s1">_analyseModule</span><span class="s3">(</span>
		<span class="s1">modulesMap</span><span class="s3">,</span>
		<span class="s1">info</span><span class="s3">,</span>
		<span class="s1">dependencyTemplates</span><span class="s3">,</span>
		<span class="s1">runtimeTemplate</span><span class="s3">,</span>
		<span class="s1">moduleGraph</span><span class="s3">,</span>
		<span class="s1">chunkGraph</span><span class="s3">,</span>
		<span class="s1">runtime</span><span class="s3">,</span>
		<span class="s1">codeGenerationResults</span>
	<span class="s3">) {</span>
		<span class="s4">if </span><span class="s3">(</span><span class="s1">info</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">&quot;concatenated&quot;</span><span class="s3">) {</span>
			<span class="s4">const </span><span class="s1">m </span><span class="s3">= </span><span class="s1">info</span><span class="s3">.</span><span class="s1">module</span><span class="s3">;</span>
			<span class="s4">try </span><span class="s3">{</span>
				<span class="s0">// Create a concatenation scope to track and capture information</span>
				<span class="s4">const </span><span class="s1">concatenationScope </span><span class="s3">= </span><span class="s4">new </span><span class="s1">ConcatenationScope</span><span class="s3">(</span><span class="s1">modulesMap</span><span class="s3">, </span><span class="s1">info</span><span class="s3">);</span>

				<span class="s0">// TODO cache codeGeneration results</span>
				<span class="s4">const </span><span class="s1">codeGenResult </span><span class="s3">= </span><span class="s1">m</span><span class="s3">.</span><span class="s1">codeGeneration</span><span class="s3">({</span>
					<span class="s1">dependencyTemplates</span><span class="s3">,</span>
					<span class="s1">runtimeTemplate</span><span class="s3">,</span>
					<span class="s1">moduleGraph</span><span class="s3">,</span>
					<span class="s1">chunkGraph</span><span class="s3">,</span>
					<span class="s1">runtime</span><span class="s3">,</span>
					<span class="s1">concatenationScope</span><span class="s3">,</span>
					<span class="s1">codeGenerationResults</span><span class="s3">,</span>
					<span class="s1">sourceTypes</span><span class="s3">: </span><span class="s1">JS_TYPES</span>
				<span class="s3">});</span>
				<span class="s4">const </span><span class="s1">source </span><span class="s3">= </span><span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Source} */ </span><span class="s3">(</span>
					<span class="s1">codeGenResult</span><span class="s3">.</span><span class="s1">sources</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s2">&quot;javascript&quot;</span><span class="s3">)</span>
				<span class="s3">);</span>
				<span class="s4">const </span><span class="s1">data </span><span class="s3">= </span><span class="s1">codeGenResult</span><span class="s3">.</span><span class="s1">data</span><span class="s3">;</span>
				<span class="s4">const </span><span class="s1">chunkInitFragments </span><span class="s3">= </span><span class="s1">data </span><span class="s3">&amp;&amp; </span><span class="s1">data</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s2">&quot;chunkInitFragments&quot;</span><span class="s3">);</span>
				<span class="s4">const </span><span class="s1">code </span><span class="s3">= </span><span class="s1">source</span><span class="s3">.</span><span class="s1">source</span><span class="s3">().</span><span class="s1">toString</span><span class="s3">();</span>
				<span class="s4">let </span><span class="s1">ast</span><span class="s3">;</span>
				<span class="s4">try </span><span class="s3">{</span>
					<span class="s1">ast </span><span class="s3">= </span><span class="s1">JavascriptParser</span><span class="s3">.</span><span class="s1">_parse</span><span class="s3">(</span><span class="s1">code</span><span class="s3">, {</span>
						<span class="s1">sourceType</span><span class="s3">: </span><span class="s2">&quot;module&quot;</span>
					<span class="s3">});</span>
				<span class="s3">} </span><span class="s4">catch </span><span class="s3">(</span><span class="s1">_err</span><span class="s3">) {</span>
					<span class="s4">const </span><span class="s1">err </span><span class="s3">= </span><span class="s5">/** </span><span class="s6">@type </span><span class="s5">{TODO} */ </span><span class="s3">(</span><span class="s1">_err</span><span class="s3">);</span>
					<span class="s4">if </span><span class="s3">(</span>
						<span class="s1">err</span><span class="s3">.</span><span class="s1">loc </span><span class="s3">&amp;&amp;</span>
						<span class="s4">typeof </span><span class="s1">err</span><span class="s3">.</span><span class="s1">loc </span><span class="s3">=== </span><span class="s2">&quot;object&quot; </span><span class="s3">&amp;&amp;</span>
						<span class="s4">typeof </span><span class="s1">err</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">.</span><span class="s1">line </span><span class="s3">=== </span><span class="s2">&quot;number&quot;</span>
					<span class="s3">) {</span>
						<span class="s4">const </span><span class="s1">lineNumber </span><span class="s3">= </span><span class="s1">err</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">.</span><span class="s1">line</span><span class="s3">;</span>
						<span class="s4">const </span><span class="s1">lines </span><span class="s3">= </span><span class="s1">code</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s2">&quot;</span><span class="s4">\n</span><span class="s2">&quot;</span><span class="s3">);</span>
						<span class="s1">err</span><span class="s3">.</span><span class="s1">message </span><span class="s3">+= </span><span class="s2">`</span><span class="s4">\n</span><span class="s2">| </span><span class="s1">$</span><span class="s3">{</span><span class="s1">lines</span>
							<span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span><span class="s1">Math</span><span class="s3">.</span><span class="s1">max</span><span class="s3">(</span><span class="s7">0</span><span class="s3">, </span><span class="s1">lineNumber </span><span class="s3">- </span><span class="s7">3</span><span class="s3">), </span><span class="s1">lineNumber </span><span class="s3">+ </span><span class="s7">2</span><span class="s3">)</span>
							<span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s2">&quot;</span><span class="s4">\n</span><span class="s2">| &quot;</span><span class="s3">)}</span><span class="s2">`</span><span class="s3">;</span>
					<span class="s3">}</span>
					<span class="s4">throw </span><span class="s1">err</span><span class="s3">;</span>
				<span class="s3">}</span>
				<span class="s4">const </span><span class="s1">scopeManager </span><span class="s3">= </span><span class="s1">eslintScope</span><span class="s3">.</span><span class="s1">analyze</span><span class="s3">(</span><span class="s1">ast</span><span class="s3">, {</span>
					<span class="s1">ecmaVersion</span><span class="s3">: </span><span class="s7">6</span><span class="s3">,</span>
					<span class="s1">sourceType</span><span class="s3">: </span><span class="s2">&quot;module&quot;</span><span class="s3">,</span>
					<span class="s1">optimistic</span><span class="s3">: </span><span class="s4">true</span><span class="s3">,</span>
					<span class="s1">ignoreEval</span><span class="s3">: </span><span class="s4">true</span><span class="s3">,</span>
					<span class="s1">impliedStrict</span><span class="s3">: </span><span class="s4">true</span>
				<span class="s3">});</span>
				<span class="s4">const </span><span class="s1">globalScope </span><span class="s3">= </span><span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Scope} */ </span><span class="s3">(</span><span class="s1">scopeManager</span><span class="s3">.</span><span class="s1">acquire</span><span class="s3">(</span><span class="s1">ast</span><span class="s3">));</span>
				<span class="s4">const </span><span class="s1">moduleScope </span><span class="s3">= </span><span class="s1">globalScope</span><span class="s3">.</span><span class="s1">childScopes</span><span class="s3">[</span><span class="s7">0</span><span class="s3">];</span>
				<span class="s4">const </span><span class="s1">resultSource </span><span class="s3">= </span><span class="s4">new </span><span class="s1">ReplaceSource</span><span class="s3">(</span><span class="s1">source</span><span class="s3">);</span>
				<span class="s1">info</span><span class="s3">.</span><span class="s1">runtimeRequirements </span><span class="s3">=</span>
					<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{ReadOnlyRuntimeRequirements} */</span>
					<span class="s3">(</span><span class="s1">codeGenResult</span><span class="s3">.</span><span class="s1">runtimeRequirements</span><span class="s3">);</span>
				<span class="s1">info</span><span class="s3">.</span><span class="s1">ast </span><span class="s3">= </span><span class="s1">ast</span><span class="s3">;</span>
				<span class="s1">info</span><span class="s3">.</span><span class="s1">internalSource </span><span class="s3">= </span><span class="s1">source</span><span class="s3">;</span>
				<span class="s1">info</span><span class="s3">.</span><span class="s1">source </span><span class="s3">= </span><span class="s1">resultSource</span><span class="s3">;</span>
				<span class="s1">info</span><span class="s3">.</span><span class="s1">chunkInitFragments </span><span class="s3">= </span><span class="s1">chunkInitFragments</span><span class="s3">;</span>
				<span class="s1">info</span><span class="s3">.</span><span class="s1">globalScope </span><span class="s3">= </span><span class="s1">globalScope</span><span class="s3">;</span>
				<span class="s1">info</span><span class="s3">.</span><span class="s1">moduleScope </span><span class="s3">= </span><span class="s1">moduleScope</span><span class="s3">;</span>
			<span class="s3">} </span><span class="s4">catch </span><span class="s3">(</span><span class="s1">err</span><span class="s3">) {</span>
				<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Error} */</span>
				<span class="s3">(</span><span class="s1">err</span><span class="s3">).</span><span class="s1">message </span><span class="s3">+=</span>
					<span class="s2">`</span><span class="s4">\n</span><span class="s2">while analyzing module </span><span class="s1">$</span><span class="s3">{</span><span class="s1">m</span><span class="s3">.</span><span class="s1">identifier</span><span class="s3">()} </span><span class="s2">for concatenation`</span><span class="s3">;</span>
				<span class="s4">throw </span><span class="s1">err</span><span class="s3">;</span>
			<span class="s3">}</span>
		<span class="s3">}</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{ModuleGraph} moduleGraph the module graph</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{RuntimeSpec} runtime the runtime</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{[ModuleInfoOrReference[], Map&lt;Module, ModuleInfo&gt;]} module info items</span>
	 <span class="s5">*/</span>
	<span class="s1">_getModulesWithInfo</span><span class="s3">(</span><span class="s1">moduleGraph</span><span class="s3">, </span><span class="s1">runtime</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">orderedConcatenationList </span><span class="s3">= </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_createConcatenationList</span><span class="s3">(</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">rootModule</span><span class="s3">,</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">_modules</span><span class="s3">,</span>
			<span class="s1">runtime</span><span class="s3">,</span>
			<span class="s1">moduleGraph</span>
		<span class="s3">);</span>
		<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{Map&lt;Module, ModuleInfo&gt;} */</span>
		<span class="s4">const </span><span class="s1">map </span><span class="s3">= </span><span class="s4">new </span><span class="s1">Map</span><span class="s3">();</span>
		<span class="s4">const </span><span class="s1">list </span><span class="s3">= </span><span class="s1">orderedConcatenationList</span><span class="s3">.</span><span class="s1">map</span><span class="s3">((</span><span class="s1">info</span><span class="s3">, </span><span class="s1">index</span><span class="s3">) =&gt; {</span>
			<span class="s4">let </span><span class="s1">item </span><span class="s3">= </span><span class="s1">map</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">info</span><span class="s3">.</span><span class="s1">module</span><span class="s3">);</span>
			<span class="s4">if </span><span class="s3">(</span><span class="s1">item </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) {</span>
				<span class="s4">switch </span><span class="s3">(</span><span class="s1">info</span><span class="s3">.</span><span class="s1">type</span><span class="s3">) {</span>
					<span class="s4">case </span><span class="s2">&quot;concatenated&quot;</span><span class="s3">:</span>
						<span class="s1">item </span><span class="s3">= {</span>
							<span class="s1">type</span><span class="s3">: </span><span class="s2">&quot;concatenated&quot;</span><span class="s3">,</span>
							<span class="s1">module</span><span class="s3">: </span><span class="s1">info</span><span class="s3">.</span><span class="s1">module</span><span class="s3">,</span>
							<span class="s1">index</span><span class="s3">,</span>
							<span class="s1">ast</span><span class="s3">: </span><span class="s1">undefined</span><span class="s3">,</span>
							<span class="s1">internalSource</span><span class="s3">: </span><span class="s1">undefined</span><span class="s3">,</span>
							<span class="s1">runtimeRequirements</span><span class="s3">: </span><span class="s1">undefined</span><span class="s3">,</span>
							<span class="s1">source</span><span class="s3">: </span><span class="s1">undefined</span><span class="s3">,</span>
							<span class="s1">globalScope</span><span class="s3">: </span><span class="s1">undefined</span><span class="s3">,</span>
							<span class="s1">moduleScope</span><span class="s3">: </span><span class="s1">undefined</span><span class="s3">,</span>
							<span class="s1">internalNames</span><span class="s3">: </span><span class="s4">new </span><span class="s1">Map</span><span class="s3">(),</span>
							<span class="s1">exportMap</span><span class="s3">: </span><span class="s1">undefined</span><span class="s3">,</span>
							<span class="s1">rawExportMap</span><span class="s3">: </span><span class="s1">undefined</span><span class="s3">,</span>
							<span class="s1">namespaceExportSymbol</span><span class="s3">: </span><span class="s1">undefined</span><span class="s3">,</span>
							<span class="s1">namespaceObjectName</span><span class="s3">: </span><span class="s1">undefined</span><span class="s3">,</span>
							<span class="s1">interopNamespaceObjectUsed</span><span class="s3">: </span><span class="s4">false</span><span class="s3">,</span>
							<span class="s1">interopNamespaceObjectName</span><span class="s3">: </span><span class="s1">undefined</span><span class="s3">,</span>
							<span class="s1">interopNamespaceObject2Used</span><span class="s3">: </span><span class="s4">false</span><span class="s3">,</span>
							<span class="s1">interopNamespaceObject2Name</span><span class="s3">: </span><span class="s1">undefined</span><span class="s3">,</span>
							<span class="s1">interopDefaultAccessUsed</span><span class="s3">: </span><span class="s4">false</span><span class="s3">,</span>
							<span class="s1">interopDefaultAccessName</span><span class="s3">: </span><span class="s1">undefined</span>
						<span class="s3">};</span>
						<span class="s4">break</span><span class="s3">;</span>
					<span class="s4">case </span><span class="s2">&quot;external&quot;</span><span class="s3">:</span>
						<span class="s1">item </span><span class="s3">= {</span>
							<span class="s1">type</span><span class="s3">: </span><span class="s2">&quot;external&quot;</span><span class="s3">,</span>
							<span class="s1">module</span><span class="s3">: </span><span class="s1">info</span><span class="s3">.</span><span class="s1">module</span><span class="s3">,</span>
							<span class="s1">runtimeCondition</span><span class="s3">: </span><span class="s1">info</span><span class="s3">.</span><span class="s1">runtimeCondition</span><span class="s3">,</span>
							<span class="s1">index</span><span class="s3">,</span>
							<span class="s1">name</span><span class="s3">: </span><span class="s1">undefined</span><span class="s3">,</span>
							<span class="s1">interopNamespaceObjectUsed</span><span class="s3">: </span><span class="s4">false</span><span class="s3">,</span>
							<span class="s1">interopNamespaceObjectName</span><span class="s3">: </span><span class="s1">undefined</span><span class="s3">,</span>
							<span class="s1">interopNamespaceObject2Used</span><span class="s3">: </span><span class="s4">false</span><span class="s3">,</span>
							<span class="s1">interopNamespaceObject2Name</span><span class="s3">: </span><span class="s1">undefined</span><span class="s3">,</span>
							<span class="s1">interopDefaultAccessUsed</span><span class="s3">: </span><span class="s4">false</span><span class="s3">,</span>
							<span class="s1">interopDefaultAccessName</span><span class="s3">: </span><span class="s1">undefined</span>
						<span class="s3">};</span>
						<span class="s4">break</span><span class="s3">;</span>
					<span class="s4">default</span><span class="s3">:</span>
						<span class="s4">throw new </span><span class="s1">Error</span><span class="s3">(</span>
							<span class="s2">`Unsupported concatenation entry type </span><span class="s1">$</span><span class="s3">{</span><span class="s1">info</span><span class="s3">.</span><span class="s1">type</span><span class="s3">}</span><span class="s2">`</span>
						<span class="s3">);</span>
				<span class="s3">}</span>
				<span class="s1">map</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span>
					<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{ModuleInfo} */ </span><span class="s3">(</span><span class="s1">item</span><span class="s3">).</span><span class="s1">module</span><span class="s3">,</span>
					<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{ModuleInfo} */ </span><span class="s3">(</span><span class="s1">item</span><span class="s3">)</span>
				<span class="s3">);</span>
				<span class="s4">return </span><span class="s5">/** </span><span class="s6">@type </span><span class="s5">{ModuleInfo} */ </span><span class="s3">(</span><span class="s1">item</span><span class="s3">);</span>
			<span class="s3">}</span>
			<span class="s5">/** </span><span class="s6">@type </span><span class="s5">{ReferenceToModuleInfo} */</span>
			<span class="s4">const </span><span class="s1">ref </span><span class="s3">= {</span>
				<span class="s1">type</span><span class="s3">: </span><span class="s2">&quot;reference&quot;</span><span class="s3">,</span>
				<span class="s1">runtimeCondition</span><span class="s3">: </span><span class="s1">info</span><span class="s3">.</span><span class="s1">runtimeCondition</span><span class="s3">,</span>
				<span class="s1">target</span><span class="s3">: </span><span class="s1">item</span>
			<span class="s3">};</span>
			<span class="s4">return </span><span class="s1">ref</span><span class="s3">;</span>
		<span class="s3">});</span>
		<span class="s4">return </span><span class="s3">[</span><span class="s1">list</span><span class="s3">, </span><span class="s1">map</span><span class="s3">];</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Hash} hash the hash used to track dependencies</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{UpdateHashContext} context context</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
	 <span class="s5">*/</span>
	<span class="s1">updateHash</span><span class="s3">(</span><span class="s1">hash</span><span class="s3">, </span><span class="s1">context</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s3">{ </span><span class="s1">chunkGraph</span><span class="s3">, </span><span class="s1">runtime </span><span class="s3">} = </span><span class="s1">context</span><span class="s3">;</span>
		<span class="s4">for </span><span class="s3">(</span><span class="s4">const </span><span class="s1">info of </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_createConcatenationList</span><span class="s3">(</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">rootModule</span><span class="s3">,</span>
			<span class="s4">this</span><span class="s3">.</span><span class="s1">_modules</span><span class="s3">,</span>
			<span class="s1">intersectRuntime</span><span class="s3">(</span><span class="s1">runtime</span><span class="s3">, </span><span class="s4">this</span><span class="s3">.</span><span class="s1">_runtime</span><span class="s3">),</span>
			<span class="s1">chunkGraph</span><span class="s3">.</span><span class="s1">moduleGraph</span>
		<span class="s3">)) {</span>
			<span class="s4">switch </span><span class="s3">(</span><span class="s1">info</span><span class="s3">.</span><span class="s1">type</span><span class="s3">) {</span>
				<span class="s4">case </span><span class="s2">&quot;concatenated&quot;</span><span class="s3">:</span>
					<span class="s1">info</span><span class="s3">.</span><span class="s1">module</span><span class="s3">.</span><span class="s1">updateHash</span><span class="s3">(</span><span class="s1">hash</span><span class="s3">, </span><span class="s1">context</span><span class="s3">);</span>
					<span class="s4">break</span><span class="s3">;</span>
				<span class="s4">case </span><span class="s2">&quot;external&quot;</span><span class="s3">:</span>
					<span class="s1">hash</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s2">`</span><span class="s1">$</span><span class="s3">{</span><span class="s1">chunkGraph</span><span class="s3">.</span><span class="s1">getModuleId</span><span class="s3">(</span><span class="s1">info</span><span class="s3">.</span><span class="s1">module</span><span class="s3">)}</span><span class="s2">`</span><span class="s3">);</span>
					<span class="s0">// TODO runtimeCondition</span>
					<span class="s4">break</span><span class="s3">;</span>
			<span class="s3">}</span>
		<span class="s3">}</span>
		<span class="s4">super</span><span class="s3">.</span><span class="s1">updateHash</span><span class="s3">(</span><span class="s1">hash</span><span class="s3">, </span><span class="s1">context</span><span class="s3">);</span>
	<span class="s3">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{ObjectDeserializerContext} context context</span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{ConcatenatedModule} ConcatenatedModule</span>
	 <span class="s5">*/</span>
	<span class="s4">static </span><span class="s1">deserialize</span><span class="s3">(</span><span class="s1">context</span><span class="s3">) {</span>
		<span class="s4">const </span><span class="s1">obj </span><span class="s3">= </span><span class="s4">new </span><span class="s1">ConcatenatedModule</span><span class="s3">({</span>
			<span class="s1">identifier</span><span class="s3">: </span><span class="s5">/** </span><span class="s6">@type </span><span class="s5">{EXPECTED_ANY} */ </span><span class="s3">(</span><span class="s1">undefined</span><span class="s3">),</span>
			<span class="s1">rootModule</span><span class="s3">: </span><span class="s5">/** </span><span class="s6">@type </span><span class="s5">{EXPECTED_ANY} */ </span><span class="s3">(</span><span class="s1">undefined</span><span class="s3">),</span>
			<span class="s1">modules</span><span class="s3">: </span><span class="s5">/** </span><span class="s6">@type </span><span class="s5">{EXPECTED_ANY} */ </span><span class="s3">(</span><span class="s1">undefined</span><span class="s3">),</span>
			<span class="s1">runtime</span><span class="s3">: </span><span class="s1">undefined</span><span class="s3">,</span>
			<span class="s1">compilation</span><span class="s3">: </span><span class="s5">/** </span><span class="s6">@type </span><span class="s5">{EXPECTED_ANY} */ </span><span class="s3">(</span><span class="s1">undefined</span><span class="s3">)</span>
		<span class="s3">});</span>
		<span class="s1">obj</span><span class="s3">.</span><span class="s1">deserialize</span><span class="s3">(</span><span class="s1">context</span><span class="s3">);</span>
		<span class="s4">return </span><span class="s1">obj</span><span class="s3">;</span>
	<span class="s3">}</span>
<span class="s3">}</span>

<span class="s1">makeSerializable</span><span class="s3">(</span><span class="s1">ConcatenatedModule</span><span class="s3">, </span><span class="s2">&quot;webpack/lib/optimize/ConcatenatedModule&quot;</span><span class="s3">);</span>

<span class="s1">module</span><span class="s3">.</span><span class="s1">exports </span><span class="s3">= </span><span class="s1">ConcatenatedModule</span><span class="s3">;</span>
</pre>
</body>
</html>