<html>
<head>
<title>SymbolTree.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #6aab73;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #5f826b; font-style: italic;}
.s4 { color: #67a37c; font-style: italic;}
.s5 { color: #cf8e6d;}
.s6 { color: #2aacb8;}
.s7 { color: #7a7e85;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
SymbolTree.js</font>
</center></td></tr></table>
<pre><span class="s0">'use strict'</span><span class="s1">;</span>

<span class="s3">/**</span>
 <span class="s3">* </span><span class="s4">@module </span><span class="s3">symbol-tree</span>
 <span class="s3">* </span><span class="s4">@author </span><span class="s3">Joris van der Wel &lt;joris@jorisvanderwel.com&gt;</span>
 <span class="s3">*/</span>

<span class="s5">const </span><span class="s2">SymbolTreeNode </span><span class="s1">= </span><span class="s2">require</span><span class="s1">(</span><span class="s0">'./SymbolTreeNode'</span><span class="s1">);</span>
<span class="s5">const </span><span class="s2">TreePosition </span><span class="s1">= </span><span class="s2">require</span><span class="s1">(</span><span class="s0">'./TreePosition'</span><span class="s1">);</span>
<span class="s5">const </span><span class="s2">TreeIterator </span><span class="s1">= </span><span class="s2">require</span><span class="s1">(</span><span class="s0">'./TreeIterator'</span><span class="s1">);</span>

<span class="s5">function </span><span class="s2">returnTrue</span><span class="s1">() {</span>
        <span class="s5">return true</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s5">function </span><span class="s2">reverseArrayIndex</span><span class="s1">(</span><span class="s2">array</span><span class="s1">, </span><span class="s2">reverseIndex</span><span class="s1">) {</span>
        <span class="s5">return </span><span class="s2">array</span><span class="s1">[</span><span class="s2">array</span><span class="s1">.</span><span class="s2">length </span><span class="s1">- </span><span class="s6">1 </span><span class="s1">- </span><span class="s2">reverseIndex</span><span class="s1">]; </span><span class="s7">// no need to check `index &gt;= 0`</span>
<span class="s1">}</span>

<span class="s5">class </span><span class="s2">SymbolTree </span><span class="s1">{</span>

        <span class="s3">/**</span>
         <span class="s3">* </span><span class="s4">@constructor</span>
         <span class="s3">* </span><span class="s4">@alias </span><span class="s3">module:symbol-tree</span>
         <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} [description='SymbolTree data'] Description used for the Symbol</span>
         <span class="s3">*/</span>
        <span class="s2">constructor</span><span class="s1">(</span><span class="s2">description</span><span class="s1">) {</span>
                <span class="s5">this</span><span class="s1">.</span><span class="s2">symbol </span><span class="s1">= </span><span class="s2">Symbol</span><span class="s1">(</span><span class="s2">description </span><span class="s1">|| </span><span class="s0">'SymbolTree data'</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s3">/**</span>
         <span class="s3">* You can use this function to (optionally) initialize an object right after its creation,</span>
         <span class="s3">* to take advantage of V8's fast properties. Also useful if you would like to</span>
         <span class="s3">* freeze your object.</span>
         <span class="s3">*</span>
         <span class="s3">* `O(1)`</span>
         <span class="s3">*</span>
         <span class="s3">* </span><span class="s4">@method</span>
         <span class="s3">* </span><span class="s4">@alias </span><span class="s3">module:symbol-tree#initialize</span>
         <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object} object</span>
         <span class="s3">* </span><span class="s4">@return </span><span class="s3">{Object} object</span>
         <span class="s3">*/</span>
        <span class="s2">initialize</span><span class="s1">(</span><span class="s2">object</span><span class="s1">) {</span>
                <span class="s5">this</span><span class="s1">.</span><span class="s2">_node</span><span class="s1">(</span><span class="s2">object</span><span class="s1">);</span>

                <span class="s5">return </span><span class="s2">object</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s2">_node</span><span class="s1">(</span><span class="s2">object</span><span class="s1">) {</span>
                <span class="s5">if </span><span class="s1">(!</span><span class="s2">object</span><span class="s1">) {</span>
                        <span class="s5">return null</span><span class="s1">;</span>
                <span class="s1">}</span>

                <span class="s5">const </span><span class="s2">node </span><span class="s1">= </span><span class="s2">object</span><span class="s1">[</span><span class="s5">this</span><span class="s1">.</span><span class="s2">symbol</span><span class="s1">];</span>

                <span class="s5">if </span><span class="s1">(</span><span class="s2">node</span><span class="s1">) {</span>
                        <span class="s5">return </span><span class="s2">node</span><span class="s1">;</span>
                <span class="s1">}</span>

                <span class="s5">return </span><span class="s1">(</span><span class="s2">object</span><span class="s1">[</span><span class="s5">this</span><span class="s1">.</span><span class="s2">symbol</span><span class="s1">] = </span><span class="s5">new </span><span class="s2">SymbolTreeNode</span><span class="s1">());</span>
        <span class="s1">}</span>

        <span class="s3">/**</span>
         <span class="s3">* Returns `true` if the object has any children. Otherwise it returns `false`.</span>
         <span class="s3">*</span>
         <span class="s3">* * `O(1)`</span>
         <span class="s3">*</span>
         <span class="s3">* </span><span class="s4">@method </span><span class="s3">hasChildren</span>
         <span class="s3">* </span><span class="s4">@memberOf </span><span class="s3">module:symbol-tree#</span>
         <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object} object</span>
         <span class="s3">* </span><span class="s4">@return </span><span class="s3">{Boolean}</span>
         <span class="s3">*/</span>
        <span class="s2">hasChildren</span><span class="s1">(</span><span class="s2">object</span><span class="s1">) {</span>
                <span class="s5">return this</span><span class="s1">.</span><span class="s2">_node</span><span class="s1">(</span><span class="s2">object</span><span class="s1">).</span><span class="s2">hasChildren</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">/**</span>
         <span class="s3">* Returns the first child of the given object.</span>
         <span class="s3">*</span>
         <span class="s3">* * `O(1)`</span>
         <span class="s3">*</span>
         <span class="s3">* </span><span class="s4">@method </span><span class="s3">firstChild</span>
         <span class="s3">* </span><span class="s4">@memberOf </span><span class="s3">module:symbol-tree#</span>
         <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object} object</span>
         <span class="s3">* </span><span class="s4">@return </span><span class="s3">{Object}</span>
         <span class="s3">*/</span>
        <span class="s2">firstChild</span><span class="s1">(</span><span class="s2">object</span><span class="s1">) {</span>
                <span class="s5">return this</span><span class="s1">.</span><span class="s2">_node</span><span class="s1">(</span><span class="s2">object</span><span class="s1">).</span><span class="s2">firstChild</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">/**</span>
         <span class="s3">* Returns the last child of the given object.</span>
         <span class="s3">*</span>
         <span class="s3">* * `O(1)`</span>
         <span class="s3">*</span>
         <span class="s3">* </span><span class="s4">@method </span><span class="s3">lastChild</span>
         <span class="s3">* </span><span class="s4">@memberOf </span><span class="s3">module:symbol-tree#</span>
         <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object} object</span>
         <span class="s3">* </span><span class="s4">@return </span><span class="s3">{Object}</span>
         <span class="s3">*/</span>
        <span class="s2">lastChild</span><span class="s1">(</span><span class="s2">object</span><span class="s1">) {</span>
                <span class="s5">return this</span><span class="s1">.</span><span class="s2">_node</span><span class="s1">(</span><span class="s2">object</span><span class="s1">).</span><span class="s2">lastChild</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">/**</span>
         <span class="s3">* Returns the previous sibling of the given object.</span>
         <span class="s3">*</span>
         <span class="s3">* * `O(1)`</span>
         <span class="s3">*</span>
         <span class="s3">* </span><span class="s4">@method </span><span class="s3">previousSibling</span>
         <span class="s3">* </span><span class="s4">@memberOf </span><span class="s3">module:symbol-tree#</span>
         <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object} object</span>
         <span class="s3">* </span><span class="s4">@return </span><span class="s3">{Object}</span>
         <span class="s3">*/</span>
        <span class="s2">previousSibling</span><span class="s1">(</span><span class="s2">object</span><span class="s1">) {</span>
                <span class="s5">return this</span><span class="s1">.</span><span class="s2">_node</span><span class="s1">(</span><span class="s2">object</span><span class="s1">).</span><span class="s2">previousSibling</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">/**</span>
         <span class="s3">* Returns the next sibling of the given object.</span>
         <span class="s3">*</span>
         <span class="s3">* * `O(1)`</span>
         <span class="s3">*</span>
         <span class="s3">* </span><span class="s4">@method </span><span class="s3">nextSibling</span>
         <span class="s3">* </span><span class="s4">@memberOf </span><span class="s3">module:symbol-tree#</span>
         <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object} object</span>
         <span class="s3">* </span><span class="s4">@return </span><span class="s3">{Object}</span>
         <span class="s3">*/</span>
        <span class="s2">nextSibling</span><span class="s1">(</span><span class="s2">object</span><span class="s1">) {</span>
                <span class="s5">return this</span><span class="s1">.</span><span class="s2">_node</span><span class="s1">(</span><span class="s2">object</span><span class="s1">).</span><span class="s2">nextSibling</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">/**</span>
         <span class="s3">* Return the parent of the given object.</span>
         <span class="s3">*</span>
         <span class="s3">* * `O(1)`</span>
         <span class="s3">*</span>
         <span class="s3">* </span><span class="s4">@method </span><span class="s3">parent</span>
         <span class="s3">* </span><span class="s4">@memberOf </span><span class="s3">module:symbol-tree#</span>
         <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object} object</span>
         <span class="s3">* </span><span class="s4">@return </span><span class="s3">{Object}</span>
         <span class="s3">*/</span>
        <span class="s2">parent</span><span class="s1">(</span><span class="s2">object</span><span class="s1">) {</span>
                <span class="s5">return this</span><span class="s1">.</span><span class="s2">_node</span><span class="s1">(</span><span class="s2">object</span><span class="s1">).</span><span class="s2">parent</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">/**</span>
         <span class="s3">* Find the inclusive descendant that is last in tree order of the given object.</span>
         <span class="s3">*</span>
         <span class="s3">* * `O(n)` (worst case) where `n` is the depth of the subtree of `object`</span>
         <span class="s3">*</span>
         <span class="s3">* </span><span class="s4">@method </span><span class="s3">lastInclusiveDescendant</span>
         <span class="s3">* </span><span class="s4">@memberOf </span><span class="s3">module:symbol-tree#</span>
         <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object} object</span>
         <span class="s3">* </span><span class="s4">@return </span><span class="s3">{Object}</span>
         <span class="s3">*/</span>
        <span class="s2">lastInclusiveDescendant</span><span class="s1">(</span><span class="s2">object</span><span class="s1">) {</span>
                <span class="s5">let </span><span class="s2">lastChild</span><span class="s1">;</span>
                <span class="s5">let </span><span class="s2">current </span><span class="s1">= </span><span class="s2">object</span><span class="s1">;</span>

                <span class="s5">while </span><span class="s1">((</span><span class="s2">lastChild </span><span class="s1">= </span><span class="s5">this</span><span class="s1">.</span><span class="s2">_node</span><span class="s1">(</span><span class="s2">current</span><span class="s1">).</span><span class="s2">lastChild</span><span class="s1">)) {</span>
                        <span class="s2">current </span><span class="s1">= </span><span class="s2">lastChild</span><span class="s1">;</span>
                <span class="s1">}</span>

                <span class="s5">return </span><span class="s2">current</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">/**</span>
         <span class="s3">* Find the preceding object (A) of the given object (B).</span>
         <span class="s3">* An object A is preceding an object B if A and B are in the same tree</span>
         <span class="s3">* and A comes before B in tree order.</span>
         <span class="s3">*</span>
         <span class="s3">* * `O(n)` (worst case)</span>
         <span class="s3">* * `O(1)` (amortized when walking the entire tree)</span>
         <span class="s3">*</span>
         <span class="s3">* </span><span class="s4">@method </span><span class="s3">preceding</span>
         <span class="s3">* </span><span class="s4">@memberOf </span><span class="s3">module:symbol-tree#</span>
         <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object} object</span>
         <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object} [options]</span>
         <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object} [options.root] If set, `root` must be an inclusive ancestor</span>
         <span class="s3">*        of the return value (or else null is returned). This check _assumes_</span>
         <span class="s3">*        that `root` is also an inclusive ancestor of the given `object`</span>
         <span class="s3">* </span><span class="s4">@return </span><span class="s3">{?Object}</span>
         <span class="s3">*/</span>
        <span class="s2">preceding</span><span class="s1">(</span><span class="s2">object</span><span class="s1">, </span><span class="s2">options</span><span class="s1">) {</span>
                <span class="s5">const </span><span class="s2">treeRoot </span><span class="s1">= </span><span class="s2">options </span><span class="s1">&amp;&amp; </span><span class="s2">options</span><span class="s1">.</span><span class="s2">root</span><span class="s1">;</span>

                <span class="s5">if </span><span class="s1">(</span><span class="s2">object </span><span class="s1">=== </span><span class="s2">treeRoot</span><span class="s1">) {</span>
                        <span class="s5">return null</span><span class="s1">;</span>
                <span class="s1">}</span>

                <span class="s5">const </span><span class="s2">previousSibling </span><span class="s1">= </span><span class="s5">this</span><span class="s1">.</span><span class="s2">_node</span><span class="s1">(</span><span class="s2">object</span><span class="s1">).</span><span class="s2">previousSibling</span><span class="s1">;</span>

                <span class="s5">if </span><span class="s1">(</span><span class="s2">previousSibling</span><span class="s1">) {</span>
                        <span class="s5">return this</span><span class="s1">.</span><span class="s2">lastInclusiveDescendant</span><span class="s1">(</span><span class="s2">previousSibling</span><span class="s1">);</span>
                <span class="s1">}</span>

                <span class="s7">// if there is no previous sibling return the parent (might be null)</span>
                <span class="s5">return this</span><span class="s1">.</span><span class="s2">_node</span><span class="s1">(</span><span class="s2">object</span><span class="s1">).</span><span class="s2">parent</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">/**</span>
         <span class="s3">* Find the following object (A) of the given object (B).</span>
         <span class="s3">* An object A is following an object B if A and B are in the same tree</span>
         <span class="s3">* and A comes after B in tree order.</span>
         <span class="s3">*</span>
         <span class="s3">* * `O(n)` (worst case) where `n` is the amount of objects in the entire tree</span>
         <span class="s3">* * `O(1)` (amortized when walking the entire tree)</span>
         <span class="s3">*</span>
         <span class="s3">* </span><span class="s4">@method </span><span class="s3">following</span>
         <span class="s3">* </span><span class="s4">@memberOf </span><span class="s3">module:symbol-tree#</span>
         <span class="s3">* </span><span class="s4">@param </span><span class="s3">{!Object} object</span>
         <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object} [options]</span>
         <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object} [options.root] If set, `root` must be an inclusive ancestor</span>
         <span class="s3">*        of the return value (or else null is returned). This check _assumes_</span>
         <span class="s3">*        that `root` is also an inclusive ancestor of the given `object`</span>
         <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Boolean} [options.skipChildren=false] If set, ignore the children of `object`</span>
         <span class="s3">* </span><span class="s4">@return </span><span class="s3">{?Object}</span>
         <span class="s3">*/</span>
        <span class="s2">following</span><span class="s1">(</span><span class="s2">object</span><span class="s1">, </span><span class="s2">options</span><span class="s1">) {</span>
                <span class="s5">const </span><span class="s2">treeRoot </span><span class="s1">= </span><span class="s2">options </span><span class="s1">&amp;&amp; </span><span class="s2">options</span><span class="s1">.</span><span class="s2">root</span><span class="s1">;</span>
                <span class="s5">const </span><span class="s2">skipChildren </span><span class="s1">= </span><span class="s2">options </span><span class="s1">&amp;&amp; </span><span class="s2">options</span><span class="s1">.</span><span class="s2">skipChildren</span><span class="s1">;</span>

                <span class="s5">const </span><span class="s2">firstChild </span><span class="s1">= !</span><span class="s2">skipChildren </span><span class="s1">&amp;&amp; </span><span class="s5">this</span><span class="s1">.</span><span class="s2">_node</span><span class="s1">(</span><span class="s2">object</span><span class="s1">).</span><span class="s2">firstChild</span><span class="s1">;</span>

                <span class="s5">if </span><span class="s1">(</span><span class="s2">firstChild</span><span class="s1">) {</span>
                        <span class="s5">return </span><span class="s2">firstChild</span><span class="s1">;</span>
                <span class="s1">}</span>

                <span class="s5">let </span><span class="s2">current </span><span class="s1">= </span><span class="s2">object</span><span class="s1">;</span>

                <span class="s5">do </span><span class="s1">{</span>
                        <span class="s5">if </span><span class="s1">(</span><span class="s2">current </span><span class="s1">=== </span><span class="s2">treeRoot</span><span class="s1">) {</span>
                                <span class="s5">return null</span><span class="s1">;</span>
                        <span class="s1">}</span>

                        <span class="s5">const </span><span class="s2">nextSibling </span><span class="s1">= </span><span class="s5">this</span><span class="s1">.</span><span class="s2">_node</span><span class="s1">(</span><span class="s2">current</span><span class="s1">).</span><span class="s2">nextSibling</span><span class="s1">;</span>

                        <span class="s5">if </span><span class="s1">(</span><span class="s2">nextSibling</span><span class="s1">) {</span>
                                <span class="s5">return </span><span class="s2">nextSibling</span><span class="s1">;</span>
                        <span class="s1">}</span>

                        <span class="s2">current </span><span class="s1">= </span><span class="s5">this</span><span class="s1">.</span><span class="s2">_node</span><span class="s1">(</span><span class="s2">current</span><span class="s1">).</span><span class="s2">parent</span><span class="s1">;</span>
                <span class="s1">} </span><span class="s5">while </span><span class="s1">(</span><span class="s2">current</span><span class="s1">);</span>

                <span class="s5">return null</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">/**</span>
         <span class="s3">* Append all children of the given object to an array.</span>
         <span class="s3">*</span>
         <span class="s3">* * `O(n)` where `n` is the amount of children of the given `parent`</span>
         <span class="s3">*</span>
         <span class="s3">* </span><span class="s4">@method </span><span class="s3">childrenToArray</span>
         <span class="s3">* </span><span class="s4">@memberOf </span><span class="s3">module:symbol-tree#</span>
         <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object} parent</span>
         <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object} [options]</span>
         <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object[]} [options.array=[]]</span>
         <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Function} [options.filter] Function to test each object before it is added to the array.</span>
         <span class="s3">*                            Invoked with arguments (object). Should return `true` if an object</span>
         <span class="s3">*                            is to be included.</span>
         <span class="s3">* </span><span class="s4">@param </span><span class="s3">{*} [options.thisArg] Value to use as `this` when executing `filter`.</span>
         <span class="s3">* </span><span class="s4">@return </span><span class="s3">{Object[]}</span>
         <span class="s3">*/</span>
        <span class="s2">childrenToArray</span><span class="s1">(</span><span class="s2">parent</span><span class="s1">, </span><span class="s2">options</span><span class="s1">) {</span>
                <span class="s5">const </span><span class="s2">array   </span><span class="s1">= (</span><span class="s2">options </span><span class="s1">&amp;&amp; </span><span class="s2">options</span><span class="s1">.</span><span class="s2">array</span><span class="s1">) || [];</span>
                <span class="s5">const </span><span class="s2">filter  </span><span class="s1">= (</span><span class="s2">options </span><span class="s1">&amp;&amp; </span><span class="s2">options</span><span class="s1">.</span><span class="s2">filter</span><span class="s1">) || </span><span class="s2">returnTrue</span><span class="s1">;</span>
                <span class="s5">const </span><span class="s2">thisArg </span><span class="s1">= (</span><span class="s2">options </span><span class="s1">&amp;&amp; </span><span class="s2">options</span><span class="s1">.</span><span class="s2">thisArg</span><span class="s1">) || </span><span class="s2">undefined</span><span class="s1">;</span>

                <span class="s5">const </span><span class="s2">parentNode </span><span class="s1">= </span><span class="s5">this</span><span class="s1">.</span><span class="s2">_node</span><span class="s1">(</span><span class="s2">parent</span><span class="s1">);</span>
                <span class="s5">let </span><span class="s2">object </span><span class="s1">= </span><span class="s2">parentNode</span><span class="s1">.</span><span class="s2">firstChild</span><span class="s1">;</span>
                <span class="s5">let </span><span class="s2">index </span><span class="s1">= </span><span class="s6">0</span><span class="s1">;</span>

                <span class="s5">while </span><span class="s1">(</span><span class="s2">object</span><span class="s1">) {</span>
                        <span class="s5">const </span><span class="s2">node </span><span class="s1">= </span><span class="s5">this</span><span class="s1">.</span><span class="s2">_node</span><span class="s1">(</span><span class="s2">object</span><span class="s1">);</span>
                        <span class="s2">node</span><span class="s1">.</span><span class="s2">setCachedIndex</span><span class="s1">(</span><span class="s2">parentNode</span><span class="s1">, </span><span class="s2">index</span><span class="s1">);</span>

                        <span class="s5">if </span><span class="s1">(</span><span class="s2">filter</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s2">thisArg</span><span class="s1">, </span><span class="s2">object</span><span class="s1">)) {</span>
                                <span class="s2">array</span><span class="s1">.</span><span class="s2">push</span><span class="s1">(</span><span class="s2">object</span><span class="s1">);</span>
                        <span class="s1">}</span>

                        <span class="s2">object </span><span class="s1">= </span><span class="s2">node</span><span class="s1">.</span><span class="s2">nextSibling</span><span class="s1">;</span>
                        <span class="s1">++</span><span class="s2">index</span><span class="s1">;</span>
                <span class="s1">}</span>

                <span class="s5">return </span><span class="s2">array</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">/**</span>
         <span class="s3">* Append all inclusive ancestors of the given object to an array.</span>
         <span class="s3">*</span>
         <span class="s3">* * `O(n)` where `n` is the amount of ancestors of the given `object`</span>
         <span class="s3">*</span>
         <span class="s3">* </span><span class="s4">@method </span><span class="s3">ancestorsToArray</span>
         <span class="s3">* </span><span class="s4">@memberOf </span><span class="s3">module:symbol-tree#</span>
         <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object} object</span>
         <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object} [options]</span>
         <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object[]} [options.array=[]]</span>
         <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Function} [options.filter] Function to test each object before it is added to the array.</span>
         <span class="s3">*                            Invoked with arguments (object). Should return `true` if an object</span>
         <span class="s3">*                            is to be included.</span>
         <span class="s3">* </span><span class="s4">@param </span><span class="s3">{*} [options.thisArg] Value to use as `this` when executing `filter`.</span>
         <span class="s3">* </span><span class="s4">@return </span><span class="s3">{Object[]}</span>
         <span class="s3">*/</span>
        <span class="s2">ancestorsToArray</span><span class="s1">(</span><span class="s2">object</span><span class="s1">, </span><span class="s2">options</span><span class="s1">) {</span>
                <span class="s5">const </span><span class="s2">array   </span><span class="s1">= (</span><span class="s2">options </span><span class="s1">&amp;&amp; </span><span class="s2">options</span><span class="s1">.</span><span class="s2">array</span><span class="s1">) || [];</span>
                <span class="s5">const </span><span class="s2">filter  </span><span class="s1">= (</span><span class="s2">options </span><span class="s1">&amp;&amp; </span><span class="s2">options</span><span class="s1">.</span><span class="s2">filter</span><span class="s1">) || </span><span class="s2">returnTrue</span><span class="s1">;</span>
                <span class="s5">const </span><span class="s2">thisArg </span><span class="s1">= (</span><span class="s2">options </span><span class="s1">&amp;&amp; </span><span class="s2">options</span><span class="s1">.</span><span class="s2">thisArg</span><span class="s1">) || </span><span class="s2">undefined</span><span class="s1">;</span>

                <span class="s5">let </span><span class="s2">ancestor </span><span class="s1">= </span><span class="s2">object</span><span class="s1">;</span>

                <span class="s5">while </span><span class="s1">(</span><span class="s2">ancestor</span><span class="s1">) {</span>
                        <span class="s5">if </span><span class="s1">(</span><span class="s2">filter</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s2">thisArg</span><span class="s1">, </span><span class="s2">ancestor</span><span class="s1">)) {</span>
                                <span class="s2">array</span><span class="s1">.</span><span class="s2">push</span><span class="s1">(</span><span class="s2">ancestor</span><span class="s1">);</span>
                        <span class="s1">}</span>
                        <span class="s2">ancestor </span><span class="s1">= </span><span class="s5">this</span><span class="s1">.</span><span class="s2">_node</span><span class="s1">(</span><span class="s2">ancestor</span><span class="s1">).</span><span class="s2">parent</span><span class="s1">;</span>
                <span class="s1">}</span>

                <span class="s5">return </span><span class="s2">array</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">/**</span>
         <span class="s3">* Append all descendants of the given object to an array (in tree order).</span>
         <span class="s3">*</span>
         <span class="s3">* * `O(n)` where `n` is the amount of objects in the sub-tree of the given `object`</span>
         <span class="s3">*</span>
         <span class="s3">* </span><span class="s4">@method </span><span class="s3">treeToArray</span>
         <span class="s3">* </span><span class="s4">@memberOf </span><span class="s3">module:symbol-tree#</span>
         <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object} root</span>
         <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object} [options]</span>
         <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object[]} [options.array=[]]</span>
         <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Function} [options.filter] Function to test each object before it is added to the array.</span>
         <span class="s3">*                            Invoked with arguments (object). Should return `true` if an object</span>
         <span class="s3">*                            is to be included.</span>
         <span class="s3">* </span><span class="s4">@param </span><span class="s3">{*} [options.thisArg] Value to use as `this` when executing `filter`.</span>
         <span class="s3">* </span><span class="s4">@return </span><span class="s3">{Object[]}</span>
         <span class="s3">*/</span>
        <span class="s2">treeToArray</span><span class="s1">(</span><span class="s2">root</span><span class="s1">, </span><span class="s2">options</span><span class="s1">) {</span>
                <span class="s5">const </span><span class="s2">array   </span><span class="s1">= (</span><span class="s2">options </span><span class="s1">&amp;&amp; </span><span class="s2">options</span><span class="s1">.</span><span class="s2">array</span><span class="s1">) || [];</span>
                <span class="s5">const </span><span class="s2">filter  </span><span class="s1">= (</span><span class="s2">options </span><span class="s1">&amp;&amp; </span><span class="s2">options</span><span class="s1">.</span><span class="s2">filter</span><span class="s1">) || </span><span class="s2">returnTrue</span><span class="s1">;</span>
                <span class="s5">const </span><span class="s2">thisArg </span><span class="s1">= (</span><span class="s2">options </span><span class="s1">&amp;&amp; </span><span class="s2">options</span><span class="s1">.</span><span class="s2">thisArg</span><span class="s1">) || </span><span class="s2">undefined</span><span class="s1">;</span>

                <span class="s5">let </span><span class="s2">object </span><span class="s1">= </span><span class="s2">root</span><span class="s1">;</span>

                <span class="s5">while </span><span class="s1">(</span><span class="s2">object</span><span class="s1">) {</span>
                        <span class="s5">if </span><span class="s1">(</span><span class="s2">filter</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s2">thisArg</span><span class="s1">, </span><span class="s2">object</span><span class="s1">)) {</span>
                                <span class="s2">array</span><span class="s1">.</span><span class="s2">push</span><span class="s1">(</span><span class="s2">object</span><span class="s1">);</span>
                        <span class="s1">}</span>
                        <span class="s2">object </span><span class="s1">= </span><span class="s5">this</span><span class="s1">.</span><span class="s2">following</span><span class="s1">(</span><span class="s2">object</span><span class="s1">, {</span><span class="s2">root</span><span class="s1">: </span><span class="s2">root</span><span class="s1">});</span>
                <span class="s1">}</span>

                <span class="s5">return </span><span class="s2">array</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">/**</span>
         <span class="s3">* Iterate over all children of the given object</span>
         <span class="s3">*</span>
         <span class="s3">* * `O(1)` for a single iteration</span>
         <span class="s3">*</span>
         <span class="s3">* </span><span class="s4">@method </span><span class="s3">childrenIterator</span>
         <span class="s3">* </span><span class="s4">@memberOf </span><span class="s3">module:symbol-tree#</span>
         <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object} parent</span>
         <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object} [options]</span>
         <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Boolean} [options.reverse=false]</span>
         <span class="s3">* </span><span class="s4">@return </span><span class="s3">{Object} An iterable iterator (ES6)</span>
         <span class="s3">*/</span>
        <span class="s2">childrenIterator</span><span class="s1">(</span><span class="s2">parent</span><span class="s1">, </span><span class="s2">options</span><span class="s1">) {</span>
                <span class="s5">const </span><span class="s2">reverse </span><span class="s1">= </span><span class="s2">options </span><span class="s1">&amp;&amp; </span><span class="s2">options</span><span class="s1">.</span><span class="s2">reverse</span><span class="s1">;</span>
                <span class="s5">const </span><span class="s2">parentNode </span><span class="s1">= </span><span class="s5">this</span><span class="s1">.</span><span class="s2">_node</span><span class="s1">(</span><span class="s2">parent</span><span class="s1">);</span>

                <span class="s5">return new </span><span class="s2">TreeIterator</span><span class="s1">(</span>
                        <span class="s5">this</span><span class="s1">,</span>
                        <span class="s2">parent</span><span class="s1">,</span>
                        <span class="s2">reverse </span><span class="s1">? </span><span class="s2">parentNode</span><span class="s1">.</span><span class="s2">lastChild </span><span class="s1">: </span><span class="s2">parentNode</span><span class="s1">.</span><span class="s2">firstChild</span><span class="s1">,</span>
                        <span class="s2">reverse </span><span class="s1">? </span><span class="s2">TreeIterator</span><span class="s1">.</span><span class="s2">PREV </span><span class="s1">: </span><span class="s2">TreeIterator</span><span class="s1">.</span><span class="s2">NEXT</span>
                <span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s3">/**</span>
         <span class="s3">* Iterate over all the previous siblings of the given object. (in reverse tree order)</span>
         <span class="s3">*</span>
         <span class="s3">* * `O(1)` for a single iteration</span>
         <span class="s3">*</span>
         <span class="s3">* </span><span class="s4">@method </span><span class="s3">previousSiblingsIterator</span>
         <span class="s3">* </span><span class="s4">@memberOf </span><span class="s3">module:symbol-tree#</span>
         <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object} object</span>
         <span class="s3">* </span><span class="s4">@return </span><span class="s3">{Object} An iterable iterator (ES6)</span>
         <span class="s3">*/</span>
        <span class="s2">previousSiblingsIterator</span><span class="s1">(</span><span class="s2">object</span><span class="s1">) {</span>
                <span class="s5">return new </span><span class="s2">TreeIterator</span><span class="s1">(</span>
                        <span class="s5">this</span><span class="s1">,</span>
                        <span class="s2">object</span><span class="s1">,</span>
                        <span class="s5">this</span><span class="s1">.</span><span class="s2">_node</span><span class="s1">(</span><span class="s2">object</span><span class="s1">).</span><span class="s2">previousSibling</span><span class="s1">,</span>
                        <span class="s2">TreeIterator</span><span class="s1">.</span><span class="s2">PREV</span>
                <span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s3">/**</span>
         <span class="s3">* Iterate over all the next siblings of the given object. (in tree order)</span>
         <span class="s3">*</span>
         <span class="s3">* * `O(1)` for a single iteration</span>
         <span class="s3">*</span>
         <span class="s3">* </span><span class="s4">@method </span><span class="s3">nextSiblingsIterator</span>
         <span class="s3">* </span><span class="s4">@memberOf </span><span class="s3">module:symbol-tree#</span>
         <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object} object</span>
         <span class="s3">* </span><span class="s4">@return </span><span class="s3">{Object} An iterable iterator (ES6)</span>
         <span class="s3">*/</span>
        <span class="s2">nextSiblingsIterator</span><span class="s1">(</span><span class="s2">object</span><span class="s1">) {</span>
                <span class="s5">return new </span><span class="s2">TreeIterator</span><span class="s1">(</span>
                        <span class="s5">this</span><span class="s1">,</span>
                        <span class="s2">object</span><span class="s1">,</span>
                        <span class="s5">this</span><span class="s1">.</span><span class="s2">_node</span><span class="s1">(</span><span class="s2">object</span><span class="s1">).</span><span class="s2">nextSibling</span><span class="s1">,</span>
                        <span class="s2">TreeIterator</span><span class="s1">.</span><span class="s2">NEXT</span>
                <span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s3">/**</span>
         <span class="s3">* Iterate over all inclusive ancestors of the given object</span>
         <span class="s3">*</span>
         <span class="s3">* * `O(1)` for a single iteration</span>
         <span class="s3">*</span>
         <span class="s3">* </span><span class="s4">@method </span><span class="s3">ancestorsIterator</span>
         <span class="s3">* </span><span class="s4">@memberOf </span><span class="s3">module:symbol-tree#</span>
         <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object} object</span>
         <span class="s3">* </span><span class="s4">@return </span><span class="s3">{Object} An iterable iterator (ES6)</span>
         <span class="s3">*/</span>
        <span class="s2">ancestorsIterator</span><span class="s1">(</span><span class="s2">object</span><span class="s1">) {</span>
                <span class="s5">return new </span><span class="s2">TreeIterator</span><span class="s1">(</span>
                        <span class="s5">this</span><span class="s1">,</span>
                        <span class="s2">object</span><span class="s1">,</span>
                        <span class="s2">object</span><span class="s1">,</span>
                        <span class="s2">TreeIterator</span><span class="s1">.</span><span class="s2">PARENT</span>
                <span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s3">/**</span>
         <span class="s3">* Iterate over all descendants of the given object (in tree order).</span>
         <span class="s3">*</span>
         <span class="s3">* Where `n` is the amount of objects in the sub-tree of the given `root`:</span>
         <span class="s3">*</span>
         <span class="s3">* * `O(n)` (worst case for a single iteration)</span>
         <span class="s3">* * `O(n)` (amortized, when completing the iterator)</span>
         <span class="s3">*</span>
         <span class="s3">* </span><span class="s4">@method </span><span class="s3">treeIterator</span>
         <span class="s3">* </span><span class="s4">@memberOf </span><span class="s3">module:symbol-tree#</span>
         <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object} root</span>
         <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object} options</span>
         <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Boolean} [options.reverse=false]</span>
         <span class="s3">* </span><span class="s4">@return </span><span class="s3">{Object} An iterable iterator (ES6)</span>
         <span class="s3">*/</span>
        <span class="s2">treeIterator</span><span class="s1">(</span><span class="s2">root</span><span class="s1">, </span><span class="s2">options</span><span class="s1">) {</span>
                <span class="s5">const </span><span class="s2">reverse </span><span class="s1">= </span><span class="s2">options </span><span class="s1">&amp;&amp; </span><span class="s2">options</span><span class="s1">.</span><span class="s2">reverse</span><span class="s1">;</span>

                <span class="s5">return new </span><span class="s2">TreeIterator</span><span class="s1">(</span>
                        <span class="s5">this</span><span class="s1">,</span>
                        <span class="s2">root</span><span class="s1">,</span>
                        <span class="s2">reverse </span><span class="s1">? </span><span class="s5">this</span><span class="s1">.</span><span class="s2">lastInclusiveDescendant</span><span class="s1">(</span><span class="s2">root</span><span class="s1">) : </span><span class="s2">root</span><span class="s1">,</span>
                        <span class="s2">reverse </span><span class="s1">? </span><span class="s2">TreeIterator</span><span class="s1">.</span><span class="s2">PRECEDING </span><span class="s1">: </span><span class="s2">TreeIterator</span><span class="s1">.</span><span class="s2">FOLLOWING</span>
                <span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s3">/**</span>
         <span class="s3">* Find the index of the given object (the number of preceding siblings).</span>
         <span class="s3">*</span>
         <span class="s3">* * `O(n)` where `n` is the amount of preceding siblings</span>
         <span class="s3">* * `O(1)` (amortized, if the tree is not modified)</span>
         <span class="s3">*</span>
         <span class="s3">* </span><span class="s4">@method </span><span class="s3">index</span>
         <span class="s3">* </span><span class="s4">@memberOf </span><span class="s3">module:symbol-tree#</span>
         <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object} child</span>
         <span class="s3">* </span><span class="s4">@return </span><span class="s3">{Number} The number of preceding siblings, or -1 if the object has no parent</span>
         <span class="s3">*/</span>
        <span class="s2">index</span><span class="s1">(</span><span class="s2">child</span><span class="s1">) {</span>
                <span class="s5">const </span><span class="s2">childNode </span><span class="s1">= </span><span class="s5">this</span><span class="s1">.</span><span class="s2">_node</span><span class="s1">(</span><span class="s2">child</span><span class="s1">);</span>
                <span class="s5">const </span><span class="s2">parentNode </span><span class="s1">= </span><span class="s5">this</span><span class="s1">.</span><span class="s2">_node</span><span class="s1">(</span><span class="s2">childNode</span><span class="s1">.</span><span class="s2">parent</span><span class="s1">);</span>

                <span class="s5">if </span><span class="s1">(!</span><span class="s2">parentNode</span><span class="s1">) {</span>
                        <span class="s7">// In principal, you could also find out the number of preceding siblings</span>
                        <span class="s7">// for objects that do not have a parent. This method limits itself only to</span>
                        <span class="s7">// objects that have a parent because that lets us optimize more.</span>
                        <span class="s5">return </span><span class="s1">-</span><span class="s6">1</span><span class="s1">;</span>
                <span class="s1">}</span>

                <span class="s5">let </span><span class="s2">currentIndex </span><span class="s1">= </span><span class="s2">childNode</span><span class="s1">.</span><span class="s2">getCachedIndex</span><span class="s1">(</span><span class="s2">parentNode</span><span class="s1">);</span>

                <span class="s5">if </span><span class="s1">(</span><span class="s2">currentIndex </span><span class="s1">&gt;= </span><span class="s6">0</span><span class="s1">) {</span>
                        <span class="s5">return </span><span class="s2">currentIndex</span><span class="s1">;</span>
                <span class="s1">}</span>

                <span class="s2">currentIndex </span><span class="s1">= </span><span class="s6">0</span><span class="s1">;</span>
                <span class="s5">let </span><span class="s2">object </span><span class="s1">= </span><span class="s2">parentNode</span><span class="s1">.</span><span class="s2">firstChild</span><span class="s1">;</span>

                <span class="s5">if </span><span class="s1">(</span><span class="s2">parentNode</span><span class="s1">.</span><span class="s2">childIndexCachedUpTo</span><span class="s1">) {</span>
                        <span class="s5">const </span><span class="s2">cachedUpToNode </span><span class="s1">= </span><span class="s5">this</span><span class="s1">.</span><span class="s2">_node</span><span class="s1">(</span><span class="s2">parentNode</span><span class="s1">.</span><span class="s2">childIndexCachedUpTo</span><span class="s1">);</span>
                        <span class="s2">object </span><span class="s1">= </span><span class="s2">cachedUpToNode</span><span class="s1">.</span><span class="s2">nextSibling</span><span class="s1">;</span>
                        <span class="s2">currentIndex </span><span class="s1">= </span><span class="s2">cachedUpToNode</span><span class="s1">.</span><span class="s2">getCachedIndex</span><span class="s1">(</span><span class="s2">parentNode</span><span class="s1">) + </span><span class="s6">1</span><span class="s1">;</span>
                <span class="s1">}</span>

                <span class="s5">while </span><span class="s1">(</span><span class="s2">object</span><span class="s1">) {</span>
                        <span class="s5">const </span><span class="s2">node </span><span class="s1">= </span><span class="s5">this</span><span class="s1">.</span><span class="s2">_node</span><span class="s1">(</span><span class="s2">object</span><span class="s1">);</span>
                        <span class="s2">node</span><span class="s1">.</span><span class="s2">setCachedIndex</span><span class="s1">(</span><span class="s2">parentNode</span><span class="s1">, </span><span class="s2">currentIndex</span><span class="s1">);</span>

                        <span class="s5">if </span><span class="s1">(</span><span class="s2">object </span><span class="s1">=== </span><span class="s2">child</span><span class="s1">) {</span>
                                <span class="s5">break</span><span class="s1">;</span>
                        <span class="s1">}</span>

                        <span class="s1">++</span><span class="s2">currentIndex</span><span class="s1">;</span>
                        <span class="s2">object </span><span class="s1">= </span><span class="s2">node</span><span class="s1">.</span><span class="s2">nextSibling</span><span class="s1">;</span>
                <span class="s1">}</span>

                <span class="s2">parentNode</span><span class="s1">.</span><span class="s2">childIndexCachedUpTo </span><span class="s1">= </span><span class="s2">child</span><span class="s1">;</span>

                <span class="s5">return </span><span class="s2">currentIndex</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">/**</span>
         <span class="s3">* Calculate the number of children.</span>
         <span class="s3">*</span>
         <span class="s3">* * `O(n)` where `n` is the amount of children</span>
         <span class="s3">* * `O(1)` (amortized, if the tree is not modified)</span>
         <span class="s3">*</span>
         <span class="s3">* </span><span class="s4">@method </span><span class="s3">childrenCount</span>
         <span class="s3">* </span><span class="s4">@memberOf </span><span class="s3">module:symbol-tree#</span>
         <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object} parent</span>
         <span class="s3">* </span><span class="s4">@return </span><span class="s3">{Number}</span>
         <span class="s3">*/</span>
        <span class="s2">childrenCount</span><span class="s1">(</span><span class="s2">parent</span><span class="s1">) {</span>
                <span class="s5">const </span><span class="s2">parentNode </span><span class="s1">= </span><span class="s5">this</span><span class="s1">.</span><span class="s2">_node</span><span class="s1">(</span><span class="s2">parent</span><span class="s1">);</span>

                <span class="s5">if </span><span class="s1">(!</span><span class="s2">parentNode</span><span class="s1">.</span><span class="s2">lastChild</span><span class="s1">) {</span>
                        <span class="s5">return </span><span class="s6">0</span><span class="s1">;</span>
                <span class="s1">}</span>

                <span class="s5">return this</span><span class="s1">.</span><span class="s2">index</span><span class="s1">(</span><span class="s2">parentNode</span><span class="s1">.</span><span class="s2">lastChild</span><span class="s1">) + </span><span class="s6">1</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">/**</span>
         <span class="s3">* Compare the position of an object relative to another object. A bit set is returned:</span>
         <span class="s3">*</span>
         <span class="s3">* &lt;ul&gt;</span>
         <span class="s3">*     &lt;li&gt;DISCONNECTED : 1&lt;/li&gt;</span>
         <span class="s3">*     &lt;li&gt;PRECEDING : 2&lt;/li&gt;</span>
         <span class="s3">*     &lt;li&gt;FOLLOWING : 4&lt;/li&gt;</span>
         <span class="s3">*     &lt;li&gt;CONTAINS : 8&lt;/li&gt;</span>
         <span class="s3">*     &lt;li&gt;CONTAINED_BY : 16&lt;/li&gt;</span>
         <span class="s3">* &lt;/ul&gt;</span>
         <span class="s3">*</span>
         <span class="s3">* The semantics are the same as compareDocumentPosition in DOM, with the exception that</span>
         <span class="s3">* DISCONNECTED never occurs with any other bit.</span>
         <span class="s3">*</span>
         <span class="s3">* where `n` and `m` are the amount of ancestors of `left` and `right`;</span>
         <span class="s3">* where `o` is the amount of children of the lowest common ancestor of `left` and `right`:</span>
         <span class="s3">*</span>
         <span class="s3">* * `O(n + m + o)` (worst case)</span>
         <span class="s3">* * `O(n + m)` (amortized, if the tree is not modified)</span>
         <span class="s3">*</span>
         <span class="s3">* </span><span class="s4">@method </span><span class="s3">compareTreePosition</span>
         <span class="s3">* </span><span class="s4">@memberOf </span><span class="s3">module:symbol-tree#</span>
         <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object} left</span>
         <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object} right</span>
         <span class="s3">* </span><span class="s4">@return </span><span class="s3">{Number}</span>
         <span class="s3">*/</span>
        <span class="s2">compareTreePosition</span><span class="s1">(</span><span class="s2">left</span><span class="s1">, </span><span class="s2">right</span><span class="s1">) {</span>
                <span class="s7">// In DOM terms:</span>
                <span class="s7">// left = reference / context object</span>
                <span class="s7">// right = other</span>

                <span class="s5">if </span><span class="s1">(</span><span class="s2">left </span><span class="s1">=== </span><span class="s2">right</span><span class="s1">) {</span>
                        <span class="s5">return </span><span class="s6">0</span><span class="s1">;</span>
                <span class="s1">}</span>

                <span class="s7">/* jshint -W016 */</span>

                <span class="s5">const </span><span class="s2">leftAncestors </span><span class="s1">= []; { </span><span class="s7">// inclusive</span>
                        <span class="s5">let </span><span class="s2">leftAncestor </span><span class="s1">= </span><span class="s2">left</span><span class="s1">;</span>

                        <span class="s5">while </span><span class="s1">(</span><span class="s2">leftAncestor</span><span class="s1">) {</span>
                                <span class="s5">if </span><span class="s1">(</span><span class="s2">leftAncestor </span><span class="s1">=== </span><span class="s2">right</span><span class="s1">) {</span>
                                        <span class="s5">return </span><span class="s2">TreePosition</span><span class="s1">.</span><span class="s2">CONTAINS </span><span class="s1">| </span><span class="s2">TreePosition</span><span class="s1">.</span><span class="s2">PRECEDING</span><span class="s1">;</span>
                                        <span class="s7">// other is ancestor of reference</span>
                                <span class="s1">}</span>

                                <span class="s2">leftAncestors</span><span class="s1">.</span><span class="s2">push</span><span class="s1">(</span><span class="s2">leftAncestor</span><span class="s1">);</span>
                                <span class="s2">leftAncestor </span><span class="s1">= </span><span class="s5">this</span><span class="s1">.</span><span class="s2">parent</span><span class="s1">(</span><span class="s2">leftAncestor</span><span class="s1">);</span>
                        <span class="s1">}</span>
                <span class="s1">}</span>


                <span class="s5">const </span><span class="s2">rightAncestors </span><span class="s1">= []; {</span>
                        <span class="s5">let </span><span class="s2">rightAncestor </span><span class="s1">= </span><span class="s2">right</span><span class="s1">;</span>

                        <span class="s5">while </span><span class="s1">(</span><span class="s2">rightAncestor</span><span class="s1">) {</span>
                                <span class="s5">if </span><span class="s1">(</span><span class="s2">rightAncestor </span><span class="s1">=== </span><span class="s2">left</span><span class="s1">) {</span>
                                        <span class="s5">return </span><span class="s2">TreePosition</span><span class="s1">.</span><span class="s2">CONTAINED_BY </span><span class="s1">| </span><span class="s2">TreePosition</span><span class="s1">.</span><span class="s2">FOLLOWING</span><span class="s1">;</span>
                                <span class="s1">}</span>

                                <span class="s2">rightAncestors</span><span class="s1">.</span><span class="s2">push</span><span class="s1">(</span><span class="s2">rightAncestor</span><span class="s1">);</span>
                                <span class="s2">rightAncestor </span><span class="s1">= </span><span class="s5">this</span><span class="s1">.</span><span class="s2">parent</span><span class="s1">(</span><span class="s2">rightAncestor</span><span class="s1">);</span>
                        <span class="s1">}</span>
                <span class="s1">}</span>


                <span class="s5">const </span><span class="s2">root </span><span class="s1">= </span><span class="s2">reverseArrayIndex</span><span class="s1">(</span><span class="s2">leftAncestors</span><span class="s1">, </span><span class="s6">0</span><span class="s1">);</span>

                <span class="s5">if </span><span class="s1">(!</span><span class="s2">root </span><span class="s1">|| </span><span class="s2">root </span><span class="s1">!== </span><span class="s2">reverseArrayIndex</span><span class="s1">(</span><span class="s2">rightAncestors</span><span class="s1">, </span><span class="s6">0</span><span class="s1">)) {</span>
                        <span class="s7">// note: unlike DOM, preceding / following is not set here</span>
                        <span class="s5">return </span><span class="s2">TreePosition</span><span class="s1">.</span><span class="s2">DISCONNECTED</span><span class="s1">;</span>
                <span class="s1">}</span>

                <span class="s7">// find the lowest common ancestor</span>
                <span class="s5">let </span><span class="s2">commonAncestorIndex </span><span class="s1">= </span><span class="s6">0</span><span class="s1">;</span>
                <span class="s5">const </span><span class="s2">ancestorsMinLength </span><span class="s1">= </span><span class="s2">Math</span><span class="s1">.</span><span class="s2">min</span><span class="s1">(</span><span class="s2">leftAncestors</span><span class="s1">.</span><span class="s2">length</span><span class="s1">, </span><span class="s2">rightAncestors</span><span class="s1">.</span><span class="s2">length</span><span class="s1">);</span>

                <span class="s5">for </span><span class="s1">(</span><span class="s5">let </span><span class="s2">i </span><span class="s1">= </span><span class="s6">0</span><span class="s1">; </span><span class="s2">i </span><span class="s1">&lt; </span><span class="s2">ancestorsMinLength</span><span class="s1">; ++</span><span class="s2">i</span><span class="s1">) {</span>
                        <span class="s5">const </span><span class="s2">leftAncestor  </span><span class="s1">= </span><span class="s2">reverseArrayIndex</span><span class="s1">(</span><span class="s2">leftAncestors</span><span class="s1">, </span><span class="s2">i</span><span class="s1">);</span>
                        <span class="s5">const </span><span class="s2">rightAncestor </span><span class="s1">= </span><span class="s2">reverseArrayIndex</span><span class="s1">(</span><span class="s2">rightAncestors</span><span class="s1">, </span><span class="s2">i</span><span class="s1">);</span>

                        <span class="s5">if </span><span class="s1">(</span><span class="s2">leftAncestor </span><span class="s1">!== </span><span class="s2">rightAncestor</span><span class="s1">) {</span>
                                <span class="s5">break</span><span class="s1">;</span>
                        <span class="s1">}</span>

                        <span class="s2">commonAncestorIndex </span><span class="s1">= </span><span class="s2">i</span><span class="s1">;</span>
                <span class="s1">}</span>

                <span class="s7">// indexes within the common ancestor</span>
                <span class="s5">const </span><span class="s2">leftIndex  </span><span class="s1">= </span><span class="s5">this</span><span class="s1">.</span><span class="s2">index</span><span class="s1">(</span><span class="s2">reverseArrayIndex</span><span class="s1">(</span><span class="s2">leftAncestors</span><span class="s1">, </span><span class="s2">commonAncestorIndex </span><span class="s1">+ </span><span class="s6">1</span><span class="s1">));</span>
                <span class="s5">const </span><span class="s2">rightIndex </span><span class="s1">= </span><span class="s5">this</span><span class="s1">.</span><span class="s2">index</span><span class="s1">(</span><span class="s2">reverseArrayIndex</span><span class="s1">(</span><span class="s2">rightAncestors</span><span class="s1">, </span><span class="s2">commonAncestorIndex </span><span class="s1">+ </span><span class="s6">1</span><span class="s1">));</span>

                <span class="s5">return </span><span class="s2">rightIndex </span><span class="s1">&lt; </span><span class="s2">leftIndex</span>
                        <span class="s1">? </span><span class="s2">TreePosition</span><span class="s1">.</span><span class="s2">PRECEDING</span>
                        <span class="s1">: </span><span class="s2">TreePosition</span><span class="s1">.</span><span class="s2">FOLLOWING</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">/**</span>
         <span class="s3">* Remove the object from this tree.</span>
         <span class="s3">* Has no effect if already removed.</span>
         <span class="s3">*</span>
         <span class="s3">* * `O(1)`</span>
         <span class="s3">*</span>
         <span class="s3">* </span><span class="s4">@method </span><span class="s3">remove</span>
         <span class="s3">* </span><span class="s4">@memberOf </span><span class="s3">module:symbol-tree#</span>
         <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object} removeObject</span>
         <span class="s3">* </span><span class="s4">@return </span><span class="s3">{Object} removeObject</span>
         <span class="s3">*/</span>
        <span class="s2">remove</span><span class="s1">(</span><span class="s2">removeObject</span><span class="s1">) {</span>
                <span class="s5">const </span><span class="s2">removeNode </span><span class="s1">= </span><span class="s5">this</span><span class="s1">.</span><span class="s2">_node</span><span class="s1">(</span><span class="s2">removeObject</span><span class="s1">);</span>
                <span class="s5">const </span><span class="s2">parentNode </span><span class="s1">= </span><span class="s5">this</span><span class="s1">.</span><span class="s2">_node</span><span class="s1">(</span><span class="s2">removeNode</span><span class="s1">.</span><span class="s2">parent</span><span class="s1">);</span>
                <span class="s5">const </span><span class="s2">prevNode </span><span class="s1">= </span><span class="s5">this</span><span class="s1">.</span><span class="s2">_node</span><span class="s1">(</span><span class="s2">removeNode</span><span class="s1">.</span><span class="s2">previousSibling</span><span class="s1">);</span>
                <span class="s5">const </span><span class="s2">nextNode </span><span class="s1">= </span><span class="s5">this</span><span class="s1">.</span><span class="s2">_node</span><span class="s1">(</span><span class="s2">removeNode</span><span class="s1">.</span><span class="s2">nextSibling</span><span class="s1">);</span>

                <span class="s5">if </span><span class="s1">(</span><span class="s2">parentNode</span><span class="s1">) {</span>
                        <span class="s5">if </span><span class="s1">(</span><span class="s2">parentNode</span><span class="s1">.</span><span class="s2">firstChild </span><span class="s1">=== </span><span class="s2">removeObject</span><span class="s1">) {</span>
                                <span class="s2">parentNode</span><span class="s1">.</span><span class="s2">firstChild </span><span class="s1">= </span><span class="s2">removeNode</span><span class="s1">.</span><span class="s2">nextSibling</span><span class="s1">;</span>
                        <span class="s1">}</span>

                        <span class="s5">if </span><span class="s1">(</span><span class="s2">parentNode</span><span class="s1">.</span><span class="s2">lastChild </span><span class="s1">=== </span><span class="s2">removeObject</span><span class="s1">) {</span>
                                <span class="s2">parentNode</span><span class="s1">.</span><span class="s2">lastChild </span><span class="s1">= </span><span class="s2">removeNode</span><span class="s1">.</span><span class="s2">previousSibling</span><span class="s1">;</span>
                        <span class="s1">}</span>
                <span class="s1">}</span>

                <span class="s5">if </span><span class="s1">(</span><span class="s2">prevNode</span><span class="s1">) {</span>
                        <span class="s2">prevNode</span><span class="s1">.</span><span class="s2">nextSibling </span><span class="s1">= </span><span class="s2">removeNode</span><span class="s1">.</span><span class="s2">nextSibling</span><span class="s1">;</span>
                <span class="s1">}</span>

                <span class="s5">if </span><span class="s1">(</span><span class="s2">nextNode</span><span class="s1">) {</span>
                        <span class="s2">nextNode</span><span class="s1">.</span><span class="s2">previousSibling </span><span class="s1">= </span><span class="s2">removeNode</span><span class="s1">.</span><span class="s2">previousSibling</span><span class="s1">;</span>
                <span class="s1">}</span>

                <span class="s2">removeNode</span><span class="s1">.</span><span class="s2">parent </span><span class="s1">= </span><span class="s5">null</span><span class="s1">;</span>
                <span class="s2">removeNode</span><span class="s1">.</span><span class="s2">previousSibling </span><span class="s1">= </span><span class="s5">null</span><span class="s1">;</span>
                <span class="s2">removeNode</span><span class="s1">.</span><span class="s2">nextSibling </span><span class="s1">= </span><span class="s5">null</span><span class="s1">;</span>
                <span class="s2">removeNode</span><span class="s1">.</span><span class="s2">cachedIndex </span><span class="s1">= -</span><span class="s6">1</span><span class="s1">;</span>
                <span class="s2">removeNode</span><span class="s1">.</span><span class="s2">cachedIndexVersion </span><span class="s1">= </span><span class="s2">NaN</span><span class="s1">;</span>

                <span class="s5">if </span><span class="s1">(</span><span class="s2">parentNode</span><span class="s1">) {</span>
                        <span class="s2">parentNode</span><span class="s1">.</span><span class="s2">childrenChanged</span><span class="s1">();</span>
                <span class="s1">}</span>

                <span class="s5">return </span><span class="s2">removeObject</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">/**</span>
         <span class="s3">* Insert the given object before the reference object.</span>
         <span class="s3">* `newObject` is now the previous sibling of `referenceObject`.</span>
         <span class="s3">*</span>
         <span class="s3">* * `O(1)`</span>
         <span class="s3">*</span>
         <span class="s3">* </span><span class="s4">@method </span><span class="s3">insertBefore</span>
         <span class="s3">* </span><span class="s4">@memberOf </span><span class="s3">module:symbol-tree#</span>
         <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object} referenceObject</span>
         <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object} newObject</span>
         <span class="s3">* </span><span class="s4">@throws </span><span class="s3">{Error} If the newObject is already present in this SymbolTree</span>
         <span class="s3">* </span><span class="s4">@return </span><span class="s3">{Object} newObject</span>
         <span class="s3">*/</span>
        <span class="s2">insertBefore</span><span class="s1">(</span><span class="s2">referenceObject</span><span class="s1">, </span><span class="s2">newObject</span><span class="s1">) {</span>
                <span class="s5">const </span><span class="s2">referenceNode </span><span class="s1">= </span><span class="s5">this</span><span class="s1">.</span><span class="s2">_node</span><span class="s1">(</span><span class="s2">referenceObject</span><span class="s1">);</span>
                <span class="s5">const </span><span class="s2">prevNode </span><span class="s1">= </span><span class="s5">this</span><span class="s1">.</span><span class="s2">_node</span><span class="s1">(</span><span class="s2">referenceNode</span><span class="s1">.</span><span class="s2">previousSibling</span><span class="s1">);</span>
                <span class="s5">const </span><span class="s2">newNode </span><span class="s1">= </span><span class="s5">this</span><span class="s1">.</span><span class="s2">_node</span><span class="s1">(</span><span class="s2">newObject</span><span class="s1">);</span>
                <span class="s5">const </span><span class="s2">parentNode </span><span class="s1">= </span><span class="s5">this</span><span class="s1">.</span><span class="s2">_node</span><span class="s1">(</span><span class="s2">referenceNode</span><span class="s1">.</span><span class="s2">parent</span><span class="s1">);</span>

                <span class="s5">if </span><span class="s1">(</span><span class="s2">newNode</span><span class="s1">.</span><span class="s2">isAttached</span><span class="s1">) {</span>
                        <span class="s5">throw </span><span class="s2">Error</span><span class="s1">(</span><span class="s0">'Given object is already present in this SymbolTree, remove it first'</span><span class="s1">);</span>
                <span class="s1">}</span>

                <span class="s2">newNode</span><span class="s1">.</span><span class="s2">parent </span><span class="s1">= </span><span class="s2">referenceNode</span><span class="s1">.</span><span class="s2">parent</span><span class="s1">;</span>
                <span class="s2">newNode</span><span class="s1">.</span><span class="s2">previousSibling </span><span class="s1">= </span><span class="s2">referenceNode</span><span class="s1">.</span><span class="s2">previousSibling</span><span class="s1">;</span>
                <span class="s2">newNode</span><span class="s1">.</span><span class="s2">nextSibling </span><span class="s1">= </span><span class="s2">referenceObject</span><span class="s1">;</span>
                <span class="s2">referenceNode</span><span class="s1">.</span><span class="s2">previousSibling </span><span class="s1">= </span><span class="s2">newObject</span><span class="s1">;</span>

                <span class="s5">if </span><span class="s1">(</span><span class="s2">prevNode</span><span class="s1">) {</span>
                        <span class="s2">prevNode</span><span class="s1">.</span><span class="s2">nextSibling </span><span class="s1">= </span><span class="s2">newObject</span><span class="s1">;</span>
                <span class="s1">}</span>

                <span class="s5">if </span><span class="s1">(</span><span class="s2">parentNode </span><span class="s1">&amp;&amp; </span><span class="s2">parentNode</span><span class="s1">.</span><span class="s2">firstChild </span><span class="s1">=== </span><span class="s2">referenceObject</span><span class="s1">) {</span>
                        <span class="s2">parentNode</span><span class="s1">.</span><span class="s2">firstChild </span><span class="s1">= </span><span class="s2">newObject</span><span class="s1">;</span>
                <span class="s1">}</span>

                <span class="s5">if </span><span class="s1">(</span><span class="s2">parentNode</span><span class="s1">) {</span>
                        <span class="s2">parentNode</span><span class="s1">.</span><span class="s2">childrenChanged</span><span class="s1">();</span>
                <span class="s1">}</span>

                <span class="s5">return </span><span class="s2">newObject</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">/**</span>
         <span class="s3">* Insert the given object after the reference object.</span>
         <span class="s3">* `newObject` is now the next sibling of `referenceObject`.</span>
         <span class="s3">*</span>
         <span class="s3">* * `O(1)`</span>
         <span class="s3">*</span>
         <span class="s3">* </span><span class="s4">@method </span><span class="s3">insertAfter</span>
         <span class="s3">* </span><span class="s4">@memberOf </span><span class="s3">module:symbol-tree#</span>
         <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object} referenceObject</span>
         <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object} newObject</span>
         <span class="s3">* </span><span class="s4">@throws </span><span class="s3">{Error} If the newObject is already present in this SymbolTree</span>
         <span class="s3">* </span><span class="s4">@return </span><span class="s3">{Object} newObject</span>
         <span class="s3">*/</span>
        <span class="s2">insertAfter</span><span class="s1">(</span><span class="s2">referenceObject</span><span class="s1">, </span><span class="s2">newObject</span><span class="s1">) {</span>
                <span class="s5">const </span><span class="s2">referenceNode </span><span class="s1">= </span><span class="s5">this</span><span class="s1">.</span><span class="s2">_node</span><span class="s1">(</span><span class="s2">referenceObject</span><span class="s1">);</span>
                <span class="s5">const </span><span class="s2">nextNode </span><span class="s1">= </span><span class="s5">this</span><span class="s1">.</span><span class="s2">_node</span><span class="s1">(</span><span class="s2">referenceNode</span><span class="s1">.</span><span class="s2">nextSibling</span><span class="s1">);</span>
                <span class="s5">const </span><span class="s2">newNode </span><span class="s1">= </span><span class="s5">this</span><span class="s1">.</span><span class="s2">_node</span><span class="s1">(</span><span class="s2">newObject</span><span class="s1">);</span>
                <span class="s5">const </span><span class="s2">parentNode </span><span class="s1">= </span><span class="s5">this</span><span class="s1">.</span><span class="s2">_node</span><span class="s1">(</span><span class="s2">referenceNode</span><span class="s1">.</span><span class="s2">parent</span><span class="s1">);</span>

                <span class="s5">if </span><span class="s1">(</span><span class="s2">newNode</span><span class="s1">.</span><span class="s2">isAttached</span><span class="s1">) {</span>
                        <span class="s5">throw </span><span class="s2">Error</span><span class="s1">(</span><span class="s0">'Given object is already present in this SymbolTree, remove it first'</span><span class="s1">);</span>
                <span class="s1">}</span>

                <span class="s2">newNode</span><span class="s1">.</span><span class="s2">parent </span><span class="s1">= </span><span class="s2">referenceNode</span><span class="s1">.</span><span class="s2">parent</span><span class="s1">;</span>
                <span class="s2">newNode</span><span class="s1">.</span><span class="s2">previousSibling </span><span class="s1">= </span><span class="s2">referenceObject</span><span class="s1">;</span>
                <span class="s2">newNode</span><span class="s1">.</span><span class="s2">nextSibling </span><span class="s1">= </span><span class="s2">referenceNode</span><span class="s1">.</span><span class="s2">nextSibling</span><span class="s1">;</span>
                <span class="s2">referenceNode</span><span class="s1">.</span><span class="s2">nextSibling </span><span class="s1">= </span><span class="s2">newObject</span><span class="s1">;</span>

                <span class="s5">if </span><span class="s1">(</span><span class="s2">nextNode</span><span class="s1">) {</span>
                        <span class="s2">nextNode</span><span class="s1">.</span><span class="s2">previousSibling </span><span class="s1">= </span><span class="s2">newObject</span><span class="s1">;</span>
                <span class="s1">}</span>

                <span class="s5">if </span><span class="s1">(</span><span class="s2">parentNode </span><span class="s1">&amp;&amp; </span><span class="s2">parentNode</span><span class="s1">.</span><span class="s2">lastChild </span><span class="s1">=== </span><span class="s2">referenceObject</span><span class="s1">) {</span>
                        <span class="s2">parentNode</span><span class="s1">.</span><span class="s2">lastChild </span><span class="s1">= </span><span class="s2">newObject</span><span class="s1">;</span>
                <span class="s1">}</span>

                <span class="s5">if </span><span class="s1">(</span><span class="s2">parentNode</span><span class="s1">) {</span>
                        <span class="s2">parentNode</span><span class="s1">.</span><span class="s2">childrenChanged</span><span class="s1">();</span>
                <span class="s1">}</span>

                <span class="s5">return </span><span class="s2">newObject</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">/**</span>
         <span class="s3">* Insert the given object as the first child of the given reference object.</span>
         <span class="s3">* `newObject` is now the first child of `referenceObject`.</span>
         <span class="s3">*</span>
         <span class="s3">* * `O(1)`</span>
         <span class="s3">*</span>
         <span class="s3">* </span><span class="s4">@method </span><span class="s3">prependChild</span>
         <span class="s3">* </span><span class="s4">@memberOf </span><span class="s3">module:symbol-tree#</span>
         <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object} referenceObject</span>
         <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object} newObject</span>
         <span class="s3">* </span><span class="s4">@throws </span><span class="s3">{Error} If the newObject is already present in this SymbolTree</span>
         <span class="s3">* </span><span class="s4">@return </span><span class="s3">{Object} newObject</span>
         <span class="s3">*/</span>
        <span class="s2">prependChild</span><span class="s1">(</span><span class="s2">referenceObject</span><span class="s1">, </span><span class="s2">newObject</span><span class="s1">) {</span>
                <span class="s5">const </span><span class="s2">referenceNode </span><span class="s1">= </span><span class="s5">this</span><span class="s1">.</span><span class="s2">_node</span><span class="s1">(</span><span class="s2">referenceObject</span><span class="s1">);</span>
                <span class="s5">const </span><span class="s2">newNode </span><span class="s1">= </span><span class="s5">this</span><span class="s1">.</span><span class="s2">_node</span><span class="s1">(</span><span class="s2">newObject</span><span class="s1">);</span>

                <span class="s5">if </span><span class="s1">(</span><span class="s2">newNode</span><span class="s1">.</span><span class="s2">isAttached</span><span class="s1">) {</span>
                        <span class="s5">throw </span><span class="s2">Error</span><span class="s1">(</span><span class="s0">'Given object is already present in this SymbolTree, remove it first'</span><span class="s1">);</span>
                <span class="s1">}</span>

                <span class="s5">if </span><span class="s1">(</span><span class="s2">referenceNode</span><span class="s1">.</span><span class="s2">hasChildren</span><span class="s1">) {</span>
                        <span class="s5">this</span><span class="s1">.</span><span class="s2">insertBefore</span><span class="s1">(</span><span class="s2">referenceNode</span><span class="s1">.</span><span class="s2">firstChild</span><span class="s1">, </span><span class="s2">newObject</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s5">else </span><span class="s1">{</span>
                        <span class="s2">newNode</span><span class="s1">.</span><span class="s2">parent </span><span class="s1">= </span><span class="s2">referenceObject</span><span class="s1">;</span>
                        <span class="s2">referenceNode</span><span class="s1">.</span><span class="s2">firstChild </span><span class="s1">= </span><span class="s2">newObject</span><span class="s1">;</span>
                        <span class="s2">referenceNode</span><span class="s1">.</span><span class="s2">lastChild </span><span class="s1">= </span><span class="s2">newObject</span><span class="s1">;</span>
                        <span class="s2">referenceNode</span><span class="s1">.</span><span class="s2">childrenChanged</span><span class="s1">();</span>
                <span class="s1">}</span>

                <span class="s5">return </span><span class="s2">newObject</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">/**</span>
         <span class="s3">* Insert the given object as the last child of the given reference object.</span>
         <span class="s3">* `newObject` is now the last child of `referenceObject`.</span>
         <span class="s3">*</span>
         <span class="s3">* * `O(1)`</span>
         <span class="s3">*</span>
         <span class="s3">* </span><span class="s4">@method </span><span class="s3">appendChild</span>
         <span class="s3">* </span><span class="s4">@memberOf </span><span class="s3">module:symbol-tree#</span>
         <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object} referenceObject</span>
         <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object} newObject</span>
         <span class="s3">* </span><span class="s4">@throws </span><span class="s3">{Error} If the newObject is already present in this SymbolTree</span>
         <span class="s3">* </span><span class="s4">@return </span><span class="s3">{Object} newObject</span>
         <span class="s3">*/</span>
        <span class="s2">appendChild</span><span class="s1">(</span><span class="s2">referenceObject</span><span class="s1">, </span><span class="s2">newObject</span><span class="s1">) {</span>
                <span class="s5">const </span><span class="s2">referenceNode </span><span class="s1">= </span><span class="s5">this</span><span class="s1">.</span><span class="s2">_node</span><span class="s1">(</span><span class="s2">referenceObject</span><span class="s1">);</span>
                <span class="s5">const </span><span class="s2">newNode </span><span class="s1">= </span><span class="s5">this</span><span class="s1">.</span><span class="s2">_node</span><span class="s1">(</span><span class="s2">newObject</span><span class="s1">);</span>

                <span class="s5">if </span><span class="s1">(</span><span class="s2">newNode</span><span class="s1">.</span><span class="s2">isAttached</span><span class="s1">) {</span>
                        <span class="s5">throw </span><span class="s2">Error</span><span class="s1">(</span><span class="s0">'Given object is already present in this SymbolTree, remove it first'</span><span class="s1">);</span>
                <span class="s1">}</span>

                <span class="s5">if </span><span class="s1">(</span><span class="s2">referenceNode</span><span class="s1">.</span><span class="s2">hasChildren</span><span class="s1">) {</span>
                        <span class="s5">this</span><span class="s1">.</span><span class="s2">insertAfter</span><span class="s1">(</span><span class="s2">referenceNode</span><span class="s1">.</span><span class="s2">lastChild</span><span class="s1">, </span><span class="s2">newObject</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s5">else </span><span class="s1">{</span>
                        <span class="s2">newNode</span><span class="s1">.</span><span class="s2">parent </span><span class="s1">= </span><span class="s2">referenceObject</span><span class="s1">;</span>
                        <span class="s2">referenceNode</span><span class="s1">.</span><span class="s2">firstChild </span><span class="s1">= </span><span class="s2">newObject</span><span class="s1">;</span>
                        <span class="s2">referenceNode</span><span class="s1">.</span><span class="s2">lastChild </span><span class="s1">= </span><span class="s2">newObject</span><span class="s1">;</span>
                        <span class="s2">referenceNode</span><span class="s1">.</span><span class="s2">childrenChanged</span><span class="s1">();</span>
                <span class="s1">}</span>

                <span class="s5">return </span><span class="s2">newObject</span><span class="s1">;</span>
        <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">module</span><span class="s1">.</span><span class="s2">exports </span><span class="s1">= </span><span class="s2">SymbolTree</span><span class="s1">;</span>
<span class="s2">SymbolTree</span><span class="s1">.</span><span class="s2">TreePosition </span><span class="s1">= </span><span class="s2">TreePosition</span><span class="s1">;</span>
</pre>
</body>
</html>