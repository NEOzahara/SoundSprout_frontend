<html>
<head>
<title>TypeScriptTransformer.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #6aab73;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #cf8e6d;}
.s4 { color: #7a7e85;}
.s5 { color: #5f826b; font-style: italic;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
TypeScriptTransformer.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span><span class="s2">Object</span><span class="s1">.</span><span class="s2">defineProperty</span><span class="s1">(</span><span class="s2">exports</span><span class="s1">, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span><span class="s2">value</span><span class="s1">: </span><span class="s3">true</span><span class="s1">}); </span><span class="s3">function </span><span class="s2">_interopRequireDefault</span><span class="s1">(</span><span class="s2">obj</span><span class="s1">) { </span><span class="s3">return </span><span class="s2">obj </span><span class="s1">&amp;&amp; </span><span class="s2">obj</span><span class="s1">.</span><span class="s2">__esModule </span><span class="s1">? </span><span class="s2">obj </span><span class="s1">: { </span><span class="s3">default</span><span class="s1">: </span><span class="s2">obj </span><span class="s1">}; }</span>
<span class="s3">var </span><span class="s2">_types </span><span class="s1">= </span><span class="s2">require</span><span class="s1">(</span><span class="s0">'../parser/tokenizer/types'</span><span class="s1">);</span>

<span class="s3">var </span><span class="s2">_isIdentifier </span><span class="s1">= </span><span class="s2">require</span><span class="s1">(</span><span class="s0">'../util/isIdentifier'</span><span class="s1">); </span><span class="s3">var </span><span class="s2">_isIdentifier2 </span><span class="s1">= </span><span class="s2">_interopRequireDefault</span><span class="s1">(</span><span class="s2">_isIdentifier</span><span class="s1">);</span>

<span class="s3">var </span><span class="s2">_Transformer </span><span class="s1">= </span><span class="s2">require</span><span class="s1">(</span><span class="s0">'./Transformer'</span><span class="s1">); </span><span class="s3">var </span><span class="s2">_Transformer2 </span><span class="s1">= </span><span class="s2">_interopRequireDefault</span><span class="s1">(</span><span class="s2">_Transformer</span><span class="s1">);</span>

 <span class="s3">class </span><span class="s2">TypeScriptTransformer </span><span class="s3">extends </span><span class="s2">_Transformer2</span><span class="s1">.</span><span class="s2">default </span><span class="s1">{</span>
  <span class="s2">constructor</span><span class="s1">(</span>
     <span class="s2">rootTransformer</span><span class="s1">,</span>
     <span class="s2">tokens</span><span class="s1">,</span>
     <span class="s2">isImportsTransformEnabled</span><span class="s1">,</span>
  <span class="s1">) {</span>
    <span class="s3">super</span><span class="s1">();</span><span class="s3">this</span><span class="s1">.</span><span class="s2">rootTransformer </span><span class="s1">= </span><span class="s2">rootTransformer</span><span class="s1">;</span><span class="s3">this</span><span class="s1">.</span><span class="s2">tokens </span><span class="s1">= </span><span class="s2">tokens</span><span class="s1">;</span><span class="s3">this</span><span class="s1">.</span><span class="s2">isImportsTransformEnabled </span><span class="s1">= </span><span class="s2">isImportsTransformEnabled</span><span class="s1">;;</span>
  <span class="s1">}</span>

  <span class="s2">process</span><span class="s1">() {</span>
    <span class="s3">if </span><span class="s1">(</span>
      <span class="s3">this</span><span class="s1">.</span><span class="s2">rootTransformer</span><span class="s1">.</span><span class="s2">processPossibleArrowParamEnd</span><span class="s1">() ||</span>
      <span class="s3">this</span><span class="s1">.</span><span class="s2">rootTransformer</span><span class="s1">.</span><span class="s2">processPossibleAsyncArrowWithTypeParams</span><span class="s1">() ||</span>
      <span class="s3">this</span><span class="s1">.</span><span class="s2">rootTransformer</span><span class="s1">.</span><span class="s2">processPossibleTypeRange</span><span class="s1">()</span>
    <span class="s1">) {</span>
      <span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(</span>
      <span class="s3">this</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">matches1</span><span class="s1">(</span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_public</span><span class="s1">) ||</span>
      <span class="s3">this</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">matches1</span><span class="s1">(</span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_protected</span><span class="s1">) ||</span>
      <span class="s3">this</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">matches1</span><span class="s1">(</span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_private</span><span class="s1">) ||</span>
      <span class="s3">this</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">matches1</span><span class="s1">(</span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_abstract</span><span class="s1">) ||</span>
      <span class="s3">this</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">matches1</span><span class="s1">(</span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_readonly</span><span class="s1">) ||</span>
      <span class="s3">this</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">matches1</span><span class="s1">(</span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_override</span><span class="s1">) ||</span>
      <span class="s3">this</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">matches1</span><span class="s1">(</span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">nonNullAssertion</span><span class="s1">)</span>
    <span class="s1">) {</span>
      <span class="s3">this</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">removeInitialToken</span><span class="s1">();</span>
      <span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">matches1</span><span class="s1">(</span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_enum</span><span class="s1">) || </span><span class="s3">this</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">matches2</span><span class="s1">(</span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_const</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_enum</span><span class="s1">)) {</span>
      <span class="s3">this</span><span class="s1">.</span><span class="s2">processEnum</span><span class="s1">();</span>
      <span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(</span>
      <span class="s3">this</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">matches2</span><span class="s1">(</span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_export</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_enum</span><span class="s1">) ||</span>
      <span class="s3">this</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">matches3</span><span class="s1">(</span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_export</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_const</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_enum</span><span class="s1">)</span>
    <span class="s1">) {</span>
      <span class="s3">this</span><span class="s1">.</span><span class="s2">processEnum</span><span class="s1">(</span><span class="s3">true</span><span class="s1">);</span>
      <span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">return false</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">processEnum</span><span class="s1">(</span><span class="s2">isExport </span><span class="s1">= </span><span class="s3">false</span><span class="s1">) {</span>
    <span class="s4">// We might have &quot;export const enum&quot;, so just remove all relevant tokens.</span>
    <span class="s3">this</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">removeInitialToken</span><span class="s1">();</span>
    <span class="s3">while </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">matches1</span><span class="s1">(</span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_const</span><span class="s1">) || </span><span class="s3">this</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">matches1</span><span class="s1">(</span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_enum</span><span class="s1">)) {</span>
      <span class="s3">this</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">removeToken</span><span class="s1">();</span>
    <span class="s1">}</span>
    <span class="s3">const </span><span class="s2">enumName </span><span class="s1">= </span><span class="s3">this</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">identifierName</span><span class="s1">();</span>
    <span class="s3">this</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">removeToken</span><span class="s1">();</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s2">isExport </span><span class="s1">&amp;&amp; !</span><span class="s3">this</span><span class="s1">.</span><span class="s2">isImportsTransformEnabled</span><span class="s1">) {</span>
      <span class="s3">this</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">appendCode</span><span class="s1">(</span><span class="s0">&quot;export &quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s3">this</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">appendCode</span><span class="s1">(</span><span class="s0">`var </span><span class="s2">$</span><span class="s1">{</span><span class="s2">enumName</span><span class="s1">}</span><span class="s0">; (function (</span><span class="s2">$</span><span class="s1">{</span><span class="s2">enumName</span><span class="s1">}</span><span class="s0">)`</span><span class="s1">);</span>
    <span class="s3">this</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">copyExpectedToken</span><span class="s1">(</span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">braceL</span><span class="s1">);</span>
    <span class="s3">this</span><span class="s1">.</span><span class="s2">processEnumBody</span><span class="s1">(</span><span class="s2">enumName</span><span class="s1">);</span>
    <span class="s3">this</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">copyExpectedToken</span><span class="s1">(</span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">braceR</span><span class="s1">);</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s2">isExport </span><span class="s1">&amp;&amp; </span><span class="s3">this</span><span class="s1">.</span><span class="s2">isImportsTransformEnabled</span><span class="s1">) {</span>
      <span class="s3">this</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">appendCode</span><span class="s1">(</span><span class="s0">`)(</span><span class="s2">$</span><span class="s1">{</span><span class="s2">enumName</span><span class="s1">} </span><span class="s0">|| (exports.</span><span class="s2">$</span><span class="s1">{</span><span class="s2">enumName</span><span class="s1">} </span><span class="s0">= </span><span class="s2">$</span><span class="s1">{</span><span class="s2">enumName</span><span class="s1">} </span><span class="s0">= {}));`</span><span class="s1">);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s3">this</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">appendCode</span><span class="s1">(</span><span class="s0">`)(</span><span class="s2">$</span><span class="s1">{</span><span class="s2">enumName</span><span class="s1">} </span><span class="s0">|| (</span><span class="s2">$</span><span class="s1">{</span><span class="s2">enumName</span><span class="s1">} </span><span class="s0">= {}));`</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s5">/**</span>
   <span class="s5">* Transform an enum into equivalent JS. This has complexity in a few places:</span>
   <span class="s5">* - TS allows string enums, numeric enums, and a mix of the two styles within an enum.</span>
   <span class="s5">* - Enum keys are allowed to be referenced in later enum values.</span>
   <span class="s5">* - Enum keys are allowed to be strings.</span>
   <span class="s5">* - When enum values are omitted, they should follow an auto-increment behavior.</span>
   <span class="s5">*/</span>
  <span class="s2">processEnumBody</span><span class="s1">(</span><span class="s2">enumName</span><span class="s1">) {</span>
    <span class="s4">// Code that can be used to reference the previous enum member, or null if this is the first</span>
    <span class="s4">// enum member.</span>
    <span class="s3">let </span><span class="s2">previousValueCode </span><span class="s1">= </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">while </span><span class="s1">(</span><span class="s3">true</span><span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">matches1</span><span class="s1">(</span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">braceR</span><span class="s1">)) {</span>
        <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s3">const </span><span class="s1">{</span><span class="s2">nameStringCode</span><span class="s1">, </span><span class="s2">variableName</span><span class="s1">} = </span><span class="s3">this</span><span class="s1">.</span><span class="s2">extractEnumKeyInfo</span><span class="s1">(</span><span class="s3">this</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">currentToken</span><span class="s1">());</span>
      <span class="s3">this</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">removeInitialToken</span><span class="s1">();</span>

      <span class="s3">if </span><span class="s1">(</span>
        <span class="s3">this</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">matches3</span><span class="s1">(</span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">eq</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">string</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">comma</span><span class="s1">) ||</span>
        <span class="s3">this</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">matches3</span><span class="s1">(</span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">eq</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">string</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">braceR</span><span class="s1">)</span>
      <span class="s1">) {</span>
        <span class="s3">this</span><span class="s1">.</span><span class="s2">processStringLiteralEnumMember</span><span class="s1">(</span><span class="s2">enumName</span><span class="s1">, </span><span class="s2">nameStringCode</span><span class="s1">, </span><span class="s2">variableName</span><span class="s1">);</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">matches1</span><span class="s1">(</span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">eq</span><span class="s1">)) {</span>
        <span class="s3">this</span><span class="s1">.</span><span class="s2">processExplicitValueEnumMember</span><span class="s1">(</span><span class="s2">enumName</span><span class="s1">, </span><span class="s2">nameStringCode</span><span class="s1">, </span><span class="s2">variableName</span><span class="s1">);</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s3">this</span><span class="s1">.</span><span class="s2">processImplicitValueEnumMember</span><span class="s1">(</span>
          <span class="s2">enumName</span><span class="s1">,</span>
          <span class="s2">nameStringCode</span><span class="s1">,</span>
          <span class="s2">variableName</span><span class="s1">,</span>
          <span class="s2">previousValueCode</span><span class="s1">,</span>
        <span class="s1">);</span>
      <span class="s1">}</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">matches1</span><span class="s1">(</span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">comma</span><span class="s1">)) {</span>
        <span class="s3">this</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">removeToken</span><span class="s1">();</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(</span><span class="s2">variableName </span><span class="s1">!= </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s2">previousValueCode </span><span class="s1">= </span><span class="s2">variableName</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s2">previousValueCode </span><span class="s1">= </span><span class="s0">`</span><span class="s2">$</span><span class="s1">{</span><span class="s2">enumName</span><span class="s1">}</span><span class="s0">[</span><span class="s2">$</span><span class="s1">{</span><span class="s2">nameStringCode</span><span class="s1">}</span><span class="s0">]`</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s5">/**</span>
   <span class="s5">* Detect name information about this enum key, which will be used to determine which code to emit</span>
   <span class="s5">* and whether we should declare a variable as part of this declaration.</span>
   <span class="s5">*</span>
   <span class="s5">* Some cases to keep in mind:</span>
   <span class="s5">* - Enum keys can be implicitly referenced later, e.g. `X = 1, Y = X`. In Sucrase, we implement</span>
   <span class="s5">*   this by declaring a variable `X` so that later expressions can use it.</span>
   <span class="s5">* - In addition to the usual identifier key syntax, enum keys are allowed to be string literals,</span>
   <span class="s5">*   e.g. `&quot;hello world&quot; = 3,`. Template literal syntax is NOT allowed.</span>
   <span class="s5">* - Even if the enum key is defined as a string literal, it may still be referenced by identifier</span>
   <span class="s5">*   later, e.g. `&quot;X&quot; = 1, Y = X`. That means that we need to detect whether or not a string</span>
   <span class="s5">*   literal is identifier-like and emit a variable if so, even if the declaration did not use an</span>
   <span class="s5">*   identifier.</span>
   <span class="s5">* - Reserved keywords like `break` are valid enum keys, but are not valid to be referenced later</span>
   <span class="s5">*   and would be a syntax error if we emitted a variable, so we need to skip the variable</span>
   <span class="s5">*   declaration in those cases.</span>
   <span class="s5">*</span>
   <span class="s5">* The variableName return value captures these nuances: if non-null, we can and must emit a</span>
   <span class="s5">* variable declaration, and if null, we can't and shouldn't.</span>
   <span class="s5">*/</span>
  <span class="s2">extractEnumKeyInfo</span><span class="s1">(</span><span class="s2">nameToken</span><span class="s1">) {</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s2">nameToken</span><span class="s1">.</span><span class="s2">type </span><span class="s1">=== </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">name</span><span class="s1">) {</span>
      <span class="s3">const </span><span class="s2">name </span><span class="s1">= </span><span class="s3">this</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">identifierNameForToken</span><span class="s1">(</span><span class="s2">nameToken</span><span class="s1">);</span>
      <span class="s3">return </span><span class="s1">{</span>
        <span class="s2">nameStringCode</span><span class="s1">: </span><span class="s0">`&quot;</span><span class="s2">$</span><span class="s1">{</span><span class="s2">name</span><span class="s1">}</span><span class="s0">&quot;`</span><span class="s1">,</span>
        <span class="s2">variableName</span><span class="s1">: </span><span class="s2">_isIdentifier2</span><span class="s1">.</span><span class="s2">default</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s6">0</span><span class="s1">, </span><span class="s2">name</span><span class="s1">) ? </span><span class="s2">name </span><span class="s1">: </span><span class="s3">null</span><span class="s1">,</span>
      <span class="s1">};</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s2">nameToken</span><span class="s1">.</span><span class="s2">type </span><span class="s1">=== </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">string</span><span class="s1">) {</span>
      <span class="s3">const </span><span class="s2">name </span><span class="s1">= </span><span class="s3">this</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">stringValueForToken</span><span class="s1">(</span><span class="s2">nameToken</span><span class="s1">);</span>
      <span class="s3">return </span><span class="s1">{</span>
        <span class="s2">nameStringCode</span><span class="s1">: </span><span class="s3">this</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">code</span><span class="s1">.</span><span class="s2">slice</span><span class="s1">(</span><span class="s2">nameToken</span><span class="s1">.</span><span class="s2">start</span><span class="s1">, </span><span class="s2">nameToken</span><span class="s1">.</span><span class="s2">end</span><span class="s1">),</span>
        <span class="s2">variableName</span><span class="s1">: </span><span class="s2">_isIdentifier2</span><span class="s1">.</span><span class="s2">default</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s6">0</span><span class="s1">, </span><span class="s2">name</span><span class="s1">) ? </span><span class="s2">name </span><span class="s1">: </span><span class="s3">null</span><span class="s1">,</span>
      <span class="s1">};</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s3">throw new </span><span class="s2">Error</span><span class="s1">(</span><span class="s0">&quot;Expected name or string at beginning of enum element.&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s5">/**</span>
   <span class="s5">* Handle an enum member where the RHS is just a string literal (not omitted, not a number, and</span>
   <span class="s5">* not a complex expression). This is the typical form for TS string enums, and in this case, we</span>
   <span class="s5">* do *not* create a reverse mapping.</span>
   <span class="s5">*</span>
   <span class="s5">* This is called after deleting the key token, when the token processor is at the equals sign.</span>
   <span class="s5">*</span>
   <span class="s5">* Example 1:</span>
   <span class="s5">* someKey = &quot;some value&quot;</span>
   <span class="s5">* -&gt;</span>
   <span class="s5">* const someKey = &quot;some value&quot;; MyEnum[&quot;someKey&quot;] = someKey;</span>
   <span class="s5">*</span>
   <span class="s5">* Example 2:</span>
   <span class="s5">* &quot;some key&quot; = &quot;some value&quot;</span>
   <span class="s5">* -&gt;</span>
   <span class="s5">* MyEnum[&quot;some key&quot;] = &quot;some value&quot;;</span>
   <span class="s5">*/</span>
  <span class="s2">processStringLiteralEnumMember</span><span class="s1">(</span>
    <span class="s2">enumName</span><span class="s1">,</span>
    <span class="s2">nameStringCode</span><span class="s1">,</span>
    <span class="s2">variableName</span><span class="s1">,</span>
  <span class="s1">) {</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s2">variableName </span><span class="s1">!= </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">this</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">appendCode</span><span class="s1">(</span><span class="s0">`const </span><span class="s2">$</span><span class="s1">{</span><span class="s2">variableName</span><span class="s1">}</span><span class="s0">`</span><span class="s1">);</span>
      <span class="s4">// =</span>
      <span class="s3">this</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">copyToken</span><span class="s1">();</span>
      <span class="s4">// value string</span>
      <span class="s3">this</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">copyToken</span><span class="s1">();</span>
      <span class="s3">this</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">appendCode</span><span class="s1">(</span><span class="s0">`; </span><span class="s2">$</span><span class="s1">{</span><span class="s2">enumName</span><span class="s1">}</span><span class="s0">[</span><span class="s2">$</span><span class="s1">{</span><span class="s2">nameStringCode</span><span class="s1">}</span><span class="s0">] = </span><span class="s2">$</span><span class="s1">{</span><span class="s2">variableName</span><span class="s1">}</span><span class="s0">;`</span><span class="s1">);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s3">this</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">appendCode</span><span class="s1">(</span><span class="s0">`</span><span class="s2">$</span><span class="s1">{</span><span class="s2">enumName</span><span class="s1">}</span><span class="s0">[</span><span class="s2">$</span><span class="s1">{</span><span class="s2">nameStringCode</span><span class="s1">}</span><span class="s0">]`</span><span class="s1">);</span>
      <span class="s4">// =</span>
      <span class="s3">this</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">copyToken</span><span class="s1">();</span>
      <span class="s4">// value string</span>
      <span class="s3">this</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">copyToken</span><span class="s1">();</span>
      <span class="s3">this</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">appendCode</span><span class="s1">(</span><span class="s0">&quot;;&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s5">/**</span>
   <span class="s5">* Handle an enum member initialized with an expression on the right-hand side (other than a</span>
   <span class="s5">* string literal). In these cases, we should transform the expression and emit code that sets up</span>
   <span class="s5">* a reverse mapping.</span>
   <span class="s5">*</span>
   <span class="s5">* The TypeScript implementation of this operation distinguishes between expressions that can be</span>
   <span class="s5">* &quot;constant folded&quot; at compile time (i.e. consist of number literals and simple math operations</span>
   <span class="s5">* on those numbers) and ones that are dynamic. For constant expressions, it emits the resolved</span>
   <span class="s5">* numeric value, and auto-incrementing is only allowed in that case. Evaluating expressions at</span>
   <span class="s5">* compile time would add significant complexity to Sucrase, so Sucrase instead leaves the</span>
   <span class="s5">* expression as-is, and will later emit something like `MyEnum[&quot;previousKey&quot;] + 1` to implement</span>
   <span class="s5">* auto-incrementing.</span>
   <span class="s5">*</span>
   <span class="s5">* This is called after deleting the key token, when the token processor is at the equals sign.</span>
   <span class="s5">*</span>
   <span class="s5">* Example 1:</span>
   <span class="s5">* someKey = 1 + 1</span>
   <span class="s5">* -&gt;</span>
   <span class="s5">* const someKey = 1 + 1; MyEnum[MyEnum[&quot;someKey&quot;] = someKey] = &quot;someKey&quot;;</span>
   <span class="s5">*</span>
   <span class="s5">* Example 2:</span>
   <span class="s5">* &quot;some key&quot; = 1 + 1</span>
   <span class="s5">* -&gt;</span>
   <span class="s5">* MyEnum[MyEnum[&quot;some key&quot;] = 1 + 1] = &quot;some key&quot;;</span>
   <span class="s5">*/</span>
  <span class="s2">processExplicitValueEnumMember</span><span class="s1">(</span>
    <span class="s2">enumName</span><span class="s1">,</span>
    <span class="s2">nameStringCode</span><span class="s1">,</span>
    <span class="s2">variableName</span><span class="s1">,</span>
  <span class="s1">) {</span>
    <span class="s3">const </span><span class="s2">rhsEndIndex </span><span class="s1">= </span><span class="s3">this</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">currentToken</span><span class="s1">().</span><span class="s2">rhsEndIndex</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s2">rhsEndIndex </span><span class="s1">== </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">throw new </span><span class="s2">Error</span><span class="s1">(</span><span class="s0">&quot;Expected rhsEndIndex on enum assign.&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s2">variableName </span><span class="s1">!= </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">this</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">appendCode</span><span class="s1">(</span><span class="s0">`const </span><span class="s2">$</span><span class="s1">{</span><span class="s2">variableName</span><span class="s1">}</span><span class="s0">`</span><span class="s1">);</span>
      <span class="s3">this</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">copyToken</span><span class="s1">();</span>
      <span class="s3">while </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">currentIndex</span><span class="s1">() &lt; </span><span class="s2">rhsEndIndex</span><span class="s1">) {</span>
        <span class="s3">this</span><span class="s1">.</span><span class="s2">rootTransformer</span><span class="s1">.</span><span class="s2">processToken</span><span class="s1">();</span>
      <span class="s1">}</span>
      <span class="s3">this</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">appendCode</span><span class="s1">(</span>
        <span class="s0">`; </span><span class="s2">$</span><span class="s1">{</span><span class="s2">enumName</span><span class="s1">}</span><span class="s0">[</span><span class="s2">$</span><span class="s1">{</span><span class="s2">enumName</span><span class="s1">}</span><span class="s0">[</span><span class="s2">$</span><span class="s1">{</span><span class="s2">nameStringCode</span><span class="s1">}</span><span class="s0">] = </span><span class="s2">$</span><span class="s1">{</span><span class="s2">variableName</span><span class="s1">}</span><span class="s0">] = </span><span class="s2">$</span><span class="s1">{</span><span class="s2">nameStringCode</span><span class="s1">}</span><span class="s0">;`</span><span class="s1">,</span>
      <span class="s1">);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s3">this</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">appendCode</span><span class="s1">(</span><span class="s0">`</span><span class="s2">$</span><span class="s1">{</span><span class="s2">enumName</span><span class="s1">}</span><span class="s0">[</span><span class="s2">$</span><span class="s1">{</span><span class="s2">enumName</span><span class="s1">}</span><span class="s0">[</span><span class="s2">$</span><span class="s1">{</span><span class="s2">nameStringCode</span><span class="s1">}</span><span class="s0">]`</span><span class="s1">);</span>
      <span class="s3">this</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">copyToken</span><span class="s1">();</span>
      <span class="s3">while </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">currentIndex</span><span class="s1">() &lt; </span><span class="s2">rhsEndIndex</span><span class="s1">) {</span>
        <span class="s3">this</span><span class="s1">.</span><span class="s2">rootTransformer</span><span class="s1">.</span><span class="s2">processToken</span><span class="s1">();</span>
      <span class="s1">}</span>
      <span class="s3">this</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">appendCode</span><span class="s1">(</span><span class="s0">`] = </span><span class="s2">$</span><span class="s1">{</span><span class="s2">nameStringCode</span><span class="s1">}</span><span class="s0">;`</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s5">/**</span>
   <span class="s5">* Handle an enum member with no right-hand side expression. In this case, the value is the</span>
   <span class="s5">* previous value plus 1, or 0 if there was no previous value. We should also always emit a</span>
   <span class="s5">* reverse mapping.</span>
   <span class="s5">*</span>
   <span class="s5">* Example 1:</span>
   <span class="s5">* someKey2</span>
   <span class="s5">* -&gt;</span>
   <span class="s5">* const someKey2 = someKey1 + 1; MyEnum[MyEnum[&quot;someKey2&quot;] = someKey2] = &quot;someKey2&quot;;</span>
   <span class="s5">*</span>
   <span class="s5">* Example 2:</span>
   <span class="s5">* &quot;some key 2&quot;</span>
   <span class="s5">* -&gt;</span>
   <span class="s5">* MyEnum[MyEnum[&quot;some key 2&quot;] = someKey1 + 1] = &quot;some key 2&quot;;</span>
   <span class="s5">*/</span>
  <span class="s2">processImplicitValueEnumMember</span><span class="s1">(</span>
    <span class="s2">enumName</span><span class="s1">,</span>
    <span class="s2">nameStringCode</span><span class="s1">,</span>
    <span class="s2">variableName</span><span class="s1">,</span>
    <span class="s2">previousValueCode</span><span class="s1">,</span>
  <span class="s1">) {</span>
    <span class="s3">let </span><span class="s2">valueCode </span><span class="s1">= </span><span class="s2">previousValueCode </span><span class="s1">!= </span><span class="s3">null </span><span class="s1">? </span><span class="s0">`</span><span class="s2">$</span><span class="s1">{</span><span class="s2">previousValueCode</span><span class="s1">} </span><span class="s0">+ 1` </span><span class="s1">: </span><span class="s0">&quot;0&quot;</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s2">variableName </span><span class="s1">!= </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">this</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">appendCode</span><span class="s1">(</span><span class="s0">`const </span><span class="s2">$</span><span class="s1">{</span><span class="s2">variableName</span><span class="s1">} </span><span class="s0">= </span><span class="s2">$</span><span class="s1">{</span><span class="s2">valueCode</span><span class="s1">}</span><span class="s0">; `</span><span class="s1">);</span>
      <span class="s2">valueCode </span><span class="s1">= </span><span class="s2">variableName</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">this</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">appendCode</span><span class="s1">(</span>
      <span class="s0">`</span><span class="s2">$</span><span class="s1">{</span><span class="s2">enumName</span><span class="s1">}</span><span class="s0">[</span><span class="s2">$</span><span class="s1">{</span><span class="s2">enumName</span><span class="s1">}</span><span class="s0">[</span><span class="s2">$</span><span class="s1">{</span><span class="s2">nameStringCode</span><span class="s1">}</span><span class="s0">] = </span><span class="s2">$</span><span class="s1">{</span><span class="s2">valueCode</span><span class="s1">}</span><span class="s0">] = </span><span class="s2">$</span><span class="s1">{</span><span class="s2">nameStringCode</span><span class="s1">}</span><span class="s0">;`</span><span class="s1">,</span>
    <span class="s1">);</span>
  <span class="s1">}</span>
<span class="s1">} </span><span class="s2">exports</span><span class="s1">.</span><span class="s2">default </span><span class="s1">= </span><span class="s2">TypeScriptTransformer</span><span class="s1">;</span>
</pre>
</body>
</html>