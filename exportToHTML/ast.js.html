<html>
<head>
<title>ast.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #6aab73;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #7a7e85;}
.s4 { color: #cf8e6d;}
.s5 { color: #2aacb8;}
.s6 { color: #42c3d4;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
ast.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s3">// parse a single path portion</span>
<span class="s2">Object</span><span class="s1">.</span><span class="s2">defineProperty</span><span class="s1">(</span><span class="s2">exports</span><span class="s1">, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, { </span><span class="s2">value</span><span class="s1">: </span><span class="s4">true </span><span class="s1">});</span>
<span class="s2">exports</span><span class="s1">.</span><span class="s2">AST </span><span class="s1">= </span><span class="s4">void </span><span class="s5">0</span><span class="s1">;</span>
<span class="s4">const </span><span class="s2">brace_expressions_js_1 </span><span class="s1">= </span><span class="s2">require</span><span class="s1">(</span><span class="s0">&quot;./brace-expressions.js&quot;</span><span class="s1">);</span>
<span class="s4">const </span><span class="s2">unescape_js_1 </span><span class="s1">= </span><span class="s2">require</span><span class="s1">(</span><span class="s0">&quot;./unescape.js&quot;</span><span class="s1">);</span>
<span class="s4">const </span><span class="s2">types </span><span class="s1">= </span><span class="s4">new </span><span class="s2">Set</span><span class="s1">([</span><span class="s0">'!'</span><span class="s1">, </span><span class="s0">'?'</span><span class="s1">, </span><span class="s0">'+'</span><span class="s1">, </span><span class="s0">'*'</span><span class="s1">, </span><span class="s0">'@'</span><span class="s1">]);</span>
<span class="s4">const </span><span class="s2">isExtglobType </span><span class="s1">= (</span><span class="s2">c</span><span class="s1">) =&gt; </span><span class="s2">types</span><span class="s1">.</span><span class="s2">has</span><span class="s1">(</span><span class="s2">c</span><span class="s1">);</span>
<span class="s3">// Patterns that get prepended to bind to the start of either the</span>
<span class="s3">// entire string, or just a single path portion, to prevent dots</span>
<span class="s3">// and/or traversal patterns, when needed.</span>
<span class="s3">// Exts don't need the ^ or / bit, because the root binds that already.</span>
<span class="s4">const </span><span class="s2">startNoTraversal </span><span class="s1">= </span><span class="s0">'(?!(?:^|/)</span><span class="s4">\\</span><span class="s0">.</span><span class="s4">\\</span><span class="s0">.?(?:$|/))'</span><span class="s1">;</span>
<span class="s4">const </span><span class="s2">startNoDot </span><span class="s1">= </span><span class="s0">'(?!</span><span class="s4">\\</span><span class="s0">.)'</span><span class="s1">;</span>
<span class="s3">// characters that indicate a start of pattern needs the &quot;no dots&quot; bit,</span>
<span class="s3">// because a dot *might* be matched. ( is not in the list, because in</span>
<span class="s3">// the case of a child extglob, it will handle the prevention itself.</span>
<span class="s4">const </span><span class="s2">addPatternStart </span><span class="s1">= </span><span class="s4">new </span><span class="s2">Set</span><span class="s1">([</span><span class="s0">'['</span><span class="s1">, </span><span class="s0">'.'</span><span class="s1">]);</span>
<span class="s3">// cases where traversal is A-OK, no dot prevention needed</span>
<span class="s4">const </span><span class="s2">justDots </span><span class="s1">= </span><span class="s4">new </span><span class="s2">Set</span><span class="s1">([</span><span class="s0">'..'</span><span class="s1">, </span><span class="s0">'.'</span><span class="s1">]);</span>
<span class="s4">const </span><span class="s2">reSpecials </span><span class="s1">= </span><span class="s4">new </span><span class="s2">Set</span><span class="s1">(</span><span class="s0">'().*{}+?[]^$</span><span class="s4">\\</span><span class="s0">!'</span><span class="s1">);</span>
<span class="s4">const </span><span class="s2">regExpEscape </span><span class="s1">= (</span><span class="s2">s</span><span class="s1">) =&gt; </span><span class="s2">s</span><span class="s1">.</span><span class="s2">replace</span><span class="s1">(</span><span class="s6">/[-[\]{}()*+?.,\\^$|#\s]/g</span><span class="s1">, </span><span class="s0">'</span><span class="s4">\\</span><span class="s0">$&amp;'</span><span class="s1">);</span>
<span class="s3">// any single thing other than /</span>
<span class="s4">const </span><span class="s2">qmark </span><span class="s1">= </span><span class="s0">'[^/]'</span><span class="s1">;</span>
<span class="s3">// * =&gt; any number of characters</span>
<span class="s4">const </span><span class="s2">star </span><span class="s1">= </span><span class="s2">qmark </span><span class="s1">+ </span><span class="s0">'*?'</span><span class="s1">;</span>
<span class="s3">// use + when we need to ensure that *something* matches, because the * is</span>
<span class="s3">// the only thing in the path portion.</span>
<span class="s4">const </span><span class="s2">starNoEmpty </span><span class="s1">= </span><span class="s2">qmark </span><span class="s1">+ </span><span class="s0">'+?'</span><span class="s1">;</span>
<span class="s3">// remove the \ chars that we added if we end up doing a nonmagic compare</span>
<span class="s3">// const deslash = (s: string) =&gt; s.replace(/\\(.)/g, '$1')</span>
<span class="s4">class </span><span class="s2">AST </span><span class="s1">{</span>
    <span class="s2">type</span><span class="s1">;</span>
    <span class="s2">#root</span><span class="s1">;</span>
    <span class="s2">#hasMagic</span><span class="s1">;</span>
    <span class="s2">#uflag </span><span class="s1">= </span><span class="s4">false</span><span class="s1">;</span>
    <span class="s2">#parts </span><span class="s1">= [];</span>
    <span class="s2">#parent</span><span class="s1">;</span>
    <span class="s2">#parentIndex</span><span class="s1">;</span>
    <span class="s2">#negs</span><span class="s1">;</span>
    <span class="s2">#filledNegs </span><span class="s1">= </span><span class="s4">false</span><span class="s1">;</span>
    <span class="s2">#options</span><span class="s1">;</span>
    <span class="s2">#toString</span><span class="s1">;</span>
    <span class="s3">// set to true if it's an extglob with no children</span>
    <span class="s3">// (which really means one child of '')</span>
    <span class="s2">#emptyExt </span><span class="s1">= </span><span class="s4">false</span><span class="s1">;</span>
    <span class="s2">constructor</span><span class="s1">(</span><span class="s2">type</span><span class="s1">, </span><span class="s2">parent</span><span class="s1">, </span><span class="s2">options </span><span class="s1">= {}) {</span>
        <span class="s4">this</span><span class="s1">.</span><span class="s2">type </span><span class="s1">= </span><span class="s2">type</span><span class="s1">;</span>
        <span class="s3">// extglobs are inherently magical</span>
        <span class="s4">if </span><span class="s1">(</span><span class="s2">type</span><span class="s1">)</span>
            <span class="s4">this</span><span class="s1">.</span><span class="s2">#hasMagic </span><span class="s1">= </span><span class="s4">true</span><span class="s1">;</span>
        <span class="s4">this</span><span class="s1">.</span><span class="s2">#parent </span><span class="s1">= </span><span class="s2">parent</span><span class="s1">;</span>
        <span class="s4">this</span><span class="s1">.</span><span class="s2">#root </span><span class="s1">= </span><span class="s4">this</span><span class="s1">.</span><span class="s2">#parent </span><span class="s1">? </span><span class="s4">this</span><span class="s1">.</span><span class="s2">#parent</span><span class="s1">.</span><span class="s2">#root </span><span class="s1">: </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s4">this</span><span class="s1">.</span><span class="s2">#options </span><span class="s1">= </span><span class="s4">this</span><span class="s1">.</span><span class="s2">#root </span><span class="s1">=== </span><span class="s4">this </span><span class="s1">? </span><span class="s2">options </span><span class="s1">: </span><span class="s4">this</span><span class="s1">.</span><span class="s2">#root</span><span class="s1">.</span><span class="s2">#options</span><span class="s1">;</span>
        <span class="s4">this</span><span class="s1">.</span><span class="s2">#negs </span><span class="s1">= </span><span class="s4">this</span><span class="s1">.</span><span class="s2">#root </span><span class="s1">=== </span><span class="s4">this </span><span class="s1">? [] : </span><span class="s4">this</span><span class="s1">.</span><span class="s2">#root</span><span class="s1">.</span><span class="s2">#negs</span><span class="s1">;</span>
        <span class="s4">if </span><span class="s1">(</span><span class="s2">type </span><span class="s1">=== </span><span class="s0">'!' </span><span class="s1">&amp;&amp; !</span><span class="s4">this</span><span class="s1">.</span><span class="s2">#root</span><span class="s1">.</span><span class="s2">#filledNegs</span><span class="s1">)</span>
            <span class="s4">this</span><span class="s1">.</span><span class="s2">#negs</span><span class="s1">.</span><span class="s2">push</span><span class="s1">(</span><span class="s4">this</span><span class="s1">);</span>
        <span class="s4">this</span><span class="s1">.</span><span class="s2">#parentIndex </span><span class="s1">= </span><span class="s4">this</span><span class="s1">.</span><span class="s2">#parent </span><span class="s1">? </span><span class="s4">this</span><span class="s1">.</span><span class="s2">#parent</span><span class="s1">.</span><span class="s2">#parts</span><span class="s1">.</span><span class="s2">length </span><span class="s1">: </span><span class="s5">0</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">get hasMagic</span><span class="s1">() {</span>
        <span class="s3">/* c8 ignore start */</span>
        <span class="s4">if </span><span class="s1">(</span><span class="s4">this</span><span class="s1">.</span><span class="s2">#hasMagic </span><span class="s1">!== </span><span class="s2">undefined</span><span class="s1">)</span>
            <span class="s4">return this</span><span class="s1">.</span><span class="s2">#hasMagic</span><span class="s1">;</span>
        <span class="s3">/* c8 ignore stop */</span>
        <span class="s4">for </span><span class="s1">(</span><span class="s4">const </span><span class="s2">p of </span><span class="s4">this</span><span class="s1">.</span><span class="s2">#parts</span><span class="s1">) {</span>
            <span class="s4">if </span><span class="s1">(</span><span class="s4">typeof </span><span class="s2">p </span><span class="s1">=== </span><span class="s0">'string'</span><span class="s1">)</span>
                <span class="s4">continue</span><span class="s1">;</span>
            <span class="s4">if </span><span class="s1">(</span><span class="s2">p</span><span class="s1">.</span><span class="s2">type </span><span class="s1">|| </span><span class="s2">p</span><span class="s1">.</span><span class="s2">hasMagic</span><span class="s1">)</span>
                <span class="s4">return </span><span class="s1">(</span><span class="s4">this</span><span class="s1">.</span><span class="s2">#hasMagic </span><span class="s1">= </span><span class="s4">true</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s3">// note: will be undefined until we generate the regexp src and find out</span>
        <span class="s4">return this</span><span class="s1">.</span><span class="s2">#hasMagic</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">// reconstructs the pattern</span>
    <span class="s2">toString</span><span class="s1">() {</span>
        <span class="s4">if </span><span class="s1">(</span><span class="s4">this</span><span class="s1">.</span><span class="s2">#toString </span><span class="s1">!== </span><span class="s2">undefined</span><span class="s1">)</span>
            <span class="s4">return this</span><span class="s1">.</span><span class="s2">#toString</span><span class="s1">;</span>
        <span class="s4">if </span><span class="s1">(!</span><span class="s4">this</span><span class="s1">.</span><span class="s2">type</span><span class="s1">) {</span>
            <span class="s4">return </span><span class="s1">(</span><span class="s4">this</span><span class="s1">.</span><span class="s2">#toString </span><span class="s1">= </span><span class="s4">this</span><span class="s1">.</span><span class="s2">#parts</span><span class="s1">.</span><span class="s2">map</span><span class="s1">(</span><span class="s2">p </span><span class="s1">=&gt; </span><span class="s2">String</span><span class="s1">(</span><span class="s2">p</span><span class="s1">)).</span><span class="s2">join</span><span class="s1">(</span><span class="s0">''</span><span class="s1">));</span>
        <span class="s1">}</span>
        <span class="s4">else </span><span class="s1">{</span>
            <span class="s4">return </span><span class="s1">(</span><span class="s4">this</span><span class="s1">.</span><span class="s2">#toString </span><span class="s1">=</span>
                <span class="s4">this</span><span class="s1">.</span><span class="s2">type </span><span class="s1">+ </span><span class="s0">'(' </span><span class="s1">+ </span><span class="s4">this</span><span class="s1">.</span><span class="s2">#parts</span><span class="s1">.</span><span class="s2">map</span><span class="s1">(</span><span class="s2">p </span><span class="s1">=&gt; </span><span class="s2">String</span><span class="s1">(</span><span class="s2">p</span><span class="s1">)).</span><span class="s2">join</span><span class="s1">(</span><span class="s0">'|'</span><span class="s1">) + </span><span class="s0">')'</span><span class="s1">);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">#fillNegs</span><span class="s1">() {</span>
        <span class="s3">/* c8 ignore start */</span>
        <span class="s4">if </span><span class="s1">(</span><span class="s4">this </span><span class="s1">!== </span><span class="s4">this</span><span class="s1">.</span><span class="s2">#root</span><span class="s1">)</span>
            <span class="s4">throw new </span><span class="s2">Error</span><span class="s1">(</span><span class="s0">'should only call on root'</span><span class="s1">);</span>
        <span class="s4">if </span><span class="s1">(</span><span class="s4">this</span><span class="s1">.</span><span class="s2">#filledNegs</span><span class="s1">)</span>
            <span class="s4">return this</span><span class="s1">;</span>
        <span class="s3">/* c8 ignore stop */</span>
        <span class="s3">// call toString() once to fill this out</span>
        <span class="s4">this</span><span class="s1">.</span><span class="s2">toString</span><span class="s1">();</span>
        <span class="s4">this</span><span class="s1">.</span><span class="s2">#filledNegs </span><span class="s1">= </span><span class="s4">true</span><span class="s1">;</span>
        <span class="s4">let </span><span class="s2">n</span><span class="s1">;</span>
        <span class="s4">while </span><span class="s1">((</span><span class="s2">n </span><span class="s1">= </span><span class="s4">this</span><span class="s1">.</span><span class="s2">#negs</span><span class="s1">.</span><span class="s2">pop</span><span class="s1">())) {</span>
            <span class="s4">if </span><span class="s1">(</span><span class="s2">n</span><span class="s1">.</span><span class="s2">type </span><span class="s1">!== </span><span class="s0">'!'</span><span class="s1">)</span>
                <span class="s4">continue</span><span class="s1">;</span>
            <span class="s3">// walk up the tree, appending everthing that comes AFTER parentIndex</span>
            <span class="s4">let </span><span class="s2">p </span><span class="s1">= </span><span class="s2">n</span><span class="s1">;</span>
            <span class="s4">let </span><span class="s2">pp </span><span class="s1">= </span><span class="s2">p</span><span class="s1">.</span><span class="s2">#parent</span><span class="s1">;</span>
            <span class="s4">while </span><span class="s1">(</span><span class="s2">pp</span><span class="s1">) {</span>
                <span class="s4">for </span><span class="s1">(</span><span class="s4">let </span><span class="s2">i </span><span class="s1">= </span><span class="s2">p</span><span class="s1">.</span><span class="s2">#parentIndex </span><span class="s1">+ </span><span class="s5">1</span><span class="s1">; !</span><span class="s2">pp</span><span class="s1">.</span><span class="s2">type </span><span class="s1">&amp;&amp; </span><span class="s2">i </span><span class="s1">&lt; </span><span class="s2">pp</span><span class="s1">.</span><span class="s2">#parts</span><span class="s1">.</span><span class="s2">length</span><span class="s1">; </span><span class="s2">i</span><span class="s1">++) {</span>
                    <span class="s4">for </span><span class="s1">(</span><span class="s4">const </span><span class="s2">part of n</span><span class="s1">.</span><span class="s2">#parts</span><span class="s1">) {</span>
                        <span class="s3">/* c8 ignore start */</span>
                        <span class="s4">if </span><span class="s1">(</span><span class="s4">typeof </span><span class="s2">part </span><span class="s1">=== </span><span class="s0">'string'</span><span class="s1">) {</span>
                            <span class="s4">throw new </span><span class="s2">Error</span><span class="s1">(</span><span class="s0">'string part in extglob AST??'</span><span class="s1">);</span>
                        <span class="s1">}</span>
                        <span class="s3">/* c8 ignore stop */</span>
                        <span class="s2">part</span><span class="s1">.</span><span class="s2">copyIn</span><span class="s1">(</span><span class="s2">pp</span><span class="s1">.</span><span class="s2">#parts</span><span class="s1">[</span><span class="s2">i</span><span class="s1">]);</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">p </span><span class="s1">= </span><span class="s2">pp</span><span class="s1">;</span>
                <span class="s2">pp </span><span class="s1">= </span><span class="s2">p</span><span class="s1">.</span><span class="s2">#parent</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s4">return this</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">push</span><span class="s1">(</span><span class="s2">...parts</span><span class="s1">) {</span>
        <span class="s4">for </span><span class="s1">(</span><span class="s4">const </span><span class="s2">p of parts</span><span class="s1">) {</span>
            <span class="s4">if </span><span class="s1">(</span><span class="s2">p </span><span class="s1">=== </span><span class="s0">''</span><span class="s1">)</span>
                <span class="s4">continue</span><span class="s1">;</span>
            <span class="s3">/* c8 ignore start */</span>
            <span class="s4">if </span><span class="s1">(</span><span class="s4">typeof </span><span class="s2">p </span><span class="s1">!== </span><span class="s0">'string' </span><span class="s1">&amp;&amp; !(</span><span class="s2">p </span><span class="s4">instanceof </span><span class="s2">AST </span><span class="s1">&amp;&amp; </span><span class="s2">p</span><span class="s1">.</span><span class="s2">#parent </span><span class="s1">=== </span><span class="s4">this</span><span class="s1">)) {</span>
                <span class="s4">throw new </span><span class="s2">Error</span><span class="s1">(</span><span class="s0">'invalid part: ' </span><span class="s1">+ </span><span class="s2">p</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s3">/* c8 ignore stop */</span>
            <span class="s4">this</span><span class="s1">.</span><span class="s2">#parts</span><span class="s1">.</span><span class="s2">push</span><span class="s1">(</span><span class="s2">p</span><span class="s1">);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">toJSON</span><span class="s1">() {</span>
        <span class="s4">const </span><span class="s2">ret </span><span class="s1">= </span><span class="s4">this</span><span class="s1">.</span><span class="s2">type </span><span class="s1">=== </span><span class="s4">null</span>
            <span class="s1">? </span><span class="s4">this</span><span class="s1">.</span><span class="s2">#parts</span><span class="s1">.</span><span class="s2">slice</span><span class="s1">().</span><span class="s2">map</span><span class="s1">(</span><span class="s2">p </span><span class="s1">=&gt; (</span><span class="s4">typeof </span><span class="s2">p </span><span class="s1">=== </span><span class="s0">'string' </span><span class="s1">? </span><span class="s2">p </span><span class="s1">: </span><span class="s2">p</span><span class="s1">.</span><span class="s2">toJSON</span><span class="s1">()))</span>
            <span class="s1">: [</span><span class="s4">this</span><span class="s1">.</span><span class="s2">type</span><span class="s1">, </span><span class="s2">...</span><span class="s4">this</span><span class="s1">.</span><span class="s2">#parts</span><span class="s1">.</span><span class="s2">map</span><span class="s1">(</span><span class="s2">p </span><span class="s1">=&gt; </span><span class="s2">p</span><span class="s1">.</span><span class="s2">toJSON</span><span class="s1">())];</span>
        <span class="s4">if </span><span class="s1">(</span><span class="s4">this</span><span class="s1">.</span><span class="s2">isStart</span><span class="s1">() &amp;&amp; !</span><span class="s4">this</span><span class="s1">.</span><span class="s2">type</span><span class="s1">)</span>
            <span class="s2">ret</span><span class="s1">.</span><span class="s2">unshift</span><span class="s1">([]);</span>
        <span class="s4">if </span><span class="s1">(</span><span class="s4">this</span><span class="s1">.</span><span class="s2">isEnd</span><span class="s1">() &amp;&amp;</span>
            <span class="s1">(</span><span class="s4">this </span><span class="s1">=== </span><span class="s4">this</span><span class="s1">.</span><span class="s2">#root </span><span class="s1">||</span>
                <span class="s1">(</span><span class="s4">this</span><span class="s1">.</span><span class="s2">#root</span><span class="s1">.</span><span class="s2">#filledNegs </span><span class="s1">&amp;&amp; </span><span class="s4">this</span><span class="s1">.</span><span class="s2">#parent</span><span class="s1">?.</span><span class="s2">type </span><span class="s1">=== </span><span class="s0">'!'</span><span class="s1">))) {</span>
            <span class="s2">ret</span><span class="s1">.</span><span class="s2">push</span><span class="s1">({});</span>
        <span class="s1">}</span>
        <span class="s4">return </span><span class="s2">ret</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">isStart</span><span class="s1">() {</span>
        <span class="s4">if </span><span class="s1">(</span><span class="s4">this</span><span class="s1">.</span><span class="s2">#root </span><span class="s1">=== </span><span class="s4">this</span><span class="s1">)</span>
            <span class="s4">return true</span><span class="s1">;</span>
        <span class="s3">// if (this.type) return !!this.#parent?.isStart()</span>
        <span class="s4">if </span><span class="s1">(!</span><span class="s4">this</span><span class="s1">.</span><span class="s2">#parent</span><span class="s1">?.</span><span class="s2">isStart</span><span class="s1">())</span>
            <span class="s4">return false</span><span class="s1">;</span>
        <span class="s4">if </span><span class="s1">(</span><span class="s4">this</span><span class="s1">.</span><span class="s2">#parentIndex </span><span class="s1">=== </span><span class="s5">0</span><span class="s1">)</span>
            <span class="s4">return true</span><span class="s1">;</span>
        <span class="s3">// if everything AHEAD of this is a negation, then it's still the &quot;start&quot;</span>
        <span class="s4">const </span><span class="s2">p </span><span class="s1">= </span><span class="s4">this</span><span class="s1">.</span><span class="s2">#parent</span><span class="s1">;</span>
        <span class="s4">for </span><span class="s1">(</span><span class="s4">let </span><span class="s2">i </span><span class="s1">= </span><span class="s5">0</span><span class="s1">; </span><span class="s2">i </span><span class="s1">&lt; </span><span class="s4">this</span><span class="s1">.</span><span class="s2">#parentIndex</span><span class="s1">; </span><span class="s2">i</span><span class="s1">++) {</span>
            <span class="s4">const </span><span class="s2">pp </span><span class="s1">= </span><span class="s2">p</span><span class="s1">.</span><span class="s2">#parts</span><span class="s1">[</span><span class="s2">i</span><span class="s1">];</span>
            <span class="s4">if </span><span class="s1">(!(</span><span class="s2">pp </span><span class="s4">instanceof </span><span class="s2">AST </span><span class="s1">&amp;&amp; </span><span class="s2">pp</span><span class="s1">.</span><span class="s2">type </span><span class="s1">=== </span><span class="s0">'!'</span><span class="s1">)) {</span>
                <span class="s4">return false</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s4">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">isEnd</span><span class="s1">() {</span>
        <span class="s4">if </span><span class="s1">(</span><span class="s4">this</span><span class="s1">.</span><span class="s2">#root </span><span class="s1">=== </span><span class="s4">this</span><span class="s1">)</span>
            <span class="s4">return true</span><span class="s1">;</span>
        <span class="s4">if </span><span class="s1">(</span><span class="s4">this</span><span class="s1">.</span><span class="s2">#parent</span><span class="s1">?.</span><span class="s2">type </span><span class="s1">=== </span><span class="s0">'!'</span><span class="s1">)</span>
            <span class="s4">return true</span><span class="s1">;</span>
        <span class="s4">if </span><span class="s1">(!</span><span class="s4">this</span><span class="s1">.</span><span class="s2">#parent</span><span class="s1">?.</span><span class="s2">isEnd</span><span class="s1">())</span>
            <span class="s4">return false</span><span class="s1">;</span>
        <span class="s4">if </span><span class="s1">(!</span><span class="s4">this</span><span class="s1">.</span><span class="s2">type</span><span class="s1">)</span>
            <span class="s4">return this</span><span class="s1">.</span><span class="s2">#parent</span><span class="s1">?.</span><span class="s2">isEnd</span><span class="s1">();</span>
        <span class="s3">// if not root, it'll always have a parent</span>
        <span class="s3">/* c8 ignore start */</span>
        <span class="s4">const </span><span class="s2">pl </span><span class="s1">= </span><span class="s4">this</span><span class="s1">.</span><span class="s2">#parent </span><span class="s1">? </span><span class="s4">this</span><span class="s1">.</span><span class="s2">#parent</span><span class="s1">.</span><span class="s2">#parts</span><span class="s1">.</span><span class="s2">length </span><span class="s1">: </span><span class="s5">0</span><span class="s1">;</span>
        <span class="s3">/* c8 ignore stop */</span>
        <span class="s4">return this</span><span class="s1">.</span><span class="s2">#parentIndex </span><span class="s1">=== </span><span class="s2">pl </span><span class="s1">- </span><span class="s5">1</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">copyIn</span><span class="s1">(</span><span class="s2">part</span><span class="s1">) {</span>
        <span class="s4">if </span><span class="s1">(</span><span class="s4">typeof </span><span class="s2">part </span><span class="s1">=== </span><span class="s0">'string'</span><span class="s1">)</span>
            <span class="s4">this</span><span class="s1">.</span><span class="s2">push</span><span class="s1">(</span><span class="s2">part</span><span class="s1">);</span>
        <span class="s4">else</span>
            <span class="s4">this</span><span class="s1">.</span><span class="s2">push</span><span class="s1">(</span><span class="s2">part</span><span class="s1">.</span><span class="s2">clone</span><span class="s1">(</span><span class="s4">this</span><span class="s1">));</span>
    <span class="s1">}</span>
    <span class="s2">clone</span><span class="s1">(</span><span class="s2">parent</span><span class="s1">) {</span>
        <span class="s4">const </span><span class="s2">c </span><span class="s1">= </span><span class="s4">new </span><span class="s2">AST</span><span class="s1">(</span><span class="s4">this</span><span class="s1">.</span><span class="s2">type</span><span class="s1">, </span><span class="s2">parent</span><span class="s1">);</span>
        <span class="s4">for </span><span class="s1">(</span><span class="s4">const </span><span class="s2">p of </span><span class="s4">this</span><span class="s1">.</span><span class="s2">#parts</span><span class="s1">) {</span>
            <span class="s2">c</span><span class="s1">.</span><span class="s2">copyIn</span><span class="s1">(</span><span class="s2">p</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s4">return </span><span class="s2">c</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s4">static </span><span class="s2">#parseAST</span><span class="s1">(</span><span class="s2">str</span><span class="s1">, </span><span class="s2">ast</span><span class="s1">, </span><span class="s2">pos</span><span class="s1">, </span><span class="s2">opt</span><span class="s1">) {</span>
        <span class="s4">let </span><span class="s2">escaping </span><span class="s1">= </span><span class="s4">false</span><span class="s1">;</span>
        <span class="s4">let </span><span class="s2">inBrace </span><span class="s1">= </span><span class="s4">false</span><span class="s1">;</span>
        <span class="s4">let </span><span class="s2">braceStart </span><span class="s1">= -</span><span class="s5">1</span><span class="s1">;</span>
        <span class="s4">let </span><span class="s2">braceNeg </span><span class="s1">= </span><span class="s4">false</span><span class="s1">;</span>
        <span class="s4">if </span><span class="s1">(</span><span class="s2">ast</span><span class="s1">.</span><span class="s2">type </span><span class="s1">=== </span><span class="s4">null</span><span class="s1">) {</span>
            <span class="s3">// outside of a extglob, append until we find a start</span>
            <span class="s4">let </span><span class="s2">i </span><span class="s1">= </span><span class="s2">pos</span><span class="s1">;</span>
            <span class="s4">let </span><span class="s2">acc </span><span class="s1">= </span><span class="s0">''</span><span class="s1">;</span>
            <span class="s4">while </span><span class="s1">(</span><span class="s2">i </span><span class="s1">&lt; </span><span class="s2">str</span><span class="s1">.</span><span class="s2">length</span><span class="s1">) {</span>
                <span class="s4">const </span><span class="s2">c </span><span class="s1">= </span><span class="s2">str</span><span class="s1">.</span><span class="s2">charAt</span><span class="s1">(</span><span class="s2">i</span><span class="s1">++);</span>
                <span class="s3">// still accumulate escapes at this point, but we do ignore</span>
                <span class="s3">// starts that are escaped</span>
                <span class="s4">if </span><span class="s1">(</span><span class="s2">escaping </span><span class="s1">|| </span><span class="s2">c </span><span class="s1">=== </span><span class="s0">'</span><span class="s4">\\</span><span class="s0">'</span><span class="s1">) {</span>
                    <span class="s2">escaping </span><span class="s1">= !</span><span class="s2">escaping</span><span class="s1">;</span>
                    <span class="s2">acc </span><span class="s1">+= </span><span class="s2">c</span><span class="s1">;</span>
                    <span class="s4">continue</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s4">if </span><span class="s1">(</span><span class="s2">inBrace</span><span class="s1">) {</span>
                    <span class="s4">if </span><span class="s1">(</span><span class="s2">i </span><span class="s1">=== </span><span class="s2">braceStart </span><span class="s1">+ </span><span class="s5">1</span><span class="s1">) {</span>
                        <span class="s4">if </span><span class="s1">(</span><span class="s2">c </span><span class="s1">=== </span><span class="s0">'^' </span><span class="s1">|| </span><span class="s2">c </span><span class="s1">=== </span><span class="s0">'!'</span><span class="s1">) {</span>
                            <span class="s2">braceNeg </span><span class="s1">= </span><span class="s4">true</span><span class="s1">;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                    <span class="s4">else if </span><span class="s1">(</span><span class="s2">c </span><span class="s1">=== </span><span class="s0">']' </span><span class="s1">&amp;&amp; !(</span><span class="s2">i </span><span class="s1">=== </span><span class="s2">braceStart </span><span class="s1">+ </span><span class="s5">2 </span><span class="s1">&amp;&amp; </span><span class="s2">braceNeg</span><span class="s1">)) {</span>
                        <span class="s2">inBrace </span><span class="s1">= </span><span class="s4">false</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s2">acc </span><span class="s1">+= </span><span class="s2">c</span><span class="s1">;</span>
                    <span class="s4">continue</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s4">else if </span><span class="s1">(</span><span class="s2">c </span><span class="s1">=== </span><span class="s0">'['</span><span class="s1">) {</span>
                    <span class="s2">inBrace </span><span class="s1">= </span><span class="s4">true</span><span class="s1">;</span>
                    <span class="s2">braceStart </span><span class="s1">= </span><span class="s2">i</span><span class="s1">;</span>
                    <span class="s2">braceNeg </span><span class="s1">= </span><span class="s4">false</span><span class="s1">;</span>
                    <span class="s2">acc </span><span class="s1">+= </span><span class="s2">c</span><span class="s1">;</span>
                    <span class="s4">continue</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s4">if </span><span class="s1">(!</span><span class="s2">opt</span><span class="s1">.</span><span class="s2">noext </span><span class="s1">&amp;&amp; </span><span class="s2">isExtglobType</span><span class="s1">(</span><span class="s2">c</span><span class="s1">) &amp;&amp; </span><span class="s2">str</span><span class="s1">.</span><span class="s2">charAt</span><span class="s1">(</span><span class="s2">i</span><span class="s1">) === </span><span class="s0">'('</span><span class="s1">) {</span>
                    <span class="s2">ast</span><span class="s1">.</span><span class="s2">push</span><span class="s1">(</span><span class="s2">acc</span><span class="s1">);</span>
                    <span class="s2">acc </span><span class="s1">= </span><span class="s0">''</span><span class="s1">;</span>
                    <span class="s4">const </span><span class="s2">ext </span><span class="s1">= </span><span class="s4">new </span><span class="s2">AST</span><span class="s1">(</span><span class="s2">c</span><span class="s1">, </span><span class="s2">ast</span><span class="s1">);</span>
                    <span class="s2">i </span><span class="s1">= </span><span class="s2">AST</span><span class="s1">.</span><span class="s2">#parseAST</span><span class="s1">(</span><span class="s2">str</span><span class="s1">, </span><span class="s2">ext</span><span class="s1">, </span><span class="s2">i</span><span class="s1">, </span><span class="s2">opt</span><span class="s1">);</span>
                    <span class="s2">ast</span><span class="s1">.</span><span class="s2">push</span><span class="s1">(</span><span class="s2">ext</span><span class="s1">);</span>
                    <span class="s4">continue</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">acc </span><span class="s1">+= </span><span class="s2">c</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">ast</span><span class="s1">.</span><span class="s2">push</span><span class="s1">(</span><span class="s2">acc</span><span class="s1">);</span>
            <span class="s4">return </span><span class="s2">i</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">// some kind of extglob, pos is at the (</span>
        <span class="s3">// find the next | or )</span>
        <span class="s4">let </span><span class="s2">i </span><span class="s1">= </span><span class="s2">pos </span><span class="s1">+ </span><span class="s5">1</span><span class="s1">;</span>
        <span class="s4">let </span><span class="s2">part </span><span class="s1">= </span><span class="s4">new </span><span class="s2">AST</span><span class="s1">(</span><span class="s4">null</span><span class="s1">, </span><span class="s2">ast</span><span class="s1">);</span>
        <span class="s4">const </span><span class="s2">parts </span><span class="s1">= [];</span>
        <span class="s4">let </span><span class="s2">acc </span><span class="s1">= </span><span class="s0">''</span><span class="s1">;</span>
        <span class="s4">while </span><span class="s1">(</span><span class="s2">i </span><span class="s1">&lt; </span><span class="s2">str</span><span class="s1">.</span><span class="s2">length</span><span class="s1">) {</span>
            <span class="s4">const </span><span class="s2">c </span><span class="s1">= </span><span class="s2">str</span><span class="s1">.</span><span class="s2">charAt</span><span class="s1">(</span><span class="s2">i</span><span class="s1">++);</span>
            <span class="s3">// still accumulate escapes at this point, but we do ignore</span>
            <span class="s3">// starts that are escaped</span>
            <span class="s4">if </span><span class="s1">(</span><span class="s2">escaping </span><span class="s1">|| </span><span class="s2">c </span><span class="s1">=== </span><span class="s0">'</span><span class="s4">\\</span><span class="s0">'</span><span class="s1">) {</span>
                <span class="s2">escaping </span><span class="s1">= !</span><span class="s2">escaping</span><span class="s1">;</span>
                <span class="s2">acc </span><span class="s1">+= </span><span class="s2">c</span><span class="s1">;</span>
                <span class="s4">continue</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s4">if </span><span class="s1">(</span><span class="s2">inBrace</span><span class="s1">) {</span>
                <span class="s4">if </span><span class="s1">(</span><span class="s2">i </span><span class="s1">=== </span><span class="s2">braceStart </span><span class="s1">+ </span><span class="s5">1</span><span class="s1">) {</span>
                    <span class="s4">if </span><span class="s1">(</span><span class="s2">c </span><span class="s1">=== </span><span class="s0">'^' </span><span class="s1">|| </span><span class="s2">c </span><span class="s1">=== </span><span class="s0">'!'</span><span class="s1">) {</span>
                        <span class="s2">braceNeg </span><span class="s1">= </span><span class="s4">true</span><span class="s1">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s4">else if </span><span class="s1">(</span><span class="s2">c </span><span class="s1">=== </span><span class="s0">']' </span><span class="s1">&amp;&amp; !(</span><span class="s2">i </span><span class="s1">=== </span><span class="s2">braceStart </span><span class="s1">+ </span><span class="s5">2 </span><span class="s1">&amp;&amp; </span><span class="s2">braceNeg</span><span class="s1">)) {</span>
                    <span class="s2">inBrace </span><span class="s1">= </span><span class="s4">false</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">acc </span><span class="s1">+= </span><span class="s2">c</span><span class="s1">;</span>
                <span class="s4">continue</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s4">else if </span><span class="s1">(</span><span class="s2">c </span><span class="s1">=== </span><span class="s0">'['</span><span class="s1">) {</span>
                <span class="s2">inBrace </span><span class="s1">= </span><span class="s4">true</span><span class="s1">;</span>
                <span class="s2">braceStart </span><span class="s1">= </span><span class="s2">i</span><span class="s1">;</span>
                <span class="s2">braceNeg </span><span class="s1">= </span><span class="s4">false</span><span class="s1">;</span>
                <span class="s2">acc </span><span class="s1">+= </span><span class="s2">c</span><span class="s1">;</span>
                <span class="s4">continue</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s4">if </span><span class="s1">(</span><span class="s2">isExtglobType</span><span class="s1">(</span><span class="s2">c</span><span class="s1">) &amp;&amp; </span><span class="s2">str</span><span class="s1">.</span><span class="s2">charAt</span><span class="s1">(</span><span class="s2">i</span><span class="s1">) === </span><span class="s0">'('</span><span class="s1">) {</span>
                <span class="s2">part</span><span class="s1">.</span><span class="s2">push</span><span class="s1">(</span><span class="s2">acc</span><span class="s1">);</span>
                <span class="s2">acc </span><span class="s1">= </span><span class="s0">''</span><span class="s1">;</span>
                <span class="s4">const </span><span class="s2">ext </span><span class="s1">= </span><span class="s4">new </span><span class="s2">AST</span><span class="s1">(</span><span class="s2">c</span><span class="s1">, </span><span class="s2">part</span><span class="s1">);</span>
                <span class="s2">part</span><span class="s1">.</span><span class="s2">push</span><span class="s1">(</span><span class="s2">ext</span><span class="s1">);</span>
                <span class="s2">i </span><span class="s1">= </span><span class="s2">AST</span><span class="s1">.</span><span class="s2">#parseAST</span><span class="s1">(</span><span class="s2">str</span><span class="s1">, </span><span class="s2">ext</span><span class="s1">, </span><span class="s2">i</span><span class="s1">, </span><span class="s2">opt</span><span class="s1">);</span>
                <span class="s4">continue</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s4">if </span><span class="s1">(</span><span class="s2">c </span><span class="s1">=== </span><span class="s0">'|'</span><span class="s1">) {</span>
                <span class="s2">part</span><span class="s1">.</span><span class="s2">push</span><span class="s1">(</span><span class="s2">acc</span><span class="s1">);</span>
                <span class="s2">acc </span><span class="s1">= </span><span class="s0">''</span><span class="s1">;</span>
                <span class="s2">parts</span><span class="s1">.</span><span class="s2">push</span><span class="s1">(</span><span class="s2">part</span><span class="s1">);</span>
                <span class="s2">part </span><span class="s1">= </span><span class="s4">new </span><span class="s2">AST</span><span class="s1">(</span><span class="s4">null</span><span class="s1">, </span><span class="s2">ast</span><span class="s1">);</span>
                <span class="s4">continue</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s4">if </span><span class="s1">(</span><span class="s2">c </span><span class="s1">=== </span><span class="s0">')'</span><span class="s1">) {</span>
                <span class="s4">if </span><span class="s1">(</span><span class="s2">acc </span><span class="s1">=== </span><span class="s0">'' </span><span class="s1">&amp;&amp; </span><span class="s2">ast</span><span class="s1">.</span><span class="s2">#parts</span><span class="s1">.</span><span class="s2">length </span><span class="s1">=== </span><span class="s5">0</span><span class="s1">) {</span>
                    <span class="s2">ast</span><span class="s1">.</span><span class="s2">#emptyExt </span><span class="s1">= </span><span class="s4">true</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">part</span><span class="s1">.</span><span class="s2">push</span><span class="s1">(</span><span class="s2">acc</span><span class="s1">);</span>
                <span class="s2">acc </span><span class="s1">= </span><span class="s0">''</span><span class="s1">;</span>
                <span class="s2">ast</span><span class="s1">.</span><span class="s2">push</span><span class="s1">(</span><span class="s2">...parts</span><span class="s1">, </span><span class="s2">part</span><span class="s1">);</span>
                <span class="s4">return </span><span class="s2">i</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">acc </span><span class="s1">+= </span><span class="s2">c</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">// unfinished extglob</span>
        <span class="s3">// if we got here, it was a malformed extglob! not an extglob, but</span>
        <span class="s3">// maybe something else in there.</span>
        <span class="s2">ast</span><span class="s1">.</span><span class="s2">type </span><span class="s1">= </span><span class="s4">null</span><span class="s1">;</span>
        <span class="s2">ast</span><span class="s1">.</span><span class="s2">#hasMagic </span><span class="s1">= </span><span class="s2">undefined</span><span class="s1">;</span>
        <span class="s2">ast</span><span class="s1">.</span><span class="s2">#parts </span><span class="s1">= [</span><span class="s2">str</span><span class="s1">.</span><span class="s2">substring</span><span class="s1">(</span><span class="s2">pos </span><span class="s1">- </span><span class="s5">1</span><span class="s1">)];</span>
        <span class="s4">return </span><span class="s2">i</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s4">static </span><span class="s2">fromGlob</span><span class="s1">(</span><span class="s2">pattern</span><span class="s1">, </span><span class="s2">options </span><span class="s1">= {}) {</span>
        <span class="s4">const </span><span class="s2">ast </span><span class="s1">= </span><span class="s4">new </span><span class="s2">AST</span><span class="s1">(</span><span class="s4">null</span><span class="s1">, </span><span class="s2">undefined</span><span class="s1">, </span><span class="s2">options</span><span class="s1">);</span>
        <span class="s2">AST</span><span class="s1">.</span><span class="s2">#parseAST</span><span class="s1">(</span><span class="s2">pattern</span><span class="s1">, </span><span class="s2">ast</span><span class="s1">, </span><span class="s5">0</span><span class="s1">, </span><span class="s2">options</span><span class="s1">);</span>
        <span class="s4">return </span><span class="s2">ast</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">// returns the regular expression if there's magic, or the unescaped</span>
    <span class="s3">// string if not.</span>
    <span class="s2">toMMPattern</span><span class="s1">() {</span>
        <span class="s3">// should only be called on root</span>
        <span class="s3">/* c8 ignore start */</span>
        <span class="s4">if </span><span class="s1">(</span><span class="s4">this </span><span class="s1">!== </span><span class="s4">this</span><span class="s1">.</span><span class="s2">#root</span><span class="s1">)</span>
            <span class="s4">return this</span><span class="s1">.</span><span class="s2">#root</span><span class="s1">.</span><span class="s2">toMMPattern</span><span class="s1">();</span>
        <span class="s3">/* c8 ignore stop */</span>
        <span class="s4">const </span><span class="s2">glob </span><span class="s1">= </span><span class="s4">this</span><span class="s1">.</span><span class="s2">toString</span><span class="s1">();</span>
        <span class="s4">const </span><span class="s1">[</span><span class="s2">re</span><span class="s1">, </span><span class="s2">body</span><span class="s1">, </span><span class="s2">hasMagic</span><span class="s1">, </span><span class="s2">uflag</span><span class="s1">] = </span><span class="s4">this</span><span class="s1">.</span><span class="s2">toRegExpSource</span><span class="s1">();</span>
        <span class="s3">// if we're in nocase mode, and not nocaseMagicOnly, then we do</span>
        <span class="s3">// still need a regular expression if we have to case-insensitively</span>
        <span class="s3">// match capital/lowercase characters.</span>
        <span class="s4">const </span><span class="s2">anyMagic </span><span class="s1">= </span><span class="s2">hasMagic </span><span class="s1">||</span>
            <span class="s4">this</span><span class="s1">.</span><span class="s2">#hasMagic </span><span class="s1">||</span>
            <span class="s1">(</span><span class="s4">this</span><span class="s1">.</span><span class="s2">#options</span><span class="s1">.</span><span class="s2">nocase </span><span class="s1">&amp;&amp;</span>
                <span class="s1">!</span><span class="s4">this</span><span class="s1">.</span><span class="s2">#options</span><span class="s1">.</span><span class="s2">nocaseMagicOnly </span><span class="s1">&amp;&amp;</span>
                <span class="s2">glob</span><span class="s1">.</span><span class="s2">toUpperCase</span><span class="s1">() !== </span><span class="s2">glob</span><span class="s1">.</span><span class="s2">toLowerCase</span><span class="s1">());</span>
        <span class="s4">if </span><span class="s1">(!</span><span class="s2">anyMagic</span><span class="s1">) {</span>
            <span class="s4">return </span><span class="s2">body</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s4">const </span><span class="s2">flags </span><span class="s1">= (</span><span class="s4">this</span><span class="s1">.</span><span class="s2">#options</span><span class="s1">.</span><span class="s2">nocase </span><span class="s1">? </span><span class="s0">'i' </span><span class="s1">: </span><span class="s0">''</span><span class="s1">) + (</span><span class="s2">uflag </span><span class="s1">? </span><span class="s0">'u' </span><span class="s1">: </span><span class="s0">''</span><span class="s1">);</span>
        <span class="s4">return </span><span class="s2">Object</span><span class="s1">.</span><span class="s2">assign</span><span class="s1">(</span><span class="s4">new </span><span class="s2">RegExp</span><span class="s1">(</span><span class="s0">`^</span><span class="s2">$</span><span class="s1">{</span><span class="s2">re</span><span class="s1">}</span><span class="s0">$`</span><span class="s1">, </span><span class="s2">flags</span><span class="s1">), {</span>
            <span class="s2">_src</span><span class="s1">: </span><span class="s2">re</span><span class="s1">,</span>
            <span class="s2">_glob</span><span class="s1">: </span><span class="s2">glob</span><span class="s1">,</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">get options</span><span class="s1">() {</span>
        <span class="s4">return this</span><span class="s1">.</span><span class="s2">#options</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">// returns the string match, the regexp source, whether there's magic</span>
    <span class="s3">// in the regexp (so a regular expression is required) and whether or</span>
    <span class="s3">// not the uflag is needed for the regular expression (for posix classes)</span>
    <span class="s3">// TODO: instead of injecting the start/end at this point, just return</span>
    <span class="s3">// the BODY of the regexp, along with the start/end portions suitable</span>
    <span class="s3">// for binding the start/end in either a joined full-path makeRe context</span>
    <span class="s3">// (where we bind to (^|/), or a standalone matchPart context (where</span>
    <span class="s3">// we bind to ^, and not /).  Otherwise slashes get duped!</span>
    <span class="s3">//</span>
    <span class="s3">// In part-matching mode, the start is:</span>
    <span class="s3">// - if not isStart: nothing</span>
    <span class="s3">// - if traversal possible, but not allowed: ^(?!\.\.?$)</span>
    <span class="s3">// - if dots allowed or not possible: ^</span>
    <span class="s3">// - if dots possible and not allowed: ^(?!\.)</span>
    <span class="s3">// end is:</span>
    <span class="s3">// - if not isEnd(): nothing</span>
    <span class="s3">// - else: $</span>
    <span class="s3">//</span>
    <span class="s3">// In full-path matching mode, we put the slash at the START of the</span>
    <span class="s3">// pattern, so start is:</span>
    <span class="s3">// - if first pattern: same as part-matching mode</span>
    <span class="s3">// - if not isStart(): nothing</span>
    <span class="s3">// - if traversal possible, but not allowed: /(?!\.\.?(?:$|/))</span>
    <span class="s3">// - if dots allowed or not possible: /</span>
    <span class="s3">// - if dots possible and not allowed: /(?!\.)</span>
    <span class="s3">// end is:</span>
    <span class="s3">// - if last pattern, same as part-matching mode</span>
    <span class="s3">// - else nothing</span>
    <span class="s3">//</span>
    <span class="s3">// Always put the (?:$|/) on negated tails, though, because that has to be</span>
    <span class="s3">// there to bind the end of the negated pattern portion, and it's easier to</span>
    <span class="s3">// just stick it in now rather than try to inject it later in the middle of</span>
    <span class="s3">// the pattern.</span>
    <span class="s3">//</span>
    <span class="s3">// We can just always return the same end, and leave it up to the caller</span>
    <span class="s3">// to know whether it's going to be used joined or in parts.</span>
    <span class="s3">// And, if the start is adjusted slightly, can do the same there:</span>
    <span class="s3">// - if not isStart: nothing</span>
    <span class="s3">// - if traversal possible, but not allowed: (?:/|^)(?!\.\.?$)</span>
    <span class="s3">// - if dots allowed or not possible: (?:/|^)</span>
    <span class="s3">// - if dots possible and not allowed: (?:/|^)(?!\.)</span>
    <span class="s3">//</span>
    <span class="s3">// But it's better to have a simpler binding without a conditional, for</span>
    <span class="s3">// performance, so probably better to return both start options.</span>
    <span class="s3">//</span>
    <span class="s3">// Then the caller just ignores the end if it's not the first pattern,</span>
    <span class="s3">// and the start always gets applied.</span>
    <span class="s3">//</span>
    <span class="s3">// But that's always going to be $ if it's the ending pattern, or nothing,</span>
    <span class="s3">// so the caller can just attach $ at the end of the pattern when building.</span>
    <span class="s3">//</span>
    <span class="s3">// So the todo is:</span>
    <span class="s3">// - better detect what kind of start is needed</span>
    <span class="s3">// - return both flavors of starting pattern</span>
    <span class="s3">// - attach $ at the end of the pattern when creating the actual RegExp</span>
    <span class="s3">//</span>
    <span class="s3">// Ah, but wait, no, that all only applies to the root when the first pattern</span>
    <span class="s3">// is not an extglob. If the first pattern IS an extglob, then we need all</span>
    <span class="s3">// that dot prevention biz to live in the extglob portions, because eg</span>
    <span class="s3">// +(*|.x*) can match .xy but not .yx.</span>
    <span class="s3">//</span>
    <span class="s3">// So, return the two flavors if it's #root and the first child is not an</span>
    <span class="s3">// AST, otherwise leave it to the child AST to handle it, and there,</span>
    <span class="s3">// use the (?:^|/) style of start binding.</span>
    <span class="s3">//</span>
    <span class="s3">// Even simplified further:</span>
    <span class="s3">// - Since the start for a join is eg /(?!\.) and the start for a part</span>
    <span class="s3">// is ^(?!\.), we can just prepend (?!\.) to the pattern (either root</span>
    <span class="s3">// or start or whatever) and prepend ^ or / at the Regexp construction.</span>
    <span class="s2">toRegExpSource</span><span class="s1">(</span><span class="s2">allowDot</span><span class="s1">) {</span>
        <span class="s4">const </span><span class="s2">dot </span><span class="s1">= </span><span class="s2">allowDot </span><span class="s1">?? !!</span><span class="s4">this</span><span class="s1">.</span><span class="s2">#options</span><span class="s1">.</span><span class="s2">dot</span><span class="s1">;</span>
        <span class="s4">if </span><span class="s1">(</span><span class="s4">this</span><span class="s1">.</span><span class="s2">#root </span><span class="s1">=== </span><span class="s4">this</span><span class="s1">)</span>
            <span class="s4">this</span><span class="s1">.</span><span class="s2">#fillNegs</span><span class="s1">();</span>
        <span class="s4">if </span><span class="s1">(!</span><span class="s4">this</span><span class="s1">.</span><span class="s2">type</span><span class="s1">) {</span>
            <span class="s4">const </span><span class="s2">noEmpty </span><span class="s1">= </span><span class="s4">this</span><span class="s1">.</span><span class="s2">isStart</span><span class="s1">() &amp;&amp; </span><span class="s4">this</span><span class="s1">.</span><span class="s2">isEnd</span><span class="s1">();</span>
            <span class="s4">const </span><span class="s2">src </span><span class="s1">= </span><span class="s4">this</span><span class="s1">.</span><span class="s2">#parts</span>
                <span class="s1">.</span><span class="s2">map</span><span class="s1">(</span><span class="s2">p </span><span class="s1">=&gt; {</span>
                <span class="s4">const </span><span class="s1">[</span><span class="s2">re</span><span class="s1">, </span><span class="s2">_</span><span class="s1">, </span><span class="s2">hasMagic</span><span class="s1">, </span><span class="s2">uflag</span><span class="s1">] = </span><span class="s4">typeof </span><span class="s2">p </span><span class="s1">=== </span><span class="s0">'string'</span>
                    <span class="s1">? </span><span class="s2">AST</span><span class="s1">.</span><span class="s2">#parseGlob</span><span class="s1">(</span><span class="s2">p</span><span class="s1">, </span><span class="s4">this</span><span class="s1">.</span><span class="s2">#hasMagic</span><span class="s1">, </span><span class="s2">noEmpty</span><span class="s1">)</span>
                    <span class="s1">: </span><span class="s2">p</span><span class="s1">.</span><span class="s2">toRegExpSource</span><span class="s1">(</span><span class="s2">allowDot</span><span class="s1">);</span>
                <span class="s4">this</span><span class="s1">.</span><span class="s2">#hasMagic </span><span class="s1">= </span><span class="s4">this</span><span class="s1">.</span><span class="s2">#hasMagic </span><span class="s1">|| </span><span class="s2">hasMagic</span><span class="s1">;</span>
                <span class="s4">this</span><span class="s1">.</span><span class="s2">#uflag </span><span class="s1">= </span><span class="s4">this</span><span class="s1">.</span><span class="s2">#uflag </span><span class="s1">|| </span><span class="s2">uflag</span><span class="s1">;</span>
                <span class="s4">return </span><span class="s2">re</span><span class="s1">;</span>
            <span class="s1">})</span>
                <span class="s1">.</span><span class="s2">join</span><span class="s1">(</span><span class="s0">''</span><span class="s1">);</span>
            <span class="s4">let </span><span class="s2">start </span><span class="s1">= </span><span class="s0">''</span><span class="s1">;</span>
            <span class="s4">if </span><span class="s1">(</span><span class="s4">this</span><span class="s1">.</span><span class="s2">isStart</span><span class="s1">()) {</span>
                <span class="s4">if </span><span class="s1">(</span><span class="s4">typeof this</span><span class="s1">.</span><span class="s2">#parts</span><span class="s1">[</span><span class="s5">0</span><span class="s1">] === </span><span class="s0">'string'</span><span class="s1">) {</span>
                    <span class="s3">// this is the string that will match the start of the pattern,</span>
                    <span class="s3">// so we need to protect against dots and such.</span>
                    <span class="s3">// '.' and '..' cannot match unless the pattern is that exactly,</span>
                    <span class="s3">// even if it starts with . or dot:true is set.</span>
                    <span class="s4">const </span><span class="s2">dotTravAllowed </span><span class="s1">= </span><span class="s4">this</span><span class="s1">.</span><span class="s2">#parts</span><span class="s1">.</span><span class="s2">length </span><span class="s1">=== </span><span class="s5">1 </span><span class="s1">&amp;&amp; </span><span class="s2">justDots</span><span class="s1">.</span><span class="s2">has</span><span class="s1">(</span><span class="s4">this</span><span class="s1">.</span><span class="s2">#parts</span><span class="s1">[</span><span class="s5">0</span><span class="s1">]);</span>
                    <span class="s4">if </span><span class="s1">(!</span><span class="s2">dotTravAllowed</span><span class="s1">) {</span>
                        <span class="s4">const </span><span class="s2">aps </span><span class="s1">= </span><span class="s2">addPatternStart</span><span class="s1">;</span>
                        <span class="s3">// check if we have a possibility of matching . or ..,</span>
                        <span class="s3">// and prevent that.</span>
                        <span class="s4">const </span><span class="s2">needNoTrav </span><span class="s1">= </span>
                        <span class="s3">// dots are allowed, and the pattern starts with [ or .</span>
                        <span class="s1">(</span><span class="s2">dot </span><span class="s1">&amp;&amp; </span><span class="s2">aps</span><span class="s1">.</span><span class="s2">has</span><span class="s1">(</span><span class="s2">src</span><span class="s1">.</span><span class="s2">charAt</span><span class="s1">(</span><span class="s5">0</span><span class="s1">))) ||</span>
                            <span class="s3">// the pattern starts with \., and then [ or .</span>
                            <span class="s1">(</span><span class="s2">src</span><span class="s1">.</span><span class="s2">startsWith</span><span class="s1">(</span><span class="s0">'</span><span class="s4">\\</span><span class="s0">.'</span><span class="s1">) &amp;&amp; </span><span class="s2">aps</span><span class="s1">.</span><span class="s2">has</span><span class="s1">(</span><span class="s2">src</span><span class="s1">.</span><span class="s2">charAt</span><span class="s1">(</span><span class="s5">2</span><span class="s1">))) ||</span>
                            <span class="s3">// the pattern starts with \.\., and then [ or .</span>
                            <span class="s1">(</span><span class="s2">src</span><span class="s1">.</span><span class="s2">startsWith</span><span class="s1">(</span><span class="s0">'</span><span class="s4">\\</span><span class="s0">.</span><span class="s4">\\</span><span class="s0">.'</span><span class="s1">) &amp;&amp; </span><span class="s2">aps</span><span class="s1">.</span><span class="s2">has</span><span class="s1">(</span><span class="s2">src</span><span class="s1">.</span><span class="s2">charAt</span><span class="s1">(</span><span class="s5">4</span><span class="s1">)));</span>
                        <span class="s3">// no need to prevent dots if it can't match a dot, or if a</span>
                        <span class="s3">// sub-pattern will be preventing it anyway.</span>
                        <span class="s4">const </span><span class="s2">needNoDot </span><span class="s1">= !</span><span class="s2">dot </span><span class="s1">&amp;&amp; !</span><span class="s2">allowDot </span><span class="s1">&amp;&amp; </span><span class="s2">aps</span><span class="s1">.</span><span class="s2">has</span><span class="s1">(</span><span class="s2">src</span><span class="s1">.</span><span class="s2">charAt</span><span class="s1">(</span><span class="s5">0</span><span class="s1">));</span>
                        <span class="s2">start </span><span class="s1">= </span><span class="s2">needNoTrav </span><span class="s1">? </span><span class="s2">startNoTraversal </span><span class="s1">: </span><span class="s2">needNoDot </span><span class="s1">? </span><span class="s2">startNoDot </span><span class="s1">: </span><span class="s0">''</span><span class="s1">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s3">// append the &quot;end of path portion&quot; pattern to negation tails</span>
            <span class="s4">let </span><span class="s2">end </span><span class="s1">= </span><span class="s0">''</span><span class="s1">;</span>
            <span class="s4">if </span><span class="s1">(</span><span class="s4">this</span><span class="s1">.</span><span class="s2">isEnd</span><span class="s1">() &amp;&amp;</span>
                <span class="s4">this</span><span class="s1">.</span><span class="s2">#root</span><span class="s1">.</span><span class="s2">#filledNegs </span><span class="s1">&amp;&amp;</span>
                <span class="s4">this</span><span class="s1">.</span><span class="s2">#parent</span><span class="s1">?.</span><span class="s2">type </span><span class="s1">=== </span><span class="s0">'!'</span><span class="s1">) {</span>
                <span class="s2">end </span><span class="s1">= </span><span class="s0">'(?:$|</span><span class="s4">\\</span><span class="s0">/)'</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s4">const </span><span class="s2">final </span><span class="s1">= </span><span class="s2">start </span><span class="s1">+ </span><span class="s2">src </span><span class="s1">+ </span><span class="s2">end</span><span class="s1">;</span>
            <span class="s4">return </span><span class="s1">[</span>
                <span class="s2">final</span><span class="s1">,</span>
                <span class="s1">(</span><span class="s5">0</span><span class="s1">, </span><span class="s2">unescape_js_1</span><span class="s1">.</span><span class="s2">unescape</span><span class="s1">)(</span><span class="s2">src</span><span class="s1">),</span>
                <span class="s1">(</span><span class="s4">this</span><span class="s1">.</span><span class="s2">#hasMagic </span><span class="s1">= !!</span><span class="s4">this</span><span class="s1">.</span><span class="s2">#hasMagic</span><span class="s1">),</span>
                <span class="s4">this</span><span class="s1">.</span><span class="s2">#uflag</span><span class="s1">,</span>
            <span class="s1">];</span>
        <span class="s1">}</span>
        <span class="s3">// We need to calculate the body *twice* if it's a repeat pattern</span>
        <span class="s3">// at the start, once in nodot mode, then again in dot mode, so a</span>
        <span class="s3">// pattern like *(?) can match 'x.y'</span>
        <span class="s4">const </span><span class="s2">repeated </span><span class="s1">= </span><span class="s4">this</span><span class="s1">.</span><span class="s2">type </span><span class="s1">=== </span><span class="s0">'*' </span><span class="s1">|| </span><span class="s4">this</span><span class="s1">.</span><span class="s2">type </span><span class="s1">=== </span><span class="s0">'+'</span><span class="s1">;</span>
        <span class="s3">// some kind of extglob</span>
        <span class="s4">const </span><span class="s2">start </span><span class="s1">= </span><span class="s4">this</span><span class="s1">.</span><span class="s2">type </span><span class="s1">=== </span><span class="s0">'!' </span><span class="s1">? </span><span class="s0">'(?:(?!(?:' </span><span class="s1">: </span><span class="s0">'(?:'</span><span class="s1">;</span>
        <span class="s4">let </span><span class="s2">body </span><span class="s1">= </span><span class="s4">this</span><span class="s1">.</span><span class="s2">#partsToRegExp</span><span class="s1">(</span><span class="s2">dot</span><span class="s1">);</span>
        <span class="s4">if </span><span class="s1">(</span><span class="s4">this</span><span class="s1">.</span><span class="s2">isStart</span><span class="s1">() &amp;&amp; </span><span class="s4">this</span><span class="s1">.</span><span class="s2">isEnd</span><span class="s1">() &amp;&amp; !</span><span class="s2">body </span><span class="s1">&amp;&amp; </span><span class="s4">this</span><span class="s1">.</span><span class="s2">type </span><span class="s1">!== </span><span class="s0">'!'</span><span class="s1">) {</span>
            <span class="s3">// invalid extglob, has to at least be *something* present, if it's</span>
            <span class="s3">// the entire path portion.</span>
            <span class="s4">const </span><span class="s2">s </span><span class="s1">= </span><span class="s4">this</span><span class="s1">.</span><span class="s2">toString</span><span class="s1">();</span>
            <span class="s4">this</span><span class="s1">.</span><span class="s2">#parts </span><span class="s1">= [</span><span class="s2">s</span><span class="s1">];</span>
            <span class="s4">this</span><span class="s1">.</span><span class="s2">type </span><span class="s1">= </span><span class="s4">null</span><span class="s1">;</span>
            <span class="s4">this</span><span class="s1">.</span><span class="s2">#hasMagic </span><span class="s1">= </span><span class="s2">undefined</span><span class="s1">;</span>
            <span class="s4">return </span><span class="s1">[</span><span class="s2">s</span><span class="s1">, (</span><span class="s5">0</span><span class="s1">, </span><span class="s2">unescape_js_1</span><span class="s1">.</span><span class="s2">unescape</span><span class="s1">)(</span><span class="s4">this</span><span class="s1">.</span><span class="s2">toString</span><span class="s1">()), </span><span class="s4">false</span><span class="s1">, </span><span class="s4">false</span><span class="s1">];</span>
        <span class="s1">}</span>
        <span class="s3">// XXX abstract out this map method</span>
        <span class="s4">let </span><span class="s2">bodyDotAllowed </span><span class="s1">= !</span><span class="s2">repeated </span><span class="s1">|| </span><span class="s2">allowDot </span><span class="s1">|| </span><span class="s2">dot </span><span class="s1">|| !</span><span class="s2">startNoDot</span>
            <span class="s1">? </span><span class="s0">''</span>
            <span class="s1">: </span><span class="s4">this</span><span class="s1">.</span><span class="s2">#partsToRegExp</span><span class="s1">(</span><span class="s4">true</span><span class="s1">);</span>
        <span class="s4">if </span><span class="s1">(</span><span class="s2">bodyDotAllowed </span><span class="s1">=== </span><span class="s2">body</span><span class="s1">) {</span>
            <span class="s2">bodyDotAllowed </span><span class="s1">= </span><span class="s0">''</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s4">if </span><span class="s1">(</span><span class="s2">bodyDotAllowed</span><span class="s1">) {</span>
            <span class="s2">body </span><span class="s1">= </span><span class="s0">`(?:</span><span class="s2">$</span><span class="s1">{</span><span class="s2">body</span><span class="s1">}</span><span class="s0">)(?:</span><span class="s2">$</span><span class="s1">{</span><span class="s2">bodyDotAllowed</span><span class="s1">}</span><span class="s0">)*?`</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">// an empty !() is exactly equivalent to a starNoEmpty</span>
        <span class="s4">let </span><span class="s2">final </span><span class="s1">= </span><span class="s0">''</span><span class="s1">;</span>
        <span class="s4">if </span><span class="s1">(</span><span class="s4">this</span><span class="s1">.</span><span class="s2">type </span><span class="s1">=== </span><span class="s0">'!' </span><span class="s1">&amp;&amp; </span><span class="s4">this</span><span class="s1">.</span><span class="s2">#emptyExt</span><span class="s1">) {</span>
            <span class="s2">final </span><span class="s1">= (</span><span class="s4">this</span><span class="s1">.</span><span class="s2">isStart</span><span class="s1">() &amp;&amp; !</span><span class="s2">dot </span><span class="s1">? </span><span class="s2">startNoDot </span><span class="s1">: </span><span class="s0">''</span><span class="s1">) + </span><span class="s2">starNoEmpty</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s4">else </span><span class="s1">{</span>
            <span class="s4">const </span><span class="s2">close </span><span class="s1">= </span><span class="s4">this</span><span class="s1">.</span><span class="s2">type </span><span class="s1">=== </span><span class="s0">'!'</span>
                <span class="s1">? </span><span class="s3">// !() must match something,but !(x) can match ''</span>
                    <span class="s0">'))' </span><span class="s1">+</span>
                        <span class="s1">(</span><span class="s4">this</span><span class="s1">.</span><span class="s2">isStart</span><span class="s1">() &amp;&amp; !</span><span class="s2">dot </span><span class="s1">&amp;&amp; !</span><span class="s2">allowDot </span><span class="s1">? </span><span class="s2">startNoDot </span><span class="s1">: </span><span class="s0">''</span><span class="s1">) +</span>
                        <span class="s2">star </span><span class="s1">+</span>
                        <span class="s0">')'</span>
                <span class="s1">: </span><span class="s4">this</span><span class="s1">.</span><span class="s2">type </span><span class="s1">=== </span><span class="s0">'@'</span>
                    <span class="s1">? </span><span class="s0">')'</span>
                    <span class="s1">: </span><span class="s4">this</span><span class="s1">.</span><span class="s2">type </span><span class="s1">=== </span><span class="s0">'?'</span>
                        <span class="s1">? </span><span class="s0">')?'</span>
                        <span class="s1">: </span><span class="s4">this</span><span class="s1">.</span><span class="s2">type </span><span class="s1">=== </span><span class="s0">'+' </span><span class="s1">&amp;&amp; </span><span class="s2">bodyDotAllowed</span>
                            <span class="s1">? </span><span class="s0">')'</span>
                            <span class="s1">: </span><span class="s4">this</span><span class="s1">.</span><span class="s2">type </span><span class="s1">=== </span><span class="s0">'*' </span><span class="s1">&amp;&amp; </span><span class="s2">bodyDotAllowed</span>
                                <span class="s1">? </span><span class="s0">`)?`</span>
                                <span class="s1">: </span><span class="s0">`)</span><span class="s2">$</span><span class="s1">{</span><span class="s4">this</span><span class="s1">.</span><span class="s2">type</span><span class="s1">}</span><span class="s0">`</span><span class="s1">;</span>
            <span class="s2">final </span><span class="s1">= </span><span class="s2">start </span><span class="s1">+ </span><span class="s2">body </span><span class="s1">+ </span><span class="s2">close</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s4">return </span><span class="s1">[</span>
            <span class="s2">final</span><span class="s1">,</span>
            <span class="s1">(</span><span class="s5">0</span><span class="s1">, </span><span class="s2">unescape_js_1</span><span class="s1">.</span><span class="s2">unescape</span><span class="s1">)(</span><span class="s2">body</span><span class="s1">),</span>
            <span class="s1">(</span><span class="s4">this</span><span class="s1">.</span><span class="s2">#hasMagic </span><span class="s1">= !!</span><span class="s4">this</span><span class="s1">.</span><span class="s2">#hasMagic</span><span class="s1">),</span>
            <span class="s4">this</span><span class="s1">.</span><span class="s2">#uflag</span><span class="s1">,</span>
        <span class="s1">];</span>
    <span class="s1">}</span>
    <span class="s2">#partsToRegExp</span><span class="s1">(</span><span class="s2">dot</span><span class="s1">) {</span>
        <span class="s4">return this</span><span class="s1">.</span><span class="s2">#parts</span>
            <span class="s1">.</span><span class="s2">map</span><span class="s1">(</span><span class="s2">p </span><span class="s1">=&gt; {</span>
            <span class="s3">// extglob ASTs should only contain parent ASTs</span>
            <span class="s3">/* c8 ignore start */</span>
            <span class="s4">if </span><span class="s1">(</span><span class="s4">typeof </span><span class="s2">p </span><span class="s1">=== </span><span class="s0">'string'</span><span class="s1">) {</span>
                <span class="s4">throw new </span><span class="s2">Error</span><span class="s1">(</span><span class="s0">'string type in extglob ast??'</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s3">/* c8 ignore stop */</span>
            <span class="s3">// can ignore hasMagic, because extglobs are already always magic</span>
            <span class="s4">const </span><span class="s1">[</span><span class="s2">re</span><span class="s1">, </span><span class="s2">_</span><span class="s1">, </span><span class="s2">_hasMagic</span><span class="s1">, </span><span class="s2">uflag</span><span class="s1">] = </span><span class="s2">p</span><span class="s1">.</span><span class="s2">toRegExpSource</span><span class="s1">(</span><span class="s2">dot</span><span class="s1">);</span>
            <span class="s4">this</span><span class="s1">.</span><span class="s2">#uflag </span><span class="s1">= </span><span class="s4">this</span><span class="s1">.</span><span class="s2">#uflag </span><span class="s1">|| </span><span class="s2">uflag</span><span class="s1">;</span>
            <span class="s4">return </span><span class="s2">re</span><span class="s1">;</span>
        <span class="s1">})</span>
            <span class="s1">.</span><span class="s2">filter</span><span class="s1">(</span><span class="s2">p </span><span class="s1">=&gt; !(</span><span class="s4">this</span><span class="s1">.</span><span class="s2">isStart</span><span class="s1">() &amp;&amp; </span><span class="s4">this</span><span class="s1">.</span><span class="s2">isEnd</span><span class="s1">()) || !!</span><span class="s2">p</span><span class="s1">)</span>
            <span class="s1">.</span><span class="s2">join</span><span class="s1">(</span><span class="s0">'|'</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s4">static </span><span class="s2">#parseGlob</span><span class="s1">(</span><span class="s2">glob</span><span class="s1">, </span><span class="s2">hasMagic</span><span class="s1">, </span><span class="s2">noEmpty </span><span class="s1">= </span><span class="s4">false</span><span class="s1">) {</span>
        <span class="s4">let </span><span class="s2">escaping </span><span class="s1">= </span><span class="s4">false</span><span class="s1">;</span>
        <span class="s4">let </span><span class="s2">re </span><span class="s1">= </span><span class="s0">''</span><span class="s1">;</span>
        <span class="s4">let </span><span class="s2">uflag </span><span class="s1">= </span><span class="s4">false</span><span class="s1">;</span>
        <span class="s4">for </span><span class="s1">(</span><span class="s4">let </span><span class="s2">i </span><span class="s1">= </span><span class="s5">0</span><span class="s1">; </span><span class="s2">i </span><span class="s1">&lt; </span><span class="s2">glob</span><span class="s1">.</span><span class="s2">length</span><span class="s1">; </span><span class="s2">i</span><span class="s1">++) {</span>
            <span class="s4">const </span><span class="s2">c </span><span class="s1">= </span><span class="s2">glob</span><span class="s1">.</span><span class="s2">charAt</span><span class="s1">(</span><span class="s2">i</span><span class="s1">);</span>
            <span class="s4">if </span><span class="s1">(</span><span class="s2">escaping</span><span class="s1">) {</span>
                <span class="s2">escaping </span><span class="s1">= </span><span class="s4">false</span><span class="s1">;</span>
                <span class="s2">re </span><span class="s1">+= (</span><span class="s2">reSpecials</span><span class="s1">.</span><span class="s2">has</span><span class="s1">(</span><span class="s2">c</span><span class="s1">) ? </span><span class="s0">'</span><span class="s4">\\</span><span class="s0">' </span><span class="s1">: </span><span class="s0">''</span><span class="s1">) + </span><span class="s2">c</span><span class="s1">;</span>
                <span class="s4">continue</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s4">if </span><span class="s1">(</span><span class="s2">c </span><span class="s1">=== </span><span class="s0">'</span><span class="s4">\\</span><span class="s0">'</span><span class="s1">) {</span>
                <span class="s4">if </span><span class="s1">(</span><span class="s2">i </span><span class="s1">=== </span><span class="s2">glob</span><span class="s1">.</span><span class="s2">length </span><span class="s1">- </span><span class="s5">1</span><span class="s1">) {</span>
                    <span class="s2">re </span><span class="s1">+= </span><span class="s0">'</span><span class="s4">\\\\</span><span class="s0">'</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s4">else </span><span class="s1">{</span>
                    <span class="s2">escaping </span><span class="s1">= </span><span class="s4">true</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s4">continue</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s4">if </span><span class="s1">(</span><span class="s2">c </span><span class="s1">=== </span><span class="s0">'['</span><span class="s1">) {</span>
                <span class="s4">const </span><span class="s1">[</span><span class="s2">src</span><span class="s1">, </span><span class="s2">needUflag</span><span class="s1">, </span><span class="s2">consumed</span><span class="s1">, </span><span class="s2">magic</span><span class="s1">] = (</span><span class="s5">0</span><span class="s1">, </span><span class="s2">brace_expressions_js_1</span><span class="s1">.</span><span class="s2">parseClass</span><span class="s1">)(</span><span class="s2">glob</span><span class="s1">, </span><span class="s2">i</span><span class="s1">);</span>
                <span class="s4">if </span><span class="s1">(</span><span class="s2">consumed</span><span class="s1">) {</span>
                    <span class="s2">re </span><span class="s1">+= </span><span class="s2">src</span><span class="s1">;</span>
                    <span class="s2">uflag </span><span class="s1">= </span><span class="s2">uflag </span><span class="s1">|| </span><span class="s2">needUflag</span><span class="s1">;</span>
                    <span class="s2">i </span><span class="s1">+= </span><span class="s2">consumed </span><span class="s1">- </span><span class="s5">1</span><span class="s1">;</span>
                    <span class="s2">hasMagic </span><span class="s1">= </span><span class="s2">hasMagic </span><span class="s1">|| </span><span class="s2">magic</span><span class="s1">;</span>
                    <span class="s4">continue</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s4">if </span><span class="s1">(</span><span class="s2">c </span><span class="s1">=== </span><span class="s0">'*'</span><span class="s1">) {</span>
                <span class="s4">if </span><span class="s1">(</span><span class="s2">noEmpty </span><span class="s1">&amp;&amp; </span><span class="s2">glob </span><span class="s1">=== </span><span class="s0">'*'</span><span class="s1">)</span>
                    <span class="s2">re </span><span class="s1">+= </span><span class="s2">starNoEmpty</span><span class="s1">;</span>
                <span class="s4">else</span>
                    <span class="s2">re </span><span class="s1">+= </span><span class="s2">star</span><span class="s1">;</span>
                <span class="s2">hasMagic </span><span class="s1">= </span><span class="s4">true</span><span class="s1">;</span>
                <span class="s4">continue</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s4">if </span><span class="s1">(</span><span class="s2">c </span><span class="s1">=== </span><span class="s0">'?'</span><span class="s1">) {</span>
                <span class="s2">re </span><span class="s1">+= </span><span class="s2">qmark</span><span class="s1">;</span>
                <span class="s2">hasMagic </span><span class="s1">= </span><span class="s4">true</span><span class="s1">;</span>
                <span class="s4">continue</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">re </span><span class="s1">+= </span><span class="s2">regExpEscape</span><span class="s1">(</span><span class="s2">c</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s4">return </span><span class="s1">[</span><span class="s2">re</span><span class="s1">, (</span><span class="s5">0</span><span class="s1">, </span><span class="s2">unescape_js_1</span><span class="s1">.</span><span class="s2">unescape</span><span class="s1">)(</span><span class="s2">glob</span><span class="s1">), !!</span><span class="s2">hasMagic</span><span class="s1">, </span><span class="s2">uflag</span><span class="s1">];</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">exports</span><span class="s1">.</span><span class="s2">AST </span><span class="s1">= </span><span class="s2">AST</span><span class="s1">;</span>
<span class="s3">//# sourceMappingURL=ast.js.map</span></pre>
</body>
</html>