<html>
<head>
<title>ast.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
ast.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;ast.js&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceRoot&quot;</span><span class="s0">:</span><span class="s1">&quot;&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../src/ast.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;// parse a single path portion</span><span class="s3">\n\n</span><span class="s1">import { parseClass } from './brace-expressions.js'</span><span class="s3">\n</span><span class="s1">import { MinimatchOptions, MMRegExp } from './index.js'</span><span class="s3">\n</span><span class="s1">import { unescape } from './unescape.js'</span><span class="s3">\n\n</span><span class="s1">// classes [] are handled by the parseClass method</span><span class="s3">\n</span><span class="s1">// for positive extglobs, we sub-parse the contents, and combine,</span><span class="s3">\n</span><span class="s1">// with the appropriate regexp close.</span><span class="s3">\n</span><span class="s1">// for negative extglobs, we sub-parse the contents, but then</span><span class="s3">\n</span><span class="s1">// have to include the rest of the pattern, then the parent, etc.,</span><span class="s3">\n</span><span class="s1">// as the thing that cannot be because RegExp negative lookaheads</span><span class="s3">\n</span><span class="s1">// are different from globs.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// So for example:</span><span class="s3">\n</span><span class="s1">// a@(i|w!(x|y)z|j)b =&gt; ^a(i|w((!?(x|y)zb).*)z|j)b$</span><span class="s3">\n</span><span class="s1">//   1   2 3   4 5 6      1   2    3   46      5 6</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// Assembling the extglob requires not just the negated patterns themselves,</span><span class="s3">\n</span><span class="s1">// but also anything following the negative patterns up to the boundary</span><span class="s3">\n</span><span class="s1">// of the current pattern, plus anything following in the parent pattern.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// So, first, we parse the string into an AST of extglobs, without turning</span><span class="s3">\n</span><span class="s1">// anything into regexps yet.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// ['a', {@ [['i'], ['w', {!['x', 'y']}, 'z'], ['j']]}, 'b']</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// Then, for all the negative extglobs, we append whatever comes after in</span><span class="s3">\n</span><span class="s1">// each parent as their tail</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// ['a', {@ [['i'], ['w', {!['x', 'y'], 'z', 'b'}, 'z'], ['j']]}, 'b']</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// Lastly, we turn each of these pieces into a regexp, and join</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">//                                 v----- .* because there's more following,</span><span class="s3">\n</span><span class="s1">//                                 v    v  otherwise, .+ because it must be</span><span class="s3">\n</span><span class="s1">//                                 v    v  *something* there.</span><span class="s3">\n</span><span class="s1">// ['^a', {@ ['i', 'w(?:(!?(?:x|y).*zb$).*)z', 'j' ]}, 'b$']</span><span class="s3">\n</span><span class="s1">//   copy what follows into here--^^^^^</span><span class="s3">\n</span><span class="s1">// ['^a', '(?:i|w(?:(?!(?:x|y).*zb$).*)z|j)', 'b$']</span><span class="s3">\n</span><span class="s1">// ['^a(?:i|w(?:(?!(?:x|y).*zb$).*)z|j)b$']</span><span class="s3">\n\n</span><span class="s1">export type ExtglobType = '!' | '?' | '+' | '*' | '@'</span><span class="s3">\n</span><span class="s1">const types = new Set&lt;ExtglobType&gt;(['!', '?', '+', '*', '@'])</span><span class="s3">\n</span><span class="s1">const isExtglobType = (c: string): c is ExtglobType =&gt;</span><span class="s3">\n  </span><span class="s1">types.has(c as ExtglobType)</span><span class="s3">\n\n</span><span class="s1">// Patterns that get prepended to bind to the start of either the</span><span class="s3">\n</span><span class="s1">// entire string, or just a single path portion, to prevent dots</span><span class="s3">\n</span><span class="s1">// and/or traversal patterns, when needed.</span><span class="s3">\n</span><span class="s1">// Exts don't need the ^ or / bit, because the root binds that already.</span><span class="s3">\n</span><span class="s1">const startNoTraversal = '(?!(?:^|/)</span><span class="s3">\\\\</span><span class="s1">.</span><span class="s3">\\\\</span><span class="s1">.?(?:$|/))'</span><span class="s3">\n</span><span class="s1">const startNoDot = '(?!</span><span class="s3">\\\\</span><span class="s1">.)'</span><span class="s3">\n\n</span><span class="s1">// characters that indicate a start of pattern needs the </span><span class="s3">\&quot;</span><span class="s1">no dots</span><span class="s3">\&quot; </span><span class="s1">bit,</span><span class="s3">\n</span><span class="s1">// because a dot *might* be matched. ( is not in the list, because in</span><span class="s3">\n</span><span class="s1">// the case of a child extglob, it will handle the prevention itself.</span><span class="s3">\n</span><span class="s1">const addPatternStart = new Set(['[', '.'])</span><span class="s3">\n</span><span class="s1">// cases where traversal is A-OK, no dot prevention needed</span><span class="s3">\n</span><span class="s1">const justDots = new Set(['..', '.'])</span><span class="s3">\n</span><span class="s1">const reSpecials = new Set('().*{}+?[]^$</span><span class="s3">\\\\</span><span class="s1">!')</span><span class="s3">\n</span><span class="s1">const regExpEscape = (s: string) =&gt;</span><span class="s3">\n  </span><span class="s1">s.replace(/[-[</span><span class="s3">\\</span><span class="s1">]{}()*+?.,</span><span class="s3">\\\\</span><span class="s1">^$|#</span><span class="s3">\\</span><span class="s1">s]/g, '</span><span class="s3">\\\\</span><span class="s1">$&amp;')</span><span class="s3">\n\n</span><span class="s1">// any single thing other than /</span><span class="s3">\n</span><span class="s1">const qmark = '[^/]'</span><span class="s3">\n\n</span><span class="s1">// * =&gt; any number of characters</span><span class="s3">\n</span><span class="s1">const star = qmark + '*?'</span><span class="s3">\n</span><span class="s1">// use + when we need to ensure that *something* matches, because the * is</span><span class="s3">\n</span><span class="s1">// the only thing in the path portion.</span><span class="s3">\n</span><span class="s1">const starNoEmpty = qmark + '+?'</span><span class="s3">\n\n</span><span class="s1">// remove the </span><span class="s3">\\ </span><span class="s1">chars that we added if we end up doing a nonmagic compare</span><span class="s3">\n</span><span class="s1">// const deslash = (s: string) =&gt; s.replace(/</span><span class="s3">\\\\</span><span class="s1">(.)/g, '$1')</span><span class="s3">\n\n</span><span class="s1">export class AST {</span><span class="s3">\n  </span><span class="s1">type: ExtglobType | null</span><span class="s3">\n  </span><span class="s1">readonly #root: AST</span><span class="s3">\n\n  </span><span class="s1">#hasMagic?: boolean</span><span class="s3">\n  </span><span class="s1">#uflag: boolean = false</span><span class="s3">\n  </span><span class="s1">#parts: (string | AST)[] = []</span><span class="s3">\n  </span><span class="s1">readonly #parent?: AST</span><span class="s3">\n  </span><span class="s1">readonly #parentIndex: number</span><span class="s3">\n  </span><span class="s1">#negs: AST[]</span><span class="s3">\n  </span><span class="s1">#filledNegs: boolean = false</span><span class="s3">\n  </span><span class="s1">#options: MinimatchOptions</span><span class="s3">\n  </span><span class="s1">#toString?: string</span><span class="s3">\n  </span><span class="s1">// set to true if it's an extglob with no children</span><span class="s3">\n  </span><span class="s1">// (which really means one child of '')</span><span class="s3">\n  </span><span class="s1">#emptyExt: boolean = false</span><span class="s3">\n\n  </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">type: ExtglobType | null,</span><span class="s3">\n    </span><span class="s1">parent?: AST,</span><span class="s3">\n    </span><span class="s1">options: MinimatchOptions = {}</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">this.type = type</span><span class="s3">\n    </span><span class="s1">// extglobs are inherently magical</span><span class="s3">\n    </span><span class="s1">if (type) this.#hasMagic = true</span><span class="s3">\n    </span><span class="s1">this.#parent = parent</span><span class="s3">\n    </span><span class="s1">this.#root = this.#parent ? this.#parent.#root : this</span><span class="s3">\n    </span><span class="s1">this.#options = this.#root === this ? options : this.#root.#options</span><span class="s3">\n    </span><span class="s1">this.#negs = this.#root === this ? [] : this.#root.#negs</span><span class="s3">\n    </span><span class="s1">if (type === '!' &amp;&amp; !this.#root.#filledNegs) this.#negs.push(this)</span><span class="s3">\n    </span><span class="s1">this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get hasMagic(): boolean | undefined {</span><span class="s3">\n    </span><span class="s1">/* c8 ignore start */</span><span class="s3">\n    </span><span class="s1">if (this.#hasMagic !== undefined) return this.#hasMagic</span><span class="s3">\n    </span><span class="s1">/* c8 ignore stop */</span><span class="s3">\n    </span><span class="s1">for (const p of this.#parts) {</span><span class="s3">\n      </span><span class="s1">if (typeof p === 'string') continue</span><span class="s3">\n      </span><span class="s1">if (p.type || p.hasMagic) return (this.#hasMagic = true)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// note: will be undefined until we generate the regexp src and find out</span><span class="s3">\n    </span><span class="s1">return this.#hasMagic</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// reconstructs the pattern</span><span class="s3">\n  </span><span class="s1">toString(): string {</span><span class="s3">\n    </span><span class="s1">if (this.#toString !== undefined) return this.#toString</span><span class="s3">\n    </span><span class="s1">if (!this.type) {</span><span class="s3">\n      </span><span class="s1">return (this.#toString = this.#parts.map(p =&gt; String(p)).join(''))</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">return (this.#toString =</span><span class="s3">\n        </span><span class="s1">this.type + '(' + this.#parts.map(p =&gt; String(p)).join('|') + ')')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">#fillNegs() {</span><span class="s3">\n    </span><span class="s1">/* c8 ignore start */</span><span class="s3">\n    </span><span class="s1">if (this !== this.#root) throw new Error('should only call on root')</span><span class="s3">\n    </span><span class="s1">if (this.#filledNegs) return this</span><span class="s3">\n    </span><span class="s1">/* c8 ignore stop */</span><span class="s3">\n\n    </span><span class="s1">// call toString() once to fill this out</span><span class="s3">\n    </span><span class="s1">this.toString()</span><span class="s3">\n    </span><span class="s1">this.#filledNegs = true</span><span class="s3">\n    </span><span class="s1">let n: AST | undefined</span><span class="s3">\n    </span><span class="s1">while ((n = this.#negs.pop())) {</span><span class="s3">\n      </span><span class="s1">if (n.type !== '!') continue</span><span class="s3">\n      </span><span class="s1">// walk up the tree, appending everthing that comes AFTER parentIndex</span><span class="s3">\n      </span><span class="s1">let p: AST | undefined = n</span><span class="s3">\n      </span><span class="s1">let pp = p.#parent</span><span class="s3">\n      </span><span class="s1">while (pp) {</span><span class="s3">\n        </span><span class="s1">for (</span><span class="s3">\n          </span><span class="s1">let i = p.#parentIndex + 1;</span><span class="s3">\n          </span><span class="s1">!pp.type &amp;&amp; i &lt; pp.#parts.length;</span><span class="s3">\n          </span><span class="s1">i++</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">for (const part of n.#parts) {</span><span class="s3">\n            </span><span class="s1">/* c8 ignore start */</span><span class="s3">\n            </span><span class="s1">if (typeof part === 'string') {</span><span class="s3">\n              </span><span class="s1">throw new Error('string part in extglob AST??')</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">/* c8 ignore stop */</span><span class="s3">\n            </span><span class="s1">part.copyIn(pp.#parts[i])</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">p = pp</span><span class="s3">\n        </span><span class="s1">pp = p.#parent</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">push(...parts: (string | AST)[]) {</span><span class="s3">\n    </span><span class="s1">for (const p of parts) {</span><span class="s3">\n      </span><span class="s1">if (p === '') continue</span><span class="s3">\n      </span><span class="s1">/* c8 ignore start */</span><span class="s3">\n      </span><span class="s1">if (typeof p !== 'string' &amp;&amp; !(p instanceof AST &amp;&amp; p.#parent === this)) {</span><span class="s3">\n        </span><span class="s1">throw new Error('invalid part: ' + p)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">/* c8 ignore stop */</span><span class="s3">\n      </span><span class="s1">this.#parts.push(p)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">toJSON() {</span><span class="s3">\n    </span><span class="s1">const ret: any[] =</span><span class="s3">\n      </span><span class="s1">this.type === null</span><span class="s3">\n        </span><span class="s1">? this.#parts.slice().map(p =&gt; (typeof p === 'string' ? p : p.toJSON()))</span><span class="s3">\n        </span><span class="s1">: [this.type, ...this.#parts.map(p =&gt; (p as AST).toJSON())]</span><span class="s3">\n    </span><span class="s1">if (this.isStart() &amp;&amp; !this.type) ret.unshift([])</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">this.isEnd() &amp;&amp;</span><span class="s3">\n      </span><span class="s1">(this === this.#root ||</span><span class="s3">\n        </span><span class="s1">(this.#root.#filledNegs &amp;&amp; this.#parent?.type === '!'))</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">ret.push({})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return ret</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">isStart(): boolean {</span><span class="s3">\n    </span><span class="s1">if (this.#root === this) return true</span><span class="s3">\n    </span><span class="s1">// if (this.type) return !!this.#parent?.isStart()</span><span class="s3">\n    </span><span class="s1">if (!this.#parent?.isStart()) return false</span><span class="s3">\n    </span><span class="s1">if (this.#parentIndex === 0) return true</span><span class="s3">\n    </span><span class="s1">// if everything AHEAD of this is a negation, then it's still the </span><span class="s3">\&quot;</span><span class="s1">start</span><span class="s3">\&quot;\n    </span><span class="s1">const p = this.#parent</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; this.#parentIndex; i++) {</span><span class="s3">\n      </span><span class="s1">const pp = p.#parts[i]</span><span class="s3">\n      </span><span class="s1">if (!(pp instanceof AST &amp;&amp; pp.type === '!')) {</span><span class="s3">\n        </span><span class="s1">return false</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">isEnd(): boolean {</span><span class="s3">\n    </span><span class="s1">if (this.#root === this) return true</span><span class="s3">\n    </span><span class="s1">if (this.#parent?.type === '!') return true</span><span class="s3">\n    </span><span class="s1">if (!this.#parent?.isEnd()) return false</span><span class="s3">\n    </span><span class="s1">if (!this.type) return this.#parent?.isEnd()</span><span class="s3">\n    </span><span class="s1">// if not root, it'll always have a parent</span><span class="s3">\n    </span><span class="s1">/* c8 ignore start */</span><span class="s3">\n    </span><span class="s1">const pl = this.#parent ? this.#parent.#parts.length : 0</span><span class="s3">\n    </span><span class="s1">/* c8 ignore stop */</span><span class="s3">\n    </span><span class="s1">return this.#parentIndex === pl - 1</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">copyIn(part: AST | string) {</span><span class="s3">\n    </span><span class="s1">if (typeof part === 'string') this.push(part)</span><span class="s3">\n    </span><span class="s1">else this.push(part.clone(this))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">clone(parent: AST) {</span><span class="s3">\n    </span><span class="s1">const c = new AST(this.type, parent)</span><span class="s3">\n    </span><span class="s1">for (const p of this.#parts) {</span><span class="s3">\n      </span><span class="s1">c.copyIn(p)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return c</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">static #parseAST(</span><span class="s3">\n    </span><span class="s1">str: string,</span><span class="s3">\n    </span><span class="s1">ast: AST,</span><span class="s3">\n    </span><span class="s1">pos: number,</span><span class="s3">\n    </span><span class="s1">opt: MinimatchOptions</span><span class="s3">\n  </span><span class="s1">): number {</span><span class="s3">\n    </span><span class="s1">let escaping = false</span><span class="s3">\n    </span><span class="s1">let inBrace = false</span><span class="s3">\n    </span><span class="s1">let braceStart = -1</span><span class="s3">\n    </span><span class="s1">let braceNeg = false</span><span class="s3">\n    </span><span class="s1">if (ast.type === null) {</span><span class="s3">\n      </span><span class="s1">// outside of a extglob, append until we find a start</span><span class="s3">\n      </span><span class="s1">let i = pos</span><span class="s3">\n      </span><span class="s1">let acc = ''</span><span class="s3">\n      </span><span class="s1">while (i &lt; str.length) {</span><span class="s3">\n        </span><span class="s1">const c = str.charAt(i++)</span><span class="s3">\n        </span><span class="s1">// still accumulate escapes at this point, but we do ignore</span><span class="s3">\n        </span><span class="s1">// starts that are escaped</span><span class="s3">\n        </span><span class="s1">if (escaping || c === '</span><span class="s3">\\\\</span><span class="s1">') {</span><span class="s3">\n          </span><span class="s1">escaping = !escaping</span><span class="s3">\n          </span><span class="s1">acc += c</span><span class="s3">\n          </span><span class="s1">continue</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (inBrace) {</span><span class="s3">\n          </span><span class="s1">if (i === braceStart + 1) {</span><span class="s3">\n            </span><span class="s1">if (c === '^' || c === '!') {</span><span class="s3">\n              </span><span class="s1">braceNeg = true</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">} else if (c === ']' &amp;&amp; !(i === braceStart + 2 &amp;&amp; braceNeg)) {</span><span class="s3">\n            </span><span class="s1">inBrace = false</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">acc += c</span><span class="s3">\n          </span><span class="s1">continue</span><span class="s3">\n        </span><span class="s1">} else if (c === '[') {</span><span class="s3">\n          </span><span class="s1">inBrace = true</span><span class="s3">\n          </span><span class="s1">braceStart = i</span><span class="s3">\n          </span><span class="s1">braceNeg = false</span><span class="s3">\n          </span><span class="s1">acc += c</span><span class="s3">\n          </span><span class="s1">continue</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (!opt.noext &amp;&amp; isExtglobType(c) &amp;&amp; str.charAt(i) === '(') {</span><span class="s3">\n          </span><span class="s1">ast.push(acc)</span><span class="s3">\n          </span><span class="s1">acc = ''</span><span class="s3">\n          </span><span class="s1">const ext = new AST(c, ast)</span><span class="s3">\n          </span><span class="s1">i = AST.#parseAST(str, ext, i, opt)</span><span class="s3">\n          </span><span class="s1">ast.push(ext)</span><span class="s3">\n          </span><span class="s1">continue</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">acc += c</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">ast.push(acc)</span><span class="s3">\n      </span><span class="s1">return i</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// some kind of extglob, pos is at the (</span><span class="s3">\n    </span><span class="s1">// find the next | or )</span><span class="s3">\n    </span><span class="s1">let i = pos + 1</span><span class="s3">\n    </span><span class="s1">let part = new AST(null, ast)</span><span class="s3">\n    </span><span class="s1">const parts: AST[] = []</span><span class="s3">\n    </span><span class="s1">let acc = ''</span><span class="s3">\n    </span><span class="s1">while (i &lt; str.length) {</span><span class="s3">\n      </span><span class="s1">const c = str.charAt(i++)</span><span class="s3">\n      </span><span class="s1">// still accumulate escapes at this point, but we do ignore</span><span class="s3">\n      </span><span class="s1">// starts that are escaped</span><span class="s3">\n      </span><span class="s1">if (escaping || c === '</span><span class="s3">\\\\</span><span class="s1">') {</span><span class="s3">\n        </span><span class="s1">escaping = !escaping</span><span class="s3">\n        </span><span class="s1">acc += c</span><span class="s3">\n        </span><span class="s1">continue</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (inBrace) {</span><span class="s3">\n        </span><span class="s1">if (i === braceStart + 1) {</span><span class="s3">\n          </span><span class="s1">if (c === '^' || c === '!') {</span><span class="s3">\n            </span><span class="s1">braceNeg = true</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} else if (c === ']' &amp;&amp; !(i === braceStart + 2 &amp;&amp; braceNeg)) {</span><span class="s3">\n          </span><span class="s1">inBrace = false</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">acc += c</span><span class="s3">\n        </span><span class="s1">continue</span><span class="s3">\n      </span><span class="s1">} else if (c === '[') {</span><span class="s3">\n        </span><span class="s1">inBrace = true</span><span class="s3">\n        </span><span class="s1">braceStart = i</span><span class="s3">\n        </span><span class="s1">braceNeg = false</span><span class="s3">\n        </span><span class="s1">acc += c</span><span class="s3">\n        </span><span class="s1">continue</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (isExtglobType(c) &amp;&amp; str.charAt(i) === '(') {</span><span class="s3">\n        </span><span class="s1">part.push(acc)</span><span class="s3">\n        </span><span class="s1">acc = ''</span><span class="s3">\n        </span><span class="s1">const ext = new AST(c, part)</span><span class="s3">\n        </span><span class="s1">part.push(ext)</span><span class="s3">\n        </span><span class="s1">i = AST.#parseAST(str, ext, i, opt)</span><span class="s3">\n        </span><span class="s1">continue</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (c === '|') {</span><span class="s3">\n        </span><span class="s1">part.push(acc)</span><span class="s3">\n        </span><span class="s1">acc = ''</span><span class="s3">\n        </span><span class="s1">parts.push(part)</span><span class="s3">\n        </span><span class="s1">part = new AST(null, ast)</span><span class="s3">\n        </span><span class="s1">continue</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (c === ')') {</span><span class="s3">\n        </span><span class="s1">if (acc === '' &amp;&amp; ast.#parts.length === 0) {</span><span class="s3">\n          </span><span class="s1">ast.#emptyExt = true</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">part.push(acc)</span><span class="s3">\n        </span><span class="s1">acc = ''</span><span class="s3">\n        </span><span class="s1">ast.push(...parts, part)</span><span class="s3">\n        </span><span class="s1">return i</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">acc += c</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// unfinished extglob</span><span class="s3">\n    </span><span class="s1">// if we got here, it was a malformed extglob! not an extglob, but</span><span class="s3">\n    </span><span class="s1">// maybe something else in there.</span><span class="s3">\n    </span><span class="s1">ast.type = null</span><span class="s3">\n    </span><span class="s1">ast.#hasMagic = undefined</span><span class="s3">\n    </span><span class="s1">ast.#parts = [str.substring(pos - 1)]</span><span class="s3">\n    </span><span class="s1">return i</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">static fromGlob(pattern: string, options: MinimatchOptions = {}) {</span><span class="s3">\n    </span><span class="s1">const ast = new AST(null, undefined, options)</span><span class="s3">\n    </span><span class="s1">AST.#parseAST(pattern, ast, 0, options)</span><span class="s3">\n    </span><span class="s1">return ast</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// returns the regular expression if there's magic, or the unescaped</span><span class="s3">\n  </span><span class="s1">// string if not.</span><span class="s3">\n  </span><span class="s1">toMMPattern(): MMRegExp | string {</span><span class="s3">\n    </span><span class="s1">// should only be called on root</span><span class="s3">\n    </span><span class="s1">/* c8 ignore start */</span><span class="s3">\n    </span><span class="s1">if (this !== this.#root) return this.#root.toMMPattern()</span><span class="s3">\n    </span><span class="s1">/* c8 ignore stop */</span><span class="s3">\n    </span><span class="s1">const glob = this.toString()</span><span class="s3">\n    </span><span class="s1">const [re, body, hasMagic, uflag] = this.toRegExpSource()</span><span class="s3">\n    </span><span class="s1">// if we're in nocase mode, and not nocaseMagicOnly, then we do</span><span class="s3">\n    </span><span class="s1">// still need a regular expression if we have to case-insensitively</span><span class="s3">\n    </span><span class="s1">// match capital/lowercase characters.</span><span class="s3">\n    </span><span class="s1">const anyMagic =</span><span class="s3">\n      </span><span class="s1">hasMagic ||</span><span class="s3">\n      </span><span class="s1">this.#hasMagic ||</span><span class="s3">\n      </span><span class="s1">(this.#options.nocase &amp;&amp;</span><span class="s3">\n        </span><span class="s1">!this.#options.nocaseMagicOnly &amp;&amp;</span><span class="s3">\n        </span><span class="s1">glob.toUpperCase() !== glob.toLowerCase())</span><span class="s3">\n    </span><span class="s1">if (!anyMagic) {</span><span class="s3">\n      </span><span class="s1">return body</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const flags = (this.#options.nocase ? 'i' : '') + (uflag ? 'u' : '')</span><span class="s3">\n    </span><span class="s1">return Object.assign(new RegExp(`^${re}$`, flags), {</span><span class="s3">\n      </span><span class="s1">_src: re,</span><span class="s3">\n      </span><span class="s1">_glob: glob,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get options() {</span><span class="s3">\n    </span><span class="s1">return this.#options</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// returns the string match, the regexp source, whether there's magic</span><span class="s3">\n  </span><span class="s1">// in the regexp (so a regular expression is required) and whether or</span><span class="s3">\n  </span><span class="s1">// not the uflag is needed for the regular expression (for posix classes)</span><span class="s3">\n  </span><span class="s1">// TODO: instead of injecting the start/end at this point, just return</span><span class="s3">\n  </span><span class="s1">// the BODY of the regexp, along with the start/end portions suitable</span><span class="s3">\n  </span><span class="s1">// for binding the start/end in either a joined full-path makeRe context</span><span class="s3">\n  </span><span class="s1">// (where we bind to (^|/), or a standalone matchPart context (where</span><span class="s3">\n  </span><span class="s1">// we bind to ^, and not /).  Otherwise slashes get duped!</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// In part-matching mode, the start is:</span><span class="s3">\n  </span><span class="s1">// - if not isStart: nothing</span><span class="s3">\n  </span><span class="s1">// - if traversal possible, but not allowed: ^(?!</span><span class="s3">\\</span><span class="s1">.</span><span class="s3">\\</span><span class="s1">.?$)</span><span class="s3">\n  </span><span class="s1">// - if dots allowed or not possible: ^</span><span class="s3">\n  </span><span class="s1">// - if dots possible and not allowed: ^(?!</span><span class="s3">\\</span><span class="s1">.)</span><span class="s3">\n  </span><span class="s1">// end is:</span><span class="s3">\n  </span><span class="s1">// - if not isEnd(): nothing</span><span class="s3">\n  </span><span class="s1">// - else: $</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// In full-path matching mode, we put the slash at the START of the</span><span class="s3">\n  </span><span class="s1">// pattern, so start is:</span><span class="s3">\n  </span><span class="s1">// - if first pattern: same as part-matching mode</span><span class="s3">\n  </span><span class="s1">// - if not isStart(): nothing</span><span class="s3">\n  </span><span class="s1">// - if traversal possible, but not allowed: /(?!</span><span class="s3">\\</span><span class="s1">.</span><span class="s3">\\</span><span class="s1">.?(?:$|/))</span><span class="s3">\n  </span><span class="s1">// - if dots allowed or not possible: /</span><span class="s3">\n  </span><span class="s1">// - if dots possible and not allowed: /(?!</span><span class="s3">\\</span><span class="s1">.)</span><span class="s3">\n  </span><span class="s1">// end is:</span><span class="s3">\n  </span><span class="s1">// - if last pattern, same as part-matching mode</span><span class="s3">\n  </span><span class="s1">// - else nothing</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// Always put the (?:$|/) on negated tails, though, because that has to be</span><span class="s3">\n  </span><span class="s1">// there to bind the end of the negated pattern portion, and it's easier to</span><span class="s3">\n  </span><span class="s1">// just stick it in now rather than try to inject it later in the middle of</span><span class="s3">\n  </span><span class="s1">// the pattern.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// We can just always return the same end, and leave it up to the caller</span><span class="s3">\n  </span><span class="s1">// to know whether it's going to be used joined or in parts.</span><span class="s3">\n  </span><span class="s1">// And, if the start is adjusted slightly, can do the same there:</span><span class="s3">\n  </span><span class="s1">// - if not isStart: nothing</span><span class="s3">\n  </span><span class="s1">// - if traversal possible, but not allowed: (?:/|^)(?!</span><span class="s3">\\</span><span class="s1">.</span><span class="s3">\\</span><span class="s1">.?$)</span><span class="s3">\n  </span><span class="s1">// - if dots allowed or not possible: (?:/|^)</span><span class="s3">\n  </span><span class="s1">// - if dots possible and not allowed: (?:/|^)(?!</span><span class="s3">\\</span><span class="s1">.)</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// But it's better to have a simpler binding without a conditional, for</span><span class="s3">\n  </span><span class="s1">// performance, so probably better to return both start options.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// Then the caller just ignores the end if it's not the first pattern,</span><span class="s3">\n  </span><span class="s1">// and the start always gets applied.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// But that's always going to be $ if it's the ending pattern, or nothing,</span><span class="s3">\n  </span><span class="s1">// so the caller can just attach $ at the end of the pattern when building.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// So the todo is:</span><span class="s3">\n  </span><span class="s1">// - better detect what kind of start is needed</span><span class="s3">\n  </span><span class="s1">// - return both flavors of starting pattern</span><span class="s3">\n  </span><span class="s1">// - attach $ at the end of the pattern when creating the actual RegExp</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// Ah, but wait, no, that all only applies to the root when the first pattern</span><span class="s3">\n  </span><span class="s1">// is not an extglob. If the first pattern IS an extglob, then we need all</span><span class="s3">\n  </span><span class="s1">// that dot prevention biz to live in the extglob portions, because eg</span><span class="s3">\n  </span><span class="s1">// +(*|.x*) can match .xy but not .yx.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// So, return the two flavors if it's #root and the first child is not an</span><span class="s3">\n  </span><span class="s1">// AST, otherwise leave it to the child AST to handle it, and there,</span><span class="s3">\n  </span><span class="s1">// use the (?:^|/) style of start binding.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// Even simplified further:</span><span class="s3">\n  </span><span class="s1">// - Since the start for a join is eg /(?!</span><span class="s3">\\</span><span class="s1">.) and the start for a part</span><span class="s3">\n  </span><span class="s1">// is ^(?!</span><span class="s3">\\</span><span class="s1">.), we can just prepend (?!</span><span class="s3">\\</span><span class="s1">.) to the pattern (either root</span><span class="s3">\n  </span><span class="s1">// or start or whatever) and prepend ^ or / at the Regexp construction.</span><span class="s3">\n  </span><span class="s1">toRegExpSource(</span><span class="s3">\n    </span><span class="s1">allowDot?: boolean</span><span class="s3">\n  </span><span class="s1">): [re: string, body: string, hasMagic: boolean, uflag: boolean] {</span><span class="s3">\n    </span><span class="s1">const dot = allowDot ?? !!this.#options.dot</span><span class="s3">\n    </span><span class="s1">if (this.#root === this) this.#fillNegs()</span><span class="s3">\n    </span><span class="s1">if (!this.type) {</span><span class="s3">\n      </span><span class="s1">const noEmpty = this.isStart() &amp;&amp; this.isEnd()</span><span class="s3">\n      </span><span class="s1">const src = this.#parts</span><span class="s3">\n        </span><span class="s1">.map(p =&gt; {</span><span class="s3">\n          </span><span class="s1">const [re, _, hasMagic, uflag] =</span><span class="s3">\n            </span><span class="s1">typeof p === 'string'</span><span class="s3">\n              </span><span class="s1">? AST.#parseGlob(p, this.#hasMagic, noEmpty)</span><span class="s3">\n              </span><span class="s1">: p.toRegExpSource(allowDot)</span><span class="s3">\n          </span><span class="s1">this.#hasMagic = this.#hasMagic || hasMagic</span><span class="s3">\n          </span><span class="s1">this.#uflag = this.#uflag || uflag</span><span class="s3">\n          </span><span class="s1">return re</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n        </span><span class="s1">.join('')</span><span class="s3">\n\n      </span><span class="s1">let start = ''</span><span class="s3">\n      </span><span class="s1">if (this.isStart()) {</span><span class="s3">\n        </span><span class="s1">if (typeof this.#parts[0] === 'string') {</span><span class="s3">\n          </span><span class="s1">// this is the string that will match the start of the pattern,</span><span class="s3">\n          </span><span class="s1">// so we need to protect against dots and such.</span><span class="s3">\n\n          </span><span class="s1">// '.' and '..' cannot match unless the pattern is that exactly,</span><span class="s3">\n          </span><span class="s1">// even if it starts with . or dot:true is set.</span><span class="s3">\n          </span><span class="s1">const dotTravAllowed =</span><span class="s3">\n            </span><span class="s1">this.#parts.length === 1 &amp;&amp; justDots.has(this.#parts[0])</span><span class="s3">\n          </span><span class="s1">if (!dotTravAllowed) {</span><span class="s3">\n            </span><span class="s1">const aps = addPatternStart</span><span class="s3">\n            </span><span class="s1">// check if we have a possibility of matching . or ..,</span><span class="s3">\n            </span><span class="s1">// and prevent that.</span><span class="s3">\n            </span><span class="s1">const needNoTrav =</span><span class="s3">\n              </span><span class="s1">// dots are allowed, and the pattern starts with [ or .</span><span class="s3">\n              </span><span class="s1">(dot &amp;&amp; aps.has(src.charAt(0))) ||</span><span class="s3">\n              </span><span class="s1">// the pattern starts with </span><span class="s3">\\</span><span class="s1">., and then [ or .</span><span class="s3">\n              </span><span class="s1">(src.startsWith('</span><span class="s3">\\\\</span><span class="s1">.') &amp;&amp; aps.has(src.charAt(2))) ||</span><span class="s3">\n              </span><span class="s1">// the pattern starts with </span><span class="s3">\\</span><span class="s1">.</span><span class="s3">\\</span><span class="s1">., and then [ or .</span><span class="s3">\n              </span><span class="s1">(src.startsWith('</span><span class="s3">\\\\</span><span class="s1">.</span><span class="s3">\\\\</span><span class="s1">.') &amp;&amp; aps.has(src.charAt(4)))</span><span class="s3">\n            </span><span class="s1">// no need to prevent dots if it can't match a dot, or if a</span><span class="s3">\n            </span><span class="s1">// sub-pattern will be preventing it anyway.</span><span class="s3">\n            </span><span class="s1">const needNoDot = !dot &amp;&amp; !allowDot &amp;&amp; aps.has(src.charAt(0))</span><span class="s3">\n\n            </span><span class="s1">start = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : ''</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// append the </span><span class="s3">\&quot;</span><span class="s1">end of path portion</span><span class="s3">\&quot; </span><span class="s1">pattern to negation tails</span><span class="s3">\n      </span><span class="s1">let end = ''</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">this.isEnd() &amp;&amp;</span><span class="s3">\n        </span><span class="s1">this.#root.#filledNegs &amp;&amp;</span><span class="s3">\n        </span><span class="s1">this.#parent?.type === '!'</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">end = '(?:$|</span><span class="s3">\\\\</span><span class="s1">/)'</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">const final = start + src + end</span><span class="s3">\n      </span><span class="s1">return [</span><span class="s3">\n        </span><span class="s1">final,</span><span class="s3">\n        </span><span class="s1">unescape(src),</span><span class="s3">\n        </span><span class="s1">(this.#hasMagic = !!this.#hasMagic),</span><span class="s3">\n        </span><span class="s1">this.#uflag,</span><span class="s3">\n      </span><span class="s1">]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// We need to calculate the body *twice* if it's a repeat pattern</span><span class="s3">\n    </span><span class="s1">// at the start, once in nodot mode, then again in dot mode, so a</span><span class="s3">\n    </span><span class="s1">// pattern like *(?) can match 'x.y'</span><span class="s3">\n\n    </span><span class="s1">const repeated = this.type === '*' || this.type === '+'</span><span class="s3">\n    </span><span class="s1">// some kind of extglob</span><span class="s3">\n    </span><span class="s1">const start = this.type === '!' ? '(?:(?!(?:' : '(?:'</span><span class="s3">\n    </span><span class="s1">let body = this.#partsToRegExp(dot)</span><span class="s3">\n\n    </span><span class="s1">if (this.isStart() &amp;&amp; this.isEnd() &amp;&amp; !body &amp;&amp; this.type !== '!') {</span><span class="s3">\n      </span><span class="s1">// invalid extglob, has to at least be *something* present, if it's</span><span class="s3">\n      </span><span class="s1">// the entire path portion.</span><span class="s3">\n      </span><span class="s1">const s = this.toString()</span><span class="s3">\n      </span><span class="s1">this.#parts = [s]</span><span class="s3">\n      </span><span class="s1">this.type = null</span><span class="s3">\n      </span><span class="s1">this.#hasMagic = undefined</span><span class="s3">\n      </span><span class="s1">return [s, unescape(this.toString()), false, false]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// XXX abstract out this map method</span><span class="s3">\n    </span><span class="s1">let bodyDotAllowed =</span><span class="s3">\n      </span><span class="s1">!repeated || allowDot || dot || !startNoDot</span><span class="s3">\n        </span><span class="s1">? ''</span><span class="s3">\n        </span><span class="s1">: this.#partsToRegExp(true)</span><span class="s3">\n    </span><span class="s1">if (bodyDotAllowed === body) {</span><span class="s3">\n      </span><span class="s1">bodyDotAllowed = ''</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (bodyDotAllowed) {</span><span class="s3">\n      </span><span class="s1">body = `(?:${body})(?:${bodyDotAllowed})*?`</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// an empty !() is exactly equivalent to a starNoEmpty</span><span class="s3">\n    </span><span class="s1">let final = ''</span><span class="s3">\n    </span><span class="s1">if (this.type === '!' &amp;&amp; this.#emptyExt) {</span><span class="s3">\n      </span><span class="s1">final = (this.isStart() &amp;&amp; !dot ? startNoDot : '') + starNoEmpty</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">const close =</span><span class="s3">\n        </span><span class="s1">this.type === '!'</span><span class="s3">\n          </span><span class="s1">? // !() must match something,but !(x) can match ''</span><span class="s3">\n            </span><span class="s1">'))' +</span><span class="s3">\n            </span><span class="s1">(this.isStart() &amp;&amp; !dot &amp;&amp; !allowDot ? startNoDot : '') +</span><span class="s3">\n            </span><span class="s1">star +</span><span class="s3">\n            </span><span class="s1">')'</span><span class="s3">\n          </span><span class="s1">: this.type === '@'</span><span class="s3">\n          </span><span class="s1">? ')'</span><span class="s3">\n          </span><span class="s1">: this.type === '?'</span><span class="s3">\n          </span><span class="s1">? ')?'</span><span class="s3">\n          </span><span class="s1">: this.type === '+' &amp;&amp; bodyDotAllowed</span><span class="s3">\n          </span><span class="s1">? ')'</span><span class="s3">\n          </span><span class="s1">: this.type === '*' &amp;&amp; bodyDotAllowed</span><span class="s3">\n          </span><span class="s1">? `)?`</span><span class="s3">\n          </span><span class="s1">: `)${this.type}`</span><span class="s3">\n      </span><span class="s1">final = start + body + close</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return [</span><span class="s3">\n      </span><span class="s1">final,</span><span class="s3">\n      </span><span class="s1">unescape(body),</span><span class="s3">\n      </span><span class="s1">(this.#hasMagic = !!this.#hasMagic),</span><span class="s3">\n      </span><span class="s1">this.#uflag,</span><span class="s3">\n    </span><span class="s1">]</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">#partsToRegExp(dot: boolean) {</span><span class="s3">\n    </span><span class="s1">return this.#parts</span><span class="s3">\n      </span><span class="s1">.map(p =&gt; {</span><span class="s3">\n        </span><span class="s1">// extglob ASTs should only contain parent ASTs</span><span class="s3">\n        </span><span class="s1">/* c8 ignore start */</span><span class="s3">\n        </span><span class="s1">if (typeof p === 'string') {</span><span class="s3">\n          </span><span class="s1">throw new Error('string type in extglob ast??')</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">/* c8 ignore stop */</span><span class="s3">\n        </span><span class="s1">// can ignore hasMagic, because extglobs are already always magic</span><span class="s3">\n        </span><span class="s1">const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot)</span><span class="s3">\n        </span><span class="s1">this.#uflag = this.#uflag || uflag</span><span class="s3">\n        </span><span class="s1">return re</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">.filter(p =&gt; !(this.isStart() &amp;&amp; this.isEnd()) || !!p)</span><span class="s3">\n      </span><span class="s1">.join('|')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">static #parseGlob(</span><span class="s3">\n    </span><span class="s1">glob: string,</span><span class="s3">\n    </span><span class="s1">hasMagic: boolean | undefined,</span><span class="s3">\n    </span><span class="s1">noEmpty: boolean = false</span><span class="s3">\n  </span><span class="s1">): [re: string, body: string, hasMagic: boolean, uflag: boolean] {</span><span class="s3">\n    </span><span class="s1">let escaping = false</span><span class="s3">\n    </span><span class="s1">let re = ''</span><span class="s3">\n    </span><span class="s1">let uflag = false</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; glob.length; i++) {</span><span class="s3">\n      </span><span class="s1">const c = glob.charAt(i)</span><span class="s3">\n      </span><span class="s1">if (escaping) {</span><span class="s3">\n        </span><span class="s1">escaping = false</span><span class="s3">\n        </span><span class="s1">re += (reSpecials.has(c) ? '</span><span class="s3">\\\\</span><span class="s1">' : '') + c</span><span class="s3">\n        </span><span class="s1">continue</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (c === '</span><span class="s3">\\\\</span><span class="s1">') {</span><span class="s3">\n        </span><span class="s1">if (i === glob.length - 1) {</span><span class="s3">\n          </span><span class="s1">re += '</span><span class="s3">\\\\\\\\</span><span class="s1">'</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">escaping = true</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">continue</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (c === '[') {</span><span class="s3">\n        </span><span class="s1">const [src, needUflag, consumed, magic] = parseClass(glob, i)</span><span class="s3">\n        </span><span class="s1">if (consumed) {</span><span class="s3">\n          </span><span class="s1">re += src</span><span class="s3">\n          </span><span class="s1">uflag = uflag || needUflag</span><span class="s3">\n          </span><span class="s1">i += consumed - 1</span><span class="s3">\n          </span><span class="s1">hasMagic = hasMagic || magic</span><span class="s3">\n          </span><span class="s1">continue</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (c === '*') {</span><span class="s3">\n        </span><span class="s1">if (noEmpty &amp;&amp; glob === '*') re += starNoEmpty</span><span class="s3">\n        </span><span class="s1">else re += star</span><span class="s3">\n        </span><span class="s1">hasMagic = true</span><span class="s3">\n        </span><span class="s1">continue</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (c === '?') {</span><span class="s3">\n        </span><span class="s1">re += qmark</span><span class="s3">\n        </span><span class="s1">hasMagic = true</span><span class="s3">\n        </span><span class="s1">continue</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">re += regExpEscape(c)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return [re, unescape(glob), !!hasMagic, uflag]</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">]}</span></pre>
</body>
</html>