<html>
<head>
<title>async.mjs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #67a37c; font-style: italic;}
.s2 { color: #bcbec4;}
.s3 { color: #cf8e6d;}
.s4 { color: #bcbec4;}
.s5 { color: #7a7e85;}
.s6 { color: #6aab73;}
.s7 { color: #2aacb8;}
.s8 { color: #42c3d4;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
async.mjs</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* Creates a continuation function with some arguments already applied.</span>
 <span class="s0">*</span>
 <span class="s0">* Useful as a shorthand when combined with other control flow functions. Any</span>
 <span class="s0">* arguments passed to the returned function are added to the arguments</span>
 <span class="s0">* originally passed to apply.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">apply</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Utils</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Util</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} fn - The function you want to eventually apply all</span>
 <span class="s0">* arguments to. Invokes with (arguments...).</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{...*} arguments... - Any number of arguments to automatically apply</span>
 <span class="s0">* when the continuation is called.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Function} the partially-applied function</span>
 <span class="s0">* </span><span class="s1">@example</span>
 <span class="s0">*</span>
 <span class="s0">* // using apply</span>
 <span class="s0">* async.parallel([</span>
 <span class="s0">*     async.apply(fs.writeFile, 'testfile1', 'test1'),</span>
 <span class="s0">*     async.apply(fs.writeFile, 'testfile2', 'test2')</span>
 <span class="s0">* ]);</span>
 <span class="s0">*</span>
 <span class="s0">*</span>
 <span class="s0">* // the same process without using apply</span>
 <span class="s0">* async.parallel([</span>
 <span class="s0">*     function(callback) {</span>
 <span class="s0">*         fs.writeFile('testfile1', 'test1', callback);</span>
 <span class="s0">*     },</span>
 <span class="s0">*     function(callback) {</span>
 <span class="s0">*         fs.writeFile('testfile2', 'test2', callback);</span>
 <span class="s0">*     }</span>
 <span class="s0">* ]);</span>
 <span class="s0">*</span>
 <span class="s0">* // It's possible to pass any number of additional arguments when calling the</span>
 <span class="s0">* // continuation:</span>
 <span class="s0">*</span>
 <span class="s0">* node&gt; var fn = async.apply(sys.puts, 'one');</span>
 <span class="s0">* node&gt; fn('two', 'three');</span>
 <span class="s0">* one</span>
 <span class="s0">* two</span>
 <span class="s0">* three</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">apply</span><span class="s4">(</span><span class="s2">fn</span><span class="s4">, </span><span class="s2">...args</span><span class="s4">) {</span>
    <span class="s3">return </span><span class="s4">(</span><span class="s2">...callArgs</span><span class="s4">) =&gt; </span><span class="s2">fn</span><span class="s4">(</span><span class="s2">...args</span><span class="s4">,</span><span class="s2">...callArgs</span><span class="s4">);</span>
<span class="s4">}</span>

<span class="s3">function </span><span class="s2">initialParams </span><span class="s4">(</span><span class="s2">fn</span><span class="s4">) {</span>
    <span class="s3">return function </span><span class="s4">(</span><span class="s2">...args</span><span class="s5">/*, callback*/</span><span class="s4">) {</span>
        <span class="s3">var </span><span class="s2">callback </span><span class="s4">= </span><span class="s2">args</span><span class="s4">.</span><span class="s2">pop</span><span class="s4">();</span>
        <span class="s3">return </span><span class="s2">fn</span><span class="s4">.</span><span class="s2">call</span><span class="s4">(</span><span class="s3">this</span><span class="s4">, </span><span class="s2">args</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">);</span>
    <span class="s4">};</span>
<span class="s4">}</span>

<span class="s5">/* istanbul ignore file */</span>

<span class="s3">var </span><span class="s2">hasQueueMicrotask </span><span class="s4">= </span><span class="s3">typeof </span><span class="s2">queueMicrotask </span><span class="s4">=== </span><span class="s6">'function' </span><span class="s4">&amp;&amp; </span><span class="s2">queueMicrotask</span><span class="s4">;</span>
<span class="s3">var </span><span class="s2">hasSetImmediate </span><span class="s4">= </span><span class="s3">typeof </span><span class="s2">setImmediate </span><span class="s4">=== </span><span class="s6">'function' </span><span class="s4">&amp;&amp; </span><span class="s2">setImmediate</span><span class="s4">;</span>
<span class="s3">var </span><span class="s2">hasNextTick </span><span class="s4">= </span><span class="s3">typeof </span><span class="s2">process </span><span class="s4">=== </span><span class="s6">'object' </span><span class="s4">&amp;&amp; </span><span class="s3">typeof </span><span class="s2">process</span><span class="s4">.</span><span class="s2">nextTick </span><span class="s4">=== </span><span class="s6">'function'</span><span class="s4">;</span>

<span class="s3">function </span><span class="s2">fallback</span><span class="s4">(</span><span class="s2">fn</span><span class="s4">) {</span>
    <span class="s2">setTimeout</span><span class="s4">(</span><span class="s2">fn</span><span class="s4">, </span><span class="s7">0</span><span class="s4">);</span>
<span class="s4">}</span>

<span class="s3">function </span><span class="s2">wrap</span><span class="s4">(</span><span class="s2">defer</span><span class="s4">) {</span>
    <span class="s3">return </span><span class="s4">(</span><span class="s2">fn</span><span class="s4">, </span><span class="s2">...args</span><span class="s4">) =&gt; </span><span class="s2">defer</span><span class="s4">(() =&gt; </span><span class="s2">fn</span><span class="s4">(</span><span class="s2">...args</span><span class="s4">));</span>
<span class="s4">}</span>

<span class="s3">var </span><span class="s2">_defer$1</span><span class="s4">;</span>

<span class="s3">if </span><span class="s4">(</span><span class="s2">hasQueueMicrotask</span><span class="s4">) {</span>
    <span class="s2">_defer$1 </span><span class="s4">= </span><span class="s2">queueMicrotask</span><span class="s4">;</span>
<span class="s4">} </span><span class="s3">else if </span><span class="s4">(</span><span class="s2">hasSetImmediate</span><span class="s4">) {</span>
    <span class="s2">_defer$1 </span><span class="s4">= </span><span class="s2">setImmediate</span><span class="s4">;</span>
<span class="s4">} </span><span class="s3">else if </span><span class="s4">(</span><span class="s2">hasNextTick</span><span class="s4">) {</span>
    <span class="s2">_defer$1 </span><span class="s4">= </span><span class="s2">process</span><span class="s4">.</span><span class="s2">nextTick</span><span class="s4">;</span>
<span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
    <span class="s2">_defer$1 </span><span class="s4">= </span><span class="s2">fallback</span><span class="s4">;</span>
<span class="s4">}</span>

<span class="s3">var </span><span class="s2">setImmediate$1 </span><span class="s4">= </span><span class="s2">wrap</span><span class="s4">(</span><span class="s2">_defer$1</span><span class="s4">);</span>

<span class="s0">/**</span>
 <span class="s0">* Take a sync function and make it async, passing its return value to a</span>
 <span class="s0">* callback. This is useful for plugging sync functions into a waterfall,</span>
 <span class="s0">* series, or other async functions. Any arguments passed to the generated</span>
 <span class="s0">* function will be passed to the wrapped function (except for the final</span>
 <span class="s0">* callback argument). Errors thrown will be passed to the callback.</span>
 <span class="s0">*</span>
 <span class="s0">* If the function passed to `asyncify` returns a Promise, that promises's</span>
 <span class="s0">* resolved/rejected state will be used to call the callback, rather than simply</span>
 <span class="s0">* the synchronous return value.</span>
 <span class="s0">*</span>
 <span class="s0">* This also means you can asyncify ES2017 `async` functions.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">asyncify</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Utils</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@alias </span><span class="s0">wrapSync</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Util</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} func - The synchronous function, or Promise-returning</span>
 <span class="s0">* function to convert to an {</span><span class="s1">@link </span><span class="s0">AsyncFunction}.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{AsyncFunction} An asynchronous wrapper of the `func`. To be</span>
 <span class="s0">* invoked with `(args..., callback)`.</span>
 <span class="s0">* </span><span class="s1">@example</span>
 <span class="s0">*</span>
 <span class="s0">* // passing a regular synchronous function</span>
 <span class="s0">* async.waterfall([</span>
 <span class="s0">*     async.apply(fs.readFile, filename, &quot;utf8&quot;),</span>
 <span class="s0">*     async.asyncify(JSON.parse),</span>
 <span class="s0">*     function (data, next) {</span>
 <span class="s0">*         // data is the result of parsing the text.</span>
 <span class="s0">*         // If there was a parsing error, it would have been caught.</span>
 <span class="s0">*     }</span>
 <span class="s0">* ], callback);</span>
 <span class="s0">*</span>
 <span class="s0">* // passing a function returning a promise</span>
 <span class="s0">* async.waterfall([</span>
 <span class="s0">*     async.apply(fs.readFile, filename, &quot;utf8&quot;),</span>
 <span class="s0">*     async.asyncify(function (contents) {</span>
 <span class="s0">*         return db.model.create(contents);</span>
 <span class="s0">*     }),</span>
 <span class="s0">*     function (model, next) {</span>
 <span class="s0">*         // `model` is the instantiated model object.</span>
 <span class="s0">*         // If there was an error, this function would be skipped.</span>
 <span class="s0">*     }</span>
 <span class="s0">* ], callback);</span>
 <span class="s0">*</span>
 <span class="s0">* // es2017 example, though `asyncify` is not needed if your JS environment</span>
 <span class="s0">* // supports async functions out of the box</span>
 <span class="s0">* var q = async.queue(async.asyncify(async function(file) {</span>
 <span class="s0">*     var intermediateStep = await processFile(file);</span>
 <span class="s0">*     return await somePromise(intermediateStep)</span>
 <span class="s0">* }));</span>
 <span class="s0">*</span>
 <span class="s0">* q.push(files);</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">asyncify</span><span class="s4">(</span><span class="s2">func</span><span class="s4">) {</span>
    <span class="s3">if </span><span class="s4">(</span><span class="s2">isAsync</span><span class="s4">(</span><span class="s2">func</span><span class="s4">)) {</span>
        <span class="s3">return function </span><span class="s4">(</span><span class="s2">...args</span><span class="s5">/*, callback*/</span><span class="s4">) {</span>
            <span class="s3">const </span><span class="s2">callback </span><span class="s4">= </span><span class="s2">args</span><span class="s4">.</span><span class="s2">pop</span><span class="s4">();</span>
            <span class="s3">const </span><span class="s2">promise </span><span class="s4">= </span><span class="s2">func</span><span class="s4">.</span><span class="s2">apply</span><span class="s4">(</span><span class="s3">this</span><span class="s4">, </span><span class="s2">args</span><span class="s4">);</span>
            <span class="s3">return </span><span class="s2">handlePromise</span><span class="s4">(</span><span class="s2">promise</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">)</span>
        <span class="s4">}</span>
    <span class="s4">}</span>

    <span class="s3">return </span><span class="s2">initialParams</span><span class="s4">(</span><span class="s3">function </span><span class="s4">(</span><span class="s2">args</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
        <span class="s3">var </span><span class="s2">result</span><span class="s4">;</span>
        <span class="s3">try </span><span class="s4">{</span>
            <span class="s2">result </span><span class="s4">= </span><span class="s2">func</span><span class="s4">.</span><span class="s2">apply</span><span class="s4">(</span><span class="s3">this</span><span class="s4">, </span><span class="s2">args</span><span class="s4">);</span>
        <span class="s4">} </span><span class="s3">catch </span><span class="s4">(</span><span class="s2">e</span><span class="s4">) {</span>
            <span class="s3">return </span><span class="s2">callback</span><span class="s4">(</span><span class="s2">e</span><span class="s4">);</span>
        <span class="s4">}</span>
        <span class="s5">// if result is Promise object</span>
        <span class="s3">if </span><span class="s4">(</span><span class="s2">result </span><span class="s4">&amp;&amp; </span><span class="s3">typeof </span><span class="s2">result</span><span class="s4">.</span><span class="s2">then </span><span class="s4">=== </span><span class="s6">'function'</span><span class="s4">) {</span>
            <span class="s3">return </span><span class="s2">handlePromise</span><span class="s4">(</span><span class="s2">result</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">)</span>
        <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
            <span class="s2">callback</span><span class="s4">(</span><span class="s3">null</span><span class="s4">, </span><span class="s2">result</span><span class="s4">);</span>
        <span class="s4">}</span>
    <span class="s4">});</span>
<span class="s4">}</span>

<span class="s3">function </span><span class="s2">handlePromise</span><span class="s4">(</span><span class="s2">promise</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
    <span class="s3">return </span><span class="s2">promise</span><span class="s4">.</span><span class="s2">then</span><span class="s4">(</span><span class="s2">value </span><span class="s4">=&gt; {</span>
        <span class="s2">invokeCallback</span><span class="s4">(</span><span class="s2">callback</span><span class="s4">, </span><span class="s3">null</span><span class="s4">, </span><span class="s2">value</span><span class="s4">);</span>
    <span class="s4">}, </span><span class="s2">err </span><span class="s4">=&gt; {</span>
        <span class="s2">invokeCallback</span><span class="s4">(</span><span class="s2">callback</span><span class="s4">, </span><span class="s2">err </span><span class="s4">&amp;&amp; (</span><span class="s2">err </span><span class="s3">instanceof </span><span class="s2">Error </span><span class="s4">|| </span><span class="s2">err</span><span class="s4">.</span><span class="s2">message</span><span class="s4">) ? </span><span class="s2">err </span><span class="s4">: </span><span class="s3">new </span><span class="s2">Error</span><span class="s4">(</span><span class="s2">err</span><span class="s4">));</span>
    <span class="s4">});</span>
<span class="s4">}</span>

<span class="s3">function </span><span class="s2">invokeCallback</span><span class="s4">(</span><span class="s2">callback</span><span class="s4">, </span><span class="s2">error</span><span class="s4">, </span><span class="s2">value</span><span class="s4">) {</span>
    <span class="s3">try </span><span class="s4">{</span>
        <span class="s2">callback</span><span class="s4">(</span><span class="s2">error</span><span class="s4">, </span><span class="s2">value</span><span class="s4">);</span>
    <span class="s4">} </span><span class="s3">catch </span><span class="s4">(</span><span class="s2">err</span><span class="s4">) {</span>
        <span class="s2">setImmediate$1</span><span class="s4">(</span><span class="s2">e </span><span class="s4">=&gt; { </span><span class="s3">throw </span><span class="s2">e </span><span class="s4">}, </span><span class="s2">err</span><span class="s4">);</span>
    <span class="s4">}</span>
<span class="s4">}</span>

<span class="s3">function </span><span class="s2">isAsync</span><span class="s4">(</span><span class="s2">fn</span><span class="s4">) {</span>
    <span class="s3">return </span><span class="s2">fn</span><span class="s4">[</span><span class="s2">Symbol</span><span class="s4">.</span><span class="s2">toStringTag</span><span class="s4">] === </span><span class="s6">'AsyncFunction'</span><span class="s4">;</span>
<span class="s4">}</span>

<span class="s3">function </span><span class="s2">isAsyncGenerator</span><span class="s4">(</span><span class="s2">fn</span><span class="s4">) {</span>
    <span class="s3">return </span><span class="s2">fn</span><span class="s4">[</span><span class="s2">Symbol</span><span class="s4">.</span><span class="s2">toStringTag</span><span class="s4">] === </span><span class="s6">'AsyncGenerator'</span><span class="s4">;</span>
<span class="s4">}</span>

<span class="s3">function </span><span class="s2">isAsyncIterable</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">) {</span>
    <span class="s3">return typeof </span><span class="s2">obj</span><span class="s4">[</span><span class="s2">Symbol</span><span class="s4">.</span><span class="s2">asyncIterator</span><span class="s4">] === </span><span class="s6">'function'</span><span class="s4">;</span>
<span class="s4">}</span>

<span class="s3">function </span><span class="s2">wrapAsync</span><span class="s4">(</span><span class="s2">asyncFn</span><span class="s4">) {</span>
    <span class="s3">if </span><span class="s4">(</span><span class="s3">typeof </span><span class="s2">asyncFn </span><span class="s4">!== </span><span class="s6">'function'</span><span class="s4">) </span><span class="s3">throw new </span><span class="s2">Error</span><span class="s4">(</span><span class="s6">'expected a function'</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s2">isAsync</span><span class="s4">(</span><span class="s2">asyncFn</span><span class="s4">) ? </span><span class="s2">asyncify</span><span class="s4">(</span><span class="s2">asyncFn</span><span class="s4">) : </span><span class="s2">asyncFn</span><span class="s4">;</span>
<span class="s4">}</span>

<span class="s5">// conditionally promisify a function.</span>
<span class="s5">// only return a promise if a callback is omitted</span>
<span class="s3">function </span><span class="s2">awaitify </span><span class="s4">(</span><span class="s2">asyncFn</span><span class="s4">, </span><span class="s2">arity</span><span class="s4">) {</span>
    <span class="s3">if </span><span class="s4">(!</span><span class="s2">arity</span><span class="s4">) </span><span class="s2">arity </span><span class="s4">= </span><span class="s2">asyncFn</span><span class="s4">.</span><span class="s2">length</span><span class="s4">;</span>
    <span class="s3">if </span><span class="s4">(!</span><span class="s2">arity</span><span class="s4">) </span><span class="s3">throw new </span><span class="s2">Error</span><span class="s4">(</span><span class="s6">'arity is undefined'</span><span class="s4">)</span>
    <span class="s3">function </span><span class="s2">awaitable </span><span class="s4">(</span><span class="s2">...args</span><span class="s4">) {</span>
        <span class="s3">if </span><span class="s4">(</span><span class="s3">typeof </span><span class="s2">args</span><span class="s4">[</span><span class="s2">arity </span><span class="s4">- </span><span class="s7">1</span><span class="s4">] === </span><span class="s6">'function'</span><span class="s4">) {</span>
            <span class="s3">return </span><span class="s2">asyncFn</span><span class="s4">.</span><span class="s2">apply</span><span class="s4">(</span><span class="s3">this</span><span class="s4">, </span><span class="s2">args</span><span class="s4">)</span>
        <span class="s4">}</span>

        <span class="s3">return new </span><span class="s2">Promise</span><span class="s4">((</span><span class="s2">resolve</span><span class="s4">, </span><span class="s2">reject</span><span class="s4">) =&gt; {</span>
            <span class="s2">args</span><span class="s4">[</span><span class="s2">arity </span><span class="s4">- </span><span class="s7">1</span><span class="s4">] = (</span><span class="s2">err</span><span class="s4">, </span><span class="s2">...cbArgs</span><span class="s4">) =&gt; {</span>
                <span class="s3">if </span><span class="s4">(</span><span class="s2">err</span><span class="s4">) </span><span class="s3">return </span><span class="s2">reject</span><span class="s4">(</span><span class="s2">err</span><span class="s4">)</span>
                <span class="s2">resolve</span><span class="s4">(</span><span class="s2">cbArgs</span><span class="s4">.</span><span class="s2">length </span><span class="s4">&gt; </span><span class="s7">1 </span><span class="s4">? </span><span class="s2">cbArgs </span><span class="s4">: </span><span class="s2">cbArgs</span><span class="s4">[</span><span class="s7">0</span><span class="s4">]);</span>
            <span class="s4">};</span>
            <span class="s2">asyncFn</span><span class="s4">.</span><span class="s2">apply</span><span class="s4">(</span><span class="s3">this</span><span class="s4">, </span><span class="s2">args</span><span class="s4">);</span>
        <span class="s4">})</span>
    <span class="s4">}</span>

    <span class="s3">return </span><span class="s2">awaitable</span>
<span class="s4">}</span>

<span class="s3">function </span><span class="s2">applyEach$1 </span><span class="s4">(</span><span class="s2">eachfn</span><span class="s4">) {</span>
    <span class="s3">return function </span><span class="s2">applyEach</span><span class="s4">(</span><span class="s2">fns</span><span class="s4">, </span><span class="s2">...callArgs</span><span class="s4">) {</span>
        <span class="s3">const </span><span class="s2">go </span><span class="s4">= </span><span class="s2">awaitify</span><span class="s4">(</span><span class="s3">function </span><span class="s4">(</span><span class="s2">callback</span><span class="s4">) {</span>
            <span class="s3">var </span><span class="s2">that </span><span class="s4">= </span><span class="s3">this</span><span class="s4">;</span>
            <span class="s3">return </span><span class="s2">eachfn</span><span class="s4">(</span><span class="s2">fns</span><span class="s4">, (</span><span class="s2">fn</span><span class="s4">, </span><span class="s2">cb</span><span class="s4">) =&gt; {</span>
                <span class="s2">wrapAsync</span><span class="s4">(</span><span class="s2">fn</span><span class="s4">).</span><span class="s2">apply</span><span class="s4">(</span><span class="s2">that</span><span class="s4">, </span><span class="s2">callArgs</span><span class="s4">.</span><span class="s2">concat</span><span class="s4">(</span><span class="s2">cb</span><span class="s4">));</span>
            <span class="s4">}, </span><span class="s2">callback</span><span class="s4">);</span>
        <span class="s4">});</span>
        <span class="s3">return </span><span class="s2">go</span><span class="s4">;</span>
    <span class="s4">};</span>
<span class="s4">}</span>

<span class="s3">function </span><span class="s2">_asyncMap</span><span class="s4">(</span><span class="s2">eachfn</span><span class="s4">, </span><span class="s2">arr</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
    <span class="s2">arr </span><span class="s4">= </span><span class="s2">arr </span><span class="s4">|| [];</span>
    <span class="s3">var </span><span class="s2">results </span><span class="s4">= [];</span>
    <span class="s3">var </span><span class="s2">counter </span><span class="s4">= </span><span class="s7">0</span><span class="s4">;</span>
    <span class="s3">var </span><span class="s2">_iteratee </span><span class="s4">= </span><span class="s2">wrapAsync</span><span class="s4">(</span><span class="s2">iteratee</span><span class="s4">);</span>

    <span class="s3">return </span><span class="s2">eachfn</span><span class="s4">(</span><span class="s2">arr</span><span class="s4">, (</span><span class="s2">value</span><span class="s4">, </span><span class="s2">_</span><span class="s4">, </span><span class="s2">iterCb</span><span class="s4">) =&gt; {</span>
        <span class="s3">var </span><span class="s2">index </span><span class="s4">= </span><span class="s2">counter</span><span class="s4">++;</span>
        <span class="s2">_iteratee</span><span class="s4">(</span><span class="s2">value</span><span class="s4">, (</span><span class="s2">err</span><span class="s4">, </span><span class="s2">v</span><span class="s4">) =&gt; {</span>
            <span class="s2">results</span><span class="s4">[</span><span class="s2">index</span><span class="s4">] = </span><span class="s2">v</span><span class="s4">;</span>
            <span class="s2">iterCb</span><span class="s4">(</span><span class="s2">err</span><span class="s4">);</span>
        <span class="s4">});</span>
    <span class="s4">}, </span><span class="s2">err </span><span class="s4">=&gt; {</span>
        <span class="s2">callback</span><span class="s4">(</span><span class="s2">err</span><span class="s4">, </span><span class="s2">results</span><span class="s4">);</span>
    <span class="s4">});</span>
<span class="s4">}</span>

<span class="s3">function </span><span class="s2">isArrayLike</span><span class="s4">(</span><span class="s2">value</span><span class="s4">) {</span>
    <span class="s3">return </span><span class="s2">value </span><span class="s4">&amp;&amp;</span>
        <span class="s3">typeof </span><span class="s2">value</span><span class="s4">.</span><span class="s2">length </span><span class="s4">=== </span><span class="s6">'number' </span><span class="s4">&amp;&amp;</span>
        <span class="s2">value</span><span class="s4">.</span><span class="s2">length </span><span class="s4">&gt;= </span><span class="s7">0 </span><span class="s4">&amp;&amp;</span>
        <span class="s2">value</span><span class="s4">.</span><span class="s2">length </span><span class="s4">% </span><span class="s7">1 </span><span class="s4">=== </span><span class="s7">0</span><span class="s4">;</span>
<span class="s4">}</span>

<span class="s5">// A temporary value used to identify if the loop should be broken.</span>
<span class="s5">// See #1064, #1293</span>
<span class="s3">const </span><span class="s2">breakLoop </span><span class="s4">= {};</span>

<span class="s3">function </span><span class="s2">once</span><span class="s4">(</span><span class="s2">fn</span><span class="s4">) {</span>
    <span class="s3">function </span><span class="s2">wrapper </span><span class="s4">(</span><span class="s2">...args</span><span class="s4">) {</span>
        <span class="s3">if </span><span class="s4">(</span><span class="s2">fn </span><span class="s4">=== </span><span class="s3">null</span><span class="s4">) </span><span class="s3">return</span><span class="s4">;</span>
        <span class="s3">var </span><span class="s2">callFn </span><span class="s4">= </span><span class="s2">fn</span><span class="s4">;</span>
        <span class="s2">fn </span><span class="s4">= </span><span class="s3">null</span><span class="s4">;</span>
        <span class="s2">callFn</span><span class="s4">.</span><span class="s2">apply</span><span class="s4">(</span><span class="s3">this</span><span class="s4">, </span><span class="s2">args</span><span class="s4">);</span>
    <span class="s4">}</span>
    <span class="s2">Object</span><span class="s4">.</span><span class="s2">assign</span><span class="s4">(</span><span class="s2">wrapper</span><span class="s4">, </span><span class="s2">fn</span><span class="s4">);</span>
    <span class="s3">return </span><span class="s2">wrapper</span>
<span class="s4">}</span>

<span class="s3">function </span><span class="s2">getIterator </span><span class="s4">(</span><span class="s2">coll</span><span class="s4">) {</span>
    <span class="s3">return </span><span class="s2">coll</span><span class="s4">[</span><span class="s2">Symbol</span><span class="s4">.</span><span class="s2">iterator</span><span class="s4">] &amp;&amp; </span><span class="s2">coll</span><span class="s4">[</span><span class="s2">Symbol</span><span class="s4">.</span><span class="s2">iterator</span><span class="s4">]();</span>
<span class="s4">}</span>

<span class="s3">function </span><span class="s2">createArrayIterator</span><span class="s4">(</span><span class="s2">coll</span><span class="s4">) {</span>
    <span class="s3">var </span><span class="s2">i </span><span class="s4">= -</span><span class="s7">1</span><span class="s4">;</span>
    <span class="s3">var </span><span class="s2">len </span><span class="s4">= </span><span class="s2">coll</span><span class="s4">.</span><span class="s2">length</span><span class="s4">;</span>
    <span class="s3">return function </span><span class="s2">next</span><span class="s4">() {</span>
        <span class="s3">return </span><span class="s4">++</span><span class="s2">i </span><span class="s4">&lt; </span><span class="s2">len </span><span class="s4">? {</span><span class="s2">value</span><span class="s4">: </span><span class="s2">coll</span><span class="s4">[</span><span class="s2">i</span><span class="s4">], </span><span class="s2">key</span><span class="s4">: </span><span class="s2">i</span><span class="s4">} : </span><span class="s3">null</span><span class="s4">;</span>
    <span class="s4">}</span>
<span class="s4">}</span>

<span class="s3">function </span><span class="s2">createES2015Iterator</span><span class="s4">(</span><span class="s2">iterator</span><span class="s4">) {</span>
    <span class="s3">var </span><span class="s2">i </span><span class="s4">= -</span><span class="s7">1</span><span class="s4">;</span>
    <span class="s3">return function </span><span class="s2">next</span><span class="s4">() {</span>
        <span class="s3">var </span><span class="s2">item </span><span class="s4">= </span><span class="s2">iterator</span><span class="s4">.</span><span class="s2">next</span><span class="s4">();</span>
        <span class="s3">if </span><span class="s4">(</span><span class="s2">item</span><span class="s4">.</span><span class="s2">done</span><span class="s4">)</span>
            <span class="s3">return null</span><span class="s4">;</span>
        <span class="s2">i</span><span class="s4">++;</span>
        <span class="s3">return </span><span class="s4">{</span><span class="s2">value</span><span class="s4">: </span><span class="s2">item</span><span class="s4">.</span><span class="s2">value</span><span class="s4">, </span><span class="s2">key</span><span class="s4">: </span><span class="s2">i</span><span class="s4">};</span>
    <span class="s4">}</span>
<span class="s4">}</span>

<span class="s3">function </span><span class="s2">createObjectIterator</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">) {</span>
    <span class="s3">var </span><span class="s2">okeys </span><span class="s4">= </span><span class="s2">obj </span><span class="s4">? </span><span class="s2">Object</span><span class="s4">.</span><span class="s2">keys</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">) : [];</span>
    <span class="s3">var </span><span class="s2">i </span><span class="s4">= -</span><span class="s7">1</span><span class="s4">;</span>
    <span class="s3">var </span><span class="s2">len </span><span class="s4">= </span><span class="s2">okeys</span><span class="s4">.</span><span class="s2">length</span><span class="s4">;</span>
    <span class="s3">return function </span><span class="s2">next</span><span class="s4">() {</span>
        <span class="s3">var </span><span class="s2">key </span><span class="s4">= </span><span class="s2">okeys</span><span class="s4">[++</span><span class="s2">i</span><span class="s4">];</span>
        <span class="s3">if </span><span class="s4">(</span><span class="s2">key </span><span class="s4">=== </span><span class="s6">'__proto__'</span><span class="s4">) {</span>
            <span class="s3">return </span><span class="s2">next</span><span class="s4">();</span>
        <span class="s4">}</span>
        <span class="s3">return </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s2">len </span><span class="s4">? {</span><span class="s2">value</span><span class="s4">: </span><span class="s2">obj</span><span class="s4">[</span><span class="s2">key</span><span class="s4">], </span><span class="s2">key</span><span class="s4">} : </span><span class="s3">null</span><span class="s4">;</span>
    <span class="s4">};</span>
<span class="s4">}</span>

<span class="s3">function </span><span class="s2">createIterator</span><span class="s4">(</span><span class="s2">coll</span><span class="s4">) {</span>
    <span class="s3">if </span><span class="s4">(</span><span class="s2">isArrayLike</span><span class="s4">(</span><span class="s2">coll</span><span class="s4">)) {</span>
        <span class="s3">return </span><span class="s2">createArrayIterator</span><span class="s4">(</span><span class="s2">coll</span><span class="s4">);</span>
    <span class="s4">}</span>

    <span class="s3">var </span><span class="s2">iterator </span><span class="s4">= </span><span class="s2">getIterator</span><span class="s4">(</span><span class="s2">coll</span><span class="s4">);</span>
    <span class="s3">return </span><span class="s2">iterator </span><span class="s4">? </span><span class="s2">createES2015Iterator</span><span class="s4">(</span><span class="s2">iterator</span><span class="s4">) : </span><span class="s2">createObjectIterator</span><span class="s4">(</span><span class="s2">coll</span><span class="s4">);</span>
<span class="s4">}</span>

<span class="s3">function </span><span class="s2">onlyOnce</span><span class="s4">(</span><span class="s2">fn</span><span class="s4">) {</span>
    <span class="s3">return function </span><span class="s4">(</span><span class="s2">...args</span><span class="s4">) {</span>
        <span class="s3">if </span><span class="s4">(</span><span class="s2">fn </span><span class="s4">=== </span><span class="s3">null</span><span class="s4">) </span><span class="s3">throw new </span><span class="s2">Error</span><span class="s4">(</span><span class="s6">&quot;Callback was already called.&quot;</span><span class="s4">);</span>
        <span class="s3">var </span><span class="s2">callFn </span><span class="s4">= </span><span class="s2">fn</span><span class="s4">;</span>
        <span class="s2">fn </span><span class="s4">= </span><span class="s3">null</span><span class="s4">;</span>
        <span class="s2">callFn</span><span class="s4">.</span><span class="s2">apply</span><span class="s4">(</span><span class="s3">this</span><span class="s4">, </span><span class="s2">args</span><span class="s4">);</span>
    <span class="s4">};</span>
<span class="s4">}</span>

<span class="s5">// for async generators</span>
<span class="s3">function </span><span class="s2">asyncEachOfLimit</span><span class="s4">(</span><span class="s2">generator</span><span class="s4">, </span><span class="s2">limit</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
    <span class="s3">let </span><span class="s2">done </span><span class="s4">= </span><span class="s3">false</span><span class="s4">;</span>
    <span class="s3">let </span><span class="s2">canceled </span><span class="s4">= </span><span class="s3">false</span><span class="s4">;</span>
    <span class="s3">let </span><span class="s2">awaiting </span><span class="s4">= </span><span class="s3">false</span><span class="s4">;</span>
    <span class="s3">let </span><span class="s2">running </span><span class="s4">= </span><span class="s7">0</span><span class="s4">;</span>
    <span class="s3">let </span><span class="s2">idx </span><span class="s4">= </span><span class="s7">0</span><span class="s4">;</span>

    <span class="s3">function </span><span class="s2">replenish</span><span class="s4">() {</span>
        <span class="s5">//console.log('replenish')</span>
        <span class="s3">if </span><span class="s4">(</span><span class="s2">running </span><span class="s4">&gt;= </span><span class="s2">limit </span><span class="s4">|| </span><span class="s2">awaiting </span><span class="s4">|| </span><span class="s2">done</span><span class="s4">) </span><span class="s3">return</span>
        <span class="s5">//console.log('replenish awaiting')</span>
        <span class="s2">awaiting </span><span class="s4">= </span><span class="s3">true</span><span class="s4">;</span>
        <span class="s2">generator</span><span class="s4">.</span><span class="s2">next</span><span class="s4">().</span><span class="s2">then</span><span class="s4">(({</span><span class="s2">value</span><span class="s4">, </span><span class="s2">done</span><span class="s4">: </span><span class="s2">iterDone</span><span class="s4">}) =&gt; {</span>
            <span class="s5">//console.log('got value', value)</span>
            <span class="s3">if </span><span class="s4">(</span><span class="s2">canceled </span><span class="s4">|| </span><span class="s2">done</span><span class="s4">) </span><span class="s3">return</span>
            <span class="s2">awaiting </span><span class="s4">= </span><span class="s3">false</span><span class="s4">;</span>
            <span class="s3">if </span><span class="s4">(</span><span class="s2">iterDone</span><span class="s4">) {</span>
                <span class="s2">done </span><span class="s4">= </span><span class="s3">true</span><span class="s4">;</span>
                <span class="s3">if </span><span class="s4">(</span><span class="s2">running </span><span class="s4">&lt;= </span><span class="s7">0</span><span class="s4">) {</span>
                    <span class="s5">//console.log('done nextCb')</span>
                    <span class="s2">callback</span><span class="s4">(</span><span class="s3">null</span><span class="s4">);</span>
                <span class="s4">}</span>
                <span class="s3">return</span><span class="s4">;</span>
            <span class="s4">}</span>
            <span class="s2">running</span><span class="s4">++;</span>
            <span class="s2">iteratee</span><span class="s4">(</span><span class="s2">value</span><span class="s4">, </span><span class="s2">idx</span><span class="s4">, </span><span class="s2">iterateeCallback</span><span class="s4">);</span>
            <span class="s2">idx</span><span class="s4">++;</span>
            <span class="s2">replenish</span><span class="s4">();</span>
        <span class="s4">}).</span><span class="s2">catch</span><span class="s4">(</span><span class="s2">handleError</span><span class="s4">);</span>
    <span class="s4">}</span>

    <span class="s3">function </span><span class="s2">iterateeCallback</span><span class="s4">(</span><span class="s2">err</span><span class="s4">, </span><span class="s2">result</span><span class="s4">) {</span>
        <span class="s5">//console.log('iterateeCallback')</span>
        <span class="s2">running </span><span class="s4">-= </span><span class="s7">1</span><span class="s4">;</span>
        <span class="s3">if </span><span class="s4">(</span><span class="s2">canceled</span><span class="s4">) </span><span class="s3">return</span>
        <span class="s3">if </span><span class="s4">(</span><span class="s2">err</span><span class="s4">) </span><span class="s3">return </span><span class="s2">handleError</span><span class="s4">(</span><span class="s2">err</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s4">(</span><span class="s2">err </span><span class="s4">=== </span><span class="s3">false</span><span class="s4">) {</span>
            <span class="s2">done </span><span class="s4">= </span><span class="s3">true</span><span class="s4">;</span>
            <span class="s2">canceled </span><span class="s4">= </span><span class="s3">true</span><span class="s4">;</span>
            <span class="s3">return</span>
        <span class="s4">}</span>

        <span class="s3">if </span><span class="s4">(</span><span class="s2">result </span><span class="s4">=== </span><span class="s2">breakLoop </span><span class="s4">|| (</span><span class="s2">done </span><span class="s4">&amp;&amp; </span><span class="s2">running </span><span class="s4">&lt;= </span><span class="s7">0</span><span class="s4">)) {</span>
            <span class="s2">done </span><span class="s4">= </span><span class="s3">true</span><span class="s4">;</span>
            <span class="s5">//console.log('done iterCb')</span>
            <span class="s3">return </span><span class="s2">callback</span><span class="s4">(</span><span class="s3">null</span><span class="s4">);</span>
        <span class="s4">}</span>
        <span class="s2">replenish</span><span class="s4">();</span>
    <span class="s4">}</span>

    <span class="s3">function </span><span class="s2">handleError</span><span class="s4">(</span><span class="s2">err</span><span class="s4">) {</span>
        <span class="s3">if </span><span class="s4">(</span><span class="s2">canceled</span><span class="s4">) </span><span class="s3">return</span>
        <span class="s2">awaiting </span><span class="s4">= </span><span class="s3">false</span><span class="s4">;</span>
        <span class="s2">done </span><span class="s4">= </span><span class="s3">true</span><span class="s4">;</span>
        <span class="s2">callback</span><span class="s4">(</span><span class="s2">err</span><span class="s4">);</span>
    <span class="s4">}</span>

    <span class="s2">replenish</span><span class="s4">();</span>
<span class="s4">}</span>

<span class="s3">var </span><span class="s2">eachOfLimit$2 </span><span class="s4">= (</span><span class="s2">limit</span><span class="s4">) =&gt; {</span>
    <span class="s3">return </span><span class="s4">(</span><span class="s2">obj</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) =&gt; {</span>
        <span class="s2">callback </span><span class="s4">= </span><span class="s2">once</span><span class="s4">(</span><span class="s2">callback</span><span class="s4">);</span>
        <span class="s3">if </span><span class="s4">(</span><span class="s2">limit </span><span class="s4">&lt;= </span><span class="s7">0</span><span class="s4">) {</span>
            <span class="s3">throw new </span><span class="s2">RangeError</span><span class="s4">(</span><span class="s6">'concurrency limit cannot be less than 1'</span><span class="s4">)</span>
        <span class="s4">}</span>
        <span class="s3">if </span><span class="s4">(!</span><span class="s2">obj</span><span class="s4">) {</span>
            <span class="s3">return </span><span class="s2">callback</span><span class="s4">(</span><span class="s3">null</span><span class="s4">);</span>
        <span class="s4">}</span>
        <span class="s3">if </span><span class="s4">(</span><span class="s2">isAsyncGenerator</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">)) {</span>
            <span class="s3">return </span><span class="s2">asyncEachOfLimit</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">, </span><span class="s2">limit</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">)</span>
        <span class="s4">}</span>
        <span class="s3">if </span><span class="s4">(</span><span class="s2">isAsyncIterable</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">)) {</span>
            <span class="s3">return </span><span class="s2">asyncEachOfLimit</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">[</span><span class="s2">Symbol</span><span class="s4">.</span><span class="s2">asyncIterator</span><span class="s4">](), </span><span class="s2">limit</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">)</span>
        <span class="s4">}</span>
        <span class="s3">var </span><span class="s2">nextElem </span><span class="s4">= </span><span class="s2">createIterator</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">);</span>
        <span class="s3">var </span><span class="s2">done </span><span class="s4">= </span><span class="s3">false</span><span class="s4">;</span>
        <span class="s3">var </span><span class="s2">canceled </span><span class="s4">= </span><span class="s3">false</span><span class="s4">;</span>
        <span class="s3">var </span><span class="s2">running </span><span class="s4">= </span><span class="s7">0</span><span class="s4">;</span>
        <span class="s3">var </span><span class="s2">looping </span><span class="s4">= </span><span class="s3">false</span><span class="s4">;</span>

        <span class="s3">function </span><span class="s2">iterateeCallback</span><span class="s4">(</span><span class="s2">err</span><span class="s4">, </span><span class="s2">value</span><span class="s4">) {</span>
            <span class="s3">if </span><span class="s4">(</span><span class="s2">canceled</span><span class="s4">) </span><span class="s3">return</span>
            <span class="s2">running </span><span class="s4">-= </span><span class="s7">1</span><span class="s4">;</span>
            <span class="s3">if </span><span class="s4">(</span><span class="s2">err</span><span class="s4">) {</span>
                <span class="s2">done </span><span class="s4">= </span><span class="s3">true</span><span class="s4">;</span>
                <span class="s2">callback</span><span class="s4">(</span><span class="s2">err</span><span class="s4">);</span>
            <span class="s4">}</span>
            <span class="s3">else if </span><span class="s4">(</span><span class="s2">err </span><span class="s4">=== </span><span class="s3">false</span><span class="s4">) {</span>
                <span class="s2">done </span><span class="s4">= </span><span class="s3">true</span><span class="s4">;</span>
                <span class="s2">canceled </span><span class="s4">= </span><span class="s3">true</span><span class="s4">;</span>
            <span class="s4">}</span>
            <span class="s3">else if </span><span class="s4">(</span><span class="s2">value </span><span class="s4">=== </span><span class="s2">breakLoop </span><span class="s4">|| (</span><span class="s2">done </span><span class="s4">&amp;&amp; </span><span class="s2">running </span><span class="s4">&lt;= </span><span class="s7">0</span><span class="s4">)) {</span>
                <span class="s2">done </span><span class="s4">= </span><span class="s3">true</span><span class="s4">;</span>
                <span class="s3">return </span><span class="s2">callback</span><span class="s4">(</span><span class="s3">null</span><span class="s4">);</span>
            <span class="s4">}</span>
            <span class="s3">else if </span><span class="s4">(!</span><span class="s2">looping</span><span class="s4">) {</span>
                <span class="s2">replenish</span><span class="s4">();</span>
            <span class="s4">}</span>
        <span class="s4">}</span>

        <span class="s3">function </span><span class="s2">replenish </span><span class="s4">() {</span>
            <span class="s2">looping </span><span class="s4">= </span><span class="s3">true</span><span class="s4">;</span>
            <span class="s3">while </span><span class="s4">(</span><span class="s2">running </span><span class="s4">&lt; </span><span class="s2">limit </span><span class="s4">&amp;&amp; !</span><span class="s2">done</span><span class="s4">) {</span>
                <span class="s3">var </span><span class="s2">elem </span><span class="s4">= </span><span class="s2">nextElem</span><span class="s4">();</span>
                <span class="s3">if </span><span class="s4">(</span><span class="s2">elem </span><span class="s4">=== </span><span class="s3">null</span><span class="s4">) {</span>
                    <span class="s2">done </span><span class="s4">= </span><span class="s3">true</span><span class="s4">;</span>
                    <span class="s3">if </span><span class="s4">(</span><span class="s2">running </span><span class="s4">&lt;= </span><span class="s7">0</span><span class="s4">) {</span>
                        <span class="s2">callback</span><span class="s4">(</span><span class="s3">null</span><span class="s4">);</span>
                    <span class="s4">}</span>
                    <span class="s3">return</span><span class="s4">;</span>
                <span class="s4">}</span>
                <span class="s2">running </span><span class="s4">+= </span><span class="s7">1</span><span class="s4">;</span>
                <span class="s2">iteratee</span><span class="s4">(</span><span class="s2">elem</span><span class="s4">.</span><span class="s2">value</span><span class="s4">, </span><span class="s2">elem</span><span class="s4">.</span><span class="s2">key</span><span class="s4">, </span><span class="s2">onlyOnce</span><span class="s4">(</span><span class="s2">iterateeCallback</span><span class="s4">));</span>
            <span class="s4">}</span>
            <span class="s2">looping </span><span class="s4">= </span><span class="s3">false</span><span class="s4">;</span>
        <span class="s4">}</span>

        <span class="s2">replenish</span><span class="s4">();</span>
    <span class="s4">};</span>
<span class="s4">};</span>

<span class="s0">/**</span>
 <span class="s0">* The same as [`eachOf`]{</span><span class="s1">@link </span><span class="s0">module:Collections.eachOf} but runs a maximum of `limit` async operations at a</span>
 <span class="s0">* time.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">eachOfLimit</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s0">[async.eachOf]{</span><span class="s1">@link </span><span class="s0">module:Collections.eachOf}</span>
 <span class="s0">* </span><span class="s1">@alias </span><span class="s0">forEachOfLimit</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collection</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{number} limit - The maximum number of async operations at a time.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{AsyncFunction} iteratee - An async function to apply to each</span>
 <span class="s0">* item in `coll`. The `key` is the item's key, or index in the case of an</span>
 <span class="s0">* array.</span>
 <span class="s0">* Invoked with (item, key, callback).</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} [callback] - A callback which is called when all</span>
 <span class="s0">* `iteratee` functions have finished, or an error occurs. Invoked with (err).</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise} a promise, if a callback is omitted</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">eachOfLimit</span><span class="s4">(</span><span class="s2">coll</span><span class="s4">, </span><span class="s2">limit</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
    <span class="s3">return </span><span class="s2">eachOfLimit$2</span><span class="s4">(</span><span class="s2">limit</span><span class="s4">)(</span><span class="s2">coll</span><span class="s4">, </span><span class="s2">wrapAsync</span><span class="s4">(</span><span class="s2">iteratee</span><span class="s4">), </span><span class="s2">callback</span><span class="s4">);</span>
<span class="s4">}</span>

<span class="s3">var </span><span class="s2">eachOfLimit$1 </span><span class="s4">= </span><span class="s2">awaitify</span><span class="s4">(</span><span class="s2">eachOfLimit</span><span class="s4">, </span><span class="s7">4</span><span class="s4">);</span>

<span class="s5">// eachOf implementation optimized for array-likes</span>
<span class="s3">function </span><span class="s2">eachOfArrayLike</span><span class="s4">(</span><span class="s2">coll</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
    <span class="s2">callback </span><span class="s4">= </span><span class="s2">once</span><span class="s4">(</span><span class="s2">callback</span><span class="s4">);</span>
    <span class="s3">var </span><span class="s2">index </span><span class="s4">= </span><span class="s7">0</span><span class="s4">,</span>
        <span class="s2">completed </span><span class="s4">= </span><span class="s7">0</span><span class="s4">,</span>
        <span class="s4">{</span><span class="s2">length</span><span class="s4">} = </span><span class="s2">coll</span><span class="s4">,</span>
        <span class="s2">canceled </span><span class="s4">= </span><span class="s3">false</span><span class="s4">;</span>
    <span class="s3">if </span><span class="s4">(</span><span class="s2">length </span><span class="s4">=== </span><span class="s7">0</span><span class="s4">) {</span>
        <span class="s2">callback</span><span class="s4">(</span><span class="s3">null</span><span class="s4">);</span>
    <span class="s4">}</span>

    <span class="s3">function </span><span class="s2">iteratorCallback</span><span class="s4">(</span><span class="s2">err</span><span class="s4">, </span><span class="s2">value</span><span class="s4">) {</span>
        <span class="s3">if </span><span class="s4">(</span><span class="s2">err </span><span class="s4">=== </span><span class="s3">false</span><span class="s4">) {</span>
            <span class="s2">canceled </span><span class="s4">= </span><span class="s3">true</span><span class="s4">;</span>
        <span class="s4">}</span>
        <span class="s3">if </span><span class="s4">(</span><span class="s2">canceled </span><span class="s4">=== </span><span class="s3">true</span><span class="s4">) </span><span class="s3">return</span>
        <span class="s3">if </span><span class="s4">(</span><span class="s2">err</span><span class="s4">) {</span>
            <span class="s2">callback</span><span class="s4">(</span><span class="s2">err</span><span class="s4">);</span>
        <span class="s4">} </span><span class="s3">else if </span><span class="s4">((++</span><span class="s2">completed </span><span class="s4">=== </span><span class="s2">length</span><span class="s4">) || </span><span class="s2">value </span><span class="s4">=== </span><span class="s2">breakLoop</span><span class="s4">) {</span>
            <span class="s2">callback</span><span class="s4">(</span><span class="s3">null</span><span class="s4">);</span>
        <span class="s4">}</span>
    <span class="s4">}</span>

    <span class="s3">for </span><span class="s4">(; </span><span class="s2">index </span><span class="s4">&lt; </span><span class="s2">length</span><span class="s4">; </span><span class="s2">index</span><span class="s4">++) {</span>
        <span class="s2">iteratee</span><span class="s4">(</span><span class="s2">coll</span><span class="s4">[</span><span class="s2">index</span><span class="s4">], </span><span class="s2">index</span><span class="s4">, </span><span class="s2">onlyOnce</span><span class="s4">(</span><span class="s2">iteratorCallback</span><span class="s4">));</span>
    <span class="s4">}</span>
<span class="s4">}</span>

<span class="s5">// a generic version of eachOf which can handle array, object, and iterator cases.</span>
<span class="s3">function </span><span class="s2">eachOfGeneric </span><span class="s4">(</span><span class="s2">coll</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
    <span class="s3">return </span><span class="s2">eachOfLimit$1</span><span class="s4">(</span><span class="s2">coll</span><span class="s4">, </span><span class="s2">Infinity</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">);</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Like [`each`]{</span><span class="s1">@link </span><span class="s0">module:Collections.each}, except that it passes the key (or index) as the second argument</span>
 <span class="s0">* to the iteratee.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">eachOf</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@alias </span><span class="s0">forEachOf</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collection</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s0">[async.each]{</span><span class="s1">@link </span><span class="s0">module:Collections.each}</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{AsyncFunction} iteratee - A function to apply to each</span>
 <span class="s0">* item in `coll`.</span>
 <span class="s0">* The `key` is the item's key, or index in the case of an array.</span>
 <span class="s0">* Invoked with (item, key, callback).</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} [callback] - A callback which is called when all</span>
 <span class="s0">* `iteratee` functions have finished, or an error occurs. Invoked with (err).</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise} a promise, if a callback is omitted</span>
 <span class="s0">* </span><span class="s1">@example</span>
 <span class="s0">*</span>
 <span class="s0">* // dev.json is a file containing a valid json object config for dev environment</span>
 <span class="s0">* // dev.json is a file containing a valid json object config for test environment</span>
 <span class="s0">* // prod.json is a file containing a valid json object config for prod environment</span>
 <span class="s0">* // invalid.json is a file with a malformed json object</span>
 <span class="s0">*</span>
 <span class="s0">* let configs = {}; //global variable</span>
 <span class="s0">* let validConfigFileMap = {dev: 'dev.json', test: 'test.json', prod: 'prod.json'};</span>
 <span class="s0">* let invalidConfigFileMap = {dev: 'dev.json', test: 'test.json', invalid: 'invalid.json'};</span>
 <span class="s0">*</span>
 <span class="s0">* // asynchronous function that reads a json file and parses the contents as json object</span>
 <span class="s0">* function parseFile(file, key, callback) {</span>
 <span class="s0">*     fs.readFile(file, &quot;utf8&quot;, function(err, data) {</span>
 <span class="s0">*         if (err) return calback(err);</span>
 <span class="s0">*         try {</span>
 <span class="s0">*             configs[key] = JSON.parse(data);</span>
 <span class="s0">*         } catch (e) {</span>
 <span class="s0">*             return callback(e);</span>
 <span class="s0">*         }</span>
 <span class="s0">*         callback();</span>
 <span class="s0">*     });</span>
 <span class="s0">* }</span>
 <span class="s0">*</span>
 <span class="s0">* // Using callbacks</span>
 <span class="s0">* async.forEachOf(validConfigFileMap, parseFile, function (err) {</span>
 <span class="s0">*     if (err) {</span>
 <span class="s0">*         console.error(err);</span>
 <span class="s0">*     } else {</span>
 <span class="s0">*         console.log(configs);</span>
 <span class="s0">*         // configs is now a map of JSON data, e.g.</span>
 <span class="s0">*         // { dev: //parsed dev.json, test: //parsed test.json, prod: //parsed prod.json}</span>
 <span class="s0">*     }</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* //Error handing</span>
 <span class="s0">* async.forEachOf(invalidConfigFileMap, parseFile, function (err) {</span>
 <span class="s0">*     if (err) {</span>
 <span class="s0">*         console.error(err);</span>
 <span class="s0">*         // JSON parse error exception</span>
 <span class="s0">*     } else {</span>
 <span class="s0">*         console.log(configs);</span>
 <span class="s0">*     }</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* // Using Promises</span>
 <span class="s0">* async.forEachOf(validConfigFileMap, parseFile)</span>
 <span class="s0">* .then( () =&gt; {</span>
 <span class="s0">*     console.log(configs);</span>
 <span class="s0">*     // configs is now a map of JSON data, e.g.</span>
 <span class="s0">*     // { dev: //parsed dev.json, test: //parsed test.json, prod: //parsed prod.json}</span>
 <span class="s0">* }).catch( err =&gt; {</span>
 <span class="s0">*     console.error(err);</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* //Error handing</span>
 <span class="s0">* async.forEachOf(invalidConfigFileMap, parseFile)</span>
 <span class="s0">* .then( () =&gt; {</span>
 <span class="s0">*     console.log(configs);</span>
 <span class="s0">* }).catch( err =&gt; {</span>
 <span class="s0">*     console.error(err);</span>
 <span class="s0">*     // JSON parse error exception</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* // Using async/await</span>
 <span class="s0">* async () =&gt; {</span>
 <span class="s0">*     try {</span>
 <span class="s0">*         let result = await async.forEachOf(validConfigFileMap, parseFile);</span>
 <span class="s0">*         console.log(configs);</span>
 <span class="s0">*         // configs is now a map of JSON data, e.g.</span>
 <span class="s0">*         // { dev: //parsed dev.json, test: //parsed test.json, prod: //parsed prod.json}</span>
 <span class="s0">*     }</span>
 <span class="s0">*     catch (err) {</span>
 <span class="s0">*         console.log(err);</span>
 <span class="s0">*     }</span>
 <span class="s0">* }</span>
 <span class="s0">*</span>
 <span class="s0">* //Error handing</span>
 <span class="s0">* async () =&gt; {</span>
 <span class="s0">*     try {</span>
 <span class="s0">*         let result = await async.forEachOf(invalidConfigFileMap, parseFile);</span>
 <span class="s0">*         console.log(configs);</span>
 <span class="s0">*     }</span>
 <span class="s0">*     catch (err) {</span>
 <span class="s0">*         console.log(err);</span>
 <span class="s0">*         // JSON parse error exception</span>
 <span class="s0">*     }</span>
 <span class="s0">* }</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">eachOf</span><span class="s4">(</span><span class="s2">coll</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
    <span class="s3">var </span><span class="s2">eachOfImplementation </span><span class="s4">= </span><span class="s2">isArrayLike</span><span class="s4">(</span><span class="s2">coll</span><span class="s4">) ? </span><span class="s2">eachOfArrayLike </span><span class="s4">: </span><span class="s2">eachOfGeneric</span><span class="s4">;</span>
    <span class="s3">return </span><span class="s2">eachOfImplementation</span><span class="s4">(</span><span class="s2">coll</span><span class="s4">, </span><span class="s2">wrapAsync</span><span class="s4">(</span><span class="s2">iteratee</span><span class="s4">), </span><span class="s2">callback</span><span class="s4">);</span>
<span class="s4">}</span>

<span class="s3">var </span><span class="s2">eachOf$1 </span><span class="s4">= </span><span class="s2">awaitify</span><span class="s4">(</span><span class="s2">eachOf</span><span class="s4">, </span><span class="s7">3</span><span class="s4">);</span>

<span class="s0">/**</span>
 <span class="s0">* Produces a new collection of values by mapping each value in `coll` through</span>
 <span class="s0">* the `iteratee` function. The `iteratee` is called with an item from `coll`</span>
 <span class="s0">* and a callback for when it has finished processing. Each of these callbacks</span>
 <span class="s0">* takes 2 arguments: an `error`, and the transformed item from `coll`. If</span>
 <span class="s0">* `iteratee` passes an error to its callback, the main `callback` (for the</span>
 <span class="s0">* `map` function) is immediately called with the error.</span>
 <span class="s0">*</span>
 <span class="s0">* Note, that since this function applies the `iteratee` to each item in</span>
 <span class="s0">* parallel, there is no guarantee that the `iteratee` functions will complete</span>
 <span class="s0">* in order. However, the results array will be in the same order as the</span>
 <span class="s0">* original `coll`.</span>
 <span class="s0">*</span>
 <span class="s0">* If `map` is passed an Object, the results will be an Array.  The results</span>
 <span class="s0">* will roughly be in the order of the original Objects' keys (but this can</span>
 <span class="s0">* vary across JavaScript engines).</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">map</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collection</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{AsyncFunction} iteratee - An async function to apply to each item in</span>
 <span class="s0">* `coll`.</span>
 <span class="s0">* The iteratee should complete with the transformed item.</span>
 <span class="s0">* Invoked with (item, callback).</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} [callback] - A callback which is called when all `iteratee`</span>
 <span class="s0">* functions have finished, or an error occurs. Results is an Array of the</span>
 <span class="s0">* transformed items from the `coll`. Invoked with (err, results).</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise} a promise, if no callback is passed</span>
 <span class="s0">* </span><span class="s1">@example</span>
 <span class="s0">*</span>
 <span class="s0">* // file1.txt is a file that is 1000 bytes in size</span>
 <span class="s0">* // file2.txt is a file that is 2000 bytes in size</span>
 <span class="s0">* // file3.txt is a file that is 3000 bytes in size</span>
 <span class="s0">* // file4.txt does not exist</span>
 <span class="s0">*</span>
 <span class="s0">* const fileList = ['file1.txt','file2.txt','file3.txt'];</span>
 <span class="s0">* const withMissingFileList = ['file1.txt','file2.txt','file4.txt'];</span>
 <span class="s0">*</span>
 <span class="s0">* // asynchronous function that returns the file size in bytes</span>
 <span class="s0">* function getFileSizeInBytes(file, callback) {</span>
 <span class="s0">*     fs.stat(file, function(err, stat) {</span>
 <span class="s0">*         if (err) {</span>
 <span class="s0">*             return callback(err);</span>
 <span class="s0">*         }</span>
 <span class="s0">*         callback(null, stat.size);</span>
 <span class="s0">*     });</span>
 <span class="s0">* }</span>
 <span class="s0">*</span>
 <span class="s0">* // Using callbacks</span>
 <span class="s0">* async.map(fileList, getFileSizeInBytes, function(err, results) {</span>
 <span class="s0">*     if (err) {</span>
 <span class="s0">*         console.log(err);</span>
 <span class="s0">*     } else {</span>
 <span class="s0">*         console.log(results);</span>
 <span class="s0">*         // results is now an array of the file size in bytes for each file, e.g.</span>
 <span class="s0">*         // [ 1000, 2000, 3000]</span>
 <span class="s0">*     }</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* // Error Handling</span>
 <span class="s0">* async.map(withMissingFileList, getFileSizeInBytes, function(err, results) {</span>
 <span class="s0">*     if (err) {</span>
 <span class="s0">*         console.log(err);</span>
 <span class="s0">*         // [ Error: ENOENT: no such file or directory ]</span>
 <span class="s0">*     } else {</span>
 <span class="s0">*         console.log(results);</span>
 <span class="s0">*     }</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* // Using Promises</span>
 <span class="s0">* async.map(fileList, getFileSizeInBytes)</span>
 <span class="s0">* .then( results =&gt; {</span>
 <span class="s0">*     console.log(results);</span>
 <span class="s0">*     // results is now an array of the file size in bytes for each file, e.g.</span>
 <span class="s0">*     // [ 1000, 2000, 3000]</span>
 <span class="s0">* }).catch( err =&gt; {</span>
 <span class="s0">*     console.log(err);</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* // Error Handling</span>
 <span class="s0">* async.map(withMissingFileList, getFileSizeInBytes)</span>
 <span class="s0">* .then( results =&gt; {</span>
 <span class="s0">*     console.log(results);</span>
 <span class="s0">* }).catch( err =&gt; {</span>
 <span class="s0">*     console.log(err);</span>
 <span class="s0">*     // [ Error: ENOENT: no such file or directory ]</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* // Using async/await</span>
 <span class="s0">* async () =&gt; {</span>
 <span class="s0">*     try {</span>
 <span class="s0">*         let results = await async.map(fileList, getFileSizeInBytes);</span>
 <span class="s0">*         console.log(results);</span>
 <span class="s0">*         // results is now an array of the file size in bytes for each file, e.g.</span>
 <span class="s0">*         // [ 1000, 2000, 3000]</span>
 <span class="s0">*     }</span>
 <span class="s0">*     catch (err) {</span>
 <span class="s0">*         console.log(err);</span>
 <span class="s0">*     }</span>
 <span class="s0">* }</span>
 <span class="s0">*</span>
 <span class="s0">* // Error Handling</span>
 <span class="s0">* async () =&gt; {</span>
 <span class="s0">*     try {</span>
 <span class="s0">*         let results = await async.map(withMissingFileList, getFileSizeInBytes);</span>
 <span class="s0">*         console.log(results);</span>
 <span class="s0">*     }</span>
 <span class="s0">*     catch (err) {</span>
 <span class="s0">*         console.log(err);</span>
 <span class="s0">*         // [ Error: ENOENT: no such file or directory ]</span>
 <span class="s0">*     }</span>
 <span class="s0">* }</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">map </span><span class="s4">(</span><span class="s2">coll</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
    <span class="s3">return </span><span class="s2">_asyncMap</span><span class="s4">(</span><span class="s2">eachOf$1</span><span class="s4">, </span><span class="s2">coll</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">)</span>
<span class="s4">}</span>
<span class="s3">var </span><span class="s2">map$1 </span><span class="s4">= </span><span class="s2">awaitify</span><span class="s4">(</span><span class="s2">map</span><span class="s4">, </span><span class="s7">3</span><span class="s4">);</span>

<span class="s0">/**</span>
 <span class="s0">* Applies the provided arguments to each function in the array, calling</span>
 <span class="s0">* `callback` after all functions have completed. If you only provide the first</span>
 <span class="s0">* argument, `fns`, then it will return a function which lets you pass in the</span>
 <span class="s0">* arguments as if it were a single function call. If more arguments are</span>
 <span class="s0">* provided, `callback` is required while `args` is still optional. The results</span>
 <span class="s0">* for each of the applied async functions are passed to the final callback</span>
 <span class="s0">* as an array.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">applyEach</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:ControlFlow</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Control Flow</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Array|Iterable|AsyncIterable|Object} fns - A collection of {</span><span class="s1">@link </span><span class="s0">AsyncFunction}s</span>
 <span class="s0">* to all call with the same arguments</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{...*} [args] - any number of separate arguments to pass to the</span>
 <span class="s0">* function.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} [callback] - the final argument should be the callback,</span>
 <span class="s0">* called when all functions have completed processing.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{AsyncFunction} - Returns a function that takes no args other than</span>
 <span class="s0">* an optional callback, that is the result of applying the `args` to each</span>
 <span class="s0">* of the functions.</span>
 <span class="s0">* </span><span class="s1">@example</span>
 <span class="s0">*</span>
 <span class="s0">* const appliedFn = async.applyEach([enableSearch, updateSchema], 'bucket')</span>
 <span class="s0">*</span>
 <span class="s0">* appliedFn((err, results) =&gt; {</span>
 <span class="s0">*     // results[0] is the results for `enableSearch`</span>
 <span class="s0">*     // results[1] is the results for `updateSchema`</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* // partial application example:</span>
 <span class="s0">* async.each(</span>
 <span class="s0">*     buckets,</span>
 <span class="s0">*     async (bucket) =&gt; async.applyEach([enableSearch, updateSchema], bucket)(),</span>
 <span class="s0">*     callback</span>
 <span class="s0">* );</span>
 <span class="s0">*/</span>
<span class="s3">var </span><span class="s2">applyEach </span><span class="s4">= </span><span class="s2">applyEach$1</span><span class="s4">(</span><span class="s2">map$1</span><span class="s4">);</span>

<span class="s0">/**</span>
 <span class="s0">* The same as [`eachOf`]{</span><span class="s1">@link </span><span class="s0">module:Collections.eachOf} but runs only a single async operation at a time.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">eachOfSeries</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s0">[async.eachOf]{</span><span class="s1">@link </span><span class="s0">module:Collections.eachOf}</span>
 <span class="s0">* </span><span class="s1">@alias </span><span class="s0">forEachOfSeries</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collection</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{AsyncFunction} iteratee - An async function to apply to each item in</span>
 <span class="s0">* `coll`.</span>
 <span class="s0">* Invoked with (item, key, callback).</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} [callback] - A callback which is called when all `iteratee`</span>
 <span class="s0">* functions have finished, or an error occurs. Invoked with (err).</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise} a promise, if a callback is omitted</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">eachOfSeries</span><span class="s4">(</span><span class="s2">coll</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
    <span class="s3">return </span><span class="s2">eachOfLimit$1</span><span class="s4">(</span><span class="s2">coll</span><span class="s4">, </span><span class="s7">1</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">)</span>
<span class="s4">}</span>
<span class="s3">var </span><span class="s2">eachOfSeries$1 </span><span class="s4">= </span><span class="s2">awaitify</span><span class="s4">(</span><span class="s2">eachOfSeries</span><span class="s4">, </span><span class="s7">3</span><span class="s4">);</span>

<span class="s0">/**</span>
 <span class="s0">* The same as [`map`]{</span><span class="s1">@link </span><span class="s0">module:Collections.map} but runs only a single async operation at a time.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">mapSeries</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s0">[async.map]{</span><span class="s1">@link </span><span class="s0">module:Collections.map}</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collection</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{AsyncFunction} iteratee - An async function to apply to each item in</span>
 <span class="s0">* `coll`.</span>
 <span class="s0">* The iteratee should complete with the transformed item.</span>
 <span class="s0">* Invoked with (item, callback).</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} [callback] - A callback which is called when all `iteratee`</span>
 <span class="s0">* functions have finished, or an error occurs. Results is an array of the</span>
 <span class="s0">* transformed items from the `coll`. Invoked with (err, results).</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise} a promise, if no callback is passed</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">mapSeries </span><span class="s4">(</span><span class="s2">coll</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
    <span class="s3">return </span><span class="s2">_asyncMap</span><span class="s4">(</span><span class="s2">eachOfSeries$1</span><span class="s4">, </span><span class="s2">coll</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">)</span>
<span class="s4">}</span>
<span class="s3">var </span><span class="s2">mapSeries$1 </span><span class="s4">= </span><span class="s2">awaitify</span><span class="s4">(</span><span class="s2">mapSeries</span><span class="s4">, </span><span class="s7">3</span><span class="s4">);</span>

<span class="s0">/**</span>
 <span class="s0">* The same as [`applyEach`]{</span><span class="s1">@link </span><span class="s0">module:ControlFlow.applyEach} but runs only a single async operation at a time.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">applyEachSeries</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:ControlFlow</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s0">[async.applyEach]{</span><span class="s1">@link </span><span class="s0">module:ControlFlow.applyEach}</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Control Flow</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Array|Iterable|AsyncIterable|Object} fns - A collection of {</span><span class="s1">@link </span><span class="s0">AsyncFunction}s to all</span>
 <span class="s0">* call with the same arguments</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{...*} [args] - any number of separate arguments to pass to the</span>
 <span class="s0">* function.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} [callback] - the final argument should be the callback,</span>
 <span class="s0">* called when all functions have completed processing.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{AsyncFunction} - A function, that when called, is the result of</span>
 <span class="s0">* appling the `args` to the list of functions.  It takes no args, other than</span>
 <span class="s0">* a callback.</span>
 <span class="s0">*/</span>
<span class="s3">var </span><span class="s2">applyEachSeries </span><span class="s4">= </span><span class="s2">applyEach$1</span><span class="s4">(</span><span class="s2">mapSeries$1</span><span class="s4">);</span>

<span class="s3">const </span><span class="s2">PROMISE_SYMBOL </span><span class="s4">= </span><span class="s2">Symbol</span><span class="s4">(</span><span class="s6">'promiseCallback'</span><span class="s4">);</span>

<span class="s3">function </span><span class="s2">promiseCallback </span><span class="s4">() {</span>
    <span class="s3">let </span><span class="s2">resolve</span><span class="s4">, </span><span class="s2">reject</span><span class="s4">;</span>
    <span class="s3">function </span><span class="s2">callback </span><span class="s4">(</span><span class="s2">err</span><span class="s4">, </span><span class="s2">...args</span><span class="s4">) {</span>
        <span class="s3">if </span><span class="s4">(</span><span class="s2">err</span><span class="s4">) </span><span class="s3">return </span><span class="s2">reject</span><span class="s4">(</span><span class="s2">err</span><span class="s4">)</span>
        <span class="s2">resolve</span><span class="s4">(</span><span class="s2">args</span><span class="s4">.</span><span class="s2">length </span><span class="s4">&gt; </span><span class="s7">1 </span><span class="s4">? </span><span class="s2">args </span><span class="s4">: </span><span class="s2">args</span><span class="s4">[</span><span class="s7">0</span><span class="s4">]);</span>
    <span class="s4">}</span>

    <span class="s2">callback</span><span class="s4">[</span><span class="s2">PROMISE_SYMBOL</span><span class="s4">] = </span><span class="s3">new </span><span class="s2">Promise</span><span class="s4">((</span><span class="s2">res</span><span class="s4">, </span><span class="s2">rej</span><span class="s4">) =&gt; {</span>
        <span class="s2">resolve </span><span class="s4">= </span><span class="s2">res</span><span class="s4">,</span>
        <span class="s2">reject </span><span class="s4">= </span><span class="s2">rej</span><span class="s4">;</span>
    <span class="s4">});</span>

    <span class="s3">return </span><span class="s2">callback</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Determines the best order for running the {</span><span class="s1">@link </span><span class="s0">AsyncFunction}s in `tasks`, based on</span>
 <span class="s0">* their requirements. Each function can optionally depend on other functions</span>
 <span class="s0">* being completed first, and each function is run as soon as its requirements</span>
 <span class="s0">* are satisfied.</span>
 <span class="s0">*</span>
 <span class="s0">* If any of the {</span><span class="s1">@link </span><span class="s0">AsyncFunction}s pass an error to their callback, the `auto` sequence</span>
 <span class="s0">* will stop. Further tasks will not execute (so any other functions depending</span>
 <span class="s0">* on it will not run), and the main `callback` is immediately called with the</span>
 <span class="s0">* error.</span>
 <span class="s0">*</span>
 <span class="s0">* {</span><span class="s1">@link </span><span class="s0">AsyncFunction}s also receive an object containing the results of functions which</span>
 <span class="s0">* have completed so far as the first argument, if they have dependencies. If a</span>
 <span class="s0">* task function has no dependencies, it will only be passed a callback.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">auto</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:ControlFlow</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Control Flow</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Object} tasks - An object. Each of its properties is either a</span>
 <span class="s0">* function or an array of requirements, with the {</span><span class="s1">@link </span><span class="s0">AsyncFunction} itself the last item</span>
 <span class="s0">* in the array. The object's key of a property serves as the name of the task</span>
 <span class="s0">* defined by that property, i.e. can be used when specifying requirements for</span>
 <span class="s0">* other tasks. The function receives one or two arguments:</span>
 <span class="s0">* * a `results` object, containing the results of the previously executed</span>
 <span class="s0">*   functions, only passed if the task has any dependencies,</span>
 <span class="s0">* * a `callback(err, result)` function, which must be called when finished,</span>
 <span class="s0">*   passing an `error` (which can be `null`) and the result of the function's</span>
 <span class="s0">*   execution.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{number} [concurrency=Infinity] - An optional `integer` for</span>
 <span class="s0">* determining the maximum number of tasks that can be run in parallel. By</span>
 <span class="s0">* default, as many as possible.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} [callback] - An optional callback which is called when all</span>
 <span class="s0">* the tasks have been completed. It receives the `err` argument if any `tasks`</span>
 <span class="s0">* pass an error to their callback. Results are always returned; however, if an</span>
 <span class="s0">* error occurs, no further `tasks` will be performed, and the results object</span>
 <span class="s0">* will only contain partial results. Invoked with (err, results).</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise} a promise, if a callback is not passed</span>
 <span class="s0">* </span><span class="s1">@example</span>
 <span class="s0">*</span>
 <span class="s0">* //Using Callbacks</span>
 <span class="s0">* async.auto({</span>
 <span class="s0">*     get_data: function(callback) {</span>
 <span class="s0">*         // async code to get some data</span>
 <span class="s0">*         callback(null, 'data', 'converted to array');</span>
 <span class="s0">*     },</span>
 <span class="s0">*     make_folder: function(callback) {</span>
 <span class="s0">*         // async code to create a directory to store a file in</span>
 <span class="s0">*         // this is run at the same time as getting the data</span>
 <span class="s0">*         callback(null, 'folder');</span>
 <span class="s0">*     },</span>
 <span class="s0">*     write_file: ['get_data', 'make_folder', function(results, callback) {</span>
 <span class="s0">*         // once there is some data and the directory exists,</span>
 <span class="s0">*         // write the data to a file in the directory</span>
 <span class="s0">*         callback(null, 'filename');</span>
 <span class="s0">*     }],</span>
 <span class="s0">*     email_link: ['write_file', function(results, callback) {</span>
 <span class="s0">*         // once the file is written let's email a link to it...</span>
 <span class="s0">*         callback(null, {'file':results.write_file, 'email':'user@example.com'});</span>
 <span class="s0">*     }]</span>
 <span class="s0">* }, function(err, results) {</span>
 <span class="s0">*     if (err) {</span>
 <span class="s0">*         console.log('err = ', err);</span>
 <span class="s0">*     }</span>
 <span class="s0">*     console.log('results = ', results);</span>
 <span class="s0">*     // results = {</span>
 <span class="s0">*     //     get_data: ['data', 'converted to array']</span>
 <span class="s0">*     //     make_folder; 'folder',</span>
 <span class="s0">*     //     write_file: 'filename'</span>
 <span class="s0">*     //     email_link: { file: 'filename', email: 'user@example.com' }</span>
 <span class="s0">*     // }</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* //Using Promises</span>
 <span class="s0">* async.auto({</span>
 <span class="s0">*     get_data: function(callback) {</span>
 <span class="s0">*         console.log('in get_data');</span>
 <span class="s0">*         // async code to get some data</span>
 <span class="s0">*         callback(null, 'data', 'converted to array');</span>
 <span class="s0">*     },</span>
 <span class="s0">*     make_folder: function(callback) {</span>
 <span class="s0">*         console.log('in make_folder');</span>
 <span class="s0">*         // async code to create a directory to store a file in</span>
 <span class="s0">*         // this is run at the same time as getting the data</span>
 <span class="s0">*         callback(null, 'folder');</span>
 <span class="s0">*     },</span>
 <span class="s0">*     write_file: ['get_data', 'make_folder', function(results, callback) {</span>
 <span class="s0">*         // once there is some data and the directory exists,</span>
 <span class="s0">*         // write the data to a file in the directory</span>
 <span class="s0">*         callback(null, 'filename');</span>
 <span class="s0">*     }],</span>
 <span class="s0">*     email_link: ['write_file', function(results, callback) {</span>
 <span class="s0">*         // once the file is written let's email a link to it...</span>
 <span class="s0">*         callback(null, {'file':results.write_file, 'email':'user@example.com'});</span>
 <span class="s0">*     }]</span>
 <span class="s0">* }).then(results =&gt; {</span>
 <span class="s0">*     console.log('results = ', results);</span>
 <span class="s0">*     // results = {</span>
 <span class="s0">*     //     get_data: ['data', 'converted to array']</span>
 <span class="s0">*     //     make_folder; 'folder',</span>
 <span class="s0">*     //     write_file: 'filename'</span>
 <span class="s0">*     //     email_link: { file: 'filename', email: 'user@example.com' }</span>
 <span class="s0">*     // }</span>
 <span class="s0">* }).catch(err =&gt; {</span>
 <span class="s0">*     console.log('err = ', err);</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* //Using async/await</span>
 <span class="s0">* async () =&gt; {</span>
 <span class="s0">*     try {</span>
 <span class="s0">*         let results = await async.auto({</span>
 <span class="s0">*             get_data: function(callback) {</span>
 <span class="s0">*                 // async code to get some data</span>
 <span class="s0">*                 callback(null, 'data', 'converted to array');</span>
 <span class="s0">*             },</span>
 <span class="s0">*             make_folder: function(callback) {</span>
 <span class="s0">*                 // async code to create a directory to store a file in</span>
 <span class="s0">*                 // this is run at the same time as getting the data</span>
 <span class="s0">*                 callback(null, 'folder');</span>
 <span class="s0">*             },</span>
 <span class="s0">*             write_file: ['get_data', 'make_folder', function(results, callback) {</span>
 <span class="s0">*                 // once there is some data and the directory exists,</span>
 <span class="s0">*                 // write the data to a file in the directory</span>
 <span class="s0">*                 callback(null, 'filename');</span>
 <span class="s0">*             }],</span>
 <span class="s0">*             email_link: ['write_file', function(results, callback) {</span>
 <span class="s0">*                 // once the file is written let's email a link to it...</span>
 <span class="s0">*                 callback(null, {'file':results.write_file, 'email':'user@example.com'});</span>
 <span class="s0">*             }]</span>
 <span class="s0">*         });</span>
 <span class="s0">*         console.log('results = ', results);</span>
 <span class="s0">*         // results = {</span>
 <span class="s0">*         //     get_data: ['data', 'converted to array']</span>
 <span class="s0">*         //     make_folder; 'folder',</span>
 <span class="s0">*         //     write_file: 'filename'</span>
 <span class="s0">*         //     email_link: { file: 'filename', email: 'user@example.com' }</span>
 <span class="s0">*         // }</span>
 <span class="s0">*     }</span>
 <span class="s0">*     catch (err) {</span>
 <span class="s0">*         console.log(err);</span>
 <span class="s0">*     }</span>
 <span class="s0">* }</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">auto</span><span class="s4">(</span><span class="s2">tasks</span><span class="s4">, </span><span class="s2">concurrency</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
    <span class="s3">if </span><span class="s4">(</span><span class="s3">typeof </span><span class="s2">concurrency </span><span class="s4">!== </span><span class="s6">'number'</span><span class="s4">) {</span>
        <span class="s5">// concurrency is optional, shift the args.</span>
        <span class="s2">callback </span><span class="s4">= </span><span class="s2">concurrency</span><span class="s4">;</span>
        <span class="s2">concurrency </span><span class="s4">= </span><span class="s3">null</span><span class="s4">;</span>
    <span class="s4">}</span>
    <span class="s2">callback </span><span class="s4">= </span><span class="s2">once</span><span class="s4">(</span><span class="s2">callback </span><span class="s4">|| </span><span class="s2">promiseCallback</span><span class="s4">());</span>
    <span class="s3">var </span><span class="s2">numTasks </span><span class="s4">= </span><span class="s2">Object</span><span class="s4">.</span><span class="s2">keys</span><span class="s4">(</span><span class="s2">tasks</span><span class="s4">).</span><span class="s2">length</span><span class="s4">;</span>
    <span class="s3">if </span><span class="s4">(!</span><span class="s2">numTasks</span><span class="s4">) {</span>
        <span class="s3">return </span><span class="s2">callback</span><span class="s4">(</span><span class="s3">null</span><span class="s4">);</span>
    <span class="s4">}</span>
    <span class="s3">if </span><span class="s4">(!</span><span class="s2">concurrency</span><span class="s4">) {</span>
        <span class="s2">concurrency </span><span class="s4">= </span><span class="s2">numTasks</span><span class="s4">;</span>
    <span class="s4">}</span>

    <span class="s3">var </span><span class="s2">results </span><span class="s4">= {};</span>
    <span class="s3">var </span><span class="s2">runningTasks </span><span class="s4">= </span><span class="s7">0</span><span class="s4">;</span>
    <span class="s3">var </span><span class="s2">canceled </span><span class="s4">= </span><span class="s3">false</span><span class="s4">;</span>
    <span class="s3">var </span><span class="s2">hasError </span><span class="s4">= </span><span class="s3">false</span><span class="s4">;</span>

    <span class="s3">var </span><span class="s2">listeners </span><span class="s4">= </span><span class="s2">Object</span><span class="s4">.</span><span class="s2">create</span><span class="s4">(</span><span class="s3">null</span><span class="s4">);</span>

    <span class="s3">var </span><span class="s2">readyTasks </span><span class="s4">= [];</span>

    <span class="s5">// for cycle detection:</span>
    <span class="s3">var </span><span class="s2">readyToCheck </span><span class="s4">= []; </span><span class="s5">// tasks that have been identified as reachable</span>
    <span class="s5">// without the possibility of returning to an ancestor task</span>
    <span class="s3">var </span><span class="s2">uncheckedDependencies </span><span class="s4">= {};</span>

    <span class="s2">Object</span><span class="s4">.</span><span class="s2">keys</span><span class="s4">(</span><span class="s2">tasks</span><span class="s4">).</span><span class="s2">forEach</span><span class="s4">(</span><span class="s2">key </span><span class="s4">=&gt; {</span>
        <span class="s3">var </span><span class="s2">task </span><span class="s4">= </span><span class="s2">tasks</span><span class="s4">[</span><span class="s2">key</span><span class="s4">];</span>
        <span class="s3">if </span><span class="s4">(!</span><span class="s2">Array</span><span class="s4">.</span><span class="s2">isArray</span><span class="s4">(</span><span class="s2">task</span><span class="s4">)) {</span>
            <span class="s5">// no dependencies</span>
            <span class="s2">enqueueTask</span><span class="s4">(</span><span class="s2">key</span><span class="s4">, [</span><span class="s2">task</span><span class="s4">]);</span>
            <span class="s2">readyToCheck</span><span class="s4">.</span><span class="s2">push</span><span class="s4">(</span><span class="s2">key</span><span class="s4">);</span>
            <span class="s3">return</span><span class="s4">;</span>
        <span class="s4">}</span>

        <span class="s3">var </span><span class="s2">dependencies </span><span class="s4">= </span><span class="s2">task</span><span class="s4">.</span><span class="s2">slice</span><span class="s4">(</span><span class="s7">0</span><span class="s4">, </span><span class="s2">task</span><span class="s4">.</span><span class="s2">length </span><span class="s4">- </span><span class="s7">1</span><span class="s4">);</span>
        <span class="s3">var </span><span class="s2">remainingDependencies </span><span class="s4">= </span><span class="s2">dependencies</span><span class="s4">.</span><span class="s2">length</span><span class="s4">;</span>
        <span class="s3">if </span><span class="s4">(</span><span class="s2">remainingDependencies </span><span class="s4">=== </span><span class="s7">0</span><span class="s4">) {</span>
            <span class="s2">enqueueTask</span><span class="s4">(</span><span class="s2">key</span><span class="s4">, </span><span class="s2">task</span><span class="s4">);</span>
            <span class="s2">readyToCheck</span><span class="s4">.</span><span class="s2">push</span><span class="s4">(</span><span class="s2">key</span><span class="s4">);</span>
            <span class="s3">return</span><span class="s4">;</span>
        <span class="s4">}</span>
        <span class="s2">uncheckedDependencies</span><span class="s4">[</span><span class="s2">key</span><span class="s4">] = </span><span class="s2">remainingDependencies</span><span class="s4">;</span>

        <span class="s2">dependencies</span><span class="s4">.</span><span class="s2">forEach</span><span class="s4">(</span><span class="s2">dependencyName </span><span class="s4">=&gt; {</span>
            <span class="s3">if </span><span class="s4">(!</span><span class="s2">tasks</span><span class="s4">[</span><span class="s2">dependencyName</span><span class="s4">]) {</span>
                <span class="s3">throw new </span><span class="s2">Error</span><span class="s4">(</span><span class="s6">'async.auto task `' </span><span class="s4">+ </span><span class="s2">key </span><span class="s4">+</span>
                    <span class="s6">'` has a non-existent dependency `' </span><span class="s4">+</span>
                    <span class="s2">dependencyName </span><span class="s4">+ </span><span class="s6">'` in ' </span><span class="s4">+</span>
                    <span class="s2">dependencies</span><span class="s4">.</span><span class="s2">join</span><span class="s4">(</span><span class="s6">', '</span><span class="s4">));</span>
            <span class="s4">}</span>
            <span class="s2">addListener</span><span class="s4">(</span><span class="s2">dependencyName</span><span class="s4">, () =&gt; {</span>
                <span class="s2">remainingDependencies</span><span class="s4">--;</span>
                <span class="s3">if </span><span class="s4">(</span><span class="s2">remainingDependencies </span><span class="s4">=== </span><span class="s7">0</span><span class="s4">) {</span>
                    <span class="s2">enqueueTask</span><span class="s4">(</span><span class="s2">key</span><span class="s4">, </span><span class="s2">task</span><span class="s4">);</span>
                <span class="s4">}</span>
            <span class="s4">});</span>
        <span class="s4">});</span>
    <span class="s4">});</span>

    <span class="s2">checkForDeadlocks</span><span class="s4">();</span>
    <span class="s2">processQueue</span><span class="s4">();</span>

    <span class="s3">function </span><span class="s2">enqueueTask</span><span class="s4">(</span><span class="s2">key</span><span class="s4">, </span><span class="s2">task</span><span class="s4">) {</span>
        <span class="s2">readyTasks</span><span class="s4">.</span><span class="s2">push</span><span class="s4">(() =&gt; </span><span class="s2">runTask</span><span class="s4">(</span><span class="s2">key</span><span class="s4">, </span><span class="s2">task</span><span class="s4">));</span>
    <span class="s4">}</span>

    <span class="s3">function </span><span class="s2">processQueue</span><span class="s4">() {</span>
        <span class="s3">if </span><span class="s4">(</span><span class="s2">canceled</span><span class="s4">) </span><span class="s3">return</span>
        <span class="s3">if </span><span class="s4">(</span><span class="s2">readyTasks</span><span class="s4">.</span><span class="s2">length </span><span class="s4">=== </span><span class="s7">0 </span><span class="s4">&amp;&amp; </span><span class="s2">runningTasks </span><span class="s4">=== </span><span class="s7">0</span><span class="s4">) {</span>
            <span class="s3">return </span><span class="s2">callback</span><span class="s4">(</span><span class="s3">null</span><span class="s4">, </span><span class="s2">results</span><span class="s4">);</span>
        <span class="s4">}</span>
        <span class="s3">while</span><span class="s4">(</span><span class="s2">readyTasks</span><span class="s4">.</span><span class="s2">length </span><span class="s4">&amp;&amp; </span><span class="s2">runningTasks </span><span class="s4">&lt; </span><span class="s2">concurrency</span><span class="s4">) {</span>
            <span class="s3">var </span><span class="s2">run </span><span class="s4">= </span><span class="s2">readyTasks</span><span class="s4">.</span><span class="s2">shift</span><span class="s4">();</span>
            <span class="s2">run</span><span class="s4">();</span>
        <span class="s4">}</span>

    <span class="s4">}</span>

    <span class="s3">function </span><span class="s2">addListener</span><span class="s4">(</span><span class="s2">taskName</span><span class="s4">, </span><span class="s2">fn</span><span class="s4">) {</span>
        <span class="s3">var </span><span class="s2">taskListeners </span><span class="s4">= </span><span class="s2">listeners</span><span class="s4">[</span><span class="s2">taskName</span><span class="s4">];</span>
        <span class="s3">if </span><span class="s4">(!</span><span class="s2">taskListeners</span><span class="s4">) {</span>
            <span class="s2">taskListeners </span><span class="s4">= </span><span class="s2">listeners</span><span class="s4">[</span><span class="s2">taskName</span><span class="s4">] = [];</span>
        <span class="s4">}</span>

        <span class="s2">taskListeners</span><span class="s4">.</span><span class="s2">push</span><span class="s4">(</span><span class="s2">fn</span><span class="s4">);</span>
    <span class="s4">}</span>

    <span class="s3">function </span><span class="s2">taskComplete</span><span class="s4">(</span><span class="s2">taskName</span><span class="s4">) {</span>
        <span class="s3">var </span><span class="s2">taskListeners </span><span class="s4">= </span><span class="s2">listeners</span><span class="s4">[</span><span class="s2">taskName</span><span class="s4">] || [];</span>
        <span class="s2">taskListeners</span><span class="s4">.</span><span class="s2">forEach</span><span class="s4">(</span><span class="s2">fn </span><span class="s4">=&gt; </span><span class="s2">fn</span><span class="s4">());</span>
        <span class="s2">processQueue</span><span class="s4">();</span>
    <span class="s4">}</span>


    <span class="s3">function </span><span class="s2">runTask</span><span class="s4">(</span><span class="s2">key</span><span class="s4">, </span><span class="s2">task</span><span class="s4">) {</span>
        <span class="s3">if </span><span class="s4">(</span><span class="s2">hasError</span><span class="s4">) </span><span class="s3">return</span><span class="s4">;</span>

        <span class="s3">var </span><span class="s2">taskCallback </span><span class="s4">= </span><span class="s2">onlyOnce</span><span class="s4">((</span><span class="s2">err</span><span class="s4">, </span><span class="s2">...result</span><span class="s4">) =&gt; {</span>
            <span class="s2">runningTasks</span><span class="s4">--;</span>
            <span class="s3">if </span><span class="s4">(</span><span class="s2">err </span><span class="s4">=== </span><span class="s3">false</span><span class="s4">) {</span>
                <span class="s2">canceled </span><span class="s4">= </span><span class="s3">true</span><span class="s4">;</span>
                <span class="s3">return</span>
            <span class="s4">}</span>
            <span class="s3">if </span><span class="s4">(</span><span class="s2">result</span><span class="s4">.</span><span class="s2">length </span><span class="s4">&lt; </span><span class="s7">2</span><span class="s4">) {</span>
                <span class="s4">[</span><span class="s2">result</span><span class="s4">] = </span><span class="s2">result</span><span class="s4">;</span>
            <span class="s4">}</span>
            <span class="s3">if </span><span class="s4">(</span><span class="s2">err</span><span class="s4">) {</span>
                <span class="s3">var </span><span class="s2">safeResults </span><span class="s4">= {};</span>
                <span class="s2">Object</span><span class="s4">.</span><span class="s2">keys</span><span class="s4">(</span><span class="s2">results</span><span class="s4">).</span><span class="s2">forEach</span><span class="s4">(</span><span class="s2">rkey </span><span class="s4">=&gt; {</span>
                    <span class="s2">safeResults</span><span class="s4">[</span><span class="s2">rkey</span><span class="s4">] = </span><span class="s2">results</span><span class="s4">[</span><span class="s2">rkey</span><span class="s4">];</span>
                <span class="s4">});</span>
                <span class="s2">safeResults</span><span class="s4">[</span><span class="s2">key</span><span class="s4">] = </span><span class="s2">result</span><span class="s4">;</span>
                <span class="s2">hasError </span><span class="s4">= </span><span class="s3">true</span><span class="s4">;</span>
                <span class="s2">listeners </span><span class="s4">= </span><span class="s2">Object</span><span class="s4">.</span><span class="s2">create</span><span class="s4">(</span><span class="s3">null</span><span class="s4">);</span>
                <span class="s3">if </span><span class="s4">(</span><span class="s2">canceled</span><span class="s4">) </span><span class="s3">return</span>
                <span class="s2">callback</span><span class="s4">(</span><span class="s2">err</span><span class="s4">, </span><span class="s2">safeResults</span><span class="s4">);</span>
            <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
                <span class="s2">results</span><span class="s4">[</span><span class="s2">key</span><span class="s4">] = </span><span class="s2">result</span><span class="s4">;</span>
                <span class="s2">taskComplete</span><span class="s4">(</span><span class="s2">key</span><span class="s4">);</span>
            <span class="s4">}</span>
        <span class="s4">});</span>

        <span class="s2">runningTasks</span><span class="s4">++;</span>
        <span class="s3">var </span><span class="s2">taskFn </span><span class="s4">= </span><span class="s2">wrapAsync</span><span class="s4">(</span><span class="s2">task</span><span class="s4">[</span><span class="s2">task</span><span class="s4">.</span><span class="s2">length </span><span class="s4">- </span><span class="s7">1</span><span class="s4">]);</span>
        <span class="s3">if </span><span class="s4">(</span><span class="s2">task</span><span class="s4">.</span><span class="s2">length </span><span class="s4">&gt; </span><span class="s7">1</span><span class="s4">) {</span>
            <span class="s2">taskFn</span><span class="s4">(</span><span class="s2">results</span><span class="s4">, </span><span class="s2">taskCallback</span><span class="s4">);</span>
        <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
            <span class="s2">taskFn</span><span class="s4">(</span><span class="s2">taskCallback</span><span class="s4">);</span>
        <span class="s4">}</span>
    <span class="s4">}</span>

    <span class="s3">function </span><span class="s2">checkForDeadlocks</span><span class="s4">() {</span>
        <span class="s5">// Kahn's algorithm</span>
        <span class="s5">// https://en.wikipedia.org/wiki/Topological_sorting#Kahn.27s_algorithm</span>
        <span class="s5">// http://connalle.blogspot.com/2013/10/topological-sortingkahn-algorithm.html</span>
        <span class="s3">var </span><span class="s2">currentTask</span><span class="s4">;</span>
        <span class="s3">var </span><span class="s2">counter </span><span class="s4">= </span><span class="s7">0</span><span class="s4">;</span>
        <span class="s3">while </span><span class="s4">(</span><span class="s2">readyToCheck</span><span class="s4">.</span><span class="s2">length</span><span class="s4">) {</span>
            <span class="s2">currentTask </span><span class="s4">= </span><span class="s2">readyToCheck</span><span class="s4">.</span><span class="s2">pop</span><span class="s4">();</span>
            <span class="s2">counter</span><span class="s4">++;</span>
            <span class="s2">getDependents</span><span class="s4">(</span><span class="s2">currentTask</span><span class="s4">).</span><span class="s2">forEach</span><span class="s4">(</span><span class="s2">dependent </span><span class="s4">=&gt; {</span>
                <span class="s3">if </span><span class="s4">(--</span><span class="s2">uncheckedDependencies</span><span class="s4">[</span><span class="s2">dependent</span><span class="s4">] === </span><span class="s7">0</span><span class="s4">) {</span>
                    <span class="s2">readyToCheck</span><span class="s4">.</span><span class="s2">push</span><span class="s4">(</span><span class="s2">dependent</span><span class="s4">);</span>
                <span class="s4">}</span>
            <span class="s4">});</span>
        <span class="s4">}</span>

        <span class="s3">if </span><span class="s4">(</span><span class="s2">counter </span><span class="s4">!== </span><span class="s2">numTasks</span><span class="s4">) {</span>
            <span class="s3">throw new </span><span class="s2">Error</span><span class="s4">(</span>
                <span class="s6">'async.auto cannot execute tasks due to a recursive dependency'</span>
            <span class="s4">);</span>
        <span class="s4">}</span>
    <span class="s4">}</span>

    <span class="s3">function </span><span class="s2">getDependents</span><span class="s4">(</span><span class="s2">taskName</span><span class="s4">) {</span>
        <span class="s3">var </span><span class="s2">result </span><span class="s4">= [];</span>
        <span class="s2">Object</span><span class="s4">.</span><span class="s2">keys</span><span class="s4">(</span><span class="s2">tasks</span><span class="s4">).</span><span class="s2">forEach</span><span class="s4">(</span><span class="s2">key </span><span class="s4">=&gt; {</span>
            <span class="s3">const </span><span class="s2">task </span><span class="s4">= </span><span class="s2">tasks</span><span class="s4">[</span><span class="s2">key</span><span class="s4">];</span>
            <span class="s3">if </span><span class="s4">(</span><span class="s2">Array</span><span class="s4">.</span><span class="s2">isArray</span><span class="s4">(</span><span class="s2">task</span><span class="s4">) &amp;&amp; </span><span class="s2">task</span><span class="s4">.</span><span class="s2">indexOf</span><span class="s4">(</span><span class="s2">taskName</span><span class="s4">) &gt;= </span><span class="s7">0</span><span class="s4">) {</span>
                <span class="s2">result</span><span class="s4">.</span><span class="s2">push</span><span class="s4">(</span><span class="s2">key</span><span class="s4">);</span>
            <span class="s4">}</span>
        <span class="s4">});</span>
        <span class="s3">return </span><span class="s2">result</span><span class="s4">;</span>
    <span class="s4">}</span>

    <span class="s3">return </span><span class="s2">callback</span><span class="s4">[</span><span class="s2">PROMISE_SYMBOL</span><span class="s4">]</span>
<span class="s4">}</span>

<span class="s3">var </span><span class="s2">FN_ARGS </span><span class="s4">= </span><span class="s8">/^(?:async\s)?(?:function)?\s*(?:\w+\s*)?\(([^)]+)\)(?:\s*{)/</span><span class="s4">;</span>
<span class="s3">var </span><span class="s2">ARROW_FN_ARGS </span><span class="s4">= </span><span class="s8">/^(?:async\s)?\s*(?:\(\s*)?((?:[^)=\s]\s*)*)(?:\)\s*)?=&gt;/</span><span class="s4">;</span>
<span class="s3">var </span><span class="s2">FN_ARG_SPLIT </span><span class="s4">= </span><span class="s8">/,/</span><span class="s4">;</span>
<span class="s3">var </span><span class="s2">FN_ARG </span><span class="s4">= </span><span class="s8">/(=.+)?(\s*)$/</span><span class="s4">;</span>

<span class="s3">function </span><span class="s2">stripComments</span><span class="s4">(</span><span class="s2">string</span><span class="s4">) {</span>
    <span class="s3">let </span><span class="s2">stripped </span><span class="s4">= </span><span class="s6">''</span><span class="s4">;</span>
    <span class="s3">let </span><span class="s2">index </span><span class="s4">= </span><span class="s7">0</span><span class="s4">;</span>
    <span class="s3">let </span><span class="s2">endBlockComment </span><span class="s4">= </span><span class="s2">string</span><span class="s4">.</span><span class="s2">indexOf</span><span class="s4">(</span><span class="s6">'*/'</span><span class="s4">);</span>
    <span class="s3">while </span><span class="s4">(</span><span class="s2">index </span><span class="s4">&lt; </span><span class="s2">string</span><span class="s4">.</span><span class="s2">length</span><span class="s4">) {</span>
        <span class="s3">if </span><span class="s4">(</span><span class="s2">string</span><span class="s4">[</span><span class="s2">index</span><span class="s4">] === </span><span class="s6">'/' </span><span class="s4">&amp;&amp; </span><span class="s2">string</span><span class="s4">[</span><span class="s2">index</span><span class="s4">+</span><span class="s7">1</span><span class="s4">] === </span><span class="s6">'/'</span><span class="s4">) {</span>
            <span class="s5">// inline comment</span>
            <span class="s3">let </span><span class="s2">endIndex </span><span class="s4">= </span><span class="s2">string</span><span class="s4">.</span><span class="s2">indexOf</span><span class="s4">(</span><span class="s6">'</span><span class="s3">\n</span><span class="s6">'</span><span class="s4">, </span><span class="s2">index</span><span class="s4">);</span>
            <span class="s2">index </span><span class="s4">= (</span><span class="s2">endIndex </span><span class="s4">=== -</span><span class="s7">1</span><span class="s4">) ? </span><span class="s2">string</span><span class="s4">.</span><span class="s2">length </span><span class="s4">: </span><span class="s2">endIndex</span><span class="s4">;</span>
        <span class="s4">} </span><span class="s3">else if </span><span class="s4">((</span><span class="s2">endBlockComment </span><span class="s4">!== -</span><span class="s7">1</span><span class="s4">) &amp;&amp; (</span><span class="s2">string</span><span class="s4">[</span><span class="s2">index</span><span class="s4">] === </span><span class="s6">'/'</span><span class="s4">) &amp;&amp; (</span><span class="s2">string</span><span class="s4">[</span><span class="s2">index</span><span class="s4">+</span><span class="s7">1</span><span class="s4">] === </span><span class="s6">'*'</span><span class="s4">)) {</span>
            <span class="s5">// block comment</span>
            <span class="s3">let </span><span class="s2">endIndex </span><span class="s4">= </span><span class="s2">string</span><span class="s4">.</span><span class="s2">indexOf</span><span class="s4">(</span><span class="s6">'*/'</span><span class="s4">, </span><span class="s2">index</span><span class="s4">);</span>
            <span class="s3">if </span><span class="s4">(</span><span class="s2">endIndex </span><span class="s4">!== -</span><span class="s7">1</span><span class="s4">) {</span>
                <span class="s2">index </span><span class="s4">= </span><span class="s2">endIndex </span><span class="s4">+ </span><span class="s7">2</span><span class="s4">;</span>
                <span class="s2">endBlockComment </span><span class="s4">= </span><span class="s2">string</span><span class="s4">.</span><span class="s2">indexOf</span><span class="s4">(</span><span class="s6">'*/'</span><span class="s4">, </span><span class="s2">index</span><span class="s4">);</span>
            <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
                <span class="s2">stripped </span><span class="s4">+= </span><span class="s2">string</span><span class="s4">[</span><span class="s2">index</span><span class="s4">];</span>
                <span class="s2">index</span><span class="s4">++;</span>
            <span class="s4">}</span>
        <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
            <span class="s2">stripped </span><span class="s4">+= </span><span class="s2">string</span><span class="s4">[</span><span class="s2">index</span><span class="s4">];</span>
            <span class="s2">index</span><span class="s4">++;</span>
        <span class="s4">}</span>
    <span class="s4">}</span>
    <span class="s3">return </span><span class="s2">stripped</span><span class="s4">;</span>
<span class="s4">}</span>

<span class="s3">function </span><span class="s2">parseParams</span><span class="s4">(</span><span class="s2">func</span><span class="s4">) {</span>
    <span class="s3">const </span><span class="s2">src </span><span class="s4">= </span><span class="s2">stripComments</span><span class="s4">(</span><span class="s2">func</span><span class="s4">.</span><span class="s2">toString</span><span class="s4">());</span>
    <span class="s3">let </span><span class="s2">match </span><span class="s4">= </span><span class="s2">src</span><span class="s4">.</span><span class="s2">match</span><span class="s4">(</span><span class="s2">FN_ARGS</span><span class="s4">);</span>
    <span class="s3">if </span><span class="s4">(!</span><span class="s2">match</span><span class="s4">) {</span>
        <span class="s2">match </span><span class="s4">= </span><span class="s2">src</span><span class="s4">.</span><span class="s2">match</span><span class="s4">(</span><span class="s2">ARROW_FN_ARGS</span><span class="s4">);</span>
    <span class="s4">}</span>
    <span class="s3">if </span><span class="s4">(!</span><span class="s2">match</span><span class="s4">) </span><span class="s3">throw new </span><span class="s2">Error</span><span class="s4">(</span><span class="s6">'could not parse args in autoInject</span><span class="s3">\n</span><span class="s6">Source:</span><span class="s3">\n</span><span class="s6">' </span><span class="s4">+ </span><span class="s2">src</span><span class="s4">)</span>
    <span class="s3">let </span><span class="s4">[, </span><span class="s2">args</span><span class="s4">] = </span><span class="s2">match</span><span class="s4">;</span>
    <span class="s3">return </span><span class="s2">args</span>
        <span class="s4">.</span><span class="s2">replace</span><span class="s4">(</span><span class="s8">/\s/g</span><span class="s4">, </span><span class="s6">''</span><span class="s4">)</span>
        <span class="s4">.</span><span class="s2">split</span><span class="s4">(</span><span class="s2">FN_ARG_SPLIT</span><span class="s4">)</span>
        <span class="s4">.</span><span class="s2">map</span><span class="s4">((</span><span class="s2">arg</span><span class="s4">) =&gt; </span><span class="s2">arg</span><span class="s4">.</span><span class="s2">replace</span><span class="s4">(</span><span class="s2">FN_ARG</span><span class="s4">, </span><span class="s6">''</span><span class="s4">).</span><span class="s2">trim</span><span class="s4">());</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* A dependency-injected version of the [async.auto]{</span><span class="s1">@link </span><span class="s0">module:ControlFlow.auto} function. Dependent</span>
 <span class="s0">* tasks are specified as parameters to the function, after the usual callback</span>
 <span class="s0">* parameter, with the parameter names matching the names of the tasks it</span>
 <span class="s0">* depends on. This can provide even more readable task graphs which can be</span>
 <span class="s0">* easier to maintain.</span>
 <span class="s0">*</span>
 <span class="s0">* If a final callback is specified, the task results are similarly injected,</span>
 <span class="s0">* specified as named parameters after the initial error parameter.</span>
 <span class="s0">*</span>
 <span class="s0">* The autoInject function is purely syntactic sugar and its semantics are</span>
 <span class="s0">* otherwise equivalent to [async.auto]{</span><span class="s1">@link </span><span class="s0">module:ControlFlow.auto}.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">autoInject</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:ControlFlow</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s0">[async.auto]{</span><span class="s1">@link </span><span class="s0">module:ControlFlow.auto}</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Control Flow</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Object} tasks - An object, each of whose properties is an {</span><span class="s1">@link </span><span class="s0">AsyncFunction} of</span>
 <span class="s0">* the form 'func([dependencies...], callback). The object's key of a property</span>
 <span class="s0">* serves as the name of the task defined by that property, i.e. can be used</span>
 <span class="s0">* when specifying requirements for other tasks.</span>
 <span class="s0">* * The `callback` parameter is a `callback(err, result)` which must be called</span>
 <span class="s0">*   when finished, passing an `error` (which can be `null`) and the result of</span>
 <span class="s0">*   the function's execution. The remaining parameters name other tasks on</span>
 <span class="s0">*   which the task is dependent, and the results from those tasks are the</span>
 <span class="s0">*   arguments of those parameters.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} [callback] - An optional callback which is called when all</span>
 <span class="s0">* the tasks have been completed. It receives the `err` argument if any `tasks`</span>
 <span class="s0">* pass an error to their callback, and a `results` object with any completed</span>
 <span class="s0">* task results, similar to `auto`.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise} a promise, if no callback is passed</span>
 <span class="s0">* </span><span class="s1">@example</span>
 <span class="s0">*</span>
 <span class="s0">* //  The example from `auto` can be rewritten as follows:</span>
 <span class="s0">* async.autoInject({</span>
 <span class="s0">*     get_data: function(callback) {</span>
 <span class="s0">*         // async code to get some data</span>
 <span class="s0">*         callback(null, 'data', 'converted to array');</span>
 <span class="s0">*     },</span>
 <span class="s0">*     make_folder: function(callback) {</span>
 <span class="s0">*         // async code to create a directory to store a file in</span>
 <span class="s0">*         // this is run at the same time as getting the data</span>
 <span class="s0">*         callback(null, 'folder');</span>
 <span class="s0">*     },</span>
 <span class="s0">*     write_file: function(get_data, make_folder, callback) {</span>
 <span class="s0">*         // once there is some data and the directory exists,</span>
 <span class="s0">*         // write the data to a file in the directory</span>
 <span class="s0">*         callback(null, 'filename');</span>
 <span class="s0">*     },</span>
 <span class="s0">*     email_link: function(write_file, callback) {</span>
 <span class="s0">*         // once the file is written let's email a link to it...</span>
 <span class="s0">*         // write_file contains the filename returned by write_file.</span>
 <span class="s0">*         callback(null, {'file':write_file, 'email':'user@example.com'});</span>
 <span class="s0">*     }</span>
 <span class="s0">* }, function(err, results) {</span>
 <span class="s0">*     console.log('err = ', err);</span>
 <span class="s0">*     console.log('email_link = ', results.email_link);</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* // If you are using a JS minifier that mangles parameter names, `autoInject`</span>
 <span class="s0">* // will not work with plain functions, since the parameter names will be</span>
 <span class="s0">* // collapsed to a single letter identifier.  To work around this, you can</span>
 <span class="s0">* // explicitly specify the names of the parameters your task function needs</span>
 <span class="s0">* // in an array, similar to Angular.js dependency injection.</span>
 <span class="s0">*</span>
 <span class="s0">* // This still has an advantage over plain `auto`, since the results a task</span>
 <span class="s0">* // depends on are still spread into arguments.</span>
 <span class="s0">* async.autoInject({</span>
 <span class="s0">*     //...</span>
 <span class="s0">*     write_file: ['get_data', 'make_folder', function(get_data, make_folder, callback) {</span>
 <span class="s0">*         callback(null, 'filename');</span>
 <span class="s0">*     }],</span>
 <span class="s0">*     email_link: ['write_file', function(write_file, callback) {</span>
 <span class="s0">*         callback(null, {'file':write_file, 'email':'user@example.com'});</span>
 <span class="s0">*     }]</span>
 <span class="s0">*     //...</span>
 <span class="s0">* }, function(err, results) {</span>
 <span class="s0">*     console.log('err = ', err);</span>
 <span class="s0">*     console.log('email_link = ', results.email_link);</span>
 <span class="s0">* });</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">autoInject</span><span class="s4">(</span><span class="s2">tasks</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
    <span class="s3">var </span><span class="s2">newTasks </span><span class="s4">= {};</span>

    <span class="s2">Object</span><span class="s4">.</span><span class="s2">keys</span><span class="s4">(</span><span class="s2">tasks</span><span class="s4">).</span><span class="s2">forEach</span><span class="s4">(</span><span class="s2">key </span><span class="s4">=&gt; {</span>
        <span class="s3">var </span><span class="s2">taskFn </span><span class="s4">= </span><span class="s2">tasks</span><span class="s4">[</span><span class="s2">key</span><span class="s4">];</span>
        <span class="s3">var </span><span class="s2">params</span><span class="s4">;</span>
        <span class="s3">var </span><span class="s2">fnIsAsync </span><span class="s4">= </span><span class="s2">isAsync</span><span class="s4">(</span><span class="s2">taskFn</span><span class="s4">);</span>
        <span class="s3">var </span><span class="s2">hasNoDeps </span><span class="s4">=</span>
            <span class="s4">(!</span><span class="s2">fnIsAsync </span><span class="s4">&amp;&amp; </span><span class="s2">taskFn</span><span class="s4">.</span><span class="s2">length </span><span class="s4">=== </span><span class="s7">1</span><span class="s4">) ||</span>
            <span class="s4">(</span><span class="s2">fnIsAsync </span><span class="s4">&amp;&amp; </span><span class="s2">taskFn</span><span class="s4">.</span><span class="s2">length </span><span class="s4">=== </span><span class="s7">0</span><span class="s4">);</span>

        <span class="s3">if </span><span class="s4">(</span><span class="s2">Array</span><span class="s4">.</span><span class="s2">isArray</span><span class="s4">(</span><span class="s2">taskFn</span><span class="s4">)) {</span>
            <span class="s2">params </span><span class="s4">= [</span><span class="s2">...taskFn</span><span class="s4">];</span>
            <span class="s2">taskFn </span><span class="s4">= </span><span class="s2">params</span><span class="s4">.</span><span class="s2">pop</span><span class="s4">();</span>

            <span class="s2">newTasks</span><span class="s4">[</span><span class="s2">key</span><span class="s4">] = </span><span class="s2">params</span><span class="s4">.</span><span class="s2">concat</span><span class="s4">(</span><span class="s2">params</span><span class="s4">.</span><span class="s2">length </span><span class="s4">&gt; </span><span class="s7">0 </span><span class="s4">? </span><span class="s2">newTask </span><span class="s4">: </span><span class="s2">taskFn</span><span class="s4">);</span>
        <span class="s4">} </span><span class="s3">else if </span><span class="s4">(</span><span class="s2">hasNoDeps</span><span class="s4">) {</span>
            <span class="s5">// no dependencies, use the function as-is</span>
            <span class="s2">newTasks</span><span class="s4">[</span><span class="s2">key</span><span class="s4">] = </span><span class="s2">taskFn</span><span class="s4">;</span>
        <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
            <span class="s2">params </span><span class="s4">= </span><span class="s2">parseParams</span><span class="s4">(</span><span class="s2">taskFn</span><span class="s4">);</span>
            <span class="s3">if </span><span class="s4">((</span><span class="s2">taskFn</span><span class="s4">.</span><span class="s2">length </span><span class="s4">=== </span><span class="s7">0 </span><span class="s4">&amp;&amp; !</span><span class="s2">fnIsAsync</span><span class="s4">) &amp;&amp; </span><span class="s2">params</span><span class="s4">.</span><span class="s2">length </span><span class="s4">=== </span><span class="s7">0</span><span class="s4">) {</span>
                <span class="s3">throw new </span><span class="s2">Error</span><span class="s4">(</span><span class="s6">&quot;autoInject task functions require explicit parameters.&quot;</span><span class="s4">);</span>
            <span class="s4">}</span>

            <span class="s5">// remove callback param</span>
            <span class="s3">if </span><span class="s4">(!</span><span class="s2">fnIsAsync</span><span class="s4">) </span><span class="s2">params</span><span class="s4">.</span><span class="s2">pop</span><span class="s4">();</span>

            <span class="s2">newTasks</span><span class="s4">[</span><span class="s2">key</span><span class="s4">] = </span><span class="s2">params</span><span class="s4">.</span><span class="s2">concat</span><span class="s4">(</span><span class="s2">newTask</span><span class="s4">);</span>
        <span class="s4">}</span>

        <span class="s3">function </span><span class="s2">newTask</span><span class="s4">(</span><span class="s2">results</span><span class="s4">, </span><span class="s2">taskCb</span><span class="s4">) {</span>
            <span class="s3">var </span><span class="s2">newArgs </span><span class="s4">= </span><span class="s2">params</span><span class="s4">.</span><span class="s2">map</span><span class="s4">(</span><span class="s2">name </span><span class="s4">=&gt; </span><span class="s2">results</span><span class="s4">[</span><span class="s2">name</span><span class="s4">]);</span>
            <span class="s2">newArgs</span><span class="s4">.</span><span class="s2">push</span><span class="s4">(</span><span class="s2">taskCb</span><span class="s4">);</span>
            <span class="s2">wrapAsync</span><span class="s4">(</span><span class="s2">taskFn</span><span class="s4">)(</span><span class="s2">...newArgs</span><span class="s4">);</span>
        <span class="s4">}</span>
    <span class="s4">});</span>

    <span class="s3">return </span><span class="s2">auto</span><span class="s4">(</span><span class="s2">newTasks</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">);</span>
<span class="s4">}</span>

<span class="s5">// Simple doubly linked list (https://en.wikipedia.org/wiki/Doubly_linked_list) implementation</span>
<span class="s5">// used for queues. This implementation assumes that the node provided by the user can be modified</span>
<span class="s5">// to adjust the next and last properties. We implement only the minimal functionality</span>
<span class="s5">// for queue support.</span>
<span class="s3">class </span><span class="s2">DLL </span><span class="s4">{</span>
    <span class="s2">constructor</span><span class="s4">() {</span>
        <span class="s3">this</span><span class="s4">.</span><span class="s2">head </span><span class="s4">= </span><span class="s3">this</span><span class="s4">.</span><span class="s2">tail </span><span class="s4">= </span><span class="s3">null</span><span class="s4">;</span>
        <span class="s3">this</span><span class="s4">.</span><span class="s2">length </span><span class="s4">= </span><span class="s7">0</span><span class="s4">;</span>
    <span class="s4">}</span>

    <span class="s2">removeLink</span><span class="s4">(</span><span class="s2">node</span><span class="s4">) {</span>
        <span class="s3">if </span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">prev</span><span class="s4">) </span><span class="s2">node</span><span class="s4">.</span><span class="s2">prev</span><span class="s4">.</span><span class="s2">next </span><span class="s4">= </span><span class="s2">node</span><span class="s4">.</span><span class="s2">next</span><span class="s4">;</span>
        <span class="s3">else this</span><span class="s4">.</span><span class="s2">head </span><span class="s4">= </span><span class="s2">node</span><span class="s4">.</span><span class="s2">next</span><span class="s4">;</span>
        <span class="s3">if </span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">next</span><span class="s4">) </span><span class="s2">node</span><span class="s4">.</span><span class="s2">next</span><span class="s4">.</span><span class="s2">prev </span><span class="s4">= </span><span class="s2">node</span><span class="s4">.</span><span class="s2">prev</span><span class="s4">;</span>
        <span class="s3">else this</span><span class="s4">.</span><span class="s2">tail </span><span class="s4">= </span><span class="s2">node</span><span class="s4">.</span><span class="s2">prev</span><span class="s4">;</span>

        <span class="s2">node</span><span class="s4">.</span><span class="s2">prev </span><span class="s4">= </span><span class="s2">node</span><span class="s4">.</span><span class="s2">next </span><span class="s4">= </span><span class="s3">null</span><span class="s4">;</span>
        <span class="s3">this</span><span class="s4">.</span><span class="s2">length </span><span class="s4">-= </span><span class="s7">1</span><span class="s4">;</span>
        <span class="s3">return </span><span class="s2">node</span><span class="s4">;</span>
    <span class="s4">}</span>

    <span class="s2">empty </span><span class="s4">() {</span>
        <span class="s3">while</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">head</span><span class="s4">) </span><span class="s3">this</span><span class="s4">.</span><span class="s2">shift</span><span class="s4">();</span>
        <span class="s3">return this</span><span class="s4">;</span>
    <span class="s4">}</span>

    <span class="s2">insertAfter</span><span class="s4">(</span><span class="s2">node</span><span class="s4">, </span><span class="s2">newNode</span><span class="s4">) {</span>
        <span class="s2">newNode</span><span class="s4">.</span><span class="s2">prev </span><span class="s4">= </span><span class="s2">node</span><span class="s4">;</span>
        <span class="s2">newNode</span><span class="s4">.</span><span class="s2">next </span><span class="s4">= </span><span class="s2">node</span><span class="s4">.</span><span class="s2">next</span><span class="s4">;</span>
        <span class="s3">if </span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">next</span><span class="s4">) </span><span class="s2">node</span><span class="s4">.</span><span class="s2">next</span><span class="s4">.</span><span class="s2">prev </span><span class="s4">= </span><span class="s2">newNode</span><span class="s4">;</span>
        <span class="s3">else this</span><span class="s4">.</span><span class="s2">tail </span><span class="s4">= </span><span class="s2">newNode</span><span class="s4">;</span>
        <span class="s2">node</span><span class="s4">.</span><span class="s2">next </span><span class="s4">= </span><span class="s2">newNode</span><span class="s4">;</span>
        <span class="s3">this</span><span class="s4">.</span><span class="s2">length </span><span class="s4">+= </span><span class="s7">1</span><span class="s4">;</span>
    <span class="s4">}</span>

    <span class="s2">insertBefore</span><span class="s4">(</span><span class="s2">node</span><span class="s4">, </span><span class="s2">newNode</span><span class="s4">) {</span>
        <span class="s2">newNode</span><span class="s4">.</span><span class="s2">prev </span><span class="s4">= </span><span class="s2">node</span><span class="s4">.</span><span class="s2">prev</span><span class="s4">;</span>
        <span class="s2">newNode</span><span class="s4">.</span><span class="s2">next </span><span class="s4">= </span><span class="s2">node</span><span class="s4">;</span>
        <span class="s3">if </span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">prev</span><span class="s4">) </span><span class="s2">node</span><span class="s4">.</span><span class="s2">prev</span><span class="s4">.</span><span class="s2">next </span><span class="s4">= </span><span class="s2">newNode</span><span class="s4">;</span>
        <span class="s3">else this</span><span class="s4">.</span><span class="s2">head </span><span class="s4">= </span><span class="s2">newNode</span><span class="s4">;</span>
        <span class="s2">node</span><span class="s4">.</span><span class="s2">prev </span><span class="s4">= </span><span class="s2">newNode</span><span class="s4">;</span>
        <span class="s3">this</span><span class="s4">.</span><span class="s2">length </span><span class="s4">+= </span><span class="s7">1</span><span class="s4">;</span>
    <span class="s4">}</span>

    <span class="s2">unshift</span><span class="s4">(</span><span class="s2">node</span><span class="s4">) {</span>
        <span class="s3">if </span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">head</span><span class="s4">) </span><span class="s3">this</span><span class="s4">.</span><span class="s2">insertBefore</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">head</span><span class="s4">, </span><span class="s2">node</span><span class="s4">);</span>
        <span class="s3">else </span><span class="s2">setInitial</span><span class="s4">(</span><span class="s3">this</span><span class="s4">, </span><span class="s2">node</span><span class="s4">);</span>
    <span class="s4">}</span>

    <span class="s2">push</span><span class="s4">(</span><span class="s2">node</span><span class="s4">) {</span>
        <span class="s3">if </span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">tail</span><span class="s4">) </span><span class="s3">this</span><span class="s4">.</span><span class="s2">insertAfter</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">tail</span><span class="s4">, </span><span class="s2">node</span><span class="s4">);</span>
        <span class="s3">else </span><span class="s2">setInitial</span><span class="s4">(</span><span class="s3">this</span><span class="s4">, </span><span class="s2">node</span><span class="s4">);</span>
    <span class="s4">}</span>

    <span class="s2">shift</span><span class="s4">() {</span>
        <span class="s3">return this</span><span class="s4">.</span><span class="s2">head </span><span class="s4">&amp;&amp; </span><span class="s3">this</span><span class="s4">.</span><span class="s2">removeLink</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">head</span><span class="s4">);</span>
    <span class="s4">}</span>

    <span class="s2">pop</span><span class="s4">() {</span>
        <span class="s3">return this</span><span class="s4">.</span><span class="s2">tail </span><span class="s4">&amp;&amp; </span><span class="s3">this</span><span class="s4">.</span><span class="s2">removeLink</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">tail</span><span class="s4">);</span>
    <span class="s4">}</span>

    <span class="s2">toArray</span><span class="s4">() {</span>
        <span class="s3">return </span><span class="s4">[</span><span class="s2">...</span><span class="s3">this</span><span class="s4">]</span>
    <span class="s4">}</span>

    <span class="s4">*[</span><span class="s2">Symbol</span><span class="s4">.</span><span class="s2">iterator</span><span class="s4">] () {</span>
        <span class="s3">var </span><span class="s2">cur </span><span class="s4">= </span><span class="s3">this</span><span class="s4">.</span><span class="s2">head</span><span class="s4">;</span>
        <span class="s3">while </span><span class="s4">(</span><span class="s2">cur</span><span class="s4">) {</span>
            <span class="s3">yield </span><span class="s2">cur</span><span class="s4">.</span><span class="s2">data</span><span class="s4">;</span>
            <span class="s2">cur </span><span class="s4">= </span><span class="s2">cur</span><span class="s4">.</span><span class="s2">next</span><span class="s4">;</span>
        <span class="s4">}</span>
    <span class="s4">}</span>

    <span class="s2">remove </span><span class="s4">(</span><span class="s2">testFn</span><span class="s4">) {</span>
        <span class="s3">var </span><span class="s2">curr </span><span class="s4">= </span><span class="s3">this</span><span class="s4">.</span><span class="s2">head</span><span class="s4">;</span>
        <span class="s3">while</span><span class="s4">(</span><span class="s2">curr</span><span class="s4">) {</span>
            <span class="s3">var </span><span class="s4">{</span><span class="s2">next</span><span class="s4">} = </span><span class="s2">curr</span><span class="s4">;</span>
            <span class="s3">if </span><span class="s4">(</span><span class="s2">testFn</span><span class="s4">(</span><span class="s2">curr</span><span class="s4">)) {</span>
                <span class="s3">this</span><span class="s4">.</span><span class="s2">removeLink</span><span class="s4">(</span><span class="s2">curr</span><span class="s4">);</span>
            <span class="s4">}</span>
            <span class="s2">curr </span><span class="s4">= </span><span class="s2">next</span><span class="s4">;</span>
        <span class="s4">}</span>
        <span class="s3">return this</span><span class="s4">;</span>
    <span class="s4">}</span>
<span class="s4">}</span>

<span class="s3">function </span><span class="s2">setInitial</span><span class="s4">(</span><span class="s2">dll</span><span class="s4">, </span><span class="s2">node</span><span class="s4">) {</span>
    <span class="s2">dll</span><span class="s4">.</span><span class="s2">length </span><span class="s4">= </span><span class="s7">1</span><span class="s4">;</span>
    <span class="s2">dll</span><span class="s4">.</span><span class="s2">head </span><span class="s4">= </span><span class="s2">dll</span><span class="s4">.</span><span class="s2">tail </span><span class="s4">= </span><span class="s2">node</span><span class="s4">;</span>
<span class="s4">}</span>

<span class="s3">function </span><span class="s2">queue$1</span><span class="s4">(</span><span class="s2">worker</span><span class="s4">, </span><span class="s2">concurrency</span><span class="s4">, </span><span class="s2">payload</span><span class="s4">) {</span>
    <span class="s3">if </span><span class="s4">(</span><span class="s2">concurrency </span><span class="s4">== </span><span class="s3">null</span><span class="s4">) {</span>
        <span class="s2">concurrency </span><span class="s4">= </span><span class="s7">1</span><span class="s4">;</span>
    <span class="s4">}</span>
    <span class="s3">else if</span><span class="s4">(</span><span class="s2">concurrency </span><span class="s4">=== </span><span class="s7">0</span><span class="s4">) {</span>
        <span class="s3">throw new </span><span class="s2">RangeError</span><span class="s4">(</span><span class="s6">'Concurrency must not be zero'</span><span class="s4">);</span>
    <span class="s4">}</span>

    <span class="s3">var </span><span class="s2">_worker </span><span class="s4">= </span><span class="s2">wrapAsync</span><span class="s4">(</span><span class="s2">worker</span><span class="s4">);</span>
    <span class="s3">var </span><span class="s2">numRunning </span><span class="s4">= </span><span class="s7">0</span><span class="s4">;</span>
    <span class="s3">var </span><span class="s2">workersList </span><span class="s4">= [];</span>
    <span class="s3">const </span><span class="s2">events </span><span class="s4">= {</span>
        <span class="s2">error</span><span class="s4">: [],</span>
        <span class="s2">drain</span><span class="s4">: [],</span>
        <span class="s2">saturated</span><span class="s4">: [],</span>
        <span class="s2">unsaturated</span><span class="s4">: [],</span>
        <span class="s2">empty</span><span class="s4">: []</span>
    <span class="s4">};</span>

    <span class="s3">function </span><span class="s2">on </span><span class="s4">(</span><span class="s2">event</span><span class="s4">, </span><span class="s2">handler</span><span class="s4">) {</span>
        <span class="s2">events</span><span class="s4">[</span><span class="s2">event</span><span class="s4">].</span><span class="s2">push</span><span class="s4">(</span><span class="s2">handler</span><span class="s4">);</span>
    <span class="s4">}</span>

    <span class="s3">function </span><span class="s2">once </span><span class="s4">(</span><span class="s2">event</span><span class="s4">, </span><span class="s2">handler</span><span class="s4">) {</span>
        <span class="s3">const </span><span class="s2">handleAndRemove </span><span class="s4">= (</span><span class="s2">...args</span><span class="s4">) =&gt; {</span>
            <span class="s2">off</span><span class="s4">(</span><span class="s2">event</span><span class="s4">, </span><span class="s2">handleAndRemove</span><span class="s4">);</span>
            <span class="s2">handler</span><span class="s4">(</span><span class="s2">...args</span><span class="s4">);</span>
        <span class="s4">};</span>
        <span class="s2">events</span><span class="s4">[</span><span class="s2">event</span><span class="s4">].</span><span class="s2">push</span><span class="s4">(</span><span class="s2">handleAndRemove</span><span class="s4">);</span>
    <span class="s4">}</span>

    <span class="s3">function </span><span class="s2">off </span><span class="s4">(</span><span class="s2">event</span><span class="s4">, </span><span class="s2">handler</span><span class="s4">) {</span>
        <span class="s3">if </span><span class="s4">(!</span><span class="s2">event</span><span class="s4">) </span><span class="s3">return </span><span class="s2">Object</span><span class="s4">.</span><span class="s2">keys</span><span class="s4">(</span><span class="s2">events</span><span class="s4">).</span><span class="s2">forEach</span><span class="s4">(</span><span class="s2">ev </span><span class="s4">=&gt; </span><span class="s2">events</span><span class="s4">[</span><span class="s2">ev</span><span class="s4">] = [])</span>
        <span class="s3">if </span><span class="s4">(!</span><span class="s2">handler</span><span class="s4">) </span><span class="s3">return </span><span class="s2">events</span><span class="s4">[</span><span class="s2">event</span><span class="s4">] = []</span>
        <span class="s2">events</span><span class="s4">[</span><span class="s2">event</span><span class="s4">] = </span><span class="s2">events</span><span class="s4">[</span><span class="s2">event</span><span class="s4">].</span><span class="s2">filter</span><span class="s4">(</span><span class="s2">ev </span><span class="s4">=&gt; </span><span class="s2">ev </span><span class="s4">!== </span><span class="s2">handler</span><span class="s4">);</span>
    <span class="s4">}</span>

    <span class="s3">function </span><span class="s2">trigger </span><span class="s4">(</span><span class="s2">event</span><span class="s4">, </span><span class="s2">...args</span><span class="s4">) {</span>
        <span class="s2">events</span><span class="s4">[</span><span class="s2">event</span><span class="s4">].</span><span class="s2">forEach</span><span class="s4">(</span><span class="s2">handler </span><span class="s4">=&gt; </span><span class="s2">handler</span><span class="s4">(</span><span class="s2">...args</span><span class="s4">));</span>
    <span class="s4">}</span>

    <span class="s3">var </span><span class="s2">processingScheduled </span><span class="s4">= </span><span class="s3">false</span><span class="s4">;</span>
    <span class="s3">function </span><span class="s2">_insert</span><span class="s4">(</span><span class="s2">data</span><span class="s4">, </span><span class="s2">insertAtFront</span><span class="s4">, </span><span class="s2">rejectOnError</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
        <span class="s3">if </span><span class="s4">(</span><span class="s2">callback </span><span class="s4">!= </span><span class="s3">null </span><span class="s4">&amp;&amp; </span><span class="s3">typeof </span><span class="s2">callback </span><span class="s4">!== </span><span class="s6">'function'</span><span class="s4">) {</span>
            <span class="s3">throw new </span><span class="s2">Error</span><span class="s4">(</span><span class="s6">'task callback must be a function'</span><span class="s4">);</span>
        <span class="s4">}</span>
        <span class="s2">q</span><span class="s4">.</span><span class="s2">started </span><span class="s4">= </span><span class="s3">true</span><span class="s4">;</span>

        <span class="s3">var </span><span class="s2">res</span><span class="s4">, </span><span class="s2">rej</span><span class="s4">;</span>
        <span class="s3">function </span><span class="s2">promiseCallback </span><span class="s4">(</span><span class="s2">err</span><span class="s4">, </span><span class="s2">...args</span><span class="s4">) {</span>
            <span class="s5">// we don't care about the error, let the global error handler</span>
            <span class="s5">// deal with it</span>
            <span class="s3">if </span><span class="s4">(</span><span class="s2">err</span><span class="s4">) </span><span class="s3">return </span><span class="s2">rejectOnError </span><span class="s4">? </span><span class="s2">rej</span><span class="s4">(</span><span class="s2">err</span><span class="s4">) : </span><span class="s2">res</span><span class="s4">()</span>
            <span class="s3">if </span><span class="s4">(</span><span class="s2">args</span><span class="s4">.</span><span class="s2">length </span><span class="s4">&lt;= </span><span class="s7">1</span><span class="s4">) </span><span class="s3">return </span><span class="s2">res</span><span class="s4">(</span><span class="s2">args</span><span class="s4">[</span><span class="s7">0</span><span class="s4">])</span>
            <span class="s2">res</span><span class="s4">(</span><span class="s2">args</span><span class="s4">);</span>
        <span class="s4">}</span>

        <span class="s3">var </span><span class="s2">item </span><span class="s4">= </span><span class="s2">q</span><span class="s4">.</span><span class="s2">_createTaskItem</span><span class="s4">(</span>
            <span class="s2">data</span><span class="s4">,</span>
            <span class="s2">rejectOnError </span><span class="s4">? </span><span class="s2">promiseCallback </span><span class="s4">:</span>
                <span class="s4">(</span><span class="s2">callback </span><span class="s4">|| </span><span class="s2">promiseCallback</span><span class="s4">)</span>
        <span class="s4">);</span>

        <span class="s3">if </span><span class="s4">(</span><span class="s2">insertAtFront</span><span class="s4">) {</span>
            <span class="s2">q</span><span class="s4">.</span><span class="s2">_tasks</span><span class="s4">.</span><span class="s2">unshift</span><span class="s4">(</span><span class="s2">item</span><span class="s4">);</span>
        <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
            <span class="s2">q</span><span class="s4">.</span><span class="s2">_tasks</span><span class="s4">.</span><span class="s2">push</span><span class="s4">(</span><span class="s2">item</span><span class="s4">);</span>
        <span class="s4">}</span>

        <span class="s3">if </span><span class="s4">(!</span><span class="s2">processingScheduled</span><span class="s4">) {</span>
            <span class="s2">processingScheduled </span><span class="s4">= </span><span class="s3">true</span><span class="s4">;</span>
            <span class="s2">setImmediate$1</span><span class="s4">(() =&gt; {</span>
                <span class="s2">processingScheduled </span><span class="s4">= </span><span class="s3">false</span><span class="s4">;</span>
                <span class="s2">q</span><span class="s4">.</span><span class="s2">process</span><span class="s4">();</span>
            <span class="s4">});</span>
        <span class="s4">}</span>

        <span class="s3">if </span><span class="s4">(</span><span class="s2">rejectOnError </span><span class="s4">|| !</span><span class="s2">callback</span><span class="s4">) {</span>
            <span class="s3">return new </span><span class="s2">Promise</span><span class="s4">((</span><span class="s2">resolve</span><span class="s4">, </span><span class="s2">reject</span><span class="s4">) =&gt; {</span>
                <span class="s2">res </span><span class="s4">= </span><span class="s2">resolve</span><span class="s4">;</span>
                <span class="s2">rej </span><span class="s4">= </span><span class="s2">reject</span><span class="s4">;</span>
            <span class="s4">})</span>
        <span class="s4">}</span>
    <span class="s4">}</span>

    <span class="s3">function </span><span class="s2">_createCB</span><span class="s4">(</span><span class="s2">tasks</span><span class="s4">) {</span>
        <span class="s3">return function </span><span class="s4">(</span><span class="s2">err</span><span class="s4">, </span><span class="s2">...args</span><span class="s4">) {</span>
            <span class="s2">numRunning </span><span class="s4">-= </span><span class="s7">1</span><span class="s4">;</span>

            <span class="s3">for </span><span class="s4">(</span><span class="s3">var </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">, </span><span class="s2">l </span><span class="s4">= </span><span class="s2">tasks</span><span class="s4">.</span><span class="s2">length</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s2">l</span><span class="s4">; </span><span class="s2">i</span><span class="s4">++) {</span>
                <span class="s3">var </span><span class="s2">task </span><span class="s4">= </span><span class="s2">tasks</span><span class="s4">[</span><span class="s2">i</span><span class="s4">];</span>

                <span class="s3">var </span><span class="s2">index </span><span class="s4">= </span><span class="s2">workersList</span><span class="s4">.</span><span class="s2">indexOf</span><span class="s4">(</span><span class="s2">task</span><span class="s4">);</span>
                <span class="s3">if </span><span class="s4">(</span><span class="s2">index </span><span class="s4">=== </span><span class="s7">0</span><span class="s4">) {</span>
                    <span class="s2">workersList</span><span class="s4">.</span><span class="s2">shift</span><span class="s4">();</span>
                <span class="s4">} </span><span class="s3">else if </span><span class="s4">(</span><span class="s2">index </span><span class="s4">&gt; </span><span class="s7">0</span><span class="s4">) {</span>
                    <span class="s2">workersList</span><span class="s4">.</span><span class="s2">splice</span><span class="s4">(</span><span class="s2">index</span><span class="s4">, </span><span class="s7">1</span><span class="s4">);</span>
                <span class="s4">}</span>

                <span class="s2">task</span><span class="s4">.</span><span class="s2">callback</span><span class="s4">(</span><span class="s2">err</span><span class="s4">, </span><span class="s2">...args</span><span class="s4">);</span>

                <span class="s3">if </span><span class="s4">(</span><span class="s2">err </span><span class="s4">!= </span><span class="s3">null</span><span class="s4">) {</span>
                    <span class="s2">trigger</span><span class="s4">(</span><span class="s6">'error'</span><span class="s4">, </span><span class="s2">err</span><span class="s4">, </span><span class="s2">task</span><span class="s4">.</span><span class="s2">data</span><span class="s4">);</span>
                <span class="s4">}</span>
            <span class="s4">}</span>

            <span class="s3">if </span><span class="s4">(</span><span class="s2">numRunning </span><span class="s4">&lt;= (</span><span class="s2">q</span><span class="s4">.</span><span class="s2">concurrency </span><span class="s4">- </span><span class="s2">q</span><span class="s4">.</span><span class="s2">buffer</span><span class="s4">) ) {</span>
                <span class="s2">trigger</span><span class="s4">(</span><span class="s6">'unsaturated'</span><span class="s4">);</span>
            <span class="s4">}</span>

            <span class="s3">if </span><span class="s4">(</span><span class="s2">q</span><span class="s4">.</span><span class="s2">idle</span><span class="s4">()) {</span>
                <span class="s2">trigger</span><span class="s4">(</span><span class="s6">'drain'</span><span class="s4">);</span>
            <span class="s4">}</span>
            <span class="s2">q</span><span class="s4">.</span><span class="s2">process</span><span class="s4">();</span>
        <span class="s4">};</span>
    <span class="s4">}</span>

    <span class="s3">function </span><span class="s2">_maybeDrain</span><span class="s4">(</span><span class="s2">data</span><span class="s4">) {</span>
        <span class="s3">if </span><span class="s4">(</span><span class="s2">data</span><span class="s4">.</span><span class="s2">length </span><span class="s4">=== </span><span class="s7">0 </span><span class="s4">&amp;&amp; </span><span class="s2">q</span><span class="s4">.</span><span class="s2">idle</span><span class="s4">()) {</span>
            <span class="s5">// call drain immediately if there are no tasks</span>
            <span class="s2">setImmediate$1</span><span class="s4">(() =&gt; </span><span class="s2">trigger</span><span class="s4">(</span><span class="s6">'drain'</span><span class="s4">));</span>
            <span class="s3">return true</span>
        <span class="s4">}</span>
        <span class="s3">return false</span>
    <span class="s4">}</span>

    <span class="s3">const </span><span class="s2">eventMethod </span><span class="s4">= (</span><span class="s2">name</span><span class="s4">) =&gt; (</span><span class="s2">handler</span><span class="s4">) =&gt; {</span>
        <span class="s3">if </span><span class="s4">(!</span><span class="s2">handler</span><span class="s4">) {</span>
            <span class="s3">return new </span><span class="s2">Promise</span><span class="s4">((</span><span class="s2">resolve</span><span class="s4">, </span><span class="s2">reject</span><span class="s4">) =&gt; {</span>
                <span class="s2">once</span><span class="s4">(</span><span class="s2">name</span><span class="s4">, (</span><span class="s2">err</span><span class="s4">, </span><span class="s2">data</span><span class="s4">) =&gt; {</span>
                    <span class="s3">if </span><span class="s4">(</span><span class="s2">err</span><span class="s4">) </span><span class="s3">return </span><span class="s2">reject</span><span class="s4">(</span><span class="s2">err</span><span class="s4">)</span>
                    <span class="s2">resolve</span><span class="s4">(</span><span class="s2">data</span><span class="s4">);</span>
                <span class="s4">});</span>
            <span class="s4">})</span>
        <span class="s4">}</span>
        <span class="s2">off</span><span class="s4">(</span><span class="s2">name</span><span class="s4">);</span>
        <span class="s2">on</span><span class="s4">(</span><span class="s2">name</span><span class="s4">, </span><span class="s2">handler</span><span class="s4">);</span>

    <span class="s4">};</span>

    <span class="s3">var </span><span class="s2">isProcessing </span><span class="s4">= </span><span class="s3">false</span><span class="s4">;</span>
    <span class="s3">var </span><span class="s2">q </span><span class="s4">= {</span>
        <span class="s2">_tasks</span><span class="s4">: </span><span class="s3">new </span><span class="s2">DLL</span><span class="s4">(),</span>
        <span class="s2">_createTaskItem </span><span class="s4">(</span><span class="s2">data</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
            <span class="s3">return </span><span class="s4">{</span>
                <span class="s2">data</span><span class="s4">,</span>
                <span class="s2">callback</span>
            <span class="s4">};</span>
        <span class="s4">},</span>
        <span class="s4">*[</span><span class="s2">Symbol</span><span class="s4">.</span><span class="s2">iterator</span><span class="s4">] () {</span>
            <span class="s3">yield</span><span class="s4">* </span><span class="s2">q</span><span class="s4">.</span><span class="s2">_tasks</span><span class="s4">[</span><span class="s2">Symbol</span><span class="s4">.</span><span class="s2">iterator</span><span class="s4">]();</span>
        <span class="s4">},</span>
        <span class="s2">concurrency</span><span class="s4">,</span>
        <span class="s2">payload</span><span class="s4">,</span>
        <span class="s2">buffer</span><span class="s4">: </span><span class="s2">concurrency </span><span class="s4">/ </span><span class="s7">4</span><span class="s4">,</span>
        <span class="s2">started</span><span class="s4">: </span><span class="s3">false</span><span class="s4">,</span>
        <span class="s2">paused</span><span class="s4">: </span><span class="s3">false</span><span class="s4">,</span>
        <span class="s2">push </span><span class="s4">(</span><span class="s2">data</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
            <span class="s3">if </span><span class="s4">(</span><span class="s2">Array</span><span class="s4">.</span><span class="s2">isArray</span><span class="s4">(</span><span class="s2">data</span><span class="s4">)) {</span>
                <span class="s3">if </span><span class="s4">(</span><span class="s2">_maybeDrain</span><span class="s4">(</span><span class="s2">data</span><span class="s4">)) </span><span class="s3">return</span>
                <span class="s3">return </span><span class="s2">data</span><span class="s4">.</span><span class="s2">map</span><span class="s4">(</span><span class="s2">datum </span><span class="s4">=&gt; </span><span class="s2">_insert</span><span class="s4">(</span><span class="s2">datum</span><span class="s4">, </span><span class="s3">false</span><span class="s4">, </span><span class="s3">false</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">))</span>
            <span class="s4">}</span>
            <span class="s3">return </span><span class="s2">_insert</span><span class="s4">(</span><span class="s2">data</span><span class="s4">, </span><span class="s3">false</span><span class="s4">, </span><span class="s3">false</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">);</span>
        <span class="s4">},</span>
        <span class="s2">pushAsync </span><span class="s4">(</span><span class="s2">data</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
            <span class="s3">if </span><span class="s4">(</span><span class="s2">Array</span><span class="s4">.</span><span class="s2">isArray</span><span class="s4">(</span><span class="s2">data</span><span class="s4">)) {</span>
                <span class="s3">if </span><span class="s4">(</span><span class="s2">_maybeDrain</span><span class="s4">(</span><span class="s2">data</span><span class="s4">)) </span><span class="s3">return</span>
                <span class="s3">return </span><span class="s2">data</span><span class="s4">.</span><span class="s2">map</span><span class="s4">(</span><span class="s2">datum </span><span class="s4">=&gt; </span><span class="s2">_insert</span><span class="s4">(</span><span class="s2">datum</span><span class="s4">, </span><span class="s3">false</span><span class="s4">, </span><span class="s3">true</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">))</span>
            <span class="s4">}</span>
            <span class="s3">return </span><span class="s2">_insert</span><span class="s4">(</span><span class="s2">data</span><span class="s4">, </span><span class="s3">false</span><span class="s4">, </span><span class="s3">true</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">);</span>
        <span class="s4">},</span>
        <span class="s2">kill </span><span class="s4">() {</span>
            <span class="s2">off</span><span class="s4">();</span>
            <span class="s2">q</span><span class="s4">.</span><span class="s2">_tasks</span><span class="s4">.</span><span class="s2">empty</span><span class="s4">();</span>
        <span class="s4">},</span>
        <span class="s2">unshift </span><span class="s4">(</span><span class="s2">data</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
            <span class="s3">if </span><span class="s4">(</span><span class="s2">Array</span><span class="s4">.</span><span class="s2">isArray</span><span class="s4">(</span><span class="s2">data</span><span class="s4">)) {</span>
                <span class="s3">if </span><span class="s4">(</span><span class="s2">_maybeDrain</span><span class="s4">(</span><span class="s2">data</span><span class="s4">)) </span><span class="s3">return</span>
                <span class="s3">return </span><span class="s2">data</span><span class="s4">.</span><span class="s2">map</span><span class="s4">(</span><span class="s2">datum </span><span class="s4">=&gt; </span><span class="s2">_insert</span><span class="s4">(</span><span class="s2">datum</span><span class="s4">, </span><span class="s3">true</span><span class="s4">, </span><span class="s3">false</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">))</span>
            <span class="s4">}</span>
            <span class="s3">return </span><span class="s2">_insert</span><span class="s4">(</span><span class="s2">data</span><span class="s4">, </span><span class="s3">true</span><span class="s4">, </span><span class="s3">false</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">);</span>
        <span class="s4">},</span>
        <span class="s2">unshiftAsync </span><span class="s4">(</span><span class="s2">data</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
            <span class="s3">if </span><span class="s4">(</span><span class="s2">Array</span><span class="s4">.</span><span class="s2">isArray</span><span class="s4">(</span><span class="s2">data</span><span class="s4">)) {</span>
                <span class="s3">if </span><span class="s4">(</span><span class="s2">_maybeDrain</span><span class="s4">(</span><span class="s2">data</span><span class="s4">)) </span><span class="s3">return</span>
                <span class="s3">return </span><span class="s2">data</span><span class="s4">.</span><span class="s2">map</span><span class="s4">(</span><span class="s2">datum </span><span class="s4">=&gt; </span><span class="s2">_insert</span><span class="s4">(</span><span class="s2">datum</span><span class="s4">, </span><span class="s3">true</span><span class="s4">, </span><span class="s3">true</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">))</span>
            <span class="s4">}</span>
            <span class="s3">return </span><span class="s2">_insert</span><span class="s4">(</span><span class="s2">data</span><span class="s4">, </span><span class="s3">true</span><span class="s4">, </span><span class="s3">true</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">);</span>
        <span class="s4">},</span>
        <span class="s2">remove </span><span class="s4">(</span><span class="s2">testFn</span><span class="s4">) {</span>
            <span class="s2">q</span><span class="s4">.</span><span class="s2">_tasks</span><span class="s4">.</span><span class="s2">remove</span><span class="s4">(</span><span class="s2">testFn</span><span class="s4">);</span>
        <span class="s4">},</span>
        <span class="s2">process </span><span class="s4">() {</span>
            <span class="s5">// Avoid trying to start too many processing operations. This can occur</span>
            <span class="s5">// when callbacks resolve synchronously (#1267).</span>
            <span class="s3">if </span><span class="s4">(</span><span class="s2">isProcessing</span><span class="s4">) {</span>
                <span class="s3">return</span><span class="s4">;</span>
            <span class="s4">}</span>
            <span class="s2">isProcessing </span><span class="s4">= </span><span class="s3">true</span><span class="s4">;</span>
            <span class="s3">while</span><span class="s4">(!</span><span class="s2">q</span><span class="s4">.</span><span class="s2">paused </span><span class="s4">&amp;&amp; </span><span class="s2">numRunning </span><span class="s4">&lt; </span><span class="s2">q</span><span class="s4">.</span><span class="s2">concurrency </span><span class="s4">&amp;&amp; </span><span class="s2">q</span><span class="s4">.</span><span class="s2">_tasks</span><span class="s4">.</span><span class="s2">length</span><span class="s4">){</span>
                <span class="s3">var </span><span class="s2">tasks </span><span class="s4">= [], </span><span class="s2">data </span><span class="s4">= [];</span>
                <span class="s3">var </span><span class="s2">l </span><span class="s4">= </span><span class="s2">q</span><span class="s4">.</span><span class="s2">_tasks</span><span class="s4">.</span><span class="s2">length</span><span class="s4">;</span>
                <span class="s3">if </span><span class="s4">(</span><span class="s2">q</span><span class="s4">.</span><span class="s2">payload</span><span class="s4">) </span><span class="s2">l </span><span class="s4">= </span><span class="s2">Math</span><span class="s4">.</span><span class="s2">min</span><span class="s4">(</span><span class="s2">l</span><span class="s4">, </span><span class="s2">q</span><span class="s4">.</span><span class="s2">payload</span><span class="s4">);</span>
                <span class="s3">for </span><span class="s4">(</span><span class="s3">var </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s2">l</span><span class="s4">; </span><span class="s2">i</span><span class="s4">++) {</span>
                    <span class="s3">var </span><span class="s2">node </span><span class="s4">= </span><span class="s2">q</span><span class="s4">.</span><span class="s2">_tasks</span><span class="s4">.</span><span class="s2">shift</span><span class="s4">();</span>
                    <span class="s2">tasks</span><span class="s4">.</span><span class="s2">push</span><span class="s4">(</span><span class="s2">node</span><span class="s4">);</span>
                    <span class="s2">workersList</span><span class="s4">.</span><span class="s2">push</span><span class="s4">(</span><span class="s2">node</span><span class="s4">);</span>
                    <span class="s2">data</span><span class="s4">.</span><span class="s2">push</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">data</span><span class="s4">);</span>
                <span class="s4">}</span>

                <span class="s2">numRunning </span><span class="s4">+= </span><span class="s7">1</span><span class="s4">;</span>

                <span class="s3">if </span><span class="s4">(</span><span class="s2">q</span><span class="s4">.</span><span class="s2">_tasks</span><span class="s4">.</span><span class="s2">length </span><span class="s4">=== </span><span class="s7">0</span><span class="s4">) {</span>
                    <span class="s2">trigger</span><span class="s4">(</span><span class="s6">'empty'</span><span class="s4">);</span>
                <span class="s4">}</span>

                <span class="s3">if </span><span class="s4">(</span><span class="s2">numRunning </span><span class="s4">=== </span><span class="s2">q</span><span class="s4">.</span><span class="s2">concurrency</span><span class="s4">) {</span>
                    <span class="s2">trigger</span><span class="s4">(</span><span class="s6">'saturated'</span><span class="s4">);</span>
                <span class="s4">}</span>

                <span class="s3">var </span><span class="s2">cb </span><span class="s4">= </span><span class="s2">onlyOnce</span><span class="s4">(</span><span class="s2">_createCB</span><span class="s4">(</span><span class="s2">tasks</span><span class="s4">));</span>
                <span class="s2">_worker</span><span class="s4">(</span><span class="s2">data</span><span class="s4">, </span><span class="s2">cb</span><span class="s4">);</span>
            <span class="s4">}</span>
            <span class="s2">isProcessing </span><span class="s4">= </span><span class="s3">false</span><span class="s4">;</span>
        <span class="s4">},</span>
        <span class="s2">length </span><span class="s4">() {</span>
            <span class="s3">return </span><span class="s2">q</span><span class="s4">.</span><span class="s2">_tasks</span><span class="s4">.</span><span class="s2">length</span><span class="s4">;</span>
        <span class="s4">},</span>
        <span class="s2">running </span><span class="s4">() {</span>
            <span class="s3">return </span><span class="s2">numRunning</span><span class="s4">;</span>
        <span class="s4">},</span>
        <span class="s2">workersList </span><span class="s4">() {</span>
            <span class="s3">return </span><span class="s2">workersList</span><span class="s4">;</span>
        <span class="s4">},</span>
        <span class="s2">idle</span><span class="s4">() {</span>
            <span class="s3">return </span><span class="s2">q</span><span class="s4">.</span><span class="s2">_tasks</span><span class="s4">.</span><span class="s2">length </span><span class="s4">+ </span><span class="s2">numRunning </span><span class="s4">=== </span><span class="s7">0</span><span class="s4">;</span>
        <span class="s4">},</span>
        <span class="s2">pause </span><span class="s4">() {</span>
            <span class="s2">q</span><span class="s4">.</span><span class="s2">paused </span><span class="s4">= </span><span class="s3">true</span><span class="s4">;</span>
        <span class="s4">},</span>
        <span class="s2">resume </span><span class="s4">() {</span>
            <span class="s3">if </span><span class="s4">(</span><span class="s2">q</span><span class="s4">.</span><span class="s2">paused </span><span class="s4">=== </span><span class="s3">false</span><span class="s4">) { </span><span class="s3">return</span><span class="s4">; }</span>
            <span class="s2">q</span><span class="s4">.</span><span class="s2">paused </span><span class="s4">= </span><span class="s3">false</span><span class="s4">;</span>
            <span class="s2">setImmediate$1</span><span class="s4">(</span><span class="s2">q</span><span class="s4">.</span><span class="s2">process</span><span class="s4">);</span>
        <span class="s4">}</span>
    <span class="s4">};</span>
    <span class="s5">// define these as fixed properties, so people get useful errors when updating</span>
    <span class="s2">Object</span><span class="s4">.</span><span class="s2">defineProperties</span><span class="s4">(</span><span class="s2">q</span><span class="s4">, {</span>
        <span class="s2">saturated</span><span class="s4">: {</span>
            <span class="s2">writable</span><span class="s4">: </span><span class="s3">false</span><span class="s4">,</span>
            <span class="s2">value</span><span class="s4">: </span><span class="s2">eventMethod</span><span class="s4">(</span><span class="s6">'saturated'</span><span class="s4">)</span>
        <span class="s4">},</span>
        <span class="s2">unsaturated</span><span class="s4">: {</span>
            <span class="s2">writable</span><span class="s4">: </span><span class="s3">false</span><span class="s4">,</span>
            <span class="s2">value</span><span class="s4">: </span><span class="s2">eventMethod</span><span class="s4">(</span><span class="s6">'unsaturated'</span><span class="s4">)</span>
        <span class="s4">},</span>
        <span class="s2">empty</span><span class="s4">: {</span>
            <span class="s2">writable</span><span class="s4">: </span><span class="s3">false</span><span class="s4">,</span>
            <span class="s2">value</span><span class="s4">: </span><span class="s2">eventMethod</span><span class="s4">(</span><span class="s6">'empty'</span><span class="s4">)</span>
        <span class="s4">},</span>
        <span class="s2">drain</span><span class="s4">: {</span>
            <span class="s2">writable</span><span class="s4">: </span><span class="s3">false</span><span class="s4">,</span>
            <span class="s2">value</span><span class="s4">: </span><span class="s2">eventMethod</span><span class="s4">(</span><span class="s6">'drain'</span><span class="s4">)</span>
        <span class="s4">},</span>
        <span class="s2">error</span><span class="s4">: {</span>
            <span class="s2">writable</span><span class="s4">: </span><span class="s3">false</span><span class="s4">,</span>
            <span class="s2">value</span><span class="s4">: </span><span class="s2">eventMethod</span><span class="s4">(</span><span class="s6">'error'</span><span class="s4">)</span>
        <span class="s4">},</span>
    <span class="s4">});</span>
    <span class="s3">return </span><span class="s2">q</span><span class="s4">;</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Creates a `cargo` object with the specified payload. Tasks added to the</span>
 <span class="s0">* cargo will be processed altogether (up to the `payload` limit). If the</span>
 <span class="s0">* `worker` is in progress, the task is queued until it becomes available. Once</span>
 <span class="s0">* the `worker` has completed some tasks, each callback of those tasks is</span>
 <span class="s0">* called. Check out [these](https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966) [animations](https://camo.githubusercontent.com/f4810e00e1c5f5f8addbe3e9f49064fd5d102699/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130312f38346339323036362d356632392d313165322d383134662d3964336430323431336266642e676966)</span>
 <span class="s0">* for how `cargo` and `queue` work.</span>
 <span class="s0">*</span>
 <span class="s0">* While [`queue`]{</span><span class="s1">@link </span><span class="s0">module:ControlFlow.queue} passes only one task to one of a group of workers</span>
 <span class="s0">* at a time, cargo passes an array of tasks to a single worker, repeating</span>
 <span class="s0">* when the worker is finished.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">cargo</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:ControlFlow</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s0">[async.queue]{</span><span class="s1">@link </span><span class="s0">module:ControlFlow.queue}</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Control Flow</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{AsyncFunction} worker - An asynchronous function for processing an array</span>
 <span class="s0">* of queued tasks. Invoked with `(tasks, callback)`.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{number} [payload=Infinity] - An optional `integer` for determining</span>
 <span class="s0">* how many tasks should be processed per round; if omitted, the default is</span>
 <span class="s0">* unlimited.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{module:ControlFlow.QueueObject} A cargo object to manage the tasks. Callbacks can</span>
 <span class="s0">* attached as certain properties to listen for specific events during the</span>
 <span class="s0">* lifecycle of the cargo and inner queue.</span>
 <span class="s0">* </span><span class="s1">@example</span>
 <span class="s0">*</span>
 <span class="s0">* // create a cargo object with payload 2</span>
 <span class="s0">* var cargo = async.cargo(function(tasks, callback) {</span>
 <span class="s0">*     for (var i=0; i&lt;tasks.length; i++) {</span>
 <span class="s0">*         console.log('hello ' + tasks[i].name);</span>
 <span class="s0">*     }</span>
 <span class="s0">*     callback();</span>
 <span class="s0">* }, 2);</span>
 <span class="s0">*</span>
 <span class="s0">* // add some items</span>
 <span class="s0">* cargo.push({name: 'foo'}, function(err) {</span>
 <span class="s0">*     console.log('finished processing foo');</span>
 <span class="s0">* });</span>
 <span class="s0">* cargo.push({name: 'bar'}, function(err) {</span>
 <span class="s0">*     console.log('finished processing bar');</span>
 <span class="s0">* });</span>
 <span class="s0">* await cargo.push({name: 'baz'});</span>
 <span class="s0">* console.log('finished processing baz');</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">cargo$1</span><span class="s4">(</span><span class="s2">worker</span><span class="s4">, </span><span class="s2">payload</span><span class="s4">) {</span>
    <span class="s3">return </span><span class="s2">queue$1</span><span class="s4">(</span><span class="s2">worker</span><span class="s4">, </span><span class="s7">1</span><span class="s4">, </span><span class="s2">payload</span><span class="s4">);</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Creates a `cargoQueue` object with the specified payload. Tasks added to the</span>
 <span class="s0">* cargoQueue will be processed together (up to the `payload` limit) in `concurrency` parallel workers.</span>
 <span class="s0">* If the all `workers` are in progress, the task is queued until one becomes available. Once</span>
 <span class="s0">* a `worker` has completed some tasks, each callback of those tasks is</span>
 <span class="s0">* called. Check out [these](https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966) [animations](https://camo.githubusercontent.com/f4810e00e1c5f5f8addbe3e9f49064fd5d102699/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130312f38346339323036362d356632392d313165322d383134662d3964336430323431336266642e676966)</span>
 <span class="s0">* for how `cargo` and `queue` work.</span>
 <span class="s0">*</span>
 <span class="s0">* While [`queue`]{</span><span class="s1">@link </span><span class="s0">module:ControlFlow.queue} passes only one task to one of a group of workers</span>
 <span class="s0">* at a time, and [`cargo`]{</span><span class="s1">@link </span><span class="s0">module:ControlFlow.cargo} passes an array of tasks to a single worker,</span>
 <span class="s0">* the cargoQueue passes an array of tasks to multiple parallel workers.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">cargoQueue</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:ControlFlow</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s0">[async.queue]{</span><span class="s1">@link </span><span class="s0">module:ControlFlow.queue}</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s0">[async.cargo]{</span><span class="s1">@link </span><span class="s0">module:ControlFLow.cargo}</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Control Flow</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{AsyncFunction} worker - An asynchronous function for processing an array</span>
 <span class="s0">* of queued tasks. Invoked with `(tasks, callback)`.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{number} [concurrency=1] - An `integer` for determining how many</span>
 <span class="s0">* `worker` functions should be run in parallel.  If omitted, the concurrency</span>
 <span class="s0">* defaults to `1`.  If the concurrency is `0`, an error is thrown.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{number} [payload=Infinity] - An optional `integer` for determining</span>
 <span class="s0">* how many tasks should be processed per round; if omitted, the default is</span>
 <span class="s0">* unlimited.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{module:ControlFlow.QueueObject} A cargoQueue object to manage the tasks. Callbacks can</span>
 <span class="s0">* attached as certain properties to listen for specific events during the</span>
 <span class="s0">* lifecycle of the cargoQueue and inner queue.</span>
 <span class="s0">* </span><span class="s1">@example</span>
 <span class="s0">*</span>
 <span class="s0">* // create a cargoQueue object with payload 2 and concurrency 2</span>
 <span class="s0">* var cargoQueue = async.cargoQueue(function(tasks, callback) {</span>
 <span class="s0">*     for (var i=0; i&lt;tasks.length; i++) {</span>
 <span class="s0">*         console.log('hello ' + tasks[i].name);</span>
 <span class="s0">*     }</span>
 <span class="s0">*     callback();</span>
 <span class="s0">* }, 2, 2);</span>
 <span class="s0">*</span>
 <span class="s0">* // add some items</span>
 <span class="s0">* cargoQueue.push({name: 'foo'}, function(err) {</span>
 <span class="s0">*     console.log('finished processing foo');</span>
 <span class="s0">* });</span>
 <span class="s0">* cargoQueue.push({name: 'bar'}, function(err) {</span>
 <span class="s0">*     console.log('finished processing bar');</span>
 <span class="s0">* });</span>
 <span class="s0">* cargoQueue.push({name: 'baz'}, function(err) {</span>
 <span class="s0">*     console.log('finished processing baz');</span>
 <span class="s0">* });</span>
 <span class="s0">* cargoQueue.push({name: 'boo'}, function(err) {</span>
 <span class="s0">*     console.log('finished processing boo');</span>
 <span class="s0">* });</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">cargo</span><span class="s4">(</span><span class="s2">worker</span><span class="s4">, </span><span class="s2">concurrency</span><span class="s4">, </span><span class="s2">payload</span><span class="s4">) {</span>
    <span class="s3">return </span><span class="s2">queue$1</span><span class="s4">(</span><span class="s2">worker</span><span class="s4">, </span><span class="s2">concurrency</span><span class="s4">, </span><span class="s2">payload</span><span class="s4">);</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Reduces `coll` into a single value using an async `iteratee` to return each</span>
 <span class="s0">* successive step. `memo` is the initial state of the reduction. This function</span>
 <span class="s0">* only operates in series.</span>
 <span class="s0">*</span>
 <span class="s0">* For performance reasons, it may make sense to split a call to this function</span>
 <span class="s0">* into a parallel map, and then use the normal `Array.prototype.reduce` on the</span>
 <span class="s0">* results. This function is for situations where each step in the reduction</span>
 <span class="s0">* needs to be async; if you can get the data before reducing it, then it's</span>
 <span class="s0">* probably a good idea to do so.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">reduce</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@alias </span><span class="s0">inject</span>
 <span class="s0">* </span><span class="s1">@alias </span><span class="s0">foldl</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collection</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{*} memo - The initial state of the reduction.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{AsyncFunction} iteratee - A function applied to each item in the</span>
 <span class="s0">* array to produce the next step in the reduction.</span>
 <span class="s0">* The `iteratee` should complete with the next state of the reduction.</span>
 <span class="s0">* If the iteratee completes with an error, the reduction is stopped and the</span>
 <span class="s0">* main `callback` is immediately called with the error.</span>
 <span class="s0">* Invoked with (memo, item, callback).</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} [callback] - A callback which is called after all the</span>
 <span class="s0">* `iteratee` functions have finished. Result is the reduced value. Invoked with</span>
 <span class="s0">* (err, result).</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise} a promise, if no callback is passed</span>
 <span class="s0">* </span><span class="s1">@example</span>
 <span class="s0">*</span>
 <span class="s0">* // file1.txt is a file that is 1000 bytes in size</span>
 <span class="s0">* // file2.txt is a file that is 2000 bytes in size</span>
 <span class="s0">* // file3.txt is a file that is 3000 bytes in size</span>
 <span class="s0">* // file4.txt does not exist</span>
 <span class="s0">*</span>
 <span class="s0">* const fileList = ['file1.txt','file2.txt','file3.txt'];</span>
 <span class="s0">* const withMissingFileList = ['file1.txt','file2.txt','file3.txt', 'file4.txt'];</span>
 <span class="s0">*</span>
 <span class="s0">* // asynchronous function that computes the file size in bytes</span>
 <span class="s0">* // file size is added to the memoized value, then returned</span>
 <span class="s0">* function getFileSizeInBytes(memo, file, callback) {</span>
 <span class="s0">*     fs.stat(file, function(err, stat) {</span>
 <span class="s0">*         if (err) {</span>
 <span class="s0">*             return callback(err);</span>
 <span class="s0">*         }</span>
 <span class="s0">*         callback(null, memo + stat.size);</span>
 <span class="s0">*     });</span>
 <span class="s0">* }</span>
 <span class="s0">*</span>
 <span class="s0">* // Using callbacks</span>
 <span class="s0">* async.reduce(fileList, 0, getFileSizeInBytes, function(err, result) {</span>
 <span class="s0">*     if (err) {</span>
 <span class="s0">*         console.log(err);</span>
 <span class="s0">*     } else {</span>
 <span class="s0">*         console.log(result);</span>
 <span class="s0">*         // 6000</span>
 <span class="s0">*         // which is the sum of the file sizes of the three files</span>
 <span class="s0">*     }</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* // Error Handling</span>
 <span class="s0">* async.reduce(withMissingFileList, 0, getFileSizeInBytes, function(err, result) {</span>
 <span class="s0">*     if (err) {</span>
 <span class="s0">*         console.log(err);</span>
 <span class="s0">*         // [ Error: ENOENT: no such file or directory ]</span>
 <span class="s0">*     } else {</span>
 <span class="s0">*         console.log(result);</span>
 <span class="s0">*     }</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* // Using Promises</span>
 <span class="s0">* async.reduce(fileList, 0, getFileSizeInBytes)</span>
 <span class="s0">* .then( result =&gt; {</span>
 <span class="s0">*     console.log(result);</span>
 <span class="s0">*     // 6000</span>
 <span class="s0">*     // which is the sum of the file sizes of the three files</span>
 <span class="s0">* }).catch( err =&gt; {</span>
 <span class="s0">*     console.log(err);</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* // Error Handling</span>
 <span class="s0">* async.reduce(withMissingFileList, 0, getFileSizeInBytes)</span>
 <span class="s0">* .then( result =&gt; {</span>
 <span class="s0">*     console.log(result);</span>
 <span class="s0">* }).catch( err =&gt; {</span>
 <span class="s0">*     console.log(err);</span>
 <span class="s0">*     // [ Error: ENOENT: no such file or directory ]</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* // Using async/await</span>
 <span class="s0">* async () =&gt; {</span>
 <span class="s0">*     try {</span>
 <span class="s0">*         let result = await async.reduce(fileList, 0, getFileSizeInBytes);</span>
 <span class="s0">*         console.log(result);</span>
 <span class="s0">*         // 6000</span>
 <span class="s0">*         // which is the sum of the file sizes of the three files</span>
 <span class="s0">*     }</span>
 <span class="s0">*     catch (err) {</span>
 <span class="s0">*         console.log(err);</span>
 <span class="s0">*     }</span>
 <span class="s0">* }</span>
 <span class="s0">*</span>
 <span class="s0">* // Error Handling</span>
 <span class="s0">* async () =&gt; {</span>
 <span class="s0">*     try {</span>
 <span class="s0">*         let result = await async.reduce(withMissingFileList, 0, getFileSizeInBytes);</span>
 <span class="s0">*         console.log(result);</span>
 <span class="s0">*     }</span>
 <span class="s0">*     catch (err) {</span>
 <span class="s0">*         console.log(err);</span>
 <span class="s0">*         // [ Error: ENOENT: no such file or directory ]</span>
 <span class="s0">*     }</span>
 <span class="s0">* }</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">reduce</span><span class="s4">(</span><span class="s2">coll</span><span class="s4">, </span><span class="s2">memo</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
    <span class="s2">callback </span><span class="s4">= </span><span class="s2">once</span><span class="s4">(</span><span class="s2">callback</span><span class="s4">);</span>
    <span class="s3">var </span><span class="s2">_iteratee </span><span class="s4">= </span><span class="s2">wrapAsync</span><span class="s4">(</span><span class="s2">iteratee</span><span class="s4">);</span>
    <span class="s3">return </span><span class="s2">eachOfSeries$1</span><span class="s4">(</span><span class="s2">coll</span><span class="s4">, (</span><span class="s2">x</span><span class="s4">, </span><span class="s2">i</span><span class="s4">, </span><span class="s2">iterCb</span><span class="s4">) =&gt; {</span>
        <span class="s2">_iteratee</span><span class="s4">(</span><span class="s2">memo</span><span class="s4">, </span><span class="s2">x</span><span class="s4">, (</span><span class="s2">err</span><span class="s4">, </span><span class="s2">v</span><span class="s4">) =&gt; {</span>
            <span class="s2">memo </span><span class="s4">= </span><span class="s2">v</span><span class="s4">;</span>
            <span class="s2">iterCb</span><span class="s4">(</span><span class="s2">err</span><span class="s4">);</span>
        <span class="s4">});</span>
    <span class="s4">}, </span><span class="s2">err </span><span class="s4">=&gt; </span><span class="s2">callback</span><span class="s4">(</span><span class="s2">err</span><span class="s4">, </span><span class="s2">memo</span><span class="s4">));</span>
<span class="s4">}</span>
<span class="s3">var </span><span class="s2">reduce$1 </span><span class="s4">= </span><span class="s2">awaitify</span><span class="s4">(</span><span class="s2">reduce</span><span class="s4">, </span><span class="s7">4</span><span class="s4">);</span>

<span class="s0">/**</span>
 <span class="s0">* Version of the compose function that is more natural to read. Each function</span>
 <span class="s0">* consumes the return value of the previous function. It is the equivalent of</span>
 <span class="s0">* [compose]{</span><span class="s1">@link </span><span class="s0">module:ControlFlow.compose} with the arguments reversed.</span>
 <span class="s0">*</span>
 <span class="s0">* Each function is executed with the `this` binding of the composed function.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">seq</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:ControlFlow</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s0">[async.compose]{</span><span class="s1">@link </span><span class="s0">module:ControlFlow.compose}</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Control Flow</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{...AsyncFunction} functions - the asynchronous functions to compose</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Function} a function that composes the `functions` in order</span>
 <span class="s0">* </span><span class="s1">@example</span>
 <span class="s0">*</span>
 <span class="s0">* // Requires lodash (or underscore), express3 and dresende's orm2.</span>
 <span class="s0">* // Part of an app, that fetches cats of the logged user.</span>
 <span class="s0">* // This example uses `seq` function to avoid overnesting and error</span>
 <span class="s0">* // handling clutter.</span>
 <span class="s0">* app.get('/cats', function(request, response) {</span>
 <span class="s0">*     var User = request.models.User;</span>
 <span class="s0">*     async.seq(</span>
 <span class="s0">*         User.get.bind(User),  // 'User.get' has signature (id, callback(err, data))</span>
 <span class="s0">*         function(user, fn) {</span>
 <span class="s0">*             user.getCats(fn);      // 'getCats' has signature (callback(err, data))</span>
 <span class="s0">*         }</span>
 <span class="s0">*     )(req.session.user_id, function (err, cats) {</span>
 <span class="s0">*         if (err) {</span>
 <span class="s0">*             console.error(err);</span>
 <span class="s0">*             response.json({ status: 'error', message: err.message });</span>
 <span class="s0">*         } else {</span>
 <span class="s0">*             response.json({ status: 'ok', message: 'Cats found', data: cats });</span>
 <span class="s0">*         }</span>
 <span class="s0">*     });</span>
 <span class="s0">* });</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">seq</span><span class="s4">(</span><span class="s2">...functions</span><span class="s4">) {</span>
    <span class="s3">var </span><span class="s2">_functions </span><span class="s4">= </span><span class="s2">functions</span><span class="s4">.</span><span class="s2">map</span><span class="s4">(</span><span class="s2">wrapAsync</span><span class="s4">);</span>
    <span class="s3">return function </span><span class="s4">(</span><span class="s2">...args</span><span class="s4">) {</span>
        <span class="s3">var </span><span class="s2">that </span><span class="s4">= </span><span class="s3">this</span><span class="s4">;</span>

        <span class="s3">var </span><span class="s2">cb </span><span class="s4">= </span><span class="s2">args</span><span class="s4">[</span><span class="s2">args</span><span class="s4">.</span><span class="s2">length </span><span class="s4">- </span><span class="s7">1</span><span class="s4">];</span>
        <span class="s3">if </span><span class="s4">(</span><span class="s3">typeof </span><span class="s2">cb </span><span class="s4">== </span><span class="s6">'function'</span><span class="s4">) {</span>
            <span class="s2">args</span><span class="s4">.</span><span class="s2">pop</span><span class="s4">();</span>
        <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
            <span class="s2">cb </span><span class="s4">= </span><span class="s2">promiseCallback</span><span class="s4">();</span>
        <span class="s4">}</span>

        <span class="s2">reduce$1</span><span class="s4">(</span><span class="s2">_functions</span><span class="s4">, </span><span class="s2">args</span><span class="s4">, (</span><span class="s2">newargs</span><span class="s4">, </span><span class="s2">fn</span><span class="s4">, </span><span class="s2">iterCb</span><span class="s4">) =&gt; {</span>
            <span class="s2">fn</span><span class="s4">.</span><span class="s2">apply</span><span class="s4">(</span><span class="s2">that</span><span class="s4">, </span><span class="s2">newargs</span><span class="s4">.</span><span class="s2">concat</span><span class="s4">((</span><span class="s2">err</span><span class="s4">, </span><span class="s2">...nextargs</span><span class="s4">) =&gt; {</span>
                <span class="s2">iterCb</span><span class="s4">(</span><span class="s2">err</span><span class="s4">, </span><span class="s2">nextargs</span><span class="s4">);</span>
            <span class="s4">}));</span>
        <span class="s4">},</span>
        <span class="s4">(</span><span class="s2">err</span><span class="s4">, </span><span class="s2">results</span><span class="s4">) =&gt; </span><span class="s2">cb</span><span class="s4">(</span><span class="s2">err</span><span class="s4">, </span><span class="s2">...results</span><span class="s4">));</span>

        <span class="s3">return </span><span class="s2">cb</span><span class="s4">[</span><span class="s2">PROMISE_SYMBOL</span><span class="s4">]</span>
    <span class="s4">};</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Creates a function which is a composition of the passed asynchronous</span>
 <span class="s0">* functions. Each function consumes the return value of the function that</span>
 <span class="s0">* follows. Composing functions `f()`, `g()`, and `h()` would produce the result</span>
 <span class="s0">* of `f(g(h()))`, only this version uses callbacks to obtain the return values.</span>
 <span class="s0">*</span>
 <span class="s0">* If the last argument to the composed function is not a function, a promise</span>
 <span class="s0">* is returned when you call it.</span>
 <span class="s0">*</span>
 <span class="s0">* Each function is executed with the `this` binding of the composed function.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">compose</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:ControlFlow</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Control Flow</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{...AsyncFunction} functions - the asynchronous functions to compose</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Function} an asynchronous function that is the composed</span>
 <span class="s0">* asynchronous `functions`</span>
 <span class="s0">* </span><span class="s1">@example</span>
 <span class="s0">*</span>
 <span class="s0">* function add1(n, callback) {</span>
 <span class="s0">*     setTimeout(function () {</span>
 <span class="s0">*         callback(null, n + 1);</span>
 <span class="s0">*     }, 10);</span>
 <span class="s0">* }</span>
 <span class="s0">*</span>
 <span class="s0">* function mul3(n, callback) {</span>
 <span class="s0">*     setTimeout(function () {</span>
 <span class="s0">*         callback(null, n * 3);</span>
 <span class="s0">*     }, 10);</span>
 <span class="s0">* }</span>
 <span class="s0">*</span>
 <span class="s0">* var add1mul3 = async.compose(mul3, add1);</span>
 <span class="s0">* add1mul3(4, function (err, result) {</span>
 <span class="s0">*     // result now equals 15</span>
 <span class="s0">* });</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">compose</span><span class="s4">(</span><span class="s2">...args</span><span class="s4">) {</span>
    <span class="s3">return </span><span class="s2">seq</span><span class="s4">(</span><span class="s2">...args</span><span class="s4">.</span><span class="s2">reverse</span><span class="s4">());</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* The same as [`map`]{</span><span class="s1">@link </span><span class="s0">module:Collections.map} but runs a maximum of `limit` async operations at a time.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">mapLimit</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s0">[async.map]{</span><span class="s1">@link </span><span class="s0">module:Collections.map}</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collection</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{number} limit - The maximum number of async operations at a time.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{AsyncFunction} iteratee - An async function to apply to each item in</span>
 <span class="s0">* `coll`.</span>
 <span class="s0">* The iteratee should complete with the transformed item.</span>
 <span class="s0">* Invoked with (item, callback).</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} [callback] - A callback which is called when all `iteratee`</span>
 <span class="s0">* functions have finished, or an error occurs. Results is an array of the</span>
 <span class="s0">* transformed items from the `coll`. Invoked with (err, results).</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise} a promise, if no callback is passed</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">mapLimit </span><span class="s4">(</span><span class="s2">coll</span><span class="s4">, </span><span class="s2">limit</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
    <span class="s3">return </span><span class="s2">_asyncMap</span><span class="s4">(</span><span class="s2">eachOfLimit$2</span><span class="s4">(</span><span class="s2">limit</span><span class="s4">), </span><span class="s2">coll</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">)</span>
<span class="s4">}</span>
<span class="s3">var </span><span class="s2">mapLimit$1 </span><span class="s4">= </span><span class="s2">awaitify</span><span class="s4">(</span><span class="s2">mapLimit</span><span class="s4">, </span><span class="s7">4</span><span class="s4">);</span>

<span class="s0">/**</span>
 <span class="s0">* The same as [`concat`]{</span><span class="s1">@link </span><span class="s0">module:Collections.concat} but runs a maximum of `limit` async operations at a time.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">concatLimit</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s0">[async.concat]{</span><span class="s1">@link </span><span class="s0">module:Collections.concat}</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collection</span>
 <span class="s0">* </span><span class="s1">@alias </span><span class="s0">flatMapLimit</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{number} limit - The maximum number of async operations at a time.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{AsyncFunction} iteratee - A function to apply to each item in `coll`,</span>
 <span class="s0">* which should use an array as its result. Invoked with (item, callback).</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} [callback] - A callback which is called after all the</span>
 <span class="s0">* `iteratee` functions have finished, or an error occurs. Results is an array</span>
 <span class="s0">* containing the concatenated results of the `iteratee` function. Invoked with</span>
 <span class="s0">* (err, results).</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">A Promise, if no callback is passed</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">concatLimit</span><span class="s4">(</span><span class="s2">coll</span><span class="s4">, </span><span class="s2">limit</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
    <span class="s3">var </span><span class="s2">_iteratee </span><span class="s4">= </span><span class="s2">wrapAsync</span><span class="s4">(</span><span class="s2">iteratee</span><span class="s4">);</span>
    <span class="s3">return </span><span class="s2">mapLimit$1</span><span class="s4">(</span><span class="s2">coll</span><span class="s4">, </span><span class="s2">limit</span><span class="s4">, (</span><span class="s2">val</span><span class="s4">, </span><span class="s2">iterCb</span><span class="s4">) =&gt; {</span>
        <span class="s2">_iteratee</span><span class="s4">(</span><span class="s2">val</span><span class="s4">, (</span><span class="s2">err</span><span class="s4">, </span><span class="s2">...args</span><span class="s4">) =&gt; {</span>
            <span class="s3">if </span><span class="s4">(</span><span class="s2">err</span><span class="s4">) </span><span class="s3">return </span><span class="s2">iterCb</span><span class="s4">(</span><span class="s2">err</span><span class="s4">);</span>
            <span class="s3">return </span><span class="s2">iterCb</span><span class="s4">(</span><span class="s2">err</span><span class="s4">, </span><span class="s2">args</span><span class="s4">);</span>
        <span class="s4">});</span>
    <span class="s4">}, (</span><span class="s2">err</span><span class="s4">, </span><span class="s2">mapResults</span><span class="s4">) =&gt; {</span>
        <span class="s3">var </span><span class="s2">result </span><span class="s4">= [];</span>
        <span class="s3">for </span><span class="s4">(</span><span class="s3">var </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s2">mapResults</span><span class="s4">.</span><span class="s2">length</span><span class="s4">; </span><span class="s2">i</span><span class="s4">++) {</span>
            <span class="s3">if </span><span class="s4">(</span><span class="s2">mapResults</span><span class="s4">[</span><span class="s2">i</span><span class="s4">]) {</span>
                <span class="s2">result </span><span class="s4">= </span><span class="s2">result</span><span class="s4">.</span><span class="s2">concat</span><span class="s4">(</span><span class="s2">...mapResults</span><span class="s4">[</span><span class="s2">i</span><span class="s4">]);</span>
            <span class="s4">}</span>
        <span class="s4">}</span>

        <span class="s3">return </span><span class="s2">callback</span><span class="s4">(</span><span class="s2">err</span><span class="s4">, </span><span class="s2">result</span><span class="s4">);</span>
    <span class="s4">});</span>
<span class="s4">}</span>
<span class="s3">var </span><span class="s2">concatLimit$1 </span><span class="s4">= </span><span class="s2">awaitify</span><span class="s4">(</span><span class="s2">concatLimit</span><span class="s4">, </span><span class="s7">4</span><span class="s4">);</span>

<span class="s0">/**</span>
 <span class="s0">* Applies `iteratee` to each item in `coll`, concatenating the results. Returns</span>
 <span class="s0">* the concatenated list. The `iteratee`s are called in parallel, and the</span>
 <span class="s0">* results are concatenated as they return. The results array will be returned in</span>
 <span class="s0">* the original order of `coll` passed to the `iteratee` function.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">concat</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collection</span>
 <span class="s0">* </span><span class="s1">@alias </span><span class="s0">flatMap</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{AsyncFunction} iteratee - A function to apply to each item in `coll`,</span>
 <span class="s0">* which should use an array as its result. Invoked with (item, callback).</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} [callback] - A callback which is called after all the</span>
 <span class="s0">* `iteratee` functions have finished, or an error occurs. Results is an array</span>
 <span class="s0">* containing the concatenated results of the `iteratee` function. Invoked with</span>
 <span class="s0">* (err, results).</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">A Promise, if no callback is passed</span>
 <span class="s0">* </span><span class="s1">@example</span>
 <span class="s0">*</span>
 <span class="s0">* // dir1 is a directory that contains file1.txt, file2.txt</span>
 <span class="s0">* // dir2 is a directory that contains file3.txt, file4.txt</span>
 <span class="s0">* // dir3 is a directory that contains file5.txt</span>
 <span class="s0">* // dir4 does not exist</span>
 <span class="s0">*</span>
 <span class="s0">* let directoryList = ['dir1','dir2','dir3'];</span>
 <span class="s0">* let withMissingDirectoryList = ['dir1','dir2','dir3', 'dir4'];</span>
 <span class="s0">*</span>
 <span class="s0">* // Using callbacks</span>
 <span class="s0">* async.concat(directoryList, fs.readdir, function(err, results) {</span>
 <span class="s0">*    if (err) {</span>
 <span class="s0">*        console.log(err);</span>
 <span class="s0">*    } else {</span>
 <span class="s0">*        console.log(results);</span>
 <span class="s0">*        // [ 'file1.txt', 'file2.txt', 'file3.txt', 'file4.txt', file5.txt ]</span>
 <span class="s0">*    }</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* // Error Handling</span>
 <span class="s0">* async.concat(withMissingDirectoryList, fs.readdir, function(err, results) {</span>
 <span class="s0">*    if (err) {</span>
 <span class="s0">*        console.log(err);</span>
 <span class="s0">*        // [ Error: ENOENT: no such file or directory ]</span>
 <span class="s0">*        // since dir4 does not exist</span>
 <span class="s0">*    } else {</span>
 <span class="s0">*        console.log(results);</span>
 <span class="s0">*    }</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* // Using Promises</span>
 <span class="s0">* async.concat(directoryList, fs.readdir)</span>
 <span class="s0">* .then(results =&gt; {</span>
 <span class="s0">*     console.log(results);</span>
 <span class="s0">*     // [ 'file1.txt', 'file2.txt', 'file3.txt', 'file4.txt', file5.txt ]</span>
 <span class="s0">* }).catch(err =&gt; {</span>
 <span class="s0">*      console.log(err);</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* // Error Handling</span>
 <span class="s0">* async.concat(withMissingDirectoryList, fs.readdir)</span>
 <span class="s0">* .then(results =&gt; {</span>
 <span class="s0">*     console.log(results);</span>
 <span class="s0">* }).catch(err =&gt; {</span>
 <span class="s0">*     console.log(err);</span>
 <span class="s0">*     // [ Error: ENOENT: no such file or directory ]</span>
 <span class="s0">*     // since dir4 does not exist</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* // Using async/await</span>
 <span class="s0">* async () =&gt; {</span>
 <span class="s0">*     try {</span>
 <span class="s0">*         let results = await async.concat(directoryList, fs.readdir);</span>
 <span class="s0">*         console.log(results);</span>
 <span class="s0">*         // [ 'file1.txt', 'file2.txt', 'file3.txt', 'file4.txt', file5.txt ]</span>
 <span class="s0">*     } catch (err) {</span>
 <span class="s0">*         console.log(err);</span>
 <span class="s0">*     }</span>
 <span class="s0">* }</span>
 <span class="s0">*</span>
 <span class="s0">* // Error Handling</span>
 <span class="s0">* async () =&gt; {</span>
 <span class="s0">*     try {</span>
 <span class="s0">*         let results = await async.concat(withMissingDirectoryList, fs.readdir);</span>
 <span class="s0">*         console.log(results);</span>
 <span class="s0">*     } catch (err) {</span>
 <span class="s0">*         console.log(err);</span>
 <span class="s0">*         // [ Error: ENOENT: no such file or directory ]</span>
 <span class="s0">*         // since dir4 does not exist</span>
 <span class="s0">*     }</span>
 <span class="s0">* }</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">concat</span><span class="s4">(</span><span class="s2">coll</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
    <span class="s3">return </span><span class="s2">concatLimit$1</span><span class="s4">(</span><span class="s2">coll</span><span class="s4">, </span><span class="s2">Infinity</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">)</span>
<span class="s4">}</span>
<span class="s3">var </span><span class="s2">concat$1 </span><span class="s4">= </span><span class="s2">awaitify</span><span class="s4">(</span><span class="s2">concat</span><span class="s4">, </span><span class="s7">3</span><span class="s4">);</span>

<span class="s0">/**</span>
 <span class="s0">* The same as [`concat`]{</span><span class="s1">@link </span><span class="s0">module:Collections.concat} but runs only a single async operation at a time.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">concatSeries</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s0">[async.concat]{</span><span class="s1">@link </span><span class="s0">module:Collections.concat}</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collection</span>
 <span class="s0">* </span><span class="s1">@alias </span><span class="s0">flatMapSeries</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{AsyncFunction} iteratee - A function to apply to each item in `coll`.</span>
 <span class="s0">* The iteratee should complete with an array an array of results.</span>
 <span class="s0">* Invoked with (item, callback).</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} [callback] - A callback which is called after all the</span>
 <span class="s0">* `iteratee` functions have finished, or an error occurs. Results is an array</span>
 <span class="s0">* containing the concatenated results of the `iteratee` function. Invoked with</span>
 <span class="s0">* (err, results).</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">A Promise, if no callback is passed</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">concatSeries</span><span class="s4">(</span><span class="s2">coll</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
    <span class="s3">return </span><span class="s2">concatLimit$1</span><span class="s4">(</span><span class="s2">coll</span><span class="s4">, </span><span class="s7">1</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">)</span>
<span class="s4">}</span>
<span class="s3">var </span><span class="s2">concatSeries$1 </span><span class="s4">= </span><span class="s2">awaitify</span><span class="s4">(</span><span class="s2">concatSeries</span><span class="s4">, </span><span class="s7">3</span><span class="s4">);</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a function that when called, calls-back with the values provided.</span>
 <span class="s0">* Useful as the first function in a [`waterfall`]{</span><span class="s1">@link </span><span class="s0">module:ControlFlow.waterfall}, or for plugging values in to</span>
 <span class="s0">* [`auto`]{</span><span class="s1">@link </span><span class="s0">module:ControlFlow.auto}.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">constant</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Utils</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Util</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{...*} arguments... - Any number of arguments to automatically invoke</span>
 <span class="s0">* callback with.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{AsyncFunction} Returns a function that when invoked, automatically</span>
 <span class="s0">* invokes the callback with the previous given arguments.</span>
 <span class="s0">* </span><span class="s1">@example</span>
 <span class="s0">*</span>
 <span class="s0">* async.waterfall([</span>
 <span class="s0">*     async.constant(42),</span>
 <span class="s0">*     function (value, next) {</span>
 <span class="s0">*         // value === 42</span>
 <span class="s0">*     },</span>
 <span class="s0">*     //...</span>
 <span class="s0">* ], callback);</span>
 <span class="s0">*</span>
 <span class="s0">* async.waterfall([</span>
 <span class="s0">*     async.constant(filename, &quot;utf8&quot;),</span>
 <span class="s0">*     fs.readFile,</span>
 <span class="s0">*     function (fileData, next) {</span>
 <span class="s0">*         //...</span>
 <span class="s0">*     }</span>
 <span class="s0">*     //...</span>
 <span class="s0">* ], callback);</span>
 <span class="s0">*</span>
 <span class="s0">* async.auto({</span>
 <span class="s0">*     hostname: async.constant(&quot;https://server.net/&quot;),</span>
 <span class="s0">*     port: findFreePort,</span>
 <span class="s0">*     launchServer: [&quot;hostname&quot;, &quot;port&quot;, function (options, cb) {</span>
 <span class="s0">*         startServer(options, cb);</span>
 <span class="s0">*     }],</span>
 <span class="s0">*     //...</span>
 <span class="s0">* }, callback);</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">constant$1</span><span class="s4">(</span><span class="s2">...args</span><span class="s4">) {</span>
    <span class="s3">return function </span><span class="s4">(</span><span class="s2">...ignoredArgs</span><span class="s5">/*, callback*/</span><span class="s4">) {</span>
        <span class="s3">var </span><span class="s2">callback </span><span class="s4">= </span><span class="s2">ignoredArgs</span><span class="s4">.</span><span class="s2">pop</span><span class="s4">();</span>
        <span class="s3">return </span><span class="s2">callback</span><span class="s4">(</span><span class="s3">null</span><span class="s4">, </span><span class="s2">...args</span><span class="s4">);</span>
    <span class="s4">};</span>
<span class="s4">}</span>

<span class="s3">function </span><span class="s2">_createTester</span><span class="s4">(</span><span class="s2">check</span><span class="s4">, </span><span class="s2">getResult</span><span class="s4">) {</span>
    <span class="s3">return </span><span class="s4">(</span><span class="s2">eachfn</span><span class="s4">, </span><span class="s2">arr</span><span class="s4">, </span><span class="s2">_iteratee</span><span class="s4">, </span><span class="s2">cb</span><span class="s4">) =&gt; {</span>
        <span class="s3">var </span><span class="s2">testPassed </span><span class="s4">= </span><span class="s3">false</span><span class="s4">;</span>
        <span class="s3">var </span><span class="s2">testResult</span><span class="s4">;</span>
        <span class="s3">const </span><span class="s2">iteratee </span><span class="s4">= </span><span class="s2">wrapAsync</span><span class="s4">(</span><span class="s2">_iteratee</span><span class="s4">);</span>
        <span class="s2">eachfn</span><span class="s4">(</span><span class="s2">arr</span><span class="s4">, (</span><span class="s2">value</span><span class="s4">, </span><span class="s2">_</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) =&gt; {</span>
            <span class="s2">iteratee</span><span class="s4">(</span><span class="s2">value</span><span class="s4">, (</span><span class="s2">err</span><span class="s4">, </span><span class="s2">result</span><span class="s4">) =&gt; {</span>
                <span class="s3">if </span><span class="s4">(</span><span class="s2">err </span><span class="s4">|| </span><span class="s2">err </span><span class="s4">=== </span><span class="s3">false</span><span class="s4">) </span><span class="s3">return </span><span class="s2">callback</span><span class="s4">(</span><span class="s2">err</span><span class="s4">);</span>

                <span class="s3">if </span><span class="s4">(</span><span class="s2">check</span><span class="s4">(</span><span class="s2">result</span><span class="s4">) &amp;&amp; !</span><span class="s2">testResult</span><span class="s4">) {</span>
                    <span class="s2">testPassed </span><span class="s4">= </span><span class="s3">true</span><span class="s4">;</span>
                    <span class="s2">testResult </span><span class="s4">= </span><span class="s2">getResult</span><span class="s4">(</span><span class="s3">true</span><span class="s4">, </span><span class="s2">value</span><span class="s4">);</span>
                    <span class="s3">return </span><span class="s2">callback</span><span class="s4">(</span><span class="s3">null</span><span class="s4">, </span><span class="s2">breakLoop</span><span class="s4">);</span>
                <span class="s4">}</span>
                <span class="s2">callback</span><span class="s4">();</span>
            <span class="s4">});</span>
        <span class="s4">}, </span><span class="s2">err </span><span class="s4">=&gt; {</span>
            <span class="s3">if </span><span class="s4">(</span><span class="s2">err</span><span class="s4">) </span><span class="s3">return </span><span class="s2">cb</span><span class="s4">(</span><span class="s2">err</span><span class="s4">);</span>
            <span class="s2">cb</span><span class="s4">(</span><span class="s3">null</span><span class="s4">, </span><span class="s2">testPassed </span><span class="s4">? </span><span class="s2">testResult </span><span class="s4">: </span><span class="s2">getResult</span><span class="s4">(</span><span class="s3">false</span><span class="s4">));</span>
        <span class="s4">});</span>
    <span class="s4">};</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Returns the first value in `coll` that passes an async truth test. The</span>
 <span class="s0">* `iteratee` is applied in parallel, meaning the first iteratee to return</span>
 <span class="s0">* `true` will fire the detect `callback` with that result. That means the</span>
 <span class="s0">* result might not be the first item in the original `coll` (in terms of order)</span>
 <span class="s0">* that passes the test.</span>

 <span class="s0">* If order within the original `coll` is important, then look at</span>
 <span class="s0">* [`detectSeries`]{</span><span class="s1">@link </span><span class="s0">module:Collections.detectSeries}.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">detect</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@alias </span><span class="s0">find</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collections</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{AsyncFunction} iteratee - A truth test to apply to each item in `coll`.</span>
 <span class="s0">* The iteratee must complete with a boolean value as its result.</span>
 <span class="s0">* Invoked with (item, callback).</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} [callback] - A callback which is called as soon as any</span>
 <span class="s0">* iteratee returns `true`, or after all the `iteratee` functions have finished.</span>
 <span class="s0">* Result will be the first item in the array that passes the truth test</span>
 <span class="s0">* (iteratee) or the value `undefined` if none passed. Invoked with</span>
 <span class="s0">* (err, result).</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise} a promise, if a callback is omitted</span>
 <span class="s0">* </span><span class="s1">@example</span>
 <span class="s0">*</span>
 <span class="s0">* // dir1 is a directory that contains file1.txt, file2.txt</span>
 <span class="s0">* // dir2 is a directory that contains file3.txt, file4.txt</span>
 <span class="s0">* // dir3 is a directory that contains file5.txt</span>
 <span class="s0">*</span>
 <span class="s0">* // asynchronous function that checks if a file exists</span>
 <span class="s0">* function fileExists(file, callback) {</span>
 <span class="s0">*    fs.access(file, fs.constants.F_OK, (err) =&gt; {</span>
 <span class="s0">*        callback(null, !err);</span>
 <span class="s0">*    });</span>
 <span class="s0">* }</span>
 <span class="s0">*</span>
 <span class="s0">* async.detect(['file3.txt','file2.txt','dir1/file1.txt'], fileExists,</span>
 <span class="s0">*    function(err, result) {</span>
 <span class="s0">*        console.log(result);</span>
 <span class="s0">*        // dir1/file1.txt</span>
 <span class="s0">*        // result now equals the first file in the list that exists</span>
 <span class="s0">*    }</span>
 <span class="s0">*);</span>
 <span class="s0">*</span>
 <span class="s0">* // Using Promises</span>
 <span class="s0">* async.detect(['file3.txt','file2.txt','dir1/file1.txt'], fileExists)</span>
 <span class="s0">* .then(result =&gt; {</span>
 <span class="s0">*     console.log(result);</span>
 <span class="s0">*     // dir1/file1.txt</span>
 <span class="s0">*     // result now equals the first file in the list that exists</span>
 <span class="s0">* }).catch(err =&gt; {</span>
 <span class="s0">*     console.log(err);</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* // Using async/await</span>
 <span class="s0">* async () =&gt; {</span>
 <span class="s0">*     try {</span>
 <span class="s0">*         let result = await async.detect(['file3.txt','file2.txt','dir1/file1.txt'], fileExists);</span>
 <span class="s0">*         console.log(result);</span>
 <span class="s0">*         // dir1/file1.txt</span>
 <span class="s0">*         // result now equals the file in the list that exists</span>
 <span class="s0">*     }</span>
 <span class="s0">*     catch (err) {</span>
 <span class="s0">*         console.log(err);</span>
 <span class="s0">*     }</span>
 <span class="s0">* }</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">detect</span><span class="s4">(</span><span class="s2">coll</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
    <span class="s3">return </span><span class="s2">_createTester</span><span class="s4">(</span><span class="s2">bool </span><span class="s4">=&gt; </span><span class="s2">bool</span><span class="s4">, (</span><span class="s2">res</span><span class="s4">, </span><span class="s2">item</span><span class="s4">) =&gt; </span><span class="s2">item</span><span class="s4">)(</span><span class="s2">eachOf$1</span><span class="s4">, </span><span class="s2">coll</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">)</span>
<span class="s4">}</span>
<span class="s3">var </span><span class="s2">detect$1 </span><span class="s4">= </span><span class="s2">awaitify</span><span class="s4">(</span><span class="s2">detect</span><span class="s4">, </span><span class="s7">3</span><span class="s4">);</span>

<span class="s0">/**</span>
 <span class="s0">* The same as [`detect`]{</span><span class="s1">@link </span><span class="s0">module:Collections.detect} but runs a maximum of `limit` async operations at a</span>
 <span class="s0">* time.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">detectLimit</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s0">[async.detect]{</span><span class="s1">@link </span><span class="s0">module:Collections.detect}</span>
 <span class="s0">* </span><span class="s1">@alias </span><span class="s0">findLimit</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collections</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{number} limit - The maximum number of async operations at a time.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{AsyncFunction} iteratee - A truth test to apply to each item in `coll`.</span>
 <span class="s0">* The iteratee must complete with a boolean value as its result.</span>
 <span class="s0">* Invoked with (item, callback).</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} [callback] - A callback which is called as soon as any</span>
 <span class="s0">* iteratee returns `true`, or after all the `iteratee` functions have finished.</span>
 <span class="s0">* Result will be the first item in the array that passes the truth test</span>
 <span class="s0">* (iteratee) or the value `undefined` if none passed. Invoked with</span>
 <span class="s0">* (err, result).</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise} a promise, if a callback is omitted</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">detectLimit</span><span class="s4">(</span><span class="s2">coll</span><span class="s4">, </span><span class="s2">limit</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
    <span class="s3">return </span><span class="s2">_createTester</span><span class="s4">(</span><span class="s2">bool </span><span class="s4">=&gt; </span><span class="s2">bool</span><span class="s4">, (</span><span class="s2">res</span><span class="s4">, </span><span class="s2">item</span><span class="s4">) =&gt; </span><span class="s2">item</span><span class="s4">)(</span><span class="s2">eachOfLimit$2</span><span class="s4">(</span><span class="s2">limit</span><span class="s4">), </span><span class="s2">coll</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">)</span>
<span class="s4">}</span>
<span class="s3">var </span><span class="s2">detectLimit$1 </span><span class="s4">= </span><span class="s2">awaitify</span><span class="s4">(</span><span class="s2">detectLimit</span><span class="s4">, </span><span class="s7">4</span><span class="s4">);</span>

<span class="s0">/**</span>
 <span class="s0">* The same as [`detect`]{</span><span class="s1">@link </span><span class="s0">module:Collections.detect} but runs only a single async operation at a time.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">detectSeries</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s0">[async.detect]{</span><span class="s1">@link </span><span class="s0">module:Collections.detect}</span>
 <span class="s0">* </span><span class="s1">@alias </span><span class="s0">findSeries</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collections</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{AsyncFunction} iteratee - A truth test to apply to each item in `coll`.</span>
 <span class="s0">* The iteratee must complete with a boolean value as its result.</span>
 <span class="s0">* Invoked with (item, callback).</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} [callback] - A callback which is called as soon as any</span>
 <span class="s0">* iteratee returns `true`, or after all the `iteratee` functions have finished.</span>
 <span class="s0">* Result will be the first item in the array that passes the truth test</span>
 <span class="s0">* (iteratee) or the value `undefined` if none passed. Invoked with</span>
 <span class="s0">* (err, result).</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise} a promise, if a callback is omitted</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">detectSeries</span><span class="s4">(</span><span class="s2">coll</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
    <span class="s3">return </span><span class="s2">_createTester</span><span class="s4">(</span><span class="s2">bool </span><span class="s4">=&gt; </span><span class="s2">bool</span><span class="s4">, (</span><span class="s2">res</span><span class="s4">, </span><span class="s2">item</span><span class="s4">) =&gt; </span><span class="s2">item</span><span class="s4">)(</span><span class="s2">eachOfLimit$2</span><span class="s4">(</span><span class="s7">1</span><span class="s4">), </span><span class="s2">coll</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">)</span>
<span class="s4">}</span>

<span class="s3">var </span><span class="s2">detectSeries$1 </span><span class="s4">= </span><span class="s2">awaitify</span><span class="s4">(</span><span class="s2">detectSeries</span><span class="s4">, </span><span class="s7">3</span><span class="s4">);</span>

<span class="s3">function </span><span class="s2">consoleFunc</span><span class="s4">(</span><span class="s2">name</span><span class="s4">) {</span>
    <span class="s3">return </span><span class="s4">(</span><span class="s2">fn</span><span class="s4">, </span><span class="s2">...args</span><span class="s4">) =&gt; </span><span class="s2">wrapAsync</span><span class="s4">(</span><span class="s2">fn</span><span class="s4">)(</span><span class="s2">...args</span><span class="s4">, (</span><span class="s2">err</span><span class="s4">, </span><span class="s2">...resultArgs</span><span class="s4">) =&gt; {</span>
        <span class="s5">/* istanbul ignore else */</span>
        <span class="s3">if </span><span class="s4">(</span><span class="s3">typeof </span><span class="s2">console </span><span class="s4">=== </span><span class="s6">'object'</span><span class="s4">) {</span>
            <span class="s5">/* istanbul ignore else */</span>
            <span class="s3">if </span><span class="s4">(</span><span class="s2">err</span><span class="s4">) {</span>
                <span class="s5">/* istanbul ignore else */</span>
                <span class="s3">if </span><span class="s4">(</span><span class="s2">console</span><span class="s4">.</span><span class="s2">error</span><span class="s4">) {</span>
                    <span class="s2">console</span><span class="s4">.</span><span class="s2">error</span><span class="s4">(</span><span class="s2">err</span><span class="s4">);</span>
                <span class="s4">}</span>
            <span class="s4">} </span><span class="s3">else if </span><span class="s4">(</span><span class="s2">console</span><span class="s4">[</span><span class="s2">name</span><span class="s4">]) { </span><span class="s5">/* istanbul ignore else */</span>
                <span class="s2">resultArgs</span><span class="s4">.</span><span class="s2">forEach</span><span class="s4">(</span><span class="s2">x </span><span class="s4">=&gt; </span><span class="s2">console</span><span class="s4">[</span><span class="s2">name</span><span class="s4">](</span><span class="s2">x</span><span class="s4">));</span>
            <span class="s4">}</span>
        <span class="s4">}</span>
    <span class="s4">})</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Logs the result of an [`async` function]{</span><span class="s1">@link </span><span class="s0">AsyncFunction} to the</span>
 <span class="s0">* `console` using `console.dir` to display the properties of the resulting object.</span>
 <span class="s0">* Only works in Node.js or in browsers that support `console.dir` and</span>
 <span class="s0">* `console.error` (such as FF and Chrome).</span>
 <span class="s0">* If multiple arguments are returned from the async function,</span>
 <span class="s0">* `console.dir` is called on each argument in order.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">dir</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Utils</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Util</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{AsyncFunction} function - The function you want to eventually apply</span>
 <span class="s0">* all arguments to.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{...*} arguments... - Any number of arguments to apply to the function.</span>
 <span class="s0">* </span><span class="s1">@example</span>
 <span class="s0">*</span>
 <span class="s0">* // in a module</span>
 <span class="s0">* var hello = function(name, callback) {</span>
 <span class="s0">*     setTimeout(function() {</span>
 <span class="s0">*         callback(null, {hello: name});</span>
 <span class="s0">*     }, 1000);</span>
 <span class="s0">* };</span>
 <span class="s0">*</span>
 <span class="s0">* // in the node repl</span>
 <span class="s0">* node&gt; async.dir(hello, 'world');</span>
 <span class="s0">* {hello: 'world'}</span>
 <span class="s0">*/</span>
<span class="s3">var </span><span class="s2">dir </span><span class="s4">= </span><span class="s2">consoleFunc</span><span class="s4">(</span><span class="s6">'dir'</span><span class="s4">);</span>

<span class="s0">/**</span>
 <span class="s0">* The post-check version of [`whilst`]{</span><span class="s1">@link </span><span class="s0">module:ControlFlow.whilst}. To reflect the difference in</span>
 <span class="s0">* the order of operations, the arguments `test` and `iteratee` are switched.</span>
 <span class="s0">*</span>
 <span class="s0">* `doWhilst` is to `whilst` as `do while` is to `while` in plain JavaScript.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">doWhilst</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:ControlFlow</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s0">[async.whilst]{</span><span class="s1">@link </span><span class="s0">module:ControlFlow.whilst}</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Control Flow</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{AsyncFunction} iteratee - A function which is called each time `test`</span>
 <span class="s0">* passes. Invoked with (callback).</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{AsyncFunction} test - asynchronous truth test to perform after each</span>
 <span class="s0">* execution of `iteratee`. Invoked with (...args, callback), where `...args` are the</span>
 <span class="s0">* non-error args from the previous callback of `iteratee`.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} [callback] - A callback which is called after the test</span>
 <span class="s0">* function has failed and repeated execution of `iteratee` has stopped.</span>
 <span class="s0">* `callback` will be passed an error and any arguments passed to the final</span>
 <span class="s0">* `iteratee`'s callback. Invoked with (err, [results]);</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise} a promise, if no callback is passed</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">doWhilst</span><span class="s4">(</span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">test</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
    <span class="s2">callback </span><span class="s4">= </span><span class="s2">onlyOnce</span><span class="s4">(</span><span class="s2">callback</span><span class="s4">);</span>
    <span class="s3">var </span><span class="s2">_fn </span><span class="s4">= </span><span class="s2">wrapAsync</span><span class="s4">(</span><span class="s2">iteratee</span><span class="s4">);</span>
    <span class="s3">var </span><span class="s2">_test </span><span class="s4">= </span><span class="s2">wrapAsync</span><span class="s4">(</span><span class="s2">test</span><span class="s4">);</span>
    <span class="s3">var </span><span class="s2">results</span><span class="s4">;</span>

    <span class="s3">function </span><span class="s2">next</span><span class="s4">(</span><span class="s2">err</span><span class="s4">, </span><span class="s2">...args</span><span class="s4">) {</span>
        <span class="s3">if </span><span class="s4">(</span><span class="s2">err</span><span class="s4">) </span><span class="s3">return </span><span class="s2">callback</span><span class="s4">(</span><span class="s2">err</span><span class="s4">);</span>
        <span class="s3">if </span><span class="s4">(</span><span class="s2">err </span><span class="s4">=== </span><span class="s3">false</span><span class="s4">) </span><span class="s3">return</span><span class="s4">;</span>
        <span class="s2">results </span><span class="s4">= </span><span class="s2">args</span><span class="s4">;</span>
        <span class="s2">_test</span><span class="s4">(</span><span class="s2">...args</span><span class="s4">, </span><span class="s2">check</span><span class="s4">);</span>
    <span class="s4">}</span>

    <span class="s3">function </span><span class="s2">check</span><span class="s4">(</span><span class="s2">err</span><span class="s4">, </span><span class="s2">truth</span><span class="s4">) {</span>
        <span class="s3">if </span><span class="s4">(</span><span class="s2">err</span><span class="s4">) </span><span class="s3">return </span><span class="s2">callback</span><span class="s4">(</span><span class="s2">err</span><span class="s4">);</span>
        <span class="s3">if </span><span class="s4">(</span><span class="s2">err </span><span class="s4">=== </span><span class="s3">false</span><span class="s4">) </span><span class="s3">return</span><span class="s4">;</span>
        <span class="s3">if </span><span class="s4">(!</span><span class="s2">truth</span><span class="s4">) </span><span class="s3">return </span><span class="s2">callback</span><span class="s4">(</span><span class="s3">null</span><span class="s4">, </span><span class="s2">...results</span><span class="s4">);</span>
        <span class="s2">_fn</span><span class="s4">(</span><span class="s2">next</span><span class="s4">);</span>
    <span class="s4">}</span>

    <span class="s3">return </span><span class="s2">check</span><span class="s4">(</span><span class="s3">null</span><span class="s4">, </span><span class="s3">true</span><span class="s4">);</span>
<span class="s4">}</span>

<span class="s3">var </span><span class="s2">doWhilst$1 </span><span class="s4">= </span><span class="s2">awaitify</span><span class="s4">(</span><span class="s2">doWhilst</span><span class="s4">, </span><span class="s7">3</span><span class="s4">);</span>

<span class="s0">/**</span>
 <span class="s0">* Like ['doWhilst']{</span><span class="s1">@link </span><span class="s0">module:ControlFlow.doWhilst}, except the `test` is inverted. Note the</span>
 <span class="s0">* argument ordering differs from `until`.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">doUntil</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:ControlFlow</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s0">[async.doWhilst]{</span><span class="s1">@link </span><span class="s0">module:ControlFlow.doWhilst}</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Control Flow</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{AsyncFunction} iteratee - An async function which is called each time</span>
 <span class="s0">* `test` fails. Invoked with (callback).</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{AsyncFunction} test - asynchronous truth test to perform after each</span>
 <span class="s0">* execution of `iteratee`. Invoked with (...args, callback), where `...args` are the</span>
 <span class="s0">* non-error args from the previous callback of `iteratee`</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} [callback] - A callback which is called after the test</span>
 <span class="s0">* function has passed and repeated execution of `iteratee` has stopped. `callback`</span>
 <span class="s0">* will be passed an error and any arguments passed to the final `iteratee`'s</span>
 <span class="s0">* callback. Invoked with (err, [results]);</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise} a promise, if no callback is passed</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">doUntil</span><span class="s4">(</span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">test</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
    <span class="s3">const </span><span class="s2">_test </span><span class="s4">= </span><span class="s2">wrapAsync</span><span class="s4">(</span><span class="s2">test</span><span class="s4">);</span>
    <span class="s3">return </span><span class="s2">doWhilst$1</span><span class="s4">(</span><span class="s2">iteratee</span><span class="s4">, (</span><span class="s2">...args</span><span class="s4">) =&gt; {</span>
        <span class="s3">const </span><span class="s2">cb </span><span class="s4">= </span><span class="s2">args</span><span class="s4">.</span><span class="s2">pop</span><span class="s4">();</span>
        <span class="s2">_test</span><span class="s4">(</span><span class="s2">...args</span><span class="s4">, (</span><span class="s2">err</span><span class="s4">, </span><span class="s2">truth</span><span class="s4">) =&gt; </span><span class="s2">cb </span><span class="s4">(</span><span class="s2">err</span><span class="s4">, !</span><span class="s2">truth</span><span class="s4">));</span>
    <span class="s4">}, </span><span class="s2">callback</span><span class="s4">);</span>
<span class="s4">}</span>

<span class="s3">function </span><span class="s2">_withoutIndex</span><span class="s4">(</span><span class="s2">iteratee</span><span class="s4">) {</span>
    <span class="s3">return </span><span class="s4">(</span><span class="s2">value</span><span class="s4">, </span><span class="s2">index</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) =&gt; </span><span class="s2">iteratee</span><span class="s4">(</span><span class="s2">value</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">);</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Applies the function `iteratee` to each item in `coll`, in parallel.</span>
 <span class="s0">* The `iteratee` is called with an item from the list, and a callback for when</span>
 <span class="s0">* it has finished. If the `iteratee` passes an error to its `callback`, the</span>
 <span class="s0">* main `callback` (for the `each` function) is immediately called with the</span>
 <span class="s0">* error.</span>
 <span class="s0">*</span>
 <span class="s0">* Note, that since this function applies `iteratee` to each item in parallel,</span>
 <span class="s0">* there is no guarantee that the iteratee functions will complete in order.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">each</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@alias </span><span class="s0">forEach</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collection</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{AsyncFunction} iteratee - An async function to apply to</span>
 <span class="s0">* each item in `coll`. Invoked with (item, callback).</span>
 <span class="s0">* The array index is not passed to the iteratee.</span>
 <span class="s0">* If you need the index, use `eachOf`.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} [callback] - A callback which is called when all</span>
 <span class="s0">* `iteratee` functions have finished, or an error occurs. Invoked with (err).</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise} a promise, if a callback is omitted</span>
 <span class="s0">* </span><span class="s1">@example</span>
 <span class="s0">*</span>
 <span class="s0">* // dir1 is a directory that contains file1.txt, file2.txt</span>
 <span class="s0">* // dir2 is a directory that contains file3.txt, file4.txt</span>
 <span class="s0">* // dir3 is a directory that contains file5.txt</span>
 <span class="s0">* // dir4 does not exist</span>
 <span class="s0">*</span>
 <span class="s0">* const fileList = [ 'dir1/file2.txt', 'dir2/file3.txt', 'dir/file5.txt'];</span>
 <span class="s0">* const withMissingFileList = ['dir1/file1.txt', 'dir4/file2.txt'];</span>
 <span class="s0">*</span>
 <span class="s0">* // asynchronous function that deletes a file</span>
 <span class="s0">* const deleteFile = function(file, callback) {</span>
 <span class="s0">*     fs.unlink(file, callback);</span>
 <span class="s0">* };</span>
 <span class="s0">*</span>
 <span class="s0">* // Using callbacks</span>
 <span class="s0">* async.each(fileList, deleteFile, function(err) {</span>
 <span class="s0">*     if( err ) {</span>
 <span class="s0">*         console.log(err);</span>
 <span class="s0">*     } else {</span>
 <span class="s0">*         console.log('All files have been deleted successfully');</span>
 <span class="s0">*     }</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* // Error Handling</span>
 <span class="s0">* async.each(withMissingFileList, deleteFile, function(err){</span>
 <span class="s0">*     console.log(err);</span>
 <span class="s0">*     // [ Error: ENOENT: no such file or directory ]</span>
 <span class="s0">*     // since dir4/file2.txt does not exist</span>
 <span class="s0">*     // dir1/file1.txt could have been deleted</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* // Using Promises</span>
 <span class="s0">* async.each(fileList, deleteFile)</span>
 <span class="s0">* .then( () =&gt; {</span>
 <span class="s0">*     console.log('All files have been deleted successfully');</span>
 <span class="s0">* }).catch( err =&gt; {</span>
 <span class="s0">*     console.log(err);</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* // Error Handling</span>
 <span class="s0">* async.each(fileList, deleteFile)</span>
 <span class="s0">* .then( () =&gt; {</span>
 <span class="s0">*     console.log('All files have been deleted successfully');</span>
 <span class="s0">* }).catch( err =&gt; {</span>
 <span class="s0">*     console.log(err);</span>
 <span class="s0">*     // [ Error: ENOENT: no such file or directory ]</span>
 <span class="s0">*     // since dir4/file2.txt does not exist</span>
 <span class="s0">*     // dir1/file1.txt could have been deleted</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* // Using async/await</span>
 <span class="s0">* async () =&gt; {</span>
 <span class="s0">*     try {</span>
 <span class="s0">*         await async.each(files, deleteFile);</span>
 <span class="s0">*     }</span>
 <span class="s0">*     catch (err) {</span>
 <span class="s0">*         console.log(err);</span>
 <span class="s0">*     }</span>
 <span class="s0">* }</span>
 <span class="s0">*</span>
 <span class="s0">* // Error Handling</span>
 <span class="s0">* async () =&gt; {</span>
 <span class="s0">*     try {</span>
 <span class="s0">*         await async.each(withMissingFileList, deleteFile);</span>
 <span class="s0">*     }</span>
 <span class="s0">*     catch (err) {</span>
 <span class="s0">*         console.log(err);</span>
 <span class="s0">*         // [ Error: ENOENT: no such file or directory ]</span>
 <span class="s0">*         // since dir4/file2.txt does not exist</span>
 <span class="s0">*         // dir1/file1.txt could have been deleted</span>
 <span class="s0">*     }</span>
 <span class="s0">* }</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">eachLimit$2</span><span class="s4">(</span><span class="s2">coll</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
    <span class="s3">return </span><span class="s2">eachOf$1</span><span class="s4">(</span><span class="s2">coll</span><span class="s4">, </span><span class="s2">_withoutIndex</span><span class="s4">(</span><span class="s2">wrapAsync</span><span class="s4">(</span><span class="s2">iteratee</span><span class="s4">)), </span><span class="s2">callback</span><span class="s4">);</span>
<span class="s4">}</span>

<span class="s3">var </span><span class="s2">each </span><span class="s4">= </span><span class="s2">awaitify</span><span class="s4">(</span><span class="s2">eachLimit$2</span><span class="s4">, </span><span class="s7">3</span><span class="s4">);</span>

<span class="s0">/**</span>
 <span class="s0">* The same as [`each`]{</span><span class="s1">@link </span><span class="s0">module:Collections.each} but runs a maximum of `limit` async operations at a time.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">eachLimit</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s0">[async.each]{</span><span class="s1">@link </span><span class="s0">module:Collections.each}</span>
 <span class="s0">* </span><span class="s1">@alias </span><span class="s0">forEachLimit</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collection</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{number} limit - The maximum number of async operations at a time.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{AsyncFunction} iteratee - An async function to apply to each item in</span>
 <span class="s0">* `coll`.</span>
 <span class="s0">* The array index is not passed to the iteratee.</span>
 <span class="s0">* If you need the index, use `eachOfLimit`.</span>
 <span class="s0">* Invoked with (item, callback).</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} [callback] - A callback which is called when all</span>
 <span class="s0">* `iteratee` functions have finished, or an error occurs. Invoked with (err).</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise} a promise, if a callback is omitted</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">eachLimit</span><span class="s4">(</span><span class="s2">coll</span><span class="s4">, </span><span class="s2">limit</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
    <span class="s3">return </span><span class="s2">eachOfLimit$2</span><span class="s4">(</span><span class="s2">limit</span><span class="s4">)(</span><span class="s2">coll</span><span class="s4">, </span><span class="s2">_withoutIndex</span><span class="s4">(</span><span class="s2">wrapAsync</span><span class="s4">(</span><span class="s2">iteratee</span><span class="s4">)), </span><span class="s2">callback</span><span class="s4">);</span>
<span class="s4">}</span>
<span class="s3">var </span><span class="s2">eachLimit$1 </span><span class="s4">= </span><span class="s2">awaitify</span><span class="s4">(</span><span class="s2">eachLimit</span><span class="s4">, </span><span class="s7">4</span><span class="s4">);</span>

<span class="s0">/**</span>
 <span class="s0">* The same as [`each`]{</span><span class="s1">@link </span><span class="s0">module:Collections.each} but runs only a single async operation at a time.</span>
 <span class="s0">*</span>
 <span class="s0">* Note, that unlike [`each`]{</span><span class="s1">@link </span><span class="s0">module:Collections.each}, this function applies iteratee to each item</span>
 <span class="s0">* in series and therefore the iteratee functions will complete in order.</span>

 <span class="s0">* </span><span class="s1">@name </span><span class="s0">eachSeries</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s0">[async.each]{</span><span class="s1">@link </span><span class="s0">module:Collections.each}</span>
 <span class="s0">* </span><span class="s1">@alias </span><span class="s0">forEachSeries</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collection</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{AsyncFunction} iteratee - An async function to apply to each</span>
 <span class="s0">* item in `coll`.</span>
 <span class="s0">* The array index is not passed to the iteratee.</span>
 <span class="s0">* If you need the index, use `eachOfSeries`.</span>
 <span class="s0">* Invoked with (item, callback).</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} [callback] - A callback which is called when all</span>
 <span class="s0">* `iteratee` functions have finished, or an error occurs. Invoked with (err).</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise} a promise, if a callback is omitted</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">eachSeries</span><span class="s4">(</span><span class="s2">coll</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
    <span class="s3">return </span><span class="s2">eachLimit$1</span><span class="s4">(</span><span class="s2">coll</span><span class="s4">, </span><span class="s7">1</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">)</span>
<span class="s4">}</span>
<span class="s3">var </span><span class="s2">eachSeries$1 </span><span class="s4">= </span><span class="s2">awaitify</span><span class="s4">(</span><span class="s2">eachSeries</span><span class="s4">, </span><span class="s7">3</span><span class="s4">);</span>

<span class="s0">/**</span>
 <span class="s0">* Wrap an async function and ensure it calls its callback on a later tick of</span>
 <span class="s0">* the event loop.  If the function already calls its callback on a next tick,</span>
 <span class="s0">* no extra deferral is added. This is useful for preventing stack overflows</span>
 <span class="s0">* (`RangeError: Maximum call stack size exceeded`) and generally keeping</span>
 <span class="s0">* [Zalgo](http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony)</span>
 <span class="s0">* contained. ES2017 `async` functions are returned as-is -- they are immune</span>
 <span class="s0">* to Zalgo's corrupting influences, as they always resolve on a later tick.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">ensureAsync</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Utils</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Util</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{AsyncFunction} fn - an async function, one that expects a node-style</span>
 <span class="s0">* callback as its last argument.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{AsyncFunction} Returns a wrapped function with the exact same call</span>
 <span class="s0">* signature as the function passed in.</span>
 <span class="s0">* </span><span class="s1">@example</span>
 <span class="s0">*</span>
 <span class="s0">* function sometimesAsync(arg, callback) {</span>
 <span class="s0">*     if (cache[arg]) {</span>
 <span class="s0">*         return callback(null, cache[arg]); // this would be synchronous!!</span>
 <span class="s0">*     } else {</span>
 <span class="s0">*         doSomeIO(arg, callback); // this IO would be asynchronous</span>
 <span class="s0">*     }</span>
 <span class="s0">* }</span>
 <span class="s0">*</span>
 <span class="s0">* // this has a risk of stack overflows if many results are cached in a row</span>
 <span class="s0">* async.mapSeries(args, sometimesAsync, done);</span>
 <span class="s0">*</span>
 <span class="s0">* // this will defer sometimesAsync's callback if necessary,</span>
 <span class="s0">* // preventing stack overflows</span>
 <span class="s0">* async.mapSeries(args, async.ensureAsync(sometimesAsync), done);</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">ensureAsync</span><span class="s4">(</span><span class="s2">fn</span><span class="s4">) {</span>
    <span class="s3">if </span><span class="s4">(</span><span class="s2">isAsync</span><span class="s4">(</span><span class="s2">fn</span><span class="s4">)) </span><span class="s3">return </span><span class="s2">fn</span><span class="s4">;</span>
    <span class="s3">return function </span><span class="s4">(</span><span class="s2">...args</span><span class="s5">/*, callback*/</span><span class="s4">) {</span>
        <span class="s3">var </span><span class="s2">callback </span><span class="s4">= </span><span class="s2">args</span><span class="s4">.</span><span class="s2">pop</span><span class="s4">();</span>
        <span class="s3">var </span><span class="s2">sync </span><span class="s4">= </span><span class="s3">true</span><span class="s4">;</span>
        <span class="s2">args</span><span class="s4">.</span><span class="s2">push</span><span class="s4">((</span><span class="s2">...innerArgs</span><span class="s4">) =&gt; {</span>
            <span class="s3">if </span><span class="s4">(</span><span class="s2">sync</span><span class="s4">) {</span>
                <span class="s2">setImmediate$1</span><span class="s4">(() =&gt; </span><span class="s2">callback</span><span class="s4">(</span><span class="s2">...innerArgs</span><span class="s4">));</span>
            <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
                <span class="s2">callback</span><span class="s4">(</span><span class="s2">...innerArgs</span><span class="s4">);</span>
            <span class="s4">}</span>
        <span class="s4">});</span>
        <span class="s2">fn</span><span class="s4">.</span><span class="s2">apply</span><span class="s4">(</span><span class="s3">this</span><span class="s4">, </span><span class="s2">args</span><span class="s4">);</span>
        <span class="s2">sync </span><span class="s4">= </span><span class="s3">false</span><span class="s4">;</span>
    <span class="s4">};</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Returns `true` if every element in `coll` satisfies an async test. If any</span>
 <span class="s0">* iteratee call returns `false`, the main `callback` is immediately called.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">every</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@alias </span><span class="s0">all</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collection</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{AsyncFunction} iteratee - An async truth test to apply to each item</span>
 <span class="s0">* in the collection in parallel.</span>
 <span class="s0">* The iteratee must complete with a boolean result value.</span>
 <span class="s0">* Invoked with (item, callback).</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} [callback] - A callback which is called after all the</span>
 <span class="s0">* `iteratee` functions have finished. Result will be either `true` or `false`</span>
 <span class="s0">* depending on the values of the async tests. Invoked with (err, result).</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise} a promise, if no callback provided</span>
 <span class="s0">* </span><span class="s1">@example</span>
 <span class="s0">*</span>
 <span class="s0">* // dir1 is a directory that contains file1.txt, file2.txt</span>
 <span class="s0">* // dir2 is a directory that contains file3.txt, file4.txt</span>
 <span class="s0">* // dir3 is a directory that contains file5.txt</span>
 <span class="s0">* // dir4 does not exist</span>
 <span class="s0">*</span>
 <span class="s0">* const fileList = ['dir1/file1.txt','dir2/file3.txt','dir3/file5.txt'];</span>
 <span class="s0">* const withMissingFileList = ['file1.txt','file2.txt','file4.txt'];</span>
 <span class="s0">*</span>
 <span class="s0">* // asynchronous function that checks if a file exists</span>
 <span class="s0">* function fileExists(file, callback) {</span>
 <span class="s0">*    fs.access(file, fs.constants.F_OK, (err) =&gt; {</span>
 <span class="s0">*        callback(null, !err);</span>
 <span class="s0">*    });</span>
 <span class="s0">* }</span>
 <span class="s0">*</span>
 <span class="s0">* // Using callbacks</span>
 <span class="s0">* async.every(fileList, fileExists, function(err, result) {</span>
 <span class="s0">*     console.log(result);</span>
 <span class="s0">*     // true</span>
 <span class="s0">*     // result is true since every file exists</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* async.every(withMissingFileList, fileExists, function(err, result) {</span>
 <span class="s0">*     console.log(result);</span>
 <span class="s0">*     // false</span>
 <span class="s0">*     // result is false since NOT every file exists</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* // Using Promises</span>
 <span class="s0">* async.every(fileList, fileExists)</span>
 <span class="s0">* .then( result =&gt; {</span>
 <span class="s0">*     console.log(result);</span>
 <span class="s0">*     // true</span>
 <span class="s0">*     // result is true since every file exists</span>
 <span class="s0">* }).catch( err =&gt; {</span>
 <span class="s0">*     console.log(err);</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* async.every(withMissingFileList, fileExists)</span>
 <span class="s0">* .then( result =&gt; {</span>
 <span class="s0">*     console.log(result);</span>
 <span class="s0">*     // false</span>
 <span class="s0">*     // result is false since NOT every file exists</span>
 <span class="s0">* }).catch( err =&gt; {</span>
 <span class="s0">*     console.log(err);</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* // Using async/await</span>
 <span class="s0">* async () =&gt; {</span>
 <span class="s0">*     try {</span>
 <span class="s0">*         let result = await async.every(fileList, fileExists);</span>
 <span class="s0">*         console.log(result);</span>
 <span class="s0">*         // true</span>
 <span class="s0">*         // result is true since every file exists</span>
 <span class="s0">*     }</span>
 <span class="s0">*     catch (err) {</span>
 <span class="s0">*         console.log(err);</span>
 <span class="s0">*     }</span>
 <span class="s0">* }</span>
 <span class="s0">*</span>
 <span class="s0">* async () =&gt; {</span>
 <span class="s0">*     try {</span>
 <span class="s0">*         let result = await async.every(withMissingFileList, fileExists);</span>
 <span class="s0">*         console.log(result);</span>
 <span class="s0">*         // false</span>
 <span class="s0">*         // result is false since NOT every file exists</span>
 <span class="s0">*     }</span>
 <span class="s0">*     catch (err) {</span>
 <span class="s0">*         console.log(err);</span>
 <span class="s0">*     }</span>
 <span class="s0">* }</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">every</span><span class="s4">(</span><span class="s2">coll</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
    <span class="s3">return </span><span class="s2">_createTester</span><span class="s4">(</span><span class="s2">bool </span><span class="s4">=&gt; !</span><span class="s2">bool</span><span class="s4">, </span><span class="s2">res </span><span class="s4">=&gt; !</span><span class="s2">res</span><span class="s4">)(</span><span class="s2">eachOf$1</span><span class="s4">, </span><span class="s2">coll</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">)</span>
<span class="s4">}</span>
<span class="s3">var </span><span class="s2">every$1 </span><span class="s4">= </span><span class="s2">awaitify</span><span class="s4">(</span><span class="s2">every</span><span class="s4">, </span><span class="s7">3</span><span class="s4">);</span>

<span class="s0">/**</span>
 <span class="s0">* The same as [`every`]{</span><span class="s1">@link </span><span class="s0">module:Collections.every} but runs a maximum of `limit` async operations at a time.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">everyLimit</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s0">[async.every]{</span><span class="s1">@link </span><span class="s0">module:Collections.every}</span>
 <span class="s0">* </span><span class="s1">@alias </span><span class="s0">allLimit</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collection</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{number} limit - The maximum number of async operations at a time.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{AsyncFunction} iteratee - An async truth test to apply to each item</span>
 <span class="s0">* in the collection in parallel.</span>
 <span class="s0">* The iteratee must complete with a boolean result value.</span>
 <span class="s0">* Invoked with (item, callback).</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} [callback] - A callback which is called after all the</span>
 <span class="s0">* `iteratee` functions have finished. Result will be either `true` or `false`</span>
 <span class="s0">* depending on the values of the async tests. Invoked with (err, result).</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise} a promise, if no callback provided</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">everyLimit</span><span class="s4">(</span><span class="s2">coll</span><span class="s4">, </span><span class="s2">limit</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
    <span class="s3">return </span><span class="s2">_createTester</span><span class="s4">(</span><span class="s2">bool </span><span class="s4">=&gt; !</span><span class="s2">bool</span><span class="s4">, </span><span class="s2">res </span><span class="s4">=&gt; !</span><span class="s2">res</span><span class="s4">)(</span><span class="s2">eachOfLimit$2</span><span class="s4">(</span><span class="s2">limit</span><span class="s4">), </span><span class="s2">coll</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">)</span>
<span class="s4">}</span>
<span class="s3">var </span><span class="s2">everyLimit$1 </span><span class="s4">= </span><span class="s2">awaitify</span><span class="s4">(</span><span class="s2">everyLimit</span><span class="s4">, </span><span class="s7">4</span><span class="s4">);</span>

<span class="s0">/**</span>
 <span class="s0">* The same as [`every`]{</span><span class="s1">@link </span><span class="s0">module:Collections.every} but runs only a single async operation at a time.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">everySeries</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s0">[async.every]{</span><span class="s1">@link </span><span class="s0">module:Collections.every}</span>
 <span class="s0">* </span><span class="s1">@alias </span><span class="s0">allSeries</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collection</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{AsyncFunction} iteratee - An async truth test to apply to each item</span>
 <span class="s0">* in the collection in series.</span>
 <span class="s0">* The iteratee must complete with a boolean result value.</span>
 <span class="s0">* Invoked with (item, callback).</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} [callback] - A callback which is called after all the</span>
 <span class="s0">* `iteratee` functions have finished. Result will be either `true` or `false`</span>
 <span class="s0">* depending on the values of the async tests. Invoked with (err, result).</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise} a promise, if no callback provided</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">everySeries</span><span class="s4">(</span><span class="s2">coll</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
    <span class="s3">return </span><span class="s2">_createTester</span><span class="s4">(</span><span class="s2">bool </span><span class="s4">=&gt; !</span><span class="s2">bool</span><span class="s4">, </span><span class="s2">res </span><span class="s4">=&gt; !</span><span class="s2">res</span><span class="s4">)(</span><span class="s2">eachOfSeries$1</span><span class="s4">, </span><span class="s2">coll</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">)</span>
<span class="s4">}</span>
<span class="s3">var </span><span class="s2">everySeries$1 </span><span class="s4">= </span><span class="s2">awaitify</span><span class="s4">(</span><span class="s2">everySeries</span><span class="s4">, </span><span class="s7">3</span><span class="s4">);</span>

<span class="s3">function </span><span class="s2">filterArray</span><span class="s4">(</span><span class="s2">eachfn</span><span class="s4">, </span><span class="s2">arr</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
    <span class="s3">var </span><span class="s2">truthValues </span><span class="s4">= </span><span class="s3">new </span><span class="s2">Array</span><span class="s4">(</span><span class="s2">arr</span><span class="s4">.</span><span class="s2">length</span><span class="s4">);</span>
    <span class="s2">eachfn</span><span class="s4">(</span><span class="s2">arr</span><span class="s4">, (</span><span class="s2">x</span><span class="s4">, </span><span class="s2">index</span><span class="s4">, </span><span class="s2">iterCb</span><span class="s4">) =&gt; {</span>
        <span class="s2">iteratee</span><span class="s4">(</span><span class="s2">x</span><span class="s4">, (</span><span class="s2">err</span><span class="s4">, </span><span class="s2">v</span><span class="s4">) =&gt; {</span>
            <span class="s2">truthValues</span><span class="s4">[</span><span class="s2">index</span><span class="s4">] = !!</span><span class="s2">v</span><span class="s4">;</span>
            <span class="s2">iterCb</span><span class="s4">(</span><span class="s2">err</span><span class="s4">);</span>
        <span class="s4">});</span>
    <span class="s4">}, </span><span class="s2">err </span><span class="s4">=&gt; {</span>
        <span class="s3">if </span><span class="s4">(</span><span class="s2">err</span><span class="s4">) </span><span class="s3">return </span><span class="s2">callback</span><span class="s4">(</span><span class="s2">err</span><span class="s4">);</span>
        <span class="s3">var </span><span class="s2">results </span><span class="s4">= [];</span>
        <span class="s3">for </span><span class="s4">(</span><span class="s3">var </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s2">arr</span><span class="s4">.</span><span class="s2">length</span><span class="s4">; </span><span class="s2">i</span><span class="s4">++) {</span>
            <span class="s3">if </span><span class="s4">(</span><span class="s2">truthValues</span><span class="s4">[</span><span class="s2">i</span><span class="s4">]) </span><span class="s2">results</span><span class="s4">.</span><span class="s2">push</span><span class="s4">(</span><span class="s2">arr</span><span class="s4">[</span><span class="s2">i</span><span class="s4">]);</span>
        <span class="s4">}</span>
        <span class="s2">callback</span><span class="s4">(</span><span class="s3">null</span><span class="s4">, </span><span class="s2">results</span><span class="s4">);</span>
    <span class="s4">});</span>
<span class="s4">}</span>

<span class="s3">function </span><span class="s2">filterGeneric</span><span class="s4">(</span><span class="s2">eachfn</span><span class="s4">, </span><span class="s2">coll</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
    <span class="s3">var </span><span class="s2">results </span><span class="s4">= [];</span>
    <span class="s2">eachfn</span><span class="s4">(</span><span class="s2">coll</span><span class="s4">, (</span><span class="s2">x</span><span class="s4">, </span><span class="s2">index</span><span class="s4">, </span><span class="s2">iterCb</span><span class="s4">) =&gt; {</span>
        <span class="s2">iteratee</span><span class="s4">(</span><span class="s2">x</span><span class="s4">, (</span><span class="s2">err</span><span class="s4">, </span><span class="s2">v</span><span class="s4">) =&gt; {</span>
            <span class="s3">if </span><span class="s4">(</span><span class="s2">err</span><span class="s4">) </span><span class="s3">return </span><span class="s2">iterCb</span><span class="s4">(</span><span class="s2">err</span><span class="s4">);</span>
            <span class="s3">if </span><span class="s4">(</span><span class="s2">v</span><span class="s4">) {</span>
                <span class="s2">results</span><span class="s4">.</span><span class="s2">push</span><span class="s4">({</span><span class="s2">index</span><span class="s4">, </span><span class="s2">value</span><span class="s4">: </span><span class="s2">x</span><span class="s4">});</span>
            <span class="s4">}</span>
            <span class="s2">iterCb</span><span class="s4">(</span><span class="s2">err</span><span class="s4">);</span>
        <span class="s4">});</span>
    <span class="s4">}, </span><span class="s2">err </span><span class="s4">=&gt; {</span>
        <span class="s3">if </span><span class="s4">(</span><span class="s2">err</span><span class="s4">) </span><span class="s3">return </span><span class="s2">callback</span><span class="s4">(</span><span class="s2">err</span><span class="s4">);</span>
        <span class="s2">callback</span><span class="s4">(</span><span class="s3">null</span><span class="s4">, </span><span class="s2">results</span>
            <span class="s4">.</span><span class="s2">sort</span><span class="s4">((</span><span class="s2">a</span><span class="s4">, </span><span class="s2">b</span><span class="s4">) =&gt; </span><span class="s2">a</span><span class="s4">.</span><span class="s2">index </span><span class="s4">- </span><span class="s2">b</span><span class="s4">.</span><span class="s2">index</span><span class="s4">)</span>
            <span class="s4">.</span><span class="s2">map</span><span class="s4">(</span><span class="s2">v </span><span class="s4">=&gt; </span><span class="s2">v</span><span class="s4">.</span><span class="s2">value</span><span class="s4">));</span>
    <span class="s4">});</span>
<span class="s4">}</span>

<span class="s3">function </span><span class="s2">_filter</span><span class="s4">(</span><span class="s2">eachfn</span><span class="s4">, </span><span class="s2">coll</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
    <span class="s3">var </span><span class="s2">filter </span><span class="s4">= </span><span class="s2">isArrayLike</span><span class="s4">(</span><span class="s2">coll</span><span class="s4">) ? </span><span class="s2">filterArray </span><span class="s4">: </span><span class="s2">filterGeneric</span><span class="s4">;</span>
    <span class="s3">return </span><span class="s2">filter</span><span class="s4">(</span><span class="s2">eachfn</span><span class="s4">, </span><span class="s2">coll</span><span class="s4">, </span><span class="s2">wrapAsync</span><span class="s4">(</span><span class="s2">iteratee</span><span class="s4">), </span><span class="s2">callback</span><span class="s4">);</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a new array of all the values in `coll` which pass an async truth</span>
 <span class="s0">* test. This operation is performed in parallel, but the results array will be</span>
 <span class="s0">* in the same order as the original.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">filter</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@alias </span><span class="s0">select</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collection</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} iteratee - A truth test to apply to each item in `coll`.</span>
 <span class="s0">* The `iteratee` is passed a `callback(err, truthValue)`, which must be called</span>
 <span class="s0">* with a boolean argument once it has completed. Invoked with (item, callback).</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} [callback] - A callback which is called after all the</span>
 <span class="s0">* `iteratee` functions have finished. Invoked with (err, results).</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise} a promise, if no callback provided</span>
 <span class="s0">* </span><span class="s1">@example</span>
 <span class="s0">*</span>
 <span class="s0">* // dir1 is a directory that contains file1.txt, file2.txt</span>
 <span class="s0">* // dir2 is a directory that contains file3.txt, file4.txt</span>
 <span class="s0">* // dir3 is a directory that contains file5.txt</span>
 <span class="s0">*</span>
 <span class="s0">* const files = ['dir1/file1.txt','dir2/file3.txt','dir3/file6.txt'];</span>
 <span class="s0">*</span>
 <span class="s0">* // asynchronous function that checks if a file exists</span>
 <span class="s0">* function fileExists(file, callback) {</span>
 <span class="s0">*    fs.access(file, fs.constants.F_OK, (err) =&gt; {</span>
 <span class="s0">*        callback(null, !err);</span>
 <span class="s0">*    });</span>
 <span class="s0">* }</span>
 <span class="s0">*</span>
 <span class="s0">* // Using callbacks</span>
 <span class="s0">* async.filter(files, fileExists, function(err, results) {</span>
 <span class="s0">*    if(err) {</span>
 <span class="s0">*        console.log(err);</span>
 <span class="s0">*    } else {</span>
 <span class="s0">*        console.log(results);</span>
 <span class="s0">*        // [ 'dir1/file1.txt', 'dir2/file3.txt' ]</span>
 <span class="s0">*        // results is now an array of the existing files</span>
 <span class="s0">*    }</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* // Using Promises</span>
 <span class="s0">* async.filter(files, fileExists)</span>
 <span class="s0">* .then(results =&gt; {</span>
 <span class="s0">*     console.log(results);</span>
 <span class="s0">*     // [ 'dir1/file1.txt', 'dir2/file3.txt' ]</span>
 <span class="s0">*     // results is now an array of the existing files</span>
 <span class="s0">* }).catch(err =&gt; {</span>
 <span class="s0">*     console.log(err);</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* // Using async/await</span>
 <span class="s0">* async () =&gt; {</span>
 <span class="s0">*     try {</span>
 <span class="s0">*         let results = await async.filter(files, fileExists);</span>
 <span class="s0">*         console.log(results);</span>
 <span class="s0">*         // [ 'dir1/file1.txt', 'dir2/file3.txt' ]</span>
 <span class="s0">*         // results is now an array of the existing files</span>
 <span class="s0">*     }</span>
 <span class="s0">*     catch (err) {</span>
 <span class="s0">*         console.log(err);</span>
 <span class="s0">*     }</span>
 <span class="s0">* }</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">filter </span><span class="s4">(</span><span class="s2">coll</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
    <span class="s3">return </span><span class="s2">_filter</span><span class="s4">(</span><span class="s2">eachOf$1</span><span class="s4">, </span><span class="s2">coll</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">)</span>
<span class="s4">}</span>
<span class="s3">var </span><span class="s2">filter$1 </span><span class="s4">= </span><span class="s2">awaitify</span><span class="s4">(</span><span class="s2">filter</span><span class="s4">, </span><span class="s7">3</span><span class="s4">);</span>

<span class="s0">/**</span>
 <span class="s0">* The same as [`filter`]{</span><span class="s1">@link </span><span class="s0">module:Collections.filter} but runs a maximum of `limit` async operations at a</span>
 <span class="s0">* time.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">filterLimit</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s0">[async.filter]{</span><span class="s1">@link </span><span class="s0">module:Collections.filter}</span>
 <span class="s0">* </span><span class="s1">@alias </span><span class="s0">selectLimit</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collection</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{number} limit - The maximum number of async operations at a time.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} iteratee - A truth test to apply to each item in `coll`.</span>
 <span class="s0">* The `iteratee` is passed a `callback(err, truthValue)`, which must be called</span>
 <span class="s0">* with a boolean argument once it has completed. Invoked with (item, callback).</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} [callback] - A callback which is called after all the</span>
 <span class="s0">* `iteratee` functions have finished. Invoked with (err, results).</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise} a promise, if no callback provided</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">filterLimit </span><span class="s4">(</span><span class="s2">coll</span><span class="s4">, </span><span class="s2">limit</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
    <span class="s3">return </span><span class="s2">_filter</span><span class="s4">(</span><span class="s2">eachOfLimit$2</span><span class="s4">(</span><span class="s2">limit</span><span class="s4">), </span><span class="s2">coll</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">)</span>
<span class="s4">}</span>
<span class="s3">var </span><span class="s2">filterLimit$1 </span><span class="s4">= </span><span class="s2">awaitify</span><span class="s4">(</span><span class="s2">filterLimit</span><span class="s4">, </span><span class="s7">4</span><span class="s4">);</span>

<span class="s0">/**</span>
 <span class="s0">* The same as [`filter`]{</span><span class="s1">@link </span><span class="s0">module:Collections.filter} but runs only a single async operation at a time.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">filterSeries</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s0">[async.filter]{</span><span class="s1">@link </span><span class="s0">module:Collections.filter}</span>
 <span class="s0">* </span><span class="s1">@alias </span><span class="s0">selectSeries</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collection</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} iteratee - A truth test to apply to each item in `coll`.</span>
 <span class="s0">* The `iteratee` is passed a `callback(err, truthValue)`, which must be called</span>
 <span class="s0">* with a boolean argument once it has completed. Invoked with (item, callback).</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} [callback] - A callback which is called after all the</span>
 <span class="s0">* `iteratee` functions have finished. Invoked with (err, results)</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise} a promise, if no callback provided</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">filterSeries </span><span class="s4">(</span><span class="s2">coll</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
    <span class="s3">return </span><span class="s2">_filter</span><span class="s4">(</span><span class="s2">eachOfSeries$1</span><span class="s4">, </span><span class="s2">coll</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">)</span>
<span class="s4">}</span>
<span class="s3">var </span><span class="s2">filterSeries$1 </span><span class="s4">= </span><span class="s2">awaitify</span><span class="s4">(</span><span class="s2">filterSeries</span><span class="s4">, </span><span class="s7">3</span><span class="s4">);</span>

<span class="s0">/**</span>
 <span class="s0">* Calls the asynchronous function `fn` with a callback parameter that allows it</span>
 <span class="s0">* to call itself again, in series, indefinitely.</span>

 <span class="s0">* If an error is passed to the callback then `errback` is called with the</span>
 <span class="s0">* error, and execution stops, otherwise it will never be called.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">forever</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:ControlFlow</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Control Flow</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{AsyncFunction} fn - an async function to call repeatedly.</span>
 <span class="s0">* Invoked with (next).</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} [errback] - when `fn` passes an error to it's callback,</span>
 <span class="s0">* this function will be called, and execution stops. Invoked with (err).</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise} a promise that rejects if an error occurs and an errback</span>
 <span class="s0">* is not passed</span>
 <span class="s0">* </span><span class="s1">@example</span>
 <span class="s0">*</span>
 <span class="s0">* async.forever(</span>
 <span class="s0">*     function(next) {</span>
 <span class="s0">*         // next is suitable for passing to things that need a callback(err [, whatever]);</span>
 <span class="s0">*         // it will result in this function being called again.</span>
 <span class="s0">*     },</span>
 <span class="s0">*     function(err) {</span>
 <span class="s0">*         // if next is called with a value in its first parameter, it will appear</span>
 <span class="s0">*         // in here as 'err', and execution will stop.</span>
 <span class="s0">*     }</span>
 <span class="s0">* );</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">forever</span><span class="s4">(</span><span class="s2">fn</span><span class="s4">, </span><span class="s2">errback</span><span class="s4">) {</span>
    <span class="s3">var </span><span class="s2">done </span><span class="s4">= </span><span class="s2">onlyOnce</span><span class="s4">(</span><span class="s2">errback</span><span class="s4">);</span>
    <span class="s3">var </span><span class="s2">task </span><span class="s4">= </span><span class="s2">wrapAsync</span><span class="s4">(</span><span class="s2">ensureAsync</span><span class="s4">(</span><span class="s2">fn</span><span class="s4">));</span>

    <span class="s3">function </span><span class="s2">next</span><span class="s4">(</span><span class="s2">err</span><span class="s4">) {</span>
        <span class="s3">if </span><span class="s4">(</span><span class="s2">err</span><span class="s4">) </span><span class="s3">return </span><span class="s2">done</span><span class="s4">(</span><span class="s2">err</span><span class="s4">);</span>
        <span class="s3">if </span><span class="s4">(</span><span class="s2">err </span><span class="s4">=== </span><span class="s3">false</span><span class="s4">) </span><span class="s3">return</span><span class="s4">;</span>
        <span class="s2">task</span><span class="s4">(</span><span class="s2">next</span><span class="s4">);</span>
    <span class="s4">}</span>
    <span class="s3">return </span><span class="s2">next</span><span class="s4">();</span>
<span class="s4">}</span>
<span class="s3">var </span><span class="s2">forever$1 </span><span class="s4">= </span><span class="s2">awaitify</span><span class="s4">(</span><span class="s2">forever</span><span class="s4">, </span><span class="s7">2</span><span class="s4">);</span>

<span class="s0">/**</span>
 <span class="s0">* The same as [`groupBy`]{</span><span class="s1">@link </span><span class="s0">module:Collections.groupBy} but runs a maximum of `limit` async operations at a time.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">groupByLimit</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s0">[async.groupBy]{</span><span class="s1">@link </span><span class="s0">module:Collections.groupBy}</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collection</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{number} limit - The maximum number of async operations at a time.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{AsyncFunction} iteratee - An async function to apply to each item in</span>
 <span class="s0">* `coll`.</span>
 <span class="s0">* The iteratee should complete with a `key` to group the value under.</span>
 <span class="s0">* Invoked with (value, callback).</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} [callback] - A callback which is called when all `iteratee`</span>
 <span class="s0">* functions have finished, or an error occurs. Result is an `Object` whoses</span>
 <span class="s0">* properties are arrays of values which returned the corresponding key.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise} a promise, if no callback is passed</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">groupByLimit</span><span class="s4">(</span><span class="s2">coll</span><span class="s4">, </span><span class="s2">limit</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
    <span class="s3">var </span><span class="s2">_iteratee </span><span class="s4">= </span><span class="s2">wrapAsync</span><span class="s4">(</span><span class="s2">iteratee</span><span class="s4">);</span>
    <span class="s3">return </span><span class="s2">mapLimit$1</span><span class="s4">(</span><span class="s2">coll</span><span class="s4">, </span><span class="s2">limit</span><span class="s4">, (</span><span class="s2">val</span><span class="s4">, </span><span class="s2">iterCb</span><span class="s4">) =&gt; {</span>
        <span class="s2">_iteratee</span><span class="s4">(</span><span class="s2">val</span><span class="s4">, (</span><span class="s2">err</span><span class="s4">, </span><span class="s2">key</span><span class="s4">) =&gt; {</span>
            <span class="s3">if </span><span class="s4">(</span><span class="s2">err</span><span class="s4">) </span><span class="s3">return </span><span class="s2">iterCb</span><span class="s4">(</span><span class="s2">err</span><span class="s4">);</span>
            <span class="s3">return </span><span class="s2">iterCb</span><span class="s4">(</span><span class="s2">err</span><span class="s4">, {</span><span class="s2">key</span><span class="s4">, </span><span class="s2">val</span><span class="s4">});</span>
        <span class="s4">});</span>
    <span class="s4">}, (</span><span class="s2">err</span><span class="s4">, </span><span class="s2">mapResults</span><span class="s4">) =&gt; {</span>
        <span class="s3">var </span><span class="s2">result </span><span class="s4">= {};</span>
        <span class="s5">// from MDN, handle object having an `hasOwnProperty` prop</span>
        <span class="s3">var </span><span class="s4">{</span><span class="s2">hasOwnProperty</span><span class="s4">} = </span><span class="s2">Object</span><span class="s4">.</span><span class="s2">prototype</span><span class="s4">;</span>

        <span class="s3">for </span><span class="s4">(</span><span class="s3">var </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s2">mapResults</span><span class="s4">.</span><span class="s2">length</span><span class="s4">; </span><span class="s2">i</span><span class="s4">++) {</span>
            <span class="s3">if </span><span class="s4">(</span><span class="s2">mapResults</span><span class="s4">[</span><span class="s2">i</span><span class="s4">]) {</span>
                <span class="s3">var </span><span class="s4">{</span><span class="s2">key</span><span class="s4">} = </span><span class="s2">mapResults</span><span class="s4">[</span><span class="s2">i</span><span class="s4">];</span>
                <span class="s3">var </span><span class="s4">{</span><span class="s2">val</span><span class="s4">} = </span><span class="s2">mapResults</span><span class="s4">[</span><span class="s2">i</span><span class="s4">];</span>

                <span class="s3">if </span><span class="s4">(</span><span class="s2">hasOwnProperty</span><span class="s4">.</span><span class="s2">call</span><span class="s4">(</span><span class="s2">result</span><span class="s4">, </span><span class="s2">key</span><span class="s4">)) {</span>
                    <span class="s2">result</span><span class="s4">[</span><span class="s2">key</span><span class="s4">].</span><span class="s2">push</span><span class="s4">(</span><span class="s2">val</span><span class="s4">);</span>
                <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
                    <span class="s2">result</span><span class="s4">[</span><span class="s2">key</span><span class="s4">] = [</span><span class="s2">val</span><span class="s4">];</span>
                <span class="s4">}</span>
            <span class="s4">}</span>
        <span class="s4">}</span>

        <span class="s3">return </span><span class="s2">callback</span><span class="s4">(</span><span class="s2">err</span><span class="s4">, </span><span class="s2">result</span><span class="s4">);</span>
    <span class="s4">});</span>
<span class="s4">}</span>

<span class="s3">var </span><span class="s2">groupByLimit$1 </span><span class="s4">= </span><span class="s2">awaitify</span><span class="s4">(</span><span class="s2">groupByLimit</span><span class="s4">, </span><span class="s7">4</span><span class="s4">);</span>

<span class="s0">/**</span>
 <span class="s0">* Returns a new object, where each value corresponds to an array of items, from</span>
 <span class="s0">* `coll`, that returned the corresponding key. That is, the keys of the object</span>
 <span class="s0">* correspond to the values passed to the `iteratee` callback.</span>
 <span class="s0">*</span>
 <span class="s0">* Note: Since this function applies the `iteratee` to each item in parallel,</span>
 <span class="s0">* there is no guarantee that the `iteratee` functions will complete in order.</span>
 <span class="s0">* However, the values for each key in the `result` will be in the same order as</span>
 <span class="s0">* the original `coll`. For Objects, the values will roughly be in the order of</span>
 <span class="s0">* the original Objects' keys (but this can vary across JavaScript engines).</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">groupBy</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collection</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{AsyncFunction} iteratee - An async function to apply to each item in</span>
 <span class="s0">* `coll`.</span>
 <span class="s0">* The iteratee should complete with a `key` to group the value under.</span>
 <span class="s0">* Invoked with (value, callback).</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} [callback] - A callback which is called when all `iteratee`</span>
 <span class="s0">* functions have finished, or an error occurs. Result is an `Object` whoses</span>
 <span class="s0">* properties are arrays of values which returned the corresponding key.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise} a promise, if no callback is passed</span>
 <span class="s0">* </span><span class="s1">@example</span>
 <span class="s0">*</span>
 <span class="s0">* // dir1 is a directory that contains file1.txt, file2.txt</span>
 <span class="s0">* // dir2 is a directory that contains file3.txt, file4.txt</span>
 <span class="s0">* // dir3 is a directory that contains file5.txt</span>
 <span class="s0">* // dir4 does not exist</span>
 <span class="s0">*</span>
 <span class="s0">* const files = ['dir1/file1.txt','dir2','dir4']</span>
 <span class="s0">*</span>
 <span class="s0">* // asynchronous function that detects file type as none, file, or directory</span>
 <span class="s0">* function detectFile(file, callback) {</span>
 <span class="s0">*     fs.stat(file, function(err, stat) {</span>
 <span class="s0">*         if (err) {</span>
 <span class="s0">*             return callback(null, 'none');</span>
 <span class="s0">*         }</span>
 <span class="s0">*         callback(null, stat.isDirectory() ? 'directory' : 'file');</span>
 <span class="s0">*     });</span>
 <span class="s0">* }</span>
 <span class="s0">*</span>
 <span class="s0">* //Using callbacks</span>
 <span class="s0">* async.groupBy(files, detectFile, function(err, result) {</span>
 <span class="s0">*     if(err) {</span>
 <span class="s0">*         console.log(err);</span>
 <span class="s0">*     } else {</span>
 <span class="s0">*	       console.log(result);</span>
 <span class="s0">*         // {</span>
 <span class="s0">*         //     file: [ 'dir1/file1.txt' ],</span>
 <span class="s0">*         //     none: [ 'dir4' ],</span>
 <span class="s0">*         //     directory: [ 'dir2']</span>
 <span class="s0">*         // }</span>
 <span class="s0">*         // result is object containing the files grouped by type</span>
 <span class="s0">*     }</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* // Using Promises</span>
 <span class="s0">* async.groupBy(files, detectFile)</span>
 <span class="s0">* .then( result =&gt; {</span>
 <span class="s0">*     console.log(result);</span>
 <span class="s0">*     // {</span>
 <span class="s0">*     //     file: [ 'dir1/file1.txt' ],</span>
 <span class="s0">*     //     none: [ 'dir4' ],</span>
 <span class="s0">*     //     directory: [ 'dir2']</span>
 <span class="s0">*     // }</span>
 <span class="s0">*     // result is object containing the files grouped by type</span>
 <span class="s0">* }).catch( err =&gt; {</span>
 <span class="s0">*     console.log(err);</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* // Using async/await</span>
 <span class="s0">* async () =&gt; {</span>
 <span class="s0">*     try {</span>
 <span class="s0">*         let result = await async.groupBy(files, detectFile);</span>
 <span class="s0">*         console.log(result);</span>
 <span class="s0">*         // {</span>
 <span class="s0">*         //     file: [ 'dir1/file1.txt' ],</span>
 <span class="s0">*         //     none: [ 'dir4' ],</span>
 <span class="s0">*         //     directory: [ 'dir2']</span>
 <span class="s0">*         // }</span>
 <span class="s0">*         // result is object containing the files grouped by type</span>
 <span class="s0">*     }</span>
 <span class="s0">*     catch (err) {</span>
 <span class="s0">*         console.log(err);</span>
 <span class="s0">*     }</span>
 <span class="s0">* }</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">groupBy </span><span class="s4">(</span><span class="s2">coll</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
    <span class="s3">return </span><span class="s2">groupByLimit$1</span><span class="s4">(</span><span class="s2">coll</span><span class="s4">, </span><span class="s2">Infinity</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">)</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* The same as [`groupBy`]{</span><span class="s1">@link </span><span class="s0">module:Collections.groupBy} but runs only a single async operation at a time.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">groupBySeries</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s0">[async.groupBy]{</span><span class="s1">@link </span><span class="s0">module:Collections.groupBy}</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collection</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{AsyncFunction} iteratee - An async function to apply to each item in</span>
 <span class="s0">* `coll`.</span>
 <span class="s0">* The iteratee should complete with a `key` to group the value under.</span>
 <span class="s0">* Invoked with (value, callback).</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} [callback] - A callback which is called when all `iteratee`</span>
 <span class="s0">* functions have finished, or an error occurs. Result is an `Object` whose</span>
 <span class="s0">* properties are arrays of values which returned the corresponding key.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise} a promise, if no callback is passed</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">groupBySeries </span><span class="s4">(</span><span class="s2">coll</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
    <span class="s3">return </span><span class="s2">groupByLimit$1</span><span class="s4">(</span><span class="s2">coll</span><span class="s4">, </span><span class="s7">1</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">)</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Logs the result of an `async` function to the `console`. Only works in</span>
 <span class="s0">* Node.js or in browsers that support `console.log` and `console.error` (such</span>
 <span class="s0">* as FF and Chrome). If multiple arguments are returned from the async</span>
 <span class="s0">* function, `console.log` is called on each argument in order.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">log</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Utils</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Util</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{AsyncFunction} function - The function you want to eventually apply</span>
 <span class="s0">* all arguments to.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{...*} arguments... - Any number of arguments to apply to the function.</span>
 <span class="s0">* </span><span class="s1">@example</span>
 <span class="s0">*</span>
 <span class="s0">* // in a module</span>
 <span class="s0">* var hello = function(name, callback) {</span>
 <span class="s0">*     setTimeout(function() {</span>
 <span class="s0">*         callback(null, 'hello ' + name);</span>
 <span class="s0">*     }, 1000);</span>
 <span class="s0">* };</span>
 <span class="s0">*</span>
 <span class="s0">* // in the node repl</span>
 <span class="s0">* node&gt; async.log(hello, 'world');</span>
 <span class="s0">* 'hello world'</span>
 <span class="s0">*/</span>
<span class="s3">var </span><span class="s2">log </span><span class="s4">= </span><span class="s2">consoleFunc</span><span class="s4">(</span><span class="s6">'log'</span><span class="s4">);</span>

<span class="s0">/**</span>
 <span class="s0">* The same as [`mapValues`]{</span><span class="s1">@link </span><span class="s0">module:Collections.mapValues} but runs a maximum of `limit` async operations at a</span>
 <span class="s0">* time.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">mapValuesLimit</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s0">[async.mapValues]{</span><span class="s1">@link </span><span class="s0">module:Collections.mapValues}</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collection</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Object} obj - A collection to iterate over.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{number} limit - The maximum number of async operations at a time.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{AsyncFunction} iteratee - A function to apply to each value and key</span>
 <span class="s0">* in `coll`.</span>
 <span class="s0">* The iteratee should complete with the transformed value as its result.</span>
 <span class="s0">* Invoked with (value, key, callback).</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} [callback] - A callback which is called when all `iteratee`</span>
 <span class="s0">* functions have finished, or an error occurs. `result` is a new object consisting</span>
 <span class="s0">* of each key from `obj`, with each transformed value on the right-hand side.</span>
 <span class="s0">* Invoked with (err, result).</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise} a promise, if no callback is passed</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">mapValuesLimit</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">, </span><span class="s2">limit</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
    <span class="s2">callback </span><span class="s4">= </span><span class="s2">once</span><span class="s4">(</span><span class="s2">callback</span><span class="s4">);</span>
    <span class="s3">var </span><span class="s2">newObj </span><span class="s4">= {};</span>
    <span class="s3">var </span><span class="s2">_iteratee </span><span class="s4">= </span><span class="s2">wrapAsync</span><span class="s4">(</span><span class="s2">iteratee</span><span class="s4">);</span>
    <span class="s3">return </span><span class="s2">eachOfLimit$2</span><span class="s4">(</span><span class="s2">limit</span><span class="s4">)(</span><span class="s2">obj</span><span class="s4">, (</span><span class="s2">val</span><span class="s4">, </span><span class="s2">key</span><span class="s4">, </span><span class="s2">next</span><span class="s4">) =&gt; {</span>
        <span class="s2">_iteratee</span><span class="s4">(</span><span class="s2">val</span><span class="s4">, </span><span class="s2">key</span><span class="s4">, (</span><span class="s2">err</span><span class="s4">, </span><span class="s2">result</span><span class="s4">) =&gt; {</span>
            <span class="s3">if </span><span class="s4">(</span><span class="s2">err</span><span class="s4">) </span><span class="s3">return </span><span class="s2">next</span><span class="s4">(</span><span class="s2">err</span><span class="s4">);</span>
            <span class="s2">newObj</span><span class="s4">[</span><span class="s2">key</span><span class="s4">] = </span><span class="s2">result</span><span class="s4">;</span>
            <span class="s2">next</span><span class="s4">(</span><span class="s2">err</span><span class="s4">);</span>
        <span class="s4">});</span>
    <span class="s4">}, </span><span class="s2">err </span><span class="s4">=&gt; </span><span class="s2">callback</span><span class="s4">(</span><span class="s2">err</span><span class="s4">, </span><span class="s2">newObj</span><span class="s4">));</span>
<span class="s4">}</span>

<span class="s3">var </span><span class="s2">mapValuesLimit$1 </span><span class="s4">= </span><span class="s2">awaitify</span><span class="s4">(</span><span class="s2">mapValuesLimit</span><span class="s4">, </span><span class="s7">4</span><span class="s4">);</span>

<span class="s0">/**</span>
 <span class="s0">* A relative of [`map`]{</span><span class="s1">@link </span><span class="s0">module:Collections.map}, designed for use with objects.</span>
 <span class="s0">*</span>
 <span class="s0">* Produces a new Object by mapping each value of `obj` through the `iteratee`</span>
 <span class="s0">* function. The `iteratee` is called each `value` and `key` from `obj` and a</span>
 <span class="s0">* callback for when it has finished processing. Each of these callbacks takes</span>
 <span class="s0">* two arguments: an `error`, and the transformed item from `obj`. If `iteratee`</span>
 <span class="s0">* passes an error to its callback, the main `callback` (for the `mapValues`</span>
 <span class="s0">* function) is immediately called with the error.</span>
 <span class="s0">*</span>
 <span class="s0">* Note, the order of the keys in the result is not guaranteed.  The keys will</span>
 <span class="s0">* be roughly in the order they complete, (but this is very engine-specific)</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">mapValues</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collection</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Object} obj - A collection to iterate over.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{AsyncFunction} iteratee - A function to apply to each value and key</span>
 <span class="s0">* in `coll`.</span>
 <span class="s0">* The iteratee should complete with the transformed value as its result.</span>
 <span class="s0">* Invoked with (value, key, callback).</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} [callback] - A callback which is called when all `iteratee`</span>
 <span class="s0">* functions have finished, or an error occurs. `result` is a new object consisting</span>
 <span class="s0">* of each key from `obj`, with each transformed value on the right-hand side.</span>
 <span class="s0">* Invoked with (err, result).</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise} a promise, if no callback is passed</span>
 <span class="s0">* </span><span class="s1">@example</span>
 <span class="s0">*</span>
 <span class="s0">* // file1.txt is a file that is 1000 bytes in size</span>
 <span class="s0">* // file2.txt is a file that is 2000 bytes in size</span>
 <span class="s0">* // file3.txt is a file that is 3000 bytes in size</span>
 <span class="s0">* // file4.txt does not exist</span>
 <span class="s0">*</span>
 <span class="s0">* const fileMap = {</span>
 <span class="s0">*     f1: 'file1.txt',</span>
 <span class="s0">*     f2: 'file2.txt',</span>
 <span class="s0">*     f3: 'file3.txt'</span>
 <span class="s0">* };</span>
 <span class="s0">*</span>
 <span class="s0">* const withMissingFileMap = {</span>
 <span class="s0">*     f1: 'file1.txt',</span>
 <span class="s0">*     f2: 'file2.txt',</span>
 <span class="s0">*     f3: 'file4.txt'</span>
 <span class="s0">* };</span>
 <span class="s0">*</span>
 <span class="s0">* // asynchronous function that returns the file size in bytes</span>
 <span class="s0">* function getFileSizeInBytes(file, key, callback) {</span>
 <span class="s0">*     fs.stat(file, function(err, stat) {</span>
 <span class="s0">*         if (err) {</span>
 <span class="s0">*             return callback(err);</span>
 <span class="s0">*         }</span>
 <span class="s0">*         callback(null, stat.size);</span>
 <span class="s0">*     });</span>
 <span class="s0">* }</span>
 <span class="s0">*</span>
 <span class="s0">* // Using callbacks</span>
 <span class="s0">* async.mapValues(fileMap, getFileSizeInBytes, function(err, result) {</span>
 <span class="s0">*     if (err) {</span>
 <span class="s0">*         console.log(err);</span>
 <span class="s0">*     } else {</span>
 <span class="s0">*         console.log(result);</span>
 <span class="s0">*         // result is now a map of file size in bytes for each file, e.g.</span>
 <span class="s0">*         // {</span>
 <span class="s0">*         //     f1: 1000,</span>
 <span class="s0">*         //     f2: 2000,</span>
 <span class="s0">*         //     f3: 3000</span>
 <span class="s0">*         // }</span>
 <span class="s0">*     }</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* // Error handling</span>
 <span class="s0">* async.mapValues(withMissingFileMap, getFileSizeInBytes, function(err, result) {</span>
 <span class="s0">*     if (err) {</span>
 <span class="s0">*         console.log(err);</span>
 <span class="s0">*         // [ Error: ENOENT: no such file or directory ]</span>
 <span class="s0">*     } else {</span>
 <span class="s0">*         console.log(result);</span>
 <span class="s0">*     }</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* // Using Promises</span>
 <span class="s0">* async.mapValues(fileMap, getFileSizeInBytes)</span>
 <span class="s0">* .then( result =&gt; {</span>
 <span class="s0">*     console.log(result);</span>
 <span class="s0">*     // result is now a map of file size in bytes for each file, e.g.</span>
 <span class="s0">*     // {</span>
 <span class="s0">*     //     f1: 1000,</span>
 <span class="s0">*     //     f2: 2000,</span>
 <span class="s0">*     //     f3: 3000</span>
 <span class="s0">*     // }</span>
 <span class="s0">* }).catch (err =&gt; {</span>
 <span class="s0">*     console.log(err);</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* // Error Handling</span>
 <span class="s0">* async.mapValues(withMissingFileMap, getFileSizeInBytes)</span>
 <span class="s0">* .then( result =&gt; {</span>
 <span class="s0">*     console.log(result);</span>
 <span class="s0">* }).catch (err =&gt; {</span>
 <span class="s0">*     console.log(err);</span>
 <span class="s0">*     // [ Error: ENOENT: no such file or directory ]</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* // Using async/await</span>
 <span class="s0">* async () =&gt; {</span>
 <span class="s0">*     try {</span>
 <span class="s0">*         let result = await async.mapValues(fileMap, getFileSizeInBytes);</span>
 <span class="s0">*         console.log(result);</span>
 <span class="s0">*         // result is now a map of file size in bytes for each file, e.g.</span>
 <span class="s0">*         // {</span>
 <span class="s0">*         //     f1: 1000,</span>
 <span class="s0">*         //     f2: 2000,</span>
 <span class="s0">*         //     f3: 3000</span>
 <span class="s0">*         // }</span>
 <span class="s0">*     }</span>
 <span class="s0">*     catch (err) {</span>
 <span class="s0">*         console.log(err);</span>
 <span class="s0">*     }</span>
 <span class="s0">* }</span>
 <span class="s0">*</span>
 <span class="s0">* // Error Handling</span>
 <span class="s0">* async () =&gt; {</span>
 <span class="s0">*     try {</span>
 <span class="s0">*         let result = await async.mapValues(withMissingFileMap, getFileSizeInBytes);</span>
 <span class="s0">*         console.log(result);</span>
 <span class="s0">*     }</span>
 <span class="s0">*     catch (err) {</span>
 <span class="s0">*         console.log(err);</span>
 <span class="s0">*         // [ Error: ENOENT: no such file or directory ]</span>
 <span class="s0">*     }</span>
 <span class="s0">* }</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">mapValues</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
    <span class="s3">return </span><span class="s2">mapValuesLimit$1</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">, </span><span class="s2">Infinity</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">)</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* The same as [`mapValues`]{</span><span class="s1">@link </span><span class="s0">module:Collections.mapValues} but runs only a single async operation at a time.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">mapValuesSeries</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s0">[async.mapValues]{</span><span class="s1">@link </span><span class="s0">module:Collections.mapValues}</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collection</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Object} obj - A collection to iterate over.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{AsyncFunction} iteratee - A function to apply to each value and key</span>
 <span class="s0">* in `coll`.</span>
 <span class="s0">* The iteratee should complete with the transformed value as its result.</span>
 <span class="s0">* Invoked with (value, key, callback).</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} [callback] - A callback which is called when all `iteratee`</span>
 <span class="s0">* functions have finished, or an error occurs. `result` is a new object consisting</span>
 <span class="s0">* of each key from `obj`, with each transformed value on the right-hand side.</span>
 <span class="s0">* Invoked with (err, result).</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise} a promise, if no callback is passed</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">mapValuesSeries</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
    <span class="s3">return </span><span class="s2">mapValuesLimit$1</span><span class="s4">(</span><span class="s2">obj</span><span class="s4">, </span><span class="s7">1</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">)</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Caches the results of an async function. When creating a hash to store</span>
 <span class="s0">* function results against, the callback is omitted from the hash and an</span>
 <span class="s0">* optional hash function can be used.</span>
 <span class="s0">*</span>
 <span class="s0">* **Note: if the async function errs, the result will not be cached and</span>
 <span class="s0">* subsequent calls will call the wrapped function.**</span>
 <span class="s0">*</span>
 <span class="s0">* If no hash function is specified, the first argument is used as a hash key,</span>
 <span class="s0">* which may work reasonably if it is a string or a data type that converts to a</span>
 <span class="s0">* distinct string. Note that objects and arrays will not behave reasonably.</span>
 <span class="s0">* Neither will cases where the other arguments are significant. In such cases,</span>
 <span class="s0">* specify your own hash function.</span>
 <span class="s0">*</span>
 <span class="s0">* The cache of results is exposed as the `memo` property of the function</span>
 <span class="s0">* returned by `memoize`.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">memoize</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Utils</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Util</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{AsyncFunction} fn - The async function to proxy and cache results from.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} hasher - An optional function for generating a custom hash</span>
 <span class="s0">* for storing results. It has all the arguments applied to it apart from the</span>
 <span class="s0">* callback, and must be synchronous.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{AsyncFunction} a memoized version of `fn`</span>
 <span class="s0">* </span><span class="s1">@example</span>
 <span class="s0">*</span>
 <span class="s0">* var slow_fn = function(name, callback) {</span>
 <span class="s0">*     // do something</span>
 <span class="s0">*     callback(null, result);</span>
 <span class="s0">* };</span>
 <span class="s0">* var fn = async.memoize(slow_fn);</span>
 <span class="s0">*</span>
 <span class="s0">* // fn can now be used as if it were slow_fn</span>
 <span class="s0">* fn('some name', function() {</span>
 <span class="s0">*     // callback</span>
 <span class="s0">* });</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">memoize</span><span class="s4">(</span><span class="s2">fn</span><span class="s4">, </span><span class="s2">hasher </span><span class="s4">= </span><span class="s2">v </span><span class="s4">=&gt; </span><span class="s2">v</span><span class="s4">) {</span>
    <span class="s3">var </span><span class="s2">memo </span><span class="s4">= </span><span class="s2">Object</span><span class="s4">.</span><span class="s2">create</span><span class="s4">(</span><span class="s3">null</span><span class="s4">);</span>
    <span class="s3">var </span><span class="s2">queues </span><span class="s4">= </span><span class="s2">Object</span><span class="s4">.</span><span class="s2">create</span><span class="s4">(</span><span class="s3">null</span><span class="s4">);</span>
    <span class="s3">var </span><span class="s2">_fn </span><span class="s4">= </span><span class="s2">wrapAsync</span><span class="s4">(</span><span class="s2">fn</span><span class="s4">);</span>
    <span class="s3">var </span><span class="s2">memoized </span><span class="s4">= </span><span class="s2">initialParams</span><span class="s4">((</span><span class="s2">args</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) =&gt; {</span>
        <span class="s3">var </span><span class="s2">key </span><span class="s4">= </span><span class="s2">hasher</span><span class="s4">(</span><span class="s2">...args</span><span class="s4">);</span>
        <span class="s3">if </span><span class="s4">(</span><span class="s2">key </span><span class="s3">in </span><span class="s2">memo</span><span class="s4">) {</span>
            <span class="s2">setImmediate$1</span><span class="s4">(() =&gt; </span><span class="s2">callback</span><span class="s4">(</span><span class="s3">null</span><span class="s4">, </span><span class="s2">...memo</span><span class="s4">[</span><span class="s2">key</span><span class="s4">]));</span>
        <span class="s4">} </span><span class="s3">else if </span><span class="s4">(</span><span class="s2">key </span><span class="s3">in </span><span class="s2">queues</span><span class="s4">) {</span>
            <span class="s2">queues</span><span class="s4">[</span><span class="s2">key</span><span class="s4">].</span><span class="s2">push</span><span class="s4">(</span><span class="s2">callback</span><span class="s4">);</span>
        <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
            <span class="s2">queues</span><span class="s4">[</span><span class="s2">key</span><span class="s4">] = [</span><span class="s2">callback</span><span class="s4">];</span>
            <span class="s2">_fn</span><span class="s4">(</span><span class="s2">...args</span><span class="s4">, (</span><span class="s2">err</span><span class="s4">, </span><span class="s2">...resultArgs</span><span class="s4">) =&gt; {</span>
                <span class="s5">// #1465 don't memoize if an error occurred</span>
                <span class="s3">if </span><span class="s4">(!</span><span class="s2">err</span><span class="s4">) {</span>
                    <span class="s2">memo</span><span class="s4">[</span><span class="s2">key</span><span class="s4">] = </span><span class="s2">resultArgs</span><span class="s4">;</span>
                <span class="s4">}</span>
                <span class="s3">var </span><span class="s2">q </span><span class="s4">= </span><span class="s2">queues</span><span class="s4">[</span><span class="s2">key</span><span class="s4">];</span>
                <span class="s3">delete </span><span class="s2">queues</span><span class="s4">[</span><span class="s2">key</span><span class="s4">];</span>
                <span class="s3">for </span><span class="s4">(</span><span class="s3">var </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">, </span><span class="s2">l </span><span class="s4">= </span><span class="s2">q</span><span class="s4">.</span><span class="s2">length</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s2">l</span><span class="s4">; </span><span class="s2">i</span><span class="s4">++) {</span>
                    <span class="s2">q</span><span class="s4">[</span><span class="s2">i</span><span class="s4">](</span><span class="s2">err</span><span class="s4">, </span><span class="s2">...resultArgs</span><span class="s4">);</span>
                <span class="s4">}</span>
            <span class="s4">});</span>
        <span class="s4">}</span>
    <span class="s4">});</span>
    <span class="s2">memoized</span><span class="s4">.</span><span class="s2">memo </span><span class="s4">= </span><span class="s2">memo</span><span class="s4">;</span>
    <span class="s2">memoized</span><span class="s4">.</span><span class="s2">unmemoized </span><span class="s4">= </span><span class="s2">fn</span><span class="s4">;</span>
    <span class="s3">return </span><span class="s2">memoized</span><span class="s4">;</span>
<span class="s4">}</span>

<span class="s5">/* istanbul ignore file */</span>

<span class="s0">/**</span>
 <span class="s0">* Calls `callback` on a later loop around the event loop. In Node.js this just</span>
 <span class="s0">* calls `process.nextTick`.  In the browser it will use `setImmediate` if</span>
 <span class="s0">* available, otherwise `setTimeout(callback, 0)`, which means other higher</span>
 <span class="s0">* priority events may precede the execution of `callback`.</span>
 <span class="s0">*</span>
 <span class="s0">* This is used internally for browser-compatibility purposes.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">nextTick</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Utils</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s0">[async.setImmediate]{</span><span class="s1">@link </span><span class="s0">module:Utils.setImmediate}</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Util</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} callback - The function to call on a later loop around</span>
 <span class="s0">* the event loop. Invoked with (args...).</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{...*} args... - any number of additional arguments to pass to the</span>
 <span class="s0">* callback on the next tick.</span>
 <span class="s0">* </span><span class="s1">@example</span>
 <span class="s0">*</span>
 <span class="s0">* var call_order = [];</span>
 <span class="s0">* async.nextTick(function() {</span>
 <span class="s0">*     call_order.push('two');</span>
 <span class="s0">*     // call_order now equals ['one','two']</span>
 <span class="s0">* });</span>
 <span class="s0">* call_order.push('one');</span>
 <span class="s0">*</span>
 <span class="s0">* async.setImmediate(function (a, b, c) {</span>
 <span class="s0">*     // a, b, and c equal 1, 2, and 3</span>
 <span class="s0">* }, 1, 2, 3);</span>
 <span class="s0">*/</span>
<span class="s3">var </span><span class="s2">_defer</span><span class="s4">;</span>

<span class="s3">if </span><span class="s4">(</span><span class="s2">hasNextTick</span><span class="s4">) {</span>
    <span class="s2">_defer </span><span class="s4">= </span><span class="s2">process</span><span class="s4">.</span><span class="s2">nextTick</span><span class="s4">;</span>
<span class="s4">} </span><span class="s3">else if </span><span class="s4">(</span><span class="s2">hasSetImmediate</span><span class="s4">) {</span>
    <span class="s2">_defer </span><span class="s4">= </span><span class="s2">setImmediate</span><span class="s4">;</span>
<span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
    <span class="s2">_defer </span><span class="s4">= </span><span class="s2">fallback</span><span class="s4">;</span>
<span class="s4">}</span>

<span class="s3">var </span><span class="s2">nextTick </span><span class="s4">= </span><span class="s2">wrap</span><span class="s4">(</span><span class="s2">_defer</span><span class="s4">);</span>

<span class="s3">var </span><span class="s2">_parallel </span><span class="s4">= </span><span class="s2">awaitify</span><span class="s4">((</span><span class="s2">eachfn</span><span class="s4">, </span><span class="s2">tasks</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) =&gt; {</span>
    <span class="s3">var </span><span class="s2">results </span><span class="s4">= </span><span class="s2">isArrayLike</span><span class="s4">(</span><span class="s2">tasks</span><span class="s4">) ? [] : {};</span>

    <span class="s2">eachfn</span><span class="s4">(</span><span class="s2">tasks</span><span class="s4">, (</span><span class="s2">task</span><span class="s4">, </span><span class="s2">key</span><span class="s4">, </span><span class="s2">taskCb</span><span class="s4">) =&gt; {</span>
        <span class="s2">wrapAsync</span><span class="s4">(</span><span class="s2">task</span><span class="s4">)((</span><span class="s2">err</span><span class="s4">, </span><span class="s2">...result</span><span class="s4">) =&gt; {</span>
            <span class="s3">if </span><span class="s4">(</span><span class="s2">result</span><span class="s4">.</span><span class="s2">length </span><span class="s4">&lt; </span><span class="s7">2</span><span class="s4">) {</span>
                <span class="s4">[</span><span class="s2">result</span><span class="s4">] = </span><span class="s2">result</span><span class="s4">;</span>
            <span class="s4">}</span>
            <span class="s2">results</span><span class="s4">[</span><span class="s2">key</span><span class="s4">] = </span><span class="s2">result</span><span class="s4">;</span>
            <span class="s2">taskCb</span><span class="s4">(</span><span class="s2">err</span><span class="s4">);</span>
        <span class="s4">});</span>
    <span class="s4">}, </span><span class="s2">err </span><span class="s4">=&gt; </span><span class="s2">callback</span><span class="s4">(</span><span class="s2">err</span><span class="s4">, </span><span class="s2">results</span><span class="s4">));</span>
<span class="s4">}, </span><span class="s7">3</span><span class="s4">);</span>

<span class="s0">/**</span>
 <span class="s0">* Run the `tasks` collection of functions in parallel, without waiting until</span>
 <span class="s0">* the previous function has completed. If any of the functions pass an error to</span>
 <span class="s0">* its callback, the main `callback` is immediately called with the value of the</span>
 <span class="s0">* error. Once the `tasks` have completed, the results are passed to the final</span>
 <span class="s0">* `callback` as an array.</span>
 <span class="s0">*</span>
 <span class="s0">* **Note:** `parallel` is about kicking-off I/O tasks in parallel, not about</span>
 <span class="s0">* parallel execution of code.  If your tasks do not use any timers or perform</span>
 <span class="s0">* any I/O, they will actually be executed in series.  Any synchronous setup</span>
 <span class="s0">* sections for each task will happen one after the other.  JavaScript remains</span>
 <span class="s0">* single-threaded.</span>
 <span class="s0">*</span>
 <span class="s0">* **Hint:** Use [`reflect`]{</span><span class="s1">@link </span><span class="s0">module:Utils.reflect} to continue the</span>
 <span class="s0">* execution of other tasks when a task fails.</span>
 <span class="s0">*</span>
 <span class="s0">* It is also possible to use an object instead of an array. Each property will</span>
 <span class="s0">* be run as a function and the results will be passed to the final `callback`</span>
 <span class="s0">* as an object instead of an array. This can be a more readable way of handling</span>
 <span class="s0">* results from {</span><span class="s1">@link </span><span class="s0">async.parallel}.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">parallel</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:ControlFlow</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Control Flow</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Array|Iterable|AsyncIterable|Object} tasks - A collection of</span>
 <span class="s0">* [async functions]{</span><span class="s1">@link </span><span class="s0">AsyncFunction} to run.</span>
 <span class="s0">* Each async function can complete with any number of optional `result` values.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} [callback] - An optional callback to run once all the</span>
 <span class="s0">* functions have completed successfully. This function gets a results array</span>
 <span class="s0">* (or object) containing all the result arguments passed to the task callbacks.</span>
 <span class="s0">* Invoked with (err, results).</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise} a promise, if a callback is not passed</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@example</span>
 <span class="s0">*</span>
 <span class="s0">* //Using Callbacks</span>
 <span class="s0">* async.parallel([</span>
 <span class="s0">*     function(callback) {</span>
 <span class="s0">*         setTimeout(function() {</span>
 <span class="s0">*             callback(null, 'one');</span>
 <span class="s0">*         }, 200);</span>
 <span class="s0">*     },</span>
 <span class="s0">*     function(callback) {</span>
 <span class="s0">*         setTimeout(function() {</span>
 <span class="s0">*             callback(null, 'two');</span>
 <span class="s0">*         }, 100);</span>
 <span class="s0">*     }</span>
 <span class="s0">* ], function(err, results) {</span>
 <span class="s0">*     console.log(results);</span>
 <span class="s0">*     // results is equal to ['one','two'] even though</span>
 <span class="s0">*     // the second function had a shorter timeout.</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* // an example using an object instead of an array</span>
 <span class="s0">* async.parallel({</span>
 <span class="s0">*     one: function(callback) {</span>
 <span class="s0">*         setTimeout(function() {</span>
 <span class="s0">*             callback(null, 1);</span>
 <span class="s0">*         }, 200);</span>
 <span class="s0">*     },</span>
 <span class="s0">*     two: function(callback) {</span>
 <span class="s0">*         setTimeout(function() {</span>
 <span class="s0">*             callback(null, 2);</span>
 <span class="s0">*         }, 100);</span>
 <span class="s0">*     }</span>
 <span class="s0">* }, function(err, results) {</span>
 <span class="s0">*     console.log(results);</span>
 <span class="s0">*     // results is equal to: { one: 1, two: 2 }</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* //Using Promises</span>
 <span class="s0">* async.parallel([</span>
 <span class="s0">*     function(callback) {</span>
 <span class="s0">*         setTimeout(function() {</span>
 <span class="s0">*             callback(null, 'one');</span>
 <span class="s0">*         }, 200);</span>
 <span class="s0">*     },</span>
 <span class="s0">*     function(callback) {</span>
 <span class="s0">*         setTimeout(function() {</span>
 <span class="s0">*             callback(null, 'two');</span>
 <span class="s0">*         }, 100);</span>
 <span class="s0">*     }</span>
 <span class="s0">* ]).then(results =&gt; {</span>
 <span class="s0">*     console.log(results);</span>
 <span class="s0">*     // results is equal to ['one','two'] even though</span>
 <span class="s0">*     // the second function had a shorter timeout.</span>
 <span class="s0">* }).catch(err =&gt; {</span>
 <span class="s0">*     console.log(err);</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* // an example using an object instead of an array</span>
 <span class="s0">* async.parallel({</span>
 <span class="s0">*     one: function(callback) {</span>
 <span class="s0">*         setTimeout(function() {</span>
 <span class="s0">*             callback(null, 1);</span>
 <span class="s0">*         }, 200);</span>
 <span class="s0">*     },</span>
 <span class="s0">*     two: function(callback) {</span>
 <span class="s0">*         setTimeout(function() {</span>
 <span class="s0">*             callback(null, 2);</span>
 <span class="s0">*         }, 100);</span>
 <span class="s0">*     }</span>
 <span class="s0">* }).then(results =&gt; {</span>
 <span class="s0">*     console.log(results);</span>
 <span class="s0">*     // results is equal to: { one: 1, two: 2 }</span>
 <span class="s0">* }).catch(err =&gt; {</span>
 <span class="s0">*     console.log(err);</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* //Using async/await</span>
 <span class="s0">* async () =&gt; {</span>
 <span class="s0">*     try {</span>
 <span class="s0">*         let results = await async.parallel([</span>
 <span class="s0">*             function(callback) {</span>
 <span class="s0">*                 setTimeout(function() {</span>
 <span class="s0">*                     callback(null, 'one');</span>
 <span class="s0">*                 }, 200);</span>
 <span class="s0">*             },</span>
 <span class="s0">*             function(callback) {</span>
 <span class="s0">*                 setTimeout(function() {</span>
 <span class="s0">*                     callback(null, 'two');</span>
 <span class="s0">*                 }, 100);</span>
 <span class="s0">*             }</span>
 <span class="s0">*         ]);</span>
 <span class="s0">*         console.log(results);</span>
 <span class="s0">*         // results is equal to ['one','two'] even though</span>
 <span class="s0">*         // the second function had a shorter timeout.</span>
 <span class="s0">*     }</span>
 <span class="s0">*     catch (err) {</span>
 <span class="s0">*         console.log(err);</span>
 <span class="s0">*     }</span>
 <span class="s0">* }</span>
 <span class="s0">*</span>
 <span class="s0">* // an example using an object instead of an array</span>
 <span class="s0">* async () =&gt; {</span>
 <span class="s0">*     try {</span>
 <span class="s0">*         let results = await async.parallel({</span>
 <span class="s0">*             one: function(callback) {</span>
 <span class="s0">*                 setTimeout(function() {</span>
 <span class="s0">*                     callback(null, 1);</span>
 <span class="s0">*                 }, 200);</span>
 <span class="s0">*             },</span>
 <span class="s0">*            two: function(callback) {</span>
 <span class="s0">*                 setTimeout(function() {</span>
 <span class="s0">*                     callback(null, 2);</span>
 <span class="s0">*                 }, 100);</span>
 <span class="s0">*            }</span>
 <span class="s0">*         });</span>
 <span class="s0">*         console.log(results);</span>
 <span class="s0">*         // results is equal to: { one: 1, two: 2 }</span>
 <span class="s0">*     }</span>
 <span class="s0">*     catch (err) {</span>
 <span class="s0">*         console.log(err);</span>
 <span class="s0">*     }</span>
 <span class="s0">* }</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">parallel</span><span class="s4">(</span><span class="s2">tasks</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
    <span class="s3">return </span><span class="s2">_parallel</span><span class="s4">(</span><span class="s2">eachOf$1</span><span class="s4">, </span><span class="s2">tasks</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">);</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* The same as [`parallel`]{</span><span class="s1">@link </span><span class="s0">module:ControlFlow.parallel} but runs a maximum of `limit` async operations at a</span>
 <span class="s0">* time.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">parallelLimit</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:ControlFlow</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s0">[async.parallel]{</span><span class="s1">@link </span><span class="s0">module:ControlFlow.parallel}</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Control Flow</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Array|Iterable|AsyncIterable|Object} tasks - A collection of</span>
 <span class="s0">* [async functions]{</span><span class="s1">@link </span><span class="s0">AsyncFunction} to run.</span>
 <span class="s0">* Each async function can complete with any number of optional `result` values.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{number} limit - The maximum number of async operations at a time.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} [callback] - An optional callback to run once all the</span>
 <span class="s0">* functions have completed successfully. This function gets a results array</span>
 <span class="s0">* (or object) containing all the result arguments passed to the task callbacks.</span>
 <span class="s0">* Invoked with (err, results).</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise} a promise, if a callback is not passed</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">parallelLimit</span><span class="s4">(</span><span class="s2">tasks</span><span class="s4">, </span><span class="s2">limit</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
    <span class="s3">return </span><span class="s2">_parallel</span><span class="s4">(</span><span class="s2">eachOfLimit$2</span><span class="s4">(</span><span class="s2">limit</span><span class="s4">), </span><span class="s2">tasks</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">);</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* A queue of tasks for the worker function to complete.</span>
 <span class="s0">* </span><span class="s1">@typedef </span><span class="s0">{Iterable} QueueObject</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:ControlFlow</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{Function} length - a function returning the number of items</span>
 <span class="s0">* waiting to be processed. Invoke with `queue.length()`.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{boolean} started - a boolean indicating whether or not any</span>
 <span class="s0">* items have been pushed and processed by the queue.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{Function} running - a function returning the number of items</span>
 <span class="s0">* currently being processed. Invoke with `queue.running()`.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{Function} workersList - a function returning the array of items</span>
 <span class="s0">* currently being processed. Invoke with `queue.workersList()`.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{Function} idle - a function returning false if there are items</span>
 <span class="s0">* waiting or being processed, or true if not. Invoke with `queue.idle()`.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{number} concurrency - an integer for determining how many `worker`</span>
 <span class="s0">* functions should be run in parallel. This property can be changed after a</span>
 <span class="s0">* `queue` is created to alter the concurrency on-the-fly.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{number} payload - an integer that specifies how many items are</span>
 <span class="s0">* passed to the worker function at a time. only applies if this is a</span>
 <span class="s0">* [cargo]{</span><span class="s1">@link </span><span class="s0">module:ControlFlow.cargo} object</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{AsyncFunction} push - add a new task to the `queue`. Calls `callback`</span>
 <span class="s0">* once the `worker` has finished processing the task. Instead of a single task,</span>
 <span class="s0">* a `tasks` array can be submitted. The respective callback is used for every</span>
 <span class="s0">* task in the list. Invoke with `queue.push(task, [callback])`,</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{AsyncFunction} unshift - add a new task to the front of the `queue`.</span>
 <span class="s0">* Invoke with `queue.unshift(task, [callback])`.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{AsyncFunction} pushAsync - the same as `q.push`, except this returns</span>
 <span class="s0">* a promise that rejects if an error occurs.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{AsyncFunction} unshiftAsync - the same as `q.unshift`, except this returns</span>
 <span class="s0">* a promise that rejects if an error occurs.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{Function} remove - remove items from the queue that match a test</span>
 <span class="s0">* function.  The test function will be passed an object with a `data` property,</span>
 <span class="s0">* and a `priority` property, if this is a</span>
 <span class="s0">* [priorityQueue]{</span><span class="s1">@link </span><span class="s0">module:ControlFlow.priorityQueue} object.</span>
 <span class="s0">* Invoked with `queue.remove(testFn)`, where `testFn` is of the form</span>
 <span class="s0">* `function ({data, priority}) {}` and returns a Boolean.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{Function} saturated - a function that sets a callback that is</span>
 <span class="s0">* called when the number of running workers hits the `concurrency` limit, and</span>
 <span class="s0">* further tasks will be queued.  If the callback is omitted, `q.saturated()`</span>
 <span class="s0">* returns a promise for the next occurrence.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{Function} unsaturated - a function that sets a callback that is</span>
 <span class="s0">* called when the number of running workers is less than the `concurrency` &amp;</span>
 <span class="s0">* `buffer` limits, and further tasks will not be queued. If the callback is</span>
 <span class="s0">* omitted, `q.unsaturated()` returns a promise for the next occurrence.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{number} buffer - A minimum threshold buffer in order to say that</span>
 <span class="s0">* the `queue` is `unsaturated`.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{Function} empty - a function that sets a callback that is called</span>
 <span class="s0">* when the last item from the `queue` is given to a `worker`. If the callback</span>
 <span class="s0">* is omitted, `q.empty()` returns a promise for the next occurrence.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{Function} drain - a function that sets a callback that is called</span>
 <span class="s0">* when the last item from the `queue` has returned from the `worker`. If the</span>
 <span class="s0">* callback is omitted, `q.drain()` returns a promise for the next occurrence.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{Function} error - a function that sets a callback that is called</span>
 <span class="s0">* when a task errors. Has the signature `function(error, task)`. If the</span>
 <span class="s0">* callback is omitted, `error()` returns a promise that rejects on the next</span>
 <span class="s0">* error.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{boolean} paused - a boolean for determining whether the queue is</span>
 <span class="s0">* in a paused state.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{Function} pause - a function that pauses the processing of tasks</span>
 <span class="s0">* until `resume()` is called. Invoke with `queue.pause()`.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{Function} resume - a function that resumes the processing of</span>
 <span class="s0">* queued tasks when the queue is paused. Invoke with `queue.resume()`.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{Function} kill - a function that removes the `drain` callback and</span>
 <span class="s0">* empties remaining tasks from the queue forcing it to go idle. No more tasks</span>
 <span class="s0">* should be pushed to the queue after calling this function. Invoke with `queue.kill()`.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@example</span>
 <span class="s0">* const q = async.queue(worker, 2)</span>
 <span class="s0">* q.push(item1)</span>
 <span class="s0">* q.push(item2)</span>
 <span class="s0">* q.push(item3)</span>
 <span class="s0">* // queues are iterable, spread into an array to inspect</span>
 <span class="s0">* const items = [...q] // [item1, item2, item3]</span>
 <span class="s0">* // or use for of</span>
 <span class="s0">* for (let item of q) {</span>
 <span class="s0">*     console.log(item)</span>
 <span class="s0">* }</span>
 <span class="s0">*</span>
 <span class="s0">* q.drain(() =&gt; {</span>
 <span class="s0">*     console.log('all done')</span>
 <span class="s0">* })</span>
 <span class="s0">* // or</span>
 <span class="s0">* await q.drain()</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Creates a `queue` object with the specified `concurrency`. Tasks added to the</span>
 <span class="s0">* `queue` are processed in parallel (up to the `concurrency` limit). If all</span>
 <span class="s0">* `worker`s are in progress, the task is queued until one becomes available.</span>
 <span class="s0">* Once a `worker` completes a `task`, that `task`'s callback is called.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">queue</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:ControlFlow</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Control Flow</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{AsyncFunction} worker - An async function for processing a queued task.</span>
 <span class="s0">* If you want to handle errors from an individual task, pass a callback to</span>
 <span class="s0">* `q.push()`. Invoked with (task, callback).</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{number} [concurrency=1] - An `integer` for determining how many</span>
 <span class="s0">* `worker` functions should be run in parallel.  If omitted, the concurrency</span>
 <span class="s0">* defaults to `1`.  If the concurrency is `0`, an error is thrown.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{module:ControlFlow.QueueObject} A queue object to manage the tasks. Callbacks can be</span>
 <span class="s0">* attached as certain properties to listen for specific events during the</span>
 <span class="s0">* lifecycle of the queue.</span>
 <span class="s0">* </span><span class="s1">@example</span>
 <span class="s0">*</span>
 <span class="s0">* // create a queue object with concurrency 2</span>
 <span class="s0">* var q = async.queue(function(task, callback) {</span>
 <span class="s0">*     console.log('hello ' + task.name);</span>
 <span class="s0">*     callback();</span>
 <span class="s0">* }, 2);</span>
 <span class="s0">*</span>
 <span class="s0">* // assign a callback</span>
 <span class="s0">* q.drain(function() {</span>
 <span class="s0">*     console.log('all items have been processed');</span>
 <span class="s0">* });</span>
 <span class="s0">* // or await the end</span>
 <span class="s0">* await q.drain()</span>
 <span class="s0">*</span>
 <span class="s0">* // assign an error callback</span>
 <span class="s0">* q.error(function(err, task) {</span>
 <span class="s0">*     console.error('task experienced an error');</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* // add some items to the queue</span>
 <span class="s0">* q.push({name: 'foo'}, function(err) {</span>
 <span class="s0">*     console.log('finished processing foo');</span>
 <span class="s0">* });</span>
 <span class="s0">* // callback is optional</span>
 <span class="s0">* q.push({name: 'bar'});</span>
 <span class="s0">*</span>
 <span class="s0">* // add some items to the queue (batch-wise)</span>
 <span class="s0">* q.push([{name: 'baz'},{name: 'bay'},{name: 'bax'}], function(err) {</span>
 <span class="s0">*     console.log('finished processing item');</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* // add some items to the front of the queue</span>
 <span class="s0">* q.unshift({name: 'bar'}, function (err) {</span>
 <span class="s0">*     console.log('finished processing bar');</span>
 <span class="s0">* });</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">queue </span><span class="s4">(</span><span class="s2">worker</span><span class="s4">, </span><span class="s2">concurrency</span><span class="s4">) {</span>
    <span class="s3">var </span><span class="s2">_worker </span><span class="s4">= </span><span class="s2">wrapAsync</span><span class="s4">(</span><span class="s2">worker</span><span class="s4">);</span>
    <span class="s3">return </span><span class="s2">queue$1</span><span class="s4">((</span><span class="s2">items</span><span class="s4">, </span><span class="s2">cb</span><span class="s4">) =&gt; {</span>
        <span class="s2">_worker</span><span class="s4">(</span><span class="s2">items</span><span class="s4">[</span><span class="s7">0</span><span class="s4">], </span><span class="s2">cb</span><span class="s4">);</span>
    <span class="s4">}, </span><span class="s2">concurrency</span><span class="s4">, </span><span class="s7">1</span><span class="s4">);</span>
<span class="s4">}</span>

<span class="s5">// Binary min-heap implementation used for priority queue.</span>
<span class="s5">// Implementation is stable, i.e. push time is considered for equal priorities</span>
<span class="s3">class </span><span class="s2">Heap </span><span class="s4">{</span>
    <span class="s2">constructor</span><span class="s4">() {</span>
        <span class="s3">this</span><span class="s4">.</span><span class="s2">heap </span><span class="s4">= [];</span>
        <span class="s3">this</span><span class="s4">.</span><span class="s2">pushCount </span><span class="s4">= </span><span class="s2">Number</span><span class="s4">.</span><span class="s2">MIN_SAFE_INTEGER</span><span class="s4">;</span>
    <span class="s4">}</span>

    <span class="s2">get length</span><span class="s4">() {</span>
        <span class="s3">return this</span><span class="s4">.</span><span class="s2">heap</span><span class="s4">.</span><span class="s2">length</span><span class="s4">;</span>
    <span class="s4">}</span>

    <span class="s2">empty </span><span class="s4">() {</span>
        <span class="s3">this</span><span class="s4">.</span><span class="s2">heap </span><span class="s4">= [];</span>
        <span class="s3">return this</span><span class="s4">;</span>
    <span class="s4">}</span>

    <span class="s2">percUp</span><span class="s4">(</span><span class="s2">index</span><span class="s4">) {</span>
        <span class="s3">let </span><span class="s2">p</span><span class="s4">;</span>

        <span class="s3">while </span><span class="s4">(</span><span class="s2">index </span><span class="s4">&gt; </span><span class="s7">0 </span><span class="s4">&amp;&amp; </span><span class="s2">smaller</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">heap</span><span class="s4">[</span><span class="s2">index</span><span class="s4">], </span><span class="s3">this</span><span class="s4">.</span><span class="s2">heap</span><span class="s4">[</span><span class="s2">p</span><span class="s4">=</span><span class="s2">parent</span><span class="s4">(</span><span class="s2">index</span><span class="s4">)])) {</span>
            <span class="s3">let </span><span class="s2">t </span><span class="s4">= </span><span class="s3">this</span><span class="s4">.</span><span class="s2">heap</span><span class="s4">[</span><span class="s2">index</span><span class="s4">];</span>
            <span class="s3">this</span><span class="s4">.</span><span class="s2">heap</span><span class="s4">[</span><span class="s2">index</span><span class="s4">] = </span><span class="s3">this</span><span class="s4">.</span><span class="s2">heap</span><span class="s4">[</span><span class="s2">p</span><span class="s4">];</span>
            <span class="s3">this</span><span class="s4">.</span><span class="s2">heap</span><span class="s4">[</span><span class="s2">p</span><span class="s4">] = </span><span class="s2">t</span><span class="s4">;</span>

            <span class="s2">index </span><span class="s4">= </span><span class="s2">p</span><span class="s4">;</span>
        <span class="s4">}</span>
    <span class="s4">}</span>

    <span class="s2">percDown</span><span class="s4">(</span><span class="s2">index</span><span class="s4">) {</span>
        <span class="s3">let </span><span class="s2">l</span><span class="s4">;</span>

        <span class="s3">while </span><span class="s4">((</span><span class="s2">l</span><span class="s4">=</span><span class="s2">leftChi</span><span class="s4">(</span><span class="s2">index</span><span class="s4">)) &lt; </span><span class="s3">this</span><span class="s4">.</span><span class="s2">heap</span><span class="s4">.</span><span class="s2">length</span><span class="s4">) {</span>
            <span class="s3">if </span><span class="s4">(</span><span class="s2">l</span><span class="s4">+</span><span class="s7">1 </span><span class="s4">&lt; </span><span class="s3">this</span><span class="s4">.</span><span class="s2">heap</span><span class="s4">.</span><span class="s2">length </span><span class="s4">&amp;&amp; </span><span class="s2">smaller</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">heap</span><span class="s4">[</span><span class="s2">l</span><span class="s4">+</span><span class="s7">1</span><span class="s4">], </span><span class="s3">this</span><span class="s4">.</span><span class="s2">heap</span><span class="s4">[</span><span class="s2">l</span><span class="s4">])) {</span>
                <span class="s2">l </span><span class="s4">= </span><span class="s2">l</span><span class="s4">+</span><span class="s7">1</span><span class="s4">;</span>
            <span class="s4">}</span>

            <span class="s3">if </span><span class="s4">(</span><span class="s2">smaller</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">heap</span><span class="s4">[</span><span class="s2">index</span><span class="s4">], </span><span class="s3">this</span><span class="s4">.</span><span class="s2">heap</span><span class="s4">[</span><span class="s2">l</span><span class="s4">])) {</span>
                <span class="s3">break</span><span class="s4">;</span>
            <span class="s4">}</span>

            <span class="s3">let </span><span class="s2">t </span><span class="s4">= </span><span class="s3">this</span><span class="s4">.</span><span class="s2">heap</span><span class="s4">[</span><span class="s2">index</span><span class="s4">];</span>
            <span class="s3">this</span><span class="s4">.</span><span class="s2">heap</span><span class="s4">[</span><span class="s2">index</span><span class="s4">] = </span><span class="s3">this</span><span class="s4">.</span><span class="s2">heap</span><span class="s4">[</span><span class="s2">l</span><span class="s4">];</span>
            <span class="s3">this</span><span class="s4">.</span><span class="s2">heap</span><span class="s4">[</span><span class="s2">l</span><span class="s4">] = </span><span class="s2">t</span><span class="s4">;</span>

            <span class="s2">index </span><span class="s4">= </span><span class="s2">l</span><span class="s4">;</span>
        <span class="s4">}</span>
    <span class="s4">}</span>

    <span class="s2">push</span><span class="s4">(</span><span class="s2">node</span><span class="s4">) {</span>
        <span class="s2">node</span><span class="s4">.</span><span class="s2">pushCount </span><span class="s4">= ++</span><span class="s3">this</span><span class="s4">.</span><span class="s2">pushCount</span><span class="s4">;</span>
        <span class="s3">this</span><span class="s4">.</span><span class="s2">heap</span><span class="s4">.</span><span class="s2">push</span><span class="s4">(</span><span class="s2">node</span><span class="s4">);</span>
        <span class="s3">this</span><span class="s4">.</span><span class="s2">percUp</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">heap</span><span class="s4">.</span><span class="s2">length</span><span class="s4">-</span><span class="s7">1</span><span class="s4">);</span>
    <span class="s4">}</span>

    <span class="s2">unshift</span><span class="s4">(</span><span class="s2">node</span><span class="s4">) {</span>
        <span class="s3">return this</span><span class="s4">.</span><span class="s2">heap</span><span class="s4">.</span><span class="s2">push</span><span class="s4">(</span><span class="s2">node</span><span class="s4">);</span>
    <span class="s4">}</span>

    <span class="s2">shift</span><span class="s4">() {</span>
        <span class="s3">let </span><span class="s4">[</span><span class="s2">top</span><span class="s4">] = </span><span class="s3">this</span><span class="s4">.</span><span class="s2">heap</span><span class="s4">;</span>

        <span class="s3">this</span><span class="s4">.</span><span class="s2">heap</span><span class="s4">[</span><span class="s7">0</span><span class="s4">] = </span><span class="s3">this</span><span class="s4">.</span><span class="s2">heap</span><span class="s4">[</span><span class="s3">this</span><span class="s4">.</span><span class="s2">heap</span><span class="s4">.</span><span class="s2">length</span><span class="s4">-</span><span class="s7">1</span><span class="s4">];</span>
        <span class="s3">this</span><span class="s4">.</span><span class="s2">heap</span><span class="s4">.</span><span class="s2">pop</span><span class="s4">();</span>
        <span class="s3">this</span><span class="s4">.</span><span class="s2">percDown</span><span class="s4">(</span><span class="s7">0</span><span class="s4">);</span>

        <span class="s3">return </span><span class="s2">top</span><span class="s4">;</span>
    <span class="s4">}</span>

    <span class="s2">toArray</span><span class="s4">() {</span>
        <span class="s3">return </span><span class="s4">[</span><span class="s2">...</span><span class="s3">this</span><span class="s4">];</span>
    <span class="s4">}</span>

    <span class="s4">*[</span><span class="s2">Symbol</span><span class="s4">.</span><span class="s2">iterator</span><span class="s4">] () {</span>
        <span class="s3">for </span><span class="s4">(</span><span class="s3">let </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s3">this</span><span class="s4">.</span><span class="s2">heap</span><span class="s4">.</span><span class="s2">length</span><span class="s4">; </span><span class="s2">i</span><span class="s4">++) {</span>
            <span class="s3">yield this</span><span class="s4">.</span><span class="s2">heap</span><span class="s4">[</span><span class="s2">i</span><span class="s4">].</span><span class="s2">data</span><span class="s4">;</span>
        <span class="s4">}</span>
    <span class="s4">}</span>

    <span class="s2">remove </span><span class="s4">(</span><span class="s2">testFn</span><span class="s4">) {</span>
        <span class="s3">let </span><span class="s2">j </span><span class="s4">= </span><span class="s7">0</span><span class="s4">;</span>
        <span class="s3">for </span><span class="s4">(</span><span class="s3">let </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s3">this</span><span class="s4">.</span><span class="s2">heap</span><span class="s4">.</span><span class="s2">length</span><span class="s4">; </span><span class="s2">i</span><span class="s4">++) {</span>
            <span class="s3">if </span><span class="s4">(!</span><span class="s2">testFn</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">heap</span><span class="s4">[</span><span class="s2">i</span><span class="s4">])) {</span>
                <span class="s3">this</span><span class="s4">.</span><span class="s2">heap</span><span class="s4">[</span><span class="s2">j</span><span class="s4">] = </span><span class="s3">this</span><span class="s4">.</span><span class="s2">heap</span><span class="s4">[</span><span class="s2">i</span><span class="s4">];</span>
                <span class="s2">j</span><span class="s4">++;</span>
            <span class="s4">}</span>
        <span class="s4">}</span>

        <span class="s3">this</span><span class="s4">.</span><span class="s2">heap</span><span class="s4">.</span><span class="s2">splice</span><span class="s4">(</span><span class="s2">j</span><span class="s4">);</span>

        <span class="s3">for </span><span class="s4">(</span><span class="s3">let </span><span class="s2">i </span><span class="s4">= </span><span class="s2">parent</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s2">heap</span><span class="s4">.</span><span class="s2">length</span><span class="s4">-</span><span class="s7">1</span><span class="s4">); </span><span class="s2">i </span><span class="s4">&gt;= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">i</span><span class="s4">--) {</span>
            <span class="s3">this</span><span class="s4">.</span><span class="s2">percDown</span><span class="s4">(</span><span class="s2">i</span><span class="s4">);</span>
        <span class="s4">}</span>

        <span class="s3">return this</span><span class="s4">;</span>
    <span class="s4">}</span>
<span class="s4">}</span>

<span class="s3">function </span><span class="s2">leftChi</span><span class="s4">(</span><span class="s2">i</span><span class="s4">) {</span>
    <span class="s3">return </span><span class="s4">(</span><span class="s2">i</span><span class="s4">&lt;&lt;</span><span class="s7">1</span><span class="s4">)+</span><span class="s7">1</span><span class="s4">;</span>
<span class="s4">}</span>

<span class="s3">function </span><span class="s2">parent</span><span class="s4">(</span><span class="s2">i</span><span class="s4">) {</span>
    <span class="s3">return </span><span class="s4">((</span><span class="s2">i</span><span class="s4">+</span><span class="s7">1</span><span class="s4">)&gt;&gt;</span><span class="s7">1</span><span class="s4">)-</span><span class="s7">1</span><span class="s4">;</span>
<span class="s4">}</span>

<span class="s3">function </span><span class="s2">smaller</span><span class="s4">(</span><span class="s2">x</span><span class="s4">, </span><span class="s2">y</span><span class="s4">) {</span>
    <span class="s3">if </span><span class="s4">(</span><span class="s2">x</span><span class="s4">.</span><span class="s2">priority </span><span class="s4">!== </span><span class="s2">y</span><span class="s4">.</span><span class="s2">priority</span><span class="s4">) {</span>
        <span class="s3">return </span><span class="s2">x</span><span class="s4">.</span><span class="s2">priority </span><span class="s4">&lt; </span><span class="s2">y</span><span class="s4">.</span><span class="s2">priority</span><span class="s4">;</span>
    <span class="s4">}</span>
    <span class="s3">else </span><span class="s4">{</span>
        <span class="s3">return </span><span class="s2">x</span><span class="s4">.</span><span class="s2">pushCount </span><span class="s4">&lt; </span><span class="s2">y</span><span class="s4">.</span><span class="s2">pushCount</span><span class="s4">;</span>
    <span class="s4">}</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* The same as [async.queue]{</span><span class="s1">@link </span><span class="s0">module:ControlFlow.queue} only tasks are assigned a priority and</span>
 <span class="s0">* completed in ascending priority order.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">priorityQueue</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:ControlFlow</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s0">[async.queue]{</span><span class="s1">@link </span><span class="s0">module:ControlFlow.queue}</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Control Flow</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{AsyncFunction} worker - An async function for processing a queued task.</span>
 <span class="s0">* If you want to handle errors from an individual task, pass a callback to</span>
 <span class="s0">* `q.push()`.</span>
 <span class="s0">* Invoked with (task, callback).</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{number} concurrency - An `integer` for determining how many `worker`</span>
 <span class="s0">* functions should be run in parallel.  If omitted, the concurrency defaults to</span>
 <span class="s0">* `1`.  If the concurrency is `0`, an error is thrown.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{module:ControlFlow.QueueObject} A priorityQueue object to manage the tasks. There are three</span>
 <span class="s0">* differences between `queue` and `priorityQueue` objects:</span>
 <span class="s0">* * `push(task, priority, [callback])` - `priority` should be a number. If an</span>
 <span class="s0">*   array of `tasks` is given, all tasks will be assigned the same priority.</span>
 <span class="s0">* * `pushAsync(task, priority, [callback])` - the same as `priorityQueue.push`,</span>
 <span class="s0">*   except this returns a promise that rejects if an error occurs.</span>
 <span class="s0">* * The `unshift` and `unshiftAsync` methods were removed.</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">priorityQueue</span><span class="s4">(</span><span class="s2">worker</span><span class="s4">, </span><span class="s2">concurrency</span><span class="s4">) {</span>
    <span class="s5">// Start with a normal queue</span>
    <span class="s3">var </span><span class="s2">q </span><span class="s4">= </span><span class="s2">queue</span><span class="s4">(</span><span class="s2">worker</span><span class="s4">, </span><span class="s2">concurrency</span><span class="s4">);</span>

    <span class="s3">var </span><span class="s4">{</span>
        <span class="s2">push</span><span class="s4">,</span>
        <span class="s2">pushAsync</span>
    <span class="s4">} = </span><span class="s2">q</span><span class="s4">;</span>

    <span class="s2">q</span><span class="s4">.</span><span class="s2">_tasks </span><span class="s4">= </span><span class="s3">new </span><span class="s2">Heap</span><span class="s4">();</span>
    <span class="s2">q</span><span class="s4">.</span><span class="s2">_createTaskItem </span><span class="s4">= ({</span><span class="s2">data</span><span class="s4">, </span><span class="s2">priority</span><span class="s4">}, </span><span class="s2">callback</span><span class="s4">) =&gt; {</span>
        <span class="s3">return </span><span class="s4">{</span>
            <span class="s2">data</span><span class="s4">,</span>
            <span class="s2">priority</span><span class="s4">,</span>
            <span class="s2">callback</span>
        <span class="s4">};</span>
    <span class="s4">};</span>

    <span class="s3">function </span><span class="s2">createDataItems</span><span class="s4">(</span><span class="s2">tasks</span><span class="s4">, </span><span class="s2">priority</span><span class="s4">) {</span>
        <span class="s3">if </span><span class="s4">(!</span><span class="s2">Array</span><span class="s4">.</span><span class="s2">isArray</span><span class="s4">(</span><span class="s2">tasks</span><span class="s4">)) {</span>
            <span class="s3">return </span><span class="s4">{</span><span class="s2">data</span><span class="s4">: </span><span class="s2">tasks</span><span class="s4">, </span><span class="s2">priority</span><span class="s4">};</span>
        <span class="s4">}</span>
        <span class="s3">return </span><span class="s2">tasks</span><span class="s4">.</span><span class="s2">map</span><span class="s4">(</span><span class="s2">data </span><span class="s4">=&gt; { </span><span class="s3">return </span><span class="s4">{</span><span class="s2">data</span><span class="s4">, </span><span class="s2">priority</span><span class="s4">}; });</span>
    <span class="s4">}</span>

    <span class="s5">// Override push to accept second parameter representing priority</span>
    <span class="s2">q</span><span class="s4">.</span><span class="s2">push </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">data</span><span class="s4">, </span><span class="s2">priority </span><span class="s4">= </span><span class="s7">0</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
        <span class="s3">return </span><span class="s2">push</span><span class="s4">(</span><span class="s2">createDataItems</span><span class="s4">(</span><span class="s2">data</span><span class="s4">, </span><span class="s2">priority</span><span class="s4">), </span><span class="s2">callback</span><span class="s4">);</span>
    <span class="s4">};</span>

    <span class="s2">q</span><span class="s4">.</span><span class="s2">pushAsync </span><span class="s4">= </span><span class="s3">function</span><span class="s4">(</span><span class="s2">data</span><span class="s4">, </span><span class="s2">priority </span><span class="s4">= </span><span class="s7">0</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
        <span class="s3">return </span><span class="s2">pushAsync</span><span class="s4">(</span><span class="s2">createDataItems</span><span class="s4">(</span><span class="s2">data</span><span class="s4">, </span><span class="s2">priority</span><span class="s4">), </span><span class="s2">callback</span><span class="s4">);</span>
    <span class="s4">};</span>

    <span class="s5">// Remove unshift functions</span>
    <span class="s3">delete </span><span class="s2">q</span><span class="s4">.</span><span class="s2">unshift</span><span class="s4">;</span>
    <span class="s3">delete </span><span class="s2">q</span><span class="s4">.</span><span class="s2">unshiftAsync</span><span class="s4">;</span>

    <span class="s3">return </span><span class="s2">q</span><span class="s4">;</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Runs the `tasks` array of functions in parallel, without waiting until the</span>
 <span class="s0">* previous function has completed. Once any of the `tasks` complete or pass an</span>
 <span class="s0">* error to its callback, the main `callback` is immediately called. It's</span>
 <span class="s0">* equivalent to `Promise.race()`.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">race</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:ControlFlow</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Control Flow</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Array} tasks - An array containing [async functions]{</span><span class="s1">@link </span><span class="s0">AsyncFunction}</span>
 <span class="s0">* to run. Each function can complete with an optional `result` value.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} callback - A callback to run once any of the functions have</span>
 <span class="s0">* completed. This function gets an error or result from the first function that</span>
 <span class="s0">* completed. Invoked with (err, result).</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise} a promise, if a callback is omitted</span>
 <span class="s0">* </span><span class="s1">@example</span>
 <span class="s0">*</span>
 <span class="s0">* async.race([</span>
 <span class="s0">*     function(callback) {</span>
 <span class="s0">*         setTimeout(function() {</span>
 <span class="s0">*             callback(null, 'one');</span>
 <span class="s0">*         }, 200);</span>
 <span class="s0">*     },</span>
 <span class="s0">*     function(callback) {</span>
 <span class="s0">*         setTimeout(function() {</span>
 <span class="s0">*             callback(null, 'two');</span>
 <span class="s0">*         }, 100);</span>
 <span class="s0">*     }</span>
 <span class="s0">* ],</span>
 <span class="s0">* // main callback</span>
 <span class="s0">* function(err, result) {</span>
 <span class="s0">*     // the result will be equal to 'two' as it finishes earlier</span>
 <span class="s0">* });</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">race</span><span class="s4">(</span><span class="s2">tasks</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
    <span class="s2">callback </span><span class="s4">= </span><span class="s2">once</span><span class="s4">(</span><span class="s2">callback</span><span class="s4">);</span>
    <span class="s3">if </span><span class="s4">(!</span><span class="s2">Array</span><span class="s4">.</span><span class="s2">isArray</span><span class="s4">(</span><span class="s2">tasks</span><span class="s4">)) </span><span class="s3">return </span><span class="s2">callback</span><span class="s4">(</span><span class="s3">new </span><span class="s2">TypeError</span><span class="s4">(</span><span class="s6">'First argument to race must be an array of functions'</span><span class="s4">));</span>
    <span class="s3">if </span><span class="s4">(!</span><span class="s2">tasks</span><span class="s4">.</span><span class="s2">length</span><span class="s4">) </span><span class="s3">return </span><span class="s2">callback</span><span class="s4">();</span>
    <span class="s3">for </span><span class="s4">(</span><span class="s3">var </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">, </span><span class="s2">l </span><span class="s4">= </span><span class="s2">tasks</span><span class="s4">.</span><span class="s2">length</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s2">l</span><span class="s4">; </span><span class="s2">i</span><span class="s4">++) {</span>
        <span class="s2">wrapAsync</span><span class="s4">(</span><span class="s2">tasks</span><span class="s4">[</span><span class="s2">i</span><span class="s4">])(</span><span class="s2">callback</span><span class="s4">);</span>
    <span class="s4">}</span>
<span class="s4">}</span>

<span class="s3">var </span><span class="s2">race$1 </span><span class="s4">= </span><span class="s2">awaitify</span><span class="s4">(</span><span class="s2">race</span><span class="s4">, </span><span class="s7">2</span><span class="s4">);</span>

<span class="s0">/**</span>
 <span class="s0">* Same as [`reduce`]{</span><span class="s1">@link </span><span class="s0">module:Collections.reduce}, only operates on `array` in reverse order.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">reduceRight</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s0">[async.reduce]{</span><span class="s1">@link </span><span class="s0">module:Collections.reduce}</span>
 <span class="s0">* </span><span class="s1">@alias </span><span class="s0">foldr</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collection</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Array} array - A collection to iterate over.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{*} memo - The initial state of the reduction.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{AsyncFunction} iteratee - A function applied to each item in the</span>
 <span class="s0">* array to produce the next step in the reduction.</span>
 <span class="s0">* The `iteratee` should complete with the next state of the reduction.</span>
 <span class="s0">* If the iteratee completes with an error, the reduction is stopped and the</span>
 <span class="s0">* main `callback` is immediately called with the error.</span>
 <span class="s0">* Invoked with (memo, item, callback).</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} [callback] - A callback which is called after all the</span>
 <span class="s0">* `iteratee` functions have finished. Result is the reduced value. Invoked with</span>
 <span class="s0">* (err, result).</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise} a promise, if no callback is passed</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">reduceRight </span><span class="s4">(</span><span class="s2">array</span><span class="s4">, </span><span class="s2">memo</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
    <span class="s3">var </span><span class="s2">reversed </span><span class="s4">= [</span><span class="s2">...array</span><span class="s4">].</span><span class="s2">reverse</span><span class="s4">();</span>
    <span class="s3">return </span><span class="s2">reduce$1</span><span class="s4">(</span><span class="s2">reversed</span><span class="s4">, </span><span class="s2">memo</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">);</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Wraps the async function in another function that always completes with a</span>
 <span class="s0">* result object, even when it errors.</span>
 <span class="s0">*</span>
 <span class="s0">* The result object has either the property `error` or `value`.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">reflect</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Utils</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Util</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{AsyncFunction} fn - The async function you want to wrap</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Function} - A function that always passes null to it's callback as</span>
 <span class="s0">* the error. The second argument to the callback will be an `object` with</span>
 <span class="s0">* either an `error` or a `value` property.</span>
 <span class="s0">* </span><span class="s1">@example</span>
 <span class="s0">*</span>
 <span class="s0">* async.parallel([</span>
 <span class="s0">*     async.reflect(function(callback) {</span>
 <span class="s0">*         // do some stuff ...</span>
 <span class="s0">*         callback(null, 'one');</span>
 <span class="s0">*     }),</span>
 <span class="s0">*     async.reflect(function(callback) {</span>
 <span class="s0">*         // do some more stuff but error ...</span>
 <span class="s0">*         callback('bad stuff happened');</span>
 <span class="s0">*     }),</span>
 <span class="s0">*     async.reflect(function(callback) {</span>
 <span class="s0">*         // do some more stuff ...</span>
 <span class="s0">*         callback(null, 'two');</span>
 <span class="s0">*     })</span>
 <span class="s0">* ],</span>
 <span class="s0">* // optional callback</span>
 <span class="s0">* function(err, results) {</span>
 <span class="s0">*     // values</span>
 <span class="s0">*     // results[0].value = 'one'</span>
 <span class="s0">*     // results[1].error = 'bad stuff happened'</span>
 <span class="s0">*     // results[2].value = 'two'</span>
 <span class="s0">* });</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">reflect</span><span class="s4">(</span><span class="s2">fn</span><span class="s4">) {</span>
    <span class="s3">var </span><span class="s2">_fn </span><span class="s4">= </span><span class="s2">wrapAsync</span><span class="s4">(</span><span class="s2">fn</span><span class="s4">);</span>
    <span class="s3">return </span><span class="s2">initialParams</span><span class="s4">(</span><span class="s3">function </span><span class="s2">reflectOn</span><span class="s4">(</span><span class="s2">args</span><span class="s4">, </span><span class="s2">reflectCallback</span><span class="s4">) {</span>
        <span class="s2">args</span><span class="s4">.</span><span class="s2">push</span><span class="s4">((</span><span class="s2">error</span><span class="s4">, </span><span class="s2">...cbArgs</span><span class="s4">) =&gt; {</span>
            <span class="s3">let </span><span class="s2">retVal </span><span class="s4">= {};</span>
            <span class="s3">if </span><span class="s4">(</span><span class="s2">error</span><span class="s4">) {</span>
                <span class="s2">retVal</span><span class="s4">.</span><span class="s2">error </span><span class="s4">= </span><span class="s2">error</span><span class="s4">;</span>
            <span class="s4">}</span>
            <span class="s3">if </span><span class="s4">(</span><span class="s2">cbArgs</span><span class="s4">.</span><span class="s2">length </span><span class="s4">&gt; </span><span class="s7">0</span><span class="s4">){</span>
                <span class="s3">var </span><span class="s2">value </span><span class="s4">= </span><span class="s2">cbArgs</span><span class="s4">;</span>
                <span class="s3">if </span><span class="s4">(</span><span class="s2">cbArgs</span><span class="s4">.</span><span class="s2">length </span><span class="s4">&lt;= </span><span class="s7">1</span><span class="s4">) {</span>
                    <span class="s4">[</span><span class="s2">value</span><span class="s4">] = </span><span class="s2">cbArgs</span><span class="s4">;</span>
                <span class="s4">}</span>
                <span class="s2">retVal</span><span class="s4">.</span><span class="s2">value </span><span class="s4">= </span><span class="s2">value</span><span class="s4">;</span>
            <span class="s4">}</span>
            <span class="s2">reflectCallback</span><span class="s4">(</span><span class="s3">null</span><span class="s4">, </span><span class="s2">retVal</span><span class="s4">);</span>
        <span class="s4">});</span>

        <span class="s3">return </span><span class="s2">_fn</span><span class="s4">.</span><span class="s2">apply</span><span class="s4">(</span><span class="s3">this</span><span class="s4">, </span><span class="s2">args</span><span class="s4">);</span>
    <span class="s4">});</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* A helper function that wraps an array or an object of functions with `reflect`.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">reflectAll</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Utils</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s0">[async.reflect]{</span><span class="s1">@link </span><span class="s0">module:Utils.reflect}</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Util</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Array|Object|Iterable} tasks - The collection of</span>
 <span class="s0">* [async functions]{</span><span class="s1">@link </span><span class="s0">AsyncFunction} to wrap in `async.reflect`.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Array} Returns an array of async functions, each wrapped in</span>
 <span class="s0">* `async.reflect`</span>
 <span class="s0">* </span><span class="s1">@example</span>
 <span class="s0">*</span>
 <span class="s0">* let tasks = [</span>
 <span class="s0">*     function(callback) {</span>
 <span class="s0">*         setTimeout(function() {</span>
 <span class="s0">*             callback(null, 'one');</span>
 <span class="s0">*         }, 200);</span>
 <span class="s0">*     },</span>
 <span class="s0">*     function(callback) {</span>
 <span class="s0">*         // do some more stuff but error ...</span>
 <span class="s0">*         callback(new Error('bad stuff happened'));</span>
 <span class="s0">*     },</span>
 <span class="s0">*     function(callback) {</span>
 <span class="s0">*         setTimeout(function() {</span>
 <span class="s0">*             callback(null, 'two');</span>
 <span class="s0">*         }, 100);</span>
 <span class="s0">*     }</span>
 <span class="s0">* ];</span>
 <span class="s0">*</span>
 <span class="s0">* async.parallel(async.reflectAll(tasks),</span>
 <span class="s0">* // optional callback</span>
 <span class="s0">* function(err, results) {</span>
 <span class="s0">*     // values</span>
 <span class="s0">*     // results[0].value = 'one'</span>
 <span class="s0">*     // results[1].error = Error('bad stuff happened')</span>
 <span class="s0">*     // results[2].value = 'two'</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* // an example using an object instead of an array</span>
 <span class="s0">* let tasks = {</span>
 <span class="s0">*     one: function(callback) {</span>
 <span class="s0">*         setTimeout(function() {</span>
 <span class="s0">*             callback(null, 'one');</span>
 <span class="s0">*         }, 200);</span>
 <span class="s0">*     },</span>
 <span class="s0">*     two: function(callback) {</span>
 <span class="s0">*         callback('two');</span>
 <span class="s0">*     },</span>
 <span class="s0">*     three: function(callback) {</span>
 <span class="s0">*         setTimeout(function() {</span>
 <span class="s0">*             callback(null, 'three');</span>
 <span class="s0">*         }, 100);</span>
 <span class="s0">*     }</span>
 <span class="s0">* };</span>
 <span class="s0">*</span>
 <span class="s0">* async.parallel(async.reflectAll(tasks),</span>
 <span class="s0">* // optional callback</span>
 <span class="s0">* function(err, results) {</span>
 <span class="s0">*     // values</span>
 <span class="s0">*     // results.one.value = 'one'</span>
 <span class="s0">*     // results.two.error = 'two'</span>
 <span class="s0">*     // results.three.value = 'three'</span>
 <span class="s0">* });</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">reflectAll</span><span class="s4">(</span><span class="s2">tasks</span><span class="s4">) {</span>
    <span class="s3">var </span><span class="s2">results</span><span class="s4">;</span>
    <span class="s3">if </span><span class="s4">(</span><span class="s2">Array</span><span class="s4">.</span><span class="s2">isArray</span><span class="s4">(</span><span class="s2">tasks</span><span class="s4">)) {</span>
        <span class="s2">results </span><span class="s4">= </span><span class="s2">tasks</span><span class="s4">.</span><span class="s2">map</span><span class="s4">(</span><span class="s2">reflect</span><span class="s4">);</span>
    <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
        <span class="s2">results </span><span class="s4">= {};</span>
        <span class="s2">Object</span><span class="s4">.</span><span class="s2">keys</span><span class="s4">(</span><span class="s2">tasks</span><span class="s4">).</span><span class="s2">forEach</span><span class="s4">(</span><span class="s2">key </span><span class="s4">=&gt; {</span>
            <span class="s2">results</span><span class="s4">[</span><span class="s2">key</span><span class="s4">] = </span><span class="s2">reflect</span><span class="s4">.</span><span class="s2">call</span><span class="s4">(</span><span class="s3">this</span><span class="s4">, </span><span class="s2">tasks</span><span class="s4">[</span><span class="s2">key</span><span class="s4">]);</span>
        <span class="s4">});</span>
    <span class="s4">}</span>
    <span class="s3">return </span><span class="s2">results</span><span class="s4">;</span>
<span class="s4">}</span>

<span class="s3">function </span><span class="s2">reject$2</span><span class="s4">(</span><span class="s2">eachfn</span><span class="s4">, </span><span class="s2">arr</span><span class="s4">, </span><span class="s2">_iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
    <span class="s3">const </span><span class="s2">iteratee </span><span class="s4">= </span><span class="s2">wrapAsync</span><span class="s4">(</span><span class="s2">_iteratee</span><span class="s4">);</span>
    <span class="s3">return </span><span class="s2">_filter</span><span class="s4">(</span><span class="s2">eachfn</span><span class="s4">, </span><span class="s2">arr</span><span class="s4">, (</span><span class="s2">value</span><span class="s4">, </span><span class="s2">cb</span><span class="s4">) =&gt; {</span>
        <span class="s2">iteratee</span><span class="s4">(</span><span class="s2">value</span><span class="s4">, (</span><span class="s2">err</span><span class="s4">, </span><span class="s2">v</span><span class="s4">) =&gt; {</span>
            <span class="s2">cb</span><span class="s4">(</span><span class="s2">err</span><span class="s4">, !</span><span class="s2">v</span><span class="s4">);</span>
        <span class="s4">});</span>
    <span class="s4">}, </span><span class="s2">callback</span><span class="s4">);</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* The opposite of [`filter`]{</span><span class="s1">@link </span><span class="s0">module:Collections.filter}. Removes values that pass an `async` truth test.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">reject</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s0">[async.filter]{</span><span class="s1">@link </span><span class="s0">module:Collections.filter}</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collection</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} iteratee - An async truth test to apply to each item in</span>
 <span class="s0">* `coll`.</span>
 <span class="s0">* The should complete with a boolean value as its `result`.</span>
 <span class="s0">* Invoked with (item, callback).</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} [callback] - A callback which is called after all the</span>
 <span class="s0">* `iteratee` functions have finished. Invoked with (err, results).</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise} a promise, if no callback is passed</span>
 <span class="s0">* </span><span class="s1">@example</span>
 <span class="s0">*</span>
 <span class="s0">* // dir1 is a directory that contains file1.txt, file2.txt</span>
 <span class="s0">* // dir2 is a directory that contains file3.txt, file4.txt</span>
 <span class="s0">* // dir3 is a directory that contains file5.txt</span>
 <span class="s0">*</span>
 <span class="s0">* const fileList = ['dir1/file1.txt','dir2/file3.txt','dir3/file6.txt'];</span>
 <span class="s0">*</span>
 <span class="s0">* // asynchronous function that checks if a file exists</span>
 <span class="s0">* function fileExists(file, callback) {</span>
 <span class="s0">*    fs.access(file, fs.constants.F_OK, (err) =&gt; {</span>
 <span class="s0">*        callback(null, !err);</span>
 <span class="s0">*    });</span>
 <span class="s0">* }</span>
 <span class="s0">*</span>
 <span class="s0">* // Using callbacks</span>
 <span class="s0">* async.reject(fileList, fileExists, function(err, results) {</span>
 <span class="s0">*    // [ 'dir3/file6.txt' ]</span>
 <span class="s0">*    // results now equals an array of the non-existing files</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* // Using Promises</span>
 <span class="s0">* async.reject(fileList, fileExists)</span>
 <span class="s0">* .then( results =&gt; {</span>
 <span class="s0">*     console.log(results);</span>
 <span class="s0">*     // [ 'dir3/file6.txt' ]</span>
 <span class="s0">*     // results now equals an array of the non-existing files</span>
 <span class="s0">* }).catch( err =&gt; {</span>
 <span class="s0">*     console.log(err);</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* // Using async/await</span>
 <span class="s0">* async () =&gt; {</span>
 <span class="s0">*     try {</span>
 <span class="s0">*         let results = await async.reject(fileList, fileExists);</span>
 <span class="s0">*         console.log(results);</span>
 <span class="s0">*         // [ 'dir3/file6.txt' ]</span>
 <span class="s0">*         // results now equals an array of the non-existing files</span>
 <span class="s0">*     }</span>
 <span class="s0">*     catch (err) {</span>
 <span class="s0">*         console.log(err);</span>
 <span class="s0">*     }</span>
 <span class="s0">* }</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">reject </span><span class="s4">(</span><span class="s2">coll</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
    <span class="s3">return </span><span class="s2">reject$2</span><span class="s4">(</span><span class="s2">eachOf$1</span><span class="s4">, </span><span class="s2">coll</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">)</span>
<span class="s4">}</span>
<span class="s3">var </span><span class="s2">reject$1 </span><span class="s4">= </span><span class="s2">awaitify</span><span class="s4">(</span><span class="s2">reject</span><span class="s4">, </span><span class="s7">3</span><span class="s4">);</span>

<span class="s0">/**</span>
 <span class="s0">* The same as [`reject`]{</span><span class="s1">@link </span><span class="s0">module:Collections.reject} but runs a maximum of `limit` async operations at a</span>
 <span class="s0">* time.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">rejectLimit</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s0">[async.reject]{</span><span class="s1">@link </span><span class="s0">module:Collections.reject}</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collection</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{number} limit - The maximum number of async operations at a time.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} iteratee - An async truth test to apply to each item in</span>
 <span class="s0">* `coll`.</span>
 <span class="s0">* The should complete with a boolean value as its `result`.</span>
 <span class="s0">* Invoked with (item, callback).</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} [callback] - A callback which is called after all the</span>
 <span class="s0">* `iteratee` functions have finished. Invoked with (err, results).</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise} a promise, if no callback is passed</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">rejectLimit </span><span class="s4">(</span><span class="s2">coll</span><span class="s4">, </span><span class="s2">limit</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
    <span class="s3">return </span><span class="s2">reject$2</span><span class="s4">(</span><span class="s2">eachOfLimit$2</span><span class="s4">(</span><span class="s2">limit</span><span class="s4">), </span><span class="s2">coll</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">)</span>
<span class="s4">}</span>
<span class="s3">var </span><span class="s2">rejectLimit$1 </span><span class="s4">= </span><span class="s2">awaitify</span><span class="s4">(</span><span class="s2">rejectLimit</span><span class="s4">, </span><span class="s7">4</span><span class="s4">);</span>

<span class="s0">/**</span>
 <span class="s0">* The same as [`reject`]{</span><span class="s1">@link </span><span class="s0">module:Collections.reject} but runs only a single async operation at a time.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">rejectSeries</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s0">[async.reject]{</span><span class="s1">@link </span><span class="s0">module:Collections.reject}</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collection</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} iteratee - An async truth test to apply to each item in</span>
 <span class="s0">* `coll`.</span>
 <span class="s0">* The should complete with a boolean value as its `result`.</span>
 <span class="s0">* Invoked with (item, callback).</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} [callback] - A callback which is called after all the</span>
 <span class="s0">* `iteratee` functions have finished. Invoked with (err, results).</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise} a promise, if no callback is passed</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">rejectSeries </span><span class="s4">(</span><span class="s2">coll</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
    <span class="s3">return </span><span class="s2">reject$2</span><span class="s4">(</span><span class="s2">eachOfSeries$1</span><span class="s4">, </span><span class="s2">coll</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">)</span>
<span class="s4">}</span>
<span class="s3">var </span><span class="s2">rejectSeries$1 </span><span class="s4">= </span><span class="s2">awaitify</span><span class="s4">(</span><span class="s2">rejectSeries</span><span class="s4">, </span><span class="s7">3</span><span class="s4">);</span>

<span class="s3">function </span><span class="s2">constant</span><span class="s4">(</span><span class="s2">value</span><span class="s4">) {</span>
    <span class="s3">return function </span><span class="s4">() {</span>
        <span class="s3">return </span><span class="s2">value</span><span class="s4">;</span>
    <span class="s4">}</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Attempts to get a successful response from `task` no more than `times` times</span>
 <span class="s0">* before returning an error. If the task is successful, the `callback` will be</span>
 <span class="s0">* passed the result of the successful task. If all attempts fail, the callback</span>
 <span class="s0">* will be passed the error and result (if any) of the final attempt.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">retry</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:ControlFlow</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Control Flow</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s0">[async.retryable]{</span><span class="s1">@link </span><span class="s0">module:ControlFlow.retryable}</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Object|number} [opts = {times: 5, interval: 0}| 5] - Can be either an</span>
 <span class="s0">* object with `times` and `interval` or a number.</span>
 <span class="s0">* * `times` - The number of attempts to make before giving up.  The default</span>
 <span class="s0">*   is `5`.</span>
 <span class="s0">* * `interval` - The time to wait between retries, in milliseconds.  The</span>
 <span class="s0">*   default is `0`. The interval may also be specified as a function of the</span>
 <span class="s0">*   retry count (see example).</span>
 <span class="s0">* * `errorFilter` - An optional synchronous function that is invoked on</span>
 <span class="s0">*   erroneous result. If it returns `true` the retry attempts will continue;</span>
 <span class="s0">*   if the function returns `false` the retry flow is aborted with the current</span>
 <span class="s0">*   attempt's error and result being returned to the final callback.</span>
 <span class="s0">*   Invoked with (err).</span>
 <span class="s0">* * If `opts` is a number, the number specifies the number of times to retry,</span>
 <span class="s0">*   with the default interval of `0`.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{AsyncFunction} task - An async function to retry.</span>
 <span class="s0">* Invoked with (callback).</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} [callback] - An optional callback which is called when the</span>
 <span class="s0">* task has succeeded, or after the final failed attempt. It receives the `err`</span>
 <span class="s0">* and `result` arguments of the last attempt at completing the `task`. Invoked</span>
 <span class="s0">* with (err, results).</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise} a promise if no callback provided</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@example</span>
 <span class="s0">*</span>
 <span class="s0">* // The `retry` function can be used as a stand-alone control flow by passing</span>
 <span class="s0">* // a callback, as shown below:</span>
 <span class="s0">*</span>
 <span class="s0">* // try calling apiMethod 3 times</span>
 <span class="s0">* async.retry(3, apiMethod, function(err, result) {</span>
 <span class="s0">*     // do something with the result</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* // try calling apiMethod 3 times, waiting 200 ms between each retry</span>
 <span class="s0">* async.retry({times: 3, interval: 200}, apiMethod, function(err, result) {</span>
 <span class="s0">*     // do something with the result</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* // try calling apiMethod 10 times with exponential backoff</span>
 <span class="s0">* // (i.e. intervals of 100, 200, 400, 800, 1600, ... milliseconds)</span>
 <span class="s0">* async.retry({</span>
 <span class="s0">*   times: 10,</span>
 <span class="s0">*   interval: function(retryCount) {</span>
 <span class="s0">*     return 50 * Math.pow(2, retryCount);</span>
 <span class="s0">*   }</span>
 <span class="s0">* }, apiMethod, function(err, result) {</span>
 <span class="s0">*     // do something with the result</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* // try calling apiMethod the default 5 times no delay between each retry</span>
 <span class="s0">* async.retry(apiMethod, function(err, result) {</span>
 <span class="s0">*     // do something with the result</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* // try calling apiMethod only when error condition satisfies, all other</span>
 <span class="s0">* // errors will abort the retry control flow and return to final callback</span>
 <span class="s0">* async.retry({</span>
 <span class="s0">*   errorFilter: function(err) {</span>
 <span class="s0">*     return err.message === 'Temporary error'; // only retry on a specific error</span>
 <span class="s0">*   }</span>
 <span class="s0">* }, apiMethod, function(err, result) {</span>
 <span class="s0">*     // do something with the result</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* // to retry individual methods that are not as reliable within other</span>
 <span class="s0">* // control flow functions, use the `retryable` wrapper:</span>
 <span class="s0">* async.auto({</span>
 <span class="s0">*     users: api.getUsers.bind(api),</span>
 <span class="s0">*     payments: async.retryable(3, api.getPayments.bind(api))</span>
 <span class="s0">* }, function(err, results) {</span>
 <span class="s0">*     // do something with the results</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s3">const </span><span class="s2">DEFAULT_TIMES </span><span class="s4">= </span><span class="s7">5</span><span class="s4">;</span>
<span class="s3">const </span><span class="s2">DEFAULT_INTERVAL </span><span class="s4">= </span><span class="s7">0</span><span class="s4">;</span>

<span class="s3">function </span><span class="s2">retry</span><span class="s4">(</span><span class="s2">opts</span><span class="s4">, </span><span class="s2">task</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
    <span class="s3">var </span><span class="s2">options </span><span class="s4">= {</span>
        <span class="s2">times</span><span class="s4">: </span><span class="s2">DEFAULT_TIMES</span><span class="s4">,</span>
        <span class="s2">intervalFunc</span><span class="s4">: </span><span class="s2">constant</span><span class="s4">(</span><span class="s2">DEFAULT_INTERVAL</span><span class="s4">)</span>
    <span class="s4">};</span>

    <span class="s3">if </span><span class="s4">(</span><span class="s2">arguments</span><span class="s4">.</span><span class="s2">length </span><span class="s4">&lt; </span><span class="s7">3 </span><span class="s4">&amp;&amp; </span><span class="s3">typeof </span><span class="s2">opts </span><span class="s4">=== </span><span class="s6">'function'</span><span class="s4">) {</span>
        <span class="s2">callback </span><span class="s4">= </span><span class="s2">task </span><span class="s4">|| </span><span class="s2">promiseCallback</span><span class="s4">();</span>
        <span class="s2">task </span><span class="s4">= </span><span class="s2">opts</span><span class="s4">;</span>
    <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
        <span class="s2">parseTimes</span><span class="s4">(</span><span class="s2">options</span><span class="s4">, </span><span class="s2">opts</span><span class="s4">);</span>
        <span class="s2">callback </span><span class="s4">= </span><span class="s2">callback </span><span class="s4">|| </span><span class="s2">promiseCallback</span><span class="s4">();</span>
    <span class="s4">}</span>

    <span class="s3">if </span><span class="s4">(</span><span class="s3">typeof </span><span class="s2">task </span><span class="s4">!== </span><span class="s6">'function'</span><span class="s4">) {</span>
        <span class="s3">throw new </span><span class="s2">Error</span><span class="s4">(</span><span class="s6">&quot;Invalid arguments for async.retry&quot;</span><span class="s4">);</span>
    <span class="s4">}</span>

    <span class="s3">var </span><span class="s2">_task </span><span class="s4">= </span><span class="s2">wrapAsync</span><span class="s4">(</span><span class="s2">task</span><span class="s4">);</span>

    <span class="s3">var </span><span class="s2">attempt </span><span class="s4">= </span><span class="s7">1</span><span class="s4">;</span>
    <span class="s3">function </span><span class="s2">retryAttempt</span><span class="s4">() {</span>
        <span class="s2">_task</span><span class="s4">((</span><span class="s2">err</span><span class="s4">, </span><span class="s2">...args</span><span class="s4">) =&gt; {</span>
            <span class="s3">if </span><span class="s4">(</span><span class="s2">err </span><span class="s4">=== </span><span class="s3">false</span><span class="s4">) </span><span class="s3">return</span>
            <span class="s3">if </span><span class="s4">(</span><span class="s2">err </span><span class="s4">&amp;&amp; </span><span class="s2">attempt</span><span class="s4">++ &lt; </span><span class="s2">options</span><span class="s4">.</span><span class="s2">times </span><span class="s4">&amp;&amp;</span>
                <span class="s4">(</span><span class="s3">typeof </span><span class="s2">options</span><span class="s4">.</span><span class="s2">errorFilter </span><span class="s4">!= </span><span class="s6">'function' </span><span class="s4">||</span>
                    <span class="s2">options</span><span class="s4">.</span><span class="s2">errorFilter</span><span class="s4">(</span><span class="s2">err</span><span class="s4">))) {</span>
                <span class="s2">setTimeout</span><span class="s4">(</span><span class="s2">retryAttempt</span><span class="s4">, </span><span class="s2">options</span><span class="s4">.</span><span class="s2">intervalFunc</span><span class="s4">(</span><span class="s2">attempt </span><span class="s4">- </span><span class="s7">1</span><span class="s4">));</span>
            <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
                <span class="s2">callback</span><span class="s4">(</span><span class="s2">err</span><span class="s4">, </span><span class="s2">...args</span><span class="s4">);</span>
            <span class="s4">}</span>
        <span class="s4">});</span>
    <span class="s4">}</span>

    <span class="s2">retryAttempt</span><span class="s4">();</span>
    <span class="s3">return </span><span class="s2">callback</span><span class="s4">[</span><span class="s2">PROMISE_SYMBOL</span><span class="s4">]</span>
<span class="s4">}</span>

<span class="s3">function </span><span class="s2">parseTimes</span><span class="s4">(</span><span class="s2">acc</span><span class="s4">, </span><span class="s2">t</span><span class="s4">) {</span>
    <span class="s3">if </span><span class="s4">(</span><span class="s3">typeof </span><span class="s2">t </span><span class="s4">=== </span><span class="s6">'object'</span><span class="s4">) {</span>
        <span class="s2">acc</span><span class="s4">.</span><span class="s2">times </span><span class="s4">= +</span><span class="s2">t</span><span class="s4">.</span><span class="s2">times </span><span class="s4">|| </span><span class="s2">DEFAULT_TIMES</span><span class="s4">;</span>

        <span class="s2">acc</span><span class="s4">.</span><span class="s2">intervalFunc </span><span class="s4">= </span><span class="s3">typeof </span><span class="s2">t</span><span class="s4">.</span><span class="s2">interval </span><span class="s4">=== </span><span class="s6">'function' </span><span class="s4">?</span>
            <span class="s2">t</span><span class="s4">.</span><span class="s2">interval </span><span class="s4">:</span>
            <span class="s2">constant</span><span class="s4">(+</span><span class="s2">t</span><span class="s4">.</span><span class="s2">interval </span><span class="s4">|| </span><span class="s2">DEFAULT_INTERVAL</span><span class="s4">);</span>

        <span class="s2">acc</span><span class="s4">.</span><span class="s2">errorFilter </span><span class="s4">= </span><span class="s2">t</span><span class="s4">.</span><span class="s2">errorFilter</span><span class="s4">;</span>
    <span class="s4">} </span><span class="s3">else if </span><span class="s4">(</span><span class="s3">typeof </span><span class="s2">t </span><span class="s4">=== </span><span class="s6">'number' </span><span class="s4">|| </span><span class="s3">typeof </span><span class="s2">t </span><span class="s4">=== </span><span class="s6">'string'</span><span class="s4">) {</span>
        <span class="s2">acc</span><span class="s4">.</span><span class="s2">times </span><span class="s4">= +</span><span class="s2">t </span><span class="s4">|| </span><span class="s2">DEFAULT_TIMES</span><span class="s4">;</span>
    <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
        <span class="s3">throw new </span><span class="s2">Error</span><span class="s4">(</span><span class="s6">&quot;Invalid arguments for async.retry&quot;</span><span class="s4">);</span>
    <span class="s4">}</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* A close relative of [`retry`]{</span><span class="s1">@link </span><span class="s0">module:ControlFlow.retry}.  This method</span>
 <span class="s0">* wraps a task and makes it retryable, rather than immediately calling it</span>
 <span class="s0">* with retries.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">retryable</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:ControlFlow</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s0">[async.retry]{</span><span class="s1">@link </span><span class="s0">module:ControlFlow.retry}</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Control Flow</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Object|number} [opts = {times: 5, interval: 0}| 5] - optional</span>
 <span class="s0">* options, exactly the same as from `retry`, except for a `opts.arity` that</span>
 <span class="s0">* is the arity of the `task` function, defaulting to `task.length`</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{AsyncFunction} task - the asynchronous function to wrap.</span>
 <span class="s0">* This function will be passed any arguments passed to the returned wrapper.</span>
 <span class="s0">* Invoked with (...args, callback).</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{AsyncFunction} The wrapped function, which when invoked, will</span>
 <span class="s0">* retry on an error, based on the parameters specified in `opts`.</span>
 <span class="s0">* This function will accept the same parameters as `task`.</span>
 <span class="s0">* </span><span class="s1">@example</span>
 <span class="s0">*</span>
 <span class="s0">* async.auto({</span>
 <span class="s0">*     dep1: async.retryable(3, getFromFlakyService),</span>
 <span class="s0">*     process: [&quot;dep1&quot;, async.retryable(3, function (results, cb) {</span>
 <span class="s0">*         maybeProcessData(results.dep1, cb);</span>
 <span class="s0">*     })]</span>
 <span class="s0">* }, callback);</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">retryable </span><span class="s4">(</span><span class="s2">opts</span><span class="s4">, </span><span class="s2">task</span><span class="s4">) {</span>
    <span class="s3">if </span><span class="s4">(!</span><span class="s2">task</span><span class="s4">) {</span>
        <span class="s2">task </span><span class="s4">= </span><span class="s2">opts</span><span class="s4">;</span>
        <span class="s2">opts </span><span class="s4">= </span><span class="s3">null</span><span class="s4">;</span>
    <span class="s4">}</span>
    <span class="s3">let </span><span class="s2">arity </span><span class="s4">= (</span><span class="s2">opts </span><span class="s4">&amp;&amp; </span><span class="s2">opts</span><span class="s4">.</span><span class="s2">arity</span><span class="s4">) || </span><span class="s2">task</span><span class="s4">.</span><span class="s2">length</span><span class="s4">;</span>
    <span class="s3">if </span><span class="s4">(</span><span class="s2">isAsync</span><span class="s4">(</span><span class="s2">task</span><span class="s4">)) {</span>
        <span class="s2">arity </span><span class="s4">+= </span><span class="s7">1</span><span class="s4">;</span>
    <span class="s4">}</span>
    <span class="s3">var </span><span class="s2">_task </span><span class="s4">= </span><span class="s2">wrapAsync</span><span class="s4">(</span><span class="s2">task</span><span class="s4">);</span>
    <span class="s3">return </span><span class="s2">initialParams</span><span class="s4">((</span><span class="s2">args</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) =&gt; {</span>
        <span class="s3">if </span><span class="s4">(</span><span class="s2">args</span><span class="s4">.</span><span class="s2">length </span><span class="s4">&lt; </span><span class="s2">arity </span><span class="s4">- </span><span class="s7">1 </span><span class="s4">|| </span><span class="s2">callback </span><span class="s4">== </span><span class="s3">null</span><span class="s4">) {</span>
            <span class="s2">args</span><span class="s4">.</span><span class="s2">push</span><span class="s4">(</span><span class="s2">callback</span><span class="s4">);</span>
            <span class="s2">callback </span><span class="s4">= </span><span class="s2">promiseCallback</span><span class="s4">();</span>
        <span class="s4">}</span>
        <span class="s3">function </span><span class="s2">taskFn</span><span class="s4">(</span><span class="s2">cb</span><span class="s4">) {</span>
            <span class="s2">_task</span><span class="s4">(</span><span class="s2">...args</span><span class="s4">, </span><span class="s2">cb</span><span class="s4">);</span>
        <span class="s4">}</span>

        <span class="s3">if </span><span class="s4">(</span><span class="s2">opts</span><span class="s4">) </span><span class="s2">retry</span><span class="s4">(</span><span class="s2">opts</span><span class="s4">, </span><span class="s2">taskFn</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">);</span>
        <span class="s3">else </span><span class="s2">retry</span><span class="s4">(</span><span class="s2">taskFn</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">);</span>

        <span class="s3">return </span><span class="s2">callback</span><span class="s4">[</span><span class="s2">PROMISE_SYMBOL</span><span class="s4">]</span>
    <span class="s4">});</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Run the functions in the `tasks` collection in series, each one running once</span>
 <span class="s0">* the previous function has completed. If any functions in the series pass an</span>
 <span class="s0">* error to its callback, no more functions are run, and `callback` is</span>
 <span class="s0">* immediately called with the value of the error. Otherwise, `callback`</span>
 <span class="s0">* receives an array of results when `tasks` have completed.</span>
 <span class="s0">*</span>
 <span class="s0">* It is also possible to use an object instead of an array. Each property will</span>
 <span class="s0">* be run as a function, and the results will be passed to the final `callback`</span>
 <span class="s0">* as an object instead of an array. This can be a more readable way of handling</span>
 <span class="s0">*  results from {</span><span class="s1">@link </span><span class="s0">async.series}.</span>
 <span class="s0">*</span>
 <span class="s0">* **Note** that while many implementations preserve the order of object</span>
 <span class="s0">* properties, the [ECMAScript Language Specification](http://www.ecma-international.org/ecma-262/5.1/#sec-8.6)</span>
 <span class="s0">* explicitly states that</span>
 <span class="s0">*</span>
 <span class="s0">* &gt; The mechanics and order of enumerating the properties is not specified.</span>
 <span class="s0">*</span>
 <span class="s0">* So if you rely on the order in which your series of functions are executed,</span>
 <span class="s0">* and want this to work on all platforms, consider using an array.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">series</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:ControlFlow</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Control Flow</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Array|Iterable|AsyncIterable|Object} tasks - A collection containing</span>
 <span class="s0">* [async functions]{</span><span class="s1">@link </span><span class="s0">AsyncFunction} to run in series.</span>
 <span class="s0">* Each function can complete with any number of optional `result` values.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} [callback] - An optional callback to run once all the</span>
 <span class="s0">* functions have completed. This function gets a results array (or object)</span>
 <span class="s0">* containing all the result arguments passed to the `task` callbacks. Invoked</span>
 <span class="s0">* with (err, result).</span>
 <span class="s0">* </span><span class="s1">@return </span><span class="s0">{Promise} a promise, if no callback is passed</span>
 <span class="s0">* </span><span class="s1">@example</span>
 <span class="s0">*</span>
 <span class="s0">* //Using Callbacks</span>
 <span class="s0">* async.series([</span>
 <span class="s0">*     function(callback) {</span>
 <span class="s0">*         setTimeout(function() {</span>
 <span class="s0">*             // do some async task</span>
 <span class="s0">*             callback(null, 'one');</span>
 <span class="s0">*         }, 200);</span>
 <span class="s0">*     },</span>
 <span class="s0">*     function(callback) {</span>
 <span class="s0">*         setTimeout(function() {</span>
 <span class="s0">*             // then do another async task</span>
 <span class="s0">*             callback(null, 'two');</span>
 <span class="s0">*         }, 100);</span>
 <span class="s0">*     }</span>
 <span class="s0">* ], function(err, results) {</span>
 <span class="s0">*     console.log(results);</span>
 <span class="s0">*     // results is equal to ['one','two']</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* // an example using objects instead of arrays</span>
 <span class="s0">* async.series({</span>
 <span class="s0">*     one: function(callback) {</span>
 <span class="s0">*         setTimeout(function() {</span>
 <span class="s0">*             // do some async task</span>
 <span class="s0">*             callback(null, 1);</span>
 <span class="s0">*         }, 200);</span>
 <span class="s0">*     },</span>
 <span class="s0">*     two: function(callback) {</span>
 <span class="s0">*         setTimeout(function() {</span>
 <span class="s0">*             // then do another async task</span>
 <span class="s0">*             callback(null, 2);</span>
 <span class="s0">*         }, 100);</span>
 <span class="s0">*     }</span>
 <span class="s0">* }, function(err, results) {</span>
 <span class="s0">*     console.log(results);</span>
 <span class="s0">*     // results is equal to: { one: 1, two: 2 }</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* //Using Promises</span>
 <span class="s0">* async.series([</span>
 <span class="s0">*     function(callback) {</span>
 <span class="s0">*         setTimeout(function() {</span>
 <span class="s0">*             callback(null, 'one');</span>
 <span class="s0">*         }, 200);</span>
 <span class="s0">*     },</span>
 <span class="s0">*     function(callback) {</span>
 <span class="s0">*         setTimeout(function() {</span>
 <span class="s0">*             callback(null, 'two');</span>
 <span class="s0">*         }, 100);</span>
 <span class="s0">*     }</span>
 <span class="s0">* ]).then(results =&gt; {</span>
 <span class="s0">*     console.log(results);</span>
 <span class="s0">*     // results is equal to ['one','two']</span>
 <span class="s0">* }).catch(err =&gt; {</span>
 <span class="s0">*     console.log(err);</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* // an example using an object instead of an array</span>
 <span class="s0">* async.series({</span>
 <span class="s0">*     one: function(callback) {</span>
 <span class="s0">*         setTimeout(function() {</span>
 <span class="s0">*             // do some async task</span>
 <span class="s0">*             callback(null, 1);</span>
 <span class="s0">*         }, 200);</span>
 <span class="s0">*     },</span>
 <span class="s0">*     two: function(callback) {</span>
 <span class="s0">*         setTimeout(function() {</span>
 <span class="s0">*             // then do another async task</span>
 <span class="s0">*             callback(null, 2);</span>
 <span class="s0">*         }, 100);</span>
 <span class="s0">*     }</span>
 <span class="s0">* }).then(results =&gt; {</span>
 <span class="s0">*     console.log(results);</span>
 <span class="s0">*     // results is equal to: { one: 1, two: 2 }</span>
 <span class="s0">* }).catch(err =&gt; {</span>
 <span class="s0">*     console.log(err);</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* //Using async/await</span>
 <span class="s0">* async () =&gt; {</span>
 <span class="s0">*     try {</span>
 <span class="s0">*         let results = await async.series([</span>
 <span class="s0">*             function(callback) {</span>
 <span class="s0">*                 setTimeout(function() {</span>
 <span class="s0">*                     // do some async task</span>
 <span class="s0">*                     callback(null, 'one');</span>
 <span class="s0">*                 }, 200);</span>
 <span class="s0">*             },</span>
 <span class="s0">*             function(callback) {</span>
 <span class="s0">*                 setTimeout(function() {</span>
 <span class="s0">*                     // then do another async task</span>
 <span class="s0">*                     callback(null, 'two');</span>
 <span class="s0">*                 }, 100);</span>
 <span class="s0">*             }</span>
 <span class="s0">*         ]);</span>
 <span class="s0">*         console.log(results);</span>
 <span class="s0">*         // results is equal to ['one','two']</span>
 <span class="s0">*     }</span>
 <span class="s0">*     catch (err) {</span>
 <span class="s0">*         console.log(err);</span>
 <span class="s0">*     }</span>
 <span class="s0">* }</span>
 <span class="s0">*</span>
 <span class="s0">* // an example using an object instead of an array</span>
 <span class="s0">* async () =&gt; {</span>
 <span class="s0">*     try {</span>
 <span class="s0">*         let results = await async.parallel({</span>
 <span class="s0">*             one: function(callback) {</span>
 <span class="s0">*                 setTimeout(function() {</span>
 <span class="s0">*                     // do some async task</span>
 <span class="s0">*                     callback(null, 1);</span>
 <span class="s0">*                 }, 200);</span>
 <span class="s0">*             },</span>
 <span class="s0">*            two: function(callback) {</span>
 <span class="s0">*                 setTimeout(function() {</span>
 <span class="s0">*                     // then do another async task</span>
 <span class="s0">*                     callback(null, 2);</span>
 <span class="s0">*                 }, 100);</span>
 <span class="s0">*            }</span>
 <span class="s0">*         });</span>
 <span class="s0">*         console.log(results);</span>
 <span class="s0">*         // results is equal to: { one: 1, two: 2 }</span>
 <span class="s0">*     }</span>
 <span class="s0">*     catch (err) {</span>
 <span class="s0">*         console.log(err);</span>
 <span class="s0">*     }</span>
 <span class="s0">* }</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">series</span><span class="s4">(</span><span class="s2">tasks</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
    <span class="s3">return </span><span class="s2">_parallel</span><span class="s4">(</span><span class="s2">eachOfSeries$1</span><span class="s4">, </span><span class="s2">tasks</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">);</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Returns `true` if at least one element in the `coll` satisfies an async test.</span>
 <span class="s0">* If any iteratee call returns `true`, the main `callback` is immediately</span>
 <span class="s0">* called.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">some</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@alias </span><span class="s0">any</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collection</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{AsyncFunction} iteratee - An async truth test to apply to each item</span>
 <span class="s0">* in the collections in parallel.</span>
 <span class="s0">* The iteratee should complete with a boolean `result` value.</span>
 <span class="s0">* Invoked with (item, callback).</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} [callback] - A callback which is called as soon as any</span>
 <span class="s0">* iteratee returns `true`, or after all the iteratee functions have finished.</span>
 <span class="s0">* Result will be either `true` or `false` depending on the values of the async</span>
 <span class="s0">* tests. Invoked with (err, result).</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise} a promise, if no callback provided</span>
 <span class="s0">* </span><span class="s1">@example</span>
 <span class="s0">*</span>
 <span class="s0">* // dir1 is a directory that contains file1.txt, file2.txt</span>
 <span class="s0">* // dir2 is a directory that contains file3.txt, file4.txt</span>
 <span class="s0">* // dir3 is a directory that contains file5.txt</span>
 <span class="s0">* // dir4 does not exist</span>
 <span class="s0">*</span>
 <span class="s0">* // asynchronous function that checks if a file exists</span>
 <span class="s0">* function fileExists(file, callback) {</span>
 <span class="s0">*    fs.access(file, fs.constants.F_OK, (err) =&gt; {</span>
 <span class="s0">*        callback(null, !err);</span>
 <span class="s0">*    });</span>
 <span class="s0">* }</span>
 <span class="s0">*</span>
 <span class="s0">* // Using callbacks</span>
 <span class="s0">* async.some(['dir1/missing.txt','dir2/missing.txt','dir3/file5.txt'], fileExists,</span>
 <span class="s0">*    function(err, result) {</span>
 <span class="s0">*        console.log(result);</span>
 <span class="s0">*        // true</span>
 <span class="s0">*        // result is true since some file in the list exists</span>
 <span class="s0">*    }</span>
 <span class="s0">*);</span>
 <span class="s0">*</span>
 <span class="s0">* async.some(['dir1/missing.txt','dir2/missing.txt','dir4/missing.txt'], fileExists,</span>
 <span class="s0">*    function(err, result) {</span>
 <span class="s0">*        console.log(result);</span>
 <span class="s0">*        // false</span>
 <span class="s0">*        // result is false since none of the files exists</span>
 <span class="s0">*    }</span>
 <span class="s0">*);</span>
 <span class="s0">*</span>
 <span class="s0">* // Using Promises</span>
 <span class="s0">* async.some(['dir1/missing.txt','dir2/missing.txt','dir3/file5.txt'], fileExists)</span>
 <span class="s0">* .then( result =&gt; {</span>
 <span class="s0">*     console.log(result);</span>
 <span class="s0">*     // true</span>
 <span class="s0">*     // result is true since some file in the list exists</span>
 <span class="s0">* }).catch( err =&gt; {</span>
 <span class="s0">*     console.log(err);</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* async.some(['dir1/missing.txt','dir2/missing.txt','dir4/missing.txt'], fileExists)</span>
 <span class="s0">* .then( result =&gt; {</span>
 <span class="s0">*     console.log(result);</span>
 <span class="s0">*     // false</span>
 <span class="s0">*     // result is false since none of the files exists</span>
 <span class="s0">* }).catch( err =&gt; {</span>
 <span class="s0">*     console.log(err);</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* // Using async/await</span>
 <span class="s0">* async () =&gt; {</span>
 <span class="s0">*     try {</span>
 <span class="s0">*         let result = await async.some(['dir1/missing.txt','dir2/missing.txt','dir3/file5.txt'], fileExists);</span>
 <span class="s0">*         console.log(result);</span>
 <span class="s0">*         // true</span>
 <span class="s0">*         // result is true since some file in the list exists</span>
 <span class="s0">*     }</span>
 <span class="s0">*     catch (err) {</span>
 <span class="s0">*         console.log(err);</span>
 <span class="s0">*     }</span>
 <span class="s0">* }</span>
 <span class="s0">*</span>
 <span class="s0">* async () =&gt; {</span>
 <span class="s0">*     try {</span>
 <span class="s0">*         let result = await async.some(['dir1/missing.txt','dir2/missing.txt','dir4/missing.txt'], fileExists);</span>
 <span class="s0">*         console.log(result);</span>
 <span class="s0">*         // false</span>
 <span class="s0">*         // result is false since none of the files exists</span>
 <span class="s0">*     }</span>
 <span class="s0">*     catch (err) {</span>
 <span class="s0">*         console.log(err);</span>
 <span class="s0">*     }</span>
 <span class="s0">* }</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">some</span><span class="s4">(</span><span class="s2">coll</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
    <span class="s3">return </span><span class="s2">_createTester</span><span class="s4">(</span><span class="s2">Boolean</span><span class="s4">, </span><span class="s2">res </span><span class="s4">=&gt; </span><span class="s2">res</span><span class="s4">)(</span><span class="s2">eachOf$1</span><span class="s4">, </span><span class="s2">coll</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">)</span>
<span class="s4">}</span>
<span class="s3">var </span><span class="s2">some$1 </span><span class="s4">= </span><span class="s2">awaitify</span><span class="s4">(</span><span class="s2">some</span><span class="s4">, </span><span class="s7">3</span><span class="s4">);</span>

<span class="s0">/**</span>
 <span class="s0">* The same as [`some`]{</span><span class="s1">@link </span><span class="s0">module:Collections.some} but runs a maximum of `limit` async operations at a time.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">someLimit</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s0">[async.some]{</span><span class="s1">@link </span><span class="s0">module:Collections.some}</span>
 <span class="s0">* </span><span class="s1">@alias </span><span class="s0">anyLimit</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collection</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{number} limit - The maximum number of async operations at a time.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{AsyncFunction} iteratee - An async truth test to apply to each item</span>
 <span class="s0">* in the collections in parallel.</span>
 <span class="s0">* The iteratee should complete with a boolean `result` value.</span>
 <span class="s0">* Invoked with (item, callback).</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} [callback] - A callback which is called as soon as any</span>
 <span class="s0">* iteratee returns `true`, or after all the iteratee functions have finished.</span>
 <span class="s0">* Result will be either `true` or `false` depending on the values of the async</span>
 <span class="s0">* tests. Invoked with (err, result).</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise} a promise, if no callback provided</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">someLimit</span><span class="s4">(</span><span class="s2">coll</span><span class="s4">, </span><span class="s2">limit</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
    <span class="s3">return </span><span class="s2">_createTester</span><span class="s4">(</span><span class="s2">Boolean</span><span class="s4">, </span><span class="s2">res </span><span class="s4">=&gt; </span><span class="s2">res</span><span class="s4">)(</span><span class="s2">eachOfLimit$2</span><span class="s4">(</span><span class="s2">limit</span><span class="s4">), </span><span class="s2">coll</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">)</span>
<span class="s4">}</span>
<span class="s3">var </span><span class="s2">someLimit$1 </span><span class="s4">= </span><span class="s2">awaitify</span><span class="s4">(</span><span class="s2">someLimit</span><span class="s4">, </span><span class="s7">4</span><span class="s4">);</span>

<span class="s0">/**</span>
 <span class="s0">* The same as [`some`]{</span><span class="s1">@link </span><span class="s0">module:Collections.some} but runs only a single async operation at a time.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">someSeries</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s0">[async.some]{</span><span class="s1">@link </span><span class="s0">module:Collections.some}</span>
 <span class="s0">* </span><span class="s1">@alias </span><span class="s0">anySeries</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collection</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{AsyncFunction} iteratee - An async truth test to apply to each item</span>
 <span class="s0">* in the collections in series.</span>
 <span class="s0">* The iteratee should complete with a boolean `result` value.</span>
 <span class="s0">* Invoked with (item, callback).</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} [callback] - A callback which is called as soon as any</span>
 <span class="s0">* iteratee returns `true`, or after all the iteratee functions have finished.</span>
 <span class="s0">* Result will be either `true` or `false` depending on the values of the async</span>
 <span class="s0">* tests. Invoked with (err, result).</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise} a promise, if no callback provided</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">someSeries</span><span class="s4">(</span><span class="s2">coll</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
    <span class="s3">return </span><span class="s2">_createTester</span><span class="s4">(</span><span class="s2">Boolean</span><span class="s4">, </span><span class="s2">res </span><span class="s4">=&gt; </span><span class="s2">res</span><span class="s4">)(</span><span class="s2">eachOfSeries$1</span><span class="s4">, </span><span class="s2">coll</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">)</span>
<span class="s4">}</span>
<span class="s3">var </span><span class="s2">someSeries$1 </span><span class="s4">= </span><span class="s2">awaitify</span><span class="s4">(</span><span class="s2">someSeries</span><span class="s4">, </span><span class="s7">3</span><span class="s4">);</span>

<span class="s0">/**</span>
 <span class="s0">* Sorts a list by the results of running each `coll` value through an async</span>
 <span class="s0">* `iteratee`.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">sortBy</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collection</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{AsyncFunction} iteratee - An async function to apply to each item in</span>
 <span class="s0">* `coll`.</span>
 <span class="s0">* The iteratee should complete with a value to use as the sort criteria as</span>
 <span class="s0">* its `result`.</span>
 <span class="s0">* Invoked with (item, callback).</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} callback - A callback which is called after all the</span>
 <span class="s0">* `iteratee` functions have finished, or an error occurs. Results is the items</span>
 <span class="s0">* from the original `coll` sorted by the values returned by the `iteratee`</span>
 <span class="s0">* calls. Invoked with (err, results).</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise} a promise, if no callback passed</span>
 <span class="s0">* </span><span class="s1">@example</span>
 <span class="s0">*</span>
 <span class="s0">* // bigfile.txt is a file that is 251100 bytes in size</span>
 <span class="s0">* // mediumfile.txt is a file that is 11000 bytes in size</span>
 <span class="s0">* // smallfile.txt is a file that is 121 bytes in size</span>
 <span class="s0">*</span>
 <span class="s0">* // asynchronous function that returns the file size in bytes</span>
 <span class="s0">* function getFileSizeInBytes(file, callback) {</span>
 <span class="s0">*     fs.stat(file, function(err, stat) {</span>
 <span class="s0">*         if (err) {</span>
 <span class="s0">*             return callback(err);</span>
 <span class="s0">*         }</span>
 <span class="s0">*         callback(null, stat.size);</span>
 <span class="s0">*     });</span>
 <span class="s0">* }</span>
 <span class="s0">*</span>
 <span class="s0">* // Using callbacks</span>
 <span class="s0">* async.sortBy(['mediumfile.txt','smallfile.txt','bigfile.txt'], getFileSizeInBytes,</span>
 <span class="s0">*     function(err, results) {</span>
 <span class="s0">*         if (err) {</span>
 <span class="s0">*             console.log(err);</span>
 <span class="s0">*         } else {</span>
 <span class="s0">*             console.log(results);</span>
 <span class="s0">*             // results is now the original array of files sorted by</span>
 <span class="s0">*             // file size (ascending by default), e.g.</span>
 <span class="s0">*             // [ 'smallfile.txt', 'mediumfile.txt', 'bigfile.txt']</span>
 <span class="s0">*         }</span>
 <span class="s0">*     }</span>
 <span class="s0">* );</span>
 <span class="s0">*</span>
 <span class="s0">* // By modifying the callback parameter the</span>
 <span class="s0">* // sorting order can be influenced:</span>
 <span class="s0">*</span>
 <span class="s0">* // ascending order</span>
 <span class="s0">* async.sortBy(['mediumfile.txt','smallfile.txt','bigfile.txt'], function(file, callback) {</span>
 <span class="s0">*     getFileSizeInBytes(file, function(getFileSizeErr, fileSize) {</span>
 <span class="s0">*         if (getFileSizeErr) return callback(getFileSizeErr);</span>
 <span class="s0">*         callback(null, fileSize);</span>
 <span class="s0">*     });</span>
 <span class="s0">* }, function(err, results) {</span>
 <span class="s0">*         if (err) {</span>
 <span class="s0">*             console.log(err);</span>
 <span class="s0">*         } else {</span>
 <span class="s0">*             console.log(results);</span>
 <span class="s0">*             // results is now the original array of files sorted by</span>
 <span class="s0">*             // file size (ascending by default), e.g.</span>
 <span class="s0">*             // [ 'smallfile.txt', 'mediumfile.txt', 'bigfile.txt']</span>
 <span class="s0">*         }</span>
 <span class="s0">*     }</span>
 <span class="s0">* );</span>
 <span class="s0">*</span>
 <span class="s0">* // descending order</span>
 <span class="s0">* async.sortBy(['bigfile.txt','mediumfile.txt','smallfile.txt'], function(file, callback) {</span>
 <span class="s0">*     getFileSizeInBytes(file, function(getFileSizeErr, fileSize) {</span>
 <span class="s0">*         if (getFileSizeErr) {</span>
 <span class="s0">*             return callback(getFileSizeErr);</span>
 <span class="s0">*         }</span>
 <span class="s0">*         callback(null, fileSize * -1);</span>
 <span class="s0">*     });</span>
 <span class="s0">* }, function(err, results) {</span>
 <span class="s0">*         if (err) {</span>
 <span class="s0">*             console.log(err);</span>
 <span class="s0">*         } else {</span>
 <span class="s0">*             console.log(results);</span>
 <span class="s0">*             // results is now the original array of files sorted by</span>
 <span class="s0">*             // file size (ascending by default), e.g.</span>
 <span class="s0">*             // [ 'bigfile.txt', 'mediumfile.txt', 'smallfile.txt']</span>
 <span class="s0">*         }</span>
 <span class="s0">*     }</span>
 <span class="s0">* );</span>
 <span class="s0">*</span>
 <span class="s0">* // Error handling</span>
 <span class="s0">* async.sortBy(['mediumfile.txt','smallfile.txt','missingfile.txt'], getFileSizeInBytes,</span>
 <span class="s0">*     function(err, results) {</span>
 <span class="s0">*         if (err) {</span>
 <span class="s0">*             console.log(err);</span>
 <span class="s0">*             // [ Error: ENOENT: no such file or directory ]</span>
 <span class="s0">*         } else {</span>
 <span class="s0">*             console.log(results);</span>
 <span class="s0">*         }</span>
 <span class="s0">*     }</span>
 <span class="s0">* );</span>
 <span class="s0">*</span>
 <span class="s0">* // Using Promises</span>
 <span class="s0">* async.sortBy(['mediumfile.txt','smallfile.txt','bigfile.txt'], getFileSizeInBytes)</span>
 <span class="s0">* .then( results =&gt; {</span>
 <span class="s0">*     console.log(results);</span>
 <span class="s0">*     // results is now the original array of files sorted by</span>
 <span class="s0">*     // file size (ascending by default), e.g.</span>
 <span class="s0">*     // [ 'smallfile.txt', 'mediumfile.txt', 'bigfile.txt']</span>
 <span class="s0">* }).catch( err =&gt; {</span>
 <span class="s0">*     console.log(err);</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* // Error handling</span>
 <span class="s0">* async.sortBy(['mediumfile.txt','smallfile.txt','missingfile.txt'], getFileSizeInBytes)</span>
 <span class="s0">* .then( results =&gt; {</span>
 <span class="s0">*     console.log(results);</span>
 <span class="s0">* }).catch( err =&gt; {</span>
 <span class="s0">*     console.log(err);</span>
 <span class="s0">*     // [ Error: ENOENT: no such file or directory ]</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* // Using async/await</span>
 <span class="s0">* (async () =&gt; {</span>
 <span class="s0">*     try {</span>
 <span class="s0">*         let results = await async.sortBy(['bigfile.txt','mediumfile.txt','smallfile.txt'], getFileSizeInBytes);</span>
 <span class="s0">*         console.log(results);</span>
 <span class="s0">*         // results is now the original array of files sorted by</span>
 <span class="s0">*         // file size (ascending by default), e.g.</span>
 <span class="s0">*         // [ 'smallfile.txt', 'mediumfile.txt', 'bigfile.txt']</span>
 <span class="s0">*     }</span>
 <span class="s0">*     catch (err) {</span>
 <span class="s0">*         console.log(err);</span>
 <span class="s0">*     }</span>
 <span class="s0">* })();</span>
 <span class="s0">*</span>
 <span class="s0">* // Error handling</span>
 <span class="s0">* async () =&gt; {</span>
 <span class="s0">*     try {</span>
 <span class="s0">*         let results = await async.sortBy(['missingfile.txt','mediumfile.txt','smallfile.txt'], getFileSizeInBytes);</span>
 <span class="s0">*         console.log(results);</span>
 <span class="s0">*     }</span>
 <span class="s0">*     catch (err) {</span>
 <span class="s0">*         console.log(err);</span>
 <span class="s0">*         // [ Error: ENOENT: no such file or directory ]</span>
 <span class="s0">*     }</span>
 <span class="s0">* }</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">sortBy </span><span class="s4">(</span><span class="s2">coll</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
    <span class="s3">var </span><span class="s2">_iteratee </span><span class="s4">= </span><span class="s2">wrapAsync</span><span class="s4">(</span><span class="s2">iteratee</span><span class="s4">);</span>
    <span class="s3">return </span><span class="s2">map$1</span><span class="s4">(</span><span class="s2">coll</span><span class="s4">, (</span><span class="s2">x</span><span class="s4">, </span><span class="s2">iterCb</span><span class="s4">) =&gt; {</span>
        <span class="s2">_iteratee</span><span class="s4">(</span><span class="s2">x</span><span class="s4">, (</span><span class="s2">err</span><span class="s4">, </span><span class="s2">criteria</span><span class="s4">) =&gt; {</span>
            <span class="s3">if </span><span class="s4">(</span><span class="s2">err</span><span class="s4">) </span><span class="s3">return </span><span class="s2">iterCb</span><span class="s4">(</span><span class="s2">err</span><span class="s4">);</span>
            <span class="s2">iterCb</span><span class="s4">(</span><span class="s2">err</span><span class="s4">, {</span><span class="s2">value</span><span class="s4">: </span><span class="s2">x</span><span class="s4">, </span><span class="s2">criteria</span><span class="s4">});</span>
        <span class="s4">});</span>
    <span class="s4">}, (</span><span class="s2">err</span><span class="s4">, </span><span class="s2">results</span><span class="s4">) =&gt; {</span>
        <span class="s3">if </span><span class="s4">(</span><span class="s2">err</span><span class="s4">) </span><span class="s3">return </span><span class="s2">callback</span><span class="s4">(</span><span class="s2">err</span><span class="s4">);</span>
        <span class="s2">callback</span><span class="s4">(</span><span class="s3">null</span><span class="s4">, </span><span class="s2">results</span><span class="s4">.</span><span class="s2">sort</span><span class="s4">(</span><span class="s2">comparator</span><span class="s4">).</span><span class="s2">map</span><span class="s4">(</span><span class="s2">v </span><span class="s4">=&gt; </span><span class="s2">v</span><span class="s4">.</span><span class="s2">value</span><span class="s4">));</span>
    <span class="s4">});</span>

    <span class="s3">function </span><span class="s2">comparator</span><span class="s4">(</span><span class="s2">left</span><span class="s4">, </span><span class="s2">right</span><span class="s4">) {</span>
        <span class="s3">var </span><span class="s2">a </span><span class="s4">= </span><span class="s2">left</span><span class="s4">.</span><span class="s2">criteria</span><span class="s4">, </span><span class="s2">b </span><span class="s4">= </span><span class="s2">right</span><span class="s4">.</span><span class="s2">criteria</span><span class="s4">;</span>
        <span class="s3">return </span><span class="s2">a </span><span class="s4">&lt; </span><span class="s2">b </span><span class="s4">? -</span><span class="s7">1 </span><span class="s4">: </span><span class="s2">a </span><span class="s4">&gt; </span><span class="s2">b </span><span class="s4">? </span><span class="s7">1 </span><span class="s4">: </span><span class="s7">0</span><span class="s4">;</span>
    <span class="s4">}</span>
<span class="s4">}</span>
<span class="s3">var </span><span class="s2">sortBy$1 </span><span class="s4">= </span><span class="s2">awaitify</span><span class="s4">(</span><span class="s2">sortBy</span><span class="s4">, </span><span class="s7">3</span><span class="s4">);</span>

<span class="s0">/**</span>
 <span class="s0">* Sets a time limit on an asynchronous function. If the function does not call</span>
 <span class="s0">* its callback within the specified milliseconds, it will be called with a</span>
 <span class="s0">* timeout error. The code property for the error object will be `'ETIMEDOUT'`.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">timeout</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Utils</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Util</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{AsyncFunction} asyncFn - The async function to limit in time.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{number} milliseconds - The specified time limit.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{*} [info] - Any variable you want attached (`string`, `object`, etc)</span>
 <span class="s0">* to timeout Error for more information..</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{AsyncFunction} Returns a wrapped function that can be used with any</span>
 <span class="s0">* of the control flow functions.</span>
 <span class="s0">* Invoke this function with the same parameters as you would `asyncFunc`.</span>
 <span class="s0">* </span><span class="s1">@example</span>
 <span class="s0">*</span>
 <span class="s0">* function myFunction(foo, callback) {</span>
 <span class="s0">*     doAsyncTask(foo, function(err, data) {</span>
 <span class="s0">*         // handle errors</span>
 <span class="s0">*         if (err) return callback(err);</span>
 <span class="s0">*</span>
 <span class="s0">*         // do some stuff ...</span>
 <span class="s0">*</span>
 <span class="s0">*         // return processed data</span>
 <span class="s0">*         return callback(null, data);</span>
 <span class="s0">*     });</span>
 <span class="s0">* }</span>
 <span class="s0">*</span>
 <span class="s0">* var wrapped = async.timeout(myFunction, 1000);</span>
 <span class="s0">*</span>
 <span class="s0">* // call `wrapped` as you would `myFunction`</span>
 <span class="s0">* wrapped({ bar: 'bar' }, function(err, data) {</span>
 <span class="s0">*     // if `myFunction` takes &lt; 1000 ms to execute, `err`</span>
 <span class="s0">*     // and `data` will have their expected values</span>
 <span class="s0">*</span>
 <span class="s0">*     // else `err` will be an Error with the code 'ETIMEDOUT'</span>
 <span class="s0">* });</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">timeout</span><span class="s4">(</span><span class="s2">asyncFn</span><span class="s4">, </span><span class="s2">milliseconds</span><span class="s4">, </span><span class="s2">info</span><span class="s4">) {</span>
    <span class="s3">var </span><span class="s2">fn </span><span class="s4">= </span><span class="s2">wrapAsync</span><span class="s4">(</span><span class="s2">asyncFn</span><span class="s4">);</span>

    <span class="s3">return </span><span class="s2">initialParams</span><span class="s4">((</span><span class="s2">args</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) =&gt; {</span>
        <span class="s3">var </span><span class="s2">timedOut </span><span class="s4">= </span><span class="s3">false</span><span class="s4">;</span>
        <span class="s3">var </span><span class="s2">timer</span><span class="s4">;</span>

        <span class="s3">function </span><span class="s2">timeoutCallback</span><span class="s4">() {</span>
            <span class="s3">var </span><span class="s2">name </span><span class="s4">= </span><span class="s2">asyncFn</span><span class="s4">.</span><span class="s2">name </span><span class="s4">|| </span><span class="s6">'anonymous'</span><span class="s4">;</span>
            <span class="s3">var </span><span class="s2">error  </span><span class="s4">= </span><span class="s3">new </span><span class="s2">Error</span><span class="s4">(</span><span class="s6">'Callback function &quot;' </span><span class="s4">+ </span><span class="s2">name </span><span class="s4">+ </span><span class="s6">'&quot; timed out.'</span><span class="s4">);</span>
            <span class="s2">error</span><span class="s4">.</span><span class="s2">code </span><span class="s4">= </span><span class="s6">'ETIMEDOUT'</span><span class="s4">;</span>
            <span class="s3">if </span><span class="s4">(</span><span class="s2">info</span><span class="s4">) {</span>
                <span class="s2">error</span><span class="s4">.</span><span class="s2">info </span><span class="s4">= </span><span class="s2">info</span><span class="s4">;</span>
            <span class="s4">}</span>
            <span class="s2">timedOut </span><span class="s4">= </span><span class="s3">true</span><span class="s4">;</span>
            <span class="s2">callback</span><span class="s4">(</span><span class="s2">error</span><span class="s4">);</span>
        <span class="s4">}</span>

        <span class="s2">args</span><span class="s4">.</span><span class="s2">push</span><span class="s4">((</span><span class="s2">...cbArgs</span><span class="s4">) =&gt; {</span>
            <span class="s3">if </span><span class="s4">(!</span><span class="s2">timedOut</span><span class="s4">) {</span>
                <span class="s2">callback</span><span class="s4">(</span><span class="s2">...cbArgs</span><span class="s4">);</span>
                <span class="s2">clearTimeout</span><span class="s4">(</span><span class="s2">timer</span><span class="s4">);</span>
            <span class="s4">}</span>
        <span class="s4">});</span>

        <span class="s5">// setup timer and call original function</span>
        <span class="s2">timer </span><span class="s4">= </span><span class="s2">setTimeout</span><span class="s4">(</span><span class="s2">timeoutCallback</span><span class="s4">, </span><span class="s2">milliseconds</span><span class="s4">);</span>
        <span class="s2">fn</span><span class="s4">(</span><span class="s2">...args</span><span class="s4">);</span>
    <span class="s4">});</span>
<span class="s4">}</span>

<span class="s3">function </span><span class="s2">range</span><span class="s4">(</span><span class="s2">size</span><span class="s4">) {</span>
    <span class="s3">var </span><span class="s2">result </span><span class="s4">= </span><span class="s2">Array</span><span class="s4">(</span><span class="s2">size</span><span class="s4">);</span>
    <span class="s3">while </span><span class="s4">(</span><span class="s2">size</span><span class="s4">--) {</span>
        <span class="s2">result</span><span class="s4">[</span><span class="s2">size</span><span class="s4">] = </span><span class="s2">size</span><span class="s4">;</span>
    <span class="s4">}</span>
    <span class="s3">return </span><span class="s2">result</span><span class="s4">;</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* The same as [times]{</span><span class="s1">@link </span><span class="s0">module:ControlFlow.times} but runs a maximum of `limit` async operations at a</span>
 <span class="s0">* time.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">timesLimit</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:ControlFlow</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s0">[async.times]{</span><span class="s1">@link </span><span class="s0">module:ControlFlow.times}</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Control Flow</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{number} count - The number of times to run the function.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{number} limit - The maximum number of async operations at a time.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{AsyncFunction} iteratee - The async function to call `n` times.</span>
 <span class="s0">* Invoked with the iteration index and a callback: (n, next).</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} callback - see [async.map]{</span><span class="s1">@link </span><span class="s0">module:Collections.map}.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise} a promise, if no callback is provided</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">timesLimit</span><span class="s4">(</span><span class="s2">count</span><span class="s4">, </span><span class="s2">limit</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
    <span class="s3">var </span><span class="s2">_iteratee </span><span class="s4">= </span><span class="s2">wrapAsync</span><span class="s4">(</span><span class="s2">iteratee</span><span class="s4">);</span>
    <span class="s3">return </span><span class="s2">mapLimit$1</span><span class="s4">(</span><span class="s2">range</span><span class="s4">(</span><span class="s2">count</span><span class="s4">), </span><span class="s2">limit</span><span class="s4">, </span><span class="s2">_iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">);</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Calls the `iteratee` function `n` times, and accumulates results in the same</span>
 <span class="s0">* manner you would use with [map]{</span><span class="s1">@link </span><span class="s0">module:Collections.map}.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">times</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:ControlFlow</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s0">[async.map]{</span><span class="s1">@link </span><span class="s0">module:Collections.map}</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Control Flow</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{number} n - The number of times to run the function.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{AsyncFunction} iteratee - The async function to call `n` times.</span>
 <span class="s0">* Invoked with the iteration index and a callback: (n, next).</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} callback - see {</span><span class="s1">@link </span><span class="s0">module:Collections.map}.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise} a promise, if no callback is provided</span>
 <span class="s0">* </span><span class="s1">@example</span>
 <span class="s0">*</span>
 <span class="s0">* // Pretend this is some complicated async factory</span>
 <span class="s0">* var createUser = function(id, callback) {</span>
 <span class="s0">*     callback(null, {</span>
 <span class="s0">*         id: 'user' + id</span>
 <span class="s0">*     });</span>
 <span class="s0">* };</span>
 <span class="s0">*</span>
 <span class="s0">* // generate 5 users</span>
 <span class="s0">* async.times(5, function(n, next) {</span>
 <span class="s0">*     createUser(n, function(err, user) {</span>
 <span class="s0">*         next(err, user);</span>
 <span class="s0">*     });</span>
 <span class="s0">* }, function(err, users) {</span>
 <span class="s0">*     // we should now have 5 users</span>
 <span class="s0">* });</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">times </span><span class="s4">(</span><span class="s2">n</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
    <span class="s3">return </span><span class="s2">timesLimit</span><span class="s4">(</span><span class="s2">n</span><span class="s4">, </span><span class="s2">Infinity</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">)</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* The same as [times]{</span><span class="s1">@link </span><span class="s0">module:ControlFlow.times} but runs only a single async operation at a time.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">timesSeries</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:ControlFlow</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s0">[async.times]{</span><span class="s1">@link </span><span class="s0">module:ControlFlow.times}</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Control Flow</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{number} n - The number of times to run the function.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{AsyncFunction} iteratee - The async function to call `n` times.</span>
 <span class="s0">* Invoked with the iteration index and a callback: (n, next).</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} callback - see {</span><span class="s1">@link </span><span class="s0">module:Collections.map}.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise} a promise, if no callback is provided</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">timesSeries </span><span class="s4">(</span><span class="s2">n</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
    <span class="s3">return </span><span class="s2">timesLimit</span><span class="s4">(</span><span class="s2">n</span><span class="s4">, </span><span class="s7">1</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">)</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* A relative of `reduce`.  Takes an Object or Array, and iterates over each</span>
 <span class="s0">* element in parallel, each step potentially mutating an `accumulator` value.</span>
 <span class="s0">* The type of the accumulator defaults to the type of collection passed in.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">transform</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Collections</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Collection</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{*} [accumulator] - The initial state of the transform.  If omitted,</span>
 <span class="s0">* it will default to an empty Object or Array, depending on the type of `coll`</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{AsyncFunction} iteratee - A function applied to each item in the</span>
 <span class="s0">* collection that potentially modifies the accumulator.</span>
 <span class="s0">* Invoked with (accumulator, item, key, callback).</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} [callback] - A callback which is called after all the</span>
 <span class="s0">* `iteratee` functions have finished. Result is the transformed accumulator.</span>
 <span class="s0">* Invoked with (err, result).</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise} a promise, if no callback provided</span>
 <span class="s0">* </span><span class="s1">@example</span>
 <span class="s0">*</span>
 <span class="s0">* // file1.txt is a file that is 1000 bytes in size</span>
 <span class="s0">* // file2.txt is a file that is 2000 bytes in size</span>
 <span class="s0">* // file3.txt is a file that is 3000 bytes in size</span>
 <span class="s0">*</span>
 <span class="s0">* // helper function that returns human-readable size format from bytes</span>
 <span class="s0">* function formatBytes(bytes, decimals = 2) {</span>
 <span class="s0">*   // implementation not included for brevity</span>
 <span class="s0">*   return humanReadbleFilesize;</span>
 <span class="s0">* }</span>
 <span class="s0">*</span>
 <span class="s0">* const fileList = ['file1.txt','file2.txt','file3.txt'];</span>
 <span class="s0">*</span>
 <span class="s0">* // asynchronous function that returns the file size, transformed to human-readable format</span>
 <span class="s0">* // e.g. 1024 bytes = 1KB, 1234 bytes = 1.21 KB, 1048576 bytes = 1MB, etc.</span>
 <span class="s0">* function transformFileSize(acc, value, key, callback) {</span>
 <span class="s0">*     fs.stat(value, function(err, stat) {</span>
 <span class="s0">*         if (err) {</span>
 <span class="s0">*             return callback(err);</span>
 <span class="s0">*         }</span>
 <span class="s0">*         acc[key] = formatBytes(stat.size);</span>
 <span class="s0">*         callback(null);</span>
 <span class="s0">*     });</span>
 <span class="s0">* }</span>
 <span class="s0">*</span>
 <span class="s0">* // Using callbacks</span>
 <span class="s0">* async.transform(fileList, transformFileSize, function(err, result) {</span>
 <span class="s0">*     if(err) {</span>
 <span class="s0">*         console.log(err);</span>
 <span class="s0">*     } else {</span>
 <span class="s0">*         console.log(result);</span>
 <span class="s0">*         // [ '1000 Bytes', '1.95 KB', '2.93 KB' ]</span>
 <span class="s0">*     }</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* // Using Promises</span>
 <span class="s0">* async.transform(fileList, transformFileSize)</span>
 <span class="s0">* .then(result =&gt; {</span>
 <span class="s0">*     console.log(result);</span>
 <span class="s0">*     // [ '1000 Bytes', '1.95 KB', '2.93 KB' ]</span>
 <span class="s0">* }).catch(err =&gt; {</span>
 <span class="s0">*     console.log(err);</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* // Using async/await</span>
 <span class="s0">* (async () =&gt; {</span>
 <span class="s0">*     try {</span>
 <span class="s0">*         let result = await async.transform(fileList, transformFileSize);</span>
 <span class="s0">*         console.log(result);</span>
 <span class="s0">*         // [ '1000 Bytes', '1.95 KB', '2.93 KB' ]</span>
 <span class="s0">*     }</span>
 <span class="s0">*     catch (err) {</span>
 <span class="s0">*         console.log(err);</span>
 <span class="s0">*     }</span>
 <span class="s0">* })();</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@example</span>
 <span class="s0">*</span>
 <span class="s0">* // file1.txt is a file that is 1000 bytes in size</span>
 <span class="s0">* // file2.txt is a file that is 2000 bytes in size</span>
 <span class="s0">* // file3.txt is a file that is 3000 bytes in size</span>
 <span class="s0">*</span>
 <span class="s0">* // helper function that returns human-readable size format from bytes</span>
 <span class="s0">* function formatBytes(bytes, decimals = 2) {</span>
 <span class="s0">*   // implementation not included for brevity</span>
 <span class="s0">*   return humanReadbleFilesize;</span>
 <span class="s0">* }</span>
 <span class="s0">*</span>
 <span class="s0">* const fileMap = { f1: 'file1.txt', f2: 'file2.txt', f3: 'file3.txt' };</span>
 <span class="s0">*</span>
 <span class="s0">* // asynchronous function that returns the file size, transformed to human-readable format</span>
 <span class="s0">* // e.g. 1024 bytes = 1KB, 1234 bytes = 1.21 KB, 1048576 bytes = 1MB, etc.</span>
 <span class="s0">* function transformFileSize(acc, value, key, callback) {</span>
 <span class="s0">*     fs.stat(value, function(err, stat) {</span>
 <span class="s0">*         if (err) {</span>
 <span class="s0">*             return callback(err);</span>
 <span class="s0">*         }</span>
 <span class="s0">*         acc[key] = formatBytes(stat.size);</span>
 <span class="s0">*         callback(null);</span>
 <span class="s0">*     });</span>
 <span class="s0">* }</span>
 <span class="s0">*</span>
 <span class="s0">* // Using callbacks</span>
 <span class="s0">* async.transform(fileMap, transformFileSize, function(err, result) {</span>
 <span class="s0">*     if(err) {</span>
 <span class="s0">*         console.log(err);</span>
 <span class="s0">*     } else {</span>
 <span class="s0">*         console.log(result);</span>
 <span class="s0">*         // { f1: '1000 Bytes', f2: '1.95 KB', f3: '2.93 KB' }</span>
 <span class="s0">*     }</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* // Using Promises</span>
 <span class="s0">* async.transform(fileMap, transformFileSize)</span>
 <span class="s0">* .then(result =&gt; {</span>
 <span class="s0">*     console.log(result);</span>
 <span class="s0">*     // { f1: '1000 Bytes', f2: '1.95 KB', f3: '2.93 KB' }</span>
 <span class="s0">* }).catch(err =&gt; {</span>
 <span class="s0">*     console.log(err);</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* // Using async/await</span>
 <span class="s0">* async () =&gt; {</span>
 <span class="s0">*     try {</span>
 <span class="s0">*         let result = await async.transform(fileMap, transformFileSize);</span>
 <span class="s0">*         console.log(result);</span>
 <span class="s0">*         // { f1: '1000 Bytes', f2: '1.95 KB', f3: '2.93 KB' }</span>
 <span class="s0">*     }</span>
 <span class="s0">*     catch (err) {</span>
 <span class="s0">*         console.log(err);</span>
 <span class="s0">*     }</span>
 <span class="s0">* }</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">transform </span><span class="s4">(</span><span class="s2">coll</span><span class="s4">, </span><span class="s2">accumulator</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
    <span class="s3">if </span><span class="s4">(</span><span class="s2">arguments</span><span class="s4">.</span><span class="s2">length </span><span class="s4">&lt;= </span><span class="s7">3 </span><span class="s4">&amp;&amp; </span><span class="s3">typeof </span><span class="s2">accumulator </span><span class="s4">=== </span><span class="s6">'function'</span><span class="s4">) {</span>
        <span class="s2">callback </span><span class="s4">= </span><span class="s2">iteratee</span><span class="s4">;</span>
        <span class="s2">iteratee </span><span class="s4">= </span><span class="s2">accumulator</span><span class="s4">;</span>
        <span class="s2">accumulator </span><span class="s4">= </span><span class="s2">Array</span><span class="s4">.</span><span class="s2">isArray</span><span class="s4">(</span><span class="s2">coll</span><span class="s4">) ? [] : {};</span>
    <span class="s4">}</span>
    <span class="s2">callback </span><span class="s4">= </span><span class="s2">once</span><span class="s4">(</span><span class="s2">callback </span><span class="s4">|| </span><span class="s2">promiseCallback</span><span class="s4">());</span>
    <span class="s3">var </span><span class="s2">_iteratee </span><span class="s4">= </span><span class="s2">wrapAsync</span><span class="s4">(</span><span class="s2">iteratee</span><span class="s4">);</span>

    <span class="s2">eachOf$1</span><span class="s4">(</span><span class="s2">coll</span><span class="s4">, (</span><span class="s2">v</span><span class="s4">, </span><span class="s2">k</span><span class="s4">, </span><span class="s2">cb</span><span class="s4">) =&gt; {</span>
        <span class="s2">_iteratee</span><span class="s4">(</span><span class="s2">accumulator</span><span class="s4">, </span><span class="s2">v</span><span class="s4">, </span><span class="s2">k</span><span class="s4">, </span><span class="s2">cb</span><span class="s4">);</span>
    <span class="s4">}, </span><span class="s2">err </span><span class="s4">=&gt; </span><span class="s2">callback</span><span class="s4">(</span><span class="s2">err</span><span class="s4">, </span><span class="s2">accumulator</span><span class="s4">));</span>
    <span class="s3">return </span><span class="s2">callback</span><span class="s4">[</span><span class="s2">PROMISE_SYMBOL</span><span class="s4">]</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* It runs each task in series but stops whenever any of the functions were</span>
 <span class="s0">* successful. If one of the tasks were successful, the `callback` will be</span>
 <span class="s0">* passed the result of the successful task. If all tasks fail, the callback</span>
 <span class="s0">* will be passed the error and result (if any) of the final attempt.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">tryEach</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:ControlFlow</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Control Flow</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Array|Iterable|AsyncIterable|Object} tasks - A collection containing functions to</span>
 <span class="s0">* run, each function is passed a `callback(err, result)` it must call on</span>
 <span class="s0">* completion with an error `err` (which can be `null`) and an optional `result`</span>
 <span class="s0">* value.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} [callback] - An optional callback which is called when one</span>
 <span class="s0">* of the tasks has succeeded, or all have failed. It receives the `err` and</span>
 <span class="s0">* `result` arguments of the last attempt at completing the `task`. Invoked with</span>
 <span class="s0">* (err, results).</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise} a promise, if no callback is passed</span>
 <span class="s0">* </span><span class="s1">@example</span>
 <span class="s0">* async.tryEach([</span>
 <span class="s0">*     function getDataFromFirstWebsite(callback) {</span>
 <span class="s0">*         // Try getting the data from the first website</span>
 <span class="s0">*         callback(err, data);</span>
 <span class="s0">*     },</span>
 <span class="s0">*     function getDataFromSecondWebsite(callback) {</span>
 <span class="s0">*         // First website failed,</span>
 <span class="s0">*         // Try getting the data from the backup website</span>
 <span class="s0">*         callback(err, data);</span>
 <span class="s0">*     }</span>
 <span class="s0">* ],</span>
 <span class="s0">* // optional callback</span>
 <span class="s0">* function(err, results) {</span>
 <span class="s0">*     Now do something with the data.</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">tryEach</span><span class="s4">(</span><span class="s2">tasks</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
    <span class="s3">var </span><span class="s2">error </span><span class="s4">= </span><span class="s3">null</span><span class="s4">;</span>
    <span class="s3">var </span><span class="s2">result</span><span class="s4">;</span>
    <span class="s3">return </span><span class="s2">eachSeries$1</span><span class="s4">(</span><span class="s2">tasks</span><span class="s4">, (</span><span class="s2">task</span><span class="s4">, </span><span class="s2">taskCb</span><span class="s4">) =&gt; {</span>
        <span class="s2">wrapAsync</span><span class="s4">(</span><span class="s2">task</span><span class="s4">)((</span><span class="s2">err</span><span class="s4">, </span><span class="s2">...args</span><span class="s4">) =&gt; {</span>
            <span class="s3">if </span><span class="s4">(</span><span class="s2">err </span><span class="s4">=== </span><span class="s3">false</span><span class="s4">) </span><span class="s3">return </span><span class="s2">taskCb</span><span class="s4">(</span><span class="s2">err</span><span class="s4">);</span>

            <span class="s3">if </span><span class="s4">(</span><span class="s2">args</span><span class="s4">.</span><span class="s2">length </span><span class="s4">&lt; </span><span class="s7">2</span><span class="s4">) {</span>
                <span class="s4">[</span><span class="s2">result</span><span class="s4">] = </span><span class="s2">args</span><span class="s4">;</span>
            <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
                <span class="s2">result </span><span class="s4">= </span><span class="s2">args</span><span class="s4">;</span>
            <span class="s4">}</span>
            <span class="s2">error </span><span class="s4">= </span><span class="s2">err</span><span class="s4">;</span>
            <span class="s2">taskCb</span><span class="s4">(</span><span class="s2">err </span><span class="s4">? </span><span class="s3">null </span><span class="s4">: {});</span>
        <span class="s4">});</span>
    <span class="s4">}, () =&gt; </span><span class="s2">callback</span><span class="s4">(</span><span class="s2">error</span><span class="s4">, </span><span class="s2">result</span><span class="s4">));</span>
<span class="s4">}</span>

<span class="s3">var </span><span class="s2">tryEach$1 </span><span class="s4">= </span><span class="s2">awaitify</span><span class="s4">(</span><span class="s2">tryEach</span><span class="s4">);</span>

<span class="s0">/**</span>
 <span class="s0">* Undoes a [memoize]{</span><span class="s1">@link </span><span class="s0">module:Utils.memoize}d function, reverting it to the original,</span>
 <span class="s0">* unmemoized form. Handy for testing.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">unmemoize</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:Utils</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s0">[async.memoize]{</span><span class="s1">@link </span><span class="s0">module:Utils.memoize}</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Util</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{AsyncFunction} fn - the memoized function</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{AsyncFunction} a function that calls the original unmemoized function</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">unmemoize</span><span class="s4">(</span><span class="s2">fn</span><span class="s4">) {</span>
    <span class="s3">return </span><span class="s4">(</span><span class="s2">...args</span><span class="s4">) =&gt; {</span>
        <span class="s3">return </span><span class="s4">(</span><span class="s2">fn</span><span class="s4">.</span><span class="s2">unmemoized </span><span class="s4">|| </span><span class="s2">fn</span><span class="s4">)(</span><span class="s2">...args</span><span class="s4">);</span>
    <span class="s4">};</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Repeatedly call `iteratee`, while `test` returns `true`. Calls `callback` when</span>
 <span class="s0">* stopped, or an error occurs.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">whilst</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:ControlFlow</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Control Flow</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{AsyncFunction} test - asynchronous truth test to perform before each</span>
 <span class="s0">* execution of `iteratee`. Invoked with (callback).</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{AsyncFunction} iteratee - An async function which is called each time</span>
 <span class="s0">* `test` passes. Invoked with (callback).</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} [callback] - A callback which is called after the test</span>
 <span class="s0">* function has failed and repeated execution of `iteratee` has stopped. `callback`</span>
 <span class="s0">* will be passed an error and any arguments passed to the final `iteratee`'s</span>
 <span class="s0">* callback. Invoked with (err, [results]);</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise} a promise, if no callback is passed</span>
 <span class="s0">* </span><span class="s1">@example</span>
 <span class="s0">*</span>
 <span class="s0">* var count = 0;</span>
 <span class="s0">* async.whilst(</span>
 <span class="s0">*     function test(cb) { cb(null, count &lt; 5); },</span>
 <span class="s0">*     function iter(callback) {</span>
 <span class="s0">*         count++;</span>
 <span class="s0">*         setTimeout(function() {</span>
 <span class="s0">*             callback(null, count);</span>
 <span class="s0">*         }, 1000);</span>
 <span class="s0">*     },</span>
 <span class="s0">*     function (err, n) {</span>
 <span class="s0">*         // 5 seconds have passed, n = 5</span>
 <span class="s0">*     }</span>
 <span class="s0">* );</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">whilst</span><span class="s4">(</span><span class="s2">test</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
    <span class="s2">callback </span><span class="s4">= </span><span class="s2">onlyOnce</span><span class="s4">(</span><span class="s2">callback</span><span class="s4">);</span>
    <span class="s3">var </span><span class="s2">_fn </span><span class="s4">= </span><span class="s2">wrapAsync</span><span class="s4">(</span><span class="s2">iteratee</span><span class="s4">);</span>
    <span class="s3">var </span><span class="s2">_test </span><span class="s4">= </span><span class="s2">wrapAsync</span><span class="s4">(</span><span class="s2">test</span><span class="s4">);</span>
    <span class="s3">var </span><span class="s2">results </span><span class="s4">= [];</span>

    <span class="s3">function </span><span class="s2">next</span><span class="s4">(</span><span class="s2">err</span><span class="s4">, </span><span class="s2">...rest</span><span class="s4">) {</span>
        <span class="s3">if </span><span class="s4">(</span><span class="s2">err</span><span class="s4">) </span><span class="s3">return </span><span class="s2">callback</span><span class="s4">(</span><span class="s2">err</span><span class="s4">);</span>
        <span class="s2">results </span><span class="s4">= </span><span class="s2">rest</span><span class="s4">;</span>
        <span class="s3">if </span><span class="s4">(</span><span class="s2">err </span><span class="s4">=== </span><span class="s3">false</span><span class="s4">) </span><span class="s3">return</span><span class="s4">;</span>
        <span class="s2">_test</span><span class="s4">(</span><span class="s2">check</span><span class="s4">);</span>
    <span class="s4">}</span>

    <span class="s3">function </span><span class="s2">check</span><span class="s4">(</span><span class="s2">err</span><span class="s4">, </span><span class="s2">truth</span><span class="s4">) {</span>
        <span class="s3">if </span><span class="s4">(</span><span class="s2">err</span><span class="s4">) </span><span class="s3">return </span><span class="s2">callback</span><span class="s4">(</span><span class="s2">err</span><span class="s4">);</span>
        <span class="s3">if </span><span class="s4">(</span><span class="s2">err </span><span class="s4">=== </span><span class="s3">false</span><span class="s4">) </span><span class="s3">return</span><span class="s4">;</span>
        <span class="s3">if </span><span class="s4">(!</span><span class="s2">truth</span><span class="s4">) </span><span class="s3">return </span><span class="s2">callback</span><span class="s4">(</span><span class="s3">null</span><span class="s4">, </span><span class="s2">...results</span><span class="s4">);</span>
        <span class="s2">_fn</span><span class="s4">(</span><span class="s2">next</span><span class="s4">);</span>
    <span class="s4">}</span>

    <span class="s3">return </span><span class="s2">_test</span><span class="s4">(</span><span class="s2">check</span><span class="s4">);</span>
<span class="s4">}</span>
<span class="s3">var </span><span class="s2">whilst$1 </span><span class="s4">= </span><span class="s2">awaitify</span><span class="s4">(</span><span class="s2">whilst</span><span class="s4">, </span><span class="s7">3</span><span class="s4">);</span>

<span class="s0">/**</span>
 <span class="s0">* Repeatedly call `iteratee` until `test` returns `true`. Calls `callback` when</span>
 <span class="s0">* stopped, or an error occurs. `callback` will be passed an error and any</span>
 <span class="s0">* arguments passed to the final `iteratee`'s callback.</span>
 <span class="s0">*</span>
 <span class="s0">* The inverse of [whilst]{</span><span class="s1">@link </span><span class="s0">module:ControlFlow.whilst}.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">until</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:ControlFlow</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s0">[async.whilst]{</span><span class="s1">@link </span><span class="s0">module:ControlFlow.whilst}</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Control Flow</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{AsyncFunction} test - asynchronous truth test to perform before each</span>
 <span class="s0">* execution of `iteratee`. Invoked with (callback).</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{AsyncFunction} iteratee - An async function which is called each time</span>
 <span class="s0">* `test` fails. Invoked with (callback).</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} [callback] - A callback which is called after the test</span>
 <span class="s0">* function has passed and repeated execution of `iteratee` has stopped. `callback`</span>
 <span class="s0">* will be passed an error and any arguments passed to the final `iteratee`'s</span>
 <span class="s0">* callback. Invoked with (err, [results]);</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise} a promise, if a callback is not passed</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@example</span>
 <span class="s0">* const results = []</span>
 <span class="s0">* let finished = false</span>
 <span class="s0">* async.until(function test(cb) {</span>
 <span class="s0">*     cb(null, finished)</span>
 <span class="s0">* }, function iter(next) {</span>
 <span class="s0">*     fetchPage(url, (err, body) =&gt; {</span>
 <span class="s0">*         if (err) return next(err)</span>
 <span class="s0">*         results = results.concat(body.objects)</span>
 <span class="s0">*         finished = !!body.next</span>
 <span class="s0">*         next(err)</span>
 <span class="s0">*     })</span>
 <span class="s0">* }, function done (err) {</span>
 <span class="s0">*     // all pages have been fetched</span>
 <span class="s0">* })</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">until</span><span class="s4">(</span><span class="s2">test</span><span class="s4">, </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
    <span class="s3">const </span><span class="s2">_test </span><span class="s4">= </span><span class="s2">wrapAsync</span><span class="s4">(</span><span class="s2">test</span><span class="s4">);</span>
    <span class="s3">return </span><span class="s2">whilst$1</span><span class="s4">((</span><span class="s2">cb</span><span class="s4">) =&gt; </span><span class="s2">_test</span><span class="s4">((</span><span class="s2">err</span><span class="s4">, </span><span class="s2">truth</span><span class="s4">) =&gt; </span><span class="s2">cb </span><span class="s4">(</span><span class="s2">err</span><span class="s4">, !</span><span class="s2">truth</span><span class="s4">)), </span><span class="s2">iteratee</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">);</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Runs the `tasks` array of functions in series, each passing their results to</span>
 <span class="s0">* the next in the array. However, if any of the `tasks` pass an error to their</span>
 <span class="s0">* own callback, the next function is not executed, and the main `callback` is</span>
 <span class="s0">* immediately called with the error.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@name </span><span class="s0">waterfall</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">* </span><span class="s1">@memberOf </span><span class="s0">module:ControlFlow</span>
 <span class="s0">* </span><span class="s1">@method</span>
 <span class="s0">* </span><span class="s1">@category </span><span class="s0">Control Flow</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Array} tasks - An array of [async functions]{</span><span class="s1">@link </span><span class="s0">AsyncFunction}</span>
 <span class="s0">* to run.</span>
 <span class="s0">* Each function should complete with any number of `result` values.</span>
 <span class="s0">* The `result` values will be passed as arguments, in order, to the next task.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} [callback] - An optional callback to run once all the</span>
 <span class="s0">* functions have completed. This will be passed the results of the last task's</span>
 <span class="s0">* callback. Invoked with (err, [results]).</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise} a promise, if a callback is omitted</span>
 <span class="s0">* </span><span class="s1">@example</span>
 <span class="s0">*</span>
 <span class="s0">* async.waterfall([</span>
 <span class="s0">*     function(callback) {</span>
 <span class="s0">*         callback(null, 'one', 'two');</span>
 <span class="s0">*     },</span>
 <span class="s0">*     function(arg1, arg2, callback) {</span>
 <span class="s0">*         // arg1 now equals 'one' and arg2 now equals 'two'</span>
 <span class="s0">*         callback(null, 'three');</span>
 <span class="s0">*     },</span>
 <span class="s0">*     function(arg1, callback) {</span>
 <span class="s0">*         // arg1 now equals 'three'</span>
 <span class="s0">*         callback(null, 'done');</span>
 <span class="s0">*     }</span>
 <span class="s0">* ], function (err, result) {</span>
 <span class="s0">*     // result now equals 'done'</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* // Or, with named functions:</span>
 <span class="s0">* async.waterfall([</span>
 <span class="s0">*     myFirstFunction,</span>
 <span class="s0">*     mySecondFunction,</span>
 <span class="s0">*     myLastFunction,</span>
 <span class="s0">* ], function (err, result) {</span>
 <span class="s0">*     // result now equals 'done'</span>
 <span class="s0">* });</span>
 <span class="s0">* function myFirstFunction(callback) {</span>
 <span class="s0">*     callback(null, 'one', 'two');</span>
 <span class="s0">* }</span>
 <span class="s0">* function mySecondFunction(arg1, arg2, callback) {</span>
 <span class="s0">*     // arg1 now equals 'one' and arg2 now equals 'two'</span>
 <span class="s0">*     callback(null, 'three');</span>
 <span class="s0">* }</span>
 <span class="s0">* function myLastFunction(arg1, callback) {</span>
 <span class="s0">*     // arg1 now equals 'three'</span>
 <span class="s0">*     callback(null, 'done');</span>
 <span class="s0">* }</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">waterfall </span><span class="s4">(</span><span class="s2">tasks</span><span class="s4">, </span><span class="s2">callback</span><span class="s4">) {</span>
    <span class="s2">callback </span><span class="s4">= </span><span class="s2">once</span><span class="s4">(</span><span class="s2">callback</span><span class="s4">);</span>
    <span class="s3">if </span><span class="s4">(!</span><span class="s2">Array</span><span class="s4">.</span><span class="s2">isArray</span><span class="s4">(</span><span class="s2">tasks</span><span class="s4">)) </span><span class="s3">return </span><span class="s2">callback</span><span class="s4">(</span><span class="s3">new </span><span class="s2">Error</span><span class="s4">(</span><span class="s6">'First argument to waterfall must be an array of functions'</span><span class="s4">));</span>
    <span class="s3">if </span><span class="s4">(!</span><span class="s2">tasks</span><span class="s4">.</span><span class="s2">length</span><span class="s4">) </span><span class="s3">return </span><span class="s2">callback</span><span class="s4">();</span>
    <span class="s3">var </span><span class="s2">taskIndex </span><span class="s4">= </span><span class="s7">0</span><span class="s4">;</span>

    <span class="s3">function </span><span class="s2">nextTask</span><span class="s4">(</span><span class="s2">args</span><span class="s4">) {</span>
        <span class="s3">var </span><span class="s2">task </span><span class="s4">= </span><span class="s2">wrapAsync</span><span class="s4">(</span><span class="s2">tasks</span><span class="s4">[</span><span class="s2">taskIndex</span><span class="s4">++]);</span>
        <span class="s2">task</span><span class="s4">(</span><span class="s2">...args</span><span class="s4">, </span><span class="s2">onlyOnce</span><span class="s4">(</span><span class="s2">next</span><span class="s4">));</span>
    <span class="s4">}</span>

    <span class="s3">function </span><span class="s2">next</span><span class="s4">(</span><span class="s2">err</span><span class="s4">, </span><span class="s2">...args</span><span class="s4">) {</span>
        <span class="s3">if </span><span class="s4">(</span><span class="s2">err </span><span class="s4">=== </span><span class="s3">false</span><span class="s4">) </span><span class="s3">return</span>
        <span class="s3">if </span><span class="s4">(</span><span class="s2">err </span><span class="s4">|| </span><span class="s2">taskIndex </span><span class="s4">=== </span><span class="s2">tasks</span><span class="s4">.</span><span class="s2">length</span><span class="s4">) {</span>
            <span class="s3">return </span><span class="s2">callback</span><span class="s4">(</span><span class="s2">err</span><span class="s4">, </span><span class="s2">...args</span><span class="s4">);</span>
        <span class="s4">}</span>
        <span class="s2">nextTask</span><span class="s4">(</span><span class="s2">args</span><span class="s4">);</span>
    <span class="s4">}</span>

    <span class="s2">nextTask</span><span class="s4">([]);</span>
<span class="s4">}</span>

<span class="s3">var </span><span class="s2">waterfall$1 </span><span class="s4">= </span><span class="s2">awaitify</span><span class="s4">(</span><span class="s2">waterfall</span><span class="s4">);</span>

<span class="s0">/**</span>
 <span class="s0">* An &quot;async function&quot; in the context of Async is an asynchronous function with</span>
 <span class="s0">* a variable number of parameters, with the final parameter being a callback.</span>
 <span class="s0">* (`function (arg1, arg2, ..., callback) {}`)</span>
 <span class="s0">* The final callback is of the form `callback(err, results...)`, which must be</span>
 <span class="s0">* called once the function is completed.  The callback should be called with a</span>
 <span class="s0">* Error as its first argument to signal that an error occurred.</span>
 <span class="s0">* Otherwise, if no error occurred, it should be called with `null` as the first</span>
 <span class="s0">* argument, and any additional `result` arguments that may apply, to signal</span>
 <span class="s0">* successful completion.</span>
 <span class="s0">* The callback must be called exactly once, ideally on a later tick of the</span>
 <span class="s0">* JavaScript event loop.</span>
 <span class="s0">*</span>
 <span class="s0">* This type of function is also referred to as a &quot;Node-style async function&quot;,</span>
 <span class="s0">* or a &quot;continuation passing-style function&quot; (CPS). Most of the methods of this</span>
 <span class="s0">* library are themselves CPS/Node-style async functions, or functions that</span>
 <span class="s0">* return CPS/Node-style async functions.</span>
 <span class="s0">*</span>
 <span class="s0">* Wherever we accept a Node-style async function, we also directly accept an</span>
 <span class="s0">* [ES2017 `async` function]{</span><span class="s1">@link </span><span class="s0">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function}.</span>
 <span class="s0">* In this case, the `async` function will not be passed a final callback</span>
 <span class="s0">* argument, and any thrown error will be used as the `err` argument of the</span>
 <span class="s0">* implicit callback, and the return value will be used as the `result` value.</span>
 <span class="s0">* (i.e. a `rejected` of the returned Promise becomes the `err` callback</span>
 <span class="s0">* argument, and a `resolved` value becomes the `result`.)</span>
 <span class="s0">*</span>
 <span class="s0">* Note, due to JavaScript limitations, we can only detect native `async`</span>
 <span class="s0">* functions and not transpilied implementations.</span>
 <span class="s0">* Your environment must have `async`/`await` support for this to work.</span>
 <span class="s0">* (e.g. Node &gt; v7.6, or a recent version of a modern browser).</span>
 <span class="s0">* If you are using `async` functions through a transpiler (e.g. Babel), you</span>
 <span class="s0">* must still wrap the function with [asyncify]{</span><span class="s1">@link </span><span class="s0">module:Utils.asyncify},</span>
 <span class="s0">* because the `async function` will be compiled to an ordinary function that</span>
 <span class="s0">* returns a promise.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@typedef </span><span class="s0">{Function} AsyncFunction</span>
 <span class="s0">* </span><span class="s1">@static</span>
 <span class="s0">*/</span>


<span class="s3">var </span><span class="s2">index </span><span class="s4">= {</span>
    <span class="s2">apply</span><span class="s4">,</span>
    <span class="s2">applyEach</span><span class="s4">,</span>
    <span class="s2">applyEachSeries</span><span class="s4">,</span>
    <span class="s2">asyncify</span><span class="s4">,</span>
    <span class="s2">auto</span><span class="s4">,</span>
    <span class="s2">autoInject</span><span class="s4">,</span>
    <span class="s2">cargo</span><span class="s4">: </span><span class="s2">cargo$1</span><span class="s4">,</span>
    <span class="s2">cargoQueue</span><span class="s4">: </span><span class="s2">cargo</span><span class="s4">,</span>
    <span class="s2">compose</span><span class="s4">,</span>
    <span class="s2">concat</span><span class="s4">: </span><span class="s2">concat$1</span><span class="s4">,</span>
    <span class="s2">concatLimit</span><span class="s4">: </span><span class="s2">concatLimit$1</span><span class="s4">,</span>
    <span class="s2">concatSeries</span><span class="s4">: </span><span class="s2">concatSeries$1</span><span class="s4">,</span>
    <span class="s2">constant</span><span class="s4">: </span><span class="s2">constant$1</span><span class="s4">,</span>
    <span class="s2">detect</span><span class="s4">: </span><span class="s2">detect$1</span><span class="s4">,</span>
    <span class="s2">detectLimit</span><span class="s4">: </span><span class="s2">detectLimit$1</span><span class="s4">,</span>
    <span class="s2">detectSeries</span><span class="s4">: </span><span class="s2">detectSeries$1</span><span class="s4">,</span>
    <span class="s2">dir</span><span class="s4">,</span>
    <span class="s2">doUntil</span><span class="s4">,</span>
    <span class="s2">doWhilst</span><span class="s4">: </span><span class="s2">doWhilst$1</span><span class="s4">,</span>
    <span class="s2">each</span><span class="s4">,</span>
    <span class="s2">eachLimit</span><span class="s4">: </span><span class="s2">eachLimit$1</span><span class="s4">,</span>
    <span class="s2">eachOf</span><span class="s4">: </span><span class="s2">eachOf$1</span><span class="s4">,</span>
    <span class="s2">eachOfLimit</span><span class="s4">: </span><span class="s2">eachOfLimit$1</span><span class="s4">,</span>
    <span class="s2">eachOfSeries</span><span class="s4">: </span><span class="s2">eachOfSeries$1</span><span class="s4">,</span>
    <span class="s2">eachSeries</span><span class="s4">: </span><span class="s2">eachSeries$1</span><span class="s4">,</span>
    <span class="s2">ensureAsync</span><span class="s4">,</span>
    <span class="s2">every</span><span class="s4">: </span><span class="s2">every$1</span><span class="s4">,</span>
    <span class="s2">everyLimit</span><span class="s4">: </span><span class="s2">everyLimit$1</span><span class="s4">,</span>
    <span class="s2">everySeries</span><span class="s4">: </span><span class="s2">everySeries$1</span><span class="s4">,</span>
    <span class="s2">filter</span><span class="s4">: </span><span class="s2">filter$1</span><span class="s4">,</span>
    <span class="s2">filterLimit</span><span class="s4">: </span><span class="s2">filterLimit$1</span><span class="s4">,</span>
    <span class="s2">filterSeries</span><span class="s4">: </span><span class="s2">filterSeries$1</span><span class="s4">,</span>
    <span class="s2">forever</span><span class="s4">: </span><span class="s2">forever$1</span><span class="s4">,</span>
    <span class="s2">groupBy</span><span class="s4">,</span>
    <span class="s2">groupByLimit</span><span class="s4">: </span><span class="s2">groupByLimit$1</span><span class="s4">,</span>
    <span class="s2">groupBySeries</span><span class="s4">,</span>
    <span class="s2">log</span><span class="s4">,</span>
    <span class="s2">map</span><span class="s4">: </span><span class="s2">map$1</span><span class="s4">,</span>
    <span class="s2">mapLimit</span><span class="s4">: </span><span class="s2">mapLimit$1</span><span class="s4">,</span>
    <span class="s2">mapSeries</span><span class="s4">: </span><span class="s2">mapSeries$1</span><span class="s4">,</span>
    <span class="s2">mapValues</span><span class="s4">,</span>
    <span class="s2">mapValuesLimit</span><span class="s4">: </span><span class="s2">mapValuesLimit$1</span><span class="s4">,</span>
    <span class="s2">mapValuesSeries</span><span class="s4">,</span>
    <span class="s2">memoize</span><span class="s4">,</span>
    <span class="s2">nextTick</span><span class="s4">,</span>
    <span class="s2">parallel</span><span class="s4">,</span>
    <span class="s2">parallelLimit</span><span class="s4">,</span>
    <span class="s2">priorityQueue</span><span class="s4">,</span>
    <span class="s2">queue</span><span class="s4">,</span>
    <span class="s2">race</span><span class="s4">: </span><span class="s2">race$1</span><span class="s4">,</span>
    <span class="s2">reduce</span><span class="s4">: </span><span class="s2">reduce$1</span><span class="s4">,</span>
    <span class="s2">reduceRight</span><span class="s4">,</span>
    <span class="s2">reflect</span><span class="s4">,</span>
    <span class="s2">reflectAll</span><span class="s4">,</span>
    <span class="s2">reject</span><span class="s4">: </span><span class="s2">reject$1</span><span class="s4">,</span>
    <span class="s2">rejectLimit</span><span class="s4">: </span><span class="s2">rejectLimit$1</span><span class="s4">,</span>
    <span class="s2">rejectSeries</span><span class="s4">: </span><span class="s2">rejectSeries$1</span><span class="s4">,</span>
    <span class="s2">retry</span><span class="s4">,</span>
    <span class="s2">retryable</span><span class="s4">,</span>
    <span class="s2">seq</span><span class="s4">,</span>
    <span class="s2">series</span><span class="s4">,</span>
    <span class="s2">setImmediate</span><span class="s4">: </span><span class="s2">setImmediate$1</span><span class="s4">,</span>
    <span class="s2">some</span><span class="s4">: </span><span class="s2">some$1</span><span class="s4">,</span>
    <span class="s2">someLimit</span><span class="s4">: </span><span class="s2">someLimit$1</span><span class="s4">,</span>
    <span class="s2">someSeries</span><span class="s4">: </span><span class="s2">someSeries$1</span><span class="s4">,</span>
    <span class="s2">sortBy</span><span class="s4">: </span><span class="s2">sortBy$1</span><span class="s4">,</span>
    <span class="s2">timeout</span><span class="s4">,</span>
    <span class="s2">times</span><span class="s4">,</span>
    <span class="s2">timesLimit</span><span class="s4">,</span>
    <span class="s2">timesSeries</span><span class="s4">,</span>
    <span class="s2">transform</span><span class="s4">,</span>
    <span class="s2">tryEach</span><span class="s4">: </span><span class="s2">tryEach$1</span><span class="s4">,</span>
    <span class="s2">unmemoize</span><span class="s4">,</span>
    <span class="s2">until</span><span class="s4">,</span>
    <span class="s2">waterfall</span><span class="s4">: </span><span class="s2">waterfall$1</span><span class="s4">,</span>
    <span class="s2">whilst</span><span class="s4">: </span><span class="s2">whilst$1</span><span class="s4">,</span>

    <span class="s5">// aliases</span>
    <span class="s2">all</span><span class="s4">: </span><span class="s2">every$1</span><span class="s4">,</span>
    <span class="s2">allLimit</span><span class="s4">: </span><span class="s2">everyLimit$1</span><span class="s4">,</span>
    <span class="s2">allSeries</span><span class="s4">: </span><span class="s2">everySeries$1</span><span class="s4">,</span>
    <span class="s2">any</span><span class="s4">: </span><span class="s2">some$1</span><span class="s4">,</span>
    <span class="s2">anyLimit</span><span class="s4">: </span><span class="s2">someLimit$1</span><span class="s4">,</span>
    <span class="s2">anySeries</span><span class="s4">: </span><span class="s2">someSeries$1</span><span class="s4">,</span>
    <span class="s2">find</span><span class="s4">: </span><span class="s2">detect$1</span><span class="s4">,</span>
    <span class="s2">findLimit</span><span class="s4">: </span><span class="s2">detectLimit$1</span><span class="s4">,</span>
    <span class="s2">findSeries</span><span class="s4">: </span><span class="s2">detectSeries$1</span><span class="s4">,</span>
    <span class="s2">flatMap</span><span class="s4">: </span><span class="s2">concat$1</span><span class="s4">,</span>
    <span class="s2">flatMapLimit</span><span class="s4">: </span><span class="s2">concatLimit$1</span><span class="s4">,</span>
    <span class="s2">flatMapSeries</span><span class="s4">: </span><span class="s2">concatSeries$1</span><span class="s4">,</span>
    <span class="s2">forEach</span><span class="s4">: </span><span class="s2">each</span><span class="s4">,</span>
    <span class="s2">forEachSeries</span><span class="s4">: </span><span class="s2">eachSeries$1</span><span class="s4">,</span>
    <span class="s2">forEachLimit</span><span class="s4">: </span><span class="s2">eachLimit$1</span><span class="s4">,</span>
    <span class="s2">forEachOf</span><span class="s4">: </span><span class="s2">eachOf$1</span><span class="s4">,</span>
    <span class="s2">forEachOfSeries</span><span class="s4">: </span><span class="s2">eachOfSeries$1</span><span class="s4">,</span>
    <span class="s2">forEachOfLimit</span><span class="s4">: </span><span class="s2">eachOfLimit$1</span><span class="s4">,</span>
    <span class="s2">inject</span><span class="s4">: </span><span class="s2">reduce$1</span><span class="s4">,</span>
    <span class="s2">foldl</span><span class="s4">: </span><span class="s2">reduce$1</span><span class="s4">,</span>
    <span class="s2">foldr</span><span class="s4">: </span><span class="s2">reduceRight</span><span class="s4">,</span>
    <span class="s2">select</span><span class="s4">: </span><span class="s2">filter$1</span><span class="s4">,</span>
    <span class="s2">selectLimit</span><span class="s4">: </span><span class="s2">filterLimit$1</span><span class="s4">,</span>
    <span class="s2">selectSeries</span><span class="s4">: </span><span class="s2">filterSeries$1</span><span class="s4">,</span>
    <span class="s2">wrapSync</span><span class="s4">: </span><span class="s2">asyncify</span><span class="s4">,</span>
    <span class="s2">during</span><span class="s4">: </span><span class="s2">whilst$1</span><span class="s4">,</span>
    <span class="s2">doDuring</span><span class="s4">: </span><span class="s2">doWhilst$1</span>
<span class="s4">};</span>

<span class="s3">export </span><span class="s4">{ </span><span class="s2">every$1 </span><span class="s4">as </span><span class="s2">all</span><span class="s4">, </span><span class="s2">everyLimit$1 </span><span class="s4">as </span><span class="s2">allLimit</span><span class="s4">, </span><span class="s2">everySeries$1 </span><span class="s4">as </span><span class="s2">allSeries</span><span class="s4">, </span><span class="s2">some$1 </span><span class="s4">as </span><span class="s2">any</span><span class="s4">, </span><span class="s2">someLimit$1 </span><span class="s4">as </span><span class="s2">anyLimit</span><span class="s4">, </span><span class="s2">someSeries$1 </span><span class="s4">as </span><span class="s2">anySeries</span><span class="s4">, </span><span class="s2">apply</span><span class="s4">, </span><span class="s2">applyEach</span><span class="s4">, </span><span class="s2">applyEachSeries</span><span class="s4">, </span><span class="s2">asyncify</span><span class="s4">, </span><span class="s2">auto</span><span class="s4">, </span><span class="s2">autoInject</span><span class="s4">, </span><span class="s2">cargo$1 </span><span class="s4">as </span><span class="s2">cargo</span><span class="s4">, </span><span class="s2">cargo </span><span class="s4">as </span><span class="s2">cargoQueue</span><span class="s4">, </span><span class="s2">compose</span><span class="s4">, </span><span class="s2">concat$1 </span><span class="s4">as </span><span class="s2">concat</span><span class="s4">, </span><span class="s2">concatLimit$1 </span><span class="s4">as </span><span class="s2">concatLimit</span><span class="s4">, </span><span class="s2">concatSeries$1 </span><span class="s4">as </span><span class="s2">concatSeries</span><span class="s4">, </span><span class="s2">constant$1 </span><span class="s4">as </span><span class="s2">constant</span><span class="s4">, </span><span class="s2">index </span><span class="s4">as </span><span class="s3">default</span><span class="s4">, </span><span class="s2">detect$1 </span><span class="s4">as </span><span class="s2">detect</span><span class="s4">, </span><span class="s2">detectLimit$1 </span><span class="s4">as </span><span class="s2">detectLimit</span><span class="s4">, </span><span class="s2">detectSeries$1 </span><span class="s4">as </span><span class="s2">detectSeries</span><span class="s4">, </span><span class="s2">dir</span><span class="s4">, </span><span class="s2">doWhilst$1 </span><span class="s4">as </span><span class="s2">doDuring</span><span class="s4">, </span><span class="s2">doUntil</span><span class="s4">, </span><span class="s2">doWhilst$1 </span><span class="s4">as </span><span class="s2">doWhilst</span><span class="s4">, </span><span class="s2">whilst$1 </span><span class="s4">as </span><span class="s2">during</span><span class="s4">, </span><span class="s2">each</span><span class="s4">, </span><span class="s2">eachLimit$1 </span><span class="s4">as </span><span class="s2">eachLimit</span><span class="s4">, </span><span class="s2">eachOf$1 </span><span class="s4">as </span><span class="s2">eachOf</span><span class="s4">, </span><span class="s2">eachOfLimit$1 </span><span class="s4">as </span><span class="s2">eachOfLimit</span><span class="s4">, </span><span class="s2">eachOfSeries$1 </span><span class="s4">as </span><span class="s2">eachOfSeries</span><span class="s4">, </span><span class="s2">eachSeries$1 </span><span class="s4">as </span><span class="s2">eachSeries</span><span class="s4">, </span><span class="s2">ensureAsync</span><span class="s4">, </span><span class="s2">every$1 </span><span class="s4">as </span><span class="s2">every</span><span class="s4">, </span><span class="s2">everyLimit$1 </span><span class="s4">as </span><span class="s2">everyLimit</span><span class="s4">, </span><span class="s2">everySeries$1 </span><span class="s4">as </span><span class="s2">everySeries</span><span class="s4">, </span><span class="s2">filter$1 </span><span class="s4">as </span><span class="s2">filter</span><span class="s4">, </span><span class="s2">filterLimit$1 </span><span class="s4">as </span><span class="s2">filterLimit</span><span class="s4">, </span><span class="s2">filterSeries$1 </span><span class="s4">as </span><span class="s2">filterSeries</span><span class="s4">, </span><span class="s2">detect$1 </span><span class="s4">as </span><span class="s2">find</span><span class="s4">, </span><span class="s2">detectLimit$1 </span><span class="s4">as </span><span class="s2">findLimit</span><span class="s4">, </span><span class="s2">detectSeries$1 </span><span class="s4">as </span><span class="s2">findSeries</span><span class="s4">, </span><span class="s2">concat$1 </span><span class="s4">as </span><span class="s2">flatMap</span><span class="s4">, </span><span class="s2">concatLimit$1 </span><span class="s4">as </span><span class="s2">flatMapLimit</span><span class="s4">, </span><span class="s2">concatSeries$1 </span><span class="s4">as </span><span class="s2">flatMapSeries</span><span class="s4">, </span><span class="s2">reduce$1 </span><span class="s4">as </span><span class="s2">foldl</span><span class="s4">, </span><span class="s2">reduceRight </span><span class="s4">as </span><span class="s2">foldr</span><span class="s4">, </span><span class="s2">each </span><span class="s4">as </span><span class="s2">forEach</span><span class="s4">, </span><span class="s2">eachLimit$1 </span><span class="s4">as </span><span class="s2">forEachLimit</span><span class="s4">, </span><span class="s2">eachOf$1 </span><span class="s4">as </span><span class="s2">forEachOf</span><span class="s4">, </span><span class="s2">eachOfLimit$1 </span><span class="s4">as </span><span class="s2">forEachOfLimit</span><span class="s4">, </span><span class="s2">eachOfSeries$1 </span><span class="s4">as </span><span class="s2">forEachOfSeries</span><span class="s4">, </span><span class="s2">eachSeries$1 </span><span class="s4">as </span><span class="s2">forEachSeries</span><span class="s4">, </span><span class="s2">forever$1 </span><span class="s4">as </span><span class="s2">forever</span><span class="s4">, </span><span class="s2">groupBy</span><span class="s4">, </span><span class="s2">groupByLimit$1 </span><span class="s4">as </span><span class="s2">groupByLimit</span><span class="s4">, </span><span class="s2">groupBySeries</span><span class="s4">, </span><span class="s2">reduce$1 </span><span class="s4">as </span><span class="s2">inject</span><span class="s4">, </span><span class="s2">log</span><span class="s4">, </span><span class="s2">map$1 </span><span class="s4">as </span><span class="s2">map</span><span class="s4">, </span><span class="s2">mapLimit$1 </span><span class="s4">as </span><span class="s2">mapLimit</span><span class="s4">, </span><span class="s2">mapSeries$1 </span><span class="s4">as </span><span class="s2">mapSeries</span><span class="s4">, </span><span class="s2">mapValues</span><span class="s4">, </span><span class="s2">mapValuesLimit$1 </span><span class="s4">as </span><span class="s2">mapValuesLimit</span><span class="s4">, </span><span class="s2">mapValuesSeries</span><span class="s4">, </span><span class="s2">memoize</span><span class="s4">, </span><span class="s2">nextTick</span><span class="s4">, </span><span class="s2">parallel</span><span class="s4">, </span><span class="s2">parallelLimit</span><span class="s4">, </span><span class="s2">priorityQueue</span><span class="s4">, </span><span class="s2">queue</span><span class="s4">, </span><span class="s2">race$1 </span><span class="s4">as </span><span class="s2">race</span><span class="s4">, </span><span class="s2">reduce$1 </span><span class="s4">as </span><span class="s2">reduce</span><span class="s4">, </span><span class="s2">reduceRight</span><span class="s4">, </span><span class="s2">reflect</span><span class="s4">, </span><span class="s2">reflectAll</span><span class="s4">, </span><span class="s2">reject$1 </span><span class="s4">as </span><span class="s2">reject</span><span class="s4">, </span><span class="s2">rejectLimit$1 </span><span class="s4">as </span><span class="s2">rejectLimit</span><span class="s4">, </span><span class="s2">rejectSeries$1 </span><span class="s4">as </span><span class="s2">rejectSeries</span><span class="s4">, </span><span class="s2">retry</span><span class="s4">, </span><span class="s2">retryable</span><span class="s4">, </span><span class="s2">filter$1 </span><span class="s4">as </span><span class="s2">select</span><span class="s4">, </span><span class="s2">filterLimit$1 </span><span class="s4">as </span><span class="s2">selectLimit</span><span class="s4">, </span><span class="s2">filterSeries$1 </span><span class="s4">as </span><span class="s2">selectSeries</span><span class="s4">, </span><span class="s2">seq</span><span class="s4">, </span><span class="s2">series</span><span class="s4">, </span><span class="s2">setImmediate$1 </span><span class="s4">as </span><span class="s2">setImmediate</span><span class="s4">, </span><span class="s2">some$1 </span><span class="s4">as </span><span class="s2">some</span><span class="s4">, </span><span class="s2">someLimit$1 </span><span class="s4">as </span><span class="s2">someLimit</span><span class="s4">, </span><span class="s2">someSeries$1 </span><span class="s4">as </span><span class="s2">someSeries</span><span class="s4">, </span><span class="s2">sortBy$1 </span><span class="s4">as </span><span class="s2">sortBy</span><span class="s4">, </span><span class="s2">timeout</span><span class="s4">, </span><span class="s2">times</span><span class="s4">, </span><span class="s2">timesLimit</span><span class="s4">, </span><span class="s2">timesSeries</span><span class="s4">, </span><span class="s2">transform</span><span class="s4">, </span><span class="s2">tryEach$1 </span><span class="s4">as </span><span class="s2">tryEach</span><span class="s4">, </span><span class="s2">unmemoize</span><span class="s4">, </span><span class="s2">until</span><span class="s4">, </span><span class="s2">waterfall$1 </span><span class="s4">as </span><span class="s2">waterfall</span><span class="s4">, </span><span class="s2">whilst$1 </span><span class="s4">as </span><span class="s2">whilst</span><span class="s4">, </span><span class="s2">asyncify </span><span class="s4">as </span><span class="s2">wrapSync </span><span class="s4">};</span>
</pre>
</body>
</html>