<html>
<head>
<title>asyncIterator.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
asyncIterator.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_asyncIterator&quot;</span><span class="s0">,</span><span class="s1">&quot;iterable&quot;</span><span class="s0">,</span><span class="s1">&quot;method&quot;</span><span class="s0">,</span><span class="s1">&quot;async&quot;</span><span class="s0">,</span><span class="s1">&quot;sync&quot;</span><span class="s0">,</span><span class="s1">&quot;retry&quot;</span><span class="s0">,</span><span class="s1">&quot;Symbol&quot;</span><span class="s0">,</span><span class="s1">&quot;asyncIterator&quot;</span><span class="s0">,</span><span class="s1">&quot;iterator&quot;</span><span class="s0">,</span><span class="s1">&quot;call&quot;</span><span class="s0">,</span><span class="s1">&quot;AsyncFromSyncIterator&quot;</span><span class="s0">,</span><span class="s1">&quot;TypeError&quot;</span><span class="s0">,</span><span class="s1">&quot;s&quot;</span><span class="s0">,</span><span class="s1">&quot;n&quot;</span><span class="s0">,</span><span class="s1">&quot;next&quot;</span><span class="s0">,</span><span class="s1">&quot;prototype&quot;</span><span class="s0">,</span><span class="s1">&quot;AsyncFromSyncIteratorContinuation&quot;</span><span class="s0">,</span><span class="s1">&quot;apply&quot;</span><span class="s0">,</span><span class="s1">&quot;arguments&quot;</span><span class="s0">,</span><span class="s1">&quot;return&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;ret&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;Promise&quot;</span><span class="s0">,</span><span class="s1">&quot;resolve&quot;</span><span class="s0">,</span><span class="s1">&quot;done&quot;</span><span class="s0">,</span><span class="s1">&quot;throw&quot;</span><span class="s0">,</span><span class="s1">&quot;maybeError&quot;</span><span class="s0">,</span><span class="s1">&quot;thr&quot;</span><span class="s0">,</span><span class="s1">&quot;reject&quot;</span><span class="s0">,</span><span class="s1">&quot;r&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;then&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../src/helpers/asyncIterator.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;/* @minVersion 7.15.9 */</span><span class="s3">\n\n</span><span class="s1">type AsyncIteratorFn&lt;T&gt; = AsyncIterable&lt;T&gt;[typeof Symbol.asyncIterator];</span><span class="s3">\n</span><span class="s1">type SyncIteratorFn&lt;T&gt; = Iterable&lt;T&gt;[typeof Symbol.iterator];</span><span class="s3">\n\n</span><span class="s1">export default function _asyncIterator&lt;T&gt;(</span><span class="s3">\n  </span><span class="s1">iterable: AsyncIterable&lt;T&gt; | Iterable&lt;T&gt;,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">var method: AsyncIteratorFn&lt;T&gt; | SyncIteratorFn&lt;T&gt;,</span><span class="s3">\n    </span><span class="s1">async: typeof Symbol.asyncIterator | </span><span class="s3">\&quot;</span><span class="s1">@@asyncIterator</span><span class="s3">\&quot; </span><span class="s1">| undefined,</span><span class="s3">\n    </span><span class="s1">sync: typeof Symbol.iterator | </span><span class="s3">\&quot;</span><span class="s1">@@iterator</span><span class="s3">\&quot; </span><span class="s1">| undefined,</span><span class="s3">\n    </span><span class="s1">retry = 2;</span><span class="s3">\n\n  </span><span class="s1">if (typeof Symbol !== </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">async = Symbol.asyncIterator;</span><span class="s3">\n    </span><span class="s1">sync = Symbol.iterator;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">while (retry--) {</span><span class="s3">\n    </span><span class="s1">// TypeScript doesn't have in-function narrowing, and TypeScript can't narrow</span><span class="s3">\n    </span><span class="s1">// AsyncIterable&lt;T&gt; | Iterable&lt;T&gt; down to AsyncIterable&lt;T&gt;. So let's use any here.</span><span class="s3">\n    </span><span class="s1">if (async &amp;&amp; (method = (iterable as any)[async]) != null) {</span><span class="s3">\n      </span><span class="s1">return (method as AsyncIteratorFn&lt;T&gt;).call(iterable as AsyncIterable&lt;T&gt;);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Same here, TypeScript can't narrow AsyncIterable&lt;T&gt; | Iterable&lt;T&gt; down to Iterable&lt;T&gt;.</span><span class="s3">\n    </span><span class="s1">if (sync &amp;&amp; (method = (iterable as any)[sync]) != null) {</span><span class="s3">\n      </span><span class="s1">return new AsyncFromSyncIterator(</span><span class="s3">\n        </span><span class="s1">(method as SyncIteratorFn&lt;T&gt;).call(iterable as Iterable&lt;T&gt;),</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">async = </span><span class="s3">\&quot;</span><span class="s1">@@asyncIterator</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">sync = </span><span class="s3">\&quot;</span><span class="s1">@@iterator</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">Object is not async iterable</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// AsyncFromSyncIterator is actually a class that implements AsyncIterator interface</span><span class="s3">\n</span><span class="s1">declare class AsyncFromSyncIterator&lt;T = any, TReturn = any, TNext = undefined&gt;</span><span class="s3">\n  </span><span class="s1">implements AsyncIterator&lt;T, TReturn, TNext&gt;</span><span class="s3">\n</span><span class="s1">{</span><span class="s3">\n  </span><span class="s1">s: Iterator&lt;T&gt;;</span><span class="s3">\n  </span><span class="s1">n: Iterator&lt;T&gt;[</span><span class="s3">\&quot;</span><span class="s1">next</span><span class="s3">\&quot;</span><span class="s1">];</span><span class="s3">\n  </span><span class="s1">constructor(s: Iterator&lt;T&gt;);</span><span class="s3">\n\n  </span><span class="s1">next(...args: [] | [TNext]): Promise&lt;IteratorResult&lt;T, TReturn&gt;&gt;;</span><span class="s3">\n  </span><span class="s1">return?(</span><span class="s3">\n    </span><span class="s1">value?: TReturn | PromiseLike&lt;TReturn&gt;,</span><span class="s3">\n  </span><span class="s1">): Promise&lt;IteratorResult&lt;T, TReturn&gt;&gt;;</span><span class="s3">\n  </span><span class="s1">throw?(e?: any): Promise&lt;IteratorResult&lt;T, TReturn&gt;&gt;;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Actual implementation of AsyncFromSyncIterator starts here</span><span class="s3">\n</span><span class="s1">// class only exists in ES6, so we need to use the old school way</span><span class="s3">\n</span><span class="s1">// This makes ESLint and TypeScript complain a lot, but it's the only way</span><span class="s3">\n</span><span class="s1">function AsyncFromSyncIterator&lt;T, TReturn = any, TNext = undefined&gt;(s: any) {</span><span class="s3">\n  </span><span class="s1">// @ts-expect-error - Intentionally overriding the constructor.</span><span class="s3">\n  </span><span class="s1">AsyncFromSyncIterator = function (</span><span class="s3">\n    </span><span class="s1">this: AsyncFromSyncIterator,</span><span class="s3">\n    </span><span class="s1">s: Iterator&lt;T&gt;,</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">this.s = s;</span><span class="s3">\n    </span><span class="s1">this.n = s.next;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">AsyncFromSyncIterator.prototype = {</span><span class="s3">\n    </span><span class="s1">// Initiating the </span><span class="s3">\&quot;</span><span class="s1">s</span><span class="s3">\&quot; </span><span class="s1">and </span><span class="s3">\&quot;</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">, use </span><span class="s3">\&quot;</span><span class="s1">any</span><span class="s3">\&quot; </span><span class="s1">to prevent TS from complaining</span><span class="s3">\n    </span><span class="s1">/* SyncIterator */ s: null as any,</span><span class="s3">\n    </span><span class="s1">/* SyncIterator.[[Next]] */ n: null as any,</span><span class="s3">\n    </span><span class="s1">next: function () {</span><span class="s3">\n      </span><span class="s1">return AsyncFromSyncIteratorContinuation&lt;T, TReturn&gt;(</span><span class="s3">\n        </span><span class="s1">// Use </span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot; </span><span class="s1">here for better compatibility and smaller bundle size</span><span class="s3">\n        </span><span class="s1">// Itentionally casting </span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot; </span><span class="s1">to an array for the type of func.apply</span><span class="s3">\n        </span><span class="s1">this.n.apply(this.s, arguments as any as [] | [undefined]),</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">return: function (value) {</span><span class="s3">\n      </span><span class="s1">var ret = this.s.return;</span><span class="s3">\n      </span><span class="s1">if (ret === undefined) {</span><span class="s3">\n        </span><span class="s1">return Promise.resolve&lt;IteratorReturnResult&lt;TReturn&gt;&gt;({</span><span class="s3">\n          </span><span class="s1">// </span><span class="s3">\&quot;</span><span class="s1">TReturn | PromiseLike&lt;TReturn&gt;</span><span class="s3">\&quot; </span><span class="s1">should have been unwrapped by Awaited&lt;T&gt;,</span><span class="s3">\n          </span><span class="s1">// but TypeScript choked, let's just casting it away</span><span class="s3">\n          </span><span class="s1">value: value as TReturn,</span><span class="s3">\n          </span><span class="s1">done: true,</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return AsyncFromSyncIteratorContinuation&lt;T, TReturn&gt;(</span><span class="s3">\n        </span><span class="s1">ret.apply(</span><span class="s3">\n          </span><span class="s1">this.s,</span><span class="s3">\n          </span><span class="s1">// Use </span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot; </span><span class="s1">here for better compatibility and smaller bundle size</span><span class="s3">\n          </span><span class="s1">// Itentionally casting </span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot; </span><span class="s1">to an array for the type of func.apply</span><span class="s3">\n          </span><span class="s1">arguments as any as [] | [TReturn | PromiseLike&lt;TReturn&gt;],</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">throw: function (maybeError?: any) {</span><span class="s3">\n      </span><span class="s1">var thr = this.s.return;</span><span class="s3">\n      </span><span class="s1">if (thr === undefined) {</span><span class="s3">\n        </span><span class="s1">// eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors</span><span class="s3">\n        </span><span class="s1">return Promise.reject(maybeError);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return AsyncFromSyncIteratorContinuation&lt;T, TReturn&gt;(</span><span class="s3">\n        </span><span class="s1">// Use </span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot; </span><span class="s1">here for better compatibility and smaller bundle size</span><span class="s3">\n        </span><span class="s1">// Itentionally casting </span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot; </span><span class="s1">to an array for the type of func.apply</span><span class="s3">\n        </span><span class="s1">thr.apply(this.s, arguments as any as [any]),</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">} satisfies AsyncFromSyncIterator&lt;T, TReturn, TNext&gt;;</span><span class="s3">\n\n  </span><span class="s1">function AsyncFromSyncIteratorContinuation&lt;T, TReturn&gt;(r: any) {</span><span class="s3">\n    </span><span class="s1">// This step is _before_ calling AsyncFromSyncIteratorContinuation in the spec.</span><span class="s3">\n    </span><span class="s1">if (Object(r) !== r) {</span><span class="s3">\n      </span><span class="s1">return Promise.reject(new TypeError(r + </span><span class="s3">\&quot; </span><span class="s1">is not an object.</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">var done = r.done;</span><span class="s3">\n    </span><span class="s1">return Promise.resolve(r.value).then&lt;IteratorResult&lt;T, TReturn&gt;&gt;(</span><span class="s3">\n      </span><span class="s1">function (value) {</span><span class="s3">\n        </span><span class="s1">return { value: value, done: done };</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return new AsyncFromSyncIterator(s);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;AAKe,SAASA,cAAcA,CACpCC,QAAwC,EACxC;EACA,IAAIC,MAA8C;IAChDC,KAAkE;IAClEC,IAAuD;IACvDC,KAAK,GAAG,CAAC;EAEX,IAAI,OAAOC,MAAM,KAAK,WAAW,EAAE;IACjCH,KAAK,GAAGG,MAAM,CAACC,aAAa;IAC5BH,IAAI,GAAGE,MAAM,CAACE,QAAQ;EACxB;EAEA,OAAOH,KAAK,EAAE,EAAE;IAGd,IAAIF,KAAK,IAAI,CAACD,MAAM,GAAID,QAAQ,CAASE,KAAK,CAAC,KAAK,IAAI,EAAE;MACxD,OAAQD,MAAM,CAAwBO,IAAI,CAACR,QAA4B,CAAC;IAC1E;IAEA,IAAIG,IAAI,IAAI,CAACF,MAAM,GAAID,QAAQ,CAASG,IAAI,CAAC,KAAK,IAAI,EAAE;MACtD,OAAO,IAAIM,qBAAqB,CAC7BR,MAAM,CAAuBO,IAAI,CAACR,QAAuB,CAC5D,CAAC;IACH;IAEAE,KAAK,GAAG,iBAAiB;IACzBC,IAAI,GAAG,YAAY;EACrB;EAEA,MAAM,IAAIO,SAAS,CAAC,8BAA8B,CAAC;AACrD;AAoBA,SAASD,qBAAqBA,CAAsCE,CAAM,EAAE;EAE1EF,qBAAqB,GAAG,SAAAA,CAEtBE,CAAc,EACd;IACA,IAAI,CAACA,CAAC,GAAGA,CAAC;IACV,IAAI,CAACC,CAAC,GAAGD,CAAC,CAACE,IAAI;EACjB,CAAC;EACDJ,qBAAqB,CAACK,SAAS,GAAG;IAEbH,CAAC,EAAE,IAAW;IACLC,CAAC,EAAE,IAAW;IAC1CC,IAAI,EAAE,SAAAA,CAAA,EAAY;MAChB,OAAOE,iCAAiC,CAGtC,IAAI,CAACH,CAAC,CAACI,KAAK,CAAC,IAAI,CAACL,CAAC,EAAEM,SAAoC,CAC3D,CAAC;IACH,CAAC;IACDC,MAAM,EAAE,SAAAA,CAAUC,KAAK,EAAE;MACvB,IAAIC,GAAG,GAAG,IAAI,CAACT,CAAC,CAACO,MAAM;MACvB,IAAIE,GAAG,KAAKC,SAAS,EAAE;QACrB,OAAOC,OAAO,CAACC,OAAO,CAAgC;UAGpDJ,KAAK,EAAEA,KAAgB;UACvBK,IAAI,EAAE;QACR,CAAC,CAAC;MACJ;MACA,OAAOT,iCAAiC,CACtCK,GAAG,CAACJ,KAAK,CACP,IAAI,CAACL,CAAC,EAGNM,SACF,CACF,CAAC;IACH,CAAC;IACDQ,KAAK,EAAE,SAAAA,CAAUC,UAAgB,EAAE;MACjC,IAAIC,GAAG,GAAG,IAAI,CAAChB,CAAC,CAACO,MAAM;MACvB,IAAIS,GAAG,KAAKN,SAAS,EAAE;QAErB,OAAOC,OAAO,CAACM,MAAM,CAACF,UAAU,CAAC;MACnC;MACA,OAAOX,iCAAiC,CAGtCY,GAAG,CAACX,KAAK,CAAC,IAAI,CAACL,CAAC,EAAEM,SAAyB,CAC7C,CAAC;IACH;EACF,CAAoD;EAEpD,SAASF,iCAAiCA,CAAac,CAAM,EAAE;IAE7D,IAAIC,MAAM,CAACD,CAAC,CAAC,KAAKA,CAAC,EAAE;MACnB,OAAOP,OAAO,CAACM,MAAM,CAAC,IAAIlB,SAAS,CAACmB,CAAC,GAAG,oBAAoB,CAAC,CAAC;IAChE;IAEA,IAAIL,IAAI,GAAGK,CAAC,CAACL,IAAI;IACjB,OAAOF,OAAO,CAACC,OAAO,CAACM,CAAC,CAACV,KAAK,CAAC,CAACY,IAAI,CAClC,UAAUZ,KAAK,EAAE;MACf,OAAO;QAAEA,KAAK,EAAEA,KAAK;QAAEK,IAAI,EAAEA;MAAK,CAAC;IACrC,CACF,CAAC;EACH;EAEA,OAAO,IAAIf,qBAAqB,CAACE,CAAC,CAAC;AACrC&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[]}</span></pre>
</body>
</html>