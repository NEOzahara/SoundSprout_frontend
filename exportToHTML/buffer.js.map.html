<html>
<head>
<title>buffer.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
buffer.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;Buffer&quot;</span><span class="s0">,</span><span class="s1">&quot;constructor&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;indentChar&quot;</span><span class="s0">,</span><span class="s1">&quot;_map&quot;</span><span class="s0">,</span><span class="s1">&quot;_buf&quot;</span><span class="s0">,</span><span class="s1">&quot;_str&quot;</span><span class="s0">,</span><span class="s1">&quot;_appendCount&quot;</span><span class="s0">,</span><span class="s1">&quot;_last&quot;</span><span class="s0">,</span><span class="s1">&quot;_queue&quot;</span><span class="s0">,</span><span class="s1">&quot;_queueCursor&quot;</span><span class="s0">,</span><span class="s1">&quot;_canMarkIdName&quot;</span><span class="s0">,</span><span class="s1">&quot;_indentChar&quot;</span><span class="s0">,</span><span class="s1">&quot;_fastIndentations&quot;</span><span class="s0">,</span><span class="s1">&quot;_position&quot;</span><span class="s0">,</span><span class="s1">&quot;line&quot;</span><span class="s0">,</span><span class="s1">&quot;column&quot;</span><span class="s0">,</span><span class="s1">&quot;_sourcePosition&quot;</span><span class="s0">,</span><span class="s1">&quot;identifierName&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;identifierNamePos&quot;</span><span class="s0">,</span><span class="s1">&quot;filename&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;repeat&quot;</span><span class="s0">,</span><span class="s1">&quot;_allocQueue&quot;</span><span class="s0">,</span><span class="s1">&quot;queue&quot;</span><span class="s0">,</span><span class="s1">&quot;char&quot;</span><span class="s0">,</span><span class="s1">&quot;_pushQueue&quot;</span><span class="s0">,</span><span class="s1">&quot;cursor&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;item&quot;</span><span class="s0">,</span><span class="s1">&quot;_popQueue&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;_flush&quot;</span><span class="s0">,</span><span class="s1">&quot;result&quot;</span><span class="s0">,</span><span class="s1">&quot;code&quot;</span><span class="s0">,</span><span class="s1">&quot;trimRight&quot;</span><span class="s0">,</span><span class="s1">&quot;decodedMap&quot;</span><span class="s0">,</span><span class="s1">&quot;getDecoded&quot;</span><span class="s0">,</span><span class="s1">&quot;__mergedMap&quot;</span><span class="s0">,</span><span class="s1">&quot;resultMap&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;defineProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;writable&quot;</span><span class="s0">,</span><span class="s1">&quot;rawMappings&quot;</span><span class="s0">,</span><span class="s1">&quot;mappings&quot;</span><span class="s0">,</span><span class="s1">&quot;getRawMappings&quot;</span><span class="s0">,</span><span class="s1">&quot;append&quot;</span><span class="s0">,</span><span class="s1">&quot;str&quot;</span><span class="s0">,</span><span class="s1">&quot;maybeNewline&quot;</span><span class="s0">,</span><span class="s1">&quot;_append&quot;</span><span class="s0">,</span><span class="s1">&quot;appendChar&quot;</span><span class="s0">,</span><span class="s1">&quot;_appendChar&quot;</span><span class="s0">,</span><span class="s1">&quot;sourcePosition&quot;</span><span class="s0">,</span><span class="s1">&quot;queueIndentation&quot;</span><span class="s0">,</span><span class="s1">&quot;queueCursor&quot;</span><span class="s0">,</span><span class="s1">&quot;sourcePos&quot;</span><span class="s0">,</span><span class="s1">&quot;fastIndentation&quot;</span><span class="s0">,</span><span class="s1">&quot;String&quot;</span><span class="s0">,</span><span class="s1">&quot;fromCharCode&quot;</span><span class="s0">,</span><span class="s1">&quot;_mark&quot;</span><span class="s0">,</span><span class="s1">&quot;len&quot;</span><span class="s0">,</span><span class="s1">&quot;position&quot;</span><span class="s0">,</span><span class="s1">&quot;charCodeAt&quot;</span><span class="s0">,</span><span class="s1">&quot;indexOf&quot;</span><span class="s0">,</span><span class="s1">&quot;last&quot;</span><span class="s0">,</span><span class="s1">&quot;_this$_map&quot;</span><span class="s0">,</span><span class="s1">&quot;mark&quot;</span><span class="s0">,</span><span class="s1">&quot;removeTrailingNewline&quot;</span><span class="s0">,</span><span class="s1">&quot;removeLastSemicolon&quot;</span><span class="s0">,</span><span class="s1">&quot;getLastChar&quot;</span><span class="s0">,</span><span class="s1">&quot;getNewlineCount&quot;</span><span class="s0">,</span><span class="s1">&quot;count&quot;</span><span class="s0">,</span><span class="s1">&quot;endsWithCharAndNewline&quot;</span><span class="s0">,</span><span class="s1">&quot;lastCp&quot;</span><span class="s0">,</span><span class="s1">&quot;hasContent&quot;</span><span class="s0">,</span><span class="s1">&quot;exactSource&quot;</span><span class="s0">,</span><span class="s1">&quot;loc&quot;</span><span class="s0">,</span><span class="s1">&quot;cb&quot;</span><span class="s0">,</span><span class="s1">&quot;source&quot;</span><span class="s0">,</span><span class="s1">&quot;prop&quot;</span><span class="s0">,</span><span class="s1">&quot;_normalizePosition&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceWithOffset&quot;</span><span class="s0">,</span><span class="s1">&quot;columnOffset&quot;</span><span class="s0">,</span><span class="s1">&quot;pos&quot;</span><span class="s0">,</span><span class="s1">&quot;target&quot;</span><span class="s0">,</span><span class="s1">&quot;Math&quot;</span><span class="s0">,</span><span class="s1">&quot;max&quot;</span><span class="s0">,</span><span class="s1">&quot;getCurrentColumn&quot;</span><span class="s0">,</span><span class="s1">&quot;lastIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;getCurrentLine&quot;</span><span class="s0">,</span><span class="s1">&quot;exports&quot;</span><span class="s0">,</span><span class="s1">&quot;default&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../src/buffer.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type SourceMap from </span><span class="s3">\&quot;</span><span class="s1">./source-map.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">// We inline this package</span><span class="s3">\n</span><span class="s1">// eslint-disable-next-line import/no-extraneous-dependencies</span><span class="s3">\n</span><span class="s1">import * as charcodes from </span><span class="s3">\&quot;</span><span class="s1">charcodes</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">export type Pos = {</span><span class="s3">\n  </span><span class="s1">line: number;</span><span class="s3">\n  </span><span class="s1">column: number;</span><span class="s3">\n  </span><span class="s1">index: number;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">export type Loc = {</span><span class="s3">\n  </span><span class="s1">start?: Pos;</span><span class="s3">\n  </span><span class="s1">end?: Pos;</span><span class="s3">\n  </span><span class="s1">filename?: string;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">type SourcePos = {</span><span class="s3">\n  </span><span class="s1">line: number | undefined;</span><span class="s3">\n  </span><span class="s1">column: number | undefined;</span><span class="s3">\n  </span><span class="s1">identifierName: string | undefined;</span><span class="s3">\n  </span><span class="s1">filename: string | undefined;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">type InternalSourcePos = SourcePos &amp; { identifierNamePos: Pos };</span><span class="s3">\n\n</span><span class="s1">type QueueItem = {</span><span class="s3">\n  </span><span class="s1">char: number;</span><span class="s3">\n  </span><span class="s1">repeat: number;</span><span class="s3">\n  </span><span class="s1">line: number | undefined;</span><span class="s3">\n  </span><span class="s1">column: number | undefined;</span><span class="s3">\n  </span><span class="s1">identifierName: undefined; // Not used, it always undefined.</span><span class="s3">\n  </span><span class="s1">identifierNamePos: undefined; // Not used, it always undefined.</span><span class="s3">\n  </span><span class="s1">filename: string | undefined;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export default class Buffer {</span><span class="s3">\n  </span><span class="s1">constructor(map: SourceMap | null, indentChar: string) {</span><span class="s3">\n    </span><span class="s1">this._map = map;</span><span class="s3">\n    </span><span class="s1">this._indentChar = indentChar;</span><span class="s3">\n\n    </span><span class="s1">for (let i = 0; i &lt; 64; i++) {</span><span class="s3">\n      </span><span class="s1">this._fastIndentations.push(indentChar.repeat(i));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this._allocQueue();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_map: SourceMap = null;</span><span class="s3">\n  </span><span class="s1">_buf = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">_str = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">_appendCount = 0;</span><span class="s3">\n  </span><span class="s1">_last = 0;</span><span class="s3">\n  </span><span class="s1">_queue: QueueItem[] = [];</span><span class="s3">\n  </span><span class="s1">_queueCursor = 0;</span><span class="s3">\n  </span><span class="s1">_canMarkIdName = true;</span><span class="s3">\n  </span><span class="s1">_indentChar = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">_fastIndentations: string[] = [];</span><span class="s3">\n\n  </span><span class="s1">_position = {</span><span class="s3">\n    </span><span class="s1">line: 1,</span><span class="s3">\n    </span><span class="s1">column: 0,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">_sourcePosition: InternalSourcePos = {</span><span class="s3">\n    </span><span class="s1">identifierName: undefined,</span><span class="s3">\n    </span><span class="s1">identifierNamePos: undefined,</span><span class="s3">\n    </span><span class="s1">line: undefined,</span><span class="s3">\n    </span><span class="s1">column: undefined,</span><span class="s3">\n    </span><span class="s1">filename: undefined,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">_allocQueue() {</span><span class="s3">\n    </span><span class="s1">const queue = this._queue;</span><span class="s3">\n\n    </span><span class="s1">for (let i = 0; i &lt; 16; i++) {</span><span class="s3">\n      </span><span class="s1">queue.push({</span><span class="s3">\n        </span><span class="s1">char: 0,</span><span class="s3">\n        </span><span class="s1">repeat: 1,</span><span class="s3">\n        </span><span class="s1">line: undefined,</span><span class="s3">\n        </span><span class="s1">column: undefined,</span><span class="s3">\n        </span><span class="s1">identifierName: undefined,</span><span class="s3">\n        </span><span class="s1">identifierNamePos: undefined,</span><span class="s3">\n        </span><span class="s1">filename: </span><span class="s3">\&quot;\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_pushQueue(</span><span class="s3">\n    </span><span class="s1">char: number,</span><span class="s3">\n    </span><span class="s1">repeat: number,</span><span class="s3">\n    </span><span class="s1">line: number | undefined,</span><span class="s3">\n    </span><span class="s1">column: number | undefined,</span><span class="s3">\n    </span><span class="s1">filename: string | undefined,</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">const cursor = this._queueCursor;</span><span class="s3">\n    </span><span class="s1">if (cursor === this._queue.length) {</span><span class="s3">\n      </span><span class="s1">this._allocQueue();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const item = this._queue[cursor];</span><span class="s3">\n    </span><span class="s1">item.char = char;</span><span class="s3">\n    </span><span class="s1">item.repeat = repeat;</span><span class="s3">\n    </span><span class="s1">item.line = line;</span><span class="s3">\n    </span><span class="s1">item.column = column;</span><span class="s3">\n    </span><span class="s1">item.filename = filename;</span><span class="s3">\n\n    </span><span class="s1">this._queueCursor++;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_popQueue(): QueueItem {</span><span class="s3">\n    </span><span class="s1">if (this._queueCursor === 0) {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">Cannot pop from empty queue</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this._queue[--this._queueCursor];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Get the final string output from the buffer, along with the sourcemap if one exists.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n\n  </span><span class="s1">get() {</span><span class="s3">\n    </span><span class="s1">this._flush();</span><span class="s3">\n\n    </span><span class="s1">const map = this._map;</span><span class="s3">\n    </span><span class="s1">const result = {</span><span class="s3">\n      </span><span class="s1">// Whatever trim is used here should not execute a regex against the</span><span class="s3">\n      </span><span class="s1">// source string since it may be arbitrarily large after all transformations</span><span class="s3">\n      </span><span class="s1">code: (this._buf + this._str).trimRight(),</span><span class="s3">\n      </span><span class="s1">// Decoded sourcemap is free to generate.</span><span class="s3">\n      </span><span class="s1">decodedMap: map?.getDecoded(),</span><span class="s3">\n      </span><span class="s1">// Used as a marker for backwards compatibility. We moved input map merging</span><span class="s3">\n      </span><span class="s1">// into the generator. We cannot merge the input map a second time, so the</span><span class="s3">\n      </span><span class="s1">// presence of this field tells us we've already done the work.</span><span class="s3">\n      </span><span class="s1">get __mergedMap() {</span><span class="s3">\n        </span><span class="s1">return this.map;</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">// Encoding the sourcemap is moderately CPU expensive.</span><span class="s3">\n      </span><span class="s1">get map() {</span><span class="s3">\n        </span><span class="s1">const resultMap = map ? map.get() : null;</span><span class="s3">\n        </span><span class="s1">result.map = resultMap;</span><span class="s3">\n        </span><span class="s1">return resultMap;</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">set map(value) {</span><span class="s3">\n        </span><span class="s1">Object.defineProperty(result, </span><span class="s3">\&quot;</span><span class="s1">map</span><span class="s3">\&quot;</span><span class="s1">, { value, writable: true });</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">// Retrieving the raw mappings is very memory intensive.</span><span class="s3">\n      </span><span class="s1">get rawMappings() {</span><span class="s3">\n        </span><span class="s1">const mappings = map?.getRawMappings();</span><span class="s3">\n        </span><span class="s1">result.rawMappings = mappings;</span><span class="s3">\n        </span><span class="s1">return mappings;</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">set rawMappings(value) {</span><span class="s3">\n        </span><span class="s1">Object.defineProperty(result, </span><span class="s3">\&quot;</span><span class="s1">rawMappings</span><span class="s3">\&quot;</span><span class="s1">, { value, writable: true });</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n\n    </span><span class="s1">return result;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Add a string to the buffer that cannot be reverted.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n\n  </span><span class="s1">append(str: string, maybeNewline: boolean): void {</span><span class="s3">\n    </span><span class="s1">this._flush();</span><span class="s3">\n\n    </span><span class="s1">this._append(str, this._sourcePosition, maybeNewline);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">appendChar(char: number): void {</span><span class="s3">\n    </span><span class="s1">this._flush();</span><span class="s3">\n    </span><span class="s1">this._appendChar(char, 1, this._sourcePosition);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Add a string to the buffer than can be reverted.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">queue(char: number): void {</span><span class="s3">\n    </span><span class="s1">// Drop trailing spaces when a newline is inserted.</span><span class="s3">\n    </span><span class="s1">if (char === charcodes.lineFeed) {</span><span class="s3">\n      </span><span class="s1">while (this._queueCursor !== 0) {</span><span class="s3">\n        </span><span class="s1">const char = this._queue[this._queueCursor - 1].char;</span><span class="s3">\n        </span><span class="s1">if (char !== charcodes.space &amp;&amp; char !== charcodes.tab) {</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">this._queueCursor--;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const sourcePosition = this._sourcePosition;</span><span class="s3">\n    </span><span class="s1">this._pushQueue(</span><span class="s3">\n      </span><span class="s1">char,</span><span class="s3">\n      </span><span class="s1">1,</span><span class="s3">\n      </span><span class="s1">sourcePosition.line,</span><span class="s3">\n      </span><span class="s1">sourcePosition.column,</span><span class="s3">\n      </span><span class="s1">sourcePosition.filename,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Same as queue, but this indentation will never have a sourcemap marker.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">queueIndentation(repeat: number): void {</span><span class="s3">\n    </span><span class="s1">if (repeat === 0) return;</span><span class="s3">\n    </span><span class="s1">this._pushQueue(-1, repeat, undefined, undefined, undefined);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_flush(): void {</span><span class="s3">\n    </span><span class="s1">const queueCursor = this._queueCursor;</span><span class="s3">\n    </span><span class="s1">const queue = this._queue;</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; queueCursor; i++) {</span><span class="s3">\n      </span><span class="s1">const item: QueueItem = queue[i];</span><span class="s3">\n      </span><span class="s1">this._appendChar(item.char, item.repeat, item);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this._queueCursor = 0;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_appendChar(</span><span class="s3">\n    </span><span class="s1">char: number,</span><span class="s3">\n    </span><span class="s1">repeat: number,</span><span class="s3">\n    </span><span class="s1">sourcePos: InternalSourcePos,</span><span class="s3">\n  </span><span class="s1">): void {</span><span class="s3">\n    </span><span class="s1">this._last = char;</span><span class="s3">\n\n    </span><span class="s1">if (char === -1) {</span><span class="s3">\n      </span><span class="s1">const fastIndentation = this._fastIndentations[repeat];</span><span class="s3">\n      </span><span class="s1">if (fastIndentation !== undefined) {</span><span class="s3">\n        </span><span class="s1">this._str += fastIndentation;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">this._str +=</span><span class="s3">\n          </span><span class="s1">repeat &gt; 1 ? this._indentChar.repeat(repeat) : this._indentChar;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">this._str +=</span><span class="s3">\n        </span><span class="s1">repeat &gt; 1</span><span class="s3">\n          </span><span class="s1">? String.fromCharCode(char).repeat(repeat)</span><span class="s3">\n          </span><span class="s1">: String.fromCharCode(char);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (char !== charcodes.lineFeed) {</span><span class="s3">\n      </span><span class="s1">this._mark(</span><span class="s3">\n        </span><span class="s1">sourcePos.line,</span><span class="s3">\n        </span><span class="s1">sourcePos.column,</span><span class="s3">\n        </span><span class="s1">sourcePos.identifierName,</span><span class="s3">\n        </span><span class="s1">sourcePos.identifierNamePos,</span><span class="s3">\n        </span><span class="s1">sourcePos.filename,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">this._position.column += repeat;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">this._position.line++;</span><span class="s3">\n      </span><span class="s1">this._position.column = 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (this._canMarkIdName) {</span><span class="s3">\n      </span><span class="s1">sourcePos.identifierName = undefined;</span><span class="s3">\n      </span><span class="s1">sourcePos.identifierNamePos = undefined;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_append(</span><span class="s3">\n    </span><span class="s1">str: string,</span><span class="s3">\n    </span><span class="s1">sourcePos: InternalSourcePos,</span><span class="s3">\n    </span><span class="s1">maybeNewline: boolean,</span><span class="s3">\n  </span><span class="s1">): void {</span><span class="s3">\n    </span><span class="s1">const len = str.length;</span><span class="s3">\n    </span><span class="s1">const position = this._position;</span><span class="s3">\n\n    </span><span class="s1">this._last = str.charCodeAt(len - 1);</span><span class="s3">\n\n    </span><span class="s1">if (++this._appendCount &gt; 4096) {</span><span class="s3">\n      </span><span class="s1">// eslint-disable-next-line @typescript-eslint/no-unused-expressions</span><span class="s3">\n      </span><span class="s1">+this._str; // Unexplainable huge performance boost. Ref: https://github.com/davidmarkclements/flatstr License: MIT</span><span class="s3">\n      </span><span class="s1">this._buf += this._str;</span><span class="s3">\n      </span><span class="s1">this._str = str;</span><span class="s3">\n      </span><span class="s1">this._appendCount = 0;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">this._str += str;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (!maybeNewline &amp;&amp; !this._map) {</span><span class="s3">\n      </span><span class="s1">position.column += len;</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const { column, identifierName, identifierNamePos, filename } = sourcePos;</span><span class="s3">\n    </span><span class="s1">let line = sourcePos.line;</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">(identifierName != null || identifierNamePos != null) &amp;&amp;</span><span class="s3">\n      </span><span class="s1">this._canMarkIdName</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">sourcePos.identifierName = undefined;</span><span class="s3">\n      </span><span class="s1">sourcePos.identifierNamePos = undefined;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Search for newline chars. We search only for `</span><span class="s3">\\</span><span class="s1">n`, since both `</span><span class="s3">\\</span><span class="s1">r` and</span><span class="s3">\n    </span><span class="s1">// `</span><span class="s3">\\</span><span class="s1">r</span><span class="s3">\\</span><span class="s1">n` are normalized to `</span><span class="s3">\\</span><span class="s1">n` during parse. We exclude `</span><span class="s3">\\</span><span class="s1">u2028` and</span><span class="s3">\n    </span><span class="s1">// `</span><span class="s3">\\</span><span class="s1">u2029` for performance reasons, they're so uncommon that it's probably</span><span class="s3">\n    </span><span class="s1">// ok. It's also unclear how other sourcemap utilities handle them...</span><span class="s3">\n    </span><span class="s1">let i = str.indexOf(</span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">let last = 0;</span><span class="s3">\n\n    </span><span class="s1">// If the string starts with a newline char, then adding a mark is redundant.</span><span class="s3">\n    </span><span class="s1">// This catches both </span><span class="s3">\&quot;</span><span class="s1">no newlines</span><span class="s3">\&quot; </span><span class="s1">and </span><span class="s3">\&quot;</span><span class="s1">newline after several chars</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\n    </span><span class="s1">if (i !== 0) {</span><span class="s3">\n      </span><span class="s1">this._mark(line, column, identifierName, identifierNamePos, filename);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Now, find each remaining newline char in the string.</span><span class="s3">\n    </span><span class="s1">while (i !== -1) {</span><span class="s3">\n      </span><span class="s1">position.line++;</span><span class="s3">\n      </span><span class="s1">position.column = 0;</span><span class="s3">\n      </span><span class="s1">last = i + 1;</span><span class="s3">\n\n      </span><span class="s1">// We mark the start of each line, which happens directly after this newline char</span><span class="s3">\n      </span><span class="s1">// unless this is the last char.</span><span class="s3">\n      </span><span class="s1">// When manually adding multi-line content (such as a comment), `line` will be `undefined`.</span><span class="s3">\n      </span><span class="s1">if (last &lt; len &amp;&amp; line !== undefined) {</span><span class="s3">\n        </span><span class="s1">this._mark(++line, 0, null, null, filename);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">i = str.indexOf(</span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">, last);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">position.column += len - last;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_mark(</span><span class="s3">\n    </span><span class="s1">line: number | undefined,</span><span class="s3">\n    </span><span class="s1">column: number | undefined,</span><span class="s3">\n    </span><span class="s1">identifierName: string | undefined,</span><span class="s3">\n    </span><span class="s1">identifierNamePos: Pos | undefined,</span><span class="s3">\n    </span><span class="s1">filename: string | undefined,</span><span class="s3">\n  </span><span class="s1">): void {</span><span class="s3">\n    </span><span class="s1">this._map?.mark(</span><span class="s3">\n      </span><span class="s1">this._position,</span><span class="s3">\n      </span><span class="s1">line,</span><span class="s3">\n      </span><span class="s1">column,</span><span class="s3">\n      </span><span class="s1">identifierName,</span><span class="s3">\n      </span><span class="s1">identifierNamePos,</span><span class="s3">\n      </span><span class="s1">filename,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">removeTrailingNewline(): void {</span><span class="s3">\n    </span><span class="s1">const queueCursor = this._queueCursor;</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">queueCursor !== 0 &amp;&amp;</span><span class="s3">\n      </span><span class="s1">this._queue[queueCursor - 1].char === charcodes.lineFeed</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">this._queueCursor--;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">removeLastSemicolon(): void {</span><span class="s3">\n    </span><span class="s1">const queueCursor = this._queueCursor;</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">queueCursor !== 0 &amp;&amp;</span><span class="s3">\n      </span><span class="s1">this._queue[queueCursor - 1].char === charcodes.semicolon</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">this._queueCursor--;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">getLastChar(): number {</span><span class="s3">\n    </span><span class="s1">const queueCursor = this._queueCursor;</span><span class="s3">\n    </span><span class="s1">return queueCursor !== 0 ? this._queue[queueCursor - 1].char : this._last;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* This will only detect at most 1 newline after a call to `flush()`,</span><span class="s3">\n   </span><span class="s1">* but this has not been found so far, and an accurate count can be achieved if needed later.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">getNewlineCount(): number {</span><span class="s3">\n    </span><span class="s1">const queueCursor = this._queueCursor;</span><span class="s3">\n    </span><span class="s1">let count = 0;</span><span class="s3">\n    </span><span class="s1">if (queueCursor === 0) return this._last === charcodes.lineFeed ? 1 : 0;</span><span class="s3">\n    </span><span class="s1">for (let i = queueCursor - 1; i &gt;= 0; i--) {</span><span class="s3">\n      </span><span class="s1">if (this._queue[i].char !== charcodes.lineFeed) {</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">count++;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return count === queueCursor &amp;&amp; this._last === charcodes.lineFeed</span><span class="s3">\n      </span><span class="s1">? count + 1</span><span class="s3">\n      </span><span class="s1">: count;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* check if current _last + queue ends with newline, return the character before newline</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">endsWithCharAndNewline(): number {</span><span class="s3">\n    </span><span class="s1">const queue = this._queue;</span><span class="s3">\n    </span><span class="s1">const queueCursor = this._queueCursor;</span><span class="s3">\n    </span><span class="s1">if (queueCursor !== 0) {</span><span class="s3">\n      </span><span class="s1">// every element in queue is one-length whitespace string</span><span class="s3">\n      </span><span class="s1">const lastCp = queue[queueCursor - 1].char;</span><span class="s3">\n      </span><span class="s1">if (lastCp !== charcodes.lineFeed) return;</span><span class="s3">\n      </span><span class="s1">if (queueCursor &gt; 1) {</span><span class="s3">\n        </span><span class="s1">return queue[queueCursor - 2].char;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">return this._last;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// We assume that everything being matched is at most a single token plus some whitespace,</span><span class="s3">\n    </span><span class="s1">// which everything currently is, but otherwise we'd have to expand _last or check _buf.</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">hasContent(): boolean {</span><span class="s3">\n    </span><span class="s1">return this._queueCursor !== 0 || !!this._last;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Certain sourcemap usecases expect mappings to be more accurate than</span><span class="s3">\n   </span><span class="s1">* Babel's generic sourcemap handling allows. For now, we special-case</span><span class="s3">\n   </span><span class="s1">* identifiers to allow for the primary cases to work.</span><span class="s3">\n   </span><span class="s1">* The goal of this line is to ensure that the map output from Babel will</span><span class="s3">\n   </span><span class="s1">* have an exact range on identifiers in the output code. Without this</span><span class="s3">\n   </span><span class="s1">* line, Babel would potentially include some number of trailing tokens</span><span class="s3">\n   </span><span class="s1">* that are printed after the identifier, but before another location has</span><span class="s3">\n   </span><span class="s1">* been assigned.</span><span class="s3">\n   </span><span class="s1">* This allows tooling like Rollup and Webpack to more accurately perform</span><span class="s3">\n   </span><span class="s1">* their own transformations. Most importantly, this allows the import/export</span><span class="s3">\n   </span><span class="s1">* transformations performed by those tools to loose less information when</span><span class="s3">\n   </span><span class="s1">* applying their own transformations on top of the code and map results</span><span class="s3">\n   </span><span class="s1">* generated by Babel itself.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* The primary example of this is the snippet:</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">*   import mod from </span><span class="s3">\&quot;</span><span class="s1">mod</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n   </span><span class="s1">*   mod();</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* With this line, there will be one mapping range over </span><span class="s3">\&quot;</span><span class="s1">mod</span><span class="s3">\&quot; </span><span class="s1">and another</span><span class="s3">\n   </span><span class="s1">* over </span><span class="s3">\&quot;</span><span class="s1">();</span><span class="s3">\&quot;</span><span class="s1">, where previously it would have been a single mapping.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">exactSource(loc: Loc | undefined, cb: () =&gt; void) {</span><span class="s3">\n    </span><span class="s1">if (!this._map) {</span><span class="s3">\n      </span><span class="s1">cb();</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this.source(</span><span class="s3">\&quot;</span><span class="s1">start</span><span class="s3">\&quot;</span><span class="s1">, loc);</span><span class="s3">\n    </span><span class="s1">// @ts-expect-error identifierName is not defined</span><span class="s3">\n    </span><span class="s1">const identifierName = loc.identifierName;</span><span class="s3">\n    </span><span class="s1">const sourcePos = this._sourcePosition;</span><span class="s3">\n    </span><span class="s1">if (identifierName) {</span><span class="s3">\n      </span><span class="s1">this._canMarkIdName = false;</span><span class="s3">\n      </span><span class="s1">sourcePos.identifierName = identifierName;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">cb();</span><span class="s3">\n\n    </span><span class="s1">if (identifierName) {</span><span class="s3">\n      </span><span class="s1">this._canMarkIdName = true;</span><span class="s3">\n      </span><span class="s1">sourcePos.identifierName = undefined;</span><span class="s3">\n      </span><span class="s1">sourcePos.identifierNamePos = undefined;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.source(</span><span class="s3">\&quot;</span><span class="s1">end</span><span class="s3">\&quot;</span><span class="s1">, loc);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Sets a given position as the current source location so generated code after this call</span><span class="s3">\n   </span><span class="s1">* will be given this position in the sourcemap.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n\n  </span><span class="s1">source(prop: </span><span class="s3">\&quot;</span><span class="s1">start</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">end</span><span class="s3">\&quot;</span><span class="s1">, loc: Loc | undefined): void {</span><span class="s3">\n    </span><span class="s1">if (!this._map) return;</span><span class="s3">\n\n    </span><span class="s1">// Since this is called extremely often, we reuse the same _sourcePosition</span><span class="s3">\n    </span><span class="s1">// object for the whole lifetime of the buffer.</span><span class="s3">\n    </span><span class="s1">this._normalizePosition(prop, loc, 0);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">sourceWithOffset(</span><span class="s3">\n    </span><span class="s1">prop: </span><span class="s3">\&quot;</span><span class="s1">start</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">end</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">loc: Loc | undefined,</span><span class="s3">\n    </span><span class="s1">columnOffset: number,</span><span class="s3">\n  </span><span class="s1">): void {</span><span class="s3">\n    </span><span class="s1">if (!this._map) return;</span><span class="s3">\n\n    </span><span class="s1">this._normalizePosition(prop, loc, columnOffset);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_normalizePosition(prop: </span><span class="s3">\&quot;</span><span class="s1">start</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">end</span><span class="s3">\&quot;</span><span class="s1">, loc: Loc, columnOffset: number) {</span><span class="s3">\n    </span><span class="s1">const pos = loc[prop];</span><span class="s3">\n    </span><span class="s1">const target = this._sourcePosition;</span><span class="s3">\n\n    </span><span class="s1">if (pos) {</span><span class="s3">\n      </span><span class="s1">target.line = pos.line;</span><span class="s3">\n      </span><span class="s1">// TODO: Fix https://github.com/babel/babel/issues/15712 in downstream</span><span class="s3">\n      </span><span class="s1">target.column = Math.max(pos.column + columnOffset, 0);</span><span class="s3">\n      </span><span class="s1">target.filename = loc.filename;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">getCurrentColumn(): number {</span><span class="s3">\n    </span><span class="s1">const queue = this._queue;</span><span class="s3">\n    </span><span class="s1">const queueCursor = this._queueCursor;</span><span class="s3">\n\n    </span><span class="s1">let lastIndex = -1;</span><span class="s3">\n    </span><span class="s1">let len = 0;</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; queueCursor; i++) {</span><span class="s3">\n      </span><span class="s1">const item = queue[i];</span><span class="s3">\n      </span><span class="s1">if (item.char === charcodes.lineFeed) {</span><span class="s3">\n        </span><span class="s1">lastIndex = len;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">len += item.repeat;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return lastIndex === -1 ? this._position.column + len : len - 1 - lastIndex;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">getCurrentLine(): number {</span><span class="s3">\n    </span><span class="s1">let count = 0;</span><span class="s3">\n\n    </span><span class="s1">const queue = this._queue;</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; this._queueCursor; i++) {</span><span class="s3">\n      </span><span class="s1">if (queue[i].char === charcodes.lineFeed) {</span><span class="s3">\n        </span><span class="s1">count++;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return this._position.line + count;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[]}</span></pre>
</body>
</html>