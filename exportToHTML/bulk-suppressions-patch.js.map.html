<html>
<head>
<title>bulk-suppressions-patch.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
bulk-suppressions-patch.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;bulk-suppressions-patch.js&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceRoot&quot;</span><span class="s0">:</span><span class="s1">&quot;&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../src/eslint-bulk-suppressions/bulk-suppressions-patch.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.</span><span class="s3">\n</span><span class="s1">// See LICENSE in the project root for license information.</span><span class="s3">\n\n</span><span class="s1">import type { TSESTree } from '@typescript-eslint/types';</span><span class="s3">\n</span><span class="s1">import fs from 'fs';</span><span class="s3">\n\n</span><span class="s1">import * as Guards from './ast-guards';</span><span class="s3">\n\n</span><span class="s1">import { eslintFolder } from '../_patch-base';</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">ESLINT_BULK_ENABLE_ENV_VAR_NAME,</span><span class="s3">\n  </span><span class="s1">ESLINT_BULK_PRUNE_ENV_VAR_NAME,</span><span class="s3">\n  </span><span class="s1">ESLINT_BULK_SUPPRESS_ENV_VAR_NAME</span><span class="s3">\n</span><span class="s1">} from './constants';</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">getSuppressionsConfigForEslintrcFolderPath,</span><span class="s3">\n  </span><span class="s1">serializeSuppression,</span><span class="s3">\n  </span><span class="s1">type IBulkSuppressionsConfig,</span><span class="s3">\n  </span><span class="s1">type ISuppression,</span><span class="s3">\n  </span><span class="s1">writeSuppressionsJsonToFile,</span><span class="s3">\n  </span><span class="s1">getAllBulkSuppressionsConfigsByEslintrcFolderPath</span><span class="s3">\n</span><span class="s1">} from './bulk-suppressions-file';</span><span class="s3">\n\n</span><span class="s1">const ESLINTRC_FILENAMES: string[] = [</span><span class="s3">\n  </span><span class="s1">'.eslintrc.js',</span><span class="s3">\n  </span><span class="s1">'.eslintrc.cjs'</span><span class="s3">\n  </span><span class="s1">// Several other filenames are allowed, but this patch requires that it be loaded via a JS config file,</span><span class="s3">\n  </span><span class="s1">// so we only need to check for the JS-based filenames</span><span class="s3">\n</span><span class="s1">];</span><span class="s3">\n</span><span class="s1">const SUPPRESSION_SYMBOL: unique symbol = Symbol('suppression');</span><span class="s3">\n</span><span class="s1">const ESLINT_BULK_SUPPRESS_ENV_VAR_VALUE: string | undefined = process.env[ESLINT_BULK_SUPPRESS_ENV_VAR_NAME];</span><span class="s3">\n</span><span class="s1">const SUPPRESS_ALL_RULES: boolean = ESLINT_BULK_SUPPRESS_ENV_VAR_VALUE === '*';</span><span class="s3">\n</span><span class="s1">const RULES_TO_SUPPRESS: Set&lt;string&gt; | undefined = ESLINT_BULK_SUPPRESS_ENV_VAR_VALUE</span><span class="s3">\n  </span><span class="s1">? new Set(ESLINT_BULK_SUPPRESS_ENV_VAR_VALUE.split(','))</span><span class="s3">\n  </span><span class="s1">: undefined;</span><span class="s3">\n\n</span><span class="s1">interface IProblem {</span><span class="s3">\n  </span><span class="s1">[SUPPRESSION_SYMBOL]?: {</span><span class="s3">\n    </span><span class="s1">config: IBulkSuppressionsConfig;</span><span class="s3">\n    </span><span class="s1">suppression: ISuppression;</span><span class="s3">\n    </span><span class="s1">serializedSuppression: string;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function getNodeName(node: TSESTree.Node): string | undefined {</span><span class="s3">\n  </span><span class="s1">if (Guards.isClassDeclarationWithName(node)) {</span><span class="s3">\n    </span><span class="s1">return node.id.name;</span><span class="s3">\n  </span><span class="s1">} else if (Guards.isFunctionDeclarationWithName(node)) {</span><span class="s3">\n    </span><span class="s1">return node.id.name;</span><span class="s3">\n  </span><span class="s1">} else if (Guards.isClassExpressionWithName(node)) {</span><span class="s3">\n    </span><span class="s1">return node.id.name;</span><span class="s3">\n  </span><span class="s1">} else if (Guards.isFunctionExpressionWithName(node)) {</span><span class="s3">\n    </span><span class="s1">return node.id.name;</span><span class="s3">\n  </span><span class="s1">} else if (Guards.isNormalVariableDeclaratorWithAnonymousExpressionAssigned(node)) {</span><span class="s3">\n    </span><span class="s1">return node.id.name;</span><span class="s3">\n  </span><span class="s1">} else if (Guards.isNormalObjectPropertyWithAnonymousExpressionAssigned(node)) {</span><span class="s3">\n    </span><span class="s1">return node.key.name;</span><span class="s3">\n  </span><span class="s1">} else if (Guards.isNormalClassPropertyDefinitionWithAnonymousExpressionAssigned(node)) {</span><span class="s3">\n    </span><span class="s1">return node.key.name;</span><span class="s3">\n  </span><span class="s1">} else if (Guards.isNormalAssignmentPatternWithAnonymousExpressionAssigned(node)) {</span><span class="s3">\n    </span><span class="s1">return node.left.name;</span><span class="s3">\n  </span><span class="s1">} else if (Guards.isNormalMethodDefinition(node)) {</span><span class="s3">\n    </span><span class="s1">return node.key.name;</span><span class="s3">\n  </span><span class="s1">} else if (Guards.isTSEnumDeclaration(node)) {</span><span class="s3">\n    </span><span class="s1">return node.id.name;</span><span class="s3">\n  </span><span class="s1">} else if (Guards.isTSInterfaceDeclaration(node)) {</span><span class="s3">\n    </span><span class="s1">return node.id.name;</span><span class="s3">\n  </span><span class="s1">} else if (Guards.isTSTypeAliasDeclaration(node)) {</span><span class="s3">\n    </span><span class="s1">return node.id.name;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type NodeWithParent = TSESTree.Node &amp; { parent?: TSESTree.Node };</span><span class="s3">\n\n</span><span class="s1">function calculateScopeId(node: NodeWithParent | undefined): string {</span><span class="s3">\n  </span><span class="s1">const scopeIds: string[] = [];</span><span class="s3">\n  </span><span class="s1">for (let current: NodeWithParent | undefined = node; current; current = current.parent) {</span><span class="s3">\n    </span><span class="s1">const scopeIdForASTNode: string | undefined = getNodeName(current);</span><span class="s3">\n    </span><span class="s1">if (scopeIdForASTNode !== undefined) {</span><span class="s3">\n      </span><span class="s1">scopeIds.unshift(scopeIdForASTNode);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (scopeIds.length === 0) {</span><span class="s3">\n    </span><span class="s1">return '.';</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return '.' + scopeIds.join('.');</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const eslintrcPathByFileOrFolderPath: Map&lt;string, string&gt; = new Map();</span><span class="s3">\n\n</span><span class="s1">function findEslintrcFolderPathForNormalizedFileAbsolutePath(normalizedFilePath: string): string {</span><span class="s3">\n  </span><span class="s1">const cachedFolderPathForFilePath: string | undefined =</span><span class="s3">\n    </span><span class="s1">eslintrcPathByFileOrFolderPath.get(normalizedFilePath);</span><span class="s3">\n  </span><span class="s1">if (cachedFolderPathForFilePath) {</span><span class="s3">\n    </span><span class="s1">return cachedFolderPathForFilePath;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const normalizedFileFolderPath: string = normalizedFilePath.substring(</span><span class="s3">\n    </span><span class="s1">0,</span><span class="s3">\n    </span><span class="s1">normalizedFilePath.lastIndexOf('/')</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n\n  </span><span class="s1">const pathsToCache: string[] = [normalizedFilePath];</span><span class="s3">\n  </span><span class="s1">let eslintrcFolderPath: string | undefined;</span><span class="s3">\n  </span><span class="s1">findEslintrcFileLoop: for (</span><span class="s3">\n    </span><span class="s1">let currentFolder: string = normalizedFileFolderPath;</span><span class="s3">\n    </span><span class="s1">currentFolder; // 'something'.substring(0, -1) is ''</span><span class="s3">\n    </span><span class="s1">currentFolder = currentFolder.substring(0, currentFolder.lastIndexOf('/'))</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">const cachedEslintrcFolderPath: string | undefined = eslintrcPathByFileOrFolderPath.get(currentFolder);</span><span class="s3">\n    </span><span class="s1">if (cachedEslintrcFolderPath) {</span><span class="s3">\n      </span><span class="s1">// Need to cache this result into the intermediate paths</span><span class="s3">\n      </span><span class="s1">eslintrcFolderPath = cachedEslintrcFolderPath;</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">pathsToCache.push(currentFolder);</span><span class="s3">\n    </span><span class="s1">for (const eslintrcFilename of ESLINTRC_FILENAMES) {</span><span class="s3">\n      </span><span class="s1">if (fs.existsSync(`${currentFolder}/${eslintrcFilename}`)) {</span><span class="s3">\n        </span><span class="s1">eslintrcFolderPath = currentFolder;</span><span class="s3">\n        </span><span class="s1">break findEslintrcFileLoop;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (eslintrcFolderPath) {</span><span class="s3">\n    </span><span class="s1">for (const checkedFolder of pathsToCache) {</span><span class="s3">\n      </span><span class="s1">eslintrcPathByFileOrFolderPath.set(checkedFolder, eslintrcFolderPath);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return eslintrcFolderPath;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">throw new Error(`Cannot locate an ESLint configuration file for ${normalizedFilePath}`);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// One-line insert into the ruleContext report method to prematurely exit if the ESLint problem has been suppressed</span><span class="s3">\n</span><span class="s1">export function shouldBulkSuppress(params: {</span><span class="s3">\n  </span><span class="s1">filename: string;</span><span class="s3">\n  </span><span class="s1">currentNode: TSESTree.Node;</span><span class="s3">\n  </span><span class="s1">ruleId: string;</span><span class="s3">\n  </span><span class="s1">problem: IProblem;</span><span class="s3">\n</span><span class="s1">}): boolean {</span><span class="s3">\n  </span><span class="s1">// Use this ENV variable to turn off eslint-bulk-suppressions functionality, default behavior is on</span><span class="s3">\n  </span><span class="s1">if (process.env[ESLINT_BULK_ENABLE_ENV_VAR_NAME] === 'false') {</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const { filename: fileAbsolutePath, currentNode, ruleId: rule, problem } = params;</span><span class="s3">\n  </span><span class="s1">const normalizedFileAbsolutePath: string = fileAbsolutePath.replace(/</span><span class="s3">\\\\</span><span class="s1">/g, '/');</span><span class="s3">\n  </span><span class="s1">const eslintrcDirectory: string =</span><span class="s3">\n    </span><span class="s1">findEslintrcFolderPathForNormalizedFileAbsolutePath(normalizedFileAbsolutePath);</span><span class="s3">\n  </span><span class="s1">const fileRelativePath: string = normalizedFileAbsolutePath.substring(eslintrcDirectory.length + 1);</span><span class="s3">\n  </span><span class="s1">const scopeId: string = calculateScopeId(currentNode);</span><span class="s3">\n  </span><span class="s1">const suppression: ISuppression = { file: fileRelativePath, scopeId, rule };</span><span class="s3">\n\n  </span><span class="s1">const config: IBulkSuppressionsConfig = getSuppressionsConfigForEslintrcFolderPath(eslintrcDirectory);</span><span class="s3">\n  </span><span class="s1">const serializedSuppression: string = serializeSuppression(suppression);</span><span class="s3">\n  </span><span class="s1">const currentNodeIsSuppressed: boolean = config.serializedSuppressions.has(serializedSuppression);</span><span class="s3">\n\n  </span><span class="s1">if (currentNodeIsSuppressed || SUPPRESS_ALL_RULES || RULES_TO_SUPPRESS?.has(suppression.rule)) {</span><span class="s3">\n    </span><span class="s1">problem[SUPPRESSION_SYMBOL] = {</span><span class="s3">\n      </span><span class="s1">suppression,</span><span class="s3">\n      </span><span class="s1">serializedSuppression,</span><span class="s3">\n      </span><span class="s1">config</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return process.env[ESLINT_BULK_PRUNE_ENV_VAR_NAME] !== '1' &amp;&amp; currentNodeIsSuppressed;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function prune(): void {</span><span class="s3">\n  </span><span class="s1">for (const [</span><span class="s3">\n    </span><span class="s1">eslintrcFolderPath,</span><span class="s3">\n    </span><span class="s1">suppressionsConfig</span><span class="s3">\n  </span><span class="s1">] of getAllBulkSuppressionsConfigsByEslintrcFolderPath()) {</span><span class="s3">\n    </span><span class="s1">if (suppressionsConfig) {</span><span class="s3">\n      </span><span class="s1">const { newSerializedSuppressions, newJsonObject } = suppressionsConfig;</span><span class="s3">\n      </span><span class="s1">const newSuppressionsConfig: IBulkSuppressionsConfig = {</span><span class="s3">\n        </span><span class="s1">serializedSuppressions: newSerializedSuppressions,</span><span class="s3">\n        </span><span class="s1">jsonObject: newJsonObject,</span><span class="s3">\n        </span><span class="s1">newSerializedSuppressions: new Set(),</span><span class="s3">\n        </span><span class="s1">newJsonObject: { suppressions: [] }</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n\n      </span><span class="s1">writeSuppressionsJsonToFile(eslintrcFolderPath, newSuppressionsConfig);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function write(): void {</span><span class="s3">\n  </span><span class="s1">for (const [</span><span class="s3">\n    </span><span class="s1">eslintrcFolderPath,</span><span class="s3">\n    </span><span class="s1">suppressionsConfig</span><span class="s3">\n  </span><span class="s1">] of getAllBulkSuppressionsConfigsByEslintrcFolderPath()) {</span><span class="s3">\n    </span><span class="s1">if (suppressionsConfig) {</span><span class="s3">\n      </span><span class="s1">writeSuppressionsJsonToFile(eslintrcFolderPath, suppressionsConfig);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// utility function for linter-patch.js to make require statements that use relative paths in linter.js work in linter-patch.js</span><span class="s3">\n</span><span class="s1">export function requireFromPathToLinterJS(importPath: string): import('eslint').Linter {</span><span class="s3">\n  </span><span class="s1">if (!eslintFolder) {</span><span class="s3">\n    </span><span class="s1">return require(importPath);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const pathToLinterFolder: string = `${eslintFolder}/lib/linter`;</span><span class="s3">\n  </span><span class="s1">const moduleAbsolutePath: string = require.resolve(importPath, { paths: [pathToLinterFolder] });</span><span class="s3">\n  </span><span class="s1">return require(moduleAbsolutePath);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function patchClass&lt;T, U extends T&gt;(originalClass: new () =&gt; T, patchedClass: new () =&gt; U): void {</span><span class="s3">\n  </span><span class="s1">// Get all the property names of the patched class prototype</span><span class="s3">\n  </span><span class="s1">const patchedProperties: string[] = Object.getOwnPropertyNames(patchedClass.prototype);</span><span class="s3">\n\n  </span><span class="s1">// Loop through all the properties</span><span class="s3">\n  </span><span class="s1">for (const prop of patchedProperties) {</span><span class="s3">\n    </span><span class="s1">// Override the property in the original class</span><span class="s3">\n    </span><span class="s1">originalClass.prototype[prop] = patchedClass.prototype[prop];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Handle getters and setters</span><span class="s3">\n  </span><span class="s1">for (const [prop, descriptor] of Object.entries(Object.getOwnPropertyDescriptors(patchedClass.prototype))) {</span><span class="s3">\n    </span><span class="s1">if (descriptor.get || descriptor.set) {</span><span class="s3">\n      </span><span class="s1">Object.defineProperty(originalClass.prototype, prop, descriptor);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This returns a wrapped version of the </span><span class="s3">\&quot;</span><span class="s1">verify</span><span class="s3">\&quot; </span><span class="s1">function from ESLint's Linter class</span><span class="s3">\n </span><span class="s1">* that postprocesses rule violations that weren't suppressed by comments. This postprocessing</span><span class="s3">\n </span><span class="s1">* records suppressions that weren't otherwise suppressed by comments to be used</span><span class="s3">\n </span><span class="s1">* by the </span><span class="s3">\&quot;</span><span class="s1">suppress</span><span class="s3">\&quot; </span><span class="s1">and </span><span class="s3">\&quot;</span><span class="s1">prune</span><span class="s3">\&quot; </span><span class="s1">commands.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function extendVerifyFunction(</span><span class="s3">\n  </span><span class="s1">originalFn: (this: unknown, ...args: unknown[]) =&gt; IProblem[] | undefined</span><span class="s3">\n</span><span class="s1">): (this: unknown, ...args: unknown[]) =&gt; IProblem[] | undefined {</span><span class="s3">\n  </span><span class="s1">return function (this: unknown, ...args: unknown[]): IProblem[] | undefined {</span><span class="s3">\n    </span><span class="s1">const problems: IProblem[] | undefined = originalFn.apply(this, args);</span><span class="s3">\n    </span><span class="s1">if (problems) {</span><span class="s3">\n      </span><span class="s1">for (const problem of problems) {</span><span class="s3">\n        </span><span class="s1">if (problem[SUPPRESSION_SYMBOL]) {</span><span class="s3">\n          </span><span class="s1">const {</span><span class="s3">\n            </span><span class="s1">serializedSuppression,</span><span class="s3">\n            </span><span class="s1">suppression,</span><span class="s3">\n            </span><span class="s1">config: {</span><span class="s3">\n              </span><span class="s1">newSerializedSuppressions,</span><span class="s3">\n              </span><span class="s1">jsonObject: { suppressions },</span><span class="s3">\n              </span><span class="s1">newJsonObject: { suppressions: newSuppressions }</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">} = problem[SUPPRESSION_SYMBOL];</span><span class="s3">\n          </span><span class="s1">if (!newSerializedSuppressions.has(serializedSuppression)) {</span><span class="s3">\n            </span><span class="s1">newSerializedSuppressions.add(serializedSuppression);</span><span class="s3">\n            </span><span class="s1">newSuppressions.push(suppression);</span><span class="s3">\n            </span><span class="s1">suppressions.push(suppression);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return problems;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">]}</span></pre>
</body>
</html>