<html>
<head>
<title>cd81cca497522485fd7a4c92efb1f39c430cc805e183960bbc2d218bc6e5de3d.json</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #cf8e6d;}
.s3 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
cd81cca497522485fd7a4c92efb1f39c430cc805e183960bbc2d218bc6e5de3d.json</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;ast&quot;</span><span class="s0">:</span><span class="s2">null</span><span class="s0">,</span><span class="s1">&quot;code&quot;</span><span class="s0">:</span><span class="s1">&quot;/**</span><span class="s2">\n </span><span class="s1">* react-router v7.6.0</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* Copyright (c) Remix Software Inc.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* This source code is licensed under the MIT license found in the</span><span class="s2">\n </span><span class="s1">* LICENSE.md file in the root directory of this source tree.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @license MIT</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">var __typeError = msg =&gt; {</span><span class="s2">\n  </span><span class="s1">throw TypeError(msg);</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">var __accessCheck = (obj, member, msg) =&gt; member.has(obj) || __typeError(</span><span class="s2">\&quot;</span><span class="s1">Cannot </span><span class="s2">\&quot; </span><span class="s1">+ msg);</span><span class="s2">\n</span><span class="s1">var __privateGet = (obj, member, getter) =&gt; (__accessCheck(obj, member, </span><span class="s2">\&quot;</span><span class="s1">read from private field</span><span class="s2">\&quot;</span><span class="s1">), getter ? getter.call(obj) : member.get(obj));</span><span class="s2">\n</span><span class="s1">var __privateAdd = (obj, member, value) =&gt; member.has(obj) ? __typeError(</span><span class="s2">\&quot;</span><span class="s1">Cannot add the same private member more than once</span><span class="s2">\&quot;</span><span class="s1">) : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);</span><span class="s2">\n\n</span><span class="s1">// lib/router/history.ts</span><span class="s2">\n</span><span class="s1">var Action = /* @__PURE__ */(Action2 =&gt; {</span><span class="s2">\n  </span><span class="s1">Action2[</span><span class="s2">\&quot;</span><span class="s1">Pop</span><span class="s2">\&quot;</span><span class="s1">] = </span><span class="s2">\&quot;</span><span class="s1">POP</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">Action2[</span><span class="s2">\&quot;</span><span class="s1">Push</span><span class="s2">\&quot;</span><span class="s1">] = </span><span class="s2">\&quot;</span><span class="s1">PUSH</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">Action2[</span><span class="s2">\&quot;</span><span class="s1">Replace</span><span class="s2">\&quot;</span><span class="s1">] = </span><span class="s2">\&quot;</span><span class="s1">REPLACE</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">return Action2;</span><span class="s2">\n</span><span class="s1">})(Action || {});</span><span class="s2">\n</span><span class="s1">var PopStateEventType = </span><span class="s2">\&quot;</span><span class="s1">popstate</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">function createMemoryHistory(options = {}) {</span><span class="s2">\n  </span><span class="s1">let {</span><span class="s2">\n    </span><span class="s1">initialEntries = [</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">],</span><span class="s2">\n    </span><span class="s1">initialIndex,</span><span class="s2">\n    </span><span class="s1">v5Compat = false</span><span class="s2">\n  </span><span class="s1">} = options;</span><span class="s2">\n  </span><span class="s1">let entries;</span><span class="s2">\n  </span><span class="s1">entries = initialEntries.map((entry, index2) =&gt; createMemoryLocation(entry, typeof entry === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">? null : entry.state, index2 === 0 ? </span><span class="s2">\&quot;</span><span class="s1">default</span><span class="s2">\&quot; </span><span class="s1">: void 0));</span><span class="s2">\n  </span><span class="s1">let index = clampIndex(initialIndex == null ? entries.length - 1 : initialIndex);</span><span class="s2">\n  </span><span class="s1">let action = </span><span class="s2">\&quot;</span><span class="s1">POP</span><span class="s2">\&quot; </span><span class="s1">/* Pop */;</span><span class="s2">\n  </span><span class="s1">let listener = null;</span><span class="s2">\n  </span><span class="s1">function clampIndex(n) {</span><span class="s2">\n    </span><span class="s1">return Math.min(Math.max(n, 0), entries.length - 1);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function getCurrentLocation() {</span><span class="s2">\n    </span><span class="s1">return entries[index];</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function createMemoryLocation(to, state = null, key) {</span><span class="s2">\n    </span><span class="s1">let location = createLocation(entries ? getCurrentLocation().pathname : </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">, to, state, key);</span><span class="s2">\n    </span><span class="s1">warning(location.pathname.charAt(0) === </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">, `relative pathnames are not supported in memory history: ${JSON.stringify(to)}`);</span><span class="s2">\n    </span><span class="s1">return location;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function createHref2(to) {</span><span class="s2">\n    </span><span class="s1">return typeof to === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">? to : createPath(to);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let history = {</span><span class="s2">\n    </span><span class="s1">get index() {</span><span class="s2">\n      </span><span class="s1">return index;</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">get action() {</span><span class="s2">\n      </span><span class="s1">return action;</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">get location() {</span><span class="s2">\n      </span><span class="s1">return getCurrentLocation();</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">createHref: createHref2,</span><span class="s2">\n    </span><span class="s1">createURL(to) {</span><span class="s2">\n      </span><span class="s1">return new URL(createHref2(to), </span><span class="s2">\&quot;</span><span class="s1">http://localhost</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">encodeLocation(to) {</span><span class="s2">\n      </span><span class="s1">let path = typeof to === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">? parsePath(to) : to;</span><span class="s2">\n      </span><span class="s1">return {</span><span class="s2">\n        </span><span class="s1">pathname: path.pathname || </span><span class="s2">\&quot;\&quot;</span><span class="s1">,</span><span class="s2">\n        </span><span class="s1">search: path.search || </span><span class="s2">\&quot;\&quot;</span><span class="s1">,</span><span class="s2">\n        </span><span class="s1">hash: path.hash || </span><span class="s2">\&quot;\&quot;\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">push(to, state) {</span><span class="s2">\n      </span><span class="s1">action = </span><span class="s2">\&quot;</span><span class="s1">PUSH</span><span class="s2">\&quot; </span><span class="s1">/* Push */;</span><span class="s2">\n      </span><span class="s1">let nextLocation = createMemoryLocation(to, state);</span><span class="s2">\n      </span><span class="s1">index += 1;</span><span class="s2">\n      </span><span class="s1">entries.splice(index, entries.length, nextLocation);</span><span class="s2">\n      </span><span class="s1">if (v5Compat &amp;&amp; listener) {</span><span class="s2">\n        </span><span class="s1">listener({</span><span class="s2">\n          </span><span class="s1">action,</span><span class="s2">\n          </span><span class="s1">location: nextLocation,</span><span class="s2">\n          </span><span class="s1">delta: 1</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">replace(to, state) {</span><span class="s2">\n      </span><span class="s1">action = </span><span class="s2">\&quot;</span><span class="s1">REPLACE</span><span class="s2">\&quot; </span><span class="s1">/* Replace */;</span><span class="s2">\n      </span><span class="s1">let nextLocation = createMemoryLocation(to, state);</span><span class="s2">\n      </span><span class="s1">entries[index] = nextLocation;</span><span class="s2">\n      </span><span class="s1">if (v5Compat &amp;&amp; listener) {</span><span class="s2">\n        </span><span class="s1">listener({</span><span class="s2">\n          </span><span class="s1">action,</span><span class="s2">\n          </span><span class="s1">location: nextLocation,</span><span class="s2">\n          </span><span class="s1">delta: 0</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">go(delta) {</span><span class="s2">\n      </span><span class="s1">action = </span><span class="s2">\&quot;</span><span class="s1">POP</span><span class="s2">\&quot; </span><span class="s1">/* Pop */;</span><span class="s2">\n      </span><span class="s1">let nextIndex = clampIndex(index + delta);</span><span class="s2">\n      </span><span class="s1">let nextLocation = entries[nextIndex];</span><span class="s2">\n      </span><span class="s1">index = nextIndex;</span><span class="s2">\n      </span><span class="s1">if (listener) {</span><span class="s2">\n        </span><span class="s1">listener({</span><span class="s2">\n          </span><span class="s1">action,</span><span class="s2">\n          </span><span class="s1">location: nextLocation,</span><span class="s2">\n          </span><span class="s1">delta</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">listen(fn) {</span><span class="s2">\n      </span><span class="s1">listener = fn;</span><span class="s2">\n      </span><span class="s1">return () =&gt; {</span><span class="s2">\n        </span><span class="s1">listener = null;</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">return history;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createBrowserHistory(options = {}) {</span><span class="s2">\n  </span><span class="s1">function createBrowserLocation(window2, globalHistory) {</span><span class="s2">\n    </span><span class="s1">let {</span><span class="s2">\n      </span><span class="s1">pathname,</span><span class="s2">\n      </span><span class="s1">search,</span><span class="s2">\n      </span><span class="s1">hash</span><span class="s2">\n    </span><span class="s1">} = window2.location;</span><span class="s2">\n    </span><span class="s1">return createLocation(</span><span class="s2">\&quot;\&quot;</span><span class="s1">, {</span><span class="s2">\n      </span><span class="s1">pathname,</span><span class="s2">\n      </span><span class="s1">search,</span><span class="s2">\n      </span><span class="s1">hash</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">// state defaults to `null` because `window.history.state` does</span><span class="s2">\n    </span><span class="s1">globalHistory.state &amp;&amp; globalHistory.state.usr || null, globalHistory.state &amp;&amp; globalHistory.state.key || </span><span class="s2">\&quot;</span><span class="s1">default</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function createBrowserHref(window2, to) {</span><span class="s2">\n    </span><span class="s1">return typeof to === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">? to : createPath(to);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createHashHistory(options = {}) {</span><span class="s2">\n  </span><span class="s1">function createHashLocation(window2, globalHistory) {</span><span class="s2">\n    </span><span class="s1">let {</span><span class="s2">\n      </span><span class="s1">pathname = </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">search = </span><span class="s2">\&quot;\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">hash = </span><span class="s2">\&quot;\&quot;\n    </span><span class="s1">} = parsePath(window2.location.hash.substring(1));</span><span class="s2">\n    </span><span class="s1">if (!pathname.startsWith(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">) &amp;&amp; !pathname.startsWith(</span><span class="s2">\&quot;</span><span class="s1">.</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n      </span><span class="s1">pathname = </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot; </span><span class="s1">+ pathname;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return createLocation(</span><span class="s2">\&quot;\&quot;</span><span class="s1">, {</span><span class="s2">\n      </span><span class="s1">pathname,</span><span class="s2">\n      </span><span class="s1">search,</span><span class="s2">\n      </span><span class="s1">hash</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">// state defaults to `null` because `window.history.state` does</span><span class="s2">\n    </span><span class="s1">globalHistory.state &amp;&amp; globalHistory.state.usr || null, globalHistory.state &amp;&amp; globalHistory.state.key || </span><span class="s2">\&quot;</span><span class="s1">default</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function createHashHref(window2, to) {</span><span class="s2">\n    </span><span class="s1">let base = window2.document.querySelector(</span><span class="s2">\&quot;</span><span class="s1">base</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">let href2 = </span><span class="s2">\&quot;\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">if (base &amp;&amp; base.getAttribute(</span><span class="s2">\&quot;</span><span class="s1">href</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n      </span><span class="s1">let url = window2.location.href;</span><span class="s2">\n      </span><span class="s1">let hashIndex = url.indexOf(</span><span class="s2">\&quot;</span><span class="s1">#</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">href2 = hashIndex === -1 ? url : url.slice(0, hashIndex);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return href2 + </span><span class="s2">\&quot;</span><span class="s1">#</span><span class="s2">\&quot; </span><span class="s1">+ (typeof to === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">? to : createPath(to));</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function validateHashLocation(location, to) {</span><span class="s2">\n    </span><span class="s1">warning(location.pathname.charAt(0) === </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">, `relative pathnames are not supported in hash history.push(${JSON.stringify(to)})`);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return getUrlBasedHistory(createHashLocation, createHashHref, validateHashLocation, options);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function invariant(value, message) {</span><span class="s2">\n  </span><span class="s1">if (value === false || value === null || typeof value === </span><span class="s2">\&quot;</span><span class="s1">undefined</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">throw new Error(message);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function warning(cond, message) {</span><span class="s2">\n  </span><span class="s1">if (!cond) {</span><span class="s2">\n    </span><span class="s1">if (typeof console !== </span><span class="s2">\&quot;</span><span class="s1">undefined</span><span class="s2">\&quot;</span><span class="s1">) console.warn(message);</span><span class="s2">\n    </span><span class="s1">try {</span><span class="s2">\n      </span><span class="s1">throw new Error(message);</span><span class="s2">\n    </span><span class="s1">} catch (e) {}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createKey() {</span><span class="s2">\n  </span><span class="s1">return Math.random().toString(36).substring(2, 10);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getHistoryState(location, index) {</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">usr: location.state,</span><span class="s2">\n    </span><span class="s1">key: location.key,</span><span class="s2">\n    </span><span class="s1">idx: index</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createLocation(current, to, state = null, key) {</span><span class="s2">\n  </span><span class="s1">let location = {</span><span class="s2">\n    </span><span class="s1">pathname: typeof current === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">? current : current.pathname,</span><span class="s2">\n    </span><span class="s1">search: </span><span class="s2">\&quot;\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">hash: </span><span class="s2">\&quot;\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">...(typeof to === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">? parsePath(to) : to),</span><span class="s2">\n    </span><span class="s1">state,</span><span class="s2">\n    </span><span class="s1">// TODO: This could be cleaned up.  push/replace should probably just take</span><span class="s2">\n    </span><span class="s1">// full Locations now and avoid the need to run through this flow at all</span><span class="s2">\n    </span><span class="s1">// But that's a pretty big refactor to the current test suite so going to</span><span class="s2">\n    </span><span class="s1">// keep as is for the time being and just let any incoming keys take precedence</span><span class="s2">\n    </span><span class="s1">key: to &amp;&amp; to.key || key || createKey()</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">return location;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createPath({</span><span class="s2">\n  </span><span class="s1">pathname = </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">search = </span><span class="s2">\&quot;\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">hash = </span><span class="s2">\&quot;\&quot;\n</span><span class="s1">}) {</span><span class="s2">\n  </span><span class="s1">if (search &amp;&amp; search !== </span><span class="s2">\&quot;</span><span class="s1">?</span><span class="s2">\&quot;</span><span class="s1">) pathname += search.charAt(0) === </span><span class="s2">\&quot;</span><span class="s1">?</span><span class="s2">\&quot; </span><span class="s1">? search : </span><span class="s2">\&quot;</span><span class="s1">?</span><span class="s2">\&quot; </span><span class="s1">+ search;</span><span class="s2">\n  </span><span class="s1">if (hash &amp;&amp; hash !== </span><span class="s2">\&quot;</span><span class="s1">#</span><span class="s2">\&quot;</span><span class="s1">) pathname += hash.charAt(0) === </span><span class="s2">\&quot;</span><span class="s1">#</span><span class="s2">\&quot; </span><span class="s1">? hash : </span><span class="s2">\&quot;</span><span class="s1">#</span><span class="s2">\&quot; </span><span class="s1">+ hash;</span><span class="s2">\n  </span><span class="s1">return pathname;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function parsePath(path) {</span><span class="s2">\n  </span><span class="s1">let parsedPath = {};</span><span class="s2">\n  </span><span class="s1">if (path) {</span><span class="s2">\n    </span><span class="s1">let hashIndex = path.indexOf(</span><span class="s2">\&quot;</span><span class="s1">#</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">if (hashIndex &gt;= 0) {</span><span class="s2">\n      </span><span class="s1">parsedPath.hash = path.substring(hashIndex);</span><span class="s2">\n      </span><span class="s1">path = path.substring(0, hashIndex);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let searchIndex = path.indexOf(</span><span class="s2">\&quot;</span><span class="s1">?</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">if (searchIndex &gt;= 0) {</span><span class="s2">\n      </span><span class="s1">parsedPath.search = path.substring(searchIndex);</span><span class="s2">\n      </span><span class="s1">path = path.substring(0, searchIndex);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (path) {</span><span class="s2">\n      </span><span class="s1">parsedPath.pathname = path;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return parsedPath;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getUrlBasedHistory(getLocation, createHref2, validateLocation, options = {}) {</span><span class="s2">\n  </span><span class="s1">let {</span><span class="s2">\n    </span><span class="s1">window: window2 = document.defaultView,</span><span class="s2">\n    </span><span class="s1">v5Compat = false</span><span class="s2">\n  </span><span class="s1">} = options;</span><span class="s2">\n  </span><span class="s1">let globalHistory = window2.history;</span><span class="s2">\n  </span><span class="s1">let action = </span><span class="s2">\&quot;</span><span class="s1">POP</span><span class="s2">\&quot; </span><span class="s1">/* Pop */;</span><span class="s2">\n  </span><span class="s1">let listener = null;</span><span class="s2">\n  </span><span class="s1">let index = getIndex();</span><span class="s2">\n  </span><span class="s1">if (index == null) {</span><span class="s2">\n    </span><span class="s1">index = 0;</span><span class="s2">\n    </span><span class="s1">globalHistory.replaceState({</span><span class="s2">\n      </span><span class="s1">...globalHistory.state,</span><span class="s2">\n      </span><span class="s1">idx: index</span><span class="s2">\n    </span><span class="s1">}, </span><span class="s2">\&quot;\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function getIndex() {</span><span class="s2">\n    </span><span class="s1">let state = globalHistory.state || {</span><span class="s2">\n      </span><span class="s1">idx: null</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">return state.idx;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function handlePop() {</span><span class="s2">\n    </span><span class="s1">action = </span><span class="s2">\&quot;</span><span class="s1">POP</span><span class="s2">\&quot; </span><span class="s1">/* Pop */;</span><span class="s2">\n    </span><span class="s1">let nextIndex = getIndex();</span><span class="s2">\n    </span><span class="s1">let delta = nextIndex == null ? null : nextIndex - index;</span><span class="s2">\n    </span><span class="s1">index = nextIndex;</span><span class="s2">\n    </span><span class="s1">if (listener) {</span><span class="s2">\n      </span><span class="s1">listener({</span><span class="s2">\n        </span><span class="s1">action,</span><span class="s2">\n        </span><span class="s1">location: history.location,</span><span class="s2">\n        </span><span class="s1">delta</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function push(to, state) {</span><span class="s2">\n    </span><span class="s1">action = </span><span class="s2">\&quot;</span><span class="s1">PUSH</span><span class="s2">\&quot; </span><span class="s1">/* Push */;</span><span class="s2">\n    </span><span class="s1">let location = createLocation(history.location, to, state);</span><span class="s2">\n    </span><span class="s1">if (validateLocation) validateLocation(location, to);</span><span class="s2">\n    </span><span class="s1">index = getIndex() + 1;</span><span class="s2">\n    </span><span class="s1">let historyState = getHistoryState(location, index);</span><span class="s2">\n    </span><span class="s1">let url = history.createHref(location);</span><span class="s2">\n    </span><span class="s1">try {</span><span class="s2">\n      </span><span class="s1">globalHistory.pushState(historyState, </span><span class="s2">\&quot;\&quot;</span><span class="s1">, url);</span><span class="s2">\n    </span><span class="s1">} catch (error) {</span><span class="s2">\n      </span><span class="s1">if (error instanceof DOMException &amp;&amp; error.name === </span><span class="s2">\&quot;</span><span class="s1">DataCloneError</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">throw error;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">window2.location.assign(url);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (v5Compat &amp;&amp; listener) {</span><span class="s2">\n      </span><span class="s1">listener({</span><span class="s2">\n        </span><span class="s1">action,</span><span class="s2">\n        </span><span class="s1">location: history.location,</span><span class="s2">\n        </span><span class="s1">delta: 1</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function replace2(to, state) {</span><span class="s2">\n    </span><span class="s1">action = </span><span class="s2">\&quot;</span><span class="s1">REPLACE</span><span class="s2">\&quot; </span><span class="s1">/* Replace */;</span><span class="s2">\n    </span><span class="s1">let location = createLocation(history.location, to, state);</span><span class="s2">\n    </span><span class="s1">if (validateLocation) validateLocation(location, to);</span><span class="s2">\n    </span><span class="s1">index = getIndex();</span><span class="s2">\n    </span><span class="s1">let historyState = getHistoryState(location, index);</span><span class="s2">\n    </span><span class="s1">let url = history.createHref(location);</span><span class="s2">\n    </span><span class="s1">globalHistory.replaceState(historyState, </span><span class="s2">\&quot;\&quot;</span><span class="s1">, url);</span><span class="s2">\n    </span><span class="s1">if (v5Compat &amp;&amp; listener) {</span><span class="s2">\n      </span><span class="s1">listener({</span><span class="s2">\n        </span><span class="s1">action,</span><span class="s2">\n        </span><span class="s1">location: history.location,</span><span class="s2">\n        </span><span class="s1">delta: 0</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function createURL(to) {</span><span class="s2">\n    </span><span class="s1">return createBrowserURLImpl(to);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let history = {</span><span class="s2">\n    </span><span class="s1">get action() {</span><span class="s2">\n      </span><span class="s1">return action;</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">get location() {</span><span class="s2">\n      </span><span class="s1">return getLocation(window2, globalHistory);</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">listen(fn) {</span><span class="s2">\n      </span><span class="s1">if (listener) {</span><span class="s2">\n        </span><span class="s1">throw new Error(</span><span class="s2">\&quot;</span><span class="s1">A history only accepts one active listener</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">window2.addEventListener(PopStateEventType, handlePop);</span><span class="s2">\n      </span><span class="s1">listener = fn;</span><span class="s2">\n      </span><span class="s1">return () =&gt; {</span><span class="s2">\n        </span><span class="s1">window2.removeEventListener(PopStateEventType, handlePop);</span><span class="s2">\n        </span><span class="s1">listener = null;</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">createHref(to) {</span><span class="s2">\n      </span><span class="s1">return createHref2(window2, to);</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">createURL,</span><span class="s2">\n    </span><span class="s1">encodeLocation(to) {</span><span class="s2">\n      </span><span class="s1">let url = createURL(to);</span><span class="s2">\n      </span><span class="s1">return {</span><span class="s2">\n        </span><span class="s1">pathname: url.pathname,</span><span class="s2">\n        </span><span class="s1">search: url.search,</span><span class="s2">\n        </span><span class="s1">hash: url.hash</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">push,</span><span class="s2">\n    </span><span class="s1">replace: replace2,</span><span class="s2">\n    </span><span class="s1">go(n) {</span><span class="s2">\n      </span><span class="s1">return globalHistory.go(n);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">return history;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createBrowserURLImpl(to, isAbsolute = false) {</span><span class="s2">\n  </span><span class="s1">let base = </span><span class="s2">\&quot;</span><span class="s1">http://localhost</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">if (typeof window !== </span><span class="s2">\&quot;</span><span class="s1">undefined</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">base = window.location.origin !== </span><span class="s2">\&quot;</span><span class="s1">null</span><span class="s2">\&quot; </span><span class="s1">? window.location.origin : window.location.href;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">invariant(base, </span><span class="s2">\&quot;</span><span class="s1">No window.location.(origin|href) available to create URL</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let href2 = typeof to === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">? to : createPath(to);</span><span class="s2">\n  </span><span class="s1">href2 = href2.replace(/ $/, </span><span class="s2">\&quot;</span><span class="s1">%20</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">if (!isAbsolute &amp;&amp; href2.startsWith(</span><span class="s2">\&quot;</span><span class="s1">//</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n    </span><span class="s1">href2 = base + href2;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return new URL(href2, base);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/router/utils.ts</span><span class="s2">\n</span><span class="s1">function unstable_createContext(defaultValue) {</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">defaultValue</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var _map;</span><span class="s2">\n</span><span class="s1">var unstable_RouterContextProvider = class {</span><span class="s2">\n  </span><span class="s1">constructor(init) {</span><span class="s2">\n    </span><span class="s1">__privateAdd(this, _map, /* @__PURE__ */new Map());</span><span class="s2">\n    </span><span class="s1">if (init) {</span><span class="s2">\n      </span><span class="s1">for (let [context, value] of init) {</span><span class="s2">\n        </span><span class="s1">this.set(context, value);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">get(context) {</span><span class="s2">\n    </span><span class="s1">if (__privateGet(this, _map).has(context)) {</span><span class="s2">\n      </span><span class="s1">return __privateGet(this, _map).get(context);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (context.defaultValue !== void 0) {</span><span class="s2">\n      </span><span class="s1">return context.defaultValue;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">throw new Error(</span><span class="s2">\&quot;</span><span class="s1">No value found for context</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">set(context, value) {</span><span class="s2">\n    </span><span class="s1">__privateGet(this, _map).set(context, value);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">_map = new WeakMap();</span><span class="s2">\n</span><span class="s1">var unsupportedLazyRouteObjectKeys = /* @__PURE__ */new Set([</span><span class="s2">\&quot;</span><span class="s1">lazy</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">caseSensitive</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">path</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">id</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">index</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">children</span><span class="s2">\&quot;</span><span class="s1">]);</span><span class="s2">\n</span><span class="s1">function isUnsupportedLazyRouteObjectKey(key) {</span><span class="s2">\n  </span><span class="s1">return unsupportedLazyRouteObjectKeys.has(key);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var unsupportedLazyRouteFunctionKeys = /* @__PURE__ */new Set([</span><span class="s2">\&quot;</span><span class="s1">lazy</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">caseSensitive</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">path</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">id</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">index</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">unstable_middleware</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">children</span><span class="s2">\&quot;</span><span class="s1">]);</span><span class="s2">\n</span><span class="s1">function isUnsupportedLazyRouteFunctionKey(key) {</span><span class="s2">\n  </span><span class="s1">return unsupportedLazyRouteFunctionKeys.has(key);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isIndexRoute(route) {</span><span class="s2">\n  </span><span class="s1">return route.index === true;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function convertRoutesToDataRoutes(routes, mapRouteProperties2, parentPath = [], manifest = {}) {</span><span class="s2">\n  </span><span class="s1">return routes.map((route, index) =&gt; {</span><span class="s2">\n    </span><span class="s1">let treePath = [...parentPath, String(index)];</span><span class="s2">\n    </span><span class="s1">let id = typeof route.id === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">? route.id : treePath.join(</span><span class="s2">\&quot;</span><span class="s1">-</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">invariant(route.index !== true || !route.children, `Cannot specify children on an index route`);</span><span class="s2">\n    </span><span class="s1">invariant(!manifest[id], `Found a route id collision on id </span><span class="s2">\&quot;</span><span class="s1">${id}</span><span class="s2">\&quot;</span><span class="s1">.  Route id's must be globally unique within Data Router usages`);</span><span class="s2">\n    </span><span class="s1">if (isIndexRoute(route)) {</span><span class="s2">\n      </span><span class="s1">let indexRoute = {</span><span class="s2">\n        </span><span class="s1">...route,</span><span class="s2">\n        </span><span class="s1">...mapRouteProperties2(route),</span><span class="s2">\n        </span><span class="s1">id</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">manifest[id] = indexRoute;</span><span class="s2">\n      </span><span class="s1">return indexRoute;</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">let pathOrLayoutRoute = {</span><span class="s2">\n        </span><span class="s1">...route,</span><span class="s2">\n        </span><span class="s1">...mapRouteProperties2(route),</span><span class="s2">\n        </span><span class="s1">id,</span><span class="s2">\n        </span><span class="s1">children: void 0</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">manifest[id] = pathOrLayoutRoute;</span><span class="s2">\n      </span><span class="s1">if (route.children) {</span><span class="s2">\n        </span><span class="s1">pathOrLayoutRoute.children = convertRoutesToDataRoutes(route.children, mapRouteProperties2, treePath, manifest);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return pathOrLayoutRoute;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function matchRoutes(routes, locationArg, basename = </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n  </span><span class="s1">return matchRoutesImpl(routes, locationArg, basename, false);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function matchRoutesImpl(routes, locationArg, basename, allowPartial) {</span><span class="s2">\n  </span><span class="s1">let location = typeof locationArg === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">? parsePath(locationArg) : locationArg;</span><span class="s2">\n  </span><span class="s1">let pathname = stripBasename(location.pathname || </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">, basename);</span><span class="s2">\n  </span><span class="s1">if (pathname == null) {</span><span class="s2">\n    </span><span class="s1">return null;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let branches = flattenRoutes(routes);</span><span class="s2">\n  </span><span class="s1">rankRouteBranches(branches);</span><span class="s2">\n  </span><span class="s1">let matches = null;</span><span class="s2">\n  </span><span class="s1">for (let i = 0; matches == null &amp;&amp; i &lt; branches.length; ++i) {</span><span class="s2">\n    </span><span class="s1">let decoded = decodePath(pathname);</span><span class="s2">\n    </span><span class="s1">matches = matchRouteBranch(branches[i], decoded, allowPartial);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return matches;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function convertRouteMatchToUiMatch(match, loaderData) {</span><span class="s2">\n  </span><span class="s1">let {</span><span class="s2">\n    </span><span class="s1">route,</span><span class="s2">\n    </span><span class="s1">pathname,</span><span class="s2">\n    </span><span class="s1">params</span><span class="s2">\n  </span><span class="s1">} = match;</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">id: route.id,</span><span class="s2">\n    </span><span class="s1">pathname,</span><span class="s2">\n    </span><span class="s1">params,</span><span class="s2">\n    </span><span class="s1">data: loaderData[route.id],</span><span class="s2">\n    </span><span class="s1">handle: route.handle</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function flattenRoutes(routes, branches = [], parentsMeta = [], parentPath = </span><span class="s2">\&quot;\&quot;</span><span class="s1">) {</span><span class="s2">\n  </span><span class="s1">let flattenRoute = (route, index, relativePath) =&gt; {</span><span class="s2">\n    </span><span class="s1">let meta = {</span><span class="s2">\n      </span><span class="s1">relativePath: relativePath === void 0 ? route.path || </span><span class="s2">\&quot;\&quot; </span><span class="s1">: relativePath,</span><span class="s2">\n      </span><span class="s1">caseSensitive: route.caseSensitive === true,</span><span class="s2">\n      </span><span class="s1">childrenIndex: index,</span><span class="s2">\n      </span><span class="s1">route</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">if (meta.relativePath.startsWith(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n      </span><span class="s1">invariant(meta.relativePath.startsWith(parentPath), `Absolute route path </span><span class="s2">\&quot;</span><span class="s1">${meta.relativePath}</span><span class="s2">\&quot; </span><span class="s1">nested under path </span><span class="s2">\&quot;</span><span class="s1">${parentPath}</span><span class="s2">\&quot; </span><span class="s1">is not valid. An absolute child route path must start with the combined path of all its parent routes.`);</span><span class="s2">\n      </span><span class="s1">meta.relativePath = meta.relativePath.slice(parentPath.length);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let path = joinPaths([parentPath, meta.relativePath]);</span><span class="s2">\n    </span><span class="s1">let routesMeta = parentsMeta.concat(meta);</span><span class="s2">\n    </span><span class="s1">if (route.children &amp;&amp; route.children.length &gt; 0) {</span><span class="s2">\n      </span><span class="s1">invariant(</span><span class="s2">\n      </span><span class="s1">// Our types know better, but runtime JS may not!</span><span class="s2">\n      </span><span class="s1">// @ts-expect-error</span><span class="s2">\n      </span><span class="s1">route.index !== true, `Index routes must not have child routes. Please remove all child routes from route path </span><span class="s2">\&quot;</span><span class="s1">${path}</span><span class="s2">\&quot;</span><span class="s1">.`);</span><span class="s2">\n      </span><span class="s1">flattenRoutes(route.children, branches, routesMeta, path);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (route.path == null &amp;&amp; !route.index) {</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">branches.push({</span><span class="s2">\n      </span><span class="s1">path,</span><span class="s2">\n      </span><span class="s1">score: computeScore(path, route.index),</span><span class="s2">\n      </span><span class="s1">routesMeta</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">routes.forEach((route, index) =&gt; {</span><span class="s2">\n    </span><span class="s1">if (route.path === </span><span class="s2">\&quot;\&quot; </span><span class="s1">|| !route.path?.includes(</span><span class="s2">\&quot;</span><span class="s1">?</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n      </span><span class="s1">flattenRoute(route, index);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">for (let exploded of explodeOptionalSegments(route.path)) {</span><span class="s2">\n        </span><span class="s1">flattenRoute(route, index, exploded);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">return branches;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function explodeOptionalSegments(path) {</span><span class="s2">\n  </span><span class="s1">let segments = path.split(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">if (segments.length === 0) return [];</span><span class="s2">\n  </span><span class="s1">let [first, ...rest] = segments;</span><span class="s2">\n  </span><span class="s1">let isOptional = first.endsWith(</span><span class="s2">\&quot;</span><span class="s1">?</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let required = first.replace(/</span><span class="s2">\\</span><span class="s1">?$/, </span><span class="s2">\&quot;\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">if (rest.length === 0) {</span><span class="s2">\n    </span><span class="s1">return isOptional ? [required, </span><span class="s2">\&quot;\&quot;</span><span class="s1">] : [required];</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let restExploded = explodeOptionalSegments(rest.join(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">));</span><span class="s2">\n  </span><span class="s1">let result = [];</span><span class="s2">\n  </span><span class="s1">result.push(...restExploded.map(subpath =&gt; subpath === </span><span class="s2">\&quot;\&quot; </span><span class="s1">? required : [required, subpath].join(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">)));</span><span class="s2">\n  </span><span class="s1">if (isOptional) {</span><span class="s2">\n    </span><span class="s1">result.push(...restExploded);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return result.map(exploded =&gt; path.startsWith(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">) &amp;&amp; exploded === </span><span class="s2">\&quot;\&quot; </span><span class="s1">? </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot; </span><span class="s1">: exploded);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function rankRouteBranches(branches) {</span><span class="s2">\n  </span><span class="s1">branches.sort((a, b) =&gt; a.score !== b.score ? b.score - a.score : compareIndexes(a.routesMeta.map(meta =&gt; meta.childrenIndex), b.routesMeta.map(meta =&gt; meta.childrenIndex)));</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var paramRe = /^:[</span><span class="s2">\\</span><span class="s1">w-]+$/;</span><span class="s2">\n</span><span class="s1">var dynamicSegmentValue = 3;</span><span class="s2">\n</span><span class="s1">var indexRouteValue = 2;</span><span class="s2">\n</span><span class="s1">var emptySegmentValue = 1;</span><span class="s2">\n</span><span class="s1">var staticSegmentValue = 10;</span><span class="s2">\n</span><span class="s1">var splatPenalty = -2;</span><span class="s2">\n</span><span class="s1">var isSplat = s =&gt; s === </span><span class="s2">\&quot;</span><span class="s1">*</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">function computeScore(path, index) {</span><span class="s2">\n  </span><span class="s1">let segments = path.split(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let initialScore = segments.length;</span><span class="s2">\n  </span><span class="s1">if (segments.some(isSplat)) {</span><span class="s2">\n    </span><span class="s1">initialScore += splatPenalty;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (index) {</span><span class="s2">\n    </span><span class="s1">initialScore += indexRouteValue;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return segments.filter(s =&gt; !isSplat(s)).reduce((score, segment) =&gt; score + (paramRe.test(segment) ? dynamicSegmentValue : segment === </span><span class="s2">\&quot;\&quot; </span><span class="s1">? emptySegmentValue : staticSegmentValue), initialScore);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function compareIndexes(a, b) {</span><span class="s2">\n  </span><span class="s1">let siblings = a.length === b.length &amp;&amp; a.slice(0, -1).every((n, i) =&gt; n === b[i]);</span><span class="s2">\n  </span><span class="s1">return siblings ?</span><span class="s2">\n  </span><span class="s1">// If two routes are siblings, we should try to match the earlier sibling</span><span class="s2">\n  </span><span class="s1">// first. This allows people to have fine-grained control over the matching</span><span class="s2">\n  </span><span class="s1">// behavior by simply putting routes with identical paths in the order they</span><span class="s2">\n  </span><span class="s1">// want them tried.</span><span class="s2">\n  </span><span class="s1">a[a.length - 1] - b[b.length - 1] :</span><span class="s2">\n  </span><span class="s1">// Otherwise, it doesn't really make sense to rank non-siblings by index,</span><span class="s2">\n  </span><span class="s1">// so they sort equally.</span><span class="s2">\n  </span><span class="s1">0;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function matchRouteBranch(branch, pathname, allowPartial = false) {</span><span class="s2">\n  </span><span class="s1">let {</span><span class="s2">\n    </span><span class="s1">routesMeta</span><span class="s2">\n  </span><span class="s1">} = branch;</span><span class="s2">\n  </span><span class="s1">let matchedParams = {};</span><span class="s2">\n  </span><span class="s1">let matchedPathname = </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">let matches = [];</span><span class="s2">\n  </span><span class="s1">for (let i = 0; i &lt; routesMeta.length; ++i) {</span><span class="s2">\n    </span><span class="s1">let meta = routesMeta[i];</span><span class="s2">\n    </span><span class="s1">let end = i === routesMeta.length - 1;</span><span class="s2">\n    </span><span class="s1">let remainingPathname = matchedPathname === </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot; </span><span class="s1">? pathname : pathname.slice(matchedPathname.length) || </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">let match = matchPath({</span><span class="s2">\n      </span><span class="s1">path: meta.relativePath,</span><span class="s2">\n      </span><span class="s1">caseSensitive: meta.caseSensitive,</span><span class="s2">\n      </span><span class="s1">end</span><span class="s2">\n    </span><span class="s1">}, remainingPathname);</span><span class="s2">\n    </span><span class="s1">let route = meta.route;</span><span class="s2">\n    </span><span class="s1">if (!match &amp;&amp; end &amp;&amp; allowPartial &amp;&amp; !routesMeta[routesMeta.length - 1].route.index) {</span><span class="s2">\n      </span><span class="s1">match = matchPath({</span><span class="s2">\n        </span><span class="s1">path: meta.relativePath,</span><span class="s2">\n        </span><span class="s1">caseSensitive: meta.caseSensitive,</span><span class="s2">\n        </span><span class="s1">end: false</span><span class="s2">\n      </span><span class="s1">}, remainingPathname);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (!match) {</span><span class="s2">\n      </span><span class="s1">return null;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">Object.assign(matchedParams, match.params);</span><span class="s2">\n    </span><span class="s1">matches.push({</span><span class="s2">\n      </span><span class="s1">// TODO: Can this as be avoided?</span><span class="s2">\n      </span><span class="s1">params: matchedParams,</span><span class="s2">\n      </span><span class="s1">pathname: joinPaths([matchedPathname, match.pathname]),</span><span class="s2">\n      </span><span class="s1">pathnameBase: normalizePathname(joinPaths([matchedPathname, match.pathnameBase])),</span><span class="s2">\n      </span><span class="s1">route</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">if (match.pathnameBase !== </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return matches;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function generatePath(originalPath, params = {}) {</span><span class="s2">\n  </span><span class="s1">let path = originalPath;</span><span class="s2">\n  </span><span class="s1">if (path.endsWith(</span><span class="s2">\&quot;</span><span class="s1">*</span><span class="s2">\&quot;</span><span class="s1">) &amp;&amp; path !== </span><span class="s2">\&quot;</span><span class="s1">*</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; !path.endsWith(</span><span class="s2">\&quot;</span><span class="s1">/*</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n    </span><span class="s1">warning(false, `Route path </span><span class="s2">\&quot;</span><span class="s1">${path}</span><span class="s2">\&quot; </span><span class="s1">will be treated as if it were </span><span class="s2">\&quot;</span><span class="s1">${path.replace(/</span><span class="s2">\\</span><span class="s1">*$/, </span><span class="s2">\&quot;</span><span class="s1">/*</span><span class="s2">\&quot;</span><span class="s1">)}</span><span class="s2">\&quot; </span><span class="s1">because the </span><span class="s2">\\</span><span class="s1">`*</span><span class="s2">\\</span><span class="s1">` character must always follow a </span><span class="s2">\\</span><span class="s1">`/</span><span class="s2">\\</span><span class="s1">` in the pattern. To get rid of this warning, please change the route path to </span><span class="s2">\&quot;</span><span class="s1">${path.replace(/</span><span class="s2">\\</span><span class="s1">*$/, </span><span class="s2">\&quot;</span><span class="s1">/*</span><span class="s2">\&quot;</span><span class="s1">)}</span><span class="s2">\&quot;</span><span class="s1">.`);</span><span class="s2">\n    </span><span class="s1">path = path.replace(/</span><span class="s2">\\</span><span class="s1">*$/, </span><span class="s2">\&quot;</span><span class="s1">/*</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">const prefix = path.startsWith(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">) ? </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot; </span><span class="s1">: </span><span class="s2">\&quot;\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">const stringify2 = p =&gt; p == null ? </span><span class="s2">\&quot;\&quot; </span><span class="s1">: typeof p === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">? p : String(p);</span><span class="s2">\n  </span><span class="s1">const segments = path.split(/</span><span class="s2">\\</span><span class="s1">/+/).map((segment, index, array) =&gt; {</span><span class="s2">\n    </span><span class="s1">const isLastSegment = index === array.length - 1;</span><span class="s2">\n    </span><span class="s1">if (isLastSegment &amp;&amp; segment === </span><span class="s2">\&quot;</span><span class="s1">*</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">const star = </span><span class="s2">\&quot;</span><span class="s1">*</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n      </span><span class="s1">return stringify2(params[star]);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">const keyMatch = segment.match(/^:([</span><span class="s2">\\</span><span class="s1">w-]+)(</span><span class="s2">\\</span><span class="s1">??)$/);</span><span class="s2">\n    </span><span class="s1">if (keyMatch) {</span><span class="s2">\n      </span><span class="s1">const [, key, optional] = keyMatch;</span><span class="s2">\n      </span><span class="s1">let param = params[key];</span><span class="s2">\n      </span><span class="s1">invariant(optional === </span><span class="s2">\&quot;</span><span class="s1">?</span><span class="s2">\&quot; </span><span class="s1">|| param != null, `Missing </span><span class="s2">\&quot;</span><span class="s1">:${key}</span><span class="s2">\&quot; </span><span class="s1">param`);</span><span class="s2">\n      </span><span class="s1">return stringify2(param);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return segment.replace(/</span><span class="s2">\\</span><span class="s1">?$/g, </span><span class="s2">\&quot;\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}).filter(segment =&gt; !!segment);</span><span class="s2">\n  </span><span class="s1">return prefix + segments.join(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function matchPath(pattern, pathname) {</span><span class="s2">\n  </span><span class="s1">if (typeof pattern === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">pattern = {</span><span class="s2">\n      </span><span class="s1">path: pattern,</span><span class="s2">\n      </span><span class="s1">caseSensitive: false,</span><span class="s2">\n      </span><span class="s1">end: true</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let [matcher, compiledParams] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);</span><span class="s2">\n  </span><span class="s1">let match = pathname.match(matcher);</span><span class="s2">\n  </span><span class="s1">if (!match) return null;</span><span class="s2">\n  </span><span class="s1">let matchedPathname = match[0];</span><span class="s2">\n  </span><span class="s1">let pathnameBase = matchedPathname.replace(/(.)</span><span class="s2">\\</span><span class="s1">/+$/, </span><span class="s2">\&quot;</span><span class="s1">$1</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let captureGroups = match.slice(1);</span><span class="s2">\n  </span><span class="s1">let params = compiledParams.reduce((memo2, {</span><span class="s2">\n    </span><span class="s1">paramName,</span><span class="s2">\n    </span><span class="s1">isOptional</span><span class="s2">\n  </span><span class="s1">}, index) =&gt; {</span><span class="s2">\n    </span><span class="s1">if (paramName === </span><span class="s2">\&quot;</span><span class="s1">*</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">let splatValue = captureGroups[index] || </span><span class="s2">\&quot;\&quot;</span><span class="s1">;</span><span class="s2">\n      </span><span class="s1">pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)</span><span class="s2">\\</span><span class="s1">/+$/, </span><span class="s2">\&quot;</span><span class="s1">$1</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">const value = captureGroups[index];</span><span class="s2">\n    </span><span class="s1">if (isOptional &amp;&amp; !value) {</span><span class="s2">\n      </span><span class="s1">memo2[paramName] = void 0;</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">memo2[paramName] = (value || </span><span class="s2">\&quot;\&quot;</span><span class="s1">).replace(/%2F/g, </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return memo2;</span><span class="s2">\n  </span><span class="s1">}, {});</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">params,</span><span class="s2">\n    </span><span class="s1">pathname: matchedPathname,</span><span class="s2">\n    </span><span class="s1">pathnameBase,</span><span class="s2">\n    </span><span class="s1">pattern</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function compilePath(path, caseSensitive = false, end = true) {</span><span class="s2">\n  </span><span class="s1">warning(path === </span><span class="s2">\&quot;</span><span class="s1">*</span><span class="s2">\&quot; </span><span class="s1">|| !path.endsWith(</span><span class="s2">\&quot;</span><span class="s1">*</span><span class="s2">\&quot;</span><span class="s1">) || path.endsWith(</span><span class="s2">\&quot;</span><span class="s1">/*</span><span class="s2">\&quot;</span><span class="s1">), `Route path </span><span class="s2">\&quot;</span><span class="s1">${path}</span><span class="s2">\&quot; </span><span class="s1">will be treated as if it were </span><span class="s2">\&quot;</span><span class="s1">${path.replace(/</span><span class="s2">\\</span><span class="s1">*$/, </span><span class="s2">\&quot;</span><span class="s1">/*</span><span class="s2">\&quot;</span><span class="s1">)}</span><span class="s2">\&quot; </span><span class="s1">because the </span><span class="s2">\\</span><span class="s1">`*</span><span class="s2">\\</span><span class="s1">` character must always follow a </span><span class="s2">\\</span><span class="s1">`/</span><span class="s2">\\</span><span class="s1">` in the pattern. To get rid of this warning, please change the route path to </span><span class="s2">\&quot;</span><span class="s1">${path.replace(/</span><span class="s2">\\</span><span class="s1">*$/, </span><span class="s2">\&quot;</span><span class="s1">/*</span><span class="s2">\&quot;</span><span class="s1">)}</span><span class="s2">\&quot;</span><span class="s1">.`);</span><span class="s2">\n  </span><span class="s1">let params = [];</span><span class="s2">\n  </span><span class="s1">let regexpSource = </span><span class="s2">\&quot;</span><span class="s1">^</span><span class="s2">\&quot; </span><span class="s1">+ path.replace(/</span><span class="s2">\\</span><span class="s1">/*</span><span class="s2">\\</span><span class="s1">*?$/, </span><span class="s2">\&quot;\&quot;</span><span class="s1">).replace(/^</span><span class="s2">\\</span><span class="s1">/*/, </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">).replace(/[</span><span class="s2">\\\\</span><span class="s1">.*+^${}|()[</span><span class="s2">\\</span><span class="s1">]]/g, </span><span class="s2">\&quot;\\\\</span><span class="s1">$&amp;</span><span class="s2">\&quot;</span><span class="s1">).replace(/</span><span class="s2">\\</span><span class="s1">/:([</span><span class="s2">\\</span><span class="s1">w-]+)(</span><span class="s2">\\</span><span class="s1">?)?/g, (_, paramName, isOptional) =&gt; {</span><span class="s2">\n    </span><span class="s1">params.push({</span><span class="s2">\n      </span><span class="s1">paramName,</span><span class="s2">\n      </span><span class="s1">isOptional: isOptional != null</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">return isOptional ? </span><span class="s2">\&quot;</span><span class="s1">/?([^</span><span class="s2">\\\\</span><span class="s1">/]+)?</span><span class="s2">\&quot; </span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">/([^</span><span class="s2">\\\\</span><span class="s1">/]+)</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">if (path.endsWith(</span><span class="s2">\&quot;</span><span class="s1">*</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n    </span><span class="s1">params.push({</span><span class="s2">\n      </span><span class="s1">paramName: </span><span class="s2">\&quot;</span><span class="s1">*</span><span class="s2">\&quot;\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">regexpSource += path === </span><span class="s2">\&quot;</span><span class="s1">*</span><span class="s2">\&quot; </span><span class="s1">|| path === </span><span class="s2">\&quot;</span><span class="s1">/*</span><span class="s2">\&quot; </span><span class="s1">? </span><span class="s2">\&quot;</span><span class="s1">(.*)$</span><span class="s2">\&quot; </span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">(?:</span><span class="s2">\\\\</span><span class="s1">/(.+)|</span><span class="s2">\\\\</span><span class="s1">/*)$</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">} else if (end) {</span><span class="s2">\n    </span><span class="s1">regexpSource += </span><span class="s2">\&quot;\\\\</span><span class="s1">/*$</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">} else if (path !== </span><span class="s2">\&quot;\&quot; </span><span class="s1">&amp;&amp; path !== </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">regexpSource += </span><span class="s2">\&quot;</span><span class="s1">(?:(?=</span><span class="s2">\\\\</span><span class="s1">/|$))</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">} else {}</span><span class="s2">\n  </span><span class="s1">let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : </span><span class="s2">\&quot;</span><span class="s1">i</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">return [matcher, params];</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function decodePath(value) {</span><span class="s2">\n  </span><span class="s1">try {</span><span class="s2">\n    </span><span class="s1">return value.split(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">).map(v =&gt; decodeURIComponent(v).replace(/</span><span class="s2">\\</span><span class="s1">//g, </span><span class="s2">\&quot;</span><span class="s1">%2F</span><span class="s2">\&quot;</span><span class="s1">)).join(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">} catch (error) {</span><span class="s2">\n    </span><span class="s1">warning(false, `The URL path </span><span class="s2">\&quot;</span><span class="s1">${value}</span><span class="s2">\&quot; </span><span class="s1">could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${error}).`);</span><span class="s2">\n    </span><span class="s1">return value;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function stripBasename(pathname, basename) {</span><span class="s2">\n  </span><span class="s1">if (basename === </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">) return pathname;</span><span class="s2">\n  </span><span class="s1">if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {</span><span class="s2">\n    </span><span class="s1">return null;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let startIndex = basename.endsWith(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">) ? basename.length - 1 : basename.length;</span><span class="s2">\n  </span><span class="s1">let nextChar = pathname.charAt(startIndex);</span><span class="s2">\n  </span><span class="s1">if (nextChar &amp;&amp; nextChar !== </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">return null;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return pathname.slice(startIndex) || </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function resolvePath(to, fromPathname = </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n  </span><span class="s1">let {</span><span class="s2">\n    </span><span class="s1">pathname: toPathname,</span><span class="s2">\n    </span><span class="s1">search = </span><span class="s2">\&quot;\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">hash = </span><span class="s2">\&quot;\&quot;\n  </span><span class="s1">} = typeof to === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">? parsePath(to) : to;</span><span class="s2">\n  </span><span class="s1">let pathname = toPathname ? toPathname.startsWith(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">) ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">pathname,</span><span class="s2">\n    </span><span class="s1">search: normalizeSearch(search),</span><span class="s2">\n    </span><span class="s1">hash: normalizeHash(hash)</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function resolvePathname(relativePath, fromPathname) {</span><span class="s2">\n  </span><span class="s1">let segments = fromPathname.replace(/</span><span class="s2">\\</span><span class="s1">/+$/, </span><span class="s2">\&quot;\&quot;</span><span class="s1">).split(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let relativeSegments = relativePath.split(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">relativeSegments.forEach(segment =&gt; {</span><span class="s2">\n    </span><span class="s1">if (segment === </span><span class="s2">\&quot;</span><span class="s1">..</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">if (segments.length &gt; 1) segments.pop();</span><span class="s2">\n    </span><span class="s1">} else if (segment !== </span><span class="s2">\&quot;</span><span class="s1">.</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">segments.push(segment);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">return segments.length &gt; 1 ? segments.join(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">) : </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getInvalidPathError(char, field, dest, path) {</span><span class="s2">\n  </span><span class="s1">return `Cannot include a '${char}' character in a manually specified </span><span class="s2">\\</span><span class="s1">`to.${field}</span><span class="s2">\\</span><span class="s1">` field [${JSON.stringify(path)}].  Please separate it out to the </span><span class="s2">\\</span><span class="s1">`to.${dest}</span><span class="s2">\\</span><span class="s1">` field. Alternatively you may provide the full path as a string in &lt;Link to=</span><span class="s2">\&quot;</span><span class="s1">...</span><span class="s2">\&quot;</span><span class="s1">&gt; and the router will parse it for you.`;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getPathContributingMatches(matches) {</span><span class="s2">\n  </span><span class="s1">return matches.filter((match, index) =&gt; index === 0 || match.route.path &amp;&amp; match.route.path.length &gt; 0);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getResolveToMatches(matches) {</span><span class="s2">\n  </span><span class="s1">let pathMatches = getPathContributingMatches(matches);</span><span class="s2">\n  </span><span class="s1">return pathMatches.map((match, idx) =&gt; idx === pathMatches.length - 1 ? match.pathname : match.pathnameBase);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function resolveTo(toArg, routePathnames, locationPathname, isPathRelative = false) {</span><span class="s2">\n  </span><span class="s1">let to;</span><span class="s2">\n  </span><span class="s1">if (typeof toArg === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">to = parsePath(toArg);</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">to = {</span><span class="s2">\n      </span><span class="s1">...toArg</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">invariant(!to.pathname || !to.pathname.includes(</span><span class="s2">\&quot;</span><span class="s1">?</span><span class="s2">\&quot;</span><span class="s1">), getInvalidPathError(</span><span class="s2">\&quot;</span><span class="s1">?</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">pathname</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">search</span><span class="s2">\&quot;</span><span class="s1">, to));</span><span class="s2">\n    </span><span class="s1">invariant(!to.pathname || !to.pathname.includes(</span><span class="s2">\&quot;</span><span class="s1">#</span><span class="s2">\&quot;</span><span class="s1">), getInvalidPathError(</span><span class="s2">\&quot;</span><span class="s1">#</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">pathname</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">hash</span><span class="s2">\&quot;</span><span class="s1">, to));</span><span class="s2">\n    </span><span class="s1">invariant(!to.search || !to.search.includes(</span><span class="s2">\&quot;</span><span class="s1">#</span><span class="s2">\&quot;</span><span class="s1">), getInvalidPathError(</span><span class="s2">\&quot;</span><span class="s1">#</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">search</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">hash</span><span class="s2">\&quot;</span><span class="s1">, to));</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let isEmptyPath = toArg === </span><span class="s2">\&quot;\&quot; </span><span class="s1">|| to.pathname === </span><span class="s2">\&quot;\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">let toPathname = isEmptyPath ? </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot; </span><span class="s1">: to.pathname;</span><span class="s2">\n  </span><span class="s1">let from;</span><span class="s2">\n  </span><span class="s1">if (toPathname == null) {</span><span class="s2">\n    </span><span class="s1">from = locationPathname;</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">let routePathnameIndex = routePathnames.length - 1;</span><span class="s2">\n    </span><span class="s1">if (!isPathRelative &amp;&amp; toPathname.startsWith(</span><span class="s2">\&quot;</span><span class="s1">..</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n      </span><span class="s1">let toSegments = toPathname.split(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">while (toSegments[0] === </span><span class="s2">\&quot;</span><span class="s1">..</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">toSegments.shift();</span><span class="s2">\n        </span><span class="s1">routePathnameIndex -= 1;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">to.pathname = toSegments.join(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">from = routePathnameIndex &gt;= 0 ? routePathnames[routePathnameIndex] : </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let path = resolvePath(to, from);</span><span class="s2">\n  </span><span class="s1">let hasExplicitTrailingSlash = toPathname &amp;&amp; toPathname !== </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; toPathname.endsWith(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let hasCurrentTrailingSlash = (isEmptyPath || toPathname === </span><span class="s2">\&quot;</span><span class="s1">.</span><span class="s2">\&quot;</span><span class="s1">) &amp;&amp; locationPathname.endsWith(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">if (!path.pathname.endsWith(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">) &amp;&amp; (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {</span><span class="s2">\n    </span><span class="s1">path.pathname += </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return path;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var joinPaths = paths =&gt; paths.join(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">).replace(/</span><span class="s2">\\</span><span class="s1">/</span><span class="s2">\\</span><span class="s1">/+/g, </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n</span><span class="s1">var normalizePathname = pathname =&gt; pathname.replace(/</span><span class="s2">\\</span><span class="s1">/+$/, </span><span class="s2">\&quot;\&quot;</span><span class="s1">).replace(/^</span><span class="s2">\\</span><span class="s1">/*/, </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n</span><span class="s1">var normalizeSearch = search =&gt; !search || search === </span><span class="s2">\&quot;</span><span class="s1">?</span><span class="s2">\&quot; </span><span class="s1">? </span><span class="s2">\&quot;\&quot; </span><span class="s1">: search.startsWith(</span><span class="s2">\&quot;</span><span class="s1">?</span><span class="s2">\&quot;</span><span class="s1">) ? search : </span><span class="s2">\&quot;</span><span class="s1">?</span><span class="s2">\&quot; </span><span class="s1">+ search;</span><span class="s2">\n</span><span class="s1">var normalizeHash = hash =&gt; !hash || hash === </span><span class="s2">\&quot;</span><span class="s1">#</span><span class="s2">\&quot; </span><span class="s1">? </span><span class="s2">\&quot;\&quot; </span><span class="s1">: hash.startsWith(</span><span class="s2">\&quot;</span><span class="s1">#</span><span class="s2">\&quot;</span><span class="s1">) ? hash : </span><span class="s2">\&quot;</span><span class="s1">#</span><span class="s2">\&quot; </span><span class="s1">+ hash;</span><span class="s2">\n</span><span class="s1">var DataWithResponseInit = class {</span><span class="s2">\n  </span><span class="s1">constructor(data2, init) {</span><span class="s2">\n    </span><span class="s1">this.type = </span><span class="s2">\&quot;</span><span class="s1">DataWithResponseInit</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">this.data = data2;</span><span class="s2">\n    </span><span class="s1">this.init = init || null;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">function data(data2, init) {</span><span class="s2">\n  </span><span class="s1">return new DataWithResponseInit(data2, typeof init === </span><span class="s2">\&quot;</span><span class="s1">number</span><span class="s2">\&quot; </span><span class="s1">? {</span><span class="s2">\n    </span><span class="s1">status: init</span><span class="s2">\n  </span><span class="s1">} : init);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var redirect = (url, init = 302) =&gt; {</span><span class="s2">\n  </span><span class="s1">let responseInit = init;</span><span class="s2">\n  </span><span class="s1">if (typeof responseInit === </span><span class="s2">\&quot;</span><span class="s1">number</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">responseInit = {</span><span class="s2">\n      </span><span class="s1">status: responseInit</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">} else if (typeof responseInit.status === </span><span class="s2">\&quot;</span><span class="s1">undefined</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">responseInit.status = 302;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let headers = new Headers(responseInit.headers);</span><span class="s2">\n  </span><span class="s1">headers.set(</span><span class="s2">\&quot;</span><span class="s1">Location</span><span class="s2">\&quot;</span><span class="s1">, url);</span><span class="s2">\n  </span><span class="s1">return new Response(null, {</span><span class="s2">\n    </span><span class="s1">...responseInit,</span><span class="s2">\n    </span><span class="s1">headers</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">var redirectDocument = (url, init) =&gt; {</span><span class="s2">\n  </span><span class="s1">let response = redirect(url, init);</span><span class="s2">\n  </span><span class="s1">response.headers.set(</span><span class="s2">\&quot;</span><span class="s1">X-Remix-Reload-Document</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">true</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">return response;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">var replace = (url, init) =&gt; {</span><span class="s2">\n  </span><span class="s1">let response = redirect(url, init);</span><span class="s2">\n  </span><span class="s1">response.headers.set(</span><span class="s2">\&quot;</span><span class="s1">X-Remix-Replace</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">true</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">return response;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">var ErrorResponseImpl = class {</span><span class="s2">\n  </span><span class="s1">constructor(status, statusText, data2, internal = false) {</span><span class="s2">\n    </span><span class="s1">this.status = status;</span><span class="s2">\n    </span><span class="s1">this.statusText = statusText || </span><span class="s2">\&quot;\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">this.internal = internal;</span><span class="s2">\n    </span><span class="s1">if (data2 instanceof Error) {</span><span class="s2">\n      </span><span class="s1">this.data = data2.toString();</span><span class="s2">\n      </span><span class="s1">this.error = data2;</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">this.data = data2;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">function isRouteErrorResponse(error) {</span><span class="s2">\n  </span><span class="s1">return error != null &amp;&amp; typeof error.status === </span><span class="s2">\&quot;</span><span class="s1">number</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; typeof error.statusText === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; typeof error.internal === </span><span class="s2">\&quot;</span><span class="s1">boolean</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; </span><span class="s2">\&quot;</span><span class="s1">data</span><span class="s2">\&quot; </span><span class="s1">in error;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/router/router.ts</span><span class="s2">\n</span><span class="s1">var validMutationMethodsArr = [</span><span class="s2">\&quot;</span><span class="s1">POST</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">PUT</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">PATCH</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">DELETE</span><span class="s2">\&quot;</span><span class="s1">];</span><span class="s2">\n</span><span class="s1">var validMutationMethods = new Set(validMutationMethodsArr);</span><span class="s2">\n</span><span class="s1">var validRequestMethodsArr = [</span><span class="s2">\&quot;</span><span class="s1">GET</span><span class="s2">\&quot;</span><span class="s1">, ...validMutationMethodsArr];</span><span class="s2">\n</span><span class="s1">var validRequestMethods = new Set(validRequestMethodsArr);</span><span class="s2">\n</span><span class="s1">var redirectStatusCodes = /* @__PURE__ */new Set([301, 302, 303, 307, 308]);</span><span class="s2">\n</span><span class="s1">var redirectPreserveMethodStatusCodes = /* @__PURE__ */new Set([307, 308]);</span><span class="s2">\n</span><span class="s1">var IDLE_NAVIGATION = {</span><span class="s2">\n  </span><span class="s1">state: </span><span class="s2">\&quot;</span><span class="s1">idle</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">location: void 0,</span><span class="s2">\n  </span><span class="s1">formMethod: void 0,</span><span class="s2">\n  </span><span class="s1">formAction: void 0,</span><span class="s2">\n  </span><span class="s1">formEncType: void 0,</span><span class="s2">\n  </span><span class="s1">formData: void 0,</span><span class="s2">\n  </span><span class="s1">json: void 0,</span><span class="s2">\n  </span><span class="s1">text: void 0</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">var IDLE_FETCHER = {</span><span class="s2">\n  </span><span class="s1">state: </span><span class="s2">\&quot;</span><span class="s1">idle</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">data: void 0,</span><span class="s2">\n  </span><span class="s1">formMethod: void 0,</span><span class="s2">\n  </span><span class="s1">formAction: void 0,</span><span class="s2">\n  </span><span class="s1">formEncType: void 0,</span><span class="s2">\n  </span><span class="s1">formData: void 0,</span><span class="s2">\n  </span><span class="s1">json: void 0,</span><span class="s2">\n  </span><span class="s1">text: void 0</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">var IDLE_BLOCKER = {</span><span class="s2">\n  </span><span class="s1">state: </span><span class="s2">\&quot;</span><span class="s1">unblocked</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">proceed: void 0,</span><span class="s2">\n  </span><span class="s1">reset: void 0,</span><span class="s2">\n  </span><span class="s1">location: void 0</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">var ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|</span><span class="s2">\\</span><span class="s1">/</span><span class="s2">\\</span><span class="s1">/)/i;</span><span class="s2">\n</span><span class="s1">var defaultMapRouteProperties = route =&gt; ({</span><span class="s2">\n  </span><span class="s1">hasErrorBoundary: Boolean(route.hasErrorBoundary)</span><span class="s2">\n</span><span class="s1">});</span><span class="s2">\n</span><span class="s1">var TRANSITIONS_STORAGE_KEY = </span><span class="s2">\&quot;</span><span class="s1">remix-router-transitions</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">var ResetLoaderDataSymbol = Symbol(</span><span class="s2">\&quot;</span><span class="s1">ResetLoaderData</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n</span><span class="s1">function createRouter(init) {</span><span class="s2">\n  </span><span class="s1">const routerWindow = init.window ? init.window : typeof window !== </span><span class="s2">\&quot;</span><span class="s1">undefined</span><span class="s2">\&quot; </span><span class="s1">? window : void 0;</span><span class="s2">\n  </span><span class="s1">const isBrowser2 = typeof routerWindow !== </span><span class="s2">\&quot;</span><span class="s1">undefined</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; typeof routerWindow.document !== </span><span class="s2">\&quot;</span><span class="s1">undefined</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; typeof routerWindow.document.createElement !== </span><span class="s2">\&quot;</span><span class="s1">undefined</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">invariant(init.routes.length &gt; 0, </span><span class="s2">\&quot;</span><span class="s1">You must provide a non-empty routes array to createRouter</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let hydrationRouteProperties2 = init.hydrationRouteProperties || [];</span><span class="s2">\n  </span><span class="s1">let mapRouteProperties2 = init.mapRouteProperties || defaultMapRouteProperties;</span><span class="s2">\n  </span><span class="s1">let manifest = {};</span><span class="s2">\n  </span><span class="s1">let dataRoutes = convertRoutesToDataRoutes(init.routes, mapRouteProperties2, void 0, manifest);</span><span class="s2">\n  </span><span class="s1">let inFlightDataRoutes;</span><span class="s2">\n  </span><span class="s1">let basename = init.basename || </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">let dataStrategyImpl = init.dataStrategy || defaultDataStrategyWithMiddleware;</span><span class="s2">\n  </span><span class="s1">let future = {</span><span class="s2">\n    </span><span class="s1">unstable_middleware: false,</span><span class="s2">\n    </span><span class="s1">...init.future</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">let unlistenHistory = null;</span><span class="s2">\n  </span><span class="s1">let subscribers = /* @__PURE__ */new Set();</span><span class="s2">\n  </span><span class="s1">let savedScrollPositions2 = null;</span><span class="s2">\n  </span><span class="s1">let getScrollRestorationKey2 = null;</span><span class="s2">\n  </span><span class="s1">let getScrollPosition = null;</span><span class="s2">\n  </span><span class="s1">let initialScrollRestored = init.hydrationData != null;</span><span class="s2">\n  </span><span class="s1">let initialMatches = matchRoutes(dataRoutes, init.history.location, basename);</span><span class="s2">\n  </span><span class="s1">let initialMatchesIsFOW = false;</span><span class="s2">\n  </span><span class="s1">let initialErrors = null;</span><span class="s2">\n  </span><span class="s1">let initialized;</span><span class="s2">\n  </span><span class="s1">if (initialMatches == null &amp;&amp; !init.patchRoutesOnNavigation) {</span><span class="s2">\n    </span><span class="s1">let error = getInternalRouterError(404, {</span><span class="s2">\n      </span><span class="s1">pathname: init.history.location.pathname</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">let {</span><span class="s2">\n      </span><span class="s1">matches,</span><span class="s2">\n      </span><span class="s1">route</span><span class="s2">\n    </span><span class="s1">} = getShortCircuitMatches(dataRoutes);</span><span class="s2">\n    </span><span class="s1">initialized = true;</span><span class="s2">\n    </span><span class="s1">initialMatches = matches;</span><span class="s2">\n    </span><span class="s1">initialErrors = {</span><span class="s2">\n      </span><span class="s1">[route.id]: error</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">if (initialMatches &amp;&amp; !init.hydrationData) {</span><span class="s2">\n      </span><span class="s1">let fogOfWar = checkFogOfWar(initialMatches, dataRoutes, init.history.location.pathname);</span><span class="s2">\n      </span><span class="s1">if (fogOfWar.active) {</span><span class="s2">\n        </span><span class="s1">initialMatches = null;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (!initialMatches) {</span><span class="s2">\n      </span><span class="s1">initialized = false;</span><span class="s2">\n      </span><span class="s1">initialMatches = [];</span><span class="s2">\n      </span><span class="s1">let fogOfWar = checkFogOfWar(null, dataRoutes, init.history.location.pathname);</span><span class="s2">\n      </span><span class="s1">if (fogOfWar.active &amp;&amp; fogOfWar.matches) {</span><span class="s2">\n        </span><span class="s1">initialMatchesIsFOW = true;</span><span class="s2">\n        </span><span class="s1">initialMatches = fogOfWar.matches;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else if (initialMatches.some(m =&gt; m.route.lazy)) {</span><span class="s2">\n      </span><span class="s1">initialized = false;</span><span class="s2">\n    </span><span class="s1">} else if (!initialMatches.some(m =&gt; m.route.loader)) {</span><span class="s2">\n      </span><span class="s1">initialized = true;</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">let loaderData = init.hydrationData ? init.hydrationData.loaderData : null;</span><span class="s2">\n      </span><span class="s1">let errors = init.hydrationData ? init.hydrationData.errors : null;</span><span class="s2">\n      </span><span class="s1">if (errors) {</span><span class="s2">\n        </span><span class="s1">let idx = initialMatches.findIndex(m =&gt; errors[m.route.id] !== void 0);</span><span class="s2">\n        </span><span class="s1">initialized = initialMatches.slice(0, idx + 1).every(m =&gt; !shouldLoadRouteOnHydration(m.route, loaderData, errors));</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">initialized = initialMatches.every(m =&gt; !shouldLoadRouteOnHydration(m.route, loaderData, errors));</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let router;</span><span class="s2">\n  </span><span class="s1">let state = {</span><span class="s2">\n    </span><span class="s1">historyAction: init.history.action,</span><span class="s2">\n    </span><span class="s1">location: init.history.location,</span><span class="s2">\n    </span><span class="s1">matches: initialMatches,</span><span class="s2">\n    </span><span class="s1">initialized,</span><span class="s2">\n    </span><span class="s1">navigation: IDLE_NAVIGATION,</span><span class="s2">\n    </span><span class="s1">// Don't restore on initial updateState() if we were SSR'd</span><span class="s2">\n    </span><span class="s1">restoreScrollPosition: init.hydrationData != null ? false : null,</span><span class="s2">\n    </span><span class="s1">preventScrollReset: false,</span><span class="s2">\n    </span><span class="s1">revalidation: </span><span class="s2">\&quot;</span><span class="s1">idle</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">loaderData: init.hydrationData &amp;&amp; init.hydrationData.loaderData || {},</span><span class="s2">\n    </span><span class="s1">actionData: init.hydrationData &amp;&amp; init.hydrationData.actionData || null,</span><span class="s2">\n    </span><span class="s1">errors: init.hydrationData &amp;&amp; init.hydrationData.errors || initialErrors,</span><span class="s2">\n    </span><span class="s1">fetchers: /* @__PURE__ */new Map(),</span><span class="s2">\n    </span><span class="s1">blockers: /* @__PURE__ */new Map()</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">let pendingAction = </span><span class="s2">\&quot;</span><span class="s1">POP</span><span class="s2">\&quot; </span><span class="s1">/* Pop */;</span><span class="s2">\n  </span><span class="s1">let pendingPreventScrollReset = false;</span><span class="s2">\n  </span><span class="s1">let pendingNavigationController;</span><span class="s2">\n  </span><span class="s1">let pendingViewTransitionEnabled = false;</span><span class="s2">\n  </span><span class="s1">let appliedViewTransitions = /* @__PURE__ */new Map();</span><span class="s2">\n  </span><span class="s1">let removePageHideEventListener = null;</span><span class="s2">\n  </span><span class="s1">let isUninterruptedRevalidation = false;</span><span class="s2">\n  </span><span class="s1">let isRevalidationRequired = false;</span><span class="s2">\n  </span><span class="s1">let cancelledFetcherLoads = /* @__PURE__ */new Set();</span><span class="s2">\n  </span><span class="s1">let fetchControllers = /* @__PURE__ */new Map();</span><span class="s2">\n  </span><span class="s1">let incrementingLoadId = 0;</span><span class="s2">\n  </span><span class="s1">let pendingNavigationLoadId = -1;</span><span class="s2">\n  </span><span class="s1">let fetchReloadIds = /* @__PURE__ */new Map();</span><span class="s2">\n  </span><span class="s1">let fetchRedirectIds = /* @__PURE__ */new Set();</span><span class="s2">\n  </span><span class="s1">let fetchLoadMatches = /* @__PURE__ */new Map();</span><span class="s2">\n  </span><span class="s1">let activeFetchers = /* @__PURE__ */new Map();</span><span class="s2">\n  </span><span class="s1">let fetchersQueuedForDeletion = /* @__PURE__ */new Set();</span><span class="s2">\n  </span><span class="s1">let blockerFunctions = /* @__PURE__ */new Map();</span><span class="s2">\n  </span><span class="s1">let unblockBlockerHistoryUpdate = void 0;</span><span class="s2">\n  </span><span class="s1">let pendingRevalidationDfd = null;</span><span class="s2">\n  </span><span class="s1">function initialize() {</span><span class="s2">\n    </span><span class="s1">unlistenHistory = init.history.listen(({</span><span class="s2">\n      </span><span class="s1">action: historyAction,</span><span class="s2">\n      </span><span class="s1">location,</span><span class="s2">\n      </span><span class="s1">delta</span><span class="s2">\n    </span><span class="s1">}) =&gt; {</span><span class="s2">\n      </span><span class="s1">if (unblockBlockerHistoryUpdate) {</span><span class="s2">\n        </span><span class="s1">unblockBlockerHistoryUpdate();</span><span class="s2">\n        </span><span class="s1">unblockBlockerHistoryUpdate = void 0;</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">warning(blockerFunctions.size === 0 || delta != null, </span><span class="s2">\&quot;</span><span class="s1">You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">let blockerKey = shouldBlockNavigation({</span><span class="s2">\n        </span><span class="s1">currentLocation: state.location,</span><span class="s2">\n        </span><span class="s1">nextLocation: location,</span><span class="s2">\n        </span><span class="s1">historyAction</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">if (blockerKey &amp;&amp; delta != null) {</span><span class="s2">\n        </span><span class="s1">let nextHistoryUpdatePromise = new Promise(resolve =&gt; {</span><span class="s2">\n          </span><span class="s1">unblockBlockerHistoryUpdate = resolve;</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">init.history.go(delta * -1);</span><span class="s2">\n        </span><span class="s1">updateBlocker(blockerKey, {</span><span class="s2">\n          </span><span class="s1">state: </span><span class="s2">\&quot;</span><span class="s1">blocked</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n          </span><span class="s1">location,</span><span class="s2">\n          </span><span class="s1">proceed() {</span><span class="s2">\n            </span><span class="s1">updateBlocker(blockerKey, {</span><span class="s2">\n              </span><span class="s1">state: </span><span class="s2">\&quot;</span><span class="s1">proceeding</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n              </span><span class="s1">proceed: void 0,</span><span class="s2">\n              </span><span class="s1">reset: void 0,</span><span class="s2">\n              </span><span class="s1">location</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n            </span><span class="s1">nextHistoryUpdatePromise.then(() =&gt; init.history.go(delta));</span><span class="s2">\n          </span><span class="s1">},</span><span class="s2">\n          </span><span class="s1">reset() {</span><span class="s2">\n            </span><span class="s1">let blockers = new Map(state.blockers);</span><span class="s2">\n            </span><span class="s1">blockers.set(blockerKey, IDLE_BLOCKER);</span><span class="s2">\n            </span><span class="s1">updateState({</span><span class="s2">\n              </span><span class="s1">blockers</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return startNavigation(historyAction, location);</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">if (isBrowser2) {</span><span class="s2">\n      </span><span class="s1">restoreAppliedTransitions(routerWindow, appliedViewTransitions);</span><span class="s2">\n      </span><span class="s1">let _saveAppliedTransitions = () =&gt; persistAppliedTransitions(routerWindow, appliedViewTransitions);</span><span class="s2">\n      </span><span class="s1">routerWindow.addEventListener(</span><span class="s2">\&quot;</span><span class="s1">pagehide</span><span class="s2">\&quot;</span><span class="s1">, _saveAppliedTransitions);</span><span class="s2">\n      </span><span class="s1">removePageHideEventListener = () =&gt; routerWindow.removeEventListener(</span><span class="s2">\&quot;</span><span class="s1">pagehide</span><span class="s2">\&quot;</span><span class="s1">, _saveAppliedTransitions);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (!state.initialized) {</span><span class="s2">\n      </span><span class="s1">startNavigation(</span><span class="s2">\&quot;</span><span class="s1">POP</span><span class="s2">\&quot; </span><span class="s1">/* Pop */, state.location, {</span><span class="s2">\n        </span><span class="s1">initialHydration: true</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return router;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function dispose() {</span><span class="s2">\n    </span><span class="s1">if (unlistenHistory) {</span><span class="s2">\n      </span><span class="s1">unlistenHistory();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (removePageHideEventListener) {</span><span class="s2">\n      </span><span class="s1">removePageHideEventListener();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">subscribers.clear();</span><span class="s2">\n    </span><span class="s1">pendingNavigationController &amp;&amp; pendingNavigationController.abort();</span><span class="s2">\n    </span><span class="s1">state.fetchers.forEach((_, key) =&gt; deleteFetcher(key));</span><span class="s2">\n    </span><span class="s1">state.blockers.forEach((_, key) =&gt; deleteBlocker(key));</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function subscribe(fn) {</span><span class="s2">\n    </span><span class="s1">subscribers.add(fn);</span><span class="s2">\n    </span><span class="s1">return () =&gt; subscribers.delete(fn);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function updateState(newState, opts = {}) {</span><span class="s2">\n    </span><span class="s1">state = {</span><span class="s2">\n      </span><span class="s1">...state,</span><span class="s2">\n      </span><span class="s1">...newState</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">let unmountedFetchers = [];</span><span class="s2">\n    </span><span class="s1">let mountedFetchers = [];</span><span class="s2">\n    </span><span class="s1">state.fetchers.forEach((fetcher, key) =&gt; {</span><span class="s2">\n      </span><span class="s1">if (fetcher.state === </span><span class="s2">\&quot;</span><span class="s1">idle</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">if (fetchersQueuedForDeletion.has(key)) {</span><span class="s2">\n          </span><span class="s1">unmountedFetchers.push(key);</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">mountedFetchers.push(key);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">fetchersQueuedForDeletion.forEach(key =&gt; {</span><span class="s2">\n      </span><span class="s1">if (!state.fetchers.has(key) &amp;&amp; !fetchControllers.has(key)) {</span><span class="s2">\n        </span><span class="s1">unmountedFetchers.push(key);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">[...subscribers].forEach(subscriber =&gt; subscriber(state, {</span><span class="s2">\n      </span><span class="s1">deletedFetchers: unmountedFetchers,</span><span class="s2">\n      </span><span class="s1">viewTransitionOpts: opts.viewTransitionOpts,</span><span class="s2">\n      </span><span class="s1">flushSync: opts.flushSync === true</span><span class="s2">\n    </span><span class="s1">}));</span><span class="s2">\n    </span><span class="s1">unmountedFetchers.forEach(key =&gt; deleteFetcher(key));</span><span class="s2">\n    </span><span class="s1">mountedFetchers.forEach(key =&gt; state.fetchers.delete(key));</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function completeNavigation(location, newState, {</span><span class="s2">\n    </span><span class="s1">flushSync</span><span class="s2">\n  </span><span class="s1">} = {}) {</span><span class="s2">\n    </span><span class="s1">let isActionReload = state.actionData != null &amp;&amp; state.navigation.formMethod != null &amp;&amp; isMutationMethod(state.navigation.formMethod) &amp;&amp; state.navigation.state === </span><span class="s2">\&quot;</span><span class="s1">loading</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; location.state?._isRedirect !== true;</span><span class="s2">\n    </span><span class="s1">let actionData;</span><span class="s2">\n    </span><span class="s1">if (newState.actionData) {</span><span class="s2">\n      </span><span class="s1">if (Object.keys(newState.actionData).length &gt; 0) {</span><span class="s2">\n        </span><span class="s1">actionData = newState.actionData;</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">actionData = null;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else if (isActionReload) {</span><span class="s2">\n      </span><span class="s1">actionData = state.actionData;</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">actionData = null;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let loaderData = newState.loaderData ? mergeLoaderData(state.loaderData, newState.loaderData, newState.matches || [], newState.errors) : state.loaderData;</span><span class="s2">\n    </span><span class="s1">let blockers = state.blockers;</span><span class="s2">\n    </span><span class="s1">if (blockers.size &gt; 0) {</span><span class="s2">\n      </span><span class="s1">blockers = new Map(blockers);</span><span class="s2">\n      </span><span class="s1">blockers.forEach((_, k) =&gt; blockers.set(k, IDLE_BLOCKER));</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let preventScrollReset = pendingPreventScrollReset === true || state.navigation.formMethod != null &amp;&amp; isMutationMethod(state.navigation.formMethod) &amp;&amp; location.state?._isRedirect !== true;</span><span class="s2">\n    </span><span class="s1">if (inFlightDataRoutes) {</span><span class="s2">\n      </span><span class="s1">dataRoutes = inFlightDataRoutes;</span><span class="s2">\n      </span><span class="s1">inFlightDataRoutes = void 0;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (isUninterruptedRevalidation) {} else if (pendingAction === </span><span class="s2">\&quot;</span><span class="s1">POP</span><span class="s2">\&quot; </span><span class="s1">/* Pop */) {} else if (pendingAction === </span><span class="s2">\&quot;</span><span class="s1">PUSH</span><span class="s2">\&quot; </span><span class="s1">/* Push */) {</span><span class="s2">\n      </span><span class="s1">init.history.push(location, location.state);</span><span class="s2">\n    </span><span class="s1">} else if (pendingAction === </span><span class="s2">\&quot;</span><span class="s1">REPLACE</span><span class="s2">\&quot; </span><span class="s1">/* Replace */) {</span><span class="s2">\n      </span><span class="s1">init.history.replace(location, location.state);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let viewTransitionOpts;</span><span class="s2">\n    </span><span class="s1">if (pendingAction === </span><span class="s2">\&quot;</span><span class="s1">POP</span><span class="s2">\&quot; </span><span class="s1">/* Pop */) {</span><span class="s2">\n      </span><span class="s1">let priorPaths = appliedViewTransitions.get(state.location.pathname);</span><span class="s2">\n      </span><span class="s1">if (priorPaths &amp;&amp; priorPaths.has(location.pathname)) {</span><span class="s2">\n        </span><span class="s1">viewTransitionOpts = {</span><span class="s2">\n          </span><span class="s1">currentLocation: state.location,</span><span class="s2">\n          </span><span class="s1">nextLocation: location</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">} else if (appliedViewTransitions.has(location.pathname)) {</span><span class="s2">\n        </span><span class="s1">viewTransitionOpts = {</span><span class="s2">\n          </span><span class="s1">currentLocation: location,</span><span class="s2">\n          </span><span class="s1">nextLocation: state.location</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else if (pendingViewTransitionEnabled) {</span><span class="s2">\n      </span><span class="s1">let toPaths = appliedViewTransitions.get(state.location.pathname);</span><span class="s2">\n      </span><span class="s1">if (toPaths) {</span><span class="s2">\n        </span><span class="s1">toPaths.add(location.pathname);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">toPaths = /* @__PURE__ */new Set([location.pathname]);</span><span class="s2">\n        </span><span class="s1">appliedViewTransitions.set(state.location.pathname, toPaths);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">viewTransitionOpts = {</span><span class="s2">\n        </span><span class="s1">currentLocation: state.location,</span><span class="s2">\n        </span><span class="s1">nextLocation: location</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">updateState({</span><span class="s2">\n      </span><span class="s1">...newState,</span><span class="s2">\n      </span><span class="s1">// matches, errors, fetchers go through as-is</span><span class="s2">\n      </span><span class="s1">actionData,</span><span class="s2">\n      </span><span class="s1">loaderData,</span><span class="s2">\n      </span><span class="s1">historyAction: pendingAction,</span><span class="s2">\n      </span><span class="s1">location,</span><span class="s2">\n      </span><span class="s1">initialized: true,</span><span class="s2">\n      </span><span class="s1">navigation: IDLE_NAVIGATION,</span><span class="s2">\n      </span><span class="s1">revalidation: </span><span class="s2">\&quot;</span><span class="s1">idle</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">restoreScrollPosition: getSavedScrollPosition(location, newState.matches || state.matches),</span><span class="s2">\n      </span><span class="s1">preventScrollReset,</span><span class="s2">\n      </span><span class="s1">blockers</span><span class="s2">\n    </span><span class="s1">}, {</span><span class="s2">\n      </span><span class="s1">viewTransitionOpts,</span><span class="s2">\n      </span><span class="s1">flushSync: flushSync === true</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">pendingAction = </span><span class="s2">\&quot;</span><span class="s1">POP</span><span class="s2">\&quot; </span><span class="s1">/* Pop */;</span><span class="s2">\n    </span><span class="s1">pendingPreventScrollReset = false;</span><span class="s2">\n    </span><span class="s1">pendingViewTransitionEnabled = false;</span><span class="s2">\n    </span><span class="s1">isUninterruptedRevalidation = false;</span><span class="s2">\n    </span><span class="s1">isRevalidationRequired = false;</span><span class="s2">\n    </span><span class="s1">pendingRevalidationDfd?.resolve();</span><span class="s2">\n    </span><span class="s1">pendingRevalidationDfd = null;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">async function navigate(to, opts) {</span><span class="s2">\n    </span><span class="s1">if (typeof to === </span><span class="s2">\&quot;</span><span class="s1">number</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">init.history.go(to);</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let normalizedPath = normalizeTo(state.location, state.matches, basename, to, opts?.fromRouteId, opts?.relative);</span><span class="s2">\n    </span><span class="s1">let {</span><span class="s2">\n      </span><span class="s1">path,</span><span class="s2">\n      </span><span class="s1">submission,</span><span class="s2">\n      </span><span class="s1">error</span><span class="s2">\n    </span><span class="s1">} = normalizeNavigateOptions(false, normalizedPath, opts);</span><span class="s2">\n    </span><span class="s1">let currentLocation = state.location;</span><span class="s2">\n    </span><span class="s1">let nextLocation = createLocation(state.location, path, opts &amp;&amp; opts.state);</span><span class="s2">\n    </span><span class="s1">nextLocation = {</span><span class="s2">\n      </span><span class="s1">...nextLocation,</span><span class="s2">\n      </span><span class="s1">...init.history.encodeLocation(nextLocation)</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">let userReplace = opts &amp;&amp; opts.replace != null ? opts.replace : void 0;</span><span class="s2">\n    </span><span class="s1">let historyAction = </span><span class="s2">\&quot;</span><span class="s1">PUSH</span><span class="s2">\&quot; </span><span class="s1">/* Push */;</span><span class="s2">\n    </span><span class="s1">if (userReplace === true) {</span><span class="s2">\n      </span><span class="s1">historyAction = </span><span class="s2">\&quot;</span><span class="s1">REPLACE</span><span class="s2">\&quot; </span><span class="s1">/* Replace */;</span><span class="s2">\n    </span><span class="s1">} else if (userReplace === false) {} else if (submission != null &amp;&amp; isMutationMethod(submission.formMethod) &amp;&amp; submission.formAction === state.location.pathname + state.location.search) {</span><span class="s2">\n      </span><span class="s1">historyAction = </span><span class="s2">\&quot;</span><span class="s1">REPLACE</span><span class="s2">\&quot; </span><span class="s1">/* Replace */;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let preventScrollReset = opts &amp;&amp; </span><span class="s2">\&quot;</span><span class="s1">preventScrollReset</span><span class="s2">\&quot; </span><span class="s1">in opts ? opts.preventScrollReset === true : void 0;</span><span class="s2">\n    </span><span class="s1">let flushSync = (opts &amp;&amp; opts.flushSync) === true;</span><span class="s2">\n    </span><span class="s1">let blockerKey = shouldBlockNavigation({</span><span class="s2">\n      </span><span class="s1">currentLocation,</span><span class="s2">\n      </span><span class="s1">nextLocation,</span><span class="s2">\n      </span><span class="s1">historyAction</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">if (blockerKey) {</span><span class="s2">\n      </span><span class="s1">updateBlocker(blockerKey, {</span><span class="s2">\n        </span><span class="s1">state: </span><span class="s2">\&quot;</span><span class="s1">blocked</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        </span><span class="s1">location: nextLocation,</span><span class="s2">\n        </span><span class="s1">proceed() {</span><span class="s2">\n          </span><span class="s1">updateBlocker(blockerKey, {</span><span class="s2">\n            </span><span class="s1">state: </span><span class="s2">\&quot;</span><span class="s1">proceeding</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n            </span><span class="s1">proceed: void 0,</span><span class="s2">\n            </span><span class="s1">reset: void 0,</span><span class="s2">\n            </span><span class="s1">location: nextLocation</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n          </span><span class="s1">navigate(to, opts);</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">reset() {</span><span class="s2">\n          </span><span class="s1">let blockers = new Map(state.blockers);</span><span class="s2">\n          </span><span class="s1">blockers.set(blockerKey, IDLE_BLOCKER);</span><span class="s2">\n          </span><span class="s1">updateState({</span><span class="s2">\n            </span><span class="s1">blockers</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">await startNavigation(historyAction, nextLocation, {</span><span class="s2">\n      </span><span class="s1">submission,</span><span class="s2">\n      </span><span class="s1">// Send through the formData serialization error if we have one so we can</span><span class="s2">\n      </span><span class="s1">// render at the right error boundary after we match routes</span><span class="s2">\n      </span><span class="s1">pendingError: error,</span><span class="s2">\n      </span><span class="s1">preventScrollReset,</span><span class="s2">\n      </span><span class="s1">replace: opts &amp;&amp; opts.replace,</span><span class="s2">\n      </span><span class="s1">enableViewTransition: opts &amp;&amp; opts.viewTransition,</span><span class="s2">\n      </span><span class="s1">flushSync</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function revalidate() {</span><span class="s2">\n    </span><span class="s1">if (!pendingRevalidationDfd) {</span><span class="s2">\n      </span><span class="s1">pendingRevalidationDfd = createDeferred();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">interruptActiveLoads();</span><span class="s2">\n    </span><span class="s1">updateState({</span><span class="s2">\n      </span><span class="s1">revalidation: </span><span class="s2">\&quot;</span><span class="s1">loading</span><span class="s2">\&quot;\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">let promise = pendingRevalidationDfd.promise;</span><span class="s2">\n    </span><span class="s1">if (state.navigation.state === </span><span class="s2">\&quot;</span><span class="s1">submitting</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">return promise;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (state.navigation.state === </span><span class="s2">\&quot;</span><span class="s1">idle</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">startNavigation(state.historyAction, state.location, {</span><span class="s2">\n        </span><span class="s1">startUninterruptedRevalidation: true</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">return promise;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">startNavigation(pendingAction || state.historyAction, state.navigation.location, {</span><span class="s2">\n      </span><span class="s1">overrideNavigation: state.navigation,</span><span class="s2">\n      </span><span class="s1">// Proxy through any rending view transition</span><span class="s2">\n      </span><span class="s1">enableViewTransition: pendingViewTransitionEnabled === true</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">return promise;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">async function startNavigation(historyAction, location, opts) {</span><span class="s2">\n    </span><span class="s1">pendingNavigationController &amp;&amp; pendingNavigationController.abort();</span><span class="s2">\n    </span><span class="s1">pendingNavigationController = null;</span><span class="s2">\n    </span><span class="s1">pendingAction = historyAction;</span><span class="s2">\n    </span><span class="s1">isUninterruptedRevalidation = (opts &amp;&amp; opts.startUninterruptedRevalidation) === true;</span><span class="s2">\n    </span><span class="s1">saveScrollPosition(state.location, state.matches);</span><span class="s2">\n    </span><span class="s1">pendingPreventScrollReset = (opts &amp;&amp; opts.preventScrollReset) === true;</span><span class="s2">\n    </span><span class="s1">pendingViewTransitionEnabled = (opts &amp;&amp; opts.enableViewTransition) === true;</span><span class="s2">\n    </span><span class="s1">let routesToUse = inFlightDataRoutes || dataRoutes;</span><span class="s2">\n    </span><span class="s1">let loadingNavigation = opts &amp;&amp; opts.overrideNavigation;</span><span class="s2">\n    </span><span class="s1">let matches = opts?.initialHydration &amp;&amp; state.matches &amp;&amp; state.matches.length &gt; 0 &amp;&amp; !initialMatchesIsFOW ?</span><span class="s2">\n    </span><span class="s1">// `matchRoutes()` has already been called if we're in here via `router.initialize()`</span><span class="s2">\n    </span><span class="s1">state.matches : matchRoutes(routesToUse, location, basename);</span><span class="s2">\n    </span><span class="s1">let flushSync = (opts &amp;&amp; opts.flushSync) === true;</span><span class="s2">\n    </span><span class="s1">if (matches &amp;&amp; state.initialized &amp;&amp; !isRevalidationRequired &amp;&amp; isHashChangeOnly(state.location, location) &amp;&amp; !(opts &amp;&amp; opts.submission &amp;&amp; isMutationMethod(opts.submission.formMethod))) {</span><span class="s2">\n      </span><span class="s1">completeNavigation(location, {</span><span class="s2">\n        </span><span class="s1">matches</span><span class="s2">\n      </span><span class="s1">}, {</span><span class="s2">\n        </span><span class="s1">flushSync</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let fogOfWar = checkFogOfWar(matches, routesToUse, location.pathname);</span><span class="s2">\n    </span><span class="s1">if (fogOfWar.active &amp;&amp; fogOfWar.matches) {</span><span class="s2">\n      </span><span class="s1">matches = fogOfWar.matches;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (!matches) {</span><span class="s2">\n      </span><span class="s1">let {</span><span class="s2">\n        </span><span class="s1">error,</span><span class="s2">\n        </span><span class="s1">notFoundMatches,</span><span class="s2">\n        </span><span class="s1">route</span><span class="s2">\n      </span><span class="s1">} = handleNavigational404(location.pathname);</span><span class="s2">\n      </span><span class="s1">completeNavigation(location, {</span><span class="s2">\n        </span><span class="s1">matches: notFoundMatches,</span><span class="s2">\n        </span><span class="s1">loaderData: {},</span><span class="s2">\n        </span><span class="s1">errors: {</span><span class="s2">\n          </span><span class="s1">[route.id]: error</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}, {</span><span class="s2">\n        </span><span class="s1">flushSync</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">pendingNavigationController = new AbortController();</span><span class="s2">\n    </span><span class="s1">let request = createClientSideRequest(init.history, location, pendingNavigationController.signal, opts &amp;&amp; opts.submission);</span><span class="s2">\n    </span><span class="s1">let scopedContext = new unstable_RouterContextProvider(init.unstable_getContext ? await init.unstable_getContext() : void 0);</span><span class="s2">\n    </span><span class="s1">let pendingActionResult;</span><span class="s2">\n    </span><span class="s1">if (opts &amp;&amp; opts.pendingError) {</span><span class="s2">\n      </span><span class="s1">pendingActionResult = [findNearestBoundary(matches).route.id, {</span><span class="s2">\n        </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">error</span><span class="s2">\&quot; </span><span class="s1">/* error */,</span><span class="s2">\n        </span><span class="s1">error: opts.pendingError</span><span class="s2">\n      </span><span class="s1">}];</span><span class="s2">\n    </span><span class="s1">} else if (opts &amp;&amp; opts.submission &amp;&amp; isMutationMethod(opts.submission.formMethod)) {</span><span class="s2">\n      </span><span class="s1">let actionResult = await handleAction(request, location, opts.submission, matches, scopedContext, fogOfWar.active, opts &amp;&amp; opts.initialHydration === true, {</span><span class="s2">\n        </span><span class="s1">replace: opts.replace,</span><span class="s2">\n        </span><span class="s1">flushSync</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">if (actionResult.shortCircuited) {</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (actionResult.pendingActionResult) {</span><span class="s2">\n        </span><span class="s1">let [routeId, result] = actionResult.pendingActionResult;</span><span class="s2">\n        </span><span class="s1">if (isErrorResult(result) &amp;&amp; isRouteErrorResponse(result.error) &amp;&amp; result.error.status === 404) {</span><span class="s2">\n          </span><span class="s1">pendingNavigationController = null;</span><span class="s2">\n          </span><span class="s1">completeNavigation(location, {</span><span class="s2">\n            </span><span class="s1">matches: actionResult.matches,</span><span class="s2">\n            </span><span class="s1">loaderData: {},</span><span class="s2">\n            </span><span class="s1">errors: {</span><span class="s2">\n              </span><span class="s1">[routeId]: result.error</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n          </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">matches = actionResult.matches || matches;</span><span class="s2">\n      </span><span class="s1">pendingActionResult = actionResult.pendingActionResult;</span><span class="s2">\n      </span><span class="s1">loadingNavigation = getLoadingNavigation(location, opts.submission);</span><span class="s2">\n      </span><span class="s1">flushSync = false;</span><span class="s2">\n      </span><span class="s1">fogOfWar.active = false;</span><span class="s2">\n      </span><span class="s1">request = createClientSideRequest(init.history, request.url, request.signal);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let {</span><span class="s2">\n      </span><span class="s1">shortCircuited,</span><span class="s2">\n      </span><span class="s1">matches: updatedMatches,</span><span class="s2">\n      </span><span class="s1">loaderData,</span><span class="s2">\n      </span><span class="s1">errors</span><span class="s2">\n    </span><span class="s1">} = await handleLoaders(request, location, matches, scopedContext, fogOfWar.active, loadingNavigation, opts &amp;&amp; opts.submission, opts &amp;&amp; opts.fetcherSubmission, opts &amp;&amp; opts.replace, opts &amp;&amp; opts.initialHydration === true, flushSync, pendingActionResult);</span><span class="s2">\n    </span><span class="s1">if (shortCircuited) {</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">pendingNavigationController = null;</span><span class="s2">\n    </span><span class="s1">completeNavigation(location, {</span><span class="s2">\n      </span><span class="s1">matches: updatedMatches || matches,</span><span class="s2">\n      </span><span class="s1">...getActionDataForCommit(pendingActionResult),</span><span class="s2">\n      </span><span class="s1">loaderData,</span><span class="s2">\n      </span><span class="s1">errors</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">async function handleAction(request, location, submission, matches, scopedContext, isFogOfWar, initialHydration, opts = {}) {</span><span class="s2">\n    </span><span class="s1">interruptActiveLoads();</span><span class="s2">\n    </span><span class="s1">let navigation = getSubmittingNavigation(location, submission);</span><span class="s2">\n    </span><span class="s1">updateState({</span><span class="s2">\n      </span><span class="s1">navigation</span><span class="s2">\n    </span><span class="s1">}, {</span><span class="s2">\n      </span><span class="s1">flushSync: opts.flushSync === true</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">if (isFogOfWar) {</span><span class="s2">\n      </span><span class="s1">let discoverResult = await discoverRoutes(matches, location.pathname, request.signal);</span><span class="s2">\n      </span><span class="s1">if (discoverResult.type === </span><span class="s2">\&quot;</span><span class="s1">aborted</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">return {</span><span class="s2">\n          </span><span class="s1">shortCircuited: true</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">} else if (discoverResult.type === </span><span class="s2">\&quot;</span><span class="s1">error</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">let boundaryId = findNearestBoundary(discoverResult.partialMatches).route.id;</span><span class="s2">\n        </span><span class="s1">return {</span><span class="s2">\n          </span><span class="s1">matches: discoverResult.partialMatches,</span><span class="s2">\n          </span><span class="s1">pendingActionResult: [boundaryId, {</span><span class="s2">\n            </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">error</span><span class="s2">\&quot; </span><span class="s1">/* error */,</span><span class="s2">\n            </span><span class="s1">error: discoverResult.error</span><span class="s2">\n          </span><span class="s1">}]</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">} else if (!discoverResult.matches) {</span><span class="s2">\n        </span><span class="s1">let {</span><span class="s2">\n          </span><span class="s1">notFoundMatches,</span><span class="s2">\n          </span><span class="s1">error,</span><span class="s2">\n          </span><span class="s1">route</span><span class="s2">\n        </span><span class="s1">} = handleNavigational404(location.pathname);</span><span class="s2">\n        </span><span class="s1">return {</span><span class="s2">\n          </span><span class="s1">matches: notFoundMatches,</span><span class="s2">\n          </span><span class="s1">pendingActionResult: [route.id, {</span><span class="s2">\n            </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">error</span><span class="s2">\&quot; </span><span class="s1">/* error */,</span><span class="s2">\n            </span><span class="s1">error</span><span class="s2">\n          </span><span class="s1">}]</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">matches = discoverResult.matches;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let result;</span><span class="s2">\n    </span><span class="s1">let actionMatch = getTargetMatch(matches, location);</span><span class="s2">\n    </span><span class="s1">if (!actionMatch.route.action &amp;&amp; !actionMatch.route.lazy) {</span><span class="s2">\n      </span><span class="s1">result = {</span><span class="s2">\n        </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">error</span><span class="s2">\&quot; </span><span class="s1">/* error */,</span><span class="s2">\n        </span><span class="s1">error: getInternalRouterError(405, {</span><span class="s2">\n          </span><span class="s1">method: request.method,</span><span class="s2">\n          </span><span class="s1">pathname: location.pathname,</span><span class="s2">\n          </span><span class="s1">routeId: actionMatch.route.id</span><span class="s2">\n        </span><span class="s1">})</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">let dsMatches = getTargetedDataStrategyMatches(mapRouteProperties2, manifest, request, matches, actionMatch, initialHydration ? [] : hydrationRouteProperties2, scopedContext);</span><span class="s2">\n      </span><span class="s1">let results = await callDataStrategy(request, dsMatches, scopedContext, null);</span><span class="s2">\n      </span><span class="s1">result = results[actionMatch.route.id];</span><span class="s2">\n      </span><span class="s1">if (!result) {</span><span class="s2">\n        </span><span class="s1">for (let match of matches) {</span><span class="s2">\n          </span><span class="s1">if (results[match.route.id]) {</span><span class="s2">\n            </span><span class="s1">result = results[match.route.id];</span><span class="s2">\n            </span><span class="s1">break;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (request.signal.aborted) {</span><span class="s2">\n        </span><span class="s1">return {</span><span class="s2">\n          </span><span class="s1">shortCircuited: true</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (isRedirectResult(result)) {</span><span class="s2">\n      </span><span class="s1">let replace2;</span><span class="s2">\n      </span><span class="s1">if (opts &amp;&amp; opts.replace != null) {</span><span class="s2">\n        </span><span class="s1">replace2 = opts.replace;</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">let location2 = normalizeRedirectLocation(result.response.headers.get(</span><span class="s2">\&quot;</span><span class="s1">Location</span><span class="s2">\&quot;</span><span class="s1">), new URL(request.url), basename);</span><span class="s2">\n        </span><span class="s1">replace2 = location2 === state.location.pathname + state.location.search;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">await startRedirectNavigation(request, result, true, {</span><span class="s2">\n        </span><span class="s1">submission,</span><span class="s2">\n        </span><span class="s1">replace: replace2</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">return {</span><span class="s2">\n        </span><span class="s1">shortCircuited: true</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (isErrorResult(result)) {</span><span class="s2">\n      </span><span class="s1">let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);</span><span class="s2">\n      </span><span class="s1">if ((opts &amp;&amp; opts.replace) !== true) {</span><span class="s2">\n        </span><span class="s1">pendingAction = </span><span class="s2">\&quot;</span><span class="s1">PUSH</span><span class="s2">\&quot; </span><span class="s1">/* Push */;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return {</span><span class="s2">\n        </span><span class="s1">matches,</span><span class="s2">\n        </span><span class="s1">pendingActionResult: [boundaryMatch.route.id, result, actionMatch.route.id]</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return {</span><span class="s2">\n      </span><span class="s1">matches,</span><span class="s2">\n      </span><span class="s1">pendingActionResult: [actionMatch.route.id, result]</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">async function handleLoaders(request, location, matches, scopedContext, isFogOfWar, overrideNavigation, submission, fetcherSubmission, replace2, initialHydration, flushSync, pendingActionResult) {</span><span class="s2">\n    </span><span class="s1">let loadingNavigation = overrideNavigation || getLoadingNavigation(location, submission);</span><span class="s2">\n    </span><span class="s1">let activeSubmission = submission || fetcherSubmission || getSubmissionFromNavigation(loadingNavigation);</span><span class="s2">\n    </span><span class="s1">let shouldUpdateNavigationState = !isUninterruptedRevalidation &amp;&amp; !initialHydration;</span><span class="s2">\n    </span><span class="s1">if (isFogOfWar) {</span><span class="s2">\n      </span><span class="s1">if (shouldUpdateNavigationState) {</span><span class="s2">\n        </span><span class="s1">let actionData = getUpdatedActionData(pendingActionResult);</span><span class="s2">\n        </span><span class="s1">updateState({</span><span class="s2">\n          </span><span class="s1">navigation: loadingNavigation,</span><span class="s2">\n          </span><span class="s1">...(actionData !== void 0 ? {</span><span class="s2">\n            </span><span class="s1">actionData</span><span class="s2">\n          </span><span class="s1">} : {})</span><span class="s2">\n        </span><span class="s1">}, {</span><span class="s2">\n          </span><span class="s1">flushSync</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">let discoverResult = await discoverRoutes(matches, location.pathname, request.signal);</span><span class="s2">\n      </span><span class="s1">if (discoverResult.type === </span><span class="s2">\&quot;</span><span class="s1">aborted</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">return {</span><span class="s2">\n          </span><span class="s1">shortCircuited: true</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">} else if (discoverResult.type === </span><span class="s2">\&quot;</span><span class="s1">error</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">let boundaryId = findNearestBoundary(discoverResult.partialMatches).route.id;</span><span class="s2">\n        </span><span class="s1">return {</span><span class="s2">\n          </span><span class="s1">matches: discoverResult.partialMatches,</span><span class="s2">\n          </span><span class="s1">loaderData: {},</span><span class="s2">\n          </span><span class="s1">errors: {</span><span class="s2">\n            </span><span class="s1">[boundaryId]: discoverResult.error</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">} else if (!discoverResult.matches) {</span><span class="s2">\n        </span><span class="s1">let {</span><span class="s2">\n          </span><span class="s1">error,</span><span class="s2">\n          </span><span class="s1">notFoundMatches,</span><span class="s2">\n          </span><span class="s1">route</span><span class="s2">\n        </span><span class="s1">} = handleNavigational404(location.pathname);</span><span class="s2">\n        </span><span class="s1">return {</span><span class="s2">\n          </span><span class="s1">matches: notFoundMatches,</span><span class="s2">\n          </span><span class="s1">loaderData: {},</span><span class="s2">\n          </span><span class="s1">errors: {</span><span class="s2">\n            </span><span class="s1">[route.id]: error</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">matches = discoverResult.matches;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let routesToUse = inFlightDataRoutes || dataRoutes;</span><span class="s2">\n    </span><span class="s1">let {</span><span class="s2">\n      </span><span class="s1">dsMatches,</span><span class="s2">\n      </span><span class="s1">revalidatingFetchers</span><span class="s2">\n    </span><span class="s1">} = getMatchesToLoad(request, scopedContext, mapRouteProperties2, manifest, init.history, state, matches, activeSubmission, location, initialHydration ? [] : hydrationRouteProperties2, initialHydration === true, isRevalidationRequired, cancelledFetcherLoads, fetchersQueuedForDeletion, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionResult);</span><span class="s2">\n    </span><span class="s1">pendingNavigationLoadId = ++incrementingLoadId;</span><span class="s2">\n    </span><span class="s1">if (!init.dataStrategy &amp;&amp; !dsMatches.some(m =&gt; m.shouldLoad) &amp;&amp; revalidatingFetchers.length === 0) {</span><span class="s2">\n      </span><span class="s1">let updatedFetchers2 = markFetchRedirectsDone();</span><span class="s2">\n      </span><span class="s1">completeNavigation(location, {</span><span class="s2">\n        </span><span class="s1">matches,</span><span class="s2">\n        </span><span class="s1">loaderData: {},</span><span class="s2">\n        </span><span class="s1">// Commit pending error if we're short circuiting</span><span class="s2">\n        </span><span class="s1">errors: pendingActionResult &amp;&amp; isErrorResult(pendingActionResult[1]) ? {</span><span class="s2">\n          </span><span class="s1">[pendingActionResult[0]]: pendingActionResult[1].error</span><span class="s2">\n        </span><span class="s1">} : null,</span><span class="s2">\n        </span><span class="s1">...getActionDataForCommit(pendingActionResult),</span><span class="s2">\n        </span><span class="s1">...(updatedFetchers2 ? {</span><span class="s2">\n          </span><span class="s1">fetchers: new Map(state.fetchers)</span><span class="s2">\n        </span><span class="s1">} : {})</span><span class="s2">\n      </span><span class="s1">}, {</span><span class="s2">\n        </span><span class="s1">flushSync</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">return {</span><span class="s2">\n        </span><span class="s1">shortCircuited: true</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (shouldUpdateNavigationState) {</span><span class="s2">\n      </span><span class="s1">let updates = {};</span><span class="s2">\n      </span><span class="s1">if (!isFogOfWar) {</span><span class="s2">\n        </span><span class="s1">updates.navigation = loadingNavigation;</span><span class="s2">\n        </span><span class="s1">let actionData = getUpdatedActionData(pendingActionResult);</span><span class="s2">\n        </span><span class="s1">if (actionData !== void 0) {</span><span class="s2">\n          </span><span class="s1">updates.actionData = actionData;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (revalidatingFetchers.length &gt; 0) {</span><span class="s2">\n        </span><span class="s1">updates.fetchers = getUpdatedRevalidatingFetchers(revalidatingFetchers);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">updateState(updates, {</span><span class="s2">\n        </span><span class="s1">flushSync</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">revalidatingFetchers.forEach(rf =&gt; {</span><span class="s2">\n      </span><span class="s1">abortFetcher(rf.key);</span><span class="s2">\n      </span><span class="s1">if (rf.controller) {</span><span class="s2">\n        </span><span class="s1">fetchControllers.set(rf.key, rf.controller);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">let abortPendingFetchRevalidations = () =&gt; revalidatingFetchers.forEach(f =&gt; abortFetcher(f.key));</span><span class="s2">\n    </span><span class="s1">if (pendingNavigationController) {</span><span class="s2">\n      </span><span class="s1">pendingNavigationController.signal.addEventListener(</span><span class="s2">\&quot;</span><span class="s1">abort</span><span class="s2">\&quot;</span><span class="s1">, abortPendingFetchRevalidations);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let {</span><span class="s2">\n      </span><span class="s1">loaderResults,</span><span class="s2">\n      </span><span class="s1">fetcherResults</span><span class="s2">\n    </span><span class="s1">} = await callLoadersAndMaybeResolveData(dsMatches, revalidatingFetchers, request, scopedContext);</span><span class="s2">\n    </span><span class="s1">if (request.signal.aborted) {</span><span class="s2">\n      </span><span class="s1">return {</span><span class="s2">\n        </span><span class="s1">shortCircuited: true</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (pendingNavigationController) {</span><span class="s2">\n      </span><span class="s1">pendingNavigationController.signal.removeEventListener(</span><span class="s2">\&quot;</span><span class="s1">abort</span><span class="s2">\&quot;</span><span class="s1">, abortPendingFetchRevalidations);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">revalidatingFetchers.forEach(rf =&gt; fetchControllers.delete(rf.key));</span><span class="s2">\n    </span><span class="s1">let redirect2 = findRedirect(loaderResults);</span><span class="s2">\n    </span><span class="s1">if (redirect2) {</span><span class="s2">\n      </span><span class="s1">await startRedirectNavigation(request, redirect2.result, true, {</span><span class="s2">\n        </span><span class="s1">replace: replace2</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">return {</span><span class="s2">\n        </span><span class="s1">shortCircuited: true</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">redirect2 = findRedirect(fetcherResults);</span><span class="s2">\n    </span><span class="s1">if (redirect2) {</span><span class="s2">\n      </span><span class="s1">fetchRedirectIds.add(redirect2.key);</span><span class="s2">\n      </span><span class="s1">await startRedirectNavigation(request, redirect2.result, true, {</span><span class="s2">\n        </span><span class="s1">replace: replace2</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">return {</span><span class="s2">\n        </span><span class="s1">shortCircuited: true</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let {</span><span class="s2">\n      </span><span class="s1">loaderData,</span><span class="s2">\n      </span><span class="s1">errors</span><span class="s2">\n    </span><span class="s1">} = processLoaderData(state, matches, loaderResults, pendingActionResult, revalidatingFetchers, fetcherResults);</span><span class="s2">\n    </span><span class="s1">if (initialHydration &amp;&amp; state.errors) {</span><span class="s2">\n      </span><span class="s1">errors = {</span><span class="s2">\n        </span><span class="s1">...state.errors,</span><span class="s2">\n        </span><span class="s1">...errors</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let updatedFetchers = markFetchRedirectsDone();</span><span class="s2">\n    </span><span class="s1">let didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId);</span><span class="s2">\n    </span><span class="s1">let shouldUpdateFetchers = updatedFetchers || didAbortFetchLoads || revalidatingFetchers.length &gt; 0;</span><span class="s2">\n    </span><span class="s1">return {</span><span class="s2">\n      </span><span class="s1">matches,</span><span class="s2">\n      </span><span class="s1">loaderData,</span><span class="s2">\n      </span><span class="s1">errors,</span><span class="s2">\n      </span><span class="s1">...(shouldUpdateFetchers ? {</span><span class="s2">\n        </span><span class="s1">fetchers: new Map(state.fetchers)</span><span class="s2">\n      </span><span class="s1">} : {})</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function getUpdatedActionData(pendingActionResult) {</span><span class="s2">\n    </span><span class="s1">if (pendingActionResult &amp;&amp; !isErrorResult(pendingActionResult[1])) {</span><span class="s2">\n      </span><span class="s1">return {</span><span class="s2">\n        </span><span class="s1">[pendingActionResult[0]]: pendingActionResult[1].data</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">} else if (state.actionData) {</span><span class="s2">\n      </span><span class="s1">if (Object.keys(state.actionData).length === 0) {</span><span class="s2">\n        </span><span class="s1">return null;</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">return state.actionData;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function getUpdatedRevalidatingFetchers(revalidatingFetchers) {</span><span class="s2">\n    </span><span class="s1">revalidatingFetchers.forEach(rf =&gt; {</span><span class="s2">\n      </span><span class="s1">let fetcher = state.fetchers.get(rf.key);</span><span class="s2">\n      </span><span class="s1">let revalidatingFetcher = getLoadingFetcher(void 0, fetcher ? fetcher.data : void 0);</span><span class="s2">\n      </span><span class="s1">state.fetchers.set(rf.key, revalidatingFetcher);</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">return new Map(state.fetchers);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">async function fetch2(key, routeId, href2, opts) {</span><span class="s2">\n    </span><span class="s1">abortFetcher(key);</span><span class="s2">\n    </span><span class="s1">let flushSync = (opts &amp;&amp; opts.flushSync) === true;</span><span class="s2">\n    </span><span class="s1">let routesToUse = inFlightDataRoutes || dataRoutes;</span><span class="s2">\n    </span><span class="s1">let normalizedPath = normalizeTo(state.location, state.matches, basename, href2, routeId, opts?.relative);</span><span class="s2">\n    </span><span class="s1">let matches = matchRoutes(routesToUse, normalizedPath, basename);</span><span class="s2">\n    </span><span class="s1">let fogOfWar = checkFogOfWar(matches, routesToUse, normalizedPath);</span><span class="s2">\n    </span><span class="s1">if (fogOfWar.active &amp;&amp; fogOfWar.matches) {</span><span class="s2">\n      </span><span class="s1">matches = fogOfWar.matches;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (!matches) {</span><span class="s2">\n      </span><span class="s1">setFetcherError(key, routeId, getInternalRouterError(404, {</span><span class="s2">\n        </span><span class="s1">pathname: normalizedPath</span><span class="s2">\n      </span><span class="s1">}), {</span><span class="s2">\n        </span><span class="s1">flushSync</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let {</span><span class="s2">\n      </span><span class="s1">path,</span><span class="s2">\n      </span><span class="s1">submission,</span><span class="s2">\n      </span><span class="s1">error</span><span class="s2">\n    </span><span class="s1">} = normalizeNavigateOptions(true, normalizedPath, opts);</span><span class="s2">\n    </span><span class="s1">if (error) {</span><span class="s2">\n      </span><span class="s1">setFetcherError(key, routeId, error, {</span><span class="s2">\n        </span><span class="s1">flushSync</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let match = getTargetMatch(matches, path);</span><span class="s2">\n    </span><span class="s1">let scopedContext = new unstable_RouterContextProvider(init.unstable_getContext ? await init.unstable_getContext() : void 0);</span><span class="s2">\n    </span><span class="s1">let preventScrollReset = (opts &amp;&amp; opts.preventScrollReset) === true;</span><span class="s2">\n    </span><span class="s1">if (submission &amp;&amp; isMutationMethod(submission.formMethod)) {</span><span class="s2">\n      </span><span class="s1">await handleFetcherAction(key, routeId, path, match, matches, scopedContext, fogOfWar.active, flushSync, preventScrollReset, submission);</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">fetchLoadMatches.set(key, {</span><span class="s2">\n      </span><span class="s1">routeId,</span><span class="s2">\n      </span><span class="s1">path</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">await handleFetcherLoader(key, routeId, path, match, matches, scopedContext, fogOfWar.active, flushSync, preventScrollReset, submission);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">async function handleFetcherAction(key, routeId, path, match, requestMatches, scopedContext, isFogOfWar, flushSync, preventScrollReset, submission) {</span><span class="s2">\n    </span><span class="s1">interruptActiveLoads();</span><span class="s2">\n    </span><span class="s1">fetchLoadMatches.delete(key);</span><span class="s2">\n    </span><span class="s1">function detectAndHandle405Error(m) {</span><span class="s2">\n      </span><span class="s1">if (!m.route.action &amp;&amp; !m.route.lazy) {</span><span class="s2">\n        </span><span class="s1">let error = getInternalRouterError(405, {</span><span class="s2">\n          </span><span class="s1">method: submission.formMethod,</span><span class="s2">\n          </span><span class="s1">pathname: path,</span><span class="s2">\n          </span><span class="s1">routeId</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">setFetcherError(key, routeId, error, {</span><span class="s2">\n          </span><span class="s1">flushSync</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">return true;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return false;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (!isFogOfWar &amp;&amp; detectAndHandle405Error(match)) {</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let existingFetcher = state.fetchers.get(key);</span><span class="s2">\n    </span><span class="s1">updateFetcherState(key, getSubmittingFetcher(submission, existingFetcher), {</span><span class="s2">\n      </span><span class="s1">flushSync</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">let abortController = new AbortController();</span><span class="s2">\n    </span><span class="s1">let fetchRequest = createClientSideRequest(init.history, path, abortController.signal, submission);</span><span class="s2">\n    </span><span class="s1">if (isFogOfWar) {</span><span class="s2">\n      </span><span class="s1">let discoverResult = await discoverRoutes(requestMatches, path, fetchRequest.signal, key);</span><span class="s2">\n      </span><span class="s1">if (discoverResult.type === </span><span class="s2">\&quot;</span><span class="s1">aborted</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">} else if (discoverResult.type === </span><span class="s2">\&quot;</span><span class="s1">error</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">setFetcherError(key, routeId, discoverResult.error, {</span><span class="s2">\n          </span><span class="s1">flushSync</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">} else if (!discoverResult.matches) {</span><span class="s2">\n        </span><span class="s1">setFetcherError(key, routeId, getInternalRouterError(404, {</span><span class="s2">\n          </span><span class="s1">pathname: path</span><span class="s2">\n        </span><span class="s1">}), {</span><span class="s2">\n          </span><span class="s1">flushSync</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">requestMatches = discoverResult.matches;</span><span class="s2">\n        </span><span class="s1">match = getTargetMatch(requestMatches, path);</span><span class="s2">\n        </span><span class="s1">if (detectAndHandle405Error(match)) {</span><span class="s2">\n          </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">fetchControllers.set(key, abortController);</span><span class="s2">\n    </span><span class="s1">let originatingLoadId = incrementingLoadId;</span><span class="s2">\n    </span><span class="s1">let fetchMatches = getTargetedDataStrategyMatches(mapRouteProperties2, manifest, fetchRequest, requestMatches, match, hydrationRouteProperties2, scopedContext);</span><span class="s2">\n    </span><span class="s1">let actionResults = await callDataStrategy(fetchRequest, fetchMatches, scopedContext, key);</span><span class="s2">\n    </span><span class="s1">let actionResult = actionResults[match.route.id];</span><span class="s2">\n    </span><span class="s1">if (fetchRequest.signal.aborted) {</span><span class="s2">\n      </span><span class="s1">if (fetchControllers.get(key) === abortController) {</span><span class="s2">\n        </span><span class="s1">fetchControllers.delete(key);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (fetchersQueuedForDeletion.has(key)) {</span><span class="s2">\n      </span><span class="s1">if (isRedirectResult(actionResult) || isErrorResult(actionResult)) {</span><span class="s2">\n        </span><span class="s1">updateFetcherState(key, getDoneFetcher(void 0));</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">if (isRedirectResult(actionResult)) {</span><span class="s2">\n        </span><span class="s1">fetchControllers.delete(key);</span><span class="s2">\n        </span><span class="s1">if (pendingNavigationLoadId &gt; originatingLoadId) {</span><span class="s2">\n          </span><span class="s1">updateFetcherState(key, getDoneFetcher(void 0));</span><span class="s2">\n          </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">fetchRedirectIds.add(key);</span><span class="s2">\n          </span><span class="s1">updateFetcherState(key, getLoadingFetcher(submission));</span><span class="s2">\n          </span><span class="s1">return startRedirectNavigation(fetchRequest, actionResult, false, {</span><span class="s2">\n            </span><span class="s1">fetcherSubmission: submission,</span><span class="s2">\n            </span><span class="s1">preventScrollReset</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (isErrorResult(actionResult)) {</span><span class="s2">\n        </span><span class="s1">setFetcherError(key, routeId, actionResult.error);</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let nextLocation = state.navigation.location || state.location;</span><span class="s2">\n    </span><span class="s1">let revalidationRequest = createClientSideRequest(init.history, nextLocation, abortController.signal);</span><span class="s2">\n    </span><span class="s1">let routesToUse = inFlightDataRoutes || dataRoutes;</span><span class="s2">\n    </span><span class="s1">let matches = state.navigation.state !== </span><span class="s2">\&quot;</span><span class="s1">idle</span><span class="s2">\&quot; </span><span class="s1">? matchRoutes(routesToUse, state.navigation.location, basename) : state.matches;</span><span class="s2">\n    </span><span class="s1">invariant(matches, </span><span class="s2">\&quot;</span><span class="s1">Didn't find any matches after fetcher action</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">let loadId = ++incrementingLoadId;</span><span class="s2">\n    </span><span class="s1">fetchReloadIds.set(key, loadId);</span><span class="s2">\n    </span><span class="s1">let loadFetcher = getLoadingFetcher(submission, actionResult.data);</span><span class="s2">\n    </span><span class="s1">state.fetchers.set(key, loadFetcher);</span><span class="s2">\n    </span><span class="s1">let {</span><span class="s2">\n      </span><span class="s1">dsMatches,</span><span class="s2">\n      </span><span class="s1">revalidatingFetchers</span><span class="s2">\n    </span><span class="s1">} = getMatchesToLoad(revalidationRequest, scopedContext, mapRouteProperties2, manifest, init.history, state, matches, submission, nextLocation, hydrationRouteProperties2, false, isRevalidationRequired, cancelledFetcherLoads, fetchersQueuedForDeletion, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, [match.route.id, actionResult]);</span><span class="s2">\n    </span><span class="s1">revalidatingFetchers.filter(rf =&gt; rf.key !== key).forEach(rf =&gt; {</span><span class="s2">\n      </span><span class="s1">let staleKey = rf.key;</span><span class="s2">\n      </span><span class="s1">let existingFetcher2 = state.fetchers.get(staleKey);</span><span class="s2">\n      </span><span class="s1">let revalidatingFetcher = getLoadingFetcher(void 0, existingFetcher2 ? existingFetcher2.data : void 0);</span><span class="s2">\n      </span><span class="s1">state.fetchers.set(staleKey, revalidatingFetcher);</span><span class="s2">\n      </span><span class="s1">abortFetcher(staleKey);</span><span class="s2">\n      </span><span class="s1">if (rf.controller) {</span><span class="s2">\n        </span><span class="s1">fetchControllers.set(staleKey, rf.controller);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">updateState({</span><span class="s2">\n      </span><span class="s1">fetchers: new Map(state.fetchers)</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">let abortPendingFetchRevalidations = () =&gt; revalidatingFetchers.forEach(rf =&gt; abortFetcher(rf.key));</span><span class="s2">\n    </span><span class="s1">abortController.signal.addEventListener(</span><span class="s2">\&quot;</span><span class="s1">abort</span><span class="s2">\&quot;</span><span class="s1">, abortPendingFetchRevalidations);</span><span class="s2">\n    </span><span class="s1">let {</span><span class="s2">\n      </span><span class="s1">loaderResults,</span><span class="s2">\n      </span><span class="s1">fetcherResults</span><span class="s2">\n    </span><span class="s1">} = await callLoadersAndMaybeResolveData(dsMatches, revalidatingFetchers, revalidationRequest, scopedContext);</span><span class="s2">\n    </span><span class="s1">if (abortController.signal.aborted) {</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">abortController.signal.removeEventListener(</span><span class="s2">\&quot;</span><span class="s1">abort</span><span class="s2">\&quot;</span><span class="s1">, abortPendingFetchRevalidations);</span><span class="s2">\n    </span><span class="s1">fetchReloadIds.delete(key);</span><span class="s2">\n    </span><span class="s1">fetchControllers.delete(key);</span><span class="s2">\n    </span><span class="s1">revalidatingFetchers.forEach(r =&gt; fetchControllers.delete(r.key));</span><span class="s2">\n    </span><span class="s1">if (state.fetchers.has(key)) {</span><span class="s2">\n      </span><span class="s1">let doneFetcher = getDoneFetcher(actionResult.data);</span><span class="s2">\n      </span><span class="s1">state.fetchers.set(key, doneFetcher);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let redirect2 = findRedirect(loaderResults);</span><span class="s2">\n    </span><span class="s1">if (redirect2) {</span><span class="s2">\n      </span><span class="s1">return startRedirectNavigation(revalidationRequest, redirect2.result, false, {</span><span class="s2">\n        </span><span class="s1">preventScrollReset</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">redirect2 = findRedirect(fetcherResults);</span><span class="s2">\n    </span><span class="s1">if (redirect2) {</span><span class="s2">\n      </span><span class="s1">fetchRedirectIds.add(redirect2.key);</span><span class="s2">\n      </span><span class="s1">return startRedirectNavigation(revalidationRequest, redirect2.result, false, {</span><span class="s2">\n        </span><span class="s1">preventScrollReset</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let {</span><span class="s2">\n      </span><span class="s1">loaderData,</span><span class="s2">\n      </span><span class="s1">errors</span><span class="s2">\n    </span><span class="s1">} = processLoaderData(state, matches, loaderResults, void 0, revalidatingFetchers, fetcherResults);</span><span class="s2">\n    </span><span class="s1">abortStaleFetchLoads(loadId);</span><span class="s2">\n    </span><span class="s1">if (state.navigation.state === </span><span class="s2">\&quot;</span><span class="s1">loading</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; loadId &gt; pendingNavigationLoadId) {</span><span class="s2">\n      </span><span class="s1">invariant(pendingAction, </span><span class="s2">\&quot;</span><span class="s1">Expected pending action</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">pendingNavigationController &amp;&amp; pendingNavigationController.abort();</span><span class="s2">\n      </span><span class="s1">completeNavigation(state.navigation.location, {</span><span class="s2">\n        </span><span class="s1">matches,</span><span class="s2">\n        </span><span class="s1">loaderData,</span><span class="s2">\n        </span><span class="s1">errors,</span><span class="s2">\n        </span><span class="s1">fetchers: new Map(state.fetchers)</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">updateState({</span><span class="s2">\n        </span><span class="s1">errors,</span><span class="s2">\n        </span><span class="s1">loaderData: mergeLoaderData(state.loaderData, loaderData, matches, errors),</span><span class="s2">\n        </span><span class="s1">fetchers: new Map(state.fetchers)</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">isRevalidationRequired = false;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">async function handleFetcherLoader(key, routeId, path, match, matches, scopedContext, isFogOfWar, flushSync, preventScrollReset, submission) {</span><span class="s2">\n    </span><span class="s1">let existingFetcher = state.fetchers.get(key);</span><span class="s2">\n    </span><span class="s1">updateFetcherState(key, getLoadingFetcher(submission, existingFetcher ? existingFetcher.data : void 0), {</span><span class="s2">\n      </span><span class="s1">flushSync</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">let abortController = new AbortController();</span><span class="s2">\n    </span><span class="s1">let fetchRequest = createClientSideRequest(init.history, path, abortController.signal);</span><span class="s2">\n    </span><span class="s1">if (isFogOfWar) {</span><span class="s2">\n      </span><span class="s1">let discoverResult = await discoverRoutes(matches, path, fetchRequest.signal, key);</span><span class="s2">\n      </span><span class="s1">if (discoverResult.type === </span><span class="s2">\&quot;</span><span class="s1">aborted</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">} else if (discoverResult.type === </span><span class="s2">\&quot;</span><span class="s1">error</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">setFetcherError(key, routeId, discoverResult.error, {</span><span class="s2">\n          </span><span class="s1">flushSync</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">} else if (!discoverResult.matches) {</span><span class="s2">\n        </span><span class="s1">setFetcherError(key, routeId, getInternalRouterError(404, {</span><span class="s2">\n          </span><span class="s1">pathname: path</span><span class="s2">\n        </span><span class="s1">}), {</span><span class="s2">\n          </span><span class="s1">flushSync</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">matches = discoverResult.matches;</span><span class="s2">\n        </span><span class="s1">match = getTargetMatch(matches, path);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">fetchControllers.set(key, abortController);</span><span class="s2">\n    </span><span class="s1">let originatingLoadId = incrementingLoadId;</span><span class="s2">\n    </span><span class="s1">let dsMatches = getTargetedDataStrategyMatches(mapRouteProperties2, manifest, fetchRequest, matches, match, hydrationRouteProperties2, scopedContext);</span><span class="s2">\n    </span><span class="s1">let results = await callDataStrategy(fetchRequest, dsMatches, scopedContext, key);</span><span class="s2">\n    </span><span class="s1">let result = results[match.route.id];</span><span class="s2">\n    </span><span class="s1">if (fetchControllers.get(key) === abortController) {</span><span class="s2">\n      </span><span class="s1">fetchControllers.delete(key);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (fetchRequest.signal.aborted) {</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (fetchersQueuedForDeletion.has(key)) {</span><span class="s2">\n      </span><span class="s1">updateFetcherState(key, getDoneFetcher(void 0));</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (isRedirectResult(result)) {</span><span class="s2">\n      </span><span class="s1">if (pendingNavigationLoadId &gt; originatingLoadId) {</span><span class="s2">\n        </span><span class="s1">updateFetcherState(key, getDoneFetcher(void 0));</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">fetchRedirectIds.add(key);</span><span class="s2">\n        </span><span class="s1">await startRedirectNavigation(fetchRequest, result, false, {</span><span class="s2">\n          </span><span class="s1">preventScrollReset</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (isErrorResult(result)) {</span><span class="s2">\n      </span><span class="s1">setFetcherError(key, routeId, result.error);</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">updateFetcherState(key, getDoneFetcher(result.data));</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">async function startRedirectNavigation(request, redirect2, isNavigation, {</span><span class="s2">\n    </span><span class="s1">submission,</span><span class="s2">\n    </span><span class="s1">fetcherSubmission,</span><span class="s2">\n    </span><span class="s1">preventScrollReset,</span><span class="s2">\n    </span><span class="s1">replace: replace2</span><span class="s2">\n  </span><span class="s1">} = {}) {</span><span class="s2">\n    </span><span class="s1">if (redirect2.response.headers.has(</span><span class="s2">\&quot;</span><span class="s1">X-Remix-Revalidate</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n      </span><span class="s1">isRevalidationRequired = true;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let location = redirect2.response.headers.get(</span><span class="s2">\&quot;</span><span class="s1">Location</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">invariant(location, </span><span class="s2">\&quot;</span><span class="s1">Expected a Location header on the redirect Response</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">location = normalizeRedirectLocation(location, new URL(request.url), basename);</span><span class="s2">\n    </span><span class="s1">let redirectLocation = createLocation(state.location, location, {</span><span class="s2">\n      </span><span class="s1">_isRedirect: true</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">if (isBrowser2) {</span><span class="s2">\n      </span><span class="s1">let isDocumentReload = false;</span><span class="s2">\n      </span><span class="s1">if (redirect2.response.headers.has(</span><span class="s2">\&quot;</span><span class="s1">X-Remix-Reload-Document</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n        </span><span class="s1">isDocumentReload = true;</span><span class="s2">\n      </span><span class="s1">} else if (ABSOLUTE_URL_REGEX.test(location)) {</span><span class="s2">\n        </span><span class="s1">const url = createBrowserURLImpl(location, true);</span><span class="s2">\n        </span><span class="s1">isDocumentReload =</span><span class="s2">\n        </span><span class="s1">// Hard reload if it's an absolute URL to a new origin</span><span class="s2">\n        </span><span class="s1">url.origin !== routerWindow.location.origin ||</span><span class="s2">\n        </span><span class="s1">// Hard reload if it's an absolute URL that does not match our basename</span><span class="s2">\n        </span><span class="s1">stripBasename(url.pathname, basename) == null;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (isDocumentReload) {</span><span class="s2">\n        </span><span class="s1">if (replace2) {</span><span class="s2">\n          </span><span class="s1">routerWindow.location.replace(location);</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">routerWindow.location.assign(location);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">pendingNavigationController = null;</span><span class="s2">\n    </span><span class="s1">let redirectNavigationType = replace2 === true || redirect2.response.headers.has(</span><span class="s2">\&quot;</span><span class="s1">X-Remix-Replace</span><span class="s2">\&quot;</span><span class="s1">) ? </span><span class="s2">\&quot;</span><span class="s1">REPLACE</span><span class="s2">\&quot; </span><span class="s1">/* Replace */ : </span><span class="s2">\&quot;</span><span class="s1">PUSH</span><span class="s2">\&quot; </span><span class="s1">/* Push */;</span><span class="s2">\n    </span><span class="s1">let {</span><span class="s2">\n      </span><span class="s1">formMethod,</span><span class="s2">\n      </span><span class="s1">formAction,</span><span class="s2">\n      </span><span class="s1">formEncType</span><span class="s2">\n    </span><span class="s1">} = state.navigation;</span><span class="s2">\n    </span><span class="s1">if (!submission &amp;&amp; !fetcherSubmission &amp;&amp; formMethod &amp;&amp; formAction &amp;&amp; formEncType) {</span><span class="s2">\n      </span><span class="s1">submission = getSubmissionFromNavigation(state.navigation);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let activeSubmission = submission || fetcherSubmission;</span><span class="s2">\n    </span><span class="s1">if (redirectPreserveMethodStatusCodes.has(redirect2.response.status) &amp;&amp; activeSubmission &amp;&amp; isMutationMethod(activeSubmission.formMethod)) {</span><span class="s2">\n      </span><span class="s1">await startNavigation(redirectNavigationType, redirectLocation, {</span><span class="s2">\n        </span><span class="s1">submission: {</span><span class="s2">\n          </span><span class="s1">...activeSubmission,</span><span class="s2">\n          </span><span class="s1">formAction: location</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">// Preserve these flags across redirects</span><span class="s2">\n        </span><span class="s1">preventScrollReset: preventScrollReset || pendingPreventScrollReset,</span><span class="s2">\n        </span><span class="s1">enableViewTransition: isNavigation ? pendingViewTransitionEnabled : void 0</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">let overrideNavigation = getLoadingNavigation(redirectLocation, submission);</span><span class="s2">\n      </span><span class="s1">await startNavigation(redirectNavigationType, redirectLocation, {</span><span class="s2">\n        </span><span class="s1">overrideNavigation,</span><span class="s2">\n        </span><span class="s1">// Send fetcher submissions through for shouldRevalidate</span><span class="s2">\n        </span><span class="s1">fetcherSubmission,</span><span class="s2">\n        </span><span class="s1">// Preserve these flags across redirects</span><span class="s2">\n        </span><span class="s1">preventScrollReset: preventScrollReset || pendingPreventScrollReset,</span><span class="s2">\n        </span><span class="s1">enableViewTransition: isNavigation ? pendingViewTransitionEnabled : void 0</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">async function callDataStrategy(request, matches, scopedContext, fetcherKey) {</span><span class="s2">\n    </span><span class="s1">let results;</span><span class="s2">\n    </span><span class="s1">let dataResults = {};</span><span class="s2">\n    </span><span class="s1">try {</span><span class="s2">\n      </span><span class="s1">results = await callDataStrategyImpl(dataStrategyImpl, request, matches, fetcherKey, scopedContext, false);</span><span class="s2">\n    </span><span class="s1">} catch (e) {</span><span class="s2">\n      </span><span class="s1">matches.filter(m =&gt; m.shouldLoad).forEach(m =&gt; {</span><span class="s2">\n        </span><span class="s1">dataResults[m.route.id] = {</span><span class="s2">\n          </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">error</span><span class="s2">\&quot; </span><span class="s1">/* error */,</span><span class="s2">\n          </span><span class="s1">error: e</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">return dataResults;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (request.signal.aborted) {</span><span class="s2">\n      </span><span class="s1">return dataResults;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">for (let [routeId, result] of Object.entries(results)) {</span><span class="s2">\n      </span><span class="s1">if (isRedirectDataStrategyResult(result)) {</span><span class="s2">\n        </span><span class="s1">let response = result.result;</span><span class="s2">\n        </span><span class="s1">dataResults[routeId] = {</span><span class="s2">\n          </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">redirect</span><span class="s2">\&quot; </span><span class="s1">/* redirect */,</span><span class="s2">\n          </span><span class="s1">response: normalizeRelativeRoutingRedirectResponse(response, request, routeId, matches, basename)</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">dataResults[routeId] = await convertDataStrategyResultToDataResult(result);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return dataResults;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">async function callLoadersAndMaybeResolveData(matches, fetchersToLoad, request, scopedContext) {</span><span class="s2">\n    </span><span class="s1">let loaderResultsPromise = callDataStrategy(request, matches, scopedContext, null);</span><span class="s2">\n    </span><span class="s1">let fetcherResultsPromise = Promise.all(fetchersToLoad.map(async f =&gt; {</span><span class="s2">\n      </span><span class="s1">if (f.matches &amp;&amp; f.match &amp;&amp; f.request &amp;&amp; f.controller) {</span><span class="s2">\n        </span><span class="s1">let results = await callDataStrategy(f.request, f.matches, scopedContext, f.key);</span><span class="s2">\n        </span><span class="s1">let result = results[f.match.route.id];</span><span class="s2">\n        </span><span class="s1">return {</span><span class="s2">\n          </span><span class="s1">[f.key]: result</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">return Promise.resolve({</span><span class="s2">\n          </span><span class="s1">[f.key]: {</span><span class="s2">\n            </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">error</span><span class="s2">\&quot; </span><span class="s1">/* error */,</span><span class="s2">\n            </span><span class="s1">error: getInternalRouterError(404, {</span><span class="s2">\n              </span><span class="s1">pathname: f.path</span><span class="s2">\n            </span><span class="s1">})</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}));</span><span class="s2">\n    </span><span class="s1">let loaderResults = await loaderResultsPromise;</span><span class="s2">\n    </span><span class="s1">let fetcherResults = (await fetcherResultsPromise).reduce((acc, r) =&gt; Object.assign(acc, r), {});</span><span class="s2">\n    </span><span class="s1">return {</span><span class="s2">\n      </span><span class="s1">loaderResults,</span><span class="s2">\n      </span><span class="s1">fetcherResults</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function interruptActiveLoads() {</span><span class="s2">\n    </span><span class="s1">isRevalidationRequired = true;</span><span class="s2">\n    </span><span class="s1">fetchLoadMatches.forEach((_, key) =&gt; {</span><span class="s2">\n      </span><span class="s1">if (fetchControllers.has(key)) {</span><span class="s2">\n        </span><span class="s1">cancelledFetcherLoads.add(key);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">abortFetcher(key);</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function updateFetcherState(key, fetcher, opts = {}) {</span><span class="s2">\n    </span><span class="s1">state.fetchers.set(key, fetcher);</span><span class="s2">\n    </span><span class="s1">updateState({</span><span class="s2">\n      </span><span class="s1">fetchers: new Map(state.fetchers)</span><span class="s2">\n    </span><span class="s1">}, {</span><span class="s2">\n      </span><span class="s1">flushSync: (opts &amp;&amp; opts.flushSync) === true</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function setFetcherError(key, routeId, error, opts = {}) {</span><span class="s2">\n    </span><span class="s1">let boundaryMatch = findNearestBoundary(state.matches, routeId);</span><span class="s2">\n    </span><span class="s1">deleteFetcher(key);</span><span class="s2">\n    </span><span class="s1">updateState({</span><span class="s2">\n      </span><span class="s1">errors: {</span><span class="s2">\n        </span><span class="s1">[boundaryMatch.route.id]: error</span><span class="s2">\n      </span><span class="s1">},</span><span class="s2">\n      </span><span class="s1">fetchers: new Map(state.fetchers)</span><span class="s2">\n    </span><span class="s1">}, {</span><span class="s2">\n      </span><span class="s1">flushSync: (opts &amp;&amp; opts.flushSync) === true</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function getFetcher(key) {</span><span class="s2">\n    </span><span class="s1">activeFetchers.set(key, (activeFetchers.get(key) || 0) + 1);</span><span class="s2">\n    </span><span class="s1">if (fetchersQueuedForDeletion.has(key)) {</span><span class="s2">\n      </span><span class="s1">fetchersQueuedForDeletion.delete(key);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return state.fetchers.get(key) || IDLE_FETCHER;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function deleteFetcher(key) {</span><span class="s2">\n    </span><span class="s1">let fetcher = state.fetchers.get(key);</span><span class="s2">\n    </span><span class="s1">if (fetchControllers.has(key) &amp;&amp; !(fetcher &amp;&amp; fetcher.state === </span><span class="s2">\&quot;</span><span class="s1">loading</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; fetchReloadIds.has(key))) {</span><span class="s2">\n      </span><span class="s1">abortFetcher(key);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">fetchLoadMatches.delete(key);</span><span class="s2">\n    </span><span class="s1">fetchReloadIds.delete(key);</span><span class="s2">\n    </span><span class="s1">fetchRedirectIds.delete(key);</span><span class="s2">\n    </span><span class="s1">fetchersQueuedForDeletion.delete(key);</span><span class="s2">\n    </span><span class="s1">cancelledFetcherLoads.delete(key);</span><span class="s2">\n    </span><span class="s1">state.fetchers.delete(key);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function queueFetcherForDeletion(key) {</span><span class="s2">\n    </span><span class="s1">let count = (activeFetchers.get(key) || 0) - 1;</span><span class="s2">\n    </span><span class="s1">if (count &lt;= 0) {</span><span class="s2">\n      </span><span class="s1">activeFetchers.delete(key);</span><span class="s2">\n      </span><span class="s1">fetchersQueuedForDeletion.add(key);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">activeFetchers.set(key, count);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">updateState({</span><span class="s2">\n      </span><span class="s1">fetchers: new Map(state.fetchers)</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function abortFetcher(key) {</span><span class="s2">\n    </span><span class="s1">let controller = fetchControllers.get(key);</span><span class="s2">\n    </span><span class="s1">if (controller) {</span><span class="s2">\n      </span><span class="s1">controller.abort();</span><span class="s2">\n      </span><span class="s1">fetchControllers.delete(key);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function markFetchersDone(keys) {</span><span class="s2">\n    </span><span class="s1">for (let key of keys) {</span><span class="s2">\n      </span><span class="s1">let fetcher = getFetcher(key);</span><span class="s2">\n      </span><span class="s1">let doneFetcher = getDoneFetcher(fetcher.data);</span><span class="s2">\n      </span><span class="s1">state.fetchers.set(key, doneFetcher);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function markFetchRedirectsDone() {</span><span class="s2">\n    </span><span class="s1">let doneKeys = [];</span><span class="s2">\n    </span><span class="s1">let updatedFetchers = false;</span><span class="s2">\n    </span><span class="s1">for (let key of fetchRedirectIds) {</span><span class="s2">\n      </span><span class="s1">let fetcher = state.fetchers.get(key);</span><span class="s2">\n      </span><span class="s1">invariant(fetcher, `Expected fetcher: ${key}`);</span><span class="s2">\n      </span><span class="s1">if (fetcher.state === </span><span class="s2">\&quot;</span><span class="s1">loading</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">fetchRedirectIds.delete(key);</span><span class="s2">\n        </span><span class="s1">doneKeys.push(key);</span><span class="s2">\n        </span><span class="s1">updatedFetchers = true;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">markFetchersDone(doneKeys);</span><span class="s2">\n    </span><span class="s1">return updatedFetchers;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function abortStaleFetchLoads(landedId) {</span><span class="s2">\n    </span><span class="s1">let yeetedKeys = [];</span><span class="s2">\n    </span><span class="s1">for (let [key, id] of fetchReloadIds) {</span><span class="s2">\n      </span><span class="s1">if (id &lt; landedId) {</span><span class="s2">\n        </span><span class="s1">let fetcher = state.fetchers.get(key);</span><span class="s2">\n        </span><span class="s1">invariant(fetcher, `Expected fetcher: ${key}`);</span><span class="s2">\n        </span><span class="s1">if (fetcher.state === </span><span class="s2">\&quot;</span><span class="s1">loading</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">abortFetcher(key);</span><span class="s2">\n          </span><span class="s1">fetchReloadIds.delete(key);</span><span class="s2">\n          </span><span class="s1">yeetedKeys.push(key);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">markFetchersDone(yeetedKeys);</span><span class="s2">\n    </span><span class="s1">return yeetedKeys.length &gt; 0;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function getBlocker(key, fn) {</span><span class="s2">\n    </span><span class="s1">let blocker = state.blockers.get(key) || IDLE_BLOCKER;</span><span class="s2">\n    </span><span class="s1">if (blockerFunctions.get(key) !== fn) {</span><span class="s2">\n      </span><span class="s1">blockerFunctions.set(key, fn);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return blocker;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function deleteBlocker(key) {</span><span class="s2">\n    </span><span class="s1">state.blockers.delete(key);</span><span class="s2">\n    </span><span class="s1">blockerFunctions.delete(key);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function updateBlocker(key, newBlocker) {</span><span class="s2">\n    </span><span class="s1">let blocker = state.blockers.get(key) || IDLE_BLOCKER;</span><span class="s2">\n    </span><span class="s1">invariant(blocker.state === </span><span class="s2">\&quot;</span><span class="s1">unblocked</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; newBlocker.state === </span><span class="s2">\&quot;</span><span class="s1">blocked</span><span class="s2">\&quot; </span><span class="s1">|| blocker.state === </span><span class="s2">\&quot;</span><span class="s1">blocked</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; newBlocker.state === </span><span class="s2">\&quot;</span><span class="s1">blocked</span><span class="s2">\&quot; </span><span class="s1">|| blocker.state === </span><span class="s2">\&quot;</span><span class="s1">blocked</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; newBlocker.state === </span><span class="s2">\&quot;</span><span class="s1">proceeding</span><span class="s2">\&quot; </span><span class="s1">|| blocker.state === </span><span class="s2">\&quot;</span><span class="s1">blocked</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; newBlocker.state === </span><span class="s2">\&quot;</span><span class="s1">unblocked</span><span class="s2">\&quot; </span><span class="s1">|| blocker.state === </span><span class="s2">\&quot;</span><span class="s1">proceeding</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; newBlocker.state === </span><span class="s2">\&quot;</span><span class="s1">unblocked</span><span class="s2">\&quot;</span><span class="s1">, `Invalid blocker state transition: ${blocker.state} -&gt; ${newBlocker.state}`);</span><span class="s2">\n    </span><span class="s1">let blockers = new Map(state.blockers);</span><span class="s2">\n    </span><span class="s1">blockers.set(key, newBlocker);</span><span class="s2">\n    </span><span class="s1">updateState({</span><span class="s2">\n      </span><span class="s1">blockers</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function shouldBlockNavigation({</span><span class="s2">\n    </span><span class="s1">currentLocation,</span><span class="s2">\n    </span><span class="s1">nextLocation,</span><span class="s2">\n    </span><span class="s1">historyAction</span><span class="s2">\n  </span><span class="s1">}) {</span><span class="s2">\n    </span><span class="s1">if (blockerFunctions.size === 0) {</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (blockerFunctions.size &gt; 1) {</span><span class="s2">\n      </span><span class="s1">warning(false, </span><span class="s2">\&quot;</span><span class="s1">A router only supports one blocker at a time</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let entries = Array.from(blockerFunctions.entries());</span><span class="s2">\n    </span><span class="s1">let [blockerKey, blockerFunction] = entries[entries.length - 1];</span><span class="s2">\n    </span><span class="s1">let blocker = state.blockers.get(blockerKey);</span><span class="s2">\n    </span><span class="s1">if (blocker &amp;&amp; blocker.state === </span><span class="s2">\&quot;</span><span class="s1">proceeding</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (blockerFunction({</span><span class="s2">\n      </span><span class="s1">currentLocation,</span><span class="s2">\n      </span><span class="s1">nextLocation,</span><span class="s2">\n      </span><span class="s1">historyAction</span><span class="s2">\n    </span><span class="s1">})) {</span><span class="s2">\n      </span><span class="s1">return blockerKey;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function handleNavigational404(pathname) {</span><span class="s2">\n    </span><span class="s1">let error = getInternalRouterError(404, {</span><span class="s2">\n      </span><span class="s1">pathname</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">let routesToUse = inFlightDataRoutes || dataRoutes;</span><span class="s2">\n    </span><span class="s1">let {</span><span class="s2">\n      </span><span class="s1">matches,</span><span class="s2">\n      </span><span class="s1">route</span><span class="s2">\n    </span><span class="s1">} = getShortCircuitMatches(routesToUse);</span><span class="s2">\n    </span><span class="s1">return {</span><span class="s2">\n      </span><span class="s1">notFoundMatches: matches,</span><span class="s2">\n      </span><span class="s1">route,</span><span class="s2">\n      </span><span class="s1">error</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function enableScrollRestoration(positions, getPosition, getKey) {</span><span class="s2">\n    </span><span class="s1">savedScrollPositions2 = positions;</span><span class="s2">\n    </span><span class="s1">getScrollPosition = getPosition;</span><span class="s2">\n    </span><span class="s1">getScrollRestorationKey2 = getKey || null;</span><span class="s2">\n    </span><span class="s1">if (!initialScrollRestored &amp;&amp; state.navigation === IDLE_NAVIGATION) {</span><span class="s2">\n      </span><span class="s1">initialScrollRestored = true;</span><span class="s2">\n      </span><span class="s1">let y = getSavedScrollPosition(state.location, state.matches);</span><span class="s2">\n      </span><span class="s1">if (y != null) {</span><span class="s2">\n        </span><span class="s1">updateState({</span><span class="s2">\n          </span><span class="s1">restoreScrollPosition: y</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return () =&gt; {</span><span class="s2">\n      </span><span class="s1">savedScrollPositions2 = null;</span><span class="s2">\n      </span><span class="s1">getScrollPosition = null;</span><span class="s2">\n      </span><span class="s1">getScrollRestorationKey2 = null;</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function getScrollKey(location, matches) {</span><span class="s2">\n    </span><span class="s1">if (getScrollRestorationKey2) {</span><span class="s2">\n      </span><span class="s1">let key = getScrollRestorationKey2(location, matches.map(m =&gt; convertRouteMatchToUiMatch(m, state.loaderData)));</span><span class="s2">\n      </span><span class="s1">return key || location.key;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return location.key;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function saveScrollPosition(location, matches) {</span><span class="s2">\n    </span><span class="s1">if (savedScrollPositions2 &amp;&amp; getScrollPosition) {</span><span class="s2">\n      </span><span class="s1">let key = getScrollKey(location, matches);</span><span class="s2">\n      </span><span class="s1">savedScrollPositions2[key] = getScrollPosition();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function getSavedScrollPosition(location, matches) {</span><span class="s2">\n    </span><span class="s1">if (savedScrollPositions2) {</span><span class="s2">\n      </span><span class="s1">let key = getScrollKey(location, matches);</span><span class="s2">\n      </span><span class="s1">let y = savedScrollPositions2[key];</span><span class="s2">\n      </span><span class="s1">if (typeof y === </span><span class="s2">\&quot;</span><span class="s1">number</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">return y;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return null;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function checkFogOfWar(matches, routesToUse, pathname) {</span><span class="s2">\n    </span><span class="s1">if (init.patchRoutesOnNavigation) {</span><span class="s2">\n      </span><span class="s1">if (!matches) {</span><span class="s2">\n        </span><span class="s1">let fogMatches = matchRoutesImpl(routesToUse, pathname, basename, true);</span><span class="s2">\n        </span><span class="s1">return {</span><span class="s2">\n          </span><span class="s1">active: true,</span><span class="s2">\n          </span><span class="s1">matches: fogMatches || []</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">if (Object.keys(matches[0].params).length &gt; 0) {</span><span class="s2">\n          </span><span class="s1">let partialMatches = matchRoutesImpl(routesToUse, pathname, basename, true);</span><span class="s2">\n          </span><span class="s1">return {</span><span class="s2">\n            </span><span class="s1">active: true,</span><span class="s2">\n            </span><span class="s1">matches: partialMatches</span><span class="s2">\n          </span><span class="s1">};</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return {</span><span class="s2">\n      </span><span class="s1">active: false,</span><span class="s2">\n      </span><span class="s1">matches: null</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">async function discoverRoutes(matches, pathname, signal, fetcherKey) {</span><span class="s2">\n    </span><span class="s1">if (!init.patchRoutesOnNavigation) {</span><span class="s2">\n      </span><span class="s1">return {</span><span class="s2">\n        </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">success</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        </span><span class="s1">matches</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let partialMatches = matches;</span><span class="s2">\n    </span><span class="s1">while (true) {</span><span class="s2">\n      </span><span class="s1">let isNonHMR = inFlightDataRoutes == null;</span><span class="s2">\n      </span><span class="s1">let routesToUse = inFlightDataRoutes || dataRoutes;</span><span class="s2">\n      </span><span class="s1">let localManifest = manifest;</span><span class="s2">\n      </span><span class="s1">try {</span><span class="s2">\n        </span><span class="s1">await init.patchRoutesOnNavigation({</span><span class="s2">\n          </span><span class="s1">signal,</span><span class="s2">\n          </span><span class="s1">path: pathname,</span><span class="s2">\n          </span><span class="s1">matches: partialMatches,</span><span class="s2">\n          </span><span class="s1">fetcherKey,</span><span class="s2">\n          </span><span class="s1">patch: (routeId, children) =&gt; {</span><span class="s2">\n            </span><span class="s1">if (signal.aborted) return;</span><span class="s2">\n            </span><span class="s1">patchRoutesImpl(routeId, children, routesToUse, localManifest, mapRouteProperties2);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">} catch (e) {</span><span class="s2">\n        </span><span class="s1">return {</span><span class="s2">\n          </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">error</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n          </span><span class="s1">error: e,</span><span class="s2">\n          </span><span class="s1">partialMatches</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">} finally {</span><span class="s2">\n        </span><span class="s1">if (isNonHMR &amp;&amp; !signal.aborted) {</span><span class="s2">\n          </span><span class="s1">dataRoutes = [...dataRoutes];</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (signal.aborted) {</span><span class="s2">\n        </span><span class="s1">return {</span><span class="s2">\n          </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">aborted</span><span class="s2">\&quot;\n        </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">let newMatches = matchRoutes(routesToUse, pathname, basename);</span><span class="s2">\n      </span><span class="s1">if (newMatches) {</span><span class="s2">\n        </span><span class="s1">return {</span><span class="s2">\n          </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">success</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n          </span><span class="s1">matches: newMatches</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">let newPartialMatches = matchRoutesImpl(routesToUse, pathname, basename, true);</span><span class="s2">\n      </span><span class="s1">if (!newPartialMatches || partialMatches.length === newPartialMatches.length &amp;&amp; partialMatches.every((m, i) =&gt; m.route.id === newPartialMatches[i].route.id)) {</span><span class="s2">\n        </span><span class="s1">return {</span><span class="s2">\n          </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">success</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n          </span><span class="s1">matches: null</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">partialMatches = newPartialMatches;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function _internalSetRoutes(newRoutes) {</span><span class="s2">\n    </span><span class="s1">manifest = {};</span><span class="s2">\n    </span><span class="s1">inFlightDataRoutes = convertRoutesToDataRoutes(newRoutes, mapRouteProperties2, void 0, manifest);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function patchRoutes(routeId, children) {</span><span class="s2">\n    </span><span class="s1">let isNonHMR = inFlightDataRoutes == null;</span><span class="s2">\n    </span><span class="s1">let routesToUse = inFlightDataRoutes || dataRoutes;</span><span class="s2">\n    </span><span class="s1">patchRoutesImpl(routeId, children, routesToUse, manifest, mapRouteProperties2);</span><span class="s2">\n    </span><span class="s1">if (isNonHMR) {</span><span class="s2">\n      </span><span class="s1">dataRoutes = [...dataRoutes];</span><span class="s2">\n      </span><span class="s1">updateState({});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">router = {</span><span class="s2">\n    </span><span class="s1">get basename() {</span><span class="s2">\n      </span><span class="s1">return basename;</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">get future() {</span><span class="s2">\n      </span><span class="s1">return future;</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">get state() {</span><span class="s2">\n      </span><span class="s1">return state;</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">get routes() {</span><span class="s2">\n      </span><span class="s1">return dataRoutes;</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">get window() {</span><span class="s2">\n      </span><span class="s1">return routerWindow;</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">initialize,</span><span class="s2">\n    </span><span class="s1">subscribe,</span><span class="s2">\n    </span><span class="s1">enableScrollRestoration,</span><span class="s2">\n    </span><span class="s1">navigate,</span><span class="s2">\n    </span><span class="s1">fetch: fetch2,</span><span class="s2">\n    </span><span class="s1">revalidate,</span><span class="s2">\n    </span><span class="s1">// Passthrough to history-aware createHref used by useHref so we get proper</span><span class="s2">\n    </span><span class="s1">// hash-aware URLs in DOM paths</span><span class="s2">\n    </span><span class="s1">createHref: to =&gt; init.history.createHref(to),</span><span class="s2">\n    </span><span class="s1">encodeLocation: to =&gt; init.history.encodeLocation(to),</span><span class="s2">\n    </span><span class="s1">getFetcher,</span><span class="s2">\n    </span><span class="s1">deleteFetcher: queueFetcherForDeletion,</span><span class="s2">\n    </span><span class="s1">dispose,</span><span class="s2">\n    </span><span class="s1">getBlocker,</span><span class="s2">\n    </span><span class="s1">deleteBlocker,</span><span class="s2">\n    </span><span class="s1">patchRoutes,</span><span class="s2">\n    </span><span class="s1">_internalFetchControllers: fetchControllers,</span><span class="s2">\n    </span><span class="s1">// TODO: Remove setRoutes, it's temporary to avoid dealing with</span><span class="s2">\n    </span><span class="s1">// updating the tree while validating the update algorithm.</span><span class="s2">\n    </span><span class="s1">_internalSetRoutes</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">return router;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createStaticHandler(routes, opts) {</span><span class="s2">\n  </span><span class="s1">invariant(routes.length &gt; 0, </span><span class="s2">\&quot;</span><span class="s1">You must provide a non-empty routes array to createStaticHandler</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let manifest = {};</span><span class="s2">\n  </span><span class="s1">let basename = (opts ? opts.basename : null) || </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">let mapRouteProperties2 = opts?.mapRouteProperties || defaultMapRouteProperties;</span><span class="s2">\n  </span><span class="s1">let dataRoutes = convertRoutesToDataRoutes(routes, mapRouteProperties2, void 0, manifest);</span><span class="s2">\n  </span><span class="s1">async function query(request, {</span><span class="s2">\n    </span><span class="s1">requestContext,</span><span class="s2">\n    </span><span class="s1">filterMatchesToLoad,</span><span class="s2">\n    </span><span class="s1">skipLoaderErrorBubbling,</span><span class="s2">\n    </span><span class="s1">skipRevalidation,</span><span class="s2">\n    </span><span class="s1">dataStrategy,</span><span class="s2">\n    </span><span class="s1">unstable_respond: respond</span><span class="s2">\n  </span><span class="s1">} = {}) {</span><span class="s2">\n    </span><span class="s1">let url = new URL(request.url);</span><span class="s2">\n    </span><span class="s1">let method = request.method;</span><span class="s2">\n    </span><span class="s1">let location = createLocation(</span><span class="s2">\&quot;\&quot;</span><span class="s1">, createPath(url), null, </span><span class="s2">\&quot;</span><span class="s1">default</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">let matches = matchRoutes(dataRoutes, location, basename);</span><span class="s2">\n    </span><span class="s1">requestContext = requestContext != null ? requestContext : new unstable_RouterContextProvider();</span><span class="s2">\n    </span><span class="s1">if (!isValidMethod(method) &amp;&amp; method !== </span><span class="s2">\&quot;</span><span class="s1">HEAD</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">let error = getInternalRouterError(405, {</span><span class="s2">\n        </span><span class="s1">method</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">let {</span><span class="s2">\n        </span><span class="s1">matches: methodNotAllowedMatches,</span><span class="s2">\n        </span><span class="s1">route</span><span class="s2">\n      </span><span class="s1">} = getShortCircuitMatches(dataRoutes);</span><span class="s2">\n      </span><span class="s1">let staticContext = {</span><span class="s2">\n        </span><span class="s1">basename,</span><span class="s2">\n        </span><span class="s1">location,</span><span class="s2">\n        </span><span class="s1">matches: methodNotAllowedMatches,</span><span class="s2">\n        </span><span class="s1">loaderData: {},</span><span class="s2">\n        </span><span class="s1">actionData: null,</span><span class="s2">\n        </span><span class="s1">errors: {</span><span class="s2">\n          </span><span class="s1">[route.id]: error</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">statusCode: error.status,</span><span class="s2">\n        </span><span class="s1">loaderHeaders: {},</span><span class="s2">\n        </span><span class="s1">actionHeaders: {}</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">return respond ? respond(staticContext) : staticContext;</span><span class="s2">\n    </span><span class="s1">} else if (!matches) {</span><span class="s2">\n      </span><span class="s1">let error = getInternalRouterError(404, {</span><span class="s2">\n        </span><span class="s1">pathname: location.pathname</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">let {</span><span class="s2">\n        </span><span class="s1">matches: notFoundMatches,</span><span class="s2">\n        </span><span class="s1">route</span><span class="s2">\n      </span><span class="s1">} = getShortCircuitMatches(dataRoutes);</span><span class="s2">\n      </span><span class="s1">let staticContext = {</span><span class="s2">\n        </span><span class="s1">basename,</span><span class="s2">\n        </span><span class="s1">location,</span><span class="s2">\n        </span><span class="s1">matches: notFoundMatches,</span><span class="s2">\n        </span><span class="s1">loaderData: {},</span><span class="s2">\n        </span><span class="s1">actionData: null,</span><span class="s2">\n        </span><span class="s1">errors: {</span><span class="s2">\n          </span><span class="s1">[route.id]: error</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">statusCode: error.status,</span><span class="s2">\n        </span><span class="s1">loaderHeaders: {},</span><span class="s2">\n        </span><span class="s1">actionHeaders: {}</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">return respond ? respond(staticContext) : staticContext;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (respond &amp;&amp; matches.some(m =&gt; m.route.unstable_middleware || typeof m.route.lazy === </span><span class="s2">\&quot;</span><span class="s1">object</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; m.route.lazy.unstable_middleware)) {</span><span class="s2">\n      </span><span class="s1">invariant(requestContext instanceof unstable_RouterContextProvider, </span><span class="s2">\&quot;</span><span class="s1">When using middleware in `staticHandler.query()`, any provided `requestContext` must be an instance of `unstable_RouterContextProvider`</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">try {</span><span class="s2">\n        </span><span class="s1">await loadLazyMiddlewareForMatches(matches, manifest, mapRouteProperties2);</span><span class="s2">\n        </span><span class="s1">let renderedStaticContext;</span><span class="s2">\n        </span><span class="s1">let response = await runMiddlewarePipeline({</span><span class="s2">\n          </span><span class="s1">request,</span><span class="s2">\n          </span><span class="s1">matches,</span><span class="s2">\n          </span><span class="s1">params: matches[0].params,</span><span class="s2">\n          </span><span class="s1">// If we're calling middleware then it must be enabled so we can cast</span><span class="s2">\n          </span><span class="s1">// this to the proper type knowing it's not an `AppLoadContext`</span><span class="s2">\n          </span><span class="s1">context: requestContext</span><span class="s2">\n        </span><span class="s1">}, true, async () =&gt; {</span><span class="s2">\n          </span><span class="s1">let result2 = await queryImpl(request, location, matches, requestContext, dataStrategy || null, skipLoaderErrorBubbling === true, null, filterMatchesToLoad || null, skipRevalidation === true);</span><span class="s2">\n          </span><span class="s1">if (isResponse(result2)) {</span><span class="s2">\n            </span><span class="s1">return result2;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">renderedStaticContext = {</span><span class="s2">\n            </span><span class="s1">location,</span><span class="s2">\n            </span><span class="s1">basename,</span><span class="s2">\n            </span><span class="s1">...result2</span><span class="s2">\n          </span><span class="s1">};</span><span class="s2">\n          </span><span class="s1">let res = await respond(renderedStaticContext);</span><span class="s2">\n          </span><span class="s1">return res;</span><span class="s2">\n        </span><span class="s1">}, async (error, routeId) =&gt; {</span><span class="s2">\n          </span><span class="s1">if (isResponse(error)) {</span><span class="s2">\n            </span><span class="s1">return error;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">if (renderedStaticContext) {</span><span class="s2">\n            </span><span class="s1">if (routeId in renderedStaticContext.loaderData) {</span><span class="s2">\n              </span><span class="s1">renderedStaticContext.loaderData[routeId] = void 0;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">return respond(getStaticContextFromError(dataRoutes, renderedStaticContext, error, skipLoaderErrorBubbling ? routeId : findNearestBoundary(matches, routeId).route.id));</span><span class="s2">\n          </span><span class="s1">} else {</span><span class="s2">\n            </span><span class="s1">let boundaryRouteId = skipLoaderErrorBubbling ? routeId : findNearestBoundary(matches, matches.find(m =&gt; m.route.id === routeId || m.route.loader)?.route.id || routeId).route.id;</span><span class="s2">\n            </span><span class="s1">return respond({</span><span class="s2">\n              </span><span class="s1">matches,</span><span class="s2">\n              </span><span class="s1">location,</span><span class="s2">\n              </span><span class="s1">basename,</span><span class="s2">\n              </span><span class="s1">loaderData: {},</span><span class="s2">\n              </span><span class="s1">actionData: null,</span><span class="s2">\n              </span><span class="s1">errors: {</span><span class="s2">\n                </span><span class="s1">[boundaryRouteId]: error</span><span class="s2">\n              </span><span class="s1">},</span><span class="s2">\n              </span><span class="s1">statusCode: isRouteErrorResponse(error) ? error.status : 500,</span><span class="s2">\n              </span><span class="s1">actionHeaders: {},</span><span class="s2">\n              </span><span class="s1">loaderHeaders: {}</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">invariant(isResponse(response), </span><span class="s2">\&quot;</span><span class="s1">Expected a response in query()</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">return response;</span><span class="s2">\n      </span><span class="s1">} catch (e) {</span><span class="s2">\n        </span><span class="s1">if (isResponse(e)) {</span><span class="s2">\n          </span><span class="s1">return e;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">throw e;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let result = await queryImpl(request, location, matches, requestContext, dataStrategy || null, skipLoaderErrorBubbling === true, null, filterMatchesToLoad || null, skipRevalidation === true);</span><span class="s2">\n    </span><span class="s1">if (isResponse(result)) {</span><span class="s2">\n      </span><span class="s1">return result;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return {</span><span class="s2">\n      </span><span class="s1">location,</span><span class="s2">\n      </span><span class="s1">basename,</span><span class="s2">\n      </span><span class="s1">...result</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">async function queryRoute(request, {</span><span class="s2">\n    </span><span class="s1">routeId,</span><span class="s2">\n    </span><span class="s1">requestContext,</span><span class="s2">\n    </span><span class="s1">dataStrategy,</span><span class="s2">\n    </span><span class="s1">unstable_respond: respond</span><span class="s2">\n  </span><span class="s1">} = {}) {</span><span class="s2">\n    </span><span class="s1">let url = new URL(request.url);</span><span class="s2">\n    </span><span class="s1">let method = request.method;</span><span class="s2">\n    </span><span class="s1">let location = createLocation(</span><span class="s2">\&quot;\&quot;</span><span class="s1">, createPath(url), null, </span><span class="s2">\&quot;</span><span class="s1">default</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">let matches = matchRoutes(dataRoutes, location, basename);</span><span class="s2">\n    </span><span class="s1">requestContext = requestContext != null ? requestContext : new unstable_RouterContextProvider();</span><span class="s2">\n    </span><span class="s1">if (!isValidMethod(method) &amp;&amp; method !== </span><span class="s2">\&quot;</span><span class="s1">HEAD</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; method !== </span><span class="s2">\&quot;</span><span class="s1">OPTIONS</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">throw getInternalRouterError(405, {</span><span class="s2">\n        </span><span class="s1">method</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">} else if (!matches) {</span><span class="s2">\n      </span><span class="s1">throw getInternalRouterError(404, {</span><span class="s2">\n        </span><span class="s1">pathname: location.pathname</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let match = routeId ? matches.find(m =&gt; m.route.id === routeId) : getTargetMatch(matches, location);</span><span class="s2">\n    </span><span class="s1">if (routeId &amp;&amp; !match) {</span><span class="s2">\n      </span><span class="s1">throw getInternalRouterError(403, {</span><span class="s2">\n        </span><span class="s1">pathname: location.pathname,</span><span class="s2">\n        </span><span class="s1">routeId</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">} else if (!match) {</span><span class="s2">\n      </span><span class="s1">throw getInternalRouterError(404, {</span><span class="s2">\n        </span><span class="s1">pathname: location.pathname</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (respond &amp;&amp; matches.some(m =&gt; m.route.unstable_middleware || typeof m.route.lazy === </span><span class="s2">\&quot;</span><span class="s1">object</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; m.route.lazy.unstable_middleware)) {</span><span class="s2">\n      </span><span class="s1">invariant(requestContext instanceof unstable_RouterContextProvider, </span><span class="s2">\&quot;</span><span class="s1">When using middleware in `staticHandler.queryRoute()`, any provided `requestContext` must be an instance of `unstable_RouterContextProvider`</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">await loadLazyMiddlewareForMatches(matches, manifest, mapRouteProperties2);</span><span class="s2">\n      </span><span class="s1">let response = await runMiddlewarePipeline({</span><span class="s2">\n        </span><span class="s1">request,</span><span class="s2">\n        </span><span class="s1">matches,</span><span class="s2">\n        </span><span class="s1">params: matches[0].params,</span><span class="s2">\n        </span><span class="s1">// If we're calling middleware then it must be enabled so we can cast</span><span class="s2">\n        </span><span class="s1">// this to the proper type knowing it's not an `AppLoadContext`</span><span class="s2">\n        </span><span class="s1">context: requestContext</span><span class="s2">\n      </span><span class="s1">}, true, async () =&gt; {</span><span class="s2">\n        </span><span class="s1">let result2 = await queryImpl(request, location, matches, requestContext, dataStrategy || null, false, match, null, false);</span><span class="s2">\n        </span><span class="s1">if (isResponse(result2)) {</span><span class="s2">\n          </span><span class="s1">return respond(result2);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">let error2 = result2.errors ? Object.values(result2.errors)[0] : void 0;</span><span class="s2">\n        </span><span class="s1">if (error2 !== void 0) {</span><span class="s2">\n          </span><span class="s1">throw error2;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">let value = result2.actionData ? Object.values(result2.actionData)[0] : Object.values(result2.loaderData)[0];</span><span class="s2">\n        </span><span class="s1">return typeof value === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">? new Response(value) : Response.json(value);</span><span class="s2">\n      </span><span class="s1">}, error2 =&gt; {</span><span class="s2">\n        </span><span class="s1">if (isResponse(error2)) {</span><span class="s2">\n          </span><span class="s1">return respond(error2);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return new Response(String(error2), {</span><span class="s2">\n          </span><span class="s1">status: 500,</span><span class="s2">\n          </span><span class="s1">statusText: </span><span class="s2">\&quot;</span><span class="s1">Unexpected Server Error</span><span class="s2">\&quot;\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">return response;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let result = await queryImpl(request, location, matches, requestContext, dataStrategy || null, false, match, null, false);</span><span class="s2">\n    </span><span class="s1">if (isResponse(result)) {</span><span class="s2">\n      </span><span class="s1">return result;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let error = result.errors ? Object.values(result.errors)[0] : void 0;</span><span class="s2">\n    </span><span class="s1">if (error !== void 0) {</span><span class="s2">\n      </span><span class="s1">throw error;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (result.actionData) {</span><span class="s2">\n      </span><span class="s1">return Object.values(result.actionData)[0];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (result.loaderData) {</span><span class="s2">\n      </span><span class="s1">return Object.values(result.loaderData)[0];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return void 0;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">async function queryImpl(request, location, matches, requestContext, dataStrategy, skipLoaderErrorBubbling, routeMatch, filterMatchesToLoad, skipRevalidation) {</span><span class="s2">\n    </span><span class="s1">invariant(request.signal, </span><span class="s2">\&quot;</span><span class="s1">query()/queryRoute() requests must contain an AbortController signal</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">try {</span><span class="s2">\n      </span><span class="s1">if (isMutationMethod(request.method)) {</span><span class="s2">\n        </span><span class="s1">let result2 = await submit(request, matches, routeMatch || getTargetMatch(matches, location), requestContext, dataStrategy, skipLoaderErrorBubbling, routeMatch != null, filterMatchesToLoad, skipRevalidation);</span><span class="s2">\n        </span><span class="s1">return result2;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">let result = await loadRouteData(request, matches, requestContext, dataStrategy, skipLoaderErrorBubbling, routeMatch, filterMatchesToLoad);</span><span class="s2">\n      </span><span class="s1">return isResponse(result) ? result : {</span><span class="s2">\n        </span><span class="s1">...result,</span><span class="s2">\n        </span><span class="s1">actionData: null,</span><span class="s2">\n        </span><span class="s1">actionHeaders: {}</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">} catch (e) {</span><span class="s2">\n      </span><span class="s1">if (isDataStrategyResult(e) &amp;&amp; isResponse(e.result)) {</span><span class="s2">\n        </span><span class="s1">if (e.type === </span><span class="s2">\&quot;</span><span class="s1">error</span><span class="s2">\&quot; </span><span class="s1">/* error */) {</span><span class="s2">\n          </span><span class="s1">throw e.result;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return e.result;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (isRedirectResponse(e)) {</span><span class="s2">\n        </span><span class="s1">return e;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">throw e;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">async function submit(request, matches, actionMatch, requestContext, dataStrategy, skipLoaderErrorBubbling, isRouteRequest, filterMatchesToLoad, skipRevalidation) {</span><span class="s2">\n    </span><span class="s1">let result;</span><span class="s2">\n    </span><span class="s1">if (!actionMatch.route.action &amp;&amp; !actionMatch.route.lazy) {</span><span class="s2">\n      </span><span class="s1">let error = getInternalRouterError(405, {</span><span class="s2">\n        </span><span class="s1">method: request.method,</span><span class="s2">\n        </span><span class="s1">pathname: new URL(request.url).pathname,</span><span class="s2">\n        </span><span class="s1">routeId: actionMatch.route.id</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">if (isRouteRequest) {</span><span class="s2">\n        </span><span class="s1">throw error;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">result = {</span><span class="s2">\n        </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">error</span><span class="s2">\&quot; </span><span class="s1">/* error */,</span><span class="s2">\n        </span><span class="s1">error</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">let dsMatches = getTargetedDataStrategyMatches(mapRouteProperties2, manifest, request, matches, actionMatch, [], requestContext);</span><span class="s2">\n      </span><span class="s1">let results = await callDataStrategy(request, dsMatches, isRouteRequest, requestContext, dataStrategy);</span><span class="s2">\n      </span><span class="s1">result = results[actionMatch.route.id];</span><span class="s2">\n      </span><span class="s1">if (request.signal.aborted) {</span><span class="s2">\n        </span><span class="s1">throwStaticHandlerAbortedError(request, isRouteRequest);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (isRedirectResult(result)) {</span><span class="s2">\n      </span><span class="s1">throw new Response(null, {</span><span class="s2">\n        </span><span class="s1">status: result.response.status,</span><span class="s2">\n        </span><span class="s1">headers: {</span><span class="s2">\n          </span><span class="s1">Location: result.response.headers.get(</span><span class="s2">\&quot;</span><span class="s1">Location</span><span class="s2">\&quot;</span><span class="s1">)</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (isRouteRequest) {</span><span class="s2">\n      </span><span class="s1">if (isErrorResult(result)) {</span><span class="s2">\n        </span><span class="s1">throw result.error;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return {</span><span class="s2">\n        </span><span class="s1">matches: [actionMatch],</span><span class="s2">\n        </span><span class="s1">loaderData: {},</span><span class="s2">\n        </span><span class="s1">actionData: {</span><span class="s2">\n          </span><span class="s1">[actionMatch.route.id]: result.data</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">errors: null,</span><span class="s2">\n        </span><span class="s1">// Note: statusCode + headers are unused here since queryRoute will</span><span class="s2">\n        </span><span class="s1">// return the raw Response or value</span><span class="s2">\n        </span><span class="s1">statusCode: 200,</span><span class="s2">\n        </span><span class="s1">loaderHeaders: {},</span><span class="s2">\n        </span><span class="s1">actionHeaders: {}</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (skipRevalidation) {</span><span class="s2">\n      </span><span class="s1">if (isErrorResult(result)) {</span><span class="s2">\n        </span><span class="s1">let boundaryMatch = skipLoaderErrorBubbling ? actionMatch : findNearestBoundary(matches, actionMatch.route.id);</span><span class="s2">\n        </span><span class="s1">return {</span><span class="s2">\n          </span><span class="s1">statusCode: isRouteErrorResponse(result.error) ? result.error.status : result.statusCode != null ? result.statusCode : 500,</span><span class="s2">\n          </span><span class="s1">actionData: null,</span><span class="s2">\n          </span><span class="s1">actionHeaders: {</span><span class="s2">\n            </span><span class="s1">...(result.headers ? {</span><span class="s2">\n              </span><span class="s1">[actionMatch.route.id]: result.headers</span><span class="s2">\n            </span><span class="s1">} : {})</span><span class="s2">\n          </span><span class="s1">},</span><span class="s2">\n          </span><span class="s1">matches,</span><span class="s2">\n          </span><span class="s1">loaderData: {},</span><span class="s2">\n          </span><span class="s1">errors: {</span><span class="s2">\n            </span><span class="s1">[boundaryMatch.route.id]: result.error</span><span class="s2">\n          </span><span class="s1">},</span><span class="s2">\n          </span><span class="s1">loaderHeaders: {}</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">return {</span><span class="s2">\n          </span><span class="s1">actionData: {</span><span class="s2">\n            </span><span class="s1">[actionMatch.route.id]: result.data</span><span class="s2">\n          </span><span class="s1">},</span><span class="s2">\n          </span><span class="s1">actionHeaders: result.headers ? {</span><span class="s2">\n            </span><span class="s1">[actionMatch.route.id]: result.headers</span><span class="s2">\n          </span><span class="s1">} : {},</span><span class="s2">\n          </span><span class="s1">matches,</span><span class="s2">\n          </span><span class="s1">loaderData: {},</span><span class="s2">\n          </span><span class="s1">errors: null,</span><span class="s2">\n          </span><span class="s1">statusCode: result.statusCode || 200,</span><span class="s2">\n          </span><span class="s1">loaderHeaders: {}</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let loaderRequest = new Request(request.url, {</span><span class="s2">\n      </span><span class="s1">headers: request.headers,</span><span class="s2">\n      </span><span class="s1">redirect: request.redirect,</span><span class="s2">\n      </span><span class="s1">signal: request.signal</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">if (isErrorResult(result)) {</span><span class="s2">\n      </span><span class="s1">let boundaryMatch = skipLoaderErrorBubbling ? actionMatch : findNearestBoundary(matches, actionMatch.route.id);</span><span class="s2">\n      </span><span class="s1">let handlerContext2 = await loadRouteData(loaderRequest, matches, requestContext, dataStrategy, skipLoaderErrorBubbling, null, filterMatchesToLoad, [boundaryMatch.route.id, result]);</span><span class="s2">\n      </span><span class="s1">return {</span><span class="s2">\n        </span><span class="s1">...handlerContext2,</span><span class="s2">\n        </span><span class="s1">statusCode: isRouteErrorResponse(result.error) ? result.error.status : result.statusCode != null ? result.statusCode : 500,</span><span class="s2">\n        </span><span class="s1">actionData: null,</span><span class="s2">\n        </span><span class="s1">actionHeaders: {</span><span class="s2">\n          </span><span class="s1">...(result.headers ? {</span><span class="s2">\n            </span><span class="s1">[actionMatch.route.id]: result.headers</span><span class="s2">\n          </span><span class="s1">} : {})</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let handlerContext = await loadRouteData(loaderRequest, matches, requestContext, dataStrategy, skipLoaderErrorBubbling, null, filterMatchesToLoad);</span><span class="s2">\n    </span><span class="s1">return {</span><span class="s2">\n      </span><span class="s1">...handlerContext,</span><span class="s2">\n      </span><span class="s1">actionData: {</span><span class="s2">\n        </span><span class="s1">[actionMatch.route.id]: result.data</span><span class="s2">\n      </span><span class="s1">},</span><span class="s2">\n      </span><span class="s1">// action status codes take precedence over loader status codes</span><span class="s2">\n      </span><span class="s1">...(result.statusCode ? {</span><span class="s2">\n        </span><span class="s1">statusCode: result.statusCode</span><span class="s2">\n      </span><span class="s1">} : {}),</span><span class="s2">\n      </span><span class="s1">actionHeaders: result.headers ? {</span><span class="s2">\n        </span><span class="s1">[actionMatch.route.id]: result.headers</span><span class="s2">\n      </span><span class="s1">} : {}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">async function loadRouteData(request, matches, requestContext, dataStrategy, skipLoaderErrorBubbling, routeMatch, filterMatchesToLoad, pendingActionResult) {</span><span class="s2">\n    </span><span class="s1">let isRouteRequest = routeMatch != null;</span><span class="s2">\n    </span><span class="s1">if (isRouteRequest &amp;&amp; !routeMatch?.route.loader &amp;&amp; !routeMatch?.route.lazy) {</span><span class="s2">\n      </span><span class="s1">throw getInternalRouterError(400, {</span><span class="s2">\n        </span><span class="s1">method: request.method,</span><span class="s2">\n        </span><span class="s1">pathname: new URL(request.url).pathname,</span><span class="s2">\n        </span><span class="s1">routeId: routeMatch?.route.id</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let dsMatches;</span><span class="s2">\n    </span><span class="s1">if (routeMatch) {</span><span class="s2">\n      </span><span class="s1">dsMatches = getTargetedDataStrategyMatches(mapRouteProperties2, manifest, request, matches, routeMatch, [], requestContext);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">let maxIdx = pendingActionResult &amp;&amp; isErrorResult(pendingActionResult[1]) ?</span><span class="s2">\n      </span><span class="s1">// Up to but not including the boundary</span><span class="s2">\n      </span><span class="s1">matches.findIndex(m =&gt; m.route.id === pendingActionResult[0]) - 1 : void 0;</span><span class="s2">\n      </span><span class="s1">dsMatches = matches.map((match, index) =&gt; {</span><span class="s2">\n        </span><span class="s1">if (maxIdx != null &amp;&amp; index &gt; maxIdx) {</span><span class="s2">\n          </span><span class="s1">return getDataStrategyMatch(mapRouteProperties2, manifest, request, match, [], requestContext, false);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return getDataStrategyMatch(mapRouteProperties2, manifest, request, match, [], requestContext, (match.route.loader || match.route.lazy) != null &amp;&amp; (!filterMatchesToLoad || filterMatchesToLoad(match)));</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (!dataStrategy &amp;&amp; !dsMatches.some(m =&gt; m.shouldLoad)) {</span><span class="s2">\n      </span><span class="s1">return {</span><span class="s2">\n        </span><span class="s1">matches,</span><span class="s2">\n        </span><span class="s1">loaderData: {},</span><span class="s2">\n        </span><span class="s1">errors: pendingActionResult &amp;&amp; isErrorResult(pendingActionResult[1]) ? {</span><span class="s2">\n          </span><span class="s1">[pendingActionResult[0]]: pendingActionResult[1].error</span><span class="s2">\n        </span><span class="s1">} : null,</span><span class="s2">\n        </span><span class="s1">statusCode: 200,</span><span class="s2">\n        </span><span class="s1">loaderHeaders: {}</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let results = await callDataStrategy(request, dsMatches, isRouteRequest, requestContext, dataStrategy);</span><span class="s2">\n    </span><span class="s1">if (request.signal.aborted) {</span><span class="s2">\n      </span><span class="s1">throwStaticHandlerAbortedError(request, isRouteRequest);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let handlerContext = processRouteLoaderData(matches, results, pendingActionResult, true, skipLoaderErrorBubbling);</span><span class="s2">\n    </span><span class="s1">return {</span><span class="s2">\n      </span><span class="s1">...handlerContext,</span><span class="s2">\n      </span><span class="s1">matches</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">async function callDataStrategy(request, matches, isRouteRequest, requestContext, dataStrategy) {</span><span class="s2">\n    </span><span class="s1">let results = await callDataStrategyImpl(dataStrategy || defaultDataStrategy, request, matches, null, requestContext, true);</span><span class="s2">\n    </span><span class="s1">let dataResults = {};</span><span class="s2">\n    </span><span class="s1">await Promise.all(matches.map(async match =&gt; {</span><span class="s2">\n      </span><span class="s1">if (!(match.route.id in results)) {</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">let result = results[match.route.id];</span><span class="s2">\n      </span><span class="s1">if (isRedirectDataStrategyResult(result)) {</span><span class="s2">\n        </span><span class="s1">let response = result.result;</span><span class="s2">\n        </span><span class="s1">throw normalizeRelativeRoutingRedirectResponse(response, request, match.route.id, matches, basename);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (isResponse(result.result) &amp;&amp; isRouteRequest) {</span><span class="s2">\n        </span><span class="s1">throw result;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">dataResults[match.route.id] = await convertDataStrategyResultToDataResult(result);</span><span class="s2">\n    </span><span class="s1">}));</span><span class="s2">\n    </span><span class="s1">return dataResults;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">dataRoutes,</span><span class="s2">\n    </span><span class="s1">query,</span><span class="s2">\n    </span><span class="s1">queryRoute</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getStaticContextFromError(routes, handlerContext, error, boundaryId) {</span><span class="s2">\n  </span><span class="s1">let errorBoundaryId = boundaryId || handlerContext._deepestRenderedBoundaryId || routes[0].id;</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">...handlerContext,</span><span class="s2">\n    </span><span class="s1">statusCode: isRouteErrorResponse(error) ? error.status : 500,</span><span class="s2">\n    </span><span class="s1">errors: {</span><span class="s2">\n      </span><span class="s1">[errorBoundaryId]: error</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function throwStaticHandlerAbortedError(request, isRouteRequest) {</span><span class="s2">\n  </span><span class="s1">if (request.signal.reason !== void 0) {</span><span class="s2">\n    </span><span class="s1">throw request.signal.reason;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let method = isRouteRequest ? </span><span class="s2">\&quot;</span><span class="s1">queryRoute</span><span class="s2">\&quot; </span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">query</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">throw new Error(`${method}() call aborted without an </span><span class="s2">\\</span><span class="s1">`AbortSignal.reason</span><span class="s2">\\</span><span class="s1">`: ${request.method} ${request.url}`);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isSubmissionNavigation(opts) {</span><span class="s2">\n  </span><span class="s1">return opts != null &amp;&amp; (</span><span class="s2">\&quot;</span><span class="s1">formData</span><span class="s2">\&quot; </span><span class="s1">in opts &amp;&amp; opts.formData != null || </span><span class="s2">\&quot;</span><span class="s1">body</span><span class="s2">\&quot; </span><span class="s1">in opts &amp;&amp; opts.body !== void 0);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function normalizeTo(location, matches, basename, to, fromRouteId, relative) {</span><span class="s2">\n  </span><span class="s1">let contextualMatches;</span><span class="s2">\n  </span><span class="s1">let activeRouteMatch;</span><span class="s2">\n  </span><span class="s1">if (fromRouteId) {</span><span class="s2">\n    </span><span class="s1">contextualMatches = [];</span><span class="s2">\n    </span><span class="s1">for (let match of matches) {</span><span class="s2">\n      </span><span class="s1">contextualMatches.push(match);</span><span class="s2">\n      </span><span class="s1">if (match.route.id === fromRouteId) {</span><span class="s2">\n        </span><span class="s1">activeRouteMatch = match;</span><span class="s2">\n        </span><span class="s1">break;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">contextualMatches = matches;</span><span class="s2">\n    </span><span class="s1">activeRouteMatch = matches[matches.length - 1];</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let path = resolveTo(to ? to : </span><span class="s2">\&quot;</span><span class="s1">.</span><span class="s2">\&quot;</span><span class="s1">, getResolveToMatches(contextualMatches), stripBasename(location.pathname, basename) || location.pathname, relative === </span><span class="s2">\&quot;</span><span class="s1">path</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">if (to == null) {</span><span class="s2">\n    </span><span class="s1">path.search = location.search;</span><span class="s2">\n    </span><span class="s1">path.hash = location.hash;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if ((to == null || to === </span><span class="s2">\&quot;\&quot; </span><span class="s1">|| to === </span><span class="s2">\&quot;</span><span class="s1">.</span><span class="s2">\&quot;</span><span class="s1">) &amp;&amp; activeRouteMatch) {</span><span class="s2">\n    </span><span class="s1">let nakedIndex = hasNakedIndexQuery(path.search);</span><span class="s2">\n    </span><span class="s1">if (activeRouteMatch.route.index &amp;&amp; !nakedIndex) {</span><span class="s2">\n      </span><span class="s1">path.search = path.search ? path.search.replace(/^</span><span class="s2">\\</span><span class="s1">?/, </span><span class="s2">\&quot;</span><span class="s1">?index&amp;</span><span class="s2">\&quot;</span><span class="s1">) : </span><span class="s2">\&quot;</span><span class="s1">?index</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">} else if (!activeRouteMatch.route.index &amp;&amp; nakedIndex) {</span><span class="s2">\n      </span><span class="s1">let params = new URLSearchParams(path.search);</span><span class="s2">\n      </span><span class="s1">let indexValues = params.getAll(</span><span class="s2">\&quot;</span><span class="s1">index</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">params.delete(</span><span class="s2">\&quot;</span><span class="s1">index</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">indexValues.filter(v =&gt; v).forEach(v =&gt; params.append(</span><span class="s2">\&quot;</span><span class="s1">index</span><span class="s2">\&quot;</span><span class="s1">, v));</span><span class="s2">\n      </span><span class="s1">let qs = params.toString();</span><span class="s2">\n      </span><span class="s1">path.search = qs ? `?${qs}` : </span><span class="s2">\&quot;\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (basename !== </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">path.pathname = path.pathname === </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot; </span><span class="s1">? basename : joinPaths([basename, path.pathname]);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return createPath(path);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function normalizeNavigateOptions(isFetcher, path, opts) {</span><span class="s2">\n  </span><span class="s1">if (!opts || !isSubmissionNavigation(opts)) {</span><span class="s2">\n    </span><span class="s1">return {</span><span class="s2">\n      </span><span class="s1">path</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (opts.formMethod &amp;&amp; !isValidMethod(opts.formMethod)) {</span><span class="s2">\n    </span><span class="s1">return {</span><span class="s2">\n      </span><span class="s1">path,</span><span class="s2">\n      </span><span class="s1">error: getInternalRouterError(405, {</span><span class="s2">\n        </span><span class="s1">method: opts.formMethod</span><span class="s2">\n      </span><span class="s1">})</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let getInvalidBodyError = () =&gt; ({</span><span class="s2">\n    </span><span class="s1">path,</span><span class="s2">\n    </span><span class="s1">error: getInternalRouterError(400, {</span><span class="s2">\n      </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">invalid-body</span><span class="s2">\&quot;\n    </span><span class="s1">})</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">let rawFormMethod = opts.formMethod || </span><span class="s2">\&quot;</span><span class="s1">get</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">let formMethod = rawFormMethod.toUpperCase();</span><span class="s2">\n  </span><span class="s1">let formAction = stripHashFromPath(path);</span><span class="s2">\n  </span><span class="s1">if (opts.body !== void 0) {</span><span class="s2">\n    </span><span class="s1">if (opts.formEncType === </span><span class="s2">\&quot;</span><span class="s1">text/plain</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">if (!isMutationMethod(formMethod)) {</span><span class="s2">\n        </span><span class="s1">return getInvalidBodyError();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">let text = typeof opts.body === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">? opts.body : opts.body instanceof FormData || opts.body instanceof URLSearchParams ?</span><span class="s2">\n      </span><span class="s1">// https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#plain-text-form-data</span><span class="s2">\n      </span><span class="s1">Array.from(opts.body.entries()).reduce((acc, [name, value]) =&gt; `${acc}${name}=${value}</span><span class="s2">\n</span><span class="s1">`, </span><span class="s2">\&quot;\&quot;</span><span class="s1">) : String(opts.body);</span><span class="s2">\n      </span><span class="s1">return {</span><span class="s2">\n        </span><span class="s1">path,</span><span class="s2">\n        </span><span class="s1">submission: {</span><span class="s2">\n          </span><span class="s1">formMethod,</span><span class="s2">\n          </span><span class="s1">formAction,</span><span class="s2">\n          </span><span class="s1">formEncType: opts.formEncType,</span><span class="s2">\n          </span><span class="s1">formData: void 0,</span><span class="s2">\n          </span><span class="s1">json: void 0,</span><span class="s2">\n          </span><span class="s1">text</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">} else if (opts.formEncType === </span><span class="s2">\&quot;</span><span class="s1">application/json</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">if (!isMutationMethod(formMethod)) {</span><span class="s2">\n        </span><span class="s1">return getInvalidBodyError();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">try {</span><span class="s2">\n        </span><span class="s1">let json = typeof opts.body === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">? JSON.parse(opts.body) : opts.body;</span><span class="s2">\n        </span><span class="s1">return {</span><span class="s2">\n          </span><span class="s1">path,</span><span class="s2">\n          </span><span class="s1">submission: {</span><span class="s2">\n            </span><span class="s1">formMethod,</span><span class="s2">\n            </span><span class="s1">formAction,</span><span class="s2">\n            </span><span class="s1">formEncType: opts.formEncType,</span><span class="s2">\n            </span><span class="s1">formData: void 0,</span><span class="s2">\n            </span><span class="s1">json,</span><span class="s2">\n            </span><span class="s1">text: void 0</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">} catch (e) {</span><span class="s2">\n        </span><span class="s1">return getInvalidBodyError();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">invariant(typeof FormData === </span><span class="s2">\&quot;</span><span class="s1">function</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">FormData is not available in this environment</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let searchParams;</span><span class="s2">\n  </span><span class="s1">let formData;</span><span class="s2">\n  </span><span class="s1">if (opts.formData) {</span><span class="s2">\n    </span><span class="s1">searchParams = convertFormDataToSearchParams(opts.formData);</span><span class="s2">\n    </span><span class="s1">formData = opts.formData;</span><span class="s2">\n  </span><span class="s1">} else if (opts.body instanceof FormData) {</span><span class="s2">\n    </span><span class="s1">searchParams = convertFormDataToSearchParams(opts.body);</span><span class="s2">\n    </span><span class="s1">formData = opts.body;</span><span class="s2">\n  </span><span class="s1">} else if (opts.body instanceof URLSearchParams) {</span><span class="s2">\n    </span><span class="s1">searchParams = opts.body;</span><span class="s2">\n    </span><span class="s1">formData = convertSearchParamsToFormData(searchParams);</span><span class="s2">\n  </span><span class="s1">} else if (opts.body == null) {</span><span class="s2">\n    </span><span class="s1">searchParams = new URLSearchParams();</span><span class="s2">\n    </span><span class="s1">formData = new FormData();</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">try {</span><span class="s2">\n      </span><span class="s1">searchParams = new URLSearchParams(opts.body);</span><span class="s2">\n      </span><span class="s1">formData = convertSearchParamsToFormData(searchParams);</span><span class="s2">\n    </span><span class="s1">} catch (e) {</span><span class="s2">\n      </span><span class="s1">return getInvalidBodyError();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let submission = {</span><span class="s2">\n    </span><span class="s1">formMethod,</span><span class="s2">\n    </span><span class="s1">formAction,</span><span class="s2">\n    </span><span class="s1">formEncType: opts &amp;&amp; opts.formEncType || </span><span class="s2">\&quot;</span><span class="s1">application/x-www-form-urlencoded</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">formData,</span><span class="s2">\n    </span><span class="s1">json: void 0,</span><span class="s2">\n    </span><span class="s1">text: void 0</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">if (isMutationMethod(submission.formMethod)) {</span><span class="s2">\n    </span><span class="s1">return {</span><span class="s2">\n      </span><span class="s1">path,</span><span class="s2">\n      </span><span class="s1">submission</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let parsedPath = parsePath(path);</span><span class="s2">\n  </span><span class="s1">if (isFetcher &amp;&amp; parsedPath.search &amp;&amp; hasNakedIndexQuery(parsedPath.search)) {</span><span class="s2">\n    </span><span class="s1">searchParams.append(</span><span class="s2">\&quot;</span><span class="s1">index</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">parsedPath.search = `?${searchParams}`;</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">path: createPath(parsedPath),</span><span class="s2">\n    </span><span class="s1">submission</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getMatchesToLoad(request, scopedContext, mapRouteProperties2, manifest, history, state, matches, submission, location, lazyRoutePropertiesToSkip, initialHydration, isRevalidationRequired, cancelledFetcherLoads, fetchersQueuedForDeletion, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionResult) {</span><span class="s2">\n  </span><span class="s1">let actionResult = pendingActionResult ? isErrorResult(pendingActionResult[1]) ? pendingActionResult[1].error : pendingActionResult[1].data : void 0;</span><span class="s2">\n  </span><span class="s1">let currentUrl = history.createURL(state.location);</span><span class="s2">\n  </span><span class="s1">let nextUrl = history.createURL(location);</span><span class="s2">\n  </span><span class="s1">let maxIdx;</span><span class="s2">\n  </span><span class="s1">if (initialHydration &amp;&amp; state.errors) {</span><span class="s2">\n    </span><span class="s1">let boundaryId = Object.keys(state.errors)[0];</span><span class="s2">\n    </span><span class="s1">maxIdx = matches.findIndex(m =&gt; m.route.id === boundaryId);</span><span class="s2">\n  </span><span class="s1">} else if (pendingActionResult &amp;&amp; isErrorResult(pendingActionResult[1])) {</span><span class="s2">\n    </span><span class="s1">let boundaryId = pendingActionResult[0];</span><span class="s2">\n    </span><span class="s1">maxIdx = matches.findIndex(m =&gt; m.route.id === boundaryId) - 1;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let actionStatus = pendingActionResult ? pendingActionResult[1].statusCode : void 0;</span><span class="s2">\n  </span><span class="s1">let shouldSkipRevalidation = actionStatus &amp;&amp; actionStatus &gt;= 400;</span><span class="s2">\n  </span><span class="s1">let baseShouldRevalidateArgs = {</span><span class="s2">\n    </span><span class="s1">currentUrl,</span><span class="s2">\n    </span><span class="s1">currentParams: state.matches[0]?.params || {},</span><span class="s2">\n    </span><span class="s1">nextUrl,</span><span class="s2">\n    </span><span class="s1">nextParams: matches[0].params,</span><span class="s2">\n    </span><span class="s1">...submission,</span><span class="s2">\n    </span><span class="s1">actionResult,</span><span class="s2">\n    </span><span class="s1">actionStatus</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">let dsMatches = matches.map((match, index) =&gt; {</span><span class="s2">\n    </span><span class="s1">let {</span><span class="s2">\n      </span><span class="s1">route</span><span class="s2">\n    </span><span class="s1">} = match;</span><span class="s2">\n    </span><span class="s1">let forceShouldLoad = null;</span><span class="s2">\n    </span><span class="s1">if (maxIdx != null &amp;&amp; index &gt; maxIdx) {</span><span class="s2">\n      </span><span class="s1">forceShouldLoad = false;</span><span class="s2">\n    </span><span class="s1">} else if (route.lazy) {</span><span class="s2">\n      </span><span class="s1">forceShouldLoad = true;</span><span class="s2">\n    </span><span class="s1">} else if (route.loader == null) {</span><span class="s2">\n      </span><span class="s1">forceShouldLoad = false;</span><span class="s2">\n    </span><span class="s1">} else if (initialHydration) {</span><span class="s2">\n      </span><span class="s1">forceShouldLoad = shouldLoadRouteOnHydration(route, state.loaderData, state.errors);</span><span class="s2">\n    </span><span class="s1">} else if (isNewLoader(state.loaderData, state.matches[index], match)) {</span><span class="s2">\n      </span><span class="s1">forceShouldLoad = true;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (forceShouldLoad !== null) {</span><span class="s2">\n      </span><span class="s1">return getDataStrategyMatch(mapRouteProperties2, manifest, request, match, lazyRoutePropertiesToSkip, scopedContext, forceShouldLoad);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let defaultShouldRevalidate = shouldSkipRevalidation ? false :</span><span class="s2">\n    </span><span class="s1">// Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate</span><span class="s2">\n    </span><span class="s1">isRevalidationRequired || currentUrl.pathname + currentUrl.search === nextUrl.pathname + nextUrl.search ||</span><span class="s2">\n    </span><span class="s1">// Search params affect all loaders</span><span class="s2">\n    </span><span class="s1">currentUrl.search !== nextUrl.search || isNewRouteInstance(state.matches[index], match);</span><span class="s2">\n    </span><span class="s1">let shouldRevalidateArgs = {</span><span class="s2">\n      </span><span class="s1">...baseShouldRevalidateArgs,</span><span class="s2">\n      </span><span class="s1">defaultShouldRevalidate</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">let shouldLoad = shouldRevalidateLoader(match, shouldRevalidateArgs);</span><span class="s2">\n    </span><span class="s1">return getDataStrategyMatch(mapRouteProperties2, manifest, request, match, lazyRoutePropertiesToSkip, scopedContext, shouldLoad, shouldRevalidateArgs);</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">let revalidatingFetchers = [];</span><span class="s2">\n  </span><span class="s1">fetchLoadMatches.forEach((f, key) =&gt; {</span><span class="s2">\n    </span><span class="s1">if (initialHydration || !matches.some(m =&gt; m.route.id === f.routeId) || fetchersQueuedForDeletion.has(key)) {</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let fetcherMatches = matchRoutes(routesToUse, f.path, basename);</span><span class="s2">\n    </span><span class="s1">if (!fetcherMatches) {</span><span class="s2">\n      </span><span class="s1">revalidatingFetchers.push({</span><span class="s2">\n        </span><span class="s1">key,</span><span class="s2">\n        </span><span class="s1">routeId: f.routeId,</span><span class="s2">\n        </span><span class="s1">path: f.path,</span><span class="s2">\n        </span><span class="s1">matches: null,</span><span class="s2">\n        </span><span class="s1">match: null,</span><span class="s2">\n        </span><span class="s1">request: null,</span><span class="s2">\n        </span><span class="s1">controller: null</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (fetchRedirectIds.has(key)) {</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let fetcher = state.fetchers.get(key);</span><span class="s2">\n    </span><span class="s1">let fetcherMatch = getTargetMatch(fetcherMatches, f.path);</span><span class="s2">\n    </span><span class="s1">let fetchController = new AbortController();</span><span class="s2">\n    </span><span class="s1">let fetchRequest = createClientSideRequest(history, f.path, fetchController.signal);</span><span class="s2">\n    </span><span class="s1">let fetcherDsMatches = null;</span><span class="s2">\n    </span><span class="s1">if (cancelledFetcherLoads.has(key)) {</span><span class="s2">\n      </span><span class="s1">cancelledFetcherLoads.delete(key);</span><span class="s2">\n      </span><span class="s1">fetcherDsMatches = getTargetedDataStrategyMatches(mapRouteProperties2, manifest, fetchRequest, fetcherMatches, fetcherMatch, lazyRoutePropertiesToSkip, scopedContext);</span><span class="s2">\n    </span><span class="s1">} else if (fetcher &amp;&amp; fetcher.state !== </span><span class="s2">\&quot;</span><span class="s1">idle</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; fetcher.data === void 0) {</span><span class="s2">\n      </span><span class="s1">if (isRevalidationRequired) {</span><span class="s2">\n        </span><span class="s1">fetcherDsMatches = getTargetedDataStrategyMatches(mapRouteProperties2, manifest, fetchRequest, fetcherMatches, fetcherMatch, lazyRoutePropertiesToSkip, scopedContext);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">let shouldRevalidateArgs = {</span><span class="s2">\n        </span><span class="s1">...baseShouldRevalidateArgs,</span><span class="s2">\n        </span><span class="s1">defaultShouldRevalidate: shouldSkipRevalidation ? false : isRevalidationRequired</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">if (shouldRevalidateLoader(fetcherMatch, shouldRevalidateArgs)) {</span><span class="s2">\n        </span><span class="s1">fetcherDsMatches = getTargetedDataStrategyMatches(mapRouteProperties2, manifest, fetchRequest, fetcherMatches, fetcherMatch, lazyRoutePropertiesToSkip, scopedContext, shouldRevalidateArgs);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (fetcherDsMatches) {</span><span class="s2">\n      </span><span class="s1">revalidatingFetchers.push({</span><span class="s2">\n        </span><span class="s1">key,</span><span class="s2">\n        </span><span class="s1">routeId: f.routeId,</span><span class="s2">\n        </span><span class="s1">path: f.path,</span><span class="s2">\n        </span><span class="s1">matches: fetcherDsMatches,</span><span class="s2">\n        </span><span class="s1">match: fetcherMatch,</span><span class="s2">\n        </span><span class="s1">request: fetchRequest,</span><span class="s2">\n        </span><span class="s1">controller: fetchController</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">dsMatches,</span><span class="s2">\n    </span><span class="s1">revalidatingFetchers</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function shouldLoadRouteOnHydration(route, loaderData, errors) {</span><span class="s2">\n  </span><span class="s1">if (route.lazy) {</span><span class="s2">\n    </span><span class="s1">return true;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (!route.loader) {</span><span class="s2">\n    </span><span class="s1">return false;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let hasData = loaderData != null &amp;&amp; route.id in loaderData;</span><span class="s2">\n  </span><span class="s1">let hasError = errors != null &amp;&amp; errors[route.id] !== void 0;</span><span class="s2">\n  </span><span class="s1">if (!hasData &amp;&amp; hasError) {</span><span class="s2">\n    </span><span class="s1">return false;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (typeof route.loader === </span><span class="s2">\&quot;</span><span class="s1">function</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; route.loader.hydrate === true) {</span><span class="s2">\n    </span><span class="s1">return true;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return !hasData &amp;&amp; !hasError;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isNewLoader(currentLoaderData, currentMatch, match) {</span><span class="s2">\n  </span><span class="s1">let isNew =</span><span class="s2">\n  </span><span class="s1">// [a] -&gt; [a, b]</span><span class="s2">\n  </span><span class="s1">!currentMatch ||</span><span class="s2">\n  </span><span class="s1">// [a, b] -&gt; [a, c]</span><span class="s2">\n  </span><span class="s1">match.route.id !== currentMatch.route.id;</span><span class="s2">\n  </span><span class="s1">let isMissingData = !currentLoaderData.hasOwnProperty(match.route.id);</span><span class="s2">\n  </span><span class="s1">return isNew || isMissingData;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isNewRouteInstance(currentMatch, match) {</span><span class="s2">\n  </span><span class="s1">let currentPath = currentMatch.route.path;</span><span class="s2">\n  </span><span class="s1">return (</span><span class="s2">\n    </span><span class="s1">// param change for this match, /users/123 -&gt; /users/456</span><span class="s2">\n    </span><span class="s1">currentMatch.pathname !== match.pathname ||</span><span class="s2">\n    </span><span class="s1">// splat param changed, which is not present in match.path</span><span class="s2">\n    </span><span class="s1">// e.g. /files/images/avatar.jpg -&gt; files/finances.xls</span><span class="s2">\n    </span><span class="s1">currentPath != null &amp;&amp; currentPath.endsWith(</span><span class="s2">\&quot;</span><span class="s1">*</span><span class="s2">\&quot;</span><span class="s1">) &amp;&amp; currentMatch.params[</span><span class="s2">\&quot;</span><span class="s1">*</span><span class="s2">\&quot;</span><span class="s1">] !== match.params[</span><span class="s2">\&quot;</span><span class="s1">*</span><span class="s2">\&quot;</span><span class="s1">]</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function shouldRevalidateLoader(loaderMatch, arg) {</span><span class="s2">\n  </span><span class="s1">if (loaderMatch.route.shouldRevalidate) {</span><span class="s2">\n    </span><span class="s1">let routeChoice = loaderMatch.route.shouldRevalidate(arg);</span><span class="s2">\n    </span><span class="s1">if (typeof routeChoice === </span><span class="s2">\&quot;</span><span class="s1">boolean</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">return routeChoice;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return arg.defaultShouldRevalidate;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function patchRoutesImpl(routeId, children, routesToUse, manifest, mapRouteProperties2) {</span><span class="s2">\n  </span><span class="s1">let childrenToPatch;</span><span class="s2">\n  </span><span class="s1">if (routeId) {</span><span class="s2">\n    </span><span class="s1">let route = manifest[routeId];</span><span class="s2">\n    </span><span class="s1">invariant(route, `No route found to patch children into: routeId = ${routeId}`);</span><span class="s2">\n    </span><span class="s1">if (!route.children) {</span><span class="s2">\n      </span><span class="s1">route.children = [];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">childrenToPatch = route.children;</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">childrenToPatch = routesToUse;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let uniqueChildren = children.filter(newRoute =&gt; !childrenToPatch.some(existingRoute =&gt; isSameRoute(newRoute, existingRoute)));</span><span class="s2">\n  </span><span class="s1">let newRoutes = convertRoutesToDataRoutes(uniqueChildren, mapRouteProperties2, [routeId || </span><span class="s2">\&quot;</span><span class="s1">_</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">patch</span><span class="s2">\&quot;</span><span class="s1">, String(childrenToPatch?.length || </span><span class="s2">\&quot;</span><span class="s1">0</span><span class="s2">\&quot;</span><span class="s1">)], manifest);</span><span class="s2">\n  </span><span class="s1">childrenToPatch.push(...newRoutes);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isSameRoute(newRoute, existingRoute) {</span><span class="s2">\n  </span><span class="s1">if (</span><span class="s2">\&quot;</span><span class="s1">id</span><span class="s2">\&quot; </span><span class="s1">in newRoute &amp;&amp; </span><span class="s2">\&quot;</span><span class="s1">id</span><span class="s2">\&quot; </span><span class="s1">in existingRoute &amp;&amp; newRoute.id === existingRoute.id) {</span><span class="s2">\n    </span><span class="s1">return true;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (!(newRoute.index === existingRoute.index &amp;&amp; newRoute.path === existingRoute.path &amp;&amp; newRoute.caseSensitive === existingRoute.caseSensitive)) {</span><span class="s2">\n    </span><span class="s1">return false;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if ((!newRoute.children || newRoute.children.length === 0) &amp;&amp; (!existingRoute.children || existingRoute.children.length === 0)) {</span><span class="s2">\n    </span><span class="s1">return true;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return newRoute.children.every((aChild, i) =&gt; existingRoute.children?.some(bChild =&gt; isSameRoute(aChild, bChild)));</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var lazyRoutePropertyCache = /* @__PURE__ */new WeakMap();</span><span class="s2">\n</span><span class="s1">var loadLazyRouteProperty = ({</span><span class="s2">\n  </span><span class="s1">key,</span><span class="s2">\n  </span><span class="s1">route,</span><span class="s2">\n  </span><span class="s1">manifest,</span><span class="s2">\n  </span><span class="s1">mapRouteProperties: mapRouteProperties2</span><span class="s2">\n</span><span class="s1">}) =&gt; {</span><span class="s2">\n  </span><span class="s1">let routeToUpdate = manifest[route.id];</span><span class="s2">\n  </span><span class="s1">invariant(routeToUpdate, </span><span class="s2">\&quot;</span><span class="s1">No route found in manifest</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">if (!routeToUpdate.lazy || typeof routeToUpdate.lazy !== </span><span class="s2">\&quot;</span><span class="s1">object</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">return;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let lazyFn = routeToUpdate.lazy[key];</span><span class="s2">\n  </span><span class="s1">if (!lazyFn) {</span><span class="s2">\n    </span><span class="s1">return;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let cache = lazyRoutePropertyCache.get(routeToUpdate);</span><span class="s2">\n  </span><span class="s1">if (!cache) {</span><span class="s2">\n    </span><span class="s1">cache = {};</span><span class="s2">\n    </span><span class="s1">lazyRoutePropertyCache.set(routeToUpdate, cache);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let cachedPromise = cache[key];</span><span class="s2">\n  </span><span class="s1">if (cachedPromise) {</span><span class="s2">\n    </span><span class="s1">return cachedPromise;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let propertyPromise = (async () =&gt; {</span><span class="s2">\n    </span><span class="s1">let isUnsupported = isUnsupportedLazyRouteObjectKey(key);</span><span class="s2">\n    </span><span class="s1">let staticRouteValue = routeToUpdate[key];</span><span class="s2">\n    </span><span class="s1">let isStaticallyDefined = staticRouteValue !== void 0 &amp;&amp; key !== </span><span class="s2">\&quot;</span><span class="s1">hasErrorBoundary</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">if (isUnsupported) {</span><span class="s2">\n      </span><span class="s1">warning(!isUnsupported, </span><span class="s2">\&quot;</span><span class="s1">Route property </span><span class="s2">\&quot; </span><span class="s1">+ key + </span><span class="s2">\&quot; </span><span class="s1">is not a supported lazy route property. This property will be ignored.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">cache[key] = Promise.resolve();</span><span class="s2">\n    </span><span class="s1">} else if (isStaticallyDefined) {</span><span class="s2">\n      </span><span class="s1">warning(false, `Route </span><span class="s2">\&quot;</span><span class="s1">${routeToUpdate.id}</span><span class="s2">\&quot; </span><span class="s1">has a static property </span><span class="s2">\&quot;</span><span class="s1">${key}</span><span class="s2">\&quot; </span><span class="s1">defined. The lazy property will be ignored.`);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">let value = await lazyFn();</span><span class="s2">\n      </span><span class="s1">if (value != null) {</span><span class="s2">\n        </span><span class="s1">Object.assign(routeToUpdate, {</span><span class="s2">\n          </span><span class="s1">[key]: value</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">Object.assign(routeToUpdate, mapRouteProperties2(routeToUpdate));</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (typeof routeToUpdate.lazy === </span><span class="s2">\&quot;</span><span class="s1">object</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">routeToUpdate.lazy[key] = void 0;</span><span class="s2">\n      </span><span class="s1">if (Object.values(routeToUpdate.lazy).every(value =&gt; value === void 0)) {</span><span class="s2">\n        </span><span class="s1">routeToUpdate.lazy = void 0;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">})();</span><span class="s2">\n  </span><span class="s1">cache[key] = propertyPromise;</span><span class="s2">\n  </span><span class="s1">return propertyPromise;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">var lazyRouteFunctionCache = /* @__PURE__ */new WeakMap();</span><span class="s2">\n</span><span class="s1">function loadLazyRoute(route, type, manifest, mapRouteProperties2, lazyRoutePropertiesToSkip) {</span><span class="s2">\n  </span><span class="s1">let routeToUpdate = manifest[route.id];</span><span class="s2">\n  </span><span class="s1">invariant(routeToUpdate, </span><span class="s2">\&quot;</span><span class="s1">No route found in manifest</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">if (!route.lazy) {</span><span class="s2">\n    </span><span class="s1">return {</span><span class="s2">\n      </span><span class="s1">lazyRoutePromise: void 0,</span><span class="s2">\n      </span><span class="s1">lazyHandlerPromise: void 0</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (typeof route.lazy === </span><span class="s2">\&quot;</span><span class="s1">function</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">let cachedPromise = lazyRouteFunctionCache.get(routeToUpdate);</span><span class="s2">\n    </span><span class="s1">if (cachedPromise) {</span><span class="s2">\n      </span><span class="s1">return {</span><span class="s2">\n        </span><span class="s1">lazyRoutePromise: cachedPromise,</span><span class="s2">\n        </span><span class="s1">lazyHandlerPromise: cachedPromise</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let lazyRoutePromise2 = (async () =&gt; {</span><span class="s2">\n      </span><span class="s1">invariant(typeof route.lazy === </span><span class="s2">\&quot;</span><span class="s1">function</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">No lazy route function found</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">let lazyRoute = await route.lazy();</span><span class="s2">\n      </span><span class="s1">let routeUpdates = {};</span><span class="s2">\n      </span><span class="s1">for (let lazyRouteProperty in lazyRoute) {</span><span class="s2">\n        </span><span class="s1">let lazyValue = lazyRoute[lazyRouteProperty];</span><span class="s2">\n        </span><span class="s1">if (lazyValue === void 0) {</span><span class="s2">\n          </span><span class="s1">continue;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">let isUnsupported = isUnsupportedLazyRouteFunctionKey(lazyRouteProperty);</span><span class="s2">\n        </span><span class="s1">let staticRouteValue = routeToUpdate[lazyRouteProperty];</span><span class="s2">\n        </span><span class="s1">let isStaticallyDefined = staticRouteValue !== void 0 &amp;&amp;</span><span class="s2">\n        </span><span class="s1">// This property isn't static since it should always be updated based</span><span class="s2">\n        </span><span class="s1">// on the route updates</span><span class="s2">\n        </span><span class="s1">lazyRouteProperty !== </span><span class="s2">\&quot;</span><span class="s1">hasErrorBoundary</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n        </span><span class="s1">if (isUnsupported) {</span><span class="s2">\n          </span><span class="s1">warning(!isUnsupported, </span><span class="s2">\&quot;</span><span class="s1">Route property </span><span class="s2">\&quot; </span><span class="s1">+ lazyRouteProperty + </span><span class="s2">\&quot; </span><span class="s1">is not a supported property to be returned from a lazy route function. This property will be ignored.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">} else if (isStaticallyDefined) {</span><span class="s2">\n          </span><span class="s1">warning(!isStaticallyDefined, `Route </span><span class="s2">\&quot;</span><span class="s1">${routeToUpdate.id}</span><span class="s2">\&quot; </span><span class="s1">has a static property </span><span class="s2">\&quot;</span><span class="s1">${lazyRouteProperty}</span><span class="s2">\&quot; </span><span class="s1">defined but its lazy function is also returning a value for this property. The lazy route property </span><span class="s2">\&quot;</span><span class="s1">${lazyRouteProperty}</span><span class="s2">\&quot; </span><span class="s1">will be ignored.`);</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">routeUpdates[lazyRouteProperty] = lazyValue;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">Object.assign(routeToUpdate, routeUpdates);</span><span class="s2">\n      </span><span class="s1">Object.assign(routeToUpdate, {</span><span class="s2">\n        </span><span class="s1">// To keep things framework agnostic, we use the provided `mapRouteProperties`</span><span class="s2">\n        </span><span class="s1">// function to set the framework-aware properties (`element`/`hasErrorBoundary`)</span><span class="s2">\n        </span><span class="s1">// since the logic will differ between frameworks.</span><span class="s2">\n        </span><span class="s1">...mapRouteProperties2(routeToUpdate),</span><span class="s2">\n        </span><span class="s1">lazy: void 0</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">})();</span><span class="s2">\n    </span><span class="s1">lazyRouteFunctionCache.set(routeToUpdate, lazyRoutePromise2);</span><span class="s2">\n    </span><span class="s1">lazyRoutePromise2.catch(() =&gt; {});</span><span class="s2">\n    </span><span class="s1">return {</span><span class="s2">\n      </span><span class="s1">lazyRoutePromise: lazyRoutePromise2,</span><span class="s2">\n      </span><span class="s1">lazyHandlerPromise: lazyRoutePromise2</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let lazyKeys = Object.keys(route.lazy);</span><span class="s2">\n  </span><span class="s1">let lazyPropertyPromises = [];</span><span class="s2">\n  </span><span class="s1">let lazyHandlerPromise = void 0;</span><span class="s2">\n  </span><span class="s1">for (let key of lazyKeys) {</span><span class="s2">\n    </span><span class="s1">if (lazyRoutePropertiesToSkip &amp;&amp; lazyRoutePropertiesToSkip.includes(key)) {</span><span class="s2">\n      </span><span class="s1">continue;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let promise = loadLazyRouteProperty({</span><span class="s2">\n      </span><span class="s1">key,</span><span class="s2">\n      </span><span class="s1">route,</span><span class="s2">\n      </span><span class="s1">manifest,</span><span class="s2">\n      </span><span class="s1">mapRouteProperties: mapRouteProperties2</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">if (promise) {</span><span class="s2">\n      </span><span class="s1">lazyPropertyPromises.push(promise);</span><span class="s2">\n      </span><span class="s1">if (key === type) {</span><span class="s2">\n        </span><span class="s1">lazyHandlerPromise = promise;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let lazyRoutePromise = lazyPropertyPromises.length &gt; 0 ? Promise.all(lazyPropertyPromises).then(() =&gt; {}) : void 0;</span><span class="s2">\n  </span><span class="s1">lazyRoutePromise?.catch(() =&gt; {});</span><span class="s2">\n  </span><span class="s1">lazyHandlerPromise?.catch(() =&gt; {});</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">lazyRoutePromise,</span><span class="s2">\n    </span><span class="s1">lazyHandlerPromise</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isNonNullable(value) {</span><span class="s2">\n  </span><span class="s1">return value !== void 0;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function loadLazyMiddlewareForMatches(matches, manifest, mapRouteProperties2) {</span><span class="s2">\n  </span><span class="s1">let promises = matches.map(({</span><span class="s2">\n    </span><span class="s1">route</span><span class="s2">\n  </span><span class="s1">}) =&gt; {</span><span class="s2">\n    </span><span class="s1">if (typeof route.lazy !== </span><span class="s2">\&quot;</span><span class="s1">object</span><span class="s2">\&quot; </span><span class="s1">|| !route.lazy.unstable_middleware) {</span><span class="s2">\n      </span><span class="s1">return void 0;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return loadLazyRouteProperty({</span><span class="s2">\n      </span><span class="s1">key: </span><span class="s2">\&quot;</span><span class="s1">unstable_middleware</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">route,</span><span class="s2">\n      </span><span class="s1">manifest,</span><span class="s2">\n      </span><span class="s1">mapRouteProperties: mapRouteProperties2</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}).filter(isNonNullable);</span><span class="s2">\n  </span><span class="s1">return promises.length &gt; 0 ? Promise.all(promises) : void 0;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">async function defaultDataStrategy(args) {</span><span class="s2">\n  </span><span class="s1">let matchesToLoad = args.matches.filter(m =&gt; m.shouldLoad);</span><span class="s2">\n  </span><span class="s1">let keyedResults = {};</span><span class="s2">\n  </span><span class="s1">let results = await Promise.all(matchesToLoad.map(m =&gt; m.resolve()));</span><span class="s2">\n  </span><span class="s1">results.forEach((result, i) =&gt; {</span><span class="s2">\n    </span><span class="s1">keyedResults[matchesToLoad[i].route.id] = result;</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">return keyedResults;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">async function defaultDataStrategyWithMiddleware(args) {</span><span class="s2">\n  </span><span class="s1">if (!args.matches.some(m =&gt; m.route.unstable_middleware)) {</span><span class="s2">\n    </span><span class="s1">return defaultDataStrategy(args);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return runMiddlewarePipeline(args, false, () =&gt; defaultDataStrategy(args), (error, routeId) =&gt; ({</span><span class="s2">\n    </span><span class="s1">[routeId]: {</span><span class="s2">\n      </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">error</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">result: error</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}));</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">async function runMiddlewarePipeline(args, propagateResult, handler, errorHandler) {</span><span class="s2">\n  </span><span class="s1">let {</span><span class="s2">\n    </span><span class="s1">matches,</span><span class="s2">\n    </span><span class="s1">request,</span><span class="s2">\n    </span><span class="s1">params,</span><span class="s2">\n    </span><span class="s1">context</span><span class="s2">\n  </span><span class="s1">} = args;</span><span class="s2">\n  </span><span class="s1">let middlewareState = {</span><span class="s2">\n    </span><span class="s1">handlerResult: void 0</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">try {</span><span class="s2">\n    </span><span class="s1">let tuples = matches.flatMap(m =&gt; m.route.unstable_middleware ? m.route.unstable_middleware.map(fn =&gt; [m.route.id, fn]) : []);</span><span class="s2">\n    </span><span class="s1">let result = await callRouteMiddleware({</span><span class="s2">\n      </span><span class="s1">request,</span><span class="s2">\n      </span><span class="s1">params,</span><span class="s2">\n      </span><span class="s1">context</span><span class="s2">\n    </span><span class="s1">}, tuples, propagateResult, middlewareState, handler);</span><span class="s2">\n    </span><span class="s1">return propagateResult ? result : middlewareState.handlerResult;</span><span class="s2">\n  </span><span class="s1">} catch (e) {</span><span class="s2">\n    </span><span class="s1">if (!middlewareState.middlewareError) {</span><span class="s2">\n      </span><span class="s1">throw e;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let result = await errorHandler(middlewareState.middlewareError.error, middlewareState.middlewareError.routeId);</span><span class="s2">\n    </span><span class="s1">if (propagateResult || !middlewareState.handlerResult) {</span><span class="s2">\n      </span><span class="s1">return result;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return Object.assign(middlewareState.handlerResult, result);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">async function callRouteMiddleware(args, middlewares, propagateResult, middlewareState, handler, idx = 0) {</span><span class="s2">\n  </span><span class="s1">let {</span><span class="s2">\n    </span><span class="s1">request</span><span class="s2">\n  </span><span class="s1">} = args;</span><span class="s2">\n  </span><span class="s1">if (request.signal.aborted) {</span><span class="s2">\n    </span><span class="s1">if (request.signal.reason) {</span><span class="s2">\n      </span><span class="s1">throw request.signal.reason;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">throw new Error(`Request aborted without an </span><span class="s2">\\</span><span class="s1">`AbortSignal.reason</span><span class="s2">\\</span><span class="s1">`: ${request.method} ${request.url}`);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let tuple = middlewares[idx];</span><span class="s2">\n  </span><span class="s1">if (!tuple) {</span><span class="s2">\n    </span><span class="s1">middlewareState.handlerResult = await handler();</span><span class="s2">\n    </span><span class="s1">return middlewareState.handlerResult;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let [routeId, middleware] = tuple;</span><span class="s2">\n  </span><span class="s1">let nextCalled = false;</span><span class="s2">\n  </span><span class="s1">let nextResult = void 0;</span><span class="s2">\n  </span><span class="s1">let next = async () =&gt; {</span><span class="s2">\n    </span><span class="s1">if (nextCalled) {</span><span class="s2">\n      </span><span class="s1">throw new Error(</span><span class="s2">\&quot;</span><span class="s1">You may only call `next()` once per middleware</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">nextCalled = true;</span><span class="s2">\n    </span><span class="s1">let result = await callRouteMiddleware(args, middlewares, propagateResult, middlewareState, handler, idx + 1);</span><span class="s2">\n    </span><span class="s1">if (propagateResult) {</span><span class="s2">\n      </span><span class="s1">nextResult = result;</span><span class="s2">\n      </span><span class="s1">return nextResult;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">try {</span><span class="s2">\n    </span><span class="s1">let result = await middleware({</span><span class="s2">\n      </span><span class="s1">request: args.request,</span><span class="s2">\n      </span><span class="s1">params: args.params,</span><span class="s2">\n      </span><span class="s1">context: args.context</span><span class="s2">\n    </span><span class="s1">}, next);</span><span class="s2">\n    </span><span class="s1">if (nextCalled) {</span><span class="s2">\n      </span><span class="s1">if (result === void 0) {</span><span class="s2">\n        </span><span class="s1">return nextResult;</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">return result;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">return next();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">} catch (error) {</span><span class="s2">\n    </span><span class="s1">if (!middlewareState.middlewareError) {</span><span class="s2">\n      </span><span class="s1">middlewareState.middlewareError = {</span><span class="s2">\n        </span><span class="s1">routeId,</span><span class="s2">\n        </span><span class="s1">error</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">} else if (middlewareState.middlewareError.error !== error) {</span><span class="s2">\n      </span><span class="s1">middlewareState.middlewareError = {</span><span class="s2">\n        </span><span class="s1">routeId,</span><span class="s2">\n        </span><span class="s1">error</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">throw error;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getDataStrategyMatchLazyPromises(mapRouteProperties2, manifest, request, match, lazyRoutePropertiesToSkip) {</span><span class="s2">\n  </span><span class="s1">let lazyMiddlewarePromise = loadLazyRouteProperty({</span><span class="s2">\n    </span><span class="s1">key: </span><span class="s2">\&quot;</span><span class="s1">unstable_middleware</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">route: match.route,</span><span class="s2">\n    </span><span class="s1">manifest,</span><span class="s2">\n    </span><span class="s1">mapRouteProperties: mapRouteProperties2</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">let lazyRoutePromises = loadLazyRoute(match.route, isMutationMethod(request.method) ? </span><span class="s2">\&quot;</span><span class="s1">action</span><span class="s2">\&quot; </span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">loader</span><span class="s2">\&quot;</span><span class="s1">, manifest, mapRouteProperties2, lazyRoutePropertiesToSkip);</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">middleware: lazyMiddlewarePromise,</span><span class="s2">\n    </span><span class="s1">route: lazyRoutePromises.lazyRoutePromise,</span><span class="s2">\n    </span><span class="s1">handler: lazyRoutePromises.lazyHandlerPromise</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getDataStrategyMatch(mapRouteProperties2, manifest, request, match, lazyRoutePropertiesToSkip, scopedContext, shouldLoad, unstable_shouldRevalidateArgs = null) {</span><span class="s2">\n  </span><span class="s1">let isUsingNewApi = false;</span><span class="s2">\n  </span><span class="s1">let _lazyPromises = getDataStrategyMatchLazyPromises(mapRouteProperties2, manifest, request, match, lazyRoutePropertiesToSkip);</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">...match,</span><span class="s2">\n    </span><span class="s1">_lazyPromises,</span><span class="s2">\n    </span><span class="s1">shouldLoad,</span><span class="s2">\n    </span><span class="s1">unstable_shouldRevalidateArgs,</span><span class="s2">\n    </span><span class="s1">unstable_shouldCallHandler(defaultShouldRevalidate) {</span><span class="s2">\n      </span><span class="s1">isUsingNewApi = true;</span><span class="s2">\n      </span><span class="s1">if (!unstable_shouldRevalidateArgs) {</span><span class="s2">\n        </span><span class="s1">return shouldLoad;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (typeof defaultShouldRevalidate === </span><span class="s2">\&quot;</span><span class="s1">boolean</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">return shouldRevalidateLoader(match, {</span><span class="s2">\n          </span><span class="s1">...unstable_shouldRevalidateArgs,</span><span class="s2">\n          </span><span class="s1">defaultShouldRevalidate</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return shouldRevalidateLoader(match, unstable_shouldRevalidateArgs);</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">resolve(handlerOverride) {</span><span class="s2">\n      </span><span class="s1">if (isUsingNewApi || shouldLoad || handlerOverride &amp;&amp; request.method === </span><span class="s2">\&quot;</span><span class="s1">GET</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; (match.route.lazy || match.route.loader)) {</span><span class="s2">\n        </span><span class="s1">return callLoaderOrAction({</span><span class="s2">\n          </span><span class="s1">request,</span><span class="s2">\n          </span><span class="s1">match,</span><span class="s2">\n          </span><span class="s1">lazyHandlerPromise: _lazyPromises?.handler,</span><span class="s2">\n          </span><span class="s1">lazyRoutePromise: _lazyPromises?.route,</span><span class="s2">\n          </span><span class="s1">handlerOverride,</span><span class="s2">\n          </span><span class="s1">scopedContext</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return Promise.resolve({</span><span class="s2">\n        </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">data</span><span class="s2">\&quot; </span><span class="s1">/* data */,</span><span class="s2">\n        </span><span class="s1">result: void 0</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getTargetedDataStrategyMatches(mapRouteProperties2, manifest, request, matches, targetMatch, lazyRoutePropertiesToSkip, scopedContext, shouldRevalidateArgs = null) {</span><span class="s2">\n  </span><span class="s1">return matches.map(match =&gt; {</span><span class="s2">\n    </span><span class="s1">if (match.route.id !== targetMatch.route.id) {</span><span class="s2">\n      </span><span class="s1">return {</span><span class="s2">\n        </span><span class="s1">...match,</span><span class="s2">\n        </span><span class="s1">shouldLoad: false,</span><span class="s2">\n        </span><span class="s1">unstable_shouldRevalidateArgs: shouldRevalidateArgs,</span><span class="s2">\n        </span><span class="s1">unstable_shouldCallHandler: () =&gt; false,</span><span class="s2">\n        </span><span class="s1">_lazyPromises: getDataStrategyMatchLazyPromises(mapRouteProperties2, manifest, request, match, lazyRoutePropertiesToSkip),</span><span class="s2">\n        </span><span class="s1">resolve: () =&gt; Promise.resolve({</span><span class="s2">\n          </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">data</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n          </span><span class="s1">result: void 0</span><span class="s2">\n        </span><span class="s1">})</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return getDataStrategyMatch(mapRouteProperties2, manifest, request, match, lazyRoutePropertiesToSkip, scopedContext, true, shouldRevalidateArgs);</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">async function callDataStrategyImpl(dataStrategyImpl, request, matches, fetcherKey, scopedContext, isStaticHandler) {</span><span class="s2">\n  </span><span class="s1">if (matches.some(m =&gt; m._lazyPromises?.middleware)) {</span><span class="s2">\n    </span><span class="s1">await Promise.all(matches.map(m =&gt; m._lazyPromises?.middleware));</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let dataStrategyArgs = {</span><span class="s2">\n    </span><span class="s1">request,</span><span class="s2">\n    </span><span class="s1">params: matches[0].params,</span><span class="s2">\n    </span><span class="s1">context: scopedContext,</span><span class="s2">\n    </span><span class="s1">matches</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">let unstable_runClientMiddleware = isStaticHandler ? () =&gt; {</span><span class="s2">\n    </span><span class="s1">throw new Error(</span><span class="s2">\&quot;</span><span class="s1">You cannot call `unstable_runClientMiddleware()` from a static handler `dataStrategy`. Middleware is run outside of `dataStrategy` during SSR in order to bubble up the Response.  You can enable middleware via the `respond` API in `query`/`queryRoute`</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">} : cb =&gt; {</span><span class="s2">\n    </span><span class="s1">let typedDataStrategyArgs = dataStrategyArgs;</span><span class="s2">\n    </span><span class="s1">return runMiddlewarePipeline(typedDataStrategyArgs, false, () =&gt; cb({</span><span class="s2">\n      </span><span class="s1">...typedDataStrategyArgs,</span><span class="s2">\n      </span><span class="s1">fetcherKey,</span><span class="s2">\n      </span><span class="s1">unstable_runClientMiddleware: () =&gt; {</span><span class="s2">\n        </span><span class="s1">throw new Error(</span><span class="s2">\&quot;</span><span class="s1">Cannot call `unstable_runClientMiddleware()` from within an `unstable_runClientMiddleware` handler</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}), (error, routeId) =&gt; ({</span><span class="s2">\n      </span><span class="s1">[routeId]: {</span><span class="s2">\n        </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">error</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        </span><span class="s1">result: error</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}));</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">let results = await dataStrategyImpl({</span><span class="s2">\n    </span><span class="s1">...dataStrategyArgs,</span><span class="s2">\n    </span><span class="s1">fetcherKey,</span><span class="s2">\n    </span><span class="s1">unstable_runClientMiddleware</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">try {</span><span class="s2">\n    </span><span class="s1">await Promise.all(matches.flatMap(m =&gt; [m._lazyPromises?.handler, m._lazyPromises?.route]));</span><span class="s2">\n  </span><span class="s1">} catch (e) {}</span><span class="s2">\n  </span><span class="s1">return results;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">async function callLoaderOrAction({</span><span class="s2">\n  </span><span class="s1">request,</span><span class="s2">\n  </span><span class="s1">match,</span><span class="s2">\n  </span><span class="s1">lazyHandlerPromise,</span><span class="s2">\n  </span><span class="s1">lazyRoutePromise,</span><span class="s2">\n  </span><span class="s1">handlerOverride,</span><span class="s2">\n  </span><span class="s1">scopedContext</span><span class="s2">\n</span><span class="s1">}) {</span><span class="s2">\n  </span><span class="s1">let result;</span><span class="s2">\n  </span><span class="s1">let onReject;</span><span class="s2">\n  </span><span class="s1">let isAction = isMutationMethod(request.method);</span><span class="s2">\n  </span><span class="s1">let type = isAction ? </span><span class="s2">\&quot;</span><span class="s1">action</span><span class="s2">\&quot; </span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">loader</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">let runHandler = handler =&gt; {</span><span class="s2">\n    </span><span class="s1">let reject;</span><span class="s2">\n    </span><span class="s1">let abortPromise = new Promise((_, r) =&gt; reject = r);</span><span class="s2">\n    </span><span class="s1">onReject = () =&gt; reject();</span><span class="s2">\n    </span><span class="s1">request.signal.addEventListener(</span><span class="s2">\&quot;</span><span class="s1">abort</span><span class="s2">\&quot;</span><span class="s1">, onReject);</span><span class="s2">\n    </span><span class="s1">let actualHandler = ctx =&gt; {</span><span class="s2">\n      </span><span class="s1">if (typeof handler !== </span><span class="s2">\&quot;</span><span class="s1">function</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">return Promise.reject(new Error(`You cannot call the handler for a route which defines a boolean </span><span class="s2">\&quot;</span><span class="s1">${type}</span><span class="s2">\&quot; </span><span class="s1">[routeId: ${match.route.id}]`));</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return handler({</span><span class="s2">\n        </span><span class="s1">request,</span><span class="s2">\n        </span><span class="s1">params: match.params,</span><span class="s2">\n        </span><span class="s1">context: scopedContext</span><span class="s2">\n      </span><span class="s1">}, ...(ctx !== void 0 ? [ctx] : []));</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">let handlerPromise = (async () =&gt; {</span><span class="s2">\n      </span><span class="s1">try {</span><span class="s2">\n        </span><span class="s1">let val = await (handlerOverride ? handlerOverride(ctx =&gt; actualHandler(ctx)) : actualHandler());</span><span class="s2">\n        </span><span class="s1">return {</span><span class="s2">\n          </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">data</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n          </span><span class="s1">result: val</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">} catch (e) {</span><span class="s2">\n        </span><span class="s1">return {</span><span class="s2">\n          </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">error</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n          </span><span class="s1">result: e</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">})();</span><span class="s2">\n    </span><span class="s1">return Promise.race([handlerPromise, abortPromise]);</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">try {</span><span class="s2">\n    </span><span class="s1">let handler = isAction ? match.route.action : match.route.loader;</span><span class="s2">\n    </span><span class="s1">if (lazyHandlerPromise || lazyRoutePromise) {</span><span class="s2">\n      </span><span class="s1">if (handler) {</span><span class="s2">\n        </span><span class="s1">let handlerError;</span><span class="s2">\n        </span><span class="s1">let [value] = await Promise.all([</span><span class="s2">\n        </span><span class="s1">// If the handler throws, don't let it immediately bubble out,</span><span class="s2">\n        </span><span class="s1">// since we need to let the lazy() execution finish so we know if this</span><span class="s2">\n        </span><span class="s1">// route has a boundary that can handle the error</span><span class="s2">\n        </span><span class="s1">runHandler(handler).catch(e =&gt; {</span><span class="s2">\n          </span><span class="s1">handlerError = e;</span><span class="s2">\n        </span><span class="s1">}),</span><span class="s2">\n        </span><span class="s1">// Ensure all lazy route promises are resolved before continuing</span><span class="s2">\n        </span><span class="s1">lazyHandlerPromise, lazyRoutePromise]);</span><span class="s2">\n        </span><span class="s1">if (handlerError !== void 0) {</span><span class="s2">\n          </span><span class="s1">throw handlerError;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">result = value;</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">await lazyHandlerPromise;</span><span class="s2">\n        </span><span class="s1">let handler2 = isAction ? match.route.action : match.route.loader;</span><span class="s2">\n        </span><span class="s1">if (handler2) {</span><span class="s2">\n          </span><span class="s1">[result] = await Promise.all([runHandler(handler2), lazyRoutePromise]);</span><span class="s2">\n        </span><span class="s1">} else if (type === </span><span class="s2">\&quot;</span><span class="s1">action</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">let url = new URL(request.url);</span><span class="s2">\n          </span><span class="s1">let pathname = url.pathname + url.search;</span><span class="s2">\n          </span><span class="s1">throw getInternalRouterError(405, {</span><span class="s2">\n            </span><span class="s1">method: request.method,</span><span class="s2">\n            </span><span class="s1">pathname,</span><span class="s2">\n            </span><span class="s1">routeId: match.route.id</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">return {</span><span class="s2">\n            </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">data</span><span class="s2">\&quot; </span><span class="s1">/* data */,</span><span class="s2">\n            </span><span class="s1">result: void 0</span><span class="s2">\n          </span><span class="s1">};</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else if (!handler) {</span><span class="s2">\n      </span><span class="s1">let url = new URL(request.url);</span><span class="s2">\n      </span><span class="s1">let pathname = url.pathname + url.search;</span><span class="s2">\n      </span><span class="s1">throw getInternalRouterError(404, {</span><span class="s2">\n        </span><span class="s1">pathname</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">result = await runHandler(handler);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">} catch (e) {</span><span class="s2">\n    </span><span class="s1">return {</span><span class="s2">\n      </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">error</span><span class="s2">\&quot; </span><span class="s1">/* error */,</span><span class="s2">\n      </span><span class="s1">result: e</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">} finally {</span><span class="s2">\n    </span><span class="s1">if (onReject) {</span><span class="s2">\n      </span><span class="s1">request.signal.removeEventListener(</span><span class="s2">\&quot;</span><span class="s1">abort</span><span class="s2">\&quot;</span><span class="s1">, onReject);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return result;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">async function convertDataStrategyResultToDataResult(dataStrategyResult) {</span><span class="s2">\n  </span><span class="s1">let {</span><span class="s2">\n    </span><span class="s1">result,</span><span class="s2">\n    </span><span class="s1">type</span><span class="s2">\n  </span><span class="s1">} = dataStrategyResult;</span><span class="s2">\n  </span><span class="s1">if (isResponse(result)) {</span><span class="s2">\n    </span><span class="s1">let data2;</span><span class="s2">\n    </span><span class="s1">try {</span><span class="s2">\n      </span><span class="s1">let contentType = result.headers.get(</span><span class="s2">\&quot;</span><span class="s1">Content-Type</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">if (contentType &amp;&amp; /</span><span class="s2">\\</span><span class="s1">bapplication</span><span class="s2">\\</span><span class="s1">/json</span><span class="s2">\\</span><span class="s1">b/.test(contentType)) {</span><span class="s2">\n        </span><span class="s1">if (result.body == null) {</span><span class="s2">\n          </span><span class="s1">data2 = null;</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">data2 = await result.json();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">data2 = await result.text();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} catch (e) {</span><span class="s2">\n      </span><span class="s1">return {</span><span class="s2">\n        </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">error</span><span class="s2">\&quot; </span><span class="s1">/* error */,</span><span class="s2">\n        </span><span class="s1">error: e</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (type === </span><span class="s2">\&quot;</span><span class="s1">error</span><span class="s2">\&quot; </span><span class="s1">/* error */) {</span><span class="s2">\n      </span><span class="s1">return {</span><span class="s2">\n        </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">error</span><span class="s2">\&quot; </span><span class="s1">/* error */,</span><span class="s2">\n        </span><span class="s1">error: new ErrorResponseImpl(result.status, result.statusText, data2),</span><span class="s2">\n        </span><span class="s1">statusCode: result.status,</span><span class="s2">\n        </span><span class="s1">headers: result.headers</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return {</span><span class="s2">\n      </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">data</span><span class="s2">\&quot; </span><span class="s1">/* data */,</span><span class="s2">\n      </span><span class="s1">data: data2,</span><span class="s2">\n      </span><span class="s1">statusCode: result.status,</span><span class="s2">\n      </span><span class="s1">headers: result.headers</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (type === </span><span class="s2">\&quot;</span><span class="s1">error</span><span class="s2">\&quot; </span><span class="s1">/* error */) {</span><span class="s2">\n    </span><span class="s1">if (isDataWithResponseInit(result)) {</span><span class="s2">\n      </span><span class="s1">if (result.data instanceof Error) {</span><span class="s2">\n        </span><span class="s1">return {</span><span class="s2">\n          </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">error</span><span class="s2">\&quot; </span><span class="s1">/* error */,</span><span class="s2">\n          </span><span class="s1">error: result.data,</span><span class="s2">\n          </span><span class="s1">statusCode: result.init?.status,</span><span class="s2">\n          </span><span class="s1">headers: result.init?.headers ? new Headers(result.init.headers) : void 0</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return {</span><span class="s2">\n        </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">error</span><span class="s2">\&quot; </span><span class="s1">/* error */,</span><span class="s2">\n        </span><span class="s1">error: new ErrorResponseImpl(result.init?.status || 500, void 0, result.data),</span><span class="s2">\n        </span><span class="s1">statusCode: isRouteErrorResponse(result) ? result.status : void 0,</span><span class="s2">\n        </span><span class="s1">headers: result.init?.headers ? new Headers(result.init.headers) : void 0</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return {</span><span class="s2">\n      </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">error</span><span class="s2">\&quot; </span><span class="s1">/* error */,</span><span class="s2">\n      </span><span class="s1">error: result,</span><span class="s2">\n      </span><span class="s1">statusCode: isRouteErrorResponse(result) ? result.status : void 0</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (isDataWithResponseInit(result)) {</span><span class="s2">\n    </span><span class="s1">return {</span><span class="s2">\n      </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">data</span><span class="s2">\&quot; </span><span class="s1">/* data */,</span><span class="s2">\n      </span><span class="s1">data: result.data,</span><span class="s2">\n      </span><span class="s1">statusCode: result.init?.status,</span><span class="s2">\n      </span><span class="s1">headers: result.init?.headers ? new Headers(result.init.headers) : void 0</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">data</span><span class="s2">\&quot; </span><span class="s1">/* data */,</span><span class="s2">\n    </span><span class="s1">data: result</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function normalizeRelativeRoutingRedirectResponse(response, request, routeId, matches, basename) {</span><span class="s2">\n  </span><span class="s1">let location = response.headers.get(</span><span class="s2">\&quot;</span><span class="s1">Location</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">invariant(location, </span><span class="s2">\&quot;</span><span class="s1">Redirects returned/thrown from loaders/actions must have a Location header</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">if (!ABSOLUTE_URL_REGEX.test(location)) {</span><span class="s2">\n    </span><span class="s1">let trimmedMatches = matches.slice(0, matches.findIndex(m =&gt; m.route.id === routeId) + 1);</span><span class="s2">\n    </span><span class="s1">location = normalizeTo(new URL(request.url), trimmedMatches, basename, location);</span><span class="s2">\n    </span><span class="s1">response.headers.set(</span><span class="s2">\&quot;</span><span class="s1">Location</span><span class="s2">\&quot;</span><span class="s1">, location);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return response;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function normalizeRedirectLocation(location, currentUrl, basename) {</span><span class="s2">\n  </span><span class="s1">if (ABSOLUTE_URL_REGEX.test(location)) {</span><span class="s2">\n    </span><span class="s1">let normalizedLocation = location;</span><span class="s2">\n    </span><span class="s1">let url = normalizedLocation.startsWith(</span><span class="s2">\&quot;</span><span class="s1">//</span><span class="s2">\&quot;</span><span class="s1">) ? new URL(currentUrl.protocol + normalizedLocation) : new URL(normalizedLocation);</span><span class="s2">\n    </span><span class="s1">let isSameBasename = stripBasename(url.pathname, basename) != null;</span><span class="s2">\n    </span><span class="s1">if (url.origin === currentUrl.origin &amp;&amp; isSameBasename) {</span><span class="s2">\n      </span><span class="s1">return url.pathname + url.search + url.hash;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return location;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createClientSideRequest(history, location, signal, submission) {</span><span class="s2">\n  </span><span class="s1">let url = history.createURL(stripHashFromPath(location)).toString();</span><span class="s2">\n  </span><span class="s1">let init = {</span><span class="s2">\n    </span><span class="s1">signal</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">if (submission &amp;&amp; isMutationMethod(submission.formMethod)) {</span><span class="s2">\n    </span><span class="s1">let {</span><span class="s2">\n      </span><span class="s1">formMethod,</span><span class="s2">\n      </span><span class="s1">formEncType</span><span class="s2">\n    </span><span class="s1">} = submission;</span><span class="s2">\n    </span><span class="s1">init.method = formMethod.toUpperCase();</span><span class="s2">\n    </span><span class="s1">if (formEncType === </span><span class="s2">\&quot;</span><span class="s1">application/json</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">init.headers = new Headers({</span><span class="s2">\n        \&quot;</span><span class="s1">Content-Type</span><span class="s2">\&quot;</span><span class="s1">: formEncType</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">init.body = JSON.stringify(submission.json);</span><span class="s2">\n    </span><span class="s1">} else if (formEncType === </span><span class="s2">\&quot;</span><span class="s1">text/plain</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">init.body = submission.text;</span><span class="s2">\n    </span><span class="s1">} else if (formEncType === </span><span class="s2">\&quot;</span><span class="s1">application/x-www-form-urlencoded</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; submission.formData) {</span><span class="s2">\n      </span><span class="s1">init.body = convertFormDataToSearchParams(submission.formData);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">init.body = submission.formData;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return new Request(url, init);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function convertFormDataToSearchParams(formData) {</span><span class="s2">\n  </span><span class="s1">let searchParams = new URLSearchParams();</span><span class="s2">\n  </span><span class="s1">for (let [key, value] of formData.entries()) {</span><span class="s2">\n    </span><span class="s1">searchParams.append(key, typeof value === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">? value : value.name);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return searchParams;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function convertSearchParamsToFormData(searchParams) {</span><span class="s2">\n  </span><span class="s1">let formData = new FormData();</span><span class="s2">\n  </span><span class="s1">for (let [key, value] of searchParams.entries()) {</span><span class="s2">\n    </span><span class="s1">formData.append(key, value);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return formData;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function processRouteLoaderData(matches, results, pendingActionResult, isStaticHandler = false, skipLoaderErrorBubbling = false) {</span><span class="s2">\n  </span><span class="s1">let loaderData = {};</span><span class="s2">\n  </span><span class="s1">let errors = null;</span><span class="s2">\n  </span><span class="s1">let statusCode;</span><span class="s2">\n  </span><span class="s1">let foundError = false;</span><span class="s2">\n  </span><span class="s1">let loaderHeaders = {};</span><span class="s2">\n  </span><span class="s1">let pendingError = pendingActionResult &amp;&amp; isErrorResult(pendingActionResult[1]) ? pendingActionResult[1].error : void 0;</span><span class="s2">\n  </span><span class="s1">matches.forEach(match =&gt; {</span><span class="s2">\n    </span><span class="s1">if (!(match.route.id in results)) {</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let id = match.route.id;</span><span class="s2">\n    </span><span class="s1">let result = results[id];</span><span class="s2">\n    </span><span class="s1">invariant(!isRedirectResult(result), </span><span class="s2">\&quot;</span><span class="s1">Cannot handle redirect results in processLoaderData</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">if (isErrorResult(result)) {</span><span class="s2">\n      </span><span class="s1">let error = result.error;</span><span class="s2">\n      </span><span class="s1">if (pendingError !== void 0) {</span><span class="s2">\n        </span><span class="s1">error = pendingError;</span><span class="s2">\n        </span><span class="s1">pendingError = void 0;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">errors = errors || {};</span><span class="s2">\n      </span><span class="s1">if (skipLoaderErrorBubbling) {</span><span class="s2">\n        </span><span class="s1">errors[id] = error;</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">let boundaryMatch = findNearestBoundary(matches, id);</span><span class="s2">\n        </span><span class="s1">if (errors[boundaryMatch.route.id] == null) {</span><span class="s2">\n          </span><span class="s1">errors[boundaryMatch.route.id] = error;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (!isStaticHandler) {</span><span class="s2">\n        </span><span class="s1">loaderData[id] = ResetLoaderDataSymbol;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (!foundError) {</span><span class="s2">\n        </span><span class="s1">foundError = true;</span><span class="s2">\n        </span><span class="s1">statusCode = isRouteErrorResponse(result.error) ? result.error.status : 500;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (result.headers) {</span><span class="s2">\n        </span><span class="s1">loaderHeaders[id] = result.headers;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">loaderData[id] = result.data;</span><span class="s2">\n      </span><span class="s1">if (result.statusCode &amp;&amp; result.statusCode !== 200 &amp;&amp; !foundError) {</span><span class="s2">\n        </span><span class="s1">statusCode = result.statusCode;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (result.headers) {</span><span class="s2">\n        </span><span class="s1">loaderHeaders[id] = result.headers;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">if (pendingError !== void 0 &amp;&amp; pendingActionResult) {</span><span class="s2">\n    </span><span class="s1">errors = {</span><span class="s2">\n      </span><span class="s1">[pendingActionResult[0]]: pendingError</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">if (pendingActionResult[2]) {</span><span class="s2">\n      </span><span class="s1">loaderData[pendingActionResult[2]] = void 0;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">loaderData,</span><span class="s2">\n    </span><span class="s1">errors,</span><span class="s2">\n    </span><span class="s1">statusCode: statusCode || 200,</span><span class="s2">\n    </span><span class="s1">loaderHeaders</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function processLoaderData(state, matches, results, pendingActionResult, revalidatingFetchers, fetcherResults) {</span><span class="s2">\n  </span><span class="s1">let {</span><span class="s2">\n    </span><span class="s1">loaderData,</span><span class="s2">\n    </span><span class="s1">errors</span><span class="s2">\n  </span><span class="s1">} = processRouteLoaderData(matches, results, pendingActionResult);</span><span class="s2">\n  </span><span class="s1">revalidatingFetchers.filter(f =&gt; !f.matches || f.matches.some(m =&gt; m.shouldLoad)).forEach(rf =&gt; {</span><span class="s2">\n    </span><span class="s1">let {</span><span class="s2">\n      </span><span class="s1">key,</span><span class="s2">\n      </span><span class="s1">match,</span><span class="s2">\n      </span><span class="s1">controller</span><span class="s2">\n    </span><span class="s1">} = rf;</span><span class="s2">\n    </span><span class="s1">let result = fetcherResults[key];</span><span class="s2">\n    </span><span class="s1">invariant(result, </span><span class="s2">\&quot;</span><span class="s1">Did not find corresponding fetcher result</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">if (controller &amp;&amp; controller.signal.aborted) {</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">} else if (isErrorResult(result)) {</span><span class="s2">\n      </span><span class="s1">let boundaryMatch = findNearestBoundary(state.matches, match?.route.id);</span><span class="s2">\n      </span><span class="s1">if (!(errors &amp;&amp; errors[boundaryMatch.route.id])) {</span><span class="s2">\n        </span><span class="s1">errors = {</span><span class="s2">\n          </span><span class="s1">...errors,</span><span class="s2">\n          </span><span class="s1">[boundaryMatch.route.id]: result.error</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">state.fetchers.delete(key);</span><span class="s2">\n    </span><span class="s1">} else if (isRedirectResult(result)) {</span><span class="s2">\n      </span><span class="s1">invariant(false, </span><span class="s2">\&quot;</span><span class="s1">Unhandled fetcher revalidation redirect</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">let doneFetcher = getDoneFetcher(result.data);</span><span class="s2">\n      </span><span class="s1">state.fetchers.set(key, doneFetcher);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">loaderData,</span><span class="s2">\n    </span><span class="s1">errors</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function mergeLoaderData(loaderData, newLoaderData, matches, errors) {</span><span class="s2">\n  </span><span class="s1">let mergedLoaderData = Object.entries(newLoaderData).filter(([, v]) =&gt; v !== ResetLoaderDataSymbol).reduce((merged, [k, v]) =&gt; {</span><span class="s2">\n    </span><span class="s1">merged[k] = v;</span><span class="s2">\n    </span><span class="s1">return merged;</span><span class="s2">\n  </span><span class="s1">}, {});</span><span class="s2">\n  </span><span class="s1">for (let match of matches) {</span><span class="s2">\n    </span><span class="s1">let id = match.route.id;</span><span class="s2">\n    </span><span class="s1">if (!newLoaderData.hasOwnProperty(id) &amp;&amp; loaderData.hasOwnProperty(id) &amp;&amp; match.route.loader) {</span><span class="s2">\n      </span><span class="s1">mergedLoaderData[id] = loaderData[id];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (errors &amp;&amp; errors.hasOwnProperty(id)) {</span><span class="s2">\n      </span><span class="s1">break;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return mergedLoaderData;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getActionDataForCommit(pendingActionResult) {</span><span class="s2">\n  </span><span class="s1">if (!pendingActionResult) {</span><span class="s2">\n    </span><span class="s1">return {};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return isErrorResult(pendingActionResult[1]) ? {</span><span class="s2">\n    </span><span class="s1">// Clear out prior actionData on errors</span><span class="s2">\n    </span><span class="s1">actionData: {}</span><span class="s2">\n  </span><span class="s1">} : {</span><span class="s2">\n    </span><span class="s1">actionData: {</span><span class="s2">\n      </span><span class="s1">[pendingActionResult[0]]: pendingActionResult[1].data</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function findNearestBoundary(matches, routeId) {</span><span class="s2">\n  </span><span class="s1">let eligibleMatches = routeId ? matches.slice(0, matches.findIndex(m =&gt; m.route.id === routeId) + 1) : [...matches];</span><span class="s2">\n  </span><span class="s1">return eligibleMatches.reverse().find(m =&gt; m.route.hasErrorBoundary === true) || matches[0];</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getShortCircuitMatches(routes) {</span><span class="s2">\n  </span><span class="s1">let route = routes.length === 1 ? routes[0] : routes.find(r =&gt; r.index || !r.path || r.path === </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">) || {</span><span class="s2">\n    </span><span class="s1">id: `__shim-error-route__`</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">matches: [{</span><span class="s2">\n      </span><span class="s1">params: {},</span><span class="s2">\n      </span><span class="s1">pathname: </span><span class="s2">\&quot;\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">pathnameBase: </span><span class="s2">\&quot;\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">route</span><span class="s2">\n    </span><span class="s1">}],</span><span class="s2">\n    </span><span class="s1">route</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getInternalRouterError(status, {</span><span class="s2">\n  </span><span class="s1">pathname,</span><span class="s2">\n  </span><span class="s1">routeId,</span><span class="s2">\n  </span><span class="s1">method,</span><span class="s2">\n  </span><span class="s1">type,</span><span class="s2">\n  </span><span class="s1">message</span><span class="s2">\n</span><span class="s1">} = {}) {</span><span class="s2">\n  </span><span class="s1">let statusText = </span><span class="s2">\&quot;</span><span class="s1">Unknown Server Error</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">let errorMessage = </span><span class="s2">\&quot;</span><span class="s1">Unknown @remix-run/router error</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">if (status === 400) {</span><span class="s2">\n    </span><span class="s1">statusText = </span><span class="s2">\&quot;</span><span class="s1">Bad Request</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">if (method &amp;&amp; pathname &amp;&amp; routeId) {</span><span class="s2">\n      </span><span class="s1">errorMessage = `You made a ${method} request to </span><span class="s2">\&quot;</span><span class="s1">${pathname}</span><span class="s2">\&quot; </span><span class="s1">but did not provide a </span><span class="s2">\\</span><span class="s1">`loader</span><span class="s2">\\</span><span class="s1">` for route </span><span class="s2">\&quot;</span><span class="s1">${routeId}</span><span class="s2">\&quot;</span><span class="s1">, so there is no way to handle the request.`;</span><span class="s2">\n    </span><span class="s1">} else if (type === </span><span class="s2">\&quot;</span><span class="s1">invalid-body</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">errorMessage = </span><span class="s2">\&quot;</span><span class="s1">Unable to encode submission body</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">} else if (status === 403) {</span><span class="s2">\n    </span><span class="s1">statusText = </span><span class="s2">\&quot;</span><span class="s1">Forbidden</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">errorMessage = `Route </span><span class="s2">\&quot;</span><span class="s1">${routeId}</span><span class="s2">\&quot; </span><span class="s1">does not match URL </span><span class="s2">\&quot;</span><span class="s1">${pathname}</span><span class="s2">\&quot;</span><span class="s1">`;</span><span class="s2">\n  </span><span class="s1">} else if (status === 404) {</span><span class="s2">\n    </span><span class="s1">statusText = </span><span class="s2">\&quot;</span><span class="s1">Not Found</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">errorMessage = `No route matches URL </span><span class="s2">\&quot;</span><span class="s1">${pathname}</span><span class="s2">\&quot;</span><span class="s1">`;</span><span class="s2">\n  </span><span class="s1">} else if (status === 405) {</span><span class="s2">\n    </span><span class="s1">statusText = </span><span class="s2">\&quot;</span><span class="s1">Method Not Allowed</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">if (method &amp;&amp; pathname &amp;&amp; routeId) {</span><span class="s2">\n      </span><span class="s1">errorMessage = `You made a ${method.toUpperCase()} request to </span><span class="s2">\&quot;</span><span class="s1">${pathname}</span><span class="s2">\&quot; </span><span class="s1">but did not provide an </span><span class="s2">\\</span><span class="s1">`action</span><span class="s2">\\</span><span class="s1">` for route </span><span class="s2">\&quot;</span><span class="s1">${routeId}</span><span class="s2">\&quot;</span><span class="s1">, so there is no way to handle the request.`;</span><span class="s2">\n    </span><span class="s1">} else if (method) {</span><span class="s2">\n      </span><span class="s1">errorMessage = `Invalid request method </span><span class="s2">\&quot;</span><span class="s1">${method.toUpperCase()}</span><span class="s2">\&quot;</span><span class="s1">`;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return new ErrorResponseImpl(status || 500, statusText, new Error(errorMessage), true);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function findRedirect(results) {</span><span class="s2">\n  </span><span class="s1">let entries = Object.entries(results);</span><span class="s2">\n  </span><span class="s1">for (let i = entries.length - 1; i &gt;= 0; i--) {</span><span class="s2">\n    </span><span class="s1">let [key, result] = entries[i];</span><span class="s2">\n    </span><span class="s1">if (isRedirectResult(result)) {</span><span class="s2">\n      </span><span class="s1">return {</span><span class="s2">\n        </span><span class="s1">key,</span><span class="s2">\n        </span><span class="s1">result</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function stripHashFromPath(path) {</span><span class="s2">\n  </span><span class="s1">let parsedPath = typeof path === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">? parsePath(path) : path;</span><span class="s2">\n  </span><span class="s1">return createPath({</span><span class="s2">\n    </span><span class="s1">...parsedPath,</span><span class="s2">\n    </span><span class="s1">hash: </span><span class="s2">\&quot;\&quot;\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isHashChangeOnly(a, b) {</span><span class="s2">\n  </span><span class="s1">if (a.pathname !== b.pathname || a.search !== b.search) {</span><span class="s2">\n    </span><span class="s1">return false;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (a.hash === </span><span class="s2">\&quot;\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">return b.hash !== </span><span class="s2">\&quot;\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">} else if (a.hash === b.hash) {</span><span class="s2">\n    </span><span class="s1">return true;</span><span class="s2">\n  </span><span class="s1">} else if (b.hash !== </span><span class="s2">\&quot;\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">return true;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return false;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isDataStrategyResult(result) {</span><span class="s2">\n  </span><span class="s1">return result != null &amp;&amp; typeof result === </span><span class="s2">\&quot;</span><span class="s1">object</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; </span><span class="s2">\&quot;</span><span class="s1">type</span><span class="s2">\&quot; </span><span class="s1">in result &amp;&amp; </span><span class="s2">\&quot;</span><span class="s1">result</span><span class="s2">\&quot; </span><span class="s1">in result &amp;&amp; (result.type === </span><span class="s2">\&quot;</span><span class="s1">data</span><span class="s2">\&quot; </span><span class="s1">/* data */ || result.type === </span><span class="s2">\&quot;</span><span class="s1">error</span><span class="s2">\&quot; </span><span class="s1">/* error */);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isRedirectDataStrategyResult(result) {</span><span class="s2">\n  </span><span class="s1">return isResponse(result.result) &amp;&amp; redirectStatusCodes.has(result.result.status);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isErrorResult(result) {</span><span class="s2">\n  </span><span class="s1">return result.type === </span><span class="s2">\&quot;</span><span class="s1">error</span><span class="s2">\&quot; </span><span class="s1">/* error */;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isRedirectResult(result) {</span><span class="s2">\n  </span><span class="s1">return (result &amp;&amp; result.type) === </span><span class="s2">\&quot;</span><span class="s1">redirect</span><span class="s2">\&quot; </span><span class="s1">/* redirect */;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isDataWithResponseInit(value) {</span><span class="s2">\n  </span><span class="s1">return typeof value === </span><span class="s2">\&quot;</span><span class="s1">object</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; value != null &amp;&amp; </span><span class="s2">\&quot;</span><span class="s1">type</span><span class="s2">\&quot; </span><span class="s1">in value &amp;&amp; </span><span class="s2">\&quot;</span><span class="s1">data</span><span class="s2">\&quot; </span><span class="s1">in value &amp;&amp; </span><span class="s2">\&quot;</span><span class="s1">init</span><span class="s2">\&quot; </span><span class="s1">in value &amp;&amp; value.type === </span><span class="s2">\&quot;</span><span class="s1">DataWithResponseInit</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isResponse(value) {</span><span class="s2">\n  </span><span class="s1">return value != null &amp;&amp; typeof value.status === </span><span class="s2">\&quot;</span><span class="s1">number</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; typeof value.statusText === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; typeof value.headers === </span><span class="s2">\&quot;</span><span class="s1">object</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; typeof value.body !== </span><span class="s2">\&quot;</span><span class="s1">undefined</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isRedirectStatusCode(statusCode) {</span><span class="s2">\n  </span><span class="s1">return redirectStatusCodes.has(statusCode);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isRedirectResponse(result) {</span><span class="s2">\n  </span><span class="s1">return isResponse(result) &amp;&amp; isRedirectStatusCode(result.status) &amp;&amp; result.headers.has(</span><span class="s2">\&quot;</span><span class="s1">Location</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isValidMethod(method) {</span><span class="s2">\n  </span><span class="s1">return validRequestMethods.has(method.toUpperCase());</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isMutationMethod(method) {</span><span class="s2">\n  </span><span class="s1">return validMutationMethods.has(method.toUpperCase());</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function hasNakedIndexQuery(search) {</span><span class="s2">\n  </span><span class="s1">return new URLSearchParams(search).getAll(</span><span class="s2">\&quot;</span><span class="s1">index</span><span class="s2">\&quot;</span><span class="s1">).some(v =&gt; v === </span><span class="s2">\&quot;\&quot;</span><span class="s1">);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getTargetMatch(matches, location) {</span><span class="s2">\n  </span><span class="s1">let search = typeof location === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">? parsePath(location).search : location.search;</span><span class="s2">\n  </span><span class="s1">if (matches[matches.length - 1].route.index &amp;&amp; hasNakedIndexQuery(search || </span><span class="s2">\&quot;\&quot;</span><span class="s1">)) {</span><span class="s2">\n    </span><span class="s1">return matches[matches.length - 1];</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let pathMatches = getPathContributingMatches(matches);</span><span class="s2">\n  </span><span class="s1">return pathMatches[pathMatches.length - 1];</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getSubmissionFromNavigation(navigation) {</span><span class="s2">\n  </span><span class="s1">let {</span><span class="s2">\n    </span><span class="s1">formMethod,</span><span class="s2">\n    </span><span class="s1">formAction,</span><span class="s2">\n    </span><span class="s1">formEncType,</span><span class="s2">\n    </span><span class="s1">text,</span><span class="s2">\n    </span><span class="s1">formData,</span><span class="s2">\n    </span><span class="s1">json</span><span class="s2">\n  </span><span class="s1">} = navigation;</span><span class="s2">\n  </span><span class="s1">if (!formMethod || !formAction || !formEncType) {</span><span class="s2">\n    </span><span class="s1">return;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (text != null) {</span><span class="s2">\n    </span><span class="s1">return {</span><span class="s2">\n      </span><span class="s1">formMethod,</span><span class="s2">\n      </span><span class="s1">formAction,</span><span class="s2">\n      </span><span class="s1">formEncType,</span><span class="s2">\n      </span><span class="s1">formData: void 0,</span><span class="s2">\n      </span><span class="s1">json: void 0,</span><span class="s2">\n      </span><span class="s1">text</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">} else if (formData != null) {</span><span class="s2">\n    </span><span class="s1">return {</span><span class="s2">\n      </span><span class="s1">formMethod,</span><span class="s2">\n      </span><span class="s1">formAction,</span><span class="s2">\n      </span><span class="s1">formEncType,</span><span class="s2">\n      </span><span class="s1">formData,</span><span class="s2">\n      </span><span class="s1">json: void 0,</span><span class="s2">\n      </span><span class="s1">text: void 0</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">} else if (json !== void 0) {</span><span class="s2">\n    </span><span class="s1">return {</span><span class="s2">\n      </span><span class="s1">formMethod,</span><span class="s2">\n      </span><span class="s1">formAction,</span><span class="s2">\n      </span><span class="s1">formEncType,</span><span class="s2">\n      </span><span class="s1">formData: void 0,</span><span class="s2">\n      </span><span class="s1">json,</span><span class="s2">\n      </span><span class="s1">text: void 0</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getLoadingNavigation(location, submission) {</span><span class="s2">\n  </span><span class="s1">if (submission) {</span><span class="s2">\n    </span><span class="s1">let navigation = {</span><span class="s2">\n      </span><span class="s1">state: </span><span class="s2">\&quot;</span><span class="s1">loading</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">location,</span><span class="s2">\n      </span><span class="s1">formMethod: submission.formMethod,</span><span class="s2">\n      </span><span class="s1">formAction: submission.formAction,</span><span class="s2">\n      </span><span class="s1">formEncType: submission.formEncType,</span><span class="s2">\n      </span><span class="s1">formData: submission.formData,</span><span class="s2">\n      </span><span class="s1">json: submission.json,</span><span class="s2">\n      </span><span class="s1">text: submission.text</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">return navigation;</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">let navigation = {</span><span class="s2">\n      </span><span class="s1">state: </span><span class="s2">\&quot;</span><span class="s1">loading</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">location,</span><span class="s2">\n      </span><span class="s1">formMethod: void 0,</span><span class="s2">\n      </span><span class="s1">formAction: void 0,</span><span class="s2">\n      </span><span class="s1">formEncType: void 0,</span><span class="s2">\n      </span><span class="s1">formData: void 0,</span><span class="s2">\n      </span><span class="s1">json: void 0,</span><span class="s2">\n      </span><span class="s1">text: void 0</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">return navigation;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getSubmittingNavigation(location, submission) {</span><span class="s2">\n  </span><span class="s1">let navigation = {</span><span class="s2">\n    </span><span class="s1">state: </span><span class="s2">\&quot;</span><span class="s1">submitting</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">location,</span><span class="s2">\n    </span><span class="s1">formMethod: submission.formMethod,</span><span class="s2">\n    </span><span class="s1">formAction: submission.formAction,</span><span class="s2">\n    </span><span class="s1">formEncType: submission.formEncType,</span><span class="s2">\n    </span><span class="s1">formData: submission.formData,</span><span class="s2">\n    </span><span class="s1">json: submission.json,</span><span class="s2">\n    </span><span class="s1">text: submission.text</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">return navigation;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getLoadingFetcher(submission, data2) {</span><span class="s2">\n  </span><span class="s1">if (submission) {</span><span class="s2">\n    </span><span class="s1">let fetcher = {</span><span class="s2">\n      </span><span class="s1">state: </span><span class="s2">\&quot;</span><span class="s1">loading</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">formMethod: submission.formMethod,</span><span class="s2">\n      </span><span class="s1">formAction: submission.formAction,</span><span class="s2">\n      </span><span class="s1">formEncType: submission.formEncType,</span><span class="s2">\n      </span><span class="s1">formData: submission.formData,</span><span class="s2">\n      </span><span class="s1">json: submission.json,</span><span class="s2">\n      </span><span class="s1">text: submission.text,</span><span class="s2">\n      </span><span class="s1">data: data2</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">return fetcher;</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">let fetcher = {</span><span class="s2">\n      </span><span class="s1">state: </span><span class="s2">\&quot;</span><span class="s1">loading</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">formMethod: void 0,</span><span class="s2">\n      </span><span class="s1">formAction: void 0,</span><span class="s2">\n      </span><span class="s1">formEncType: void 0,</span><span class="s2">\n      </span><span class="s1">formData: void 0,</span><span class="s2">\n      </span><span class="s1">json: void 0,</span><span class="s2">\n      </span><span class="s1">text: void 0,</span><span class="s2">\n      </span><span class="s1">data: data2</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">return fetcher;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getSubmittingFetcher(submission, existingFetcher) {</span><span class="s2">\n  </span><span class="s1">let fetcher = {</span><span class="s2">\n    </span><span class="s1">state: </span><span class="s2">\&quot;</span><span class="s1">submitting</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">formMethod: submission.formMethod,</span><span class="s2">\n    </span><span class="s1">formAction: submission.formAction,</span><span class="s2">\n    </span><span class="s1">formEncType: submission.formEncType,</span><span class="s2">\n    </span><span class="s1">formData: submission.formData,</span><span class="s2">\n    </span><span class="s1">json: submission.json,</span><span class="s2">\n    </span><span class="s1">text: submission.text,</span><span class="s2">\n    </span><span class="s1">data: existingFetcher ? existingFetcher.data : void 0</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">return fetcher;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getDoneFetcher(data2) {</span><span class="s2">\n  </span><span class="s1">let fetcher = {</span><span class="s2">\n    </span><span class="s1">state: </span><span class="s2">\&quot;</span><span class="s1">idle</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">formMethod: void 0,</span><span class="s2">\n    </span><span class="s1">formAction: void 0,</span><span class="s2">\n    </span><span class="s1">formEncType: void 0,</span><span class="s2">\n    </span><span class="s1">formData: void 0,</span><span class="s2">\n    </span><span class="s1">json: void 0,</span><span class="s2">\n    </span><span class="s1">text: void 0,</span><span class="s2">\n    </span><span class="s1">data: data2</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">return fetcher;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function restoreAppliedTransitions(_window, transitions) {</span><span class="s2">\n  </span><span class="s1">try {</span><span class="s2">\n    </span><span class="s1">let sessionPositions = _window.sessionStorage.getItem(TRANSITIONS_STORAGE_KEY);</span><span class="s2">\n    </span><span class="s1">if (sessionPositions) {</span><span class="s2">\n      </span><span class="s1">let json = JSON.parse(sessionPositions);</span><span class="s2">\n      </span><span class="s1">for (let [k, v] of Object.entries(json || {})) {</span><span class="s2">\n        </span><span class="s1">if (v &amp;&amp; Array.isArray(v)) {</span><span class="s2">\n          </span><span class="s1">transitions.set(k, new Set(v || []));</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">} catch (e) {}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function persistAppliedTransitions(_window, transitions) {</span><span class="s2">\n  </span><span class="s1">if (transitions.size &gt; 0) {</span><span class="s2">\n    </span><span class="s1">let json = {};</span><span class="s2">\n    </span><span class="s1">for (let [k, v] of transitions) {</span><span class="s2">\n      </span><span class="s1">json[k] = [...v];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">try {</span><span class="s2">\n      </span><span class="s1">_window.sessionStorage.setItem(TRANSITIONS_STORAGE_KEY, JSON.stringify(json));</span><span class="s2">\n    </span><span class="s1">} catch (error) {</span><span class="s2">\n      </span><span class="s1">warning(false, `Failed to save applied view transitions in sessionStorage (${error}).`);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createDeferred() {</span><span class="s2">\n  </span><span class="s1">let resolve;</span><span class="s2">\n  </span><span class="s1">let reject;</span><span class="s2">\n  </span><span class="s1">let promise = new Promise((res, rej) =&gt; {</span><span class="s2">\n    </span><span class="s1">resolve = async val =&gt; {</span><span class="s2">\n      </span><span class="s1">res(val);</span><span class="s2">\n      </span><span class="s1">try {</span><span class="s2">\n        </span><span class="s1">await promise;</span><span class="s2">\n      </span><span class="s1">} catch (e) {}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">reject = async error =&gt; {</span><span class="s2">\n      </span><span class="s1">rej(error);</span><span class="s2">\n      </span><span class="s1">try {</span><span class="s2">\n        </span><span class="s1">await promise;</span><span class="s2">\n      </span><span class="s1">} catch (e) {}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">promise,</span><span class="s2">\n    </span><span class="s1">//@ts-ignore</span><span class="s2">\n    </span><span class="s1">resolve,</span><span class="s2">\n    </span><span class="s1">//@ts-ignore</span><span class="s2">\n    </span><span class="s1">reject</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/components.tsx</span><span class="s2">\n</span><span class="s1">import * as React3 from </span><span class="s2">\&quot;</span><span class="s1">react</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n</span><span class="s1">// lib/context.ts</span><span class="s2">\n</span><span class="s1">import * as React from </span><span class="s2">\&quot;</span><span class="s1">react</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">var DataRouterContext = React.createContext(null);</span><span class="s2">\n</span><span class="s1">DataRouterContext.displayName = </span><span class="s2">\&quot;</span><span class="s1">DataRouter</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">var DataRouterStateContext = React.createContext(null);</span><span class="s2">\n</span><span class="s1">DataRouterStateContext.displayName = </span><span class="s2">\&quot;</span><span class="s1">DataRouterState</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">var ViewTransitionContext = React.createContext({</span><span class="s2">\n  </span><span class="s1">isTransitioning: false</span><span class="s2">\n</span><span class="s1">});</span><span class="s2">\n</span><span class="s1">ViewTransitionContext.displayName = </span><span class="s2">\&quot;</span><span class="s1">ViewTransition</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">var FetchersContext = React.createContext(/* @__PURE__ */new Map());</span><span class="s2">\n</span><span class="s1">FetchersContext.displayName = </span><span class="s2">\&quot;</span><span class="s1">Fetchers</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">var AwaitContext = React.createContext(null);</span><span class="s2">\n</span><span class="s1">AwaitContext.displayName = </span><span class="s2">\&quot;</span><span class="s1">Await</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">var NavigationContext = React.createContext(null);</span><span class="s2">\n</span><span class="s1">NavigationContext.displayName = </span><span class="s2">\&quot;</span><span class="s1">Navigation</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">var LocationContext = React.createContext(null);</span><span class="s2">\n</span><span class="s1">LocationContext.displayName = </span><span class="s2">\&quot;</span><span class="s1">Location</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">var RouteContext = React.createContext({</span><span class="s2">\n  </span><span class="s1">outlet: null,</span><span class="s2">\n  </span><span class="s1">matches: [],</span><span class="s2">\n  </span><span class="s1">isDataRoute: false</span><span class="s2">\n</span><span class="s1">});</span><span class="s2">\n</span><span class="s1">RouteContext.displayName = </span><span class="s2">\&quot;</span><span class="s1">Route</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">var RouteErrorContext = React.createContext(null);</span><span class="s2">\n</span><span class="s1">RouteErrorContext.displayName = </span><span class="s2">\&quot;</span><span class="s1">RouteError</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">var ENABLE_DEV_WARNINGS = true;</span><span class="s2">\n\n</span><span class="s1">// lib/hooks.tsx</span><span class="s2">\n</span><span class="s1">import * as React2 from </span><span class="s2">\&quot;</span><span class="s1">react</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">function useHref(to, {</span><span class="s2">\n  </span><span class="s1">relative</span><span class="s2">\n</span><span class="s1">} = {}) {</span><span class="s2">\n  </span><span class="s1">invariant(useInRouterContext(),</span><span class="s2">\n  </span><span class="s1">// TODO: This error is probably because they somehow have 2 versions of the</span><span class="s2">\n  </span><span class="s1">// router loaded. We can help them understand how to avoid that.</span><span class="s2">\n  </span><span class="s1">`useHref() may be used only in the context of a &lt;Router&gt; component.`);</span><span class="s2">\n  </span><span class="s1">let {</span><span class="s2">\n    </span><span class="s1">basename,</span><span class="s2">\n    </span><span class="s1">navigator</span><span class="s2">\n  </span><span class="s1">} = React2.useContext(NavigationContext);</span><span class="s2">\n  </span><span class="s1">let {</span><span class="s2">\n    </span><span class="s1">hash,</span><span class="s2">\n    </span><span class="s1">pathname,</span><span class="s2">\n    </span><span class="s1">search</span><span class="s2">\n  </span><span class="s1">} = useResolvedPath(to, {</span><span class="s2">\n    </span><span class="s1">relative</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">let joinedPathname = pathname;</span><span class="s2">\n  </span><span class="s1">if (basename !== </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">joinedPathname = pathname === </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot; </span><span class="s1">? basename : joinPaths([basename, pathname]);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return navigator.createHref({</span><span class="s2">\n    </span><span class="s1">pathname: joinedPathname,</span><span class="s2">\n    </span><span class="s1">search,</span><span class="s2">\n    </span><span class="s1">hash</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useInRouterContext() {</span><span class="s2">\n  </span><span class="s1">return React2.useContext(LocationContext) != null;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useLocation() {</span><span class="s2">\n  </span><span class="s1">invariant(useInRouterContext(),</span><span class="s2">\n  </span><span class="s1">// TODO: This error is probably because they somehow have 2 versions of the</span><span class="s2">\n  </span><span class="s1">// router loaded. We can help them understand how to avoid that.</span><span class="s2">\n  </span><span class="s1">`useLocation() may be used only in the context of a &lt;Router&gt; component.`);</span><span class="s2">\n  </span><span class="s1">return React2.useContext(LocationContext).location;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useNavigationType() {</span><span class="s2">\n  </span><span class="s1">return React2.useContext(LocationContext).navigationType;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useMatch(pattern) {</span><span class="s2">\n  </span><span class="s1">invariant(useInRouterContext(),</span><span class="s2">\n  </span><span class="s1">// TODO: This error is probably because they somehow have 2 versions of the</span><span class="s2">\n  </span><span class="s1">// router loaded. We can help them understand how to avoid that.</span><span class="s2">\n  </span><span class="s1">`useMatch() may be used only in the context of a &lt;Router&gt; component.`);</span><span class="s2">\n  </span><span class="s1">let {</span><span class="s2">\n    </span><span class="s1">pathname</span><span class="s2">\n  </span><span class="s1">} = useLocation();</span><span class="s2">\n  </span><span class="s1">return React2.useMemo(() =&gt; matchPath(pattern, decodePath(pathname)), [pathname, pattern]);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var navigateEffectWarning = `You should call navigate() in a React.useEffect(), not when your component is first rendered.`;</span><span class="s2">\n</span><span class="s1">function useIsomorphicLayoutEffect(cb) {</span><span class="s2">\n  </span><span class="s1">let isStatic = React2.useContext(NavigationContext).static;</span><span class="s2">\n  </span><span class="s1">if (!isStatic) {</span><span class="s2">\n    </span><span class="s1">React2.useLayoutEffect(cb);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useNavigate() {</span><span class="s2">\n  </span><span class="s1">let {</span><span class="s2">\n    </span><span class="s1">isDataRoute</span><span class="s2">\n  </span><span class="s1">} = React2.useContext(RouteContext);</span><span class="s2">\n  </span><span class="s1">return isDataRoute ? useNavigateStable() : useNavigateUnstable();</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useNavigateUnstable() {</span><span class="s2">\n  </span><span class="s1">invariant(useInRouterContext(),</span><span class="s2">\n  </span><span class="s1">// TODO: This error is probably because they somehow have 2 versions of the</span><span class="s2">\n  </span><span class="s1">// router loaded. We can help them understand how to avoid that.</span><span class="s2">\n  </span><span class="s1">`useNavigate() may be used only in the context of a &lt;Router&gt; component.`);</span><span class="s2">\n  </span><span class="s1">let dataRouterContext = React2.useContext(DataRouterContext);</span><span class="s2">\n  </span><span class="s1">let {</span><span class="s2">\n    </span><span class="s1">basename,</span><span class="s2">\n    </span><span class="s1">navigator</span><span class="s2">\n  </span><span class="s1">} = React2.useContext(NavigationContext);</span><span class="s2">\n  </span><span class="s1">let {</span><span class="s2">\n    </span><span class="s1">matches</span><span class="s2">\n  </span><span class="s1">} = React2.useContext(RouteContext);</span><span class="s2">\n  </span><span class="s1">let {</span><span class="s2">\n    </span><span class="s1">pathname: locationPathname</span><span class="s2">\n  </span><span class="s1">} = useLocation();</span><span class="s2">\n  </span><span class="s1">let routePathnamesJson = JSON.stringify(getResolveToMatches(matches));</span><span class="s2">\n  </span><span class="s1">let activeRef = React2.useRef(false);</span><span class="s2">\n  </span><span class="s1">useIsomorphicLayoutEffect(() =&gt; {</span><span class="s2">\n    </span><span class="s1">activeRef.current = true;</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">let navigate = React2.useCallback((to, options = {}) =&gt; {</span><span class="s2">\n    </span><span class="s1">warning(activeRef.current, navigateEffectWarning);</span><span class="s2">\n    </span><span class="s1">if (!activeRef.current) return;</span><span class="s2">\n    </span><span class="s1">if (typeof to === </span><span class="s2">\&quot;</span><span class="s1">number</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">navigator.go(to);</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let path = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === </span><span class="s2">\&quot;</span><span class="s1">path</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">if (dataRouterContext == null &amp;&amp; basename !== </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">path.pathname = path.pathname === </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot; </span><span class="s1">? basename : joinPaths([basename, path.pathname]);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">(!!options.replace ? navigator.replace : navigator.push)(path, options.state, options);</span><span class="s2">\n  </span><span class="s1">}, [basename, navigator, routePathnamesJson, locationPathname, dataRouterContext]);</span><span class="s2">\n  </span><span class="s1">return navigate;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var OutletContext = React2.createContext(null);</span><span class="s2">\n</span><span class="s1">function useOutletContext() {</span><span class="s2">\n  </span><span class="s1">return React2.useContext(OutletContext);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useOutlet(context) {</span><span class="s2">\n  </span><span class="s1">let outlet = React2.useContext(RouteContext).outlet;</span><span class="s2">\n  </span><span class="s1">if (outlet) {</span><span class="s2">\n    </span><span class="s1">return /* @__PURE__ */React2.createElement(OutletContext.Provider, {</span><span class="s2">\n      </span><span class="s1">value: context</span><span class="s2">\n    </span><span class="s1">}, outlet);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return outlet;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useParams() {</span><span class="s2">\n  </span><span class="s1">let {</span><span class="s2">\n    </span><span class="s1">matches</span><span class="s2">\n  </span><span class="s1">} = React2.useContext(RouteContext);</span><span class="s2">\n  </span><span class="s1">let routeMatch = matches[matches.length - 1];</span><span class="s2">\n  </span><span class="s1">return routeMatch ? routeMatch.params : {};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useResolvedPath(to, {</span><span class="s2">\n  </span><span class="s1">relative</span><span class="s2">\n</span><span class="s1">} = {}) {</span><span class="s2">\n  </span><span class="s1">let {</span><span class="s2">\n    </span><span class="s1">matches</span><span class="s2">\n  </span><span class="s1">} = React2.useContext(RouteContext);</span><span class="s2">\n  </span><span class="s1">let {</span><span class="s2">\n    </span><span class="s1">pathname: locationPathname</span><span class="s2">\n  </span><span class="s1">} = useLocation();</span><span class="s2">\n  </span><span class="s1">let routePathnamesJson = JSON.stringify(getResolveToMatches(matches));</span><span class="s2">\n  </span><span class="s1">return React2.useMemo(() =&gt; resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, relative === </span><span class="s2">\&quot;</span><span class="s1">path</span><span class="s2">\&quot;</span><span class="s1">), [to, routePathnamesJson, locationPathname, relative]);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useRoutes(routes, locationArg) {</span><span class="s2">\n  </span><span class="s1">return useRoutesImpl(routes, locationArg);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useRoutesImpl(routes, locationArg, dataRouterState, future) {</span><span class="s2">\n  </span><span class="s1">invariant(useInRouterContext(),</span><span class="s2">\n  </span><span class="s1">// TODO: This error is probably because they somehow have 2 versions of the</span><span class="s2">\n  </span><span class="s1">// router loaded. We can help them understand how to avoid that.</span><span class="s2">\n  </span><span class="s1">`useRoutes() may be used only in the context of a &lt;Router&gt; component.`);</span><span class="s2">\n  </span><span class="s1">let {</span><span class="s2">\n    </span><span class="s1">navigator,</span><span class="s2">\n    </span><span class="s1">static: isStatic</span><span class="s2">\n  </span><span class="s1">} = React2.useContext(NavigationContext);</span><span class="s2">\n  </span><span class="s1">let {</span><span class="s2">\n    </span><span class="s1">matches: parentMatches</span><span class="s2">\n  </span><span class="s1">} = React2.useContext(RouteContext);</span><span class="s2">\n  </span><span class="s1">let routeMatch = parentMatches[parentMatches.length - 1];</span><span class="s2">\n  </span><span class="s1">let parentParams = routeMatch ? routeMatch.params : {};</span><span class="s2">\n  </span><span class="s1">let parentPathname = routeMatch ? routeMatch.pathname : </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">let parentRoute = routeMatch &amp;&amp; routeMatch.route;</span><span class="s2">\n  </span><span class="s1">if (ENABLE_DEV_WARNINGS) {</span><span class="s2">\n    </span><span class="s1">let parentPath = parentRoute &amp;&amp; parentRoute.path || </span><span class="s2">\&quot;\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">warningOnce(parentPathname, !parentRoute || parentPath.endsWith(</span><span class="s2">\&quot;</span><span class="s1">*</span><span class="s2">\&quot;</span><span class="s1">) || parentPath.endsWith(</span><span class="s2">\&quot;</span><span class="s1">*?</span><span class="s2">\&quot;</span><span class="s1">), `You rendered descendant &lt;Routes&gt; (or called </span><span class="s2">\\</span><span class="s1">`useRoutes()</span><span class="s2">\\</span><span class="s1">`) at </span><span class="s2">\&quot;</span><span class="s1">${parentPathname}</span><span class="s2">\&quot; </span><span class="s1">(under &lt;Route path=</span><span class="s2">\&quot;</span><span class="s1">${parentPath}</span><span class="s2">\&quot;</span><span class="s1">&gt;) but the parent route path has no trailing </span><span class="s2">\&quot;</span><span class="s1">*</span><span class="s2">\&quot;</span><span class="s1">. This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.</span><span class="s2">\n\n</span><span class="s1">Please change the parent &lt;Route path=</span><span class="s2">\&quot;</span><span class="s1">${parentPath}</span><span class="s2">\&quot;</span><span class="s1">&gt; to &lt;Route path=</span><span class="s2">\&quot;</span><span class="s1">${parentPath === </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot; </span><span class="s1">? </span><span class="s2">\&quot;</span><span class="s1">*</span><span class="s2">\&quot; </span><span class="s1">: `${parentPath}/*`}</span><span class="s2">\&quot;</span><span class="s1">&gt;.`);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let locationFromContext = useLocation();</span><span class="s2">\n  </span><span class="s1">let location;</span><span class="s2">\n  </span><span class="s1">if (locationArg) {</span><span class="s2">\n    </span><span class="s1">let parsedLocationArg = typeof locationArg === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">? parsePath(locationArg) : locationArg;</span><span class="s2">\n    </span><span class="s1">invariant(parentPathnameBase === </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot; </span><span class="s1">|| parsedLocationArg.pathname?.startsWith(parentPathnameBase), `When overriding the location using </span><span class="s2">\\</span><span class="s1">`&lt;Routes location&gt;</span><span class="s2">\\</span><span class="s1">` or </span><span class="s2">\\</span><span class="s1">`useRoutes(routes, location)</span><span class="s2">\\</span><span class="s1">`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is </span><span class="s2">\&quot;</span><span class="s1">${parentPathnameBase}</span><span class="s2">\&quot; </span><span class="s1">but pathname </span><span class="s2">\&quot;</span><span class="s1">${parsedLocationArg.pathname}</span><span class="s2">\&quot; </span><span class="s1">was given in the </span><span class="s2">\\</span><span class="s1">`location</span><span class="s2">\\</span><span class="s1">` prop.`);</span><span class="s2">\n    </span><span class="s1">location = parsedLocationArg;</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">location = locationFromContext;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let pathname = location.pathname || </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">let remainingPathname = pathname;</span><span class="s2">\n  </span><span class="s1">if (parentPathnameBase !== </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">let parentSegments = parentPathnameBase.replace(/^</span><span class="s2">\\</span><span class="s1">//, </span><span class="s2">\&quot;\&quot;</span><span class="s1">).split(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">let segments = pathname.replace(/^</span><span class="s2">\\</span><span class="s1">//, </span><span class="s2">\&quot;\&quot;</span><span class="s1">).split(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">remainingPathname = </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot; </span><span class="s1">+ segments.slice(parentSegments.length).join(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let matches = !isStatic &amp;&amp; dataRouterState &amp;&amp; dataRouterState.matches &amp;&amp; dataRouterState.matches.length &gt; 0 ? dataRouterState.matches : matchRoutes(routes, {</span><span class="s2">\n    </span><span class="s1">pathname: remainingPathname</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">if (ENABLE_DEV_WARNINGS) {</span><span class="s2">\n    </span><span class="s1">warning(parentRoute || matches != null, `No routes matched location </span><span class="s2">\&quot;</span><span class="s1">${location.pathname}${location.search}${location.hash}</span><span class="s2">\&quot; </span><span class="s1">`);</span><span class="s2">\n    </span><span class="s1">warning(matches == null || matches[matches.length - 1].route.element !== void 0 || matches[matches.length - 1].route.Component !== void 0 || matches[matches.length - 1].route.lazy !== void 0, `Matched leaf route at location </span><span class="s2">\&quot;</span><span class="s1">${location.pathname}${location.search}${location.hash}</span><span class="s2">\&quot; </span><span class="s1">does not have an element or Component. This means it will render an &lt;Outlet /&gt; with a null value by default resulting in an </span><span class="s2">\&quot;</span><span class="s1">empty</span><span class="s2">\&quot; </span><span class="s1">page.`);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let renderedMatches = _renderMatches(matches &amp;&amp; matches.map(match =&gt; Object.assign({}, match, {</span><span class="s2">\n    </span><span class="s1">params: Object.assign({}, parentParams, match.params),</span><span class="s2">\n    </span><span class="s1">pathname: joinPaths([parentPathnameBase,</span><span class="s2">\n    </span><span class="s1">// Re-encode pathnames that were decoded inside matchRoutes</span><span class="s2">\n    </span><span class="s1">navigator.encodeLocation ? navigator.encodeLocation(match.pathname).pathname : match.pathname]),</span><span class="s2">\n    </span><span class="s1">pathnameBase: match.pathnameBase === </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot; </span><span class="s1">? parentPathnameBase : joinPaths([parentPathnameBase,</span><span class="s2">\n    </span><span class="s1">// Re-encode pathnames that were decoded inside matchRoutes</span><span class="s2">\n    </span><span class="s1">navigator.encodeLocation ? navigator.encodeLocation(match.pathnameBase).pathname : match.pathnameBase])</span><span class="s2">\n  </span><span class="s1">})), parentMatches, dataRouterState, future);</span><span class="s2">\n  </span><span class="s1">if (locationArg &amp;&amp; renderedMatches) {</span><span class="s2">\n    </span><span class="s1">return /* @__PURE__ */React2.createElement(LocationContext.Provider, {</span><span class="s2">\n      </span><span class="s1">value: {</span><span class="s2">\n        </span><span class="s1">location: {</span><span class="s2">\n          </span><span class="s1">pathname: </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n          </span><span class="s1">search: </span><span class="s2">\&quot;\&quot;</span><span class="s1">,</span><span class="s2">\n          </span><span class="s1">hash: </span><span class="s2">\&quot;\&quot;</span><span class="s1">,</span><span class="s2">\n          </span><span class="s1">state: null,</span><span class="s2">\n          </span><span class="s1">key: </span><span class="s2">\&quot;</span><span class="s1">default</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n          </span><span class="s1">...location</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">navigationType: </span><span class="s2">\&quot;</span><span class="s1">POP</span><span class="s2">\&quot; </span><span class="s1">/* Pop */</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}, renderedMatches);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return renderedMatches;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function DefaultErrorComponent() {</span><span class="s2">\n  </span><span class="s1">let error = useRouteError();</span><span class="s2">\n  </span><span class="s1">let message = isRouteErrorResponse(error) ? `${error.status} ${error.statusText}` : error instanceof Error ? error.message : JSON.stringify(error);</span><span class="s2">\n  </span><span class="s1">let stack = error instanceof Error ? error.stack : null;</span><span class="s2">\n  </span><span class="s1">let lightgrey = </span><span class="s2">\&quot;</span><span class="s1">rgba(200,200,200, 0.5)</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">let preStyles = {</span><span class="s2">\n    </span><span class="s1">padding: </span><span class="s2">\&quot;</span><span class="s1">0.5rem</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">backgroundColor: lightgrey</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">let codeStyles = {</span><span class="s2">\n    </span><span class="s1">padding: </span><span class="s2">\&quot;</span><span class="s1">2px 4px</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">backgroundColor: lightgrey</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">let devInfo = null;</span><span class="s2">\n  </span><span class="s1">if (ENABLE_DEV_WARNINGS) {</span><span class="s2">\n    </span><span class="s1">console.error(</span><span class="s2">\&quot;</span><span class="s1">Error handled by React Router default ErrorBoundary:</span><span class="s2">\&quot;</span><span class="s1">, error);</span><span class="s2">\n    </span><span class="s1">devInfo = /* @__PURE__ */React2.createElement(React2.Fragment, null, /* @__PURE__ */React2.createElement(</span><span class="s2">\&quot;</span><span class="s1">p</span><span class="s2">\&quot;</span><span class="s1">, null, </span><span class="s2">\&quot;\\</span><span class="s1">u{1F4BF} Hey developer </span><span class="s2">\\</span><span class="s1">u{1F44B}</span><span class="s2">\&quot;</span><span class="s1">), /* @__PURE__ */React2.createElement(</span><span class="s2">\&quot;</span><span class="s1">p</span><span class="s2">\&quot;</span><span class="s1">, null, </span><span class="s2">\&quot;</span><span class="s1">You can provide a way better UX than this when your app throws errors by providing your own </span><span class="s2">\&quot;</span><span class="s1">, /* @__PURE__ */React2.createElement(</span><span class="s2">\&quot;</span><span class="s1">code</span><span class="s2">\&quot;</span><span class="s1">, {</span><span class="s2">\n      </span><span class="s1">style: codeStyles</span><span class="s2">\n    </span><span class="s1">}, </span><span class="s2">\&quot;</span><span class="s1">ErrorBoundary</span><span class="s2">\&quot;</span><span class="s1">), </span><span class="s2">\&quot; </span><span class="s1">or</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot; \&quot;</span><span class="s1">, /* @__PURE__ */React2.createElement(</span><span class="s2">\&quot;</span><span class="s1">code</span><span class="s2">\&quot;</span><span class="s1">, {</span><span class="s2">\n      </span><span class="s1">style: codeStyles</span><span class="s2">\n    </span><span class="s1">}, </span><span class="s2">\&quot;</span><span class="s1">errorElement</span><span class="s2">\&quot;</span><span class="s1">), </span><span class="s2">\&quot; </span><span class="s1">prop on your route.</span><span class="s2">\&quot;</span><span class="s1">));</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return /* @__PURE__ */React2.createElement(React2.Fragment, null, /* @__PURE__ */React2.createElement(</span><span class="s2">\&quot;</span><span class="s1">h2</span><span class="s2">\&quot;</span><span class="s1">, null, </span><span class="s2">\&quot;</span><span class="s1">Unexpected Application Error!</span><span class="s2">\&quot;</span><span class="s1">), /* @__PURE__ */React2.createElement(</span><span class="s2">\&quot;</span><span class="s1">h3</span><span class="s2">\&quot;</span><span class="s1">, {</span><span class="s2">\n    </span><span class="s1">style: {</span><span class="s2">\n      </span><span class="s1">fontStyle: </span><span class="s2">\&quot;</span><span class="s1">italic</span><span class="s2">\&quot;\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}, message), stack ? /* @__PURE__ */React2.createElement(</span><span class="s2">\&quot;</span><span class="s1">pre</span><span class="s2">\&quot;</span><span class="s1">, {</span><span class="s2">\n    </span><span class="s1">style: preStyles</span><span class="s2">\n  </span><span class="s1">}, stack) : null, devInfo);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var defaultErrorElement = /* @__PURE__ */React2.createElement(DefaultErrorComponent, null);</span><span class="s2">\n</span><span class="s1">var RenderErrorBoundary = class extends React2.Component {</span><span class="s2">\n  </span><span class="s1">constructor(props) {</span><span class="s2">\n    </span><span class="s1">super(props);</span><span class="s2">\n    </span><span class="s1">this.state = {</span><span class="s2">\n      </span><span class="s1">location: props.location,</span><span class="s2">\n      </span><span class="s1">revalidation: props.revalidation,</span><span class="s2">\n      </span><span class="s1">error: props.error</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">static getDerivedStateFromError(error) {</span><span class="s2">\n    </span><span class="s1">return {</span><span class="s2">\n      </span><span class="s1">error</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">static getDerivedStateFromProps(props, state) {</span><span class="s2">\n    </span><span class="s1">if (state.location !== props.location || state.revalidation !== </span><span class="s2">\&quot;</span><span class="s1">idle</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; props.revalidation === </span><span class="s2">\&quot;</span><span class="s1">idle</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">return {</span><span class="s2">\n        </span><span class="s1">error: props.error,</span><span class="s2">\n        </span><span class="s1">location: props.location,</span><span class="s2">\n        </span><span class="s1">revalidation: props.revalidation</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return {</span><span class="s2">\n      </span><span class="s1">error: props.error !== void 0 ? props.error : state.error,</span><span class="s2">\n      </span><span class="s1">location: state.location,</span><span class="s2">\n      </span><span class="s1">revalidation: props.revalidation || state.revalidation</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">componentDidCatch(error, errorInfo) {</span><span class="s2">\n    </span><span class="s1">console.error(</span><span class="s2">\&quot;</span><span class="s1">React Router caught the following error during render</span><span class="s2">\&quot;</span><span class="s1">, error, errorInfo);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">render() {</span><span class="s2">\n    </span><span class="s1">return this.state.error !== void 0 ? /* @__PURE__ */React2.createElement(RouteContext.Provider, {</span><span class="s2">\n      </span><span class="s1">value: this.props.routeContext</span><span class="s2">\n    </span><span class="s1">}, /* @__PURE__ */React2.createElement(RouteErrorContext.Provider, {</span><span class="s2">\n      </span><span class="s1">value: this.state.error,</span><span class="s2">\n      </span><span class="s1">children: this.props.component</span><span class="s2">\n    </span><span class="s1">})) : this.props.children;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">function RenderedRoute({</span><span class="s2">\n  </span><span class="s1">routeContext,</span><span class="s2">\n  </span><span class="s1">match,</span><span class="s2">\n  </span><span class="s1">children</span><span class="s2">\n</span><span class="s1">}) {</span><span class="s2">\n  </span><span class="s1">let dataRouterContext = React2.useContext(DataRouterContext);</span><span class="s2">\n  </span><span class="s1">if (dataRouterContext &amp;&amp; dataRouterContext.static &amp;&amp; dataRouterContext.staticContext &amp;&amp; (match.route.errorElement || match.route.ErrorBoundary)) {</span><span class="s2">\n    </span><span class="s1">dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return /* @__PURE__ */React2.createElement(RouteContext.Provider, {</span><span class="s2">\n    </span><span class="s1">value: routeContext</span><span class="s2">\n  </span><span class="s1">}, children);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function _renderMatches(matches, parentMatches = [], dataRouterState = null, future = null) {</span><span class="s2">\n  </span><span class="s1">if (matches == null) {</span><span class="s2">\n    </span><span class="s1">if (!dataRouterState) {</span><span class="s2">\n      </span><span class="s1">return null;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (dataRouterState.errors) {</span><span class="s2">\n      </span><span class="s1">matches = dataRouterState.matches;</span><span class="s2">\n    </span><span class="s1">} else if (parentMatches.length === 0 &amp;&amp; !dataRouterState.initialized &amp;&amp; dataRouterState.matches.length &gt; 0) {</span><span class="s2">\n      </span><span class="s1">matches = dataRouterState.matches;</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">return null;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let renderedMatches = matches;</span><span class="s2">\n  </span><span class="s1">let errors = dataRouterState?.errors;</span><span class="s2">\n  </span><span class="s1">if (errors != null) {</span><span class="s2">\n    </span><span class="s1">let errorIndex = renderedMatches.findIndex(m =&gt; m.route.id &amp;&amp; errors?.[m.route.id] !== void 0);</span><span class="s2">\n    </span><span class="s1">invariant(errorIndex &gt;= 0, `Could not find a matching route for errors on route IDs: ${Object.keys(errors).join(</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\&quot;</span><span class="s1">)}`);</span><span class="s2">\n    </span><span class="s1">renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let renderFallback = false;</span><span class="s2">\n  </span><span class="s1">let fallbackIndex = -1;</span><span class="s2">\n  </span><span class="s1">if (dataRouterState) {</span><span class="s2">\n    </span><span class="s1">for (let i = 0; i &lt; renderedMatches.length; i++) {</span><span class="s2">\n      </span><span class="s1">let match = renderedMatches[i];</span><span class="s2">\n      </span><span class="s1">if (match.route.HydrateFallback || match.route.hydrateFallbackElement) {</span><span class="s2">\n        </span><span class="s1">fallbackIndex = i;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (match.route.id) {</span><span class="s2">\n        </span><span class="s1">let {</span><span class="s2">\n          </span><span class="s1">loaderData,</span><span class="s2">\n          </span><span class="s1">errors: errors2</span><span class="s2">\n        </span><span class="s1">} = dataRouterState;</span><span class="s2">\n        </span><span class="s1">let needsToRunLoader = match.route.loader &amp;&amp; !loaderData.hasOwnProperty(match.route.id) &amp;&amp; (!errors2 || errors2[match.route.id] === void 0);</span><span class="s2">\n        </span><span class="s1">if (match.route.lazy || needsToRunLoader) {</span><span class="s2">\n          </span><span class="s1">renderFallback = true;</span><span class="s2">\n          </span><span class="s1">if (fallbackIndex &gt;= 0) {</span><span class="s2">\n            </span><span class="s1">renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);</span><span class="s2">\n          </span><span class="s1">} else {</span><span class="s2">\n            </span><span class="s1">renderedMatches = [renderedMatches[0]];</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">break;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return renderedMatches.reduceRight((outlet, match, index) =&gt; {</span><span class="s2">\n    </span><span class="s1">let error;</span><span class="s2">\n    </span><span class="s1">let shouldRenderHydrateFallback = false;</span><span class="s2">\n    </span><span class="s1">let errorElement = null;</span><span class="s2">\n    </span><span class="s1">let hydrateFallbackElement = null;</span><span class="s2">\n    </span><span class="s1">if (dataRouterState) {</span><span class="s2">\n      </span><span class="s1">error = errors &amp;&amp; match.route.id ? errors[match.route.id] : void 0;</span><span class="s2">\n      </span><span class="s1">errorElement = match.route.errorElement || defaultErrorElement;</span><span class="s2">\n      </span><span class="s1">if (renderFallback) {</span><span class="s2">\n        </span><span class="s1">if (fallbackIndex &lt; 0 &amp;&amp; index === 0) {</span><span class="s2">\n          </span><span class="s1">warningOnce(</span><span class="s2">\&quot;</span><span class="s1">route-fallback</span><span class="s2">\&quot;</span><span class="s1">, false, </span><span class="s2">\&quot;</span><span class="s1">No `HydrateFallback` element provided to render during initial hydration</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">shouldRenderHydrateFallback = true;</span><span class="s2">\n          </span><span class="s1">hydrateFallbackElement = null;</span><span class="s2">\n        </span><span class="s1">} else if (fallbackIndex === index) {</span><span class="s2">\n          </span><span class="s1">shouldRenderHydrateFallback = true;</span><span class="s2">\n          </span><span class="s1">hydrateFallbackElement = match.route.hydrateFallbackElement || null;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let matches2 = parentMatches.concat(renderedMatches.slice(0, index + 1));</span><span class="s2">\n    </span><span class="s1">let getChildren = () =&gt; {</span><span class="s2">\n      </span><span class="s1">let children;</span><span class="s2">\n      </span><span class="s1">if (error) {</span><span class="s2">\n        </span><span class="s1">children = errorElement;</span><span class="s2">\n      </span><span class="s1">} else if (shouldRenderHydrateFallback) {</span><span class="s2">\n        </span><span class="s1">children = hydrateFallbackElement;</span><span class="s2">\n      </span><span class="s1">} else if (match.route.Component) {</span><span class="s2">\n        </span><span class="s1">children = /* @__PURE__ */React2.createElement(match.route.Component, null);</span><span class="s2">\n      </span><span class="s1">} else if (match.route.element) {</span><span class="s2">\n        </span><span class="s1">children = match.route.element;</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">children = outlet;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return /* @__PURE__ */React2.createElement(RenderedRoute, {</span><span class="s2">\n        </span><span class="s1">match,</span><span class="s2">\n        </span><span class="s1">routeContext: {</span><span class="s2">\n          </span><span class="s1">outlet,</span><span class="s2">\n          </span><span class="s1">matches: matches2,</span><span class="s2">\n          </span><span class="s1">isDataRoute: dataRouterState != null</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">children</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">return dataRouterState &amp;&amp; (match.route.ErrorBoundary || match.route.errorElement || index === 0) ? /* @__PURE__ */React2.createElement(RenderErrorBoundary, {</span><span class="s2">\n      </span><span class="s1">location: dataRouterState.location,</span><span class="s2">\n      </span><span class="s1">revalidation: dataRouterState.revalidation,</span><span class="s2">\n      </span><span class="s1">component: errorElement,</span><span class="s2">\n      </span><span class="s1">error,</span><span class="s2">\n      </span><span class="s1">children: getChildren(),</span><span class="s2">\n      </span><span class="s1">routeContext: {</span><span class="s2">\n        </span><span class="s1">outlet: null,</span><span class="s2">\n        </span><span class="s1">matches: matches2,</span><span class="s2">\n        </span><span class="s1">isDataRoute: true</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}) : getChildren();</span><span class="s2">\n  </span><span class="s1">}, null);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getDataRouterConsoleError(hookName) {</span><span class="s2">\n  </span><span class="s1">return `${hookName} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useDataRouterContext(hookName) {</span><span class="s2">\n  </span><span class="s1">let ctx = React2.useContext(DataRouterContext);</span><span class="s2">\n  </span><span class="s1">invariant(ctx, getDataRouterConsoleError(hookName));</span><span class="s2">\n  </span><span class="s1">return ctx;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useDataRouterState(hookName) {</span><span class="s2">\n  </span><span class="s1">let state = React2.useContext(DataRouterStateContext);</span><span class="s2">\n  </span><span class="s1">invariant(state, getDataRouterConsoleError(hookName));</span><span class="s2">\n  </span><span class="s1">return state;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useRouteContext(hookName) {</span><span class="s2">\n  </span><span class="s1">let route = React2.useContext(RouteContext);</span><span class="s2">\n  </span><span class="s1">invariant(route, getDataRouterConsoleError(hookName));</span><span class="s2">\n  </span><span class="s1">return route;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useCurrentRouteId(hookName) {</span><span class="s2">\n  </span><span class="s1">let route = useRouteContext(hookName);</span><span class="s2">\n  </span><span class="s1">let thisRoute = route.matches[route.matches.length - 1];</span><span class="s2">\n  </span><span class="s1">invariant(thisRoute.route.id, `${hookName} can only be used on routes that contain a unique </span><span class="s2">\&quot;</span><span class="s1">id</span><span class="s2">\&quot;</span><span class="s1">`);</span><span class="s2">\n  </span><span class="s1">return thisRoute.route.id;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useRouteId() {</span><span class="s2">\n  </span><span class="s1">return useCurrentRouteId(</span><span class="s2">\&quot;</span><span class="s1">useRouteId</span><span class="s2">\&quot; </span><span class="s1">/* UseRouteId */);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useNavigation() {</span><span class="s2">\n  </span><span class="s1">let state = useDataRouterState(</span><span class="s2">\&quot;</span><span class="s1">useNavigation</span><span class="s2">\&quot; </span><span class="s1">/* UseNavigation */);</span><span class="s2">\n  </span><span class="s1">return state.navigation;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useRevalidator() {</span><span class="s2">\n  </span><span class="s1">let dataRouterContext = useDataRouterContext(</span><span class="s2">\&quot;</span><span class="s1">useRevalidator</span><span class="s2">\&quot; </span><span class="s1">/* UseRevalidator */);</span><span class="s2">\n  </span><span class="s1">let state = useDataRouterState(</span><span class="s2">\&quot;</span><span class="s1">useRevalidator</span><span class="s2">\&quot; </span><span class="s1">/* UseRevalidator */);</span><span class="s2">\n  </span><span class="s1">let revalidate = React2.useCallback(async () =&gt; {</span><span class="s2">\n    </span><span class="s1">await dataRouterContext.router.revalidate();</span><span class="s2">\n  </span><span class="s1">}, [dataRouterContext.router]);</span><span class="s2">\n  </span><span class="s1">return React2.useMemo(() =&gt; ({</span><span class="s2">\n    </span><span class="s1">revalidate,</span><span class="s2">\n    </span><span class="s1">state: state.revalidation</span><span class="s2">\n  </span><span class="s1">}), [revalidate, state.revalidation]);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useMatches() {</span><span class="s2">\n  </span><span class="s1">let {</span><span class="s2">\n    </span><span class="s1">matches,</span><span class="s2">\n    </span><span class="s1">loaderData</span><span class="s2">\n  </span><span class="s1">} = useDataRouterState(</span><span class="s2">\&quot;</span><span class="s1">useMatches</span><span class="s2">\&quot; </span><span class="s1">/* UseMatches */);</span><span class="s2">\n  </span><span class="s1">return React2.useMemo(() =&gt; matches.map(m =&gt; convertRouteMatchToUiMatch(m, loaderData)), [matches, loaderData]);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useLoaderData() {</span><span class="s2">\n  </span><span class="s1">let state = useDataRouterState(</span><span class="s2">\&quot;</span><span class="s1">useLoaderData</span><span class="s2">\&quot; </span><span class="s1">/* UseLoaderData */);</span><span class="s2">\n  </span><span class="s1">let routeId = useCurrentRouteId(</span><span class="s2">\&quot;</span><span class="s1">useLoaderData</span><span class="s2">\&quot; </span><span class="s1">/* UseLoaderData */);</span><span class="s2">\n  </span><span class="s1">return state.loaderData[routeId];</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useRouteLoaderData(routeId) {</span><span class="s2">\n  </span><span class="s1">let state = useDataRouterState(</span><span class="s2">\&quot;</span><span class="s1">useRouteLoaderData</span><span class="s2">\&quot; </span><span class="s1">/* UseRouteLoaderData */);</span><span class="s2">\n  </span><span class="s1">return state.loaderData[routeId];</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useActionData() {</span><span class="s2">\n  </span><span class="s1">let state = useDataRouterState(</span><span class="s2">\&quot;</span><span class="s1">useActionData</span><span class="s2">\&quot; </span><span class="s1">/* UseActionData */);</span><span class="s2">\n  </span><span class="s1">let routeId = useCurrentRouteId(</span><span class="s2">\&quot;</span><span class="s1">useLoaderData</span><span class="s2">\&quot; </span><span class="s1">/* UseLoaderData */);</span><span class="s2">\n  </span><span class="s1">return state.actionData ? state.actionData[routeId] : void 0;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useRouteError() {</span><span class="s2">\n  </span><span class="s1">let error = React2.useContext(RouteErrorContext);</span><span class="s2">\n  </span><span class="s1">let state = useDataRouterState(</span><span class="s2">\&quot;</span><span class="s1">useRouteError</span><span class="s2">\&quot; </span><span class="s1">/* UseRouteError */);</span><span class="s2">\n  </span><span class="s1">let routeId = useCurrentRouteId(</span><span class="s2">\&quot;</span><span class="s1">useRouteError</span><span class="s2">\&quot; </span><span class="s1">/* UseRouteError */);</span><span class="s2">\n  </span><span class="s1">if (error !== void 0) {</span><span class="s2">\n    </span><span class="s1">return error;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return state.errors?.[routeId];</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useAsyncValue() {</span><span class="s2">\n  </span><span class="s1">let value = React2.useContext(AwaitContext);</span><span class="s2">\n  </span><span class="s1">return value?._data;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useAsyncError() {</span><span class="s2">\n  </span><span class="s1">let value = React2.useContext(AwaitContext);</span><span class="s2">\n  </span><span class="s1">return value?._error;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var blockerId = 0;</span><span class="s2">\n</span><span class="s1">function useBlocker(shouldBlock) {</span><span class="s2">\n  </span><span class="s1">let {</span><span class="s2">\n    </span><span class="s1">router,</span><span class="s2">\n    </span><span class="s1">basename</span><span class="s2">\n  </span><span class="s1">} = useDataRouterContext(</span><span class="s2">\&quot;</span><span class="s1">useBlocker</span><span class="s2">\&quot; </span><span class="s1">/* UseBlocker */);</span><span class="s2">\n  </span><span class="s1">let state = useDataRouterState(</span><span class="s2">\&quot;</span><span class="s1">useBlocker</span><span class="s2">\&quot; </span><span class="s1">/* UseBlocker */);</span><span class="s2">\n  </span><span class="s1">let [blockerKey, setBlockerKey] = React2.useState(</span><span class="s2">\&quot;\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let blockerFunction = React2.useCallback(arg =&gt; {</span><span class="s2">\n    </span><span class="s1">if (typeof shouldBlock !== </span><span class="s2">\&quot;</span><span class="s1">function</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">return !!shouldBlock;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (basename === </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">return shouldBlock(arg);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let {</span><span class="s2">\n      </span><span class="s1">currentLocation,</span><span class="s2">\n      </span><span class="s1">nextLocation,</span><span class="s2">\n      </span><span class="s1">historyAction</span><span class="s2">\n    </span><span class="s1">} = arg;</span><span class="s2">\n    </span><span class="s1">return shouldBlock({</span><span class="s2">\n      </span><span class="s1">currentLocation: {</span><span class="s2">\n        </span><span class="s1">...currentLocation,</span><span class="s2">\n        </span><span class="s1">pathname: stripBasename(currentLocation.pathname, basename) || currentLocation.pathname</span><span class="s2">\n      </span><span class="s1">},</span><span class="s2">\n      </span><span class="s1">nextLocation: {</span><span class="s2">\n        </span><span class="s1">...nextLocation,</span><span class="s2">\n        </span><span class="s1">pathname: stripBasename(nextLocation.pathname, basename) || nextLocation.pathname</span><span class="s2">\n      </span><span class="s1">},</span><span class="s2">\n      </span><span class="s1">historyAction</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}, [basename, shouldBlock]);</span><span class="s2">\n  </span><span class="s1">React2.useEffect(() =&gt; {</span><span class="s2">\n    </span><span class="s1">let key = String(++blockerId);</span><span class="s2">\n    </span><span class="s1">setBlockerKey(key);</span><span class="s2">\n    </span><span class="s1">return () =&gt; router.deleteBlocker(key);</span><span class="s2">\n  </span><span class="s1">}, [router]);</span><span class="s2">\n  </span><span class="s1">React2.useEffect(() =&gt; {</span><span class="s2">\n    </span><span class="s1">if (blockerKey !== </span><span class="s2">\&quot;\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">router.getBlocker(blockerKey, blockerFunction);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}, [router, blockerKey, blockerFunction]);</span><span class="s2">\n  </span><span class="s1">return blockerKey &amp;&amp; state.blockers.has(blockerKey) ? state.blockers.get(blockerKey) : IDLE_BLOCKER;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useNavigateStable() {</span><span class="s2">\n  </span><span class="s1">let {</span><span class="s2">\n    </span><span class="s1">router</span><span class="s2">\n  </span><span class="s1">} = useDataRouterContext(</span><span class="s2">\&quot;</span><span class="s1">useNavigate</span><span class="s2">\&quot; </span><span class="s1">/* UseNavigateStable */);</span><span class="s2">\n  </span><span class="s1">let id = useCurrentRouteId(</span><span class="s2">\&quot;</span><span class="s1">useNavigate</span><span class="s2">\&quot; </span><span class="s1">/* UseNavigateStable */);</span><span class="s2">\n  </span><span class="s1">let activeRef = React2.useRef(false);</span><span class="s2">\n  </span><span class="s1">useIsomorphicLayoutEffect(() =&gt; {</span><span class="s2">\n    </span><span class="s1">activeRef.current = true;</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">let navigate = React2.useCallback(async (to, options = {}) =&gt; {</span><span class="s2">\n    </span><span class="s1">warning(activeRef.current, navigateEffectWarning);</span><span class="s2">\n    </span><span class="s1">if (!activeRef.current) return;</span><span class="s2">\n    </span><span class="s1">if (typeof to === </span><span class="s2">\&quot;</span><span class="s1">number</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">router.navigate(to);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">await router.navigate(to, {</span><span class="s2">\n        </span><span class="s1">fromRouteId: id,</span><span class="s2">\n        </span><span class="s1">...options</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}, [router, id]);</span><span class="s2">\n  </span><span class="s1">return navigate;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var alreadyWarned = {};</span><span class="s2">\n</span><span class="s1">function warningOnce(key, cond, message) {</span><span class="s2">\n  </span><span class="s1">if (!cond &amp;&amp; !alreadyWarned[key]) {</span><span class="s2">\n    </span><span class="s1">alreadyWarned[key] = true;</span><span class="s2">\n    </span><span class="s1">warning(false, message);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/server-runtime/warnings.ts</span><span class="s2">\n</span><span class="s1">var alreadyWarned2 = {};</span><span class="s2">\n</span><span class="s1">function warnOnce(condition, message) {</span><span class="s2">\n  </span><span class="s1">if (!condition &amp;&amp; !alreadyWarned2[message]) {</span><span class="s2">\n    </span><span class="s1">alreadyWarned2[message] = true;</span><span class="s2">\n    </span><span class="s1">console.warn(message);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/components.tsx</span><span class="s2">\n</span><span class="s1">function mapRouteProperties(route) {</span><span class="s2">\n  </span><span class="s1">let updates = {</span><span class="s2">\n    </span><span class="s1">// Note: this check also occurs in createRoutesFromChildren so update</span><span class="s2">\n    </span><span class="s1">// there if you change this -- please and thank you!</span><span class="s2">\n    </span><span class="s1">hasErrorBoundary: route.hasErrorBoundary || route.ErrorBoundary != null || route.errorElement != null</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">if (route.Component) {</span><span class="s2">\n    </span><span class="s1">if (ENABLE_DEV_WARNINGS) {</span><span class="s2">\n      </span><span class="s1">if (route.element) {</span><span class="s2">\n        </span><span class="s1">warning(false, </span><span class="s2">\&quot;</span><span class="s1">You should not include both `Component` and `element` on your route - `Component` will be used.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">Object.assign(updates, {</span><span class="s2">\n      </span><span class="s1">element: React3.createElement(route.Component),</span><span class="s2">\n      </span><span class="s1">Component: void 0</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (route.HydrateFallback) {</span><span class="s2">\n    </span><span class="s1">if (ENABLE_DEV_WARNINGS) {</span><span class="s2">\n      </span><span class="s1">if (route.hydrateFallbackElement) {</span><span class="s2">\n        </span><span class="s1">warning(false, </span><span class="s2">\&quot;</span><span class="s1">You should not include both `HydrateFallback` and `hydrateFallbackElement` on your route - `HydrateFallback` will be used.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">Object.assign(updates, {</span><span class="s2">\n      </span><span class="s1">hydrateFallbackElement: React3.createElement(route.HydrateFallback),</span><span class="s2">\n      </span><span class="s1">HydrateFallback: void 0</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (route.ErrorBoundary) {</span><span class="s2">\n    </span><span class="s1">if (ENABLE_DEV_WARNINGS) {</span><span class="s2">\n      </span><span class="s1">if (route.errorElement) {</span><span class="s2">\n        </span><span class="s1">warning(false, </span><span class="s2">\&quot;</span><span class="s1">You should not include both `ErrorBoundary` and `errorElement` on your route - `ErrorBoundary` will be used.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">Object.assign(updates, {</span><span class="s2">\n      </span><span class="s1">errorElement: React3.createElement(route.ErrorBoundary),</span><span class="s2">\n      </span><span class="s1">ErrorBoundary: void 0</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return updates;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var hydrationRouteProperties = [</span><span class="s2">\&quot;</span><span class="s1">HydrateFallback</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">hydrateFallbackElement</span><span class="s2">\&quot;</span><span class="s1">];</span><span class="s2">\n</span><span class="s1">function createMemoryRouter(routes, opts) {</span><span class="s2">\n  </span><span class="s1">return createRouter({</span><span class="s2">\n    </span><span class="s1">basename: opts?.basename,</span><span class="s2">\n    </span><span class="s1">unstable_getContext: opts?.unstable_getContext,</span><span class="s2">\n    </span><span class="s1">future: opts?.future,</span><span class="s2">\n    </span><span class="s1">history: createMemoryHistory({</span><span class="s2">\n      </span><span class="s1">initialEntries: opts?.initialEntries,</span><span class="s2">\n      </span><span class="s1">initialIndex: opts?.initialIndex</span><span class="s2">\n    </span><span class="s1">}),</span><span class="s2">\n    </span><span class="s1">hydrationData: opts?.hydrationData,</span><span class="s2">\n    </span><span class="s1">routes,</span><span class="s2">\n    </span><span class="s1">hydrationRouteProperties,</span><span class="s2">\n    </span><span class="s1">mapRouteProperties,</span><span class="s2">\n    </span><span class="s1">dataStrategy: opts?.dataStrategy,</span><span class="s2">\n    </span><span class="s1">patchRoutesOnNavigation: opts?.patchRoutesOnNavigation</span><span class="s2">\n  </span><span class="s1">}).initialize();</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var Deferred = class {</span><span class="s2">\n  </span><span class="s1">constructor() {</span><span class="s2">\n    </span><span class="s1">this.status = </span><span class="s2">\&quot;</span><span class="s1">pending</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">this.promise = new Promise((resolve, reject) =&gt; {</span><span class="s2">\n      </span><span class="s1">this.resolve = value =&gt; {</span><span class="s2">\n        </span><span class="s1">if (this.status === </span><span class="s2">\&quot;</span><span class="s1">pending</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">this.status = </span><span class="s2">\&quot;</span><span class="s1">resolved</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n          </span><span class="s1">resolve(value);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">this.reject = reason =&gt; {</span><span class="s2">\n        </span><span class="s1">if (this.status === </span><span class="s2">\&quot;</span><span class="s1">pending</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">this.status = </span><span class="s2">\&quot;</span><span class="s1">rejected</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n          </span><span class="s1">reject(reason);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">function RouterProvider({</span><span class="s2">\n  </span><span class="s1">router,</span><span class="s2">\n  </span><span class="s1">flushSync: reactDomFlushSyncImpl</span><span class="s2">\n</span><span class="s1">}) {</span><span class="s2">\n  </span><span class="s1">let [state, setStateImpl] = React3.useState(router.state);</span><span class="s2">\n  </span><span class="s1">let [pendingState, setPendingState] = React3.useState();</span><span class="s2">\n  </span><span class="s1">let [vtContext, setVtContext] = React3.useState({</span><span class="s2">\n    </span><span class="s1">isTransitioning: false</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">let [renderDfd, setRenderDfd] = React3.useState();</span><span class="s2">\n  </span><span class="s1">let [transition, setTransition] = React3.useState();</span><span class="s2">\n  </span><span class="s1">let [interruption, setInterruption] = React3.useState();</span><span class="s2">\n  </span><span class="s1">let fetcherData = React3.useRef(/* @__PURE__ */new Map());</span><span class="s2">\n  </span><span class="s1">let setState = React3.useCallback((newState, {</span><span class="s2">\n    </span><span class="s1">deletedFetchers,</span><span class="s2">\n    </span><span class="s1">flushSync,</span><span class="s2">\n    </span><span class="s1">viewTransitionOpts</span><span class="s2">\n  </span><span class="s1">}) =&gt; {</span><span class="s2">\n    </span><span class="s1">newState.fetchers.forEach((fetcher, key) =&gt; {</span><span class="s2">\n      </span><span class="s1">if (fetcher.data !== void 0) {</span><span class="s2">\n        </span><span class="s1">fetcherData.current.set(key, fetcher.data);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">deletedFetchers.forEach(key =&gt; fetcherData.current.delete(key));</span><span class="s2">\n    </span><span class="s1">warnOnce(flushSync === false || reactDomFlushSyncImpl != null, 'You provided the `flushSync` option to a router update, but you are not using the `&lt;RouterProvider&gt;` from `react-router/dom` so `ReactDOM.flushSync()` is unavailable.  Please update your app to `import { RouterProvider } from </span><span class="s2">\&quot;</span><span class="s1">react-router/dom</span><span class="s2">\&quot;</span><span class="s1">` and ensure you have `react-dom` installed as a dependency to use the `flushSync` option.');</span><span class="s2">\n    </span><span class="s1">let isViewTransitionAvailable = router.window != null &amp;&amp; router.window.document != null &amp;&amp; typeof router.window.document.startViewTransition === </span><span class="s2">\&quot;</span><span class="s1">function</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">warnOnce(viewTransitionOpts == null || isViewTransitionAvailable, </span><span class="s2">\&quot;</span><span class="s1">You provided the `viewTransition` option to a router update, but you do not appear to be running in a DOM environment as `window.startViewTransition` is not available.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">if (!viewTransitionOpts || !isViewTransitionAvailable) {</span><span class="s2">\n      </span><span class="s1">if (reactDomFlushSyncImpl &amp;&amp; flushSync) {</span><span class="s2">\n        </span><span class="s1">reactDomFlushSyncImpl(() =&gt; setStateImpl(newState));</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">React3.startTransition(() =&gt; setStateImpl(newState));</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (reactDomFlushSyncImpl &amp;&amp; flushSync) {</span><span class="s2">\n      </span><span class="s1">reactDomFlushSyncImpl(() =&gt; {</span><span class="s2">\n        </span><span class="s1">if (transition) {</span><span class="s2">\n          </span><span class="s1">renderDfd &amp;&amp; renderDfd.resolve();</span><span class="s2">\n          </span><span class="s1">transition.skipTransition();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">setVtContext({</span><span class="s2">\n          </span><span class="s1">isTransitioning: true,</span><span class="s2">\n          </span><span class="s1">flushSync: true,</span><span class="s2">\n          </span><span class="s1">currentLocation: viewTransitionOpts.currentLocation,</span><span class="s2">\n          </span><span class="s1">nextLocation: viewTransitionOpts.nextLocation</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">let t = router.window.document.startViewTransition(() =&gt; {</span><span class="s2">\n        </span><span class="s1">reactDomFlushSyncImpl(() =&gt; setStateImpl(newState));</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">t.finished.finally(() =&gt; {</span><span class="s2">\n        </span><span class="s1">reactDomFlushSyncImpl(() =&gt; {</span><span class="s2">\n          </span><span class="s1">setRenderDfd(void 0);</span><span class="s2">\n          </span><span class="s1">setTransition(void 0);</span><span class="s2">\n          </span><span class="s1">setPendingState(void 0);</span><span class="s2">\n          </span><span class="s1">setVtContext({</span><span class="s2">\n            </span><span class="s1">isTransitioning: false</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">reactDomFlushSyncImpl(() =&gt; setTransition(t));</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (transition) {</span><span class="s2">\n      </span><span class="s1">renderDfd &amp;&amp; renderDfd.resolve();</span><span class="s2">\n      </span><span class="s1">transition.skipTransition();</span><span class="s2">\n      </span><span class="s1">setInterruption({</span><span class="s2">\n        </span><span class="s1">state: newState,</span><span class="s2">\n        </span><span class="s1">currentLocation: viewTransitionOpts.currentLocation,</span><span class="s2">\n        </span><span class="s1">nextLocation: viewTransitionOpts.nextLocation</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">setPendingState(newState);</span><span class="s2">\n      </span><span class="s1">setVtContext({</span><span class="s2">\n        </span><span class="s1">isTransitioning: true,</span><span class="s2">\n        </span><span class="s1">flushSync: false,</span><span class="s2">\n        </span><span class="s1">currentLocation: viewTransitionOpts.currentLocation,</span><span class="s2">\n        </span><span class="s1">nextLocation: viewTransitionOpts.nextLocation</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}, [router.window, reactDomFlushSyncImpl, transition, renderDfd]);</span><span class="s2">\n  </span><span class="s1">React3.useLayoutEffect(() =&gt; router.subscribe(setState), [router, setState]);</span><span class="s2">\n  </span><span class="s1">React3.useEffect(() =&gt; {</span><span class="s2">\n    </span><span class="s1">if (vtContext.isTransitioning &amp;&amp; !vtContext.flushSync) {</span><span class="s2">\n      </span><span class="s1">setRenderDfd(new Deferred());</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}, [vtContext]);</span><span class="s2">\n  </span><span class="s1">React3.useEffect(() =&gt; {</span><span class="s2">\n    </span><span class="s1">if (renderDfd &amp;&amp; pendingState &amp;&amp; router.window) {</span><span class="s2">\n      </span><span class="s1">let newState = pendingState;</span><span class="s2">\n      </span><span class="s1">let renderPromise = renderDfd.promise;</span><span class="s2">\n      </span><span class="s1">let transition2 = router.window.document.startViewTransition(async () =&gt; {</span><span class="s2">\n        </span><span class="s1">React3.startTransition(() =&gt; setStateImpl(newState));</span><span class="s2">\n        </span><span class="s1">await renderPromise;</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">transition2.finished.finally(() =&gt; {</span><span class="s2">\n        </span><span class="s1">setRenderDfd(void 0);</span><span class="s2">\n        </span><span class="s1">setTransition(void 0);</span><span class="s2">\n        </span><span class="s1">setPendingState(void 0);</span><span class="s2">\n        </span><span class="s1">setVtContext({</span><span class="s2">\n          </span><span class="s1">isTransitioning: false</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">setTransition(transition2);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}, [pendingState, renderDfd, router.window]);</span><span class="s2">\n  </span><span class="s1">React3.useEffect(() =&gt; {</span><span class="s2">\n    </span><span class="s1">if (renderDfd &amp;&amp; pendingState &amp;&amp; state.location.key === pendingState.location.key) {</span><span class="s2">\n      </span><span class="s1">renderDfd.resolve();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}, [renderDfd, transition, state.location, pendingState]);</span><span class="s2">\n  </span><span class="s1">React3.useEffect(() =&gt; {</span><span class="s2">\n    </span><span class="s1">if (!vtContext.isTransitioning &amp;&amp; interruption) {</span><span class="s2">\n      </span><span class="s1">setPendingState(interruption.state);</span><span class="s2">\n      </span><span class="s1">setVtContext({</span><span class="s2">\n        </span><span class="s1">isTransitioning: true,</span><span class="s2">\n        </span><span class="s1">flushSync: false,</span><span class="s2">\n        </span><span class="s1">currentLocation: interruption.currentLocation,</span><span class="s2">\n        </span><span class="s1">nextLocation: interruption.nextLocation</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">setInterruption(void 0);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}, [vtContext.isTransitioning, interruption]);</span><span class="s2">\n  </span><span class="s1">let navigator = React3.useMemo(() =&gt; {</span><span class="s2">\n    </span><span class="s1">return {</span><span class="s2">\n      </span><span class="s1">createHref: router.createHref,</span><span class="s2">\n      </span><span class="s1">encodeLocation: router.encodeLocation,</span><span class="s2">\n      </span><span class="s1">go: n =&gt; router.navigate(n),</span><span class="s2">\n      </span><span class="s1">push: (to, state2, opts) =&gt; router.navigate(to, {</span><span class="s2">\n        </span><span class="s1">state: state2,</span><span class="s2">\n        </span><span class="s1">preventScrollReset: opts?.preventScrollReset</span><span class="s2">\n      </span><span class="s1">}),</span><span class="s2">\n      </span><span class="s1">replace: (to, state2, opts) =&gt; router.navigate(to, {</span><span class="s2">\n        </span><span class="s1">replace: true,</span><span class="s2">\n        </span><span class="s1">state: state2,</span><span class="s2">\n        </span><span class="s1">preventScrollReset: opts?.preventScrollReset</span><span class="s2">\n      </span><span class="s1">})</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}, [router]);</span><span class="s2">\n  </span><span class="s1">let basename = router.basename || </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">let dataRouterContext = React3.useMemo(() =&gt; ({</span><span class="s2">\n    </span><span class="s1">router,</span><span class="s2">\n    </span><span class="s1">navigator,</span><span class="s2">\n    </span><span class="s1">static: false,</span><span class="s2">\n    </span><span class="s1">basename</span><span class="s2">\n  </span><span class="s1">}), [router, navigator, basename]);</span><span class="s2">\n  </span><span class="s1">return /* @__PURE__ */React3.createElement(React3.Fragment, null, /* @__PURE__ */React3.createElement(DataRouterContext.Provider, {</span><span class="s2">\n    </span><span class="s1">value: dataRouterContext</span><span class="s2">\n  </span><span class="s1">}, /* @__PURE__ */React3.createElement(DataRouterStateContext.Provider, {</span><span class="s2">\n    </span><span class="s1">value: state</span><span class="s2">\n  </span><span class="s1">}, /* @__PURE__ */React3.createElement(FetchersContext.Provider, {</span><span class="s2">\n    </span><span class="s1">value: fetcherData.current</span><span class="s2">\n  </span><span class="s1">}, /* @__PURE__ */React3.createElement(ViewTransitionContext.Provider, {</span><span class="s2">\n    </span><span class="s1">value: vtContext</span><span class="s2">\n  </span><span class="s1">}, /* @__PURE__ */React3.createElement(Router, {</span><span class="s2">\n    </span><span class="s1">basename,</span><span class="s2">\n    </span><span class="s1">location: state.location,</span><span class="s2">\n    </span><span class="s1">navigationType: state.historyAction,</span><span class="s2">\n    </span><span class="s1">navigator</span><span class="s2">\n  </span><span class="s1">}, /* @__PURE__ */React3.createElement(MemoizedDataRoutes, {</span><span class="s2">\n    </span><span class="s1">routes: router.routes,</span><span class="s2">\n    </span><span class="s1">future: router.future,</span><span class="s2">\n    </span><span class="s1">state</span><span class="s2">\n  </span><span class="s1">})))))), null);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var MemoizedDataRoutes = React3.memo(DataRoutes);</span><span class="s2">\n</span><span class="s1">function DataRoutes({</span><span class="s2">\n  </span><span class="s1">routes,</span><span class="s2">\n  </span><span class="s1">future,</span><span class="s2">\n  </span><span class="s1">state</span><span class="s2">\n</span><span class="s1">}) {</span><span class="s2">\n  </span><span class="s1">return useRoutesImpl(routes, void 0, state, future);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function MemoryRouter({</span><span class="s2">\n  </span><span class="s1">basename,</span><span class="s2">\n  </span><span class="s1">children,</span><span class="s2">\n  </span><span class="s1">initialEntries,</span><span class="s2">\n  </span><span class="s1">initialIndex</span><span class="s2">\n</span><span class="s1">}) {</span><span class="s2">\n  </span><span class="s1">let historyRef = React3.useRef();</span><span class="s2">\n  </span><span class="s1">if (historyRef.current == null) {</span><span class="s2">\n    </span><span class="s1">historyRef.current = createMemoryHistory({</span><span class="s2">\n      </span><span class="s1">initialEntries,</span><span class="s2">\n      </span><span class="s1">initialIndex,</span><span class="s2">\n      </span><span class="s1">v5Compat: true</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let history = historyRef.current;</span><span class="s2">\n  </span><span class="s1">let [state, setStateImpl] = React3.useState({</span><span class="s2">\n    </span><span class="s1">action: history.action,</span><span class="s2">\n    </span><span class="s1">location: history.location</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">let setState = React3.useCallback(newState =&gt; {</span><span class="s2">\n    </span><span class="s1">React3.startTransition(() =&gt; setStateImpl(newState));</span><span class="s2">\n  </span><span class="s1">}, [setStateImpl]);</span><span class="s2">\n  </span><span class="s1">React3.useLayoutEffect(() =&gt; history.listen(setState), [history, setState]);</span><span class="s2">\n  </span><span class="s1">return /* @__PURE__ */React3.createElement(Router, {</span><span class="s2">\n    </span><span class="s1">basename,</span><span class="s2">\n    </span><span class="s1">children,</span><span class="s2">\n    </span><span class="s1">location: state.location,</span><span class="s2">\n    </span><span class="s1">navigationType: state.action,</span><span class="s2">\n    </span><span class="s1">navigator: history</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function Navigate({</span><span class="s2">\n  </span><span class="s1">to,</span><span class="s2">\n  </span><span class="s1">replace: replace2,</span><span class="s2">\n  </span><span class="s1">state,</span><span class="s2">\n  </span><span class="s1">relative</span><span class="s2">\n</span><span class="s1">}) {</span><span class="s2">\n  </span><span class="s1">invariant(useInRouterContext(),</span><span class="s2">\n  </span><span class="s1">// TODO: This error is probably because they somehow have 2 versions of</span><span class="s2">\n  </span><span class="s1">// the router loaded. We can help them understand how to avoid that.</span><span class="s2">\n  </span><span class="s1">`&lt;Navigate&gt; may be used only in the context of a &lt;Router&gt; component.`);</span><span class="s2">\n  </span><span class="s1">let {</span><span class="s2">\n    </span><span class="s1">static: isStatic</span><span class="s2">\n  </span><span class="s1">} = React3.useContext(NavigationContext);</span><span class="s2">\n  </span><span class="s1">warning(!isStatic, `&lt;Navigate&gt; must not be used on the initial render in a &lt;StaticRouter&gt;. This is a no-op, but you should modify your code so the &lt;Navigate&gt; is only ever rendered in response to some user interaction or state change.`);</span><span class="s2">\n  </span><span class="s1">let {</span><span class="s2">\n    </span><span class="s1">matches</span><span class="s2">\n  </span><span class="s1">} = React3.useContext(RouteContext);</span><span class="s2">\n  </span><span class="s1">let {</span><span class="s2">\n    </span><span class="s1">pathname: locationPathname</span><span class="s2">\n  </span><span class="s1">} = useLocation();</span><span class="s2">\n  </span><span class="s1">let navigate = useNavigate();</span><span class="s2">\n  </span><span class="s1">let path = resolveTo(to, getResolveToMatches(matches), locationPathname, relative === </span><span class="s2">\&quot;</span><span class="s1">path</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let jsonPath = JSON.stringify(path);</span><span class="s2">\n  </span><span class="s1">React3.useEffect(() =&gt; {</span><span class="s2">\n    </span><span class="s1">navigate(JSON.parse(jsonPath), {</span><span class="s2">\n      </span><span class="s1">replace: replace2,</span><span class="s2">\n      </span><span class="s1">state,</span><span class="s2">\n      </span><span class="s1">relative</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}, [navigate, jsonPath, relative, replace2, state]);</span><span class="s2">\n  </span><span class="s1">return null;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function Outlet(props) {</span><span class="s2">\n  </span><span class="s1">return useOutlet(props.context);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function Route(_props) {</span><span class="s2">\n  </span><span class="s1">invariant(false, `A &lt;Route&gt; is only ever to be used as the child of &lt;Routes&gt; element, never rendered directly. Please wrap your &lt;Route&gt; in a &lt;Routes&gt;.`);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function Router({</span><span class="s2">\n  </span><span class="s1">basename: basenameProp = </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">children = null,</span><span class="s2">\n  </span><span class="s1">location: locationProp,</span><span class="s2">\n  </span><span class="s1">navigationType = </span><span class="s2">\&quot;</span><span class="s1">POP</span><span class="s2">\&quot; </span><span class="s1">/* Pop */,</span><span class="s2">\n  </span><span class="s1">navigator,</span><span class="s2">\n  </span><span class="s1">static: staticProp = false</span><span class="s2">\n</span><span class="s1">}) {</span><span class="s2">\n  </span><span class="s1">invariant(!useInRouterContext(), `You cannot render a &lt;Router&gt; inside another &lt;Router&gt;. You should never have more than one in your app.`);</span><span class="s2">\n  </span><span class="s1">let basename = basenameProp.replace(/^</span><span class="s2">\\</span><span class="s1">/*/, </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let navigationContext = React3.useMemo(() =&gt; ({</span><span class="s2">\n    </span><span class="s1">basename,</span><span class="s2">\n    </span><span class="s1">navigator,</span><span class="s2">\n    </span><span class="s1">static: staticProp,</span><span class="s2">\n    </span><span class="s1">future: {}</span><span class="s2">\n  </span><span class="s1">}), [basename, navigator, staticProp]);</span><span class="s2">\n  </span><span class="s1">if (typeof locationProp === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">locationProp = parsePath(locationProp);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let {</span><span class="s2">\n    </span><span class="s1">pathname = </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">search = </span><span class="s2">\&quot;\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">hash = </span><span class="s2">\&quot;\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">state = null,</span><span class="s2">\n    </span><span class="s1">key = </span><span class="s2">\&quot;</span><span class="s1">default</span><span class="s2">\&quot;\n  </span><span class="s1">} = locationProp;</span><span class="s2">\n  </span><span class="s1">let locationContext = React3.useMemo(() =&gt; {</span><span class="s2">\n    </span><span class="s1">let trailingPathname = stripBasename(pathname, basename);</span><span class="s2">\n    </span><span class="s1">if (trailingPathname == null) {</span><span class="s2">\n      </span><span class="s1">return null;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return {</span><span class="s2">\n      </span><span class="s1">location: {</span><span class="s2">\n        </span><span class="s1">pathname: trailingPathname,</span><span class="s2">\n        </span><span class="s1">search,</span><span class="s2">\n        </span><span class="s1">hash,</span><span class="s2">\n        </span><span class="s1">state,</span><span class="s2">\n        </span><span class="s1">key</span><span class="s2">\n      </span><span class="s1">},</span><span class="s2">\n      </span><span class="s1">navigationType</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}, [basename, pathname, search, hash, state, key, navigationType]);</span><span class="s2">\n  </span><span class="s1">warning(locationContext != null, `&lt;Router basename=</span><span class="s2">\&quot;</span><span class="s1">${basename}</span><span class="s2">\&quot;</span><span class="s1">&gt; is not able to match the URL </span><span class="s2">\&quot;</span><span class="s1">${pathname}${search}${hash}</span><span class="s2">\&quot; </span><span class="s1">because it does not start with the basename, so the &lt;Router&gt; won't render anything.`);</span><span class="s2">\n  </span><span class="s1">if (locationContext == null) {</span><span class="s2">\n    </span><span class="s1">return null;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return /* @__PURE__ */React3.createElement(NavigationContext.Provider, {</span><span class="s2">\n    </span><span class="s1">value: navigationContext</span><span class="s2">\n  </span><span class="s1">}, /* @__PURE__ */React3.createElement(LocationContext.Provider, {</span><span class="s2">\n    </span><span class="s1">children,</span><span class="s2">\n    </span><span class="s1">value: locationContext</span><span class="s2">\n  </span><span class="s1">}));</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function Routes({</span><span class="s2">\n  </span><span class="s1">children,</span><span class="s2">\n  </span><span class="s1">location</span><span class="s2">\n</span><span class="s1">}) {</span><span class="s2">\n  </span><span class="s1">return useRoutes(createRoutesFromChildren(children), location);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function Await({</span><span class="s2">\n  </span><span class="s1">children,</span><span class="s2">\n  </span><span class="s1">errorElement,</span><span class="s2">\n  </span><span class="s1">resolve</span><span class="s2">\n</span><span class="s1">}) {</span><span class="s2">\n  </span><span class="s1">return /* @__PURE__ */React3.createElement(AwaitErrorBoundary, {</span><span class="s2">\n    </span><span class="s1">resolve,</span><span class="s2">\n    </span><span class="s1">errorElement</span><span class="s2">\n  </span><span class="s1">}, /* @__PURE__ */React3.createElement(ResolveAwait, null, children));</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var AwaitErrorBoundary = class extends React3.Component {</span><span class="s2">\n  </span><span class="s1">constructor(props) {</span><span class="s2">\n    </span><span class="s1">super(props);</span><span class="s2">\n    </span><span class="s1">this.state = {</span><span class="s2">\n      </span><span class="s1">error: null</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">static getDerivedStateFromError(error) {</span><span class="s2">\n    </span><span class="s1">return {</span><span class="s2">\n      </span><span class="s1">error</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">componentDidCatch(error, errorInfo) {</span><span class="s2">\n    </span><span class="s1">console.error(</span><span class="s2">\&quot;</span><span class="s1">&lt;Await&gt; caught the following error during render</span><span class="s2">\&quot;</span><span class="s1">, error, errorInfo);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">render() {</span><span class="s2">\n    </span><span class="s1">let {</span><span class="s2">\n      </span><span class="s1">children,</span><span class="s2">\n      </span><span class="s1">errorElement,</span><span class="s2">\n      </span><span class="s1">resolve</span><span class="s2">\n    </span><span class="s1">} = this.props;</span><span class="s2">\n    </span><span class="s1">let promise = null;</span><span class="s2">\n    </span><span class="s1">let status = 0 /* pending */;</span><span class="s2">\n    </span><span class="s1">if (!(resolve instanceof Promise)) {</span><span class="s2">\n      </span><span class="s1">status = 1 /* success */;</span><span class="s2">\n      </span><span class="s1">promise = Promise.resolve();</span><span class="s2">\n      </span><span class="s1">Object.defineProperty(promise, </span><span class="s2">\&quot;</span><span class="s1">_tracked</span><span class="s2">\&quot;</span><span class="s1">, {</span><span class="s2">\n        </span><span class="s1">get: () =&gt; true</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">Object.defineProperty(promise, </span><span class="s2">\&quot;</span><span class="s1">_data</span><span class="s2">\&quot;</span><span class="s1">, {</span><span class="s2">\n        </span><span class="s1">get: () =&gt; resolve</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">} else if (this.state.error) {</span><span class="s2">\n      </span><span class="s1">status = 2 /* error */;</span><span class="s2">\n      </span><span class="s1">let renderError = this.state.error;</span><span class="s2">\n      </span><span class="s1">promise = Promise.reject().catch(() =&gt; {});</span><span class="s2">\n      </span><span class="s1">Object.defineProperty(promise, </span><span class="s2">\&quot;</span><span class="s1">_tracked</span><span class="s2">\&quot;</span><span class="s1">, {</span><span class="s2">\n        </span><span class="s1">get: () =&gt; true</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">Object.defineProperty(promise, </span><span class="s2">\&quot;</span><span class="s1">_error</span><span class="s2">\&quot;</span><span class="s1">, {</span><span class="s2">\n        </span><span class="s1">get: () =&gt; renderError</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">} else if (resolve._tracked) {</span><span class="s2">\n      </span><span class="s1">promise = resolve;</span><span class="s2">\n      </span><span class="s1">status = </span><span class="s2">\&quot;</span><span class="s1">_error</span><span class="s2">\&quot; </span><span class="s1">in promise ? 2 /* error */ : </span><span class="s2">\&quot;</span><span class="s1">_data</span><span class="s2">\&quot; </span><span class="s1">in promise ? 1 /* success */ : 0 /* pending */;</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">status = 0 /* pending */;</span><span class="s2">\n      </span><span class="s1">Object.defineProperty(resolve, </span><span class="s2">\&quot;</span><span class="s1">_tracked</span><span class="s2">\&quot;</span><span class="s1">, {</span><span class="s2">\n        </span><span class="s1">get: () =&gt; true</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">promise = resolve.then(data2 =&gt; Object.defineProperty(resolve, </span><span class="s2">\&quot;</span><span class="s1">_data</span><span class="s2">\&quot;</span><span class="s1">, {</span><span class="s2">\n        </span><span class="s1">get: () =&gt; data2</span><span class="s2">\n      </span><span class="s1">}), error =&gt; Object.defineProperty(resolve, </span><span class="s2">\&quot;</span><span class="s1">_error</span><span class="s2">\&quot;</span><span class="s1">, {</span><span class="s2">\n        </span><span class="s1">get: () =&gt; error</span><span class="s2">\n      </span><span class="s1">}));</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (status === 2 /* error */ &amp;&amp; !errorElement) {</span><span class="s2">\n      </span><span class="s1">throw promise._error;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (status === 2 /* error */) {</span><span class="s2">\n      </span><span class="s1">return /* @__PURE__ */React3.createElement(AwaitContext.Provider, {</span><span class="s2">\n        </span><span class="s1">value: promise,</span><span class="s2">\n        </span><span class="s1">children: errorElement</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (status === 1 /* success */) {</span><span class="s2">\n      </span><span class="s1">return /* @__PURE__ */React3.createElement(AwaitContext.Provider, {</span><span class="s2">\n        </span><span class="s1">value: promise,</span><span class="s2">\n        </span><span class="s1">children</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">throw promise;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">function ResolveAwait({</span><span class="s2">\n  </span><span class="s1">children</span><span class="s2">\n</span><span class="s1">}) {</span><span class="s2">\n  </span><span class="s1">let data2 = useAsyncValue();</span><span class="s2">\n  </span><span class="s1">let toRender = typeof children === </span><span class="s2">\&quot;</span><span class="s1">function</span><span class="s2">\&quot; </span><span class="s1">? children(data2) : children;</span><span class="s2">\n  </span><span class="s1">return /* @__PURE__ */React3.createElement(React3.Fragment, null, toRender);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createRoutesFromChildren(children, parentPath = []) {</span><span class="s2">\n  </span><span class="s1">let routes = [];</span><span class="s2">\n  </span><span class="s1">React3.Children.forEach(children, (element, index) =&gt; {</span><span class="s2">\n    </span><span class="s1">if (!React3.isValidElement(element)) {</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let treePath = [...parentPath, index];</span><span class="s2">\n    </span><span class="s1">if (element.type === React3.Fragment) {</span><span class="s2">\n      </span><span class="s1">routes.push.apply(routes, createRoutesFromChildren(element.props.children, treePath));</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">invariant(element.type === Route, `[${typeof element.type === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">? element.type : element.type.name}] is not a &lt;Route&gt; component. All component children of &lt;Routes&gt; must be a &lt;Route&gt; or &lt;React.Fragment&gt;`);</span><span class="s2">\n    </span><span class="s1">invariant(!element.props.index || !element.props.children, </span><span class="s2">\&quot;</span><span class="s1">An index route cannot have child routes.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">let route = {</span><span class="s2">\n      </span><span class="s1">id: element.props.id || treePath.join(</span><span class="s2">\&quot;</span><span class="s1">-</span><span class="s2">\&quot;</span><span class="s1">),</span><span class="s2">\n      </span><span class="s1">caseSensitive: element.props.caseSensitive,</span><span class="s2">\n      </span><span class="s1">element: element.props.element,</span><span class="s2">\n      </span><span class="s1">Component: element.props.Component,</span><span class="s2">\n      </span><span class="s1">index: element.props.index,</span><span class="s2">\n      </span><span class="s1">path: element.props.path,</span><span class="s2">\n      </span><span class="s1">loader: element.props.loader,</span><span class="s2">\n      </span><span class="s1">action: element.props.action,</span><span class="s2">\n      </span><span class="s1">hydrateFallbackElement: element.props.hydrateFallbackElement,</span><span class="s2">\n      </span><span class="s1">HydrateFallback: element.props.HydrateFallback,</span><span class="s2">\n      </span><span class="s1">errorElement: element.props.errorElement,</span><span class="s2">\n      </span><span class="s1">ErrorBoundary: element.props.ErrorBoundary,</span><span class="s2">\n      </span><span class="s1">hasErrorBoundary: element.props.hasErrorBoundary === true || element.props.ErrorBoundary != null || element.props.errorElement != null,</span><span class="s2">\n      </span><span class="s1">shouldRevalidate: element.props.shouldRevalidate,</span><span class="s2">\n      </span><span class="s1">handle: element.props.handle,</span><span class="s2">\n      </span><span class="s1">lazy: element.props.lazy</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">if (element.props.children) {</span><span class="s2">\n      </span><span class="s1">route.children = createRoutesFromChildren(element.props.children, treePath);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">routes.push(route);</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">return routes;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var createRoutesFromElements = createRoutesFromChildren;</span><span class="s2">\n</span><span class="s1">function renderMatches(matches) {</span><span class="s2">\n  </span><span class="s1">return _renderMatches(matches);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/dom/lib.tsx</span><span class="s2">\n</span><span class="s1">import * as React10 from </span><span class="s2">\&quot;</span><span class="s1">react</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n</span><span class="s1">// lib/dom/dom.ts</span><span class="s2">\n</span><span class="s1">var defaultMethod = </span><span class="s2">\&quot;</span><span class="s1">get</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">var defaultEncType = </span><span class="s2">\&quot;</span><span class="s1">application/x-www-form-urlencoded</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">function isHtmlElement(object) {</span><span class="s2">\n  </span><span class="s1">return object != null &amp;&amp; typeof object.tagName === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isButtonElement(object) {</span><span class="s2">\n  </span><span class="s1">return isHtmlElement(object) &amp;&amp; object.tagName.toLowerCase() === </span><span class="s2">\&quot;</span><span class="s1">button</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isFormElement(object) {</span><span class="s2">\n  </span><span class="s1">return isHtmlElement(object) &amp;&amp; object.tagName.toLowerCase() === </span><span class="s2">\&quot;</span><span class="s1">form</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isInputElement(object) {</span><span class="s2">\n  </span><span class="s1">return isHtmlElement(object) &amp;&amp; object.tagName.toLowerCase() === </span><span class="s2">\&quot;</span><span class="s1">input</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isModifiedEvent(event) {</span><span class="s2">\n  </span><span class="s1">return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function shouldProcessLinkClick(event, target) {</span><span class="s2">\n  </span><span class="s1">return event.button === 0 &amp;&amp; (</span><span class="s2">\n  </span><span class="s1">// Ignore everything but left clicks</span><span class="s2">\n  </span><span class="s1">!target || target === </span><span class="s2">\&quot;</span><span class="s1">_self</span><span class="s2">\&quot;</span><span class="s1">) &amp;&amp;</span><span class="s2">\n  </span><span class="s1">// Let browser handle </span><span class="s2">\&quot;</span><span class="s1">target=_blank</span><span class="s2">\&quot; </span><span class="s1">etc.</span><span class="s2">\n  </span><span class="s1">!isModifiedEvent(event);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createSearchParams(init = </span><span class="s2">\&quot;\&quot;</span><span class="s1">) {</span><span class="s2">\n  </span><span class="s1">return new URLSearchParams(typeof init === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">|| Array.isArray(init) || init instanceof URLSearchParams ? init : Object.keys(init).reduce((memo2, key) =&gt; {</span><span class="s2">\n    </span><span class="s1">let value = init[key];</span><span class="s2">\n    </span><span class="s1">return memo2.concat(Array.isArray(value) ? value.map(v =&gt; [key, v]) : [[key, value]]);</span><span class="s2">\n  </span><span class="s1">}, []));</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getSearchParamsForLocation(locationSearch, defaultSearchParams) {</span><span class="s2">\n  </span><span class="s1">let searchParams = createSearchParams(locationSearch);</span><span class="s2">\n  </span><span class="s1">if (defaultSearchParams) {</span><span class="s2">\n    </span><span class="s1">defaultSearchParams.forEach((_, key) =&gt; {</span><span class="s2">\n      </span><span class="s1">if (!searchParams.has(key)) {</span><span class="s2">\n        </span><span class="s1">defaultSearchParams.getAll(key).forEach(value =&gt; {</span><span class="s2">\n          </span><span class="s1">searchParams.append(key, value);</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return searchParams;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var _formDataSupportsSubmitter = null;</span><span class="s2">\n</span><span class="s1">function isFormDataSubmitterSupported() {</span><span class="s2">\n  </span><span class="s1">if (_formDataSupportsSubmitter === null) {</span><span class="s2">\n    </span><span class="s1">try {</span><span class="s2">\n      </span><span class="s1">new FormData(document.createElement(</span><span class="s2">\&quot;</span><span class="s1">form</span><span class="s2">\&quot;</span><span class="s1">),</span><span class="s2">\n      </span><span class="s1">// @ts-expect-error if FormData supports the submitter parameter, this will throw</span><span class="s2">\n      </span><span class="s1">0);</span><span class="s2">\n      </span><span class="s1">_formDataSupportsSubmitter = false;</span><span class="s2">\n    </span><span class="s1">} catch (e) {</span><span class="s2">\n      </span><span class="s1">_formDataSupportsSubmitter = true;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return _formDataSupportsSubmitter;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var supportedFormEncTypes = /* @__PURE__ */new Set([</span><span class="s2">\&quot;</span><span class="s1">application/x-www-form-urlencoded</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">multipart/form-data</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">text/plain</span><span class="s2">\&quot;</span><span class="s1">]);</span><span class="s2">\n</span><span class="s1">function getFormEncType(encType) {</span><span class="s2">\n  </span><span class="s1">if (encType != null &amp;&amp; !supportedFormEncTypes.has(encType)) {</span><span class="s2">\n    </span><span class="s1">warning(false, `</span><span class="s2">\&quot;</span><span class="s1">${encType}</span><span class="s2">\&quot; </span><span class="s1">is not a valid </span><span class="s2">\\</span><span class="s1">`encType</span><span class="s2">\\</span><span class="s1">` for </span><span class="s2">\\</span><span class="s1">`&lt;Form&gt;</span><span class="s2">\\</span><span class="s1">`/</span><span class="s2">\\</span><span class="s1">`&lt;fetcher.Form&gt;</span><span class="s2">\\</span><span class="s1">` and will default to </span><span class="s2">\&quot;</span><span class="s1">${defaultEncType}</span><span class="s2">\&quot;</span><span class="s1">`);</span><span class="s2">\n    </span><span class="s1">return null;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return encType;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getFormSubmissionInfo(target, basename) {</span><span class="s2">\n  </span><span class="s1">let method;</span><span class="s2">\n  </span><span class="s1">let action;</span><span class="s2">\n  </span><span class="s1">let encType;</span><span class="s2">\n  </span><span class="s1">let formData;</span><span class="s2">\n  </span><span class="s1">let body;</span><span class="s2">\n  </span><span class="s1">if (isFormElement(target)) {</span><span class="s2">\n    </span><span class="s1">let attr = target.getAttribute(</span><span class="s2">\&quot;</span><span class="s1">action</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">action = attr ? stripBasename(attr, basename) : null;</span><span class="s2">\n    </span><span class="s1">method = target.getAttribute(</span><span class="s2">\&quot;</span><span class="s1">method</span><span class="s2">\&quot;</span><span class="s1">) || defaultMethod;</span><span class="s2">\n    </span><span class="s1">encType = getFormEncType(target.getAttribute(</span><span class="s2">\&quot;</span><span class="s1">enctype</span><span class="s2">\&quot;</span><span class="s1">)) || defaultEncType;</span><span class="s2">\n    </span><span class="s1">formData = new FormData(target);</span><span class="s2">\n  </span><span class="s1">} else if (isButtonElement(target) || isInputElement(target) &amp;&amp; (target.type === </span><span class="s2">\&quot;</span><span class="s1">submit</span><span class="s2">\&quot; </span><span class="s1">|| target.type === </span><span class="s2">\&quot;</span><span class="s1">image</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n    </span><span class="s1">let form = target.form;</span><span class="s2">\n    </span><span class="s1">if (form == null) {</span><span class="s2">\n      </span><span class="s1">throw new Error(`Cannot submit a &lt;button&gt; or &lt;input type=</span><span class="s2">\&quot;</span><span class="s1">submit</span><span class="s2">\&quot;</span><span class="s1">&gt; without a &lt;form&gt;`);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let attr = target.getAttribute(</span><span class="s2">\&quot;</span><span class="s1">formaction</span><span class="s2">\&quot;</span><span class="s1">) || form.getAttribute(</span><span class="s2">\&quot;</span><span class="s1">action</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">action = attr ? stripBasename(attr, basename) : null;</span><span class="s2">\n    </span><span class="s1">method = target.getAttribute(</span><span class="s2">\&quot;</span><span class="s1">formmethod</span><span class="s2">\&quot;</span><span class="s1">) || form.getAttribute(</span><span class="s2">\&quot;</span><span class="s1">method</span><span class="s2">\&quot;</span><span class="s1">) || defaultMethod;</span><span class="s2">\n    </span><span class="s1">encType = getFormEncType(target.getAttribute(</span><span class="s2">\&quot;</span><span class="s1">formenctype</span><span class="s2">\&quot;</span><span class="s1">)) || getFormEncType(form.getAttribute(</span><span class="s2">\&quot;</span><span class="s1">enctype</span><span class="s2">\&quot;</span><span class="s1">)) || defaultEncType;</span><span class="s2">\n    </span><span class="s1">formData = new FormData(form, target);</span><span class="s2">\n    </span><span class="s1">if (!isFormDataSubmitterSupported()) {</span><span class="s2">\n      </span><span class="s1">let {</span><span class="s2">\n        </span><span class="s1">name,</span><span class="s2">\n        </span><span class="s1">type,</span><span class="s2">\n        </span><span class="s1">value</span><span class="s2">\n      </span><span class="s1">} = target;</span><span class="s2">\n      </span><span class="s1">if (type === </span><span class="s2">\&quot;</span><span class="s1">image</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">let prefix = name ? `${name}.` : </span><span class="s2">\&quot;\&quot;</span><span class="s1">;</span><span class="s2">\n        </span><span class="s1">formData.append(`${prefix}x`, </span><span class="s2">\&quot;</span><span class="s1">0</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">formData.append(`${prefix}y`, </span><span class="s2">\&quot;</span><span class="s1">0</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">} else if (name) {</span><span class="s2">\n        </span><span class="s1">formData.append(name, value);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">} else if (isHtmlElement(target)) {</span><span class="s2">\n    </span><span class="s1">throw new Error(`Cannot submit element that is not &lt;form&gt;, &lt;button&gt;, or &lt;input type=</span><span class="s2">\&quot;</span><span class="s1">submit|image</span><span class="s2">\&quot;</span><span class="s1">&gt;`);</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">method = defaultMethod;</span><span class="s2">\n    </span><span class="s1">action = null;</span><span class="s2">\n    </span><span class="s1">encType = defaultEncType;</span><span class="s2">\n    </span><span class="s1">body = target;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (formData &amp;&amp; encType === </span><span class="s2">\&quot;</span><span class="s1">text/plain</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">body = formData;</span><span class="s2">\n    </span><span class="s1">formData = void 0;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">action,</span><span class="s2">\n    </span><span class="s1">method: method.toLowerCase(),</span><span class="s2">\n    </span><span class="s1">encType,</span><span class="s2">\n    </span><span class="s1">formData,</span><span class="s2">\n    </span><span class="s1">body</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/dom/ssr/components.tsx</span><span class="s2">\n</span><span class="s1">import * as React9 from </span><span class="s2">\&quot;</span><span class="s1">react</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n</span><span class="s1">// lib/dom/ssr/invariant.ts</span><span class="s2">\n</span><span class="s1">function invariant2(value, message) {</span><span class="s2">\n  </span><span class="s1">if (value === false || value === null || typeof value === </span><span class="s2">\&quot;</span><span class="s1">undefined</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">throw new Error(message);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/dom/ssr/routeModules.ts</span><span class="s2">\n</span><span class="s1">async function loadRouteModule(route, routeModulesCache) {</span><span class="s2">\n  </span><span class="s1">if (route.id in routeModulesCache) {</span><span class="s2">\n    </span><span class="s1">return routeModulesCache[route.id];</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">try {</span><span class="s2">\n    </span><span class="s1">let routeModule = await import(/* @vite-ignore */</span><span class="s2">\n    </span><span class="s1">/* webpackIgnore: true */</span><span class="s2">\n    </span><span class="s1">route.module);</span><span class="s2">\n    </span><span class="s1">routeModulesCache[route.id] = routeModule;</span><span class="s2">\n    </span><span class="s1">return routeModule;</span><span class="s2">\n  </span><span class="s1">} catch (error) {</span><span class="s2">\n    </span><span class="s1">console.error(`Error loading route module </span><span class="s2">\\</span><span class="s1">`${route.module}</span><span class="s2">\\</span><span class="s1">`, reloading page...`);</span><span class="s2">\n    </span><span class="s1">console.error(error);</span><span class="s2">\n    </span><span class="s1">if (window.__reactRouterContext &amp;&amp; window.__reactRouterContext.isSpaMode &amp;&amp;</span><span class="s2">\n    </span><span class="s1">// @ts-expect-error</span><span class="s2">\n    </span><span class="s1">import.meta.hot) {</span><span class="s2">\n      </span><span class="s1">throw error;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">window.location.reload();</span><span class="s2">\n    </span><span class="s1">return new Promise(() =&gt; {});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/dom/ssr/links.ts</span><span class="s2">\n</span><span class="s1">function getKeyedLinksForMatches(matches, routeModules, manifest) {</span><span class="s2">\n  </span><span class="s1">let descriptors = matches.map(match =&gt; {</span><span class="s2">\n    </span><span class="s1">let module = routeModules[match.route.id];</span><span class="s2">\n    </span><span class="s1">let route = manifest.routes[match.route.id];</span><span class="s2">\n    </span><span class="s1">return [route &amp;&amp; route.css ? route.css.map(href2 =&gt; ({</span><span class="s2">\n      </span><span class="s1">rel: </span><span class="s2">\&quot;</span><span class="s1">stylesheet</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">href: href2</span><span class="s2">\n    </span><span class="s1">})) : [], module?.links?.() || []];</span><span class="s2">\n  </span><span class="s1">}).flat(2);</span><span class="s2">\n  </span><span class="s1">let preloads = getModuleLinkHrefs(matches, manifest);</span><span class="s2">\n  </span><span class="s1">return dedupeLinkDescriptors(descriptors, preloads);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getRouteCssDescriptors(route) {</span><span class="s2">\n  </span><span class="s1">if (!route.css) return [];</span><span class="s2">\n  </span><span class="s1">return route.css.map(href2 =&gt; ({</span><span class="s2">\n    </span><span class="s1">rel: </span><span class="s2">\&quot;</span><span class="s1">stylesheet</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">href: href2</span><span class="s2">\n  </span><span class="s1">}));</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">async function prefetchRouteCss(route) {</span><span class="s2">\n  </span><span class="s1">if (!route.css) return;</span><span class="s2">\n  </span><span class="s1">let descriptors = getRouteCssDescriptors(route);</span><span class="s2">\n  </span><span class="s1">await Promise.all(descriptors.map(prefetchStyleLink));</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">async function prefetchStyleLinks(route, routeModule) {</span><span class="s2">\n  </span><span class="s1">if (!route.css &amp;&amp; !routeModule.links || !isPreloadSupported()) return;</span><span class="s2">\n  </span><span class="s1">let descriptors = [];</span><span class="s2">\n  </span><span class="s1">if (route.css) {</span><span class="s2">\n    </span><span class="s1">descriptors.push(...getRouteCssDescriptors(route));</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (routeModule.links) {</span><span class="s2">\n    </span><span class="s1">descriptors.push(...routeModule.links());</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (descriptors.length === 0) return;</span><span class="s2">\n  </span><span class="s1">let styleLinks = [];</span><span class="s2">\n  </span><span class="s1">for (let descriptor of descriptors) {</span><span class="s2">\n    </span><span class="s1">if (!isPageLinkDescriptor(descriptor) &amp;&amp; descriptor.rel === </span><span class="s2">\&quot;</span><span class="s1">stylesheet</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">styleLinks.push({</span><span class="s2">\n        </span><span class="s1">...descriptor,</span><span class="s2">\n        </span><span class="s1">rel: </span><span class="s2">\&quot;</span><span class="s1">preload</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        </span><span class="s1">as: </span><span class="s2">\&quot;</span><span class="s1">style</span><span class="s2">\&quot;\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">await Promise.all(styleLinks.map(prefetchStyleLink));</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">async function prefetchStyleLink(descriptor) {</span><span class="s2">\n  </span><span class="s1">return new Promise(resolve =&gt; {</span><span class="s2">\n    </span><span class="s1">if (descriptor.media &amp;&amp; !window.matchMedia(descriptor.media).matches || document.querySelector(`link[rel=</span><span class="s2">\&quot;</span><span class="s1">stylesheet</span><span class="s2">\&quot;</span><span class="s1">][href=</span><span class="s2">\&quot;</span><span class="s1">${descriptor.href}</span><span class="s2">\&quot;</span><span class="s1">]`)) {</span><span class="s2">\n      </span><span class="s1">return resolve();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let link = document.createElement(</span><span class="s2">\&quot;</span><span class="s1">link</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">Object.assign(link, descriptor);</span><span class="s2">\n    </span><span class="s1">function removeLink() {</span><span class="s2">\n      </span><span class="s1">if (document.head.contains(link)) {</span><span class="s2">\n        </span><span class="s1">document.head.removeChild(link);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">link.onload = () =&gt; {</span><span class="s2">\n      </span><span class="s1">removeLink();</span><span class="s2">\n      </span><span class="s1">resolve();</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">link.onerror = () =&gt; {</span><span class="s2">\n      </span><span class="s1">removeLink();</span><span class="s2">\n      </span><span class="s1">resolve();</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">document.head.appendChild(link);</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isPageLinkDescriptor(object) {</span><span class="s2">\n  </span><span class="s1">return object != null &amp;&amp; typeof object.page === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isHtmlLinkDescriptor(object) {</span><span class="s2">\n  </span><span class="s1">if (object == null) {</span><span class="s2">\n    </span><span class="s1">return false;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (object.href == null) {</span><span class="s2">\n    </span><span class="s1">return object.rel === </span><span class="s2">\&quot;</span><span class="s1">preload</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; typeof object.imageSrcSet === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; typeof object.imageSizes === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return typeof object.rel === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; typeof object.href === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">async function getKeyedPrefetchLinks(matches, manifest, routeModules) {</span><span class="s2">\n  </span><span class="s1">let links = await Promise.all(matches.map(async match =&gt; {</span><span class="s2">\n    </span><span class="s1">let route = manifest.routes[match.route.id];</span><span class="s2">\n    </span><span class="s1">if (route) {</span><span class="s2">\n      </span><span class="s1">let mod = await loadRouteModule(route, routeModules);</span><span class="s2">\n      </span><span class="s1">return mod.links ? mod.links() : [];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return [];</span><span class="s2">\n  </span><span class="s1">}));</span><span class="s2">\n  </span><span class="s1">return dedupeLinkDescriptors(links.flat(1).filter(isHtmlLinkDescriptor).filter(link =&gt; link.rel === </span><span class="s2">\&quot;</span><span class="s1">stylesheet</span><span class="s2">\&quot; </span><span class="s1">|| link.rel === </span><span class="s2">\&quot;</span><span class="s1">preload</span><span class="s2">\&quot;</span><span class="s1">).map(link =&gt; link.rel === </span><span class="s2">\&quot;</span><span class="s1">stylesheet</span><span class="s2">\&quot; </span><span class="s1">? {</span><span class="s2">\n    </span><span class="s1">...link,</span><span class="s2">\n    </span><span class="s1">rel: </span><span class="s2">\&quot;</span><span class="s1">prefetch</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">as: </span><span class="s2">\&quot;</span><span class="s1">style</span><span class="s2">\&quot;\n  </span><span class="s1">} : {</span><span class="s2">\n    </span><span class="s1">...link,</span><span class="s2">\n    </span><span class="s1">rel: </span><span class="s2">\&quot;</span><span class="s1">prefetch</span><span class="s2">\&quot;\n  </span><span class="s1">}));</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getNewMatchesForLinks(page, nextMatches, currentMatches, manifest, location, mode) {</span><span class="s2">\n  </span><span class="s1">let isNew = (match, index) =&gt; {</span><span class="s2">\n    </span><span class="s1">if (!currentMatches[index]) return true;</span><span class="s2">\n    </span><span class="s1">return match.route.id !== currentMatches[index].route.id;</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">let matchPathChanged = (match, index) =&gt; {</span><span class="s2">\n    </span><span class="s1">return (</span><span class="s2">\n      </span><span class="s1">// param change, /users/123 -&gt; /users/456</span><span class="s2">\n      </span><span class="s1">currentMatches[index].pathname !== match.pathname ||</span><span class="s2">\n      </span><span class="s1">// splat param changed, which is not present in match.path</span><span class="s2">\n      </span><span class="s1">// e.g. /files/images/avatar.jpg -&gt; files/finances.xls</span><span class="s2">\n      </span><span class="s1">currentMatches[index].route.path?.endsWith(</span><span class="s2">\&quot;</span><span class="s1">*</span><span class="s2">\&quot;</span><span class="s1">) &amp;&amp; currentMatches[index].params[</span><span class="s2">\&quot;</span><span class="s1">*</span><span class="s2">\&quot;</span><span class="s1">] !== match.params[</span><span class="s2">\&quot;</span><span class="s1">*</span><span class="s2">\&quot;</span><span class="s1">]</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">if (mode === </span><span class="s2">\&quot;</span><span class="s1">assets</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">return nextMatches.filter((match, index) =&gt; isNew(match, index) || matchPathChanged(match, index));</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (mode === </span><span class="s2">\&quot;</span><span class="s1">data</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">return nextMatches.filter((match, index) =&gt; {</span><span class="s2">\n      </span><span class="s1">let manifestRoute = manifest.routes[match.route.id];</span><span class="s2">\n      </span><span class="s1">if (!manifestRoute || !manifestRoute.hasLoader) {</span><span class="s2">\n        </span><span class="s1">return false;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (isNew(match, index) || matchPathChanged(match, index)) {</span><span class="s2">\n        </span><span class="s1">return true;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (match.route.shouldRevalidate) {</span><span class="s2">\n        </span><span class="s1">let routeChoice = match.route.shouldRevalidate({</span><span class="s2">\n          </span><span class="s1">currentUrl: new URL(location.pathname + location.search + location.hash, window.origin),</span><span class="s2">\n          </span><span class="s1">currentParams: currentMatches[0]?.params || {},</span><span class="s2">\n          </span><span class="s1">nextUrl: new URL(page, window.origin),</span><span class="s2">\n          </span><span class="s1">nextParams: match.params,</span><span class="s2">\n          </span><span class="s1">defaultShouldRevalidate: true</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">if (typeof routeChoice === </span><span class="s2">\&quot;</span><span class="s1">boolean</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">return routeChoice;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return true;</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return [];</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getModuleLinkHrefs(matches, manifest, {</span><span class="s2">\n  </span><span class="s1">includeHydrateFallback</span><span class="s2">\n</span><span class="s1">} = {}) {</span><span class="s2">\n  </span><span class="s1">return dedupeHrefs(matches.map(match =&gt; {</span><span class="s2">\n    </span><span class="s1">let route = manifest.routes[match.route.id];</span><span class="s2">\n    </span><span class="s1">if (!route) return [];</span><span class="s2">\n    </span><span class="s1">let hrefs = [route.module];</span><span class="s2">\n    </span><span class="s1">if (route.clientActionModule) {</span><span class="s2">\n      </span><span class="s1">hrefs = hrefs.concat(route.clientActionModule);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (route.clientLoaderModule) {</span><span class="s2">\n      </span><span class="s1">hrefs = hrefs.concat(route.clientLoaderModule);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (includeHydrateFallback &amp;&amp; route.hydrateFallbackModule) {</span><span class="s2">\n      </span><span class="s1">hrefs = hrefs.concat(route.hydrateFallbackModule);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (route.imports) {</span><span class="s2">\n      </span><span class="s1">hrefs = hrefs.concat(route.imports);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return hrefs;</span><span class="s2">\n  </span><span class="s1">}).flat(1));</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function dedupeHrefs(hrefs) {</span><span class="s2">\n  </span><span class="s1">return [...new Set(hrefs)];</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function sortKeys(obj) {</span><span class="s2">\n  </span><span class="s1">let sorted = {};</span><span class="s2">\n  </span><span class="s1">let keys = Object.keys(obj).sort();</span><span class="s2">\n  </span><span class="s1">for (let key of keys) {</span><span class="s2">\n    </span><span class="s1">sorted[key] = obj[key];</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return sorted;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function dedupeLinkDescriptors(descriptors, preloads) {</span><span class="s2">\n  </span><span class="s1">let set = /* @__PURE__ */new Set();</span><span class="s2">\n  </span><span class="s1">let preloadsSet = new Set(preloads);</span><span class="s2">\n  </span><span class="s1">return descriptors.reduce((deduped, descriptor) =&gt; {</span><span class="s2">\n    </span><span class="s1">let alreadyModulePreload = preloads &amp;&amp; !isPageLinkDescriptor(descriptor) &amp;&amp; descriptor.as === </span><span class="s2">\&quot;</span><span class="s1">script</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; descriptor.href &amp;&amp; preloadsSet.has(descriptor.href);</span><span class="s2">\n    </span><span class="s1">if (alreadyModulePreload) {</span><span class="s2">\n      </span><span class="s1">return deduped;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let key = JSON.stringify(sortKeys(descriptor));</span><span class="s2">\n    </span><span class="s1">if (!set.has(key)) {</span><span class="s2">\n      </span><span class="s1">set.add(key);</span><span class="s2">\n      </span><span class="s1">deduped.push({</span><span class="s2">\n        </span><span class="s1">key,</span><span class="s2">\n        </span><span class="s1">link: descriptor</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return deduped;</span><span class="s2">\n  </span><span class="s1">}, []);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var _isPreloadSupported;</span><span class="s2">\n</span><span class="s1">function isPreloadSupported() {</span><span class="s2">\n  </span><span class="s1">if (_isPreloadSupported !== void 0) {</span><span class="s2">\n    </span><span class="s1">return _isPreloadSupported;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let el = document.createElement(</span><span class="s2">\&quot;</span><span class="s1">link</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">_isPreloadSupported = el.relList.supports(</span><span class="s2">\&quot;</span><span class="s1">preload</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">el = null;</span><span class="s2">\n  </span><span class="s1">return _isPreloadSupported;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/dom/ssr/markup.ts</span><span class="s2">\n</span><span class="s1">var ESCAPE_LOOKUP = {</span><span class="s2">\n  \&quot;</span><span class="s1">&amp;</span><span class="s2">\&quot;</span><span class="s1">: </span><span class="s2">\&quot;\\\\</span><span class="s1">u0026</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">&gt;</span><span class="s2">\&quot;</span><span class="s1">: </span><span class="s2">\&quot;\\\\</span><span class="s1">u003e</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">&lt;</span><span class="s2">\&quot;</span><span class="s1">: </span><span class="s2">\&quot;\\\\</span><span class="s1">u003c</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;\\</span><span class="s1">u2028</span><span class="s2">\&quot;</span><span class="s1">: </span><span class="s2">\&quot;\\\\</span><span class="s1">u2028</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;\\</span><span class="s1">u2029</span><span class="s2">\&quot;</span><span class="s1">: </span><span class="s2">\&quot;\\\\</span><span class="s1">u2029</span><span class="s2">\&quot;\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">var ESCAPE_REGEX = /[&amp;&gt;&lt;</span><span class="s2">\\</span><span class="s1">u2028</span><span class="s2">\\</span><span class="s1">u2029]/g;</span><span class="s2">\n</span><span class="s1">function escapeHtml(html) {</span><span class="s2">\n  </span><span class="s1">return html.replace(ESCAPE_REGEX, match =&gt; ESCAPE_LOOKUP[match]);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createHtml(html) {</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">__html: html</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/dom/ssr/single-fetch.tsx</span><span class="s2">\n</span><span class="s1">import * as React4 from </span><span class="s2">\&quot;</span><span class="s1">react</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n</span><span class="s1">// vendor/turbo-stream-v2/utils.ts</span><span class="s2">\n</span><span class="s1">var HOLE = -1;</span><span class="s2">\n</span><span class="s1">var NAN = -2;</span><span class="s2">\n</span><span class="s1">var NEGATIVE_INFINITY = -3;</span><span class="s2">\n</span><span class="s1">var NEGATIVE_ZERO = -4;</span><span class="s2">\n</span><span class="s1">var NULL = -5;</span><span class="s2">\n</span><span class="s1">var POSITIVE_INFINITY = -6;</span><span class="s2">\n</span><span class="s1">var UNDEFINED = -7;</span><span class="s2">\n</span><span class="s1">var TYPE_BIGINT = </span><span class="s2">\&quot;</span><span class="s1">B</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">var TYPE_DATE = </span><span class="s2">\&quot;</span><span class="s1">D</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">var TYPE_ERROR = </span><span class="s2">\&quot;</span><span class="s1">E</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">var TYPE_MAP = </span><span class="s2">\&quot;</span><span class="s1">M</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">var TYPE_NULL_OBJECT = </span><span class="s2">\&quot;</span><span class="s1">N</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">var TYPE_PROMISE = </span><span class="s2">\&quot;</span><span class="s1">P</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">var TYPE_REGEXP = </span><span class="s2">\&quot;</span><span class="s1">R</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">var TYPE_SET = </span><span class="s2">\&quot;</span><span class="s1">S</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">var TYPE_SYMBOL = </span><span class="s2">\&quot;</span><span class="s1">Y</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">var TYPE_URL = </span><span class="s2">\&quot;</span><span class="s1">U</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">var TYPE_PREVIOUS_RESOLVED = </span><span class="s2">\&quot;</span><span class="s1">Z</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">var Deferred2 = class {</span><span class="s2">\n  </span><span class="s1">constructor() {</span><span class="s2">\n    </span><span class="s1">this.promise = new Promise((resolve, reject) =&gt; {</span><span class="s2">\n      </span><span class="s1">this.resolve = resolve;</span><span class="s2">\n      </span><span class="s1">this.reject = reject;</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">function createLineSplittingTransform() {</span><span class="s2">\n  </span><span class="s1">const decoder = new TextDecoder();</span><span class="s2">\n  </span><span class="s1">let leftover = </span><span class="s2">\&quot;\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">return new TransformStream({</span><span class="s2">\n    </span><span class="s1">transform(chunk, controller) {</span><span class="s2">\n      </span><span class="s1">const str = decoder.decode(chunk, {</span><span class="s2">\n        </span><span class="s1">stream: true</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">const parts = (leftover + str).split(</span><span class="s2">\&quot;\\</span><span class="s1">n</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">leftover = parts.pop() || </span><span class="s2">\&quot;\&quot;</span><span class="s1">;</span><span class="s2">\n      </span><span class="s1">for (const part of parts) {</span><span class="s2">\n        </span><span class="s1">controller.enqueue(part);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">flush(controller) {</span><span class="s2">\n      </span><span class="s1">if (leftover) {</span><span class="s2">\n        </span><span class="s1">controller.enqueue(leftover);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// vendor/turbo-stream-v2/flatten.ts</span><span class="s2">\n</span><span class="s1">function flatten(input) {</span><span class="s2">\n  </span><span class="s1">const {</span><span class="s2">\n    </span><span class="s1">indices</span><span class="s2">\n  </span><span class="s1">} = this;</span><span class="s2">\n  </span><span class="s1">const existing = indices.get(input);</span><span class="s2">\n  </span><span class="s1">if (existing) return [existing];</span><span class="s2">\n  </span><span class="s1">if (input === void 0) return UNDEFINED;</span><span class="s2">\n  </span><span class="s1">if (input === null) return NULL;</span><span class="s2">\n  </span><span class="s1">if (Number.isNaN(input)) return NAN;</span><span class="s2">\n  </span><span class="s1">if (input === Number.POSITIVE_INFINITY) return POSITIVE_INFINITY;</span><span class="s2">\n  </span><span class="s1">if (input === Number.NEGATIVE_INFINITY) return NEGATIVE_INFINITY;</span><span class="s2">\n  </span><span class="s1">if (input === 0 &amp;&amp; 1 / input &lt; 0) return NEGATIVE_ZERO;</span><span class="s2">\n  </span><span class="s1">const index = this.index++;</span><span class="s2">\n  </span><span class="s1">indices.set(input, index);</span><span class="s2">\n  </span><span class="s1">stringify.call(this, input, index);</span><span class="s2">\n  </span><span class="s1">return index;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function stringify(input, index) {</span><span class="s2">\n  </span><span class="s1">const {</span><span class="s2">\n    </span><span class="s1">deferred,</span><span class="s2">\n    </span><span class="s1">plugins,</span><span class="s2">\n    </span><span class="s1">postPlugins</span><span class="s2">\n  </span><span class="s1">} = this;</span><span class="s2">\n  </span><span class="s1">const str = this.stringified;</span><span class="s2">\n  </span><span class="s1">const stack = [[input, index]];</span><span class="s2">\n  </span><span class="s1">while (stack.length &gt; 0) {</span><span class="s2">\n    </span><span class="s1">const [input2, index2] = stack.pop();</span><span class="s2">\n    </span><span class="s1">const partsForObj = obj =&gt; Object.keys(obj).map(k =&gt; `</span><span class="s2">\&quot;</span><span class="s1">_${flatten.call(this, k)}</span><span class="s2">\&quot;</span><span class="s1">:${flatten.call(this, obj[k])}`).join(</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">let error = null;</span><span class="s2">\n    </span><span class="s1">switch (typeof input2) {</span><span class="s2">\n      </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">boolean</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n      </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">number</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n      </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n        </span><span class="s1">str[index2] = JSON.stringify(input2);</span><span class="s2">\n        </span><span class="s1">break;</span><span class="s2">\n      </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">bigint</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n        </span><span class="s1">str[index2] = `[</span><span class="s2">\&quot;</span><span class="s1">${TYPE_BIGINT}</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\&quot;</span><span class="s1">${input2}</span><span class="s2">\&quot;</span><span class="s1">]`;</span><span class="s2">\n        </span><span class="s1">break;</span><span class="s2">\n      </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">symbol</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n        </span><span class="s1">{</span><span class="s2">\n          </span><span class="s1">const keyFor = Symbol.keyFor(input2);</span><span class="s2">\n          </span><span class="s1">if (!keyFor) {</span><span class="s2">\n            </span><span class="s1">error = new Error(</span><span class="s2">\&quot;</span><span class="s1">Cannot encode symbol unless created with Symbol.for()</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">} else {</span><span class="s2">\n            </span><span class="s1">str[index2] = `[</span><span class="s2">\&quot;</span><span class="s1">${TYPE_SYMBOL}</span><span class="s2">\&quot;</span><span class="s1">,${JSON.stringify(keyFor)}]`;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">break;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">object</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n        </span><span class="s1">{</span><span class="s2">\n          </span><span class="s1">if (!input2) {</span><span class="s2">\n            </span><span class="s1">str[index2] = `${NULL}`;</span><span class="s2">\n            </span><span class="s1">break;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">const isArray = Array.isArray(input2);</span><span class="s2">\n          </span><span class="s1">let pluginHandled = false;</span><span class="s2">\n          </span><span class="s1">if (!isArray &amp;&amp; plugins) {</span><span class="s2">\n            </span><span class="s1">for (const plugin of plugins) {</span><span class="s2">\n              </span><span class="s1">const pluginResult = plugin(input2);</span><span class="s2">\n              </span><span class="s1">if (Array.isArray(pluginResult)) {</span><span class="s2">\n                </span><span class="s1">pluginHandled = true;</span><span class="s2">\n                </span><span class="s1">const [pluginIdentifier, ...rest] = pluginResult;</span><span class="s2">\n                </span><span class="s1">str[index2] = `[${JSON.stringify(pluginIdentifier)}`;</span><span class="s2">\n                </span><span class="s1">if (rest.length &gt; 0) {</span><span class="s2">\n                  </span><span class="s1">str[index2] += `,${rest.map(v =&gt; flatten.call(this, v)).join(</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\&quot;</span><span class="s1">)}`;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">str[index2] += </span><span class="s2">\&quot;</span><span class="s1">]</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n                </span><span class="s1">break;</span><span class="s2">\n              </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">if (!pluginHandled) {</span><span class="s2">\n            </span><span class="s1">let result = isArray ? </span><span class="s2">\&quot;</span><span class="s1">[</span><span class="s2">\&quot; </span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">{</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n            </span><span class="s1">if (isArray) {</span><span class="s2">\n              </span><span class="s1">for (let i = 0; i &lt; input2.length; i++) result += (i ? </span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\&quot; </span><span class="s1">: </span><span class="s2">\&quot;\&quot;</span><span class="s1">) + (i in input2 ? flatten.call(this, input2[i]) : HOLE);</span><span class="s2">\n              </span><span class="s1">str[index2] = `${result}]`;</span><span class="s2">\n            </span><span class="s1">} else if (input2 instanceof Date) {</span><span class="s2">\n              </span><span class="s1">str[index2] = `[</span><span class="s2">\&quot;</span><span class="s1">${TYPE_DATE}</span><span class="s2">\&quot;</span><span class="s1">,${input2.getTime()}]`;</span><span class="s2">\n            </span><span class="s1">} else if (input2 instanceof URL) {</span><span class="s2">\n              </span><span class="s1">str[index2] = `[</span><span class="s2">\&quot;</span><span class="s1">${TYPE_URL}</span><span class="s2">\&quot;</span><span class="s1">,${JSON.stringify(input2.href)}]`;</span><span class="s2">\n            </span><span class="s1">} else if (input2 instanceof RegExp) {</span><span class="s2">\n              </span><span class="s1">str[index2] = `[</span><span class="s2">\&quot;</span><span class="s1">${TYPE_REGEXP}</span><span class="s2">\&quot;</span><span class="s1">,${JSON.stringify(input2.source)},${JSON.stringify(input2.flags)}]`;</span><span class="s2">\n            </span><span class="s1">} else if (input2 instanceof Set) {</span><span class="s2">\n              </span><span class="s1">if (input2.size &gt; 0) {</span><span class="s2">\n                </span><span class="s1">str[index2] = `[</span><span class="s2">\&quot;</span><span class="s1">${TYPE_SET}</span><span class="s2">\&quot;</span><span class="s1">,${[...input2].map(val =&gt; flatten.call(this, val)).join(</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\&quot;</span><span class="s1">)}]`;</span><span class="s2">\n              </span><span class="s1">} else {</span><span class="s2">\n                </span><span class="s1">str[index2] = `[</span><span class="s2">\&quot;</span><span class="s1">${TYPE_SET}</span><span class="s2">\&quot;</span><span class="s1">]`;</span><span class="s2">\n              </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">} else if (input2 instanceof Map) {</span><span class="s2">\n              </span><span class="s1">if (input2.size &gt; 0) {</span><span class="s2">\n                </span><span class="s1">str[index2] = `[</span><span class="s2">\&quot;</span><span class="s1">${TYPE_MAP}</span><span class="s2">\&quot;</span><span class="s1">,${[...input2].flatMap(([k, v]) =&gt; [flatten.call(this, k), flatten.call(this, v)]).join(</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\&quot;</span><span class="s1">)}]`;</span><span class="s2">\n              </span><span class="s1">} else {</span><span class="s2">\n                </span><span class="s1">str[index2] = `[</span><span class="s2">\&quot;</span><span class="s1">${TYPE_MAP}</span><span class="s2">\&quot;</span><span class="s1">]`;</span><span class="s2">\n              </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">} else if (input2 instanceof Promise) {</span><span class="s2">\n              </span><span class="s1">str[index2] = `[</span><span class="s2">\&quot;</span><span class="s1">${TYPE_PROMISE}</span><span class="s2">\&quot;</span><span class="s1">,${index2}]`;</span><span class="s2">\n              </span><span class="s1">deferred[index2] = input2;</span><span class="s2">\n            </span><span class="s1">} else if (input2 instanceof Error) {</span><span class="s2">\n              </span><span class="s1">str[index2] = `[</span><span class="s2">\&quot;</span><span class="s1">${TYPE_ERROR}</span><span class="s2">\&quot;</span><span class="s1">,${JSON.stringify(input2.message)}`;</span><span class="s2">\n              </span><span class="s1">if (input2.name !== </span><span class="s2">\&quot;</span><span class="s1">Error</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n                </span><span class="s1">str[index2] += `,${JSON.stringify(input2.name)}`;</span><span class="s2">\n              </span><span class="s1">}</span><span class="s2">\n              </span><span class="s1">str[index2] += </span><span class="s2">\&quot;</span><span class="s1">]</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n            </span><span class="s1">} else if (Object.getPrototypeOf(input2) === null) {</span><span class="s2">\n              </span><span class="s1">str[index2] = `[</span><span class="s2">\&quot;</span><span class="s1">${TYPE_NULL_OBJECT}</span><span class="s2">\&quot;</span><span class="s1">,{${partsForObj(input2)}}]`;</span><span class="s2">\n            </span><span class="s1">} else if (isPlainObject(input2)) {</span><span class="s2">\n              </span><span class="s1">str[index2] = `{${partsForObj(input2)}}`;</span><span class="s2">\n            </span><span class="s1">} else {</span><span class="s2">\n              </span><span class="s1">error = new Error(</span><span class="s2">\&quot;</span><span class="s1">Cannot encode object with prototype</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">break;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">default:</span><span class="s2">\n        </span><span class="s1">{</span><span class="s2">\n          </span><span class="s1">const isArray = Array.isArray(input2);</span><span class="s2">\n          </span><span class="s1">let pluginHandled = false;</span><span class="s2">\n          </span><span class="s1">if (!isArray &amp;&amp; plugins) {</span><span class="s2">\n            </span><span class="s1">for (const plugin of plugins) {</span><span class="s2">\n              </span><span class="s1">const pluginResult = plugin(input2);</span><span class="s2">\n              </span><span class="s1">if (Array.isArray(pluginResult)) {</span><span class="s2">\n                </span><span class="s1">pluginHandled = true;</span><span class="s2">\n                </span><span class="s1">const [pluginIdentifier, ...rest] = pluginResult;</span><span class="s2">\n                </span><span class="s1">str[index2] = `[${JSON.stringify(pluginIdentifier)}`;</span><span class="s2">\n                </span><span class="s1">if (rest.length &gt; 0) {</span><span class="s2">\n                  </span><span class="s1">str[index2] += `,${rest.map(v =&gt; flatten.call(this, v)).join(</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\&quot;</span><span class="s1">)}`;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">str[index2] += </span><span class="s2">\&quot;</span><span class="s1">]</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n                </span><span class="s1">break;</span><span class="s2">\n              </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">if (!pluginHandled) {</span><span class="s2">\n            </span><span class="s1">error = new Error(</span><span class="s2">\&quot;</span><span class="s1">Cannot encode function or unexpected type</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (error) {</span><span class="s2">\n      </span><span class="s1">let pluginHandled = false;</span><span class="s2">\n      </span><span class="s1">if (postPlugins) {</span><span class="s2">\n        </span><span class="s1">for (const plugin of postPlugins) {</span><span class="s2">\n          </span><span class="s1">const pluginResult = plugin(input2);</span><span class="s2">\n          </span><span class="s1">if (Array.isArray(pluginResult)) {</span><span class="s2">\n            </span><span class="s1">pluginHandled = true;</span><span class="s2">\n            </span><span class="s1">const [pluginIdentifier, ...rest] = pluginResult;</span><span class="s2">\n            </span><span class="s1">str[index2] = `[${JSON.stringify(pluginIdentifier)}`;</span><span class="s2">\n            </span><span class="s1">if (rest.length &gt; 0) {</span><span class="s2">\n              </span><span class="s1">str[index2] += `,${rest.map(v =&gt; flatten.call(this, v)).join(</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\&quot;</span><span class="s1">)}`;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">str[index2] += </span><span class="s2">\&quot;</span><span class="s1">]</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n            </span><span class="s1">break;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (!pluginHandled) {</span><span class="s2">\n        </span><span class="s1">throw error;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var objectProtoNames = Object.getOwnPropertyNames(Object.prototype).sort().join(</span><span class="s2">\&quot;\\</span><span class="s1">0</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n</span><span class="s1">function isPlainObject(thing) {</span><span class="s2">\n  </span><span class="s1">const proto = Object.getPrototypeOf(thing);</span><span class="s2">\n  </span><span class="s1">return proto === Object.prototype || proto === null || Object.getOwnPropertyNames(proto).sort().join(</span><span class="s2">\&quot;\\</span><span class="s1">0</span><span class="s2">\&quot;</span><span class="s1">) === objectProtoNames;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// vendor/turbo-stream-v2/unflatten.ts</span><span class="s2">\n</span><span class="s1">var globalObj = typeof window !== </span><span class="s2">\&quot;</span><span class="s1">undefined</span><span class="s2">\&quot; </span><span class="s1">? window : typeof globalThis !== </span><span class="s2">\&quot;</span><span class="s1">undefined</span><span class="s2">\&quot; </span><span class="s1">? globalThis : void 0;</span><span class="s2">\n</span><span class="s1">function unflatten(parsed) {</span><span class="s2">\n  </span><span class="s1">const {</span><span class="s2">\n    </span><span class="s1">hydrated,</span><span class="s2">\n    </span><span class="s1">values</span><span class="s2">\n  </span><span class="s1">} = this;</span><span class="s2">\n  </span><span class="s1">if (typeof parsed === </span><span class="s2">\&quot;</span><span class="s1">number</span><span class="s2">\&quot;</span><span class="s1">) return hydrate.call(this, parsed);</span><span class="s2">\n  </span><span class="s1">if (!Array.isArray(parsed) || !parsed.length) throw new SyntaxError();</span><span class="s2">\n  </span><span class="s1">const startIndex = values.length;</span><span class="s2">\n  </span><span class="s1">for (const value of parsed) {</span><span class="s2">\n    </span><span class="s1">values.push(value);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">hydrated.length = values.length;</span><span class="s2">\n  </span><span class="s1">return hydrate.call(this, startIndex);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function hydrate(index) {</span><span class="s2">\n  </span><span class="s1">const {</span><span class="s2">\n    </span><span class="s1">hydrated,</span><span class="s2">\n    </span><span class="s1">values,</span><span class="s2">\n    </span><span class="s1">deferred,</span><span class="s2">\n    </span><span class="s1">plugins</span><span class="s2">\n  </span><span class="s1">} = this;</span><span class="s2">\n  </span><span class="s1">let result;</span><span class="s2">\n  </span><span class="s1">const stack = [[index, v =&gt; {</span><span class="s2">\n    </span><span class="s1">result = v;</span><span class="s2">\n  </span><span class="s1">}]];</span><span class="s2">\n  </span><span class="s1">let postRun = [];</span><span class="s2">\n  </span><span class="s1">while (stack.length &gt; 0) {</span><span class="s2">\n    </span><span class="s1">const [index2, set] = stack.pop();</span><span class="s2">\n    </span><span class="s1">switch (index2) {</span><span class="s2">\n      </span><span class="s1">case UNDEFINED:</span><span class="s2">\n        </span><span class="s1">set(void 0);</span><span class="s2">\n        </span><span class="s1">continue;</span><span class="s2">\n      </span><span class="s1">case NULL:</span><span class="s2">\n        </span><span class="s1">set(null);</span><span class="s2">\n        </span><span class="s1">continue;</span><span class="s2">\n      </span><span class="s1">case NAN:</span><span class="s2">\n        </span><span class="s1">set(NaN);</span><span class="s2">\n        </span><span class="s1">continue;</span><span class="s2">\n      </span><span class="s1">case POSITIVE_INFINITY:</span><span class="s2">\n        </span><span class="s1">set(Infinity);</span><span class="s2">\n        </span><span class="s1">continue;</span><span class="s2">\n      </span><span class="s1">case NEGATIVE_INFINITY:</span><span class="s2">\n        </span><span class="s1">set(-Infinity);</span><span class="s2">\n        </span><span class="s1">continue;</span><span class="s2">\n      </span><span class="s1">case NEGATIVE_ZERO:</span><span class="s2">\n        </span><span class="s1">set(-0);</span><span class="s2">\n        </span><span class="s1">continue;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (hydrated[index2]) {</span><span class="s2">\n      </span><span class="s1">set(hydrated[index2]);</span><span class="s2">\n      </span><span class="s1">continue;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">const value = values[index2];</span><span class="s2">\n    </span><span class="s1">if (!value || typeof value !== </span><span class="s2">\&quot;</span><span class="s1">object</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">hydrated[index2] = value;</span><span class="s2">\n      </span><span class="s1">set(value);</span><span class="s2">\n      </span><span class="s1">continue;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (Array.isArray(value)) {</span><span class="s2">\n      </span><span class="s1">if (typeof value[0] === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">const [type, b, c] = value;</span><span class="s2">\n        </span><span class="s1">switch (type) {</span><span class="s2">\n          </span><span class="s1">case TYPE_DATE:</span><span class="s2">\n            </span><span class="s1">set(hydrated[index2] = new Date(b));</span><span class="s2">\n            </span><span class="s1">continue;</span><span class="s2">\n          </span><span class="s1">case TYPE_URL:</span><span class="s2">\n            </span><span class="s1">set(hydrated[index2] = new URL(b));</span><span class="s2">\n            </span><span class="s1">continue;</span><span class="s2">\n          </span><span class="s1">case TYPE_BIGINT:</span><span class="s2">\n            </span><span class="s1">set(hydrated[index2] = BigInt(b));</span><span class="s2">\n            </span><span class="s1">continue;</span><span class="s2">\n          </span><span class="s1">case TYPE_REGEXP:</span><span class="s2">\n            </span><span class="s1">set(hydrated[index2] = new RegExp(b, c));</span><span class="s2">\n            </span><span class="s1">continue;</span><span class="s2">\n          </span><span class="s1">case TYPE_SYMBOL:</span><span class="s2">\n            </span><span class="s1">set(hydrated[index2] = Symbol.for(b));</span><span class="s2">\n            </span><span class="s1">continue;</span><span class="s2">\n          </span><span class="s1">case TYPE_SET:</span><span class="s2">\n            </span><span class="s1">const newSet = /* @__PURE__ */new Set();</span><span class="s2">\n            </span><span class="s1">hydrated[index2] = newSet;</span><span class="s2">\n            </span><span class="s1">for (let i = value.length - 1; i &gt; 0; i--) stack.push([value[i], v =&gt; {</span><span class="s2">\n              </span><span class="s1">newSet.add(v);</span><span class="s2">\n            </span><span class="s1">}]);</span><span class="s2">\n            </span><span class="s1">set(newSet);</span><span class="s2">\n            </span><span class="s1">continue;</span><span class="s2">\n          </span><span class="s1">case TYPE_MAP:</span><span class="s2">\n            </span><span class="s1">const map = /* @__PURE__ */new Map();</span><span class="s2">\n            </span><span class="s1">hydrated[index2] = map;</span><span class="s2">\n            </span><span class="s1">for (let i = value.length - 2; i &gt; 0; i -= 2) {</span><span class="s2">\n              </span><span class="s1">const r = [];</span><span class="s2">\n              </span><span class="s1">stack.push([value[i + 1], v =&gt; {</span><span class="s2">\n                </span><span class="s1">r[1] = v;</span><span class="s2">\n              </span><span class="s1">}]);</span><span class="s2">\n              </span><span class="s1">stack.push([value[i], k =&gt; {</span><span class="s2">\n                </span><span class="s1">r[0] = k;</span><span class="s2">\n              </span><span class="s1">}]);</span><span class="s2">\n              </span><span class="s1">postRun.push(() =&gt; {</span><span class="s2">\n                </span><span class="s1">map.set(r[0], r[1]);</span><span class="s2">\n              </span><span class="s1">});</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">set(map);</span><span class="s2">\n            </span><span class="s1">continue;</span><span class="s2">\n          </span><span class="s1">case TYPE_NULL_OBJECT:</span><span class="s2">\n            </span><span class="s1">const obj = /* @__PURE__ */Object.create(null);</span><span class="s2">\n            </span><span class="s1">hydrated[index2] = obj;</span><span class="s2">\n            </span><span class="s1">for (const key of Object.keys(b).reverse()) {</span><span class="s2">\n              </span><span class="s1">const r = [];</span><span class="s2">\n              </span><span class="s1">stack.push([b[key], v =&gt; {</span><span class="s2">\n                </span><span class="s1">r[1] = v;</span><span class="s2">\n              </span><span class="s1">}]);</span><span class="s2">\n              </span><span class="s1">stack.push([Number(key.slice(1)), k =&gt; {</span><span class="s2">\n                </span><span class="s1">r[0] = k;</span><span class="s2">\n              </span><span class="s1">}]);</span><span class="s2">\n              </span><span class="s1">postRun.push(() =&gt; {</span><span class="s2">\n                </span><span class="s1">obj[r[0]] = r[1];</span><span class="s2">\n              </span><span class="s1">});</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">set(obj);</span><span class="s2">\n            </span><span class="s1">continue;</span><span class="s2">\n          </span><span class="s1">case TYPE_PROMISE:</span><span class="s2">\n            </span><span class="s1">if (hydrated[b]) {</span><span class="s2">\n              </span><span class="s1">set(hydrated[index2] = hydrated[b]);</span><span class="s2">\n            </span><span class="s1">} else {</span><span class="s2">\n              </span><span class="s1">const d = new Deferred2();</span><span class="s2">\n              </span><span class="s1">deferred[b] = d;</span><span class="s2">\n              </span><span class="s1">set(hydrated[index2] = d.promise);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">continue;</span><span class="s2">\n          </span><span class="s1">case TYPE_ERROR:</span><span class="s2">\n            </span><span class="s1">const [, message, errorType] = value;</span><span class="s2">\n            </span><span class="s1">let error = errorType &amp;&amp; globalObj &amp;&amp; globalObj[errorType] ? new globalObj[errorType](message) : new Error(message);</span><span class="s2">\n            </span><span class="s1">hydrated[index2] = error;</span><span class="s2">\n            </span><span class="s1">set(error);</span><span class="s2">\n            </span><span class="s1">continue;</span><span class="s2">\n          </span><span class="s1">case TYPE_PREVIOUS_RESOLVED:</span><span class="s2">\n            </span><span class="s1">set(hydrated[index2] = hydrated[b]);</span><span class="s2">\n            </span><span class="s1">continue;</span><span class="s2">\n          </span><span class="s1">default:</span><span class="s2">\n            </span><span class="s1">if (Array.isArray(plugins)) {</span><span class="s2">\n              </span><span class="s1">const r = [];</span><span class="s2">\n              </span><span class="s1">const vals = value.slice(1);</span><span class="s2">\n              </span><span class="s1">for (let i = 0; i &lt; vals.length; i++) {</span><span class="s2">\n                </span><span class="s1">const v = vals[i];</span><span class="s2">\n                </span><span class="s1">stack.push([v, v2 =&gt; {</span><span class="s2">\n                  </span><span class="s1">r[i] = v2;</span><span class="s2">\n                </span><span class="s1">}]);</span><span class="s2">\n              </span><span class="s1">}</span><span class="s2">\n              </span><span class="s1">postRun.push(() =&gt; {</span><span class="s2">\n                </span><span class="s1">for (const plugin of plugins) {</span><span class="s2">\n                  </span><span class="s1">const result2 = plugin(value[0], ...r);</span><span class="s2">\n                  </span><span class="s1">if (result2) {</span><span class="s2">\n                    </span><span class="s1">set(hydrated[index2] = result2.value);</span><span class="s2">\n                    </span><span class="s1">return;</span><span class="s2">\n                  </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">throw new SyntaxError();</span><span class="s2">\n              </span><span class="s1">});</span><span class="s2">\n              </span><span class="s1">continue;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">throw new SyntaxError();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">const array = [];</span><span class="s2">\n        </span><span class="s1">hydrated[index2] = array;</span><span class="s2">\n        </span><span class="s1">for (let i = 0; i &lt; value.length; i++) {</span><span class="s2">\n          </span><span class="s1">const n = value[i];</span><span class="s2">\n          </span><span class="s1">if (n !== HOLE) {</span><span class="s2">\n            </span><span class="s1">stack.push([n, v =&gt; {</span><span class="s2">\n              </span><span class="s1">array[i] = v;</span><span class="s2">\n            </span><span class="s1">}]);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">set(array);</span><span class="s2">\n        </span><span class="s1">continue;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">const object = {};</span><span class="s2">\n      </span><span class="s1">hydrated[index2] = object;</span><span class="s2">\n      </span><span class="s1">for (const key of Object.keys(value).reverse()) {</span><span class="s2">\n        </span><span class="s1">const r = [];</span><span class="s2">\n        </span><span class="s1">stack.push([value[key], v =&gt; {</span><span class="s2">\n          </span><span class="s1">r[1] = v;</span><span class="s2">\n        </span><span class="s1">}]);</span><span class="s2">\n        </span><span class="s1">stack.push([Number(key.slice(1)), k =&gt; {</span><span class="s2">\n          </span><span class="s1">r[0] = k;</span><span class="s2">\n        </span><span class="s1">}]);</span><span class="s2">\n        </span><span class="s1">postRun.push(() =&gt; {</span><span class="s2">\n          </span><span class="s1">object[r[0]] = r[1];</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">set(object);</span><span class="s2">\n      </span><span class="s1">continue;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">while (postRun.length &gt; 0) {</span><span class="s2">\n    </span><span class="s1">postRun.pop()();</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return result;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// vendor/turbo-stream-v2/turbo-stream.ts</span><span class="s2">\n</span><span class="s1">async function decode(readable, options) {</span><span class="s2">\n  </span><span class="s1">const {</span><span class="s2">\n    </span><span class="s1">plugins</span><span class="s2">\n  </span><span class="s1">} = options ?? {};</span><span class="s2">\n  </span><span class="s1">const done = new Deferred2();</span><span class="s2">\n  </span><span class="s1">const reader = readable.pipeThrough(createLineSplittingTransform()).getReader();</span><span class="s2">\n  </span><span class="s1">const decoder = {</span><span class="s2">\n    </span><span class="s1">values: [],</span><span class="s2">\n    </span><span class="s1">hydrated: [],</span><span class="s2">\n    </span><span class="s1">deferred: {},</span><span class="s2">\n    </span><span class="s1">plugins</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">const decoded = await decodeInitial.call(decoder, reader);</span><span class="s2">\n  </span><span class="s1">let donePromise = done.promise;</span><span class="s2">\n  </span><span class="s1">if (decoded.done) {</span><span class="s2">\n    </span><span class="s1">done.resolve();</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">donePromise = decodeDeferred.call(decoder, reader).then(done.resolve).catch(reason =&gt; {</span><span class="s2">\n      </span><span class="s1">for (const deferred of Object.values(decoder.deferred)) {</span><span class="s2">\n        </span><span class="s1">deferred.reject(reason);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">done.reject(reason);</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">done: donePromise.then(() =&gt; reader.closed),</span><span class="s2">\n    </span><span class="s1">value: decoded.value</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">async function decodeInitial(reader) {</span><span class="s2">\n  </span><span class="s1">const read = await reader.read();</span><span class="s2">\n  </span><span class="s1">if (!read.value) {</span><span class="s2">\n    </span><span class="s1">throw new SyntaxError();</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let line;</span><span class="s2">\n  </span><span class="s1">try {</span><span class="s2">\n    </span><span class="s1">line = JSON.parse(read.value);</span><span class="s2">\n  </span><span class="s1">} catch (reason) {</span><span class="s2">\n    </span><span class="s1">throw new SyntaxError();</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">done: read.done,</span><span class="s2">\n    </span><span class="s1">value: unflatten.call(this, line)</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">async function decodeDeferred(reader) {</span><span class="s2">\n  </span><span class="s1">let read = await reader.read();</span><span class="s2">\n  </span><span class="s1">while (!read.done) {</span><span class="s2">\n    </span><span class="s1">if (!read.value) continue;</span><span class="s2">\n    </span><span class="s1">const line = read.value;</span><span class="s2">\n    </span><span class="s1">switch (line[0]) {</span><span class="s2">\n      </span><span class="s1">case TYPE_PROMISE:</span><span class="s2">\n        </span><span class="s1">{</span><span class="s2">\n          </span><span class="s1">const colonIndex = line.indexOf(</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">const deferredId = Number(line.slice(1, colonIndex));</span><span class="s2">\n          </span><span class="s1">const deferred = this.deferred[deferredId];</span><span class="s2">\n          </span><span class="s1">if (!deferred) {</span><span class="s2">\n            </span><span class="s1">throw new Error(`Deferred ID ${deferredId} not found in stream`);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">const lineData = line.slice(colonIndex + 1);</span><span class="s2">\n          </span><span class="s1">let jsonLine;</span><span class="s2">\n          </span><span class="s1">try {</span><span class="s2">\n            </span><span class="s1">jsonLine = JSON.parse(lineData);</span><span class="s2">\n          </span><span class="s1">} catch (reason) {</span><span class="s2">\n            </span><span class="s1">throw new SyntaxError();</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">const value = unflatten.call(this, jsonLine);</span><span class="s2">\n          </span><span class="s1">deferred.resolve(value);</span><span class="s2">\n          </span><span class="s1">break;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">case TYPE_ERROR:</span><span class="s2">\n        </span><span class="s1">{</span><span class="s2">\n          </span><span class="s1">const colonIndex = line.indexOf(</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">const deferredId = Number(line.slice(1, colonIndex));</span><span class="s2">\n          </span><span class="s1">const deferred = this.deferred[deferredId];</span><span class="s2">\n          </span><span class="s1">if (!deferred) {</span><span class="s2">\n            </span><span class="s1">throw new Error(`Deferred ID ${deferredId} not found in stream`);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">const lineData = line.slice(colonIndex + 1);</span><span class="s2">\n          </span><span class="s1">let jsonLine;</span><span class="s2">\n          </span><span class="s1">try {</span><span class="s2">\n            </span><span class="s1">jsonLine = JSON.parse(lineData);</span><span class="s2">\n          </span><span class="s1">} catch (reason) {</span><span class="s2">\n            </span><span class="s1">throw new SyntaxError();</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">const value = unflatten.call(this, jsonLine);</span><span class="s2">\n          </span><span class="s1">deferred.reject(value);</span><span class="s2">\n          </span><span class="s1">break;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">default:</span><span class="s2">\n        </span><span class="s1">throw new SyntaxError();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">read = await reader.read();</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function encode(input, options) {</span><span class="s2">\n  </span><span class="s1">const {</span><span class="s2">\n    </span><span class="s1">plugins,</span><span class="s2">\n    </span><span class="s1">postPlugins,</span><span class="s2">\n    </span><span class="s1">signal</span><span class="s2">\n  </span><span class="s1">} = options ?? {};</span><span class="s2">\n  </span><span class="s1">const encoder2 = {</span><span class="s2">\n    </span><span class="s1">deferred: {},</span><span class="s2">\n    </span><span class="s1">index: 0,</span><span class="s2">\n    </span><span class="s1">indices: /* @__PURE__ */new Map(),</span><span class="s2">\n    </span><span class="s1">stringified: [],</span><span class="s2">\n    </span><span class="s1">plugins,</span><span class="s2">\n    </span><span class="s1">postPlugins,</span><span class="s2">\n    </span><span class="s1">signal</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">const textEncoder = new TextEncoder();</span><span class="s2">\n  </span><span class="s1">let lastSentIndex = 0;</span><span class="s2">\n  </span><span class="s1">const readable = new ReadableStream({</span><span class="s2">\n    </span><span class="s1">async start(controller) {</span><span class="s2">\n      </span><span class="s1">const id = flatten.call(encoder2, input);</span><span class="s2">\n      </span><span class="s1">if (Array.isArray(id)) {</span><span class="s2">\n        </span><span class="s1">throw new Error(</span><span class="s2">\&quot;</span><span class="s1">This should never happen</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (id &lt; 0) {</span><span class="s2">\n        </span><span class="s1">controller.enqueue(textEncoder.encode(`${id}</span><span class="s2">\n</span><span class="s1">`));</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">controller.enqueue(textEncoder.encode(`[${encoder2.stringified.join(</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\&quot;</span><span class="s1">)}]</span><span class="s2">\n</span><span class="s1">`));</span><span class="s2">\n        </span><span class="s1">lastSentIndex = encoder2.stringified.length - 1;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">const seenPromises = /* @__PURE__ */new WeakSet();</span><span class="s2">\n      </span><span class="s1">if (Object.keys(encoder2.deferred).length) {</span><span class="s2">\n        </span><span class="s1">let raceDone;</span><span class="s2">\n        </span><span class="s1">const racePromise = new Promise((resolve, reject) =&gt; {</span><span class="s2">\n          </span><span class="s1">raceDone = resolve;</span><span class="s2">\n          </span><span class="s1">if (signal) {</span><span class="s2">\n            </span><span class="s1">const rejectPromise = () =&gt; reject(signal.reason || new Error(</span><span class="s2">\&quot;</span><span class="s1">Signal was aborted.</span><span class="s2">\&quot;</span><span class="s1">));</span><span class="s2">\n            </span><span class="s1">if (signal.aborted) {</span><span class="s2">\n              </span><span class="s1">rejectPromise();</span><span class="s2">\n            </span><span class="s1">} else {</span><span class="s2">\n              </span><span class="s1">signal.addEventListener(</span><span class="s2">\&quot;</span><span class="s1">abort</span><span class="s2">\&quot;</span><span class="s1">, event =&gt; {</span><span class="s2">\n                </span><span class="s1">rejectPromise();</span><span class="s2">\n              </span><span class="s1">});</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">while (Object.keys(encoder2.deferred).length &gt; 0) {</span><span class="s2">\n          </span><span class="s1">for (const [deferredId, deferred] of Object.entries(encoder2.deferred)) {</span><span class="s2">\n            </span><span class="s1">if (seenPromises.has(deferred)) continue;</span><span class="s2">\n            </span><span class="s1">seenPromises.add(</span><span class="s2">\n            </span><span class="s1">// biome-ignore lint/suspicious/noAssignInExpressions: &lt;explanation&gt;</span><span class="s2">\n            </span><span class="s1">encoder2.deferred[Number(deferredId)] = Promise.race([racePromise, deferred]).then(resolved =&gt; {</span><span class="s2">\n              </span><span class="s1">const id2 = flatten.call(encoder2, resolved);</span><span class="s2">\n              </span><span class="s1">if (Array.isArray(id2)) {</span><span class="s2">\n                </span><span class="s1">controller.enqueue(textEncoder.encode(`${TYPE_PROMISE}${deferredId}:[[</span><span class="s2">\&quot;</span><span class="s1">${TYPE_PREVIOUS_RESOLVED}</span><span class="s2">\&quot;</span><span class="s1">,${id2[0]}]]</span><span class="s2">\n</span><span class="s1">`));</span><span class="s2">\n                </span><span class="s1">encoder2.index++;</span><span class="s2">\n                </span><span class="s1">lastSentIndex++;</span><span class="s2">\n              </span><span class="s1">} else if (id2 &lt; 0) {</span><span class="s2">\n                </span><span class="s1">controller.enqueue(textEncoder.encode(`${TYPE_PROMISE}${deferredId}:${id2}</span><span class="s2">\n</span><span class="s1">`));</span><span class="s2">\n              </span><span class="s1">} else {</span><span class="s2">\n                </span><span class="s1">const values = encoder2.stringified.slice(lastSentIndex + 1).join(</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n                </span><span class="s1">controller.enqueue(textEncoder.encode(`${TYPE_PROMISE}${deferredId}:[${values}]</span><span class="s2">\n</span><span class="s1">`));</span><span class="s2">\n                </span><span class="s1">lastSentIndex = encoder2.stringified.length - 1;</span><span class="s2">\n              </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}, reason =&gt; {</span><span class="s2">\n              </span><span class="s1">if (!reason || typeof reason !== </span><span class="s2">\&quot;</span><span class="s1">object</span><span class="s2">\&quot; </span><span class="s1">|| !(reason instanceof Error)) {</span><span class="s2">\n                </span><span class="s1">reason = new Error(</span><span class="s2">\&quot;</span><span class="s1">An unknown error occurred</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n              </span><span class="s1">}</span><span class="s2">\n              </span><span class="s1">const id2 = flatten.call(encoder2, reason);</span><span class="s2">\n              </span><span class="s1">if (Array.isArray(id2)) {</span><span class="s2">\n                </span><span class="s1">controller.enqueue(textEncoder.encode(`${TYPE_ERROR}${deferredId}:[[</span><span class="s2">\&quot;</span><span class="s1">${TYPE_PREVIOUS_RESOLVED}</span><span class="s2">\&quot;</span><span class="s1">,${id2[0]}]]</span><span class="s2">\n</span><span class="s1">`));</span><span class="s2">\n                </span><span class="s1">encoder2.index++;</span><span class="s2">\n                </span><span class="s1">lastSentIndex++;</span><span class="s2">\n              </span><span class="s1">} else if (id2 &lt; 0) {</span><span class="s2">\n                </span><span class="s1">controller.enqueue(textEncoder.encode(`${TYPE_ERROR}${deferredId}:${id2}</span><span class="s2">\n</span><span class="s1">`));</span><span class="s2">\n              </span><span class="s1">} else {</span><span class="s2">\n                </span><span class="s1">const values = encoder2.stringified.slice(lastSentIndex + 1).join(</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n                </span><span class="s1">controller.enqueue(textEncoder.encode(`${TYPE_ERROR}${deferredId}:[${values}]</span><span class="s2">\n</span><span class="s1">`));</span><span class="s2">\n                </span><span class="s1">lastSentIndex = encoder2.stringified.length - 1;</span><span class="s2">\n              </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}).finally(() =&gt; {</span><span class="s2">\n              </span><span class="s1">delete encoder2.deferred[Number(deferredId)];</span><span class="s2">\n            </span><span class="s1">}));</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">await Promise.race(Object.values(encoder2.deferred));</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">raceDone();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">await Promise.all(Object.values(encoder2.deferred));</span><span class="s2">\n      </span><span class="s1">controller.close();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">return readable;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/dom/ssr/data.ts</span><span class="s2">\n</span><span class="s1">async function createRequestInit(request) {</span><span class="s2">\n  </span><span class="s1">let init = {</span><span class="s2">\n    </span><span class="s1">signal: request.signal</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">if (request.method !== </span><span class="s2">\&quot;</span><span class="s1">GET</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">init.method = request.method;</span><span class="s2">\n    </span><span class="s1">let contentType = request.headers.get(</span><span class="s2">\&quot;</span><span class="s1">Content-Type</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">if (contentType &amp;&amp; /</span><span class="s2">\\</span><span class="s1">bapplication</span><span class="s2">\\</span><span class="s1">/json</span><span class="s2">\\</span><span class="s1">b/.test(contentType)) {</span><span class="s2">\n      </span><span class="s1">init.headers = {</span><span class="s2">\n        \&quot;</span><span class="s1">Content-Type</span><span class="s2">\&quot;</span><span class="s1">: contentType</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">init.body = JSON.stringify(await request.json());</span><span class="s2">\n    </span><span class="s1">} else if (contentType &amp;&amp; /</span><span class="s2">\\</span><span class="s1">btext</span><span class="s2">\\</span><span class="s1">/plain</span><span class="s2">\\</span><span class="s1">b/.test(contentType)) {</span><span class="s2">\n      </span><span class="s1">init.headers = {</span><span class="s2">\n        \&quot;</span><span class="s1">Content-Type</span><span class="s2">\&quot;</span><span class="s1">: contentType</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">init.body = await request.text();</span><span class="s2">\n    </span><span class="s1">} else if (contentType &amp;&amp; /</span><span class="s2">\\</span><span class="s1">bapplication</span><span class="s2">\\</span><span class="s1">/x-www-form-urlencoded</span><span class="s2">\\</span><span class="s1">b/.test(contentType)) {</span><span class="s2">\n      </span><span class="s1">init.body = new URLSearchParams(await request.text());</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">init.body = await request.formData();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return init;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/dom/ssr/single-fetch.tsx</span><span class="s2">\n</span><span class="s1">var SingleFetchRedirectSymbol = Symbol(</span><span class="s2">\&quot;</span><span class="s1">SingleFetchRedirect</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n</span><span class="s1">var SingleFetchNoResultError = class extends Error {};</span><span class="s2">\n</span><span class="s1">var SINGLE_FETCH_REDIRECT_STATUS = 202;</span><span class="s2">\n</span><span class="s1">var NO_BODY_STATUS_CODES = /* @__PURE__ */new Set([100, 101, 204, 205]);</span><span class="s2">\n</span><span class="s1">function StreamTransfer({</span><span class="s2">\n  </span><span class="s1">context,</span><span class="s2">\n  </span><span class="s1">identifier,</span><span class="s2">\n  </span><span class="s1">reader,</span><span class="s2">\n  </span><span class="s1">textDecoder,</span><span class="s2">\n  </span><span class="s1">nonce</span><span class="s2">\n</span><span class="s1">}) {</span><span class="s2">\n  </span><span class="s1">if (!context.renderMeta || !context.renderMeta.didRenderScripts) {</span><span class="s2">\n    </span><span class="s1">return null;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (!context.renderMeta.streamCache) {</span><span class="s2">\n    </span><span class="s1">context.renderMeta.streamCache = {};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let {</span><span class="s2">\n    </span><span class="s1">streamCache</span><span class="s2">\n  </span><span class="s1">} = context.renderMeta;</span><span class="s2">\n  </span><span class="s1">let promise = streamCache[identifier];</span><span class="s2">\n  </span><span class="s1">if (!promise) {</span><span class="s2">\n    </span><span class="s1">promise = streamCache[identifier] = reader.read().then(result =&gt; {</span><span class="s2">\n      </span><span class="s1">streamCache[identifier].result = {</span><span class="s2">\n        </span><span class="s1">done: result.done,</span><span class="s2">\n        </span><span class="s1">value: textDecoder.decode(result.value, {</span><span class="s2">\n          </span><span class="s1">stream: true</span><span class="s2">\n        </span><span class="s1">})</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}).catch(e =&gt; {</span><span class="s2">\n      </span><span class="s1">streamCache[identifier].error = e;</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (promise.error) {</span><span class="s2">\n    </span><span class="s1">throw promise.error;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (promise.result === void 0) {</span><span class="s2">\n    </span><span class="s1">throw promise;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let {</span><span class="s2">\n    </span><span class="s1">done,</span><span class="s2">\n    </span><span class="s1">value</span><span class="s2">\n  </span><span class="s1">} = promise.result;</span><span class="s2">\n  </span><span class="s1">let scriptTag = value ? /* @__PURE__ */React4.createElement(</span><span class="s2">\&quot;</span><span class="s1">script</span><span class="s2">\&quot;</span><span class="s1">, {</span><span class="s2">\n    </span><span class="s1">nonce,</span><span class="s2">\n    </span><span class="s1">dangerouslySetInnerHTML: {</span><span class="s2">\n      </span><span class="s1">__html: `window.__reactRouterContext.streamController.enqueue(${escapeHtml(JSON.stringify(value))});`</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}) : null;</span><span class="s2">\n  </span><span class="s1">if (done) {</span><span class="s2">\n    </span><span class="s1">return /* @__PURE__ */React4.createElement(React4.Fragment, null, scriptTag, /* @__PURE__ */React4.createElement(</span><span class="s2">\&quot;</span><span class="s1">script</span><span class="s2">\&quot;</span><span class="s1">, {</span><span class="s2">\n      </span><span class="s1">nonce,</span><span class="s2">\n      </span><span class="s1">dangerouslySetInnerHTML: {</span><span class="s2">\n        </span><span class="s1">__html: `window.__reactRouterContext.streamController.close();`</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}));</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">return /* @__PURE__ */React4.createElement(React4.Fragment, null, scriptTag, /* @__PURE__ */React4.createElement(React4.Suspense, null, /* @__PURE__ */React4.createElement(StreamTransfer, {</span><span class="s2">\n      </span><span class="s1">context,</span><span class="s2">\n      </span><span class="s1">identifier: identifier + 1,</span><span class="s2">\n      </span><span class="s1">reader,</span><span class="s2">\n      </span><span class="s1">textDecoder,</span><span class="s2">\n      </span><span class="s1">nonce</span><span class="s2">\n    </span><span class="s1">})));</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getTurboStreamSingleFetchDataStrategy(getRouter, manifest, routeModules, ssr, basename) {</span><span class="s2">\n  </span><span class="s1">let dataStrategy = getSingleFetchDataStrategyImpl(getRouter, match =&gt; {</span><span class="s2">\n    </span><span class="s1">let manifestRoute = manifest.routes[match.route.id];</span><span class="s2">\n    </span><span class="s1">invariant2(manifestRoute, </span><span class="s2">\&quot;</span><span class="s1">Route not found in manifest</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">let routeModule = routeModules[match.route.id];</span><span class="s2">\n    </span><span class="s1">return {</span><span class="s2">\n      </span><span class="s1">hasLoader: manifestRoute.hasLoader,</span><span class="s2">\n      </span><span class="s1">hasClientLoader: manifestRoute.hasClientLoader,</span><span class="s2">\n      </span><span class="s1">hasShouldRevalidate: Boolean(routeModule?.shouldRevalidate)</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}, fetchAndDecodeViaTurboStream, ssr, basename);</span><span class="s2">\n  </span><span class="s1">return async args =&gt; args.unstable_runClientMiddleware(dataStrategy);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getSingleFetchDataStrategyImpl(getRouter, getRouteInfo, fetchAndDecode, ssr, basename) {</span><span class="s2">\n  </span><span class="s1">return async args =&gt; {</span><span class="s2">\n    </span><span class="s1">let {</span><span class="s2">\n      </span><span class="s1">request,</span><span class="s2">\n      </span><span class="s1">matches,</span><span class="s2">\n      </span><span class="s1">fetcherKey</span><span class="s2">\n    </span><span class="s1">} = args;</span><span class="s2">\n    </span><span class="s1">let router = getRouter();</span><span class="s2">\n    </span><span class="s1">if (request.method !== </span><span class="s2">\&quot;</span><span class="s1">GET</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">return singleFetchActionStrategy(args, fetchAndDecode, basename);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let foundRevalidatingServerLoader = matches.some(m =&gt; {</span><span class="s2">\n      </span><span class="s1">let {</span><span class="s2">\n        </span><span class="s1">hasLoader,</span><span class="s2">\n        </span><span class="s1">hasClientLoader</span><span class="s2">\n      </span><span class="s1">} = getRouteInfo(m);</span><span class="s2">\n      </span><span class="s1">return m.unstable_shouldCallHandler() &amp;&amp; hasLoader &amp;&amp; !hasClientLoader;</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">if (!ssr &amp;&amp; !foundRevalidatingServerLoader) {</span><span class="s2">\n      </span><span class="s1">return nonSsrStrategy(args, getRouteInfo, fetchAndDecode, basename);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (fetcherKey) {</span><span class="s2">\n      </span><span class="s1">return singleFetchLoaderFetcherStrategy(args, fetchAndDecode, basename);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return singleFetchLoaderNavigationStrategy(args, router, getRouteInfo, fetchAndDecode, ssr, basename);</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">async function singleFetchActionStrategy(args, fetchAndDecode, basename) {</span><span class="s2">\n  </span><span class="s1">let actionMatch = args.matches.find(m =&gt; m.unstable_shouldCallHandler());</span><span class="s2">\n  </span><span class="s1">invariant2(actionMatch, </span><span class="s2">\&quot;</span><span class="s1">No action match found</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let actionStatus = void 0;</span><span class="s2">\n  </span><span class="s1">let result = await actionMatch.resolve(async handler =&gt; {</span><span class="s2">\n    </span><span class="s1">let result2 = await handler(async () =&gt; {</span><span class="s2">\n      </span><span class="s1">let {</span><span class="s2">\n        </span><span class="s1">data: data2,</span><span class="s2">\n        </span><span class="s1">status</span><span class="s2">\n      </span><span class="s1">} = await fetchAndDecode(args, basename, [actionMatch.route.id]);</span><span class="s2">\n      </span><span class="s1">actionStatus = status;</span><span class="s2">\n      </span><span class="s1">return unwrapSingleFetchResult(data2, actionMatch.route.id);</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">return result2;</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">if (isResponse(result.result) || isRouteErrorResponse(result.result) || isDataWithResponseInit(result.result)) {</span><span class="s2">\n    </span><span class="s1">return {</span><span class="s2">\n      </span><span class="s1">[actionMatch.route.id]: result</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">[actionMatch.route.id]: {</span><span class="s2">\n      </span><span class="s1">type: result.type,</span><span class="s2">\n      </span><span class="s1">result: data(result.result, actionStatus)</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">async function nonSsrStrategy(args, getRouteInfo, fetchAndDecode, basename) {</span><span class="s2">\n  </span><span class="s1">let matchesToLoad = args.matches.filter(m =&gt; m.unstable_shouldCallHandler());</span><span class="s2">\n  </span><span class="s1">let results = {};</span><span class="s2">\n  </span><span class="s1">await Promise.all(matchesToLoad.map(m =&gt; m.resolve(async handler =&gt; {</span><span class="s2">\n    </span><span class="s1">try {</span><span class="s2">\n      </span><span class="s1">let {</span><span class="s2">\n        </span><span class="s1">hasClientLoader</span><span class="s2">\n      </span><span class="s1">} = getRouteInfo(m);</span><span class="s2">\n      </span><span class="s1">let routeId = m.route.id;</span><span class="s2">\n      </span><span class="s1">let result = hasClientLoader ? await handler(async () =&gt; {</span><span class="s2">\n        </span><span class="s1">let {</span><span class="s2">\n          </span><span class="s1">data: data2</span><span class="s2">\n        </span><span class="s1">} = await fetchAndDecode(args, basename, [routeId]);</span><span class="s2">\n        </span><span class="s1">return unwrapSingleFetchResult(data2, routeId);</span><span class="s2">\n      </span><span class="s1">}) : await handler();</span><span class="s2">\n      </span><span class="s1">results[m.route.id] = {</span><span class="s2">\n        </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">data</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        </span><span class="s1">result</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">} catch (e) {</span><span class="s2">\n      </span><span class="s1">results[m.route.id] = {</span><span class="s2">\n        </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">error</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        </span><span class="s1">result: e</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">})));</span><span class="s2">\n  </span><span class="s1">return results;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">async function singleFetchLoaderNavigationStrategy(args, router, getRouteInfo, fetchAndDecode, ssr, basename) {</span><span class="s2">\n  </span><span class="s1">let routesParams = /* @__PURE__ */new Set();</span><span class="s2">\n  </span><span class="s1">let foundOptOutRoute = false;</span><span class="s2">\n  </span><span class="s1">let routeDfds = args.matches.map(() =&gt; createDeferred2());</span><span class="s2">\n  </span><span class="s1">let singleFetchDfd = createDeferred2();</span><span class="s2">\n  </span><span class="s1">let results = {};</span><span class="s2">\n  </span><span class="s1">let resolvePromise = Promise.all(args.matches.map(async (m, i) =&gt; m.resolve(async handler =&gt; {</span><span class="s2">\n    </span><span class="s1">routeDfds[i].resolve();</span><span class="s2">\n    </span><span class="s1">let routeId = m.route.id;</span><span class="s2">\n    </span><span class="s1">let {</span><span class="s2">\n      </span><span class="s1">hasLoader,</span><span class="s2">\n      </span><span class="s1">hasClientLoader,</span><span class="s2">\n      </span><span class="s1">hasShouldRevalidate</span><span class="s2">\n    </span><span class="s1">} = getRouteInfo(m);</span><span class="s2">\n    </span><span class="s1">let defaultShouldRevalidate = !m.unstable_shouldRevalidateArgs || m.unstable_shouldRevalidateArgs.actionStatus == null || m.unstable_shouldRevalidateArgs.actionStatus &lt; 400;</span><span class="s2">\n    </span><span class="s1">let shouldCall = m.unstable_shouldCallHandler(defaultShouldRevalidate);</span><span class="s2">\n    </span><span class="s1">if (!shouldCall) {</span><span class="s2">\n      </span><span class="s1">foundOptOutRoute || (foundOptOutRoute = m.unstable_shouldRevalidateArgs != null &amp;&amp;</span><span class="s2">\n      </span><span class="s1">// This is a revalidation,</span><span class="s2">\n      </span><span class="s1">hasLoader &amp;&amp;</span><span class="s2">\n      </span><span class="s1">// for a route with a server loader,</span><span class="s2">\n      </span><span class="s1">hasShouldRevalidate === true);</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (hasClientLoader) {</span><span class="s2">\n      </span><span class="s1">if (hasLoader) {</span><span class="s2">\n        </span><span class="s1">foundOptOutRoute = true;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">try {</span><span class="s2">\n        </span><span class="s1">let result = await handler(async () =&gt; {</span><span class="s2">\n          </span><span class="s1">let {</span><span class="s2">\n            </span><span class="s1">data: data2</span><span class="s2">\n          </span><span class="s1">} = await fetchAndDecode(args, basename, [routeId]);</span><span class="s2">\n          </span><span class="s1">return unwrapSingleFetchResult(data2, routeId);</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">results[routeId] = {</span><span class="s2">\n          </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">data</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n          </span><span class="s1">result</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">} catch (e) {</span><span class="s2">\n        </span><span class="s1">results[routeId] = {</span><span class="s2">\n          </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">error</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n          </span><span class="s1">result: e</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (hasLoader) {</span><span class="s2">\n      </span><span class="s1">routesParams.add(routeId);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">try {</span><span class="s2">\n      </span><span class="s1">let result = await handler(async () =&gt; {</span><span class="s2">\n        </span><span class="s1">let data2 = await singleFetchDfd.promise;</span><span class="s2">\n        </span><span class="s1">return unwrapSingleFetchResult(data2, routeId);</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">results[routeId] = {</span><span class="s2">\n        </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">data</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        </span><span class="s1">result</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">} catch (e) {</span><span class="s2">\n      </span><span class="s1">results[routeId] = {</span><span class="s2">\n        </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">error</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        </span><span class="s1">result: e</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">})));</span><span class="s2">\n  </span><span class="s1">await Promise.all(routeDfds.map(d =&gt; d.promise));</span><span class="s2">\n  </span><span class="s1">let isInitialLoad = !router.state.initialized &amp;&amp; router.state.navigation.state === </span><span class="s2">\&quot;</span><span class="s1">idle</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">if ((isInitialLoad || routesParams.size === 0) &amp;&amp; !window.__reactRouterHdrActive) {</span><span class="s2">\n    </span><span class="s1">singleFetchDfd.resolve({</span><span class="s2">\n      </span><span class="s1">routes: {}</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">let targetRoutes = ssr &amp;&amp; foundOptOutRoute &amp;&amp; routesParams.size &gt; 0 ? [...routesParams.keys()] : void 0;</span><span class="s2">\n    </span><span class="s1">try {</span><span class="s2">\n      </span><span class="s1">let data2 = await fetchAndDecode(args, basename, targetRoutes);</span><span class="s2">\n      </span><span class="s1">singleFetchDfd.resolve(data2.data);</span><span class="s2">\n    </span><span class="s1">} catch (e) {</span><span class="s2">\n      </span><span class="s1">singleFetchDfd.reject(e);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">await resolvePromise;</span><span class="s2">\n  </span><span class="s1">await bubbleMiddlewareErrors(singleFetchDfd.promise, args.matches, routesParams, results);</span><span class="s2">\n  </span><span class="s1">return results;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">async function bubbleMiddlewareErrors(singleFetchPromise, matches, routesParams, results) {</span><span class="s2">\n  </span><span class="s1">try {</span><span class="s2">\n    </span><span class="s1">let middlewareError;</span><span class="s2">\n    </span><span class="s1">let fetchedData = await singleFetchPromise;</span><span class="s2">\n    </span><span class="s1">if (</span><span class="s2">\&quot;</span><span class="s1">routes</span><span class="s2">\&quot; </span><span class="s1">in fetchedData) {</span><span class="s2">\n      </span><span class="s1">for (let match of matches) {</span><span class="s2">\n        </span><span class="s1">if (match.route.id in fetchedData.routes) {</span><span class="s2">\n          </span><span class="s1">let routeResult = fetchedData.routes[match.route.id];</span><span class="s2">\n          </span><span class="s1">if (</span><span class="s2">\&quot;</span><span class="s1">error</span><span class="s2">\&quot; </span><span class="s1">in routeResult) {</span><span class="s2">\n            </span><span class="s1">middlewareError = routeResult.error;</span><span class="s2">\n            </span><span class="s1">break;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (middlewareError !== void 0) {</span><span class="s2">\n      </span><span class="s1">Array.from(routesParams.values()).forEach(routeId =&gt; {</span><span class="s2">\n        </span><span class="s1">if (results[routeId].result instanceof SingleFetchNoResultError) {</span><span class="s2">\n          </span><span class="s1">results[routeId].result = middlewareError;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">} catch (e) {}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">async function singleFetchLoaderFetcherStrategy(args, fetchAndDecode, basename) {</span><span class="s2">\n  </span><span class="s1">let fetcherMatch = args.matches.find(m =&gt; m.unstable_shouldCallHandler());</span><span class="s2">\n  </span><span class="s1">invariant2(fetcherMatch, </span><span class="s2">\&quot;</span><span class="s1">No fetcher match found</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let routeId = fetcherMatch.route.id;</span><span class="s2">\n  </span><span class="s1">let result = await fetcherMatch.resolve(async handler =&gt; handler(async () =&gt; {</span><span class="s2">\n    </span><span class="s1">let {</span><span class="s2">\n      </span><span class="s1">data: data2</span><span class="s2">\n    </span><span class="s1">} = await fetchAndDecode(args, basename, [routeId]);</span><span class="s2">\n    </span><span class="s1">return unwrapSingleFetchResult(data2, routeId);</span><span class="s2">\n  </span><span class="s1">}));</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">[fetcherMatch.route.id]: result</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function stripIndexParam(url) {</span><span class="s2">\n  </span><span class="s1">let indexValues = url.searchParams.getAll(</span><span class="s2">\&quot;</span><span class="s1">index</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">url.searchParams.delete(</span><span class="s2">\&quot;</span><span class="s1">index</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let indexValuesToKeep = [];</span><span class="s2">\n  </span><span class="s1">for (let indexValue of indexValues) {</span><span class="s2">\n    </span><span class="s1">if (indexValue) {</span><span class="s2">\n      </span><span class="s1">indexValuesToKeep.push(indexValue);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">for (let toKeep of indexValuesToKeep) {</span><span class="s2">\n    </span><span class="s1">url.searchParams.append(</span><span class="s2">\&quot;</span><span class="s1">index</span><span class="s2">\&quot;</span><span class="s1">, toKeep);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return url;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function singleFetchUrl(reqUrl, basename) {</span><span class="s2">\n  </span><span class="s1">let url = typeof reqUrl === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">? new URL(reqUrl,</span><span class="s2">\n  </span><span class="s1">// This can be called during the SSR flow via PrefetchPageLinksImpl so</span><span class="s2">\n  </span><span class="s1">// don't assume window is available</span><span class="s2">\n  </span><span class="s1">typeof window === </span><span class="s2">\&quot;</span><span class="s1">undefined</span><span class="s2">\&quot; </span><span class="s1">? </span><span class="s2">\&quot;</span><span class="s1">server://singlefetch/</span><span class="s2">\&quot; </span><span class="s1">: window.location.origin) : reqUrl;</span><span class="s2">\n  </span><span class="s1">if (url.pathname === </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">url.pathname = </span><span class="s2">\&quot;</span><span class="s1">_root.data</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">} else if (basename &amp;&amp; stripBasename(url.pathname, basename) === </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">url.pathname = `${basename.replace(/</span><span class="s2">\\</span><span class="s1">/$/, </span><span class="s2">\&quot;\&quot;</span><span class="s1">)}/_root.data`;</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">url.pathname = `${url.pathname.replace(/</span><span class="s2">\\</span><span class="s1">/$/, </span><span class="s2">\&quot;\&quot;</span><span class="s1">)}.data`;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return url;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">async function fetchAndDecodeViaTurboStream(args, basename, targetRoutes) {</span><span class="s2">\n  </span><span class="s1">let {</span><span class="s2">\n    </span><span class="s1">request</span><span class="s2">\n  </span><span class="s1">} = args;</span><span class="s2">\n  </span><span class="s1">let url = singleFetchUrl(request.url, basename);</span><span class="s2">\n  </span><span class="s1">if (request.method === </span><span class="s2">\&quot;</span><span class="s1">GET</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">url = stripIndexParam(url);</span><span class="s2">\n    </span><span class="s1">if (targetRoutes) {</span><span class="s2">\n      </span><span class="s1">url.searchParams.set(</span><span class="s2">\&quot;</span><span class="s1">_routes</span><span class="s2">\&quot;</span><span class="s1">, targetRoutes.join(</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\&quot;</span><span class="s1">));</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let res = await fetch(url, await createRequestInit(request));</span><span class="s2">\n  </span><span class="s1">if (res.status === 404 &amp;&amp; !res.headers.has(</span><span class="s2">\&quot;</span><span class="s1">X-Remix-Response</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n    </span><span class="s1">throw new ErrorResponseImpl(404, </span><span class="s2">\&quot;</span><span class="s1">Not Found</span><span class="s2">\&quot;</span><span class="s1">, true);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (res.status === 204 &amp;&amp; res.headers.has(</span><span class="s2">\&quot;</span><span class="s1">X-Remix-Redirect</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n    </span><span class="s1">return {</span><span class="s2">\n      </span><span class="s1">status: SINGLE_FETCH_REDIRECT_STATUS,</span><span class="s2">\n      </span><span class="s1">data: {</span><span class="s2">\n        </span><span class="s1">redirect: {</span><span class="s2">\n          </span><span class="s1">redirect: res.headers.get(</span><span class="s2">\&quot;</span><span class="s1">X-Remix-Redirect</span><span class="s2">\&quot;</span><span class="s1">),</span><span class="s2">\n          </span><span class="s1">status: Number(res.headers.get(</span><span class="s2">\&quot;</span><span class="s1">X-Remix-Status</span><span class="s2">\&quot;</span><span class="s1">) || </span><span class="s2">\&quot;</span><span class="s1">302</span><span class="s2">\&quot;</span><span class="s1">),</span><span class="s2">\n          </span><span class="s1">revalidate: res.headers.get(</span><span class="s2">\&quot;</span><span class="s1">X-Remix-Revalidate</span><span class="s2">\&quot;</span><span class="s1">) === </span><span class="s2">\&quot;</span><span class="s1">true</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n          </span><span class="s1">reload: res.headers.get(</span><span class="s2">\&quot;</span><span class="s1">X-Remix-Reload-Document</span><span class="s2">\&quot;</span><span class="s1">) === </span><span class="s2">\&quot;</span><span class="s1">true</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n          </span><span class="s1">replace: res.headers.get(</span><span class="s2">\&quot;</span><span class="s1">X-Remix-Replace</span><span class="s2">\&quot;</span><span class="s1">) === </span><span class="s2">\&quot;</span><span class="s1">true</span><span class="s2">\&quot;\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (NO_BODY_STATUS_CODES.has(res.status)) {</span><span class="s2">\n    </span><span class="s1">let routes = {};</span><span class="s2">\n    </span><span class="s1">if (targetRoutes &amp;&amp; request.method !== </span><span class="s2">\&quot;</span><span class="s1">GET</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">routes[targetRoutes[0]] = {</span><span class="s2">\n        </span><span class="s1">data: void 0</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return {</span><span class="s2">\n      </span><span class="s1">status: res.status,</span><span class="s2">\n      </span><span class="s1">data: {</span><span class="s2">\n        </span><span class="s1">routes</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">invariant2(res.body, </span><span class="s2">\&quot;</span><span class="s1">No response body to decode</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">try {</span><span class="s2">\n    </span><span class="s1">let decoded = await decodeViaTurboStream(res.body, window);</span><span class="s2">\n    </span><span class="s1">let data2;</span><span class="s2">\n    </span><span class="s1">if (request.method === </span><span class="s2">\&quot;</span><span class="s1">GET</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">let typed = decoded.value;</span><span class="s2">\n      </span><span class="s1">if (SingleFetchRedirectSymbol in typed) {</span><span class="s2">\n        </span><span class="s1">data2 = {</span><span class="s2">\n          </span><span class="s1">redirect: typed[SingleFetchRedirectSymbol]</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">data2 = {</span><span class="s2">\n          </span><span class="s1">routes: typed</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">let typed = decoded.value;</span><span class="s2">\n      </span><span class="s1">let routeId = targetRoutes?.[0];</span><span class="s2">\n      </span><span class="s1">invariant2(routeId, </span><span class="s2">\&quot;</span><span class="s1">No routeId found for single fetch call decoding</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">if (</span><span class="s2">\&quot;</span><span class="s1">redirect</span><span class="s2">\&quot; </span><span class="s1">in typed) {</span><span class="s2">\n        </span><span class="s1">data2 = {</span><span class="s2">\n          </span><span class="s1">redirect: typed</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">data2 = {</span><span class="s2">\n          </span><span class="s1">routes: {</span><span class="s2">\n            </span><span class="s1">[routeId]: typed</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return {</span><span class="s2">\n      </span><span class="s1">status: res.status,</span><span class="s2">\n      </span><span class="s1">data: data2</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">} catch (e) {</span><span class="s2">\n    </span><span class="s1">throw new Error(</span><span class="s2">\&quot;</span><span class="s1">Unable to decode turbo-stream response</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function decodeViaTurboStream(body, global2) {</span><span class="s2">\n  </span><span class="s1">return decode(body, {</span><span class="s2">\n    </span><span class="s1">plugins: [(type, ...rest) =&gt; {</span><span class="s2">\n      </span><span class="s1">if (type === </span><span class="s2">\&quot;</span><span class="s1">SanitizedError</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">let [name, message, stack] = rest;</span><span class="s2">\n        </span><span class="s1">let Constructor = Error;</span><span class="s2">\n        </span><span class="s1">if (name &amp;&amp; name in global2 &amp;&amp; typeof global2[name] === </span><span class="s2">\&quot;</span><span class="s1">function</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">Constructor = global2[name];</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">let error = new Constructor(message);</span><span class="s2">\n        </span><span class="s1">error.stack = stack;</span><span class="s2">\n        </span><span class="s1">return {</span><span class="s2">\n          </span><span class="s1">value: error</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (type === </span><span class="s2">\&quot;</span><span class="s1">ErrorResponse</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">let [data2, status, statusText] = rest;</span><span class="s2">\n        </span><span class="s1">return {</span><span class="s2">\n          </span><span class="s1">value: new ErrorResponseImpl(status, statusText, data2)</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (type === </span><span class="s2">\&quot;</span><span class="s1">SingleFetchRedirect</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">return {</span><span class="s2">\n          </span><span class="s1">value: {</span><span class="s2">\n            </span><span class="s1">[SingleFetchRedirectSymbol]: rest[0]</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (type === </span><span class="s2">\&quot;</span><span class="s1">SingleFetchClassInstance</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">return {</span><span class="s2">\n          </span><span class="s1">value: rest[0]</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (type === </span><span class="s2">\&quot;</span><span class="s1">SingleFetchFallback</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">return {</span><span class="s2">\n          </span><span class="s1">value: void 0</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}]</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function unwrapSingleFetchResult(result, routeId) {</span><span class="s2">\n  </span><span class="s1">if (</span><span class="s2">\&quot;</span><span class="s1">redirect</span><span class="s2">\&quot; </span><span class="s1">in result) {</span><span class="s2">\n    </span><span class="s1">let {</span><span class="s2">\n      </span><span class="s1">redirect: location,</span><span class="s2">\n      </span><span class="s1">revalidate,</span><span class="s2">\n      </span><span class="s1">reload,</span><span class="s2">\n      </span><span class="s1">replace: replace2,</span><span class="s2">\n      </span><span class="s1">status</span><span class="s2">\n    </span><span class="s1">} = result.redirect;</span><span class="s2">\n    </span><span class="s1">throw redirect(location, {</span><span class="s2">\n      </span><span class="s1">status,</span><span class="s2">\n      </span><span class="s1">headers: {</span><span class="s2">\n        </span><span class="s1">// Three R's of redirecting (lol Veep)</span><span class="s2">\n        </span><span class="s1">...(revalidate ? {</span><span class="s2">\n          \&quot;</span><span class="s1">X-Remix-Revalidate</span><span class="s2">\&quot;</span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">yes</span><span class="s2">\&quot;\n        </span><span class="s1">} : null),</span><span class="s2">\n        </span><span class="s1">...(reload ? {</span><span class="s2">\n          \&quot;</span><span class="s1">X-Remix-Reload-Document</span><span class="s2">\&quot;</span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">yes</span><span class="s2">\&quot;\n        </span><span class="s1">} : null),</span><span class="s2">\n        </span><span class="s1">...(replace2 ? {</span><span class="s2">\n          \&quot;</span><span class="s1">X-Remix-Replace</span><span class="s2">\&quot;</span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">yes</span><span class="s2">\&quot;\n        </span><span class="s1">} : null)</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let routeResult = result.routes[routeId];</span><span class="s2">\n  </span><span class="s1">if (routeResult == null) {</span><span class="s2">\n    </span><span class="s1">throw new SingleFetchNoResultError(`No result found for routeId </span><span class="s2">\&quot;</span><span class="s1">${routeId}</span><span class="s2">\&quot;</span><span class="s1">`);</span><span class="s2">\n  </span><span class="s1">} else if (</span><span class="s2">\&quot;</span><span class="s1">error</span><span class="s2">\&quot; </span><span class="s1">in routeResult) {</span><span class="s2">\n    </span><span class="s1">throw routeResult.error;</span><span class="s2">\n  </span><span class="s1">} else if (</span><span class="s2">\&quot;</span><span class="s1">data</span><span class="s2">\&quot; </span><span class="s1">in routeResult) {</span><span class="s2">\n    </span><span class="s1">return routeResult.data;</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">throw new Error(`Invalid response found for routeId </span><span class="s2">\&quot;</span><span class="s1">${routeId}</span><span class="s2">\&quot;</span><span class="s1">`);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createDeferred2() {</span><span class="s2">\n  </span><span class="s1">let resolve;</span><span class="s2">\n  </span><span class="s1">let reject;</span><span class="s2">\n  </span><span class="s1">let promise = new Promise((res, rej) =&gt; {</span><span class="s2">\n    </span><span class="s1">resolve = async val =&gt; {</span><span class="s2">\n      </span><span class="s1">res(val);</span><span class="s2">\n      </span><span class="s1">try {</span><span class="s2">\n        </span><span class="s1">await promise;</span><span class="s2">\n      </span><span class="s1">} catch (e) {}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">reject = async error =&gt; {</span><span class="s2">\n      </span><span class="s1">rej(error);</span><span class="s2">\n      </span><span class="s1">try {</span><span class="s2">\n        </span><span class="s1">await promise;</span><span class="s2">\n      </span><span class="s1">} catch (e) {}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">promise,</span><span class="s2">\n    </span><span class="s1">//@ts-ignore</span><span class="s2">\n    </span><span class="s1">resolve,</span><span class="s2">\n    </span><span class="s1">//@ts-ignore</span><span class="s2">\n    </span><span class="s1">reject</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/dom/ssr/fog-of-war.ts</span><span class="s2">\n</span><span class="s1">import * as React8 from </span><span class="s2">\&quot;</span><span class="s1">react</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n</span><span class="s1">// lib/dom/ssr/routes.tsx</span><span class="s2">\n</span><span class="s1">import * as React7 from </span><span class="s2">\&quot;</span><span class="s1">react</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n</span><span class="s1">// lib/dom/ssr/errorBoundaries.tsx</span><span class="s2">\n</span><span class="s1">import * as React5 from </span><span class="s2">\&quot;</span><span class="s1">react</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">var RemixErrorBoundary = class extends React5.Component {</span><span class="s2">\n  </span><span class="s1">constructor(props) {</span><span class="s2">\n    </span><span class="s1">super(props);</span><span class="s2">\n    </span><span class="s1">this.state = {</span><span class="s2">\n      </span><span class="s1">error: props.error || null,</span><span class="s2">\n      </span><span class="s1">location: props.location</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">static getDerivedStateFromError(error) {</span><span class="s2">\n    </span><span class="s1">return {</span><span class="s2">\n      </span><span class="s1">error</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">static getDerivedStateFromProps(props, state) {</span><span class="s2">\n    </span><span class="s1">if (state.location !== props.location) {</span><span class="s2">\n      </span><span class="s1">return {</span><span class="s2">\n        </span><span class="s1">error: props.error || null,</span><span class="s2">\n        </span><span class="s1">location: props.location</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return {</span><span class="s2">\n      </span><span class="s1">error: props.error || state.error,</span><span class="s2">\n      </span><span class="s1">location: state.location</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">render() {</span><span class="s2">\n    </span><span class="s1">if (this.state.error) {</span><span class="s2">\n      </span><span class="s1">return /* @__PURE__ */React5.createElement(RemixRootDefaultErrorBoundary, {</span><span class="s2">\n        </span><span class="s1">error: this.state.error,</span><span class="s2">\n        </span><span class="s1">isOutsideRemixApp: true</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">return this.props.children;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">function RemixRootDefaultErrorBoundary({</span><span class="s2">\n  </span><span class="s1">error,</span><span class="s2">\n  </span><span class="s1">isOutsideRemixApp</span><span class="s2">\n</span><span class="s1">}) {</span><span class="s2">\n  </span><span class="s1">console.error(error);</span><span class="s2">\n  </span><span class="s1">let heyDeveloper = /* @__PURE__ */React5.createElement(</span><span class="s2">\&quot;</span><span class="s1">script</span><span class="s2">\&quot;</span><span class="s1">, {</span><span class="s2">\n    </span><span class="s1">dangerouslySetInnerHTML: {</span><span class="s2">\n      </span><span class="s1">__html: `</span><span class="s2">\n        </span><span class="s1">console.log(</span><span class="s2">\n          \&quot;\\</span><span class="s1">u{1F4BF} Hey developer </span><span class="s2">\\</span><span class="s1">u{1F44B}. You can provide a way better UX than this when your app throws errors. Check out https://reactrouter.com/how-to/error-boundary for more information.</span><span class="s2">\&quot;\n        </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">`</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">if (isRouteErrorResponse(error)) {</span><span class="s2">\n    </span><span class="s1">return /* @__PURE__ */React5.createElement(BoundaryShell, {</span><span class="s2">\n      </span><span class="s1">title: </span><span class="s2">\&quot;</span><span class="s1">Unhandled Thrown Response!</span><span class="s2">\&quot;\n    </span><span class="s1">}, /* @__PURE__ */React5.createElement(</span><span class="s2">\&quot;</span><span class="s1">h1</span><span class="s2">\&quot;</span><span class="s1">, {</span><span class="s2">\n      </span><span class="s1">style: {</span><span class="s2">\n        </span><span class="s1">fontSize: </span><span class="s2">\&quot;</span><span class="s1">24px</span><span class="s2">\&quot;\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}, error.status, </span><span class="s2">\&quot; \&quot;</span><span class="s1">, error.statusText), ENABLE_DEV_WARNINGS ? heyDeveloper : null);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let errorInstance;</span><span class="s2">\n  </span><span class="s1">if (error instanceof Error) {</span><span class="s2">\n    </span><span class="s1">errorInstance = error;</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">let errorString = error == null ? </span><span class="s2">\&quot;</span><span class="s1">Unknown Error</span><span class="s2">\&quot; </span><span class="s1">: typeof error === </span><span class="s2">\&quot;</span><span class="s1">object</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; </span><span class="s2">\&quot;</span><span class="s1">toString</span><span class="s2">\&quot; </span><span class="s1">in error ? error.toString() : JSON.stringify(error);</span><span class="s2">\n    </span><span class="s1">errorInstance = new Error(errorString);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return /* @__PURE__ */React5.createElement(BoundaryShell, {</span><span class="s2">\n    </span><span class="s1">title: </span><span class="s2">\&quot;</span><span class="s1">Application Error!</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">isOutsideRemixApp</span><span class="s2">\n  </span><span class="s1">}, /* @__PURE__ */React5.createElement(</span><span class="s2">\&quot;</span><span class="s1">h1</span><span class="s2">\&quot;</span><span class="s1">, {</span><span class="s2">\n    </span><span class="s1">style: {</span><span class="s2">\n      </span><span class="s1">fontSize: </span><span class="s2">\&quot;</span><span class="s1">24px</span><span class="s2">\&quot;\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}, </span><span class="s2">\&quot;</span><span class="s1">Application Error</span><span class="s2">\&quot;</span><span class="s1">), /* @__PURE__ */React5.createElement(</span><span class="s2">\&quot;</span><span class="s1">pre</span><span class="s2">\&quot;</span><span class="s1">, {</span><span class="s2">\n    </span><span class="s1">style: {</span><span class="s2">\n      </span><span class="s1">padding: </span><span class="s2">\&quot;</span><span class="s1">2rem</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">background: </span><span class="s2">\&quot;</span><span class="s1">hsla(10, 50%, 50%, 0.1)</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">color: </span><span class="s2">\&quot;</span><span class="s1">red</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">overflow: </span><span class="s2">\&quot;</span><span class="s1">auto</span><span class="s2">\&quot;\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}, errorInstance.stack), heyDeveloper);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function BoundaryShell({</span><span class="s2">\n  </span><span class="s1">title,</span><span class="s2">\n  </span><span class="s1">renderScripts,</span><span class="s2">\n  </span><span class="s1">isOutsideRemixApp,</span><span class="s2">\n  </span><span class="s1">children</span><span class="s2">\n</span><span class="s1">}) {</span><span class="s2">\n  </span><span class="s1">let {</span><span class="s2">\n    </span><span class="s1">routeModules</span><span class="s2">\n  </span><span class="s1">} = useFrameworkContext();</span><span class="s2">\n  </span><span class="s1">if (routeModules.root?.Layout &amp;&amp; !isOutsideRemixApp) {</span><span class="s2">\n    </span><span class="s1">return children;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return /* @__PURE__ */React5.createElement(</span><span class="s2">\&quot;</span><span class="s1">html</span><span class="s2">\&quot;</span><span class="s1">, {</span><span class="s2">\n    </span><span class="s1">lang: </span><span class="s2">\&quot;</span><span class="s1">en</span><span class="s2">\&quot;\n  </span><span class="s1">}, /* @__PURE__ */React5.createElement(</span><span class="s2">\&quot;</span><span class="s1">head</span><span class="s2">\&quot;</span><span class="s1">, null, /* @__PURE__ */React5.createElement(</span><span class="s2">\&quot;</span><span class="s1">meta</span><span class="s2">\&quot;</span><span class="s1">, {</span><span class="s2">\n    </span><span class="s1">charSet: </span><span class="s2">\&quot;</span><span class="s1">utf-8</span><span class="s2">\&quot;\n  </span><span class="s1">}), /* @__PURE__ */React5.createElement(</span><span class="s2">\&quot;</span><span class="s1">meta</span><span class="s2">\&quot;</span><span class="s1">, {</span><span class="s2">\n    </span><span class="s1">name: </span><span class="s2">\&quot;</span><span class="s1">viewport</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">content: </span><span class="s2">\&quot;</span><span class="s1">width=device-width,initial-scale=1,viewport-fit=cover</span><span class="s2">\&quot;\n  </span><span class="s1">}), /* @__PURE__ */React5.createElement(</span><span class="s2">\&quot;</span><span class="s1">title</span><span class="s2">\&quot;</span><span class="s1">, null, title)), /* @__PURE__ */React5.createElement(</span><span class="s2">\&quot;</span><span class="s1">body</span><span class="s2">\&quot;</span><span class="s1">, null, /* @__PURE__ */React5.createElement(</span><span class="s2">\&quot;</span><span class="s1">main</span><span class="s2">\&quot;</span><span class="s1">, {</span><span class="s2">\n    </span><span class="s1">style: {</span><span class="s2">\n      </span><span class="s1">fontFamily: </span><span class="s2">\&quot;</span><span class="s1">system-ui, sans-serif</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">padding: </span><span class="s2">\&quot;</span><span class="s1">2rem</span><span class="s2">\&quot;\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}, children, renderScripts ? /* @__PURE__ */React5.createElement(Scripts, null) : null)));</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/dom/ssr/fallback.tsx</span><span class="s2">\n</span><span class="s1">import * as React6 from </span><span class="s2">\&quot;</span><span class="s1">react</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">function RemixRootDefaultHydrateFallback() {</span><span class="s2">\n  </span><span class="s1">return /* @__PURE__ */React6.createElement(BoundaryShell, {</span><span class="s2">\n    </span><span class="s1">title: </span><span class="s2">\&quot;</span><span class="s1">Loading...</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">renderScripts: true</span><span class="s2">\n  </span><span class="s1">}, ENABLE_DEV_WARNINGS ? /* @__PURE__ */React6.createElement(</span><span class="s2">\&quot;</span><span class="s1">script</span><span class="s2">\&quot;</span><span class="s1">, {</span><span class="s2">\n    </span><span class="s1">dangerouslySetInnerHTML: {</span><span class="s2">\n      </span><span class="s1">__html: `</span><span class="s2">\n              </span><span class="s1">console.log(</span><span class="s2">\n                \&quot;\\</span><span class="s1">u{1F4BF} Hey developer </span><span class="s2">\\</span><span class="s1">u{1F44B}. You can provide a way better UX than this </span><span class="s2">\&quot; </span><span class="s1">+</span><span class="s2">\n                \&quot;</span><span class="s1">when your app is loading JS modules and/or running </span><span class="s2">\\</span><span class="s1">`clientLoader</span><span class="s2">\\</span><span class="s1">` </span><span class="s2">\&quot; </span><span class="s1">+</span><span class="s2">\n                \&quot;</span><span class="s1">functions. Check out https://reactrouter.com/start/framework/route-module#hydratefallback </span><span class="s2">\&quot; </span><span class="s1">+</span><span class="s2">\n                \&quot;</span><span class="s1">for more information.</span><span class="s2">\&quot;\n              </span><span class="s1">);</span><span class="s2">\n            </span><span class="s1">`</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}) : null);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/dom/ssr/routes.tsx</span><span class="s2">\n</span><span class="s1">function groupRoutesByParentId(manifest) {</span><span class="s2">\n  </span><span class="s1">let routes = {};</span><span class="s2">\n  </span><span class="s1">Object.values(manifest).forEach(route =&gt; {</span><span class="s2">\n    </span><span class="s1">if (route) {</span><span class="s2">\n      </span><span class="s1">let parentId = route.parentId || </span><span class="s2">\&quot;\&quot;</span><span class="s1">;</span><span class="s2">\n      </span><span class="s1">if (!routes[parentId]) {</span><span class="s2">\n        </span><span class="s1">routes[parentId] = [];</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">routes[parentId].push(route);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">return routes;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getRouteComponents(route, routeModule, isSpaMode) {</span><span class="s2">\n  </span><span class="s1">let Component4 = getRouteModuleComponent(routeModule);</span><span class="s2">\n  </span><span class="s1">let HydrateFallback = routeModule.HydrateFallback &amp;&amp; (!isSpaMode || route.id === </span><span class="s2">\&quot;</span><span class="s1">root</span><span class="s2">\&quot;</span><span class="s1">) ? routeModule.HydrateFallback : route.id === </span><span class="s2">\&quot;</span><span class="s1">root</span><span class="s2">\&quot; </span><span class="s1">? RemixRootDefaultHydrateFallback : void 0;</span><span class="s2">\n  </span><span class="s1">let ErrorBoundary = routeModule.ErrorBoundary ? routeModule.ErrorBoundary : route.id === </span><span class="s2">\&quot;</span><span class="s1">root</span><span class="s2">\&quot; </span><span class="s1">? () =&gt; /* @__PURE__ */React7.createElement(RemixRootDefaultErrorBoundary, {</span><span class="s2">\n    </span><span class="s1">error: useRouteError()</span><span class="s2">\n  </span><span class="s1">}) : void 0;</span><span class="s2">\n  </span><span class="s1">if (route.id === </span><span class="s2">\&quot;</span><span class="s1">root</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; routeModule.Layout) {</span><span class="s2">\n    </span><span class="s1">return {</span><span class="s2">\n      </span><span class="s1">...(Component4 ? {</span><span class="s2">\n        </span><span class="s1">element: /* @__PURE__ */React7.createElement(routeModule.Layout, null, /* @__PURE__ */React7.createElement(Component4, null))</span><span class="s2">\n      </span><span class="s1">} : {</span><span class="s2">\n        </span><span class="s1">Component: Component4</span><span class="s2">\n      </span><span class="s1">}),</span><span class="s2">\n      </span><span class="s1">...(ErrorBoundary ? {</span><span class="s2">\n        </span><span class="s1">errorElement: /* @__PURE__ */React7.createElement(routeModule.Layout, null, /* @__PURE__ */React7.createElement(ErrorBoundary, null))</span><span class="s2">\n      </span><span class="s1">} : {</span><span class="s2">\n        </span><span class="s1">ErrorBoundary</span><span class="s2">\n      </span><span class="s1">}),</span><span class="s2">\n      </span><span class="s1">...(HydrateFallback ? {</span><span class="s2">\n        </span><span class="s1">hydrateFallbackElement: /* @__PURE__ */React7.createElement(routeModule.Layout, null, /* @__PURE__ */React7.createElement(HydrateFallback, null))</span><span class="s2">\n      </span><span class="s1">} : {</span><span class="s2">\n        </span><span class="s1">HydrateFallback</span><span class="s2">\n      </span><span class="s1">})</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">Component: Component4,</span><span class="s2">\n    </span><span class="s1">ErrorBoundary,</span><span class="s2">\n    </span><span class="s1">HydrateFallback</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createServerRoutes(manifest, routeModules, future, isSpaMode, parentId = </span><span class="s2">\&quot;\&quot;</span><span class="s1">, routesByParentId = groupRoutesByParentId(manifest), spaModeLazyPromise = Promise.resolve({</span><span class="s2">\n  </span><span class="s1">Component: () =&gt; null</span><span class="s2">\n</span><span class="s1">})) {</span><span class="s2">\n  </span><span class="s1">return (routesByParentId[parentId] || []).map(route =&gt; {</span><span class="s2">\n    </span><span class="s1">let routeModule = routeModules[route.id];</span><span class="s2">\n    </span><span class="s1">invariant2(routeModule, </span><span class="s2">\&quot;</span><span class="s1">No `routeModule` available to create server routes</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">let dataRoute = {</span><span class="s2">\n      </span><span class="s1">...getRouteComponents(route, routeModule, isSpaMode),</span><span class="s2">\n      </span><span class="s1">caseSensitive: route.caseSensitive,</span><span class="s2">\n      </span><span class="s1">id: route.id,</span><span class="s2">\n      </span><span class="s1">index: route.index,</span><span class="s2">\n      </span><span class="s1">path: route.path,</span><span class="s2">\n      </span><span class="s1">handle: routeModule.handle,</span><span class="s2">\n      </span><span class="s1">// For SPA Mode, all routes are lazy except root.  However we tell the</span><span class="s2">\n      </span><span class="s1">// router root is also lazy here too since we don't need a full</span><span class="s2">\n      </span><span class="s1">// implementation - we just need a `lazy` prop to tell the RR rendering</span><span class="s2">\n      </span><span class="s1">// where to stop which is always at the root route in SPA mode</span><span class="s2">\n      </span><span class="s1">lazy: isSpaMode ? () =&gt; spaModeLazyPromise : void 0,</span><span class="s2">\n      </span><span class="s1">// For partial hydration rendering, we need to indicate when the route</span><span class="s2">\n      </span><span class="s1">// has a loader/clientLoader, but it won't ever be called during the static</span><span class="s2">\n      </span><span class="s1">// render, so just give it a no-op function so we can render down to the</span><span class="s2">\n      </span><span class="s1">// proper fallback</span><span class="s2">\n      </span><span class="s1">loader: route.hasLoader || route.hasClientLoader ? () =&gt; null : void 0</span><span class="s2">\n      </span><span class="s1">// We don't need middleware/action/shouldRevalidate on these routes since</span><span class="s2">\n      </span><span class="s1">// they're for a static render</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">let children = createServerRoutes(manifest, routeModules, future, isSpaMode, route.id, routesByParentId, spaModeLazyPromise);</span><span class="s2">\n    </span><span class="s1">if (children.length &gt; 0) dataRoute.children = children;</span><span class="s2">\n    </span><span class="s1">return dataRoute;</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createClientRoutesWithHMRRevalidationOptOut(needsRevalidation, manifest, routeModulesCache, initialState, ssr, isSpaMode) {</span><span class="s2">\n  </span><span class="s1">return createClientRoutes(manifest, routeModulesCache, initialState, ssr, isSpaMode, </span><span class="s2">\&quot;\&quot;</span><span class="s1">, groupRoutesByParentId(manifest), needsRevalidation);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function preventInvalidServerHandlerCall(type, route) {</span><span class="s2">\n  </span><span class="s1">if (type === </span><span class="s2">\&quot;</span><span class="s1">loader</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; !route.hasLoader || type === </span><span class="s2">\&quot;</span><span class="s1">action</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; !route.hasAction) {</span><span class="s2">\n    </span><span class="s1">let fn = type === </span><span class="s2">\&quot;</span><span class="s1">action</span><span class="s2">\&quot; </span><span class="s1">? </span><span class="s2">\&quot;</span><span class="s1">serverAction()</span><span class="s2">\&quot; </span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">serverLoader()</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">let msg = `You are trying to call ${fn} on a route that does not have a server ${type} (routeId: </span><span class="s2">\&quot;</span><span class="s1">${route.id}</span><span class="s2">\&quot;</span><span class="s1">)`;</span><span class="s2">\n    </span><span class="s1">console.error(msg);</span><span class="s2">\n    </span><span class="s1">throw new ErrorResponseImpl(400, </span><span class="s2">\&quot;</span><span class="s1">Bad Request</span><span class="s2">\&quot;</span><span class="s1">, new Error(msg), true);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function noActionDefinedError(type, routeId) {</span><span class="s2">\n  </span><span class="s1">let article = type === </span><span class="s2">\&quot;</span><span class="s1">clientAction</span><span class="s2">\&quot; </span><span class="s1">? </span><span class="s2">\&quot;</span><span class="s1">a</span><span class="s2">\&quot; </span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">an</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">let msg = `Route </span><span class="s2">\&quot;</span><span class="s1">${routeId}</span><span class="s2">\&quot; </span><span class="s1">does not have ${article} ${type}, but you are trying to submit to it. To fix this, please add ${article} </span><span class="s2">\\</span><span class="s1">`${type}</span><span class="s2">\\</span><span class="s1">` function to the route`;</span><span class="s2">\n  </span><span class="s1">console.error(msg);</span><span class="s2">\n  </span><span class="s1">throw new ErrorResponseImpl(405, </span><span class="s2">\&quot;</span><span class="s1">Method Not Allowed</span><span class="s2">\&quot;</span><span class="s1">, new Error(msg), true);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createClientRoutes(manifest, routeModulesCache, initialState, ssr, isSpaMode, parentId = </span><span class="s2">\&quot;\&quot;</span><span class="s1">, routesByParentId = groupRoutesByParentId(manifest), needsRevalidation) {</span><span class="s2">\n  </span><span class="s1">return (routesByParentId[parentId] || []).map(route =&gt; {</span><span class="s2">\n    </span><span class="s1">let routeModule = routeModulesCache[route.id];</span><span class="s2">\n    </span><span class="s1">function fetchServerHandler(singleFetch) {</span><span class="s2">\n      </span><span class="s1">invariant2(typeof singleFetch === </span><span class="s2">\&quot;</span><span class="s1">function</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">No single fetch function available for route handler</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">return singleFetch();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">function fetchServerLoader(singleFetch) {</span><span class="s2">\n      </span><span class="s1">if (!route.hasLoader) return Promise.resolve(null);</span><span class="s2">\n      </span><span class="s1">return fetchServerHandler(singleFetch);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">function fetchServerAction(singleFetch) {</span><span class="s2">\n      </span><span class="s1">if (!route.hasAction) {</span><span class="s2">\n        </span><span class="s1">throw noActionDefinedError(</span><span class="s2">\&quot;</span><span class="s1">action</span><span class="s2">\&quot;</span><span class="s1">, route.id);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return fetchServerHandler(singleFetch);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">function prefetchModule(modulePath) {</span><span class="s2">\n      </span><span class="s1">import(/* @vite-ignore */</span><span class="s2">\n      </span><span class="s1">/* webpackIgnore: true */</span><span class="s2">\n      </span><span class="s1">modulePath);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">function prefetchRouteModuleChunks(route2) {</span><span class="s2">\n      </span><span class="s1">if (route2.clientActionModule) {</span><span class="s2">\n        </span><span class="s1">prefetchModule(route2.clientActionModule);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (route2.clientLoaderModule) {</span><span class="s2">\n        </span><span class="s1">prefetchModule(route2.clientLoaderModule);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">async function prefetchStylesAndCallHandler(handler) {</span><span class="s2">\n      </span><span class="s1">let cachedModule = routeModulesCache[route.id];</span><span class="s2">\n      </span><span class="s1">let linkPrefetchPromise = cachedModule ? prefetchStyleLinks(route, cachedModule) : Promise.resolve();</span><span class="s2">\n      </span><span class="s1">try {</span><span class="s2">\n        </span><span class="s1">return handler();</span><span class="s2">\n      </span><span class="s1">} finally {</span><span class="s2">\n        </span><span class="s1">await linkPrefetchPromise;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let dataRoute = {</span><span class="s2">\n      </span><span class="s1">id: route.id,</span><span class="s2">\n      </span><span class="s1">index: route.index,</span><span class="s2">\n      </span><span class="s1">path: route.path</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">if (routeModule) {</span><span class="s2">\n      </span><span class="s1">Object.assign(dataRoute, {</span><span class="s2">\n        </span><span class="s1">...dataRoute,</span><span class="s2">\n        </span><span class="s1">...getRouteComponents(route, routeModule, isSpaMode),</span><span class="s2">\n        </span><span class="s1">unstable_middleware: routeModule.unstable_clientMiddleware,</span><span class="s2">\n        </span><span class="s1">handle: routeModule.handle,</span><span class="s2">\n        </span><span class="s1">shouldRevalidate: getShouldRevalidateFunction(dataRoute.path, routeModule, route, ssr, needsRevalidation)</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">let hasInitialData = initialState &amp;&amp; initialState.loaderData &amp;&amp; route.id in initialState.loaderData;</span><span class="s2">\n      </span><span class="s1">let initialData = hasInitialData ? initialState?.loaderData?.[route.id] : void 0;</span><span class="s2">\n      </span><span class="s1">let hasInitialError = initialState &amp;&amp; initialState.errors &amp;&amp; route.id in initialState.errors;</span><span class="s2">\n      </span><span class="s1">let initialError = hasInitialError ? initialState?.errors?.[route.id] : void 0;</span><span class="s2">\n      </span><span class="s1">let isHydrationRequest = needsRevalidation == null &amp;&amp; (routeModule.clientLoader?.hydrate === true || !route.hasLoader);</span><span class="s2">\n      </span><span class="s1">dataRoute.loader = async ({</span><span class="s2">\n        </span><span class="s1">request,</span><span class="s2">\n        </span><span class="s1">params,</span><span class="s2">\n        </span><span class="s1">context</span><span class="s2">\n      </span><span class="s1">}, singleFetch) =&gt; {</span><span class="s2">\n        </span><span class="s1">try {</span><span class="s2">\n          </span><span class="s1">let result = await prefetchStylesAndCallHandler(async () =&gt; {</span><span class="s2">\n            </span><span class="s1">invariant2(routeModule, </span><span class="s2">\&quot;</span><span class="s1">No `routeModule` available for critical-route loader</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n            </span><span class="s1">if (!routeModule.clientLoader) {</span><span class="s2">\n              </span><span class="s1">return fetchServerLoader(singleFetch);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">return routeModule.clientLoader({</span><span class="s2">\n              </span><span class="s1">request,</span><span class="s2">\n              </span><span class="s1">params,</span><span class="s2">\n              </span><span class="s1">context,</span><span class="s2">\n              </span><span class="s1">async serverLoader() {</span><span class="s2">\n                </span><span class="s1">preventInvalidServerHandlerCall(</span><span class="s2">\&quot;</span><span class="s1">loader</span><span class="s2">\&quot;</span><span class="s1">, route);</span><span class="s2">\n                </span><span class="s1">if (isHydrationRequest) {</span><span class="s2">\n                  </span><span class="s1">if (hasInitialData) {</span><span class="s2">\n                    </span><span class="s1">return initialData;</span><span class="s2">\n                  </span><span class="s1">}</span><span class="s2">\n                  </span><span class="s1">if (hasInitialError) {</span><span class="s2">\n                    </span><span class="s1">throw initialError;</span><span class="s2">\n                  </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">return fetchServerLoader(singleFetch);</span><span class="s2">\n              </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n          </span><span class="s1">return result;</span><span class="s2">\n        </span><span class="s1">} finally {</span><span class="s2">\n          </span><span class="s1">isHydrationRequest = false;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">dataRoute.loader.hydrate = shouldHydrateRouteLoader(route.id, routeModule.clientLoader, route.hasLoader, isSpaMode);</span><span class="s2">\n      </span><span class="s1">dataRoute.action = ({</span><span class="s2">\n        </span><span class="s1">request,</span><span class="s2">\n        </span><span class="s1">params,</span><span class="s2">\n        </span><span class="s1">context</span><span class="s2">\n      </span><span class="s1">}, singleFetch) =&gt; {</span><span class="s2">\n        </span><span class="s1">return prefetchStylesAndCallHandler(async () =&gt; {</span><span class="s2">\n          </span><span class="s1">invariant2(routeModule, </span><span class="s2">\&quot;</span><span class="s1">No `routeModule` available for critical-route action</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">if (!routeModule.clientAction) {</span><span class="s2">\n            </span><span class="s1">if (isSpaMode) {</span><span class="s2">\n              </span><span class="s1">throw noActionDefinedError(</span><span class="s2">\&quot;</span><span class="s1">clientAction</span><span class="s2">\&quot;</span><span class="s1">, route.id);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">return fetchServerAction(singleFetch);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">return routeModule.clientAction({</span><span class="s2">\n            </span><span class="s1">request,</span><span class="s2">\n            </span><span class="s1">params,</span><span class="s2">\n            </span><span class="s1">context,</span><span class="s2">\n            </span><span class="s1">async serverAction() {</span><span class="s2">\n              </span><span class="s1">preventInvalidServerHandlerCall(</span><span class="s2">\&quot;</span><span class="s1">action</span><span class="s2">\&quot;</span><span class="s1">, route);</span><span class="s2">\n              </span><span class="s1">return fetchServerAction(singleFetch);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">if (!route.hasClientLoader) {</span><span class="s2">\n        </span><span class="s1">dataRoute.loader = (_, singleFetch) =&gt; prefetchStylesAndCallHandler(() =&gt; {</span><span class="s2">\n          </span><span class="s1">return fetchServerLoader(singleFetch);</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (!route.hasClientAction) {</span><span class="s2">\n        </span><span class="s1">dataRoute.action = (_, singleFetch) =&gt; prefetchStylesAndCallHandler(() =&gt; {</span><span class="s2">\n          </span><span class="s1">if (isSpaMode) {</span><span class="s2">\n            </span><span class="s1">throw noActionDefinedError(</span><span class="s2">\&quot;</span><span class="s1">clientAction</span><span class="s2">\&quot;</span><span class="s1">, route.id);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">return fetchServerAction(singleFetch);</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">let lazyRoutePromise;</span><span class="s2">\n      </span><span class="s1">async function getLazyRoute() {</span><span class="s2">\n        </span><span class="s1">if (lazyRoutePromise) {</span><span class="s2">\n          </span><span class="s1">return await lazyRoutePromise;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">lazyRoutePromise = (async () =&gt; {</span><span class="s2">\n          </span><span class="s1">if (route.clientLoaderModule || route.clientActionModule) {</span><span class="s2">\n            </span><span class="s1">await new Promise(resolve =&gt; setTimeout(resolve, 0));</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">let routeModulePromise = loadRouteModuleWithBlockingLinks(route, routeModulesCache);</span><span class="s2">\n          </span><span class="s1">prefetchRouteModuleChunks(route);</span><span class="s2">\n          </span><span class="s1">return await routeModulePromise;</span><span class="s2">\n        </span><span class="s1">})();</span><span class="s2">\n        </span><span class="s1">return await lazyRoutePromise;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">dataRoute.lazy = {</span><span class="s2">\n        </span><span class="s1">loader: route.hasClientLoader ? async () =&gt; {</span><span class="s2">\n          </span><span class="s1">let {</span><span class="s2">\n            </span><span class="s1">clientLoader</span><span class="s2">\n          </span><span class="s1">} = route.clientLoaderModule ? await import(/* @vite-ignore */</span><span class="s2">\n          </span><span class="s1">/* webpackIgnore: true */</span><span class="s2">\n          </span><span class="s1">route.clientLoaderModule) : await getLazyRoute();</span><span class="s2">\n          </span><span class="s1">invariant2(clientLoader, </span><span class="s2">\&quot;</span><span class="s1">No `clientLoader` export found</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">return (args, singleFetch) =&gt; clientLoader({</span><span class="s2">\n            </span><span class="s1">...args,</span><span class="s2">\n            </span><span class="s1">async serverLoader() {</span><span class="s2">\n              </span><span class="s1">preventInvalidServerHandlerCall(</span><span class="s2">\&quot;</span><span class="s1">loader</span><span class="s2">\&quot;</span><span class="s1">, route);</span><span class="s2">\n              </span><span class="s1">return fetchServerLoader(singleFetch);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">} : void 0,</span><span class="s2">\n        </span><span class="s1">action: route.hasClientAction ? async () =&gt; {</span><span class="s2">\n          </span><span class="s1">let clientActionPromise = route.clientActionModule ? import(/* @vite-ignore */</span><span class="s2">\n          </span><span class="s1">/* webpackIgnore: true */</span><span class="s2">\n          </span><span class="s1">route.clientActionModule) : getLazyRoute();</span><span class="s2">\n          </span><span class="s1">prefetchRouteModuleChunks(route);</span><span class="s2">\n          </span><span class="s1">let {</span><span class="s2">\n            </span><span class="s1">clientAction</span><span class="s2">\n          </span><span class="s1">} = await clientActionPromise;</span><span class="s2">\n          </span><span class="s1">invariant2(clientAction, </span><span class="s2">\&quot;</span><span class="s1">No `clientAction` export found</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">return (args, singleFetch) =&gt; clientAction({</span><span class="s2">\n            </span><span class="s1">...args,</span><span class="s2">\n            </span><span class="s1">async serverAction() {</span><span class="s2">\n              </span><span class="s1">preventInvalidServerHandlerCall(</span><span class="s2">\&quot;</span><span class="s1">action</span><span class="s2">\&quot;</span><span class="s1">, route);</span><span class="s2">\n              </span><span class="s1">return fetchServerAction(singleFetch);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">} : void 0,</span><span class="s2">\n        </span><span class="s1">unstable_middleware: route.hasClientMiddleware ? async () =&gt; {</span><span class="s2">\n          </span><span class="s1">let {</span><span class="s2">\n            </span><span class="s1">unstable_clientMiddleware</span><span class="s2">\n          </span><span class="s1">} = route.clientMiddlewareModule ? await import(/* @vite-ignore */</span><span class="s2">\n          </span><span class="s1">/* webpackIgnore: true */</span><span class="s2">\n          </span><span class="s1">route.clientMiddlewareModule) : await getLazyRoute();</span><span class="s2">\n          </span><span class="s1">invariant2(unstable_clientMiddleware, </span><span class="s2">\&quot;</span><span class="s1">No `unstable_clientMiddleware` export found</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">return unstable_clientMiddleware;</span><span class="s2">\n        </span><span class="s1">} : void 0,</span><span class="s2">\n        </span><span class="s1">shouldRevalidate: async () =&gt; {</span><span class="s2">\n          </span><span class="s1">let lazyRoute = await getLazyRoute();</span><span class="s2">\n          </span><span class="s1">return getShouldRevalidateFunction(dataRoute.path, lazyRoute, route, ssr, needsRevalidation);</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">handle: async () =&gt; (await getLazyRoute()).handle,</span><span class="s2">\n        </span><span class="s1">// No need to wrap these in layout since the root route is never</span><span class="s2">\n        </span><span class="s1">// loaded via route.lazy()</span><span class="s2">\n        </span><span class="s1">Component: async () =&gt; (await getLazyRoute()).Component,</span><span class="s2">\n        </span><span class="s1">ErrorBoundary: route.hasErrorBoundary ? async () =&gt; (await getLazyRoute()).ErrorBoundary : void 0</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let children = createClientRoutes(manifest, routeModulesCache, initialState, ssr, isSpaMode, route.id, routesByParentId, needsRevalidation);</span><span class="s2">\n    </span><span class="s1">if (children.length &gt; 0) dataRoute.children = children;</span><span class="s2">\n    </span><span class="s1">return dataRoute;</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getShouldRevalidateFunction(path, route, manifestRoute, ssr, needsRevalidation) {</span><span class="s2">\n  </span><span class="s1">if (needsRevalidation) {</span><span class="s2">\n    </span><span class="s1">return wrapShouldRevalidateForHdr(manifestRoute.id, route.shouldRevalidate, needsRevalidation);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (!ssr &amp;&amp; manifestRoute.hasLoader &amp;&amp; !manifestRoute.hasClientLoader) {</span><span class="s2">\n    </span><span class="s1">let myParams = path ? compilePath(path)[1].map(p =&gt; p.paramName) : [];</span><span class="s2">\n    </span><span class="s1">const didParamsChange = opts =&gt; myParams.some(p =&gt; opts.currentParams[p] !== opts.nextParams[p]);</span><span class="s2">\n    </span><span class="s1">if (route.shouldRevalidate) {</span><span class="s2">\n      </span><span class="s1">let fn = route.shouldRevalidate;</span><span class="s2">\n      </span><span class="s1">return opts =&gt; fn({</span><span class="s2">\n        </span><span class="s1">...opts,</span><span class="s2">\n        </span><span class="s1">defaultShouldRevalidate: didParamsChange(opts)</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">return opts =&gt; didParamsChange(opts);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (ssr &amp;&amp; route.shouldRevalidate) {</span><span class="s2">\n    </span><span class="s1">let fn = route.shouldRevalidate;</span><span class="s2">\n    </span><span class="s1">return opts =&gt; fn({</span><span class="s2">\n      </span><span class="s1">...opts,</span><span class="s2">\n      </span><span class="s1">defaultShouldRevalidate: true</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return route.shouldRevalidate;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function wrapShouldRevalidateForHdr(routeId, routeShouldRevalidate, needsRevalidation) {</span><span class="s2">\n  </span><span class="s1">let handledRevalidation = false;</span><span class="s2">\n  </span><span class="s1">return arg =&gt; {</span><span class="s2">\n    </span><span class="s1">if (!handledRevalidation) {</span><span class="s2">\n      </span><span class="s1">handledRevalidation = true;</span><span class="s2">\n      </span><span class="s1">return needsRevalidation.has(routeId);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return routeShouldRevalidate ? routeShouldRevalidate(arg) : arg.defaultShouldRevalidate;</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">async function loadRouteModuleWithBlockingLinks(route, routeModules) {</span><span class="s2">\n  </span><span class="s1">let routeModulePromise = loadRouteModule(route, routeModules);</span><span class="s2">\n  </span><span class="s1">let prefetchRouteCssPromise = prefetchRouteCss(route);</span><span class="s2">\n  </span><span class="s1">let routeModule = await routeModulePromise;</span><span class="s2">\n  </span><span class="s1">await Promise.all([prefetchRouteCssPromise, prefetchStyleLinks(route, routeModule)]);</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">Component: getRouteModuleComponent(routeModule),</span><span class="s2">\n    </span><span class="s1">ErrorBoundary: routeModule.ErrorBoundary,</span><span class="s2">\n    </span><span class="s1">unstable_clientMiddleware: routeModule.unstable_clientMiddleware,</span><span class="s2">\n    </span><span class="s1">clientAction: routeModule.clientAction,</span><span class="s2">\n    </span><span class="s1">clientLoader: routeModule.clientLoader,</span><span class="s2">\n    </span><span class="s1">handle: routeModule.handle,</span><span class="s2">\n    </span><span class="s1">links: routeModule.links,</span><span class="s2">\n    </span><span class="s1">meta: routeModule.meta,</span><span class="s2">\n    </span><span class="s1">shouldRevalidate: routeModule.shouldRevalidate</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getRouteModuleComponent(routeModule) {</span><span class="s2">\n  </span><span class="s1">if (routeModule.default == null) return void 0;</span><span class="s2">\n  </span><span class="s1">let isEmptyObject = typeof routeModule.default === </span><span class="s2">\&quot;</span><span class="s1">object</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; Object.keys(routeModule.default).length === 0;</span><span class="s2">\n  </span><span class="s1">if (!isEmptyObject) {</span><span class="s2">\n    </span><span class="s1">return routeModule.default;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function shouldHydrateRouteLoader(routeId, clientLoader, hasLoader, isSpaMode) {</span><span class="s2">\n  </span><span class="s1">return isSpaMode &amp;&amp; routeId !== </span><span class="s2">\&quot;</span><span class="s1">root</span><span class="s2">\&quot; </span><span class="s1">|| clientLoader != null &amp;&amp; (clientLoader.hydrate === true || hasLoader !== true);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/dom/ssr/fog-of-war.ts</span><span class="s2">\n</span><span class="s1">var nextPaths = /* @__PURE__ */new Set();</span><span class="s2">\n</span><span class="s1">var discoveredPathsMaxSize = 1e3;</span><span class="s2">\n</span><span class="s1">var discoveredPaths = /* @__PURE__ */new Set();</span><span class="s2">\n</span><span class="s1">var URL_LIMIT = 7680;</span><span class="s2">\n</span><span class="s1">function isFogOfWarEnabled(routeDiscovery, ssr) {</span><span class="s2">\n  </span><span class="s1">return routeDiscovery.mode === </span><span class="s2">\&quot;</span><span class="s1">lazy</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; ssr === true;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getPartialManifest({</span><span class="s2">\n  </span><span class="s1">sri,</span><span class="s2">\n  </span><span class="s1">...manifest</span><span class="s2">\n</span><span class="s1">}, router) {</span><span class="s2">\n  </span><span class="s1">let routeIds = new Set(router.state.matches.map(m =&gt; m.route.id));</span><span class="s2">\n  </span><span class="s1">let segments = router.state.location.pathname.split(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">).filter(Boolean);</span><span class="s2">\n  </span><span class="s1">let paths = [</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">];</span><span class="s2">\n  </span><span class="s1">segments.pop();</span><span class="s2">\n  </span><span class="s1">while (segments.length &gt; 0) {</span><span class="s2">\n    </span><span class="s1">paths.push(`/${segments.join(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">)}`);</span><span class="s2">\n    </span><span class="s1">segments.pop();</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">paths.forEach(path =&gt; {</span><span class="s2">\n    </span><span class="s1">let matches = matchRoutes(router.routes, path, router.basename);</span><span class="s2">\n    </span><span class="s1">if (matches) {</span><span class="s2">\n      </span><span class="s1">matches.forEach(m =&gt; routeIds.add(m.route.id));</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">let initialRoutes = [...routeIds].reduce((acc, id) =&gt; Object.assign(acc, {</span><span class="s2">\n    </span><span class="s1">[id]: manifest.routes[id]</span><span class="s2">\n  </span><span class="s1">}), {});</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">...manifest,</span><span class="s2">\n    </span><span class="s1">routes: initialRoutes,</span><span class="s2">\n    </span><span class="s1">sri: sri ? true : void 0</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getPatchRoutesOnNavigationFunction(manifest, routeModules, ssr, routeDiscovery, isSpaMode, basename) {</span><span class="s2">\n  </span><span class="s1">if (!isFogOfWarEnabled(routeDiscovery, ssr)) {</span><span class="s2">\n    </span><span class="s1">return void 0;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return async ({</span><span class="s2">\n    </span><span class="s1">path,</span><span class="s2">\n    </span><span class="s1">patch,</span><span class="s2">\n    </span><span class="s1">signal,</span><span class="s2">\n    </span><span class="s1">fetcherKey</span><span class="s2">\n  </span><span class="s1">}) =&gt; {</span><span class="s2">\n    </span><span class="s1">if (discoveredPaths.has(path)) {</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">await fetchAndApplyManifestPatches([path], fetcherKey ? window.location.href : path, manifest, routeModules, ssr, isSpaMode, basename, routeDiscovery.manifestPath, patch, signal);</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useFogOFWarDiscovery(router, manifest, routeModules, ssr, routeDiscovery, isSpaMode) {</span><span class="s2">\n  </span><span class="s1">React8.useEffect(() =&gt; {</span><span class="s2">\n    </span><span class="s1">if (!isFogOfWarEnabled(routeDiscovery, ssr) ||</span><span class="s2">\n    </span><span class="s1">// @ts-expect-error - TS doesn't know about this yet</span><span class="s2">\n    </span><span class="s1">window.navigator?.connection?.saveData === true) {</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">function registerElement(el) {</span><span class="s2">\n      </span><span class="s1">let path = el.tagName === </span><span class="s2">\&quot;</span><span class="s1">FORM</span><span class="s2">\&quot; </span><span class="s1">? el.getAttribute(</span><span class="s2">\&quot;</span><span class="s1">action</span><span class="s2">\&quot;</span><span class="s1">) : el.getAttribute(</span><span class="s2">\&quot;</span><span class="s1">href</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">if (!path) {</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">let pathname = el.tagName === </span><span class="s2">\&quot;</span><span class="s1">A</span><span class="s2">\&quot; </span><span class="s1">? el.pathname : new URL(path, window.location.origin).pathname;</span><span class="s2">\n      </span><span class="s1">if (!discoveredPaths.has(pathname)) {</span><span class="s2">\n        </span><span class="s1">nextPaths.add(pathname);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">async function fetchPatches() {</span><span class="s2">\n      </span><span class="s1">document.querySelectorAll(</span><span class="s2">\&quot;</span><span class="s1">a[data-discover], form[data-discover]</span><span class="s2">\&quot;</span><span class="s1">).forEach(registerElement);</span><span class="s2">\n      </span><span class="s1">let lazyPaths = Array.from(nextPaths.keys()).filter(path =&gt; {</span><span class="s2">\n        </span><span class="s1">if (discoveredPaths.has(path)) {</span><span class="s2">\n          </span><span class="s1">nextPaths.delete(path);</span><span class="s2">\n          </span><span class="s1">return false;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return true;</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">if (lazyPaths.length === 0) {</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">try {</span><span class="s2">\n        </span><span class="s1">await fetchAndApplyManifestPatches(lazyPaths, null, manifest, routeModules, ssr, isSpaMode, router.basename, routeDiscovery.manifestPath, router.patchRoutes);</span><span class="s2">\n      </span><span class="s1">} catch (e) {</span><span class="s2">\n        </span><span class="s1">console.error(</span><span class="s2">\&quot;</span><span class="s1">Failed to fetch manifest patches</span><span class="s2">\&quot;</span><span class="s1">, e);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let debouncedFetchPatches = debounce(fetchPatches, 100);</span><span class="s2">\n    </span><span class="s1">fetchPatches();</span><span class="s2">\n    </span><span class="s1">let observer = new MutationObserver(() =&gt; debouncedFetchPatches());</span><span class="s2">\n    </span><span class="s1">observer.observe(document.documentElement, {</span><span class="s2">\n      </span><span class="s1">subtree: true,</span><span class="s2">\n      </span><span class="s1">childList: true,</span><span class="s2">\n      </span><span class="s1">attributes: true,</span><span class="s2">\n      </span><span class="s1">attributeFilter: [</span><span class="s2">\&quot;</span><span class="s1">data-discover</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">href</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">action</span><span class="s2">\&quot;</span><span class="s1">]</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">return () =&gt; observer.disconnect();</span><span class="s2">\n  </span><span class="s1">}, [ssr, isSpaMode, manifest, routeModules, router, routeDiscovery]);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getManifestPath(_manifestPath, basename) {</span><span class="s2">\n  </span><span class="s1">let manifestPath = _manifestPath || </span><span class="s2">\&quot;</span><span class="s1">/__manifest</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">if (basename == null) {</span><span class="s2">\n    </span><span class="s1">return manifestPath;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return `${basename}${manifestPath}`.replace(/</span><span class="s2">\\</span><span class="s1">/+/g, </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var MANIFEST_VERSION_STORAGE_KEY = </span><span class="s2">\&quot;</span><span class="s1">react-router-manifest-version</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">async function fetchAndApplyManifestPatches(paths, errorReloadPath, manifest, routeModules, ssr, isSpaMode, basename, manifestPath, patchRoutes, signal) {</span><span class="s2">\n  </span><span class="s1">let url = new URL(getManifestPath(manifestPath, basename), window.location.origin);</span><span class="s2">\n  </span><span class="s1">paths.sort().forEach(path =&gt; url.searchParams.append(</span><span class="s2">\&quot;</span><span class="s1">p</span><span class="s2">\&quot;</span><span class="s1">, path));</span><span class="s2">\n  </span><span class="s1">url.searchParams.set(</span><span class="s2">\&quot;</span><span class="s1">version</span><span class="s2">\&quot;</span><span class="s1">, manifest.version);</span><span class="s2">\n  </span><span class="s1">if (url.toString().length &gt; URL_LIMIT) {</span><span class="s2">\n    </span><span class="s1">nextPaths.clear();</span><span class="s2">\n    </span><span class="s1">return;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let serverPatches;</span><span class="s2">\n  </span><span class="s1">try {</span><span class="s2">\n    </span><span class="s1">let res = await fetch(url, {</span><span class="s2">\n      </span><span class="s1">signal</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">if (!res.ok) {</span><span class="s2">\n      </span><span class="s1">throw new Error(`${res.status} ${res.statusText}`);</span><span class="s2">\n    </span><span class="s1">} else if (res.status === 204 &amp;&amp; res.headers.has(</span><span class="s2">\&quot;</span><span class="s1">X-Remix-Reload-Document</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n      </span><span class="s1">if (!errorReloadPath) {</span><span class="s2">\n        </span><span class="s1">console.warn(</span><span class="s2">\&quot;</span><span class="s1">Detected a manifest version mismatch during eager route discovery. The next navigation/fetch to an undiscovered route will result in a new document navigation to sync up with the latest manifest.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (sessionStorage.getItem(MANIFEST_VERSION_STORAGE_KEY) === manifest.version) {</span><span class="s2">\n        </span><span class="s1">console.error(</span><span class="s2">\&quot;</span><span class="s1">Unable to discover routes due to manifest version mismatch.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">sessionStorage.setItem(MANIFEST_VERSION_STORAGE_KEY, manifest.version);</span><span class="s2">\n      </span><span class="s1">window.location.href = errorReloadPath;</span><span class="s2">\n      </span><span class="s1">console.warn(</span><span class="s2">\&quot;</span><span class="s1">Detected manifest version mismatch, reloading...</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">await new Promise(() =&gt; {});</span><span class="s2">\n    </span><span class="s1">} else if (res.status &gt;= 400) {</span><span class="s2">\n      </span><span class="s1">throw new Error(await res.text());</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">sessionStorage.removeItem(MANIFEST_VERSION_STORAGE_KEY);</span><span class="s2">\n    </span><span class="s1">serverPatches = await res.json();</span><span class="s2">\n  </span><span class="s1">} catch (e) {</span><span class="s2">\n    </span><span class="s1">if (signal?.aborted) return;</span><span class="s2">\n    </span><span class="s1">throw e;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let knownRoutes = new Set(Object.keys(manifest.routes));</span><span class="s2">\n  </span><span class="s1">let patches = Object.values(serverPatches).reduce((acc, route) =&gt; {</span><span class="s2">\n    </span><span class="s1">if (route &amp;&amp; !knownRoutes.has(route.id)) {</span><span class="s2">\n      </span><span class="s1">acc[route.id] = route;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return acc;</span><span class="s2">\n  </span><span class="s1">}, {});</span><span class="s2">\n  </span><span class="s1">Object.assign(manifest.routes, patches);</span><span class="s2">\n  </span><span class="s1">paths.forEach(p =&gt; addToFifoQueue(p, discoveredPaths));</span><span class="s2">\n  </span><span class="s1">let parentIds = /* @__PURE__ */new Set();</span><span class="s2">\n  </span><span class="s1">Object.values(patches).forEach(patch =&gt; {</span><span class="s2">\n    </span><span class="s1">if (patch &amp;&amp; (!patch.parentId || !patches[patch.parentId])) {</span><span class="s2">\n      </span><span class="s1">parentIds.add(patch.parentId);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">parentIds.forEach(parentId =&gt; patchRoutes(parentId || null, createClientRoutes(patches, routeModules, null, ssr, isSpaMode, parentId)));</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function addToFifoQueue(path, queue) {</span><span class="s2">\n  </span><span class="s1">if (queue.size &gt;= discoveredPathsMaxSize) {</span><span class="s2">\n    </span><span class="s1">let first = queue.values().next().value;</span><span class="s2">\n    </span><span class="s1">queue.delete(first);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">queue.add(path);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function debounce(callback, wait) {</span><span class="s2">\n  </span><span class="s1">let timeoutId;</span><span class="s2">\n  </span><span class="s1">return (...args) =&gt; {</span><span class="s2">\n    </span><span class="s1">window.clearTimeout(timeoutId);</span><span class="s2">\n    </span><span class="s1">timeoutId = window.setTimeout(() =&gt; callback(...args), wait);</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/dom/ssr/components.tsx</span><span class="s2">\n</span><span class="s1">function useDataRouterContext2() {</span><span class="s2">\n  </span><span class="s1">let context = React9.useContext(DataRouterContext);</span><span class="s2">\n  </span><span class="s1">invariant2(context, </span><span class="s2">\&quot;</span><span class="s1">You must render this element inside a &lt;DataRouterContext.Provider&gt; element</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">return context;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useDataRouterStateContext() {</span><span class="s2">\n  </span><span class="s1">let context = React9.useContext(DataRouterStateContext);</span><span class="s2">\n  </span><span class="s1">invariant2(context, </span><span class="s2">\&quot;</span><span class="s1">You must render this element inside a &lt;DataRouterStateContext.Provider&gt; element</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">return context;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var FrameworkContext = React9.createContext(void 0);</span><span class="s2">\n</span><span class="s1">FrameworkContext.displayName = </span><span class="s2">\&quot;</span><span class="s1">FrameworkContext</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">function useFrameworkContext() {</span><span class="s2">\n  </span><span class="s1">let context = React9.useContext(FrameworkContext);</span><span class="s2">\n  </span><span class="s1">invariant2(context, </span><span class="s2">\&quot;</span><span class="s1">You must render this element inside a &lt;HydratedRouter&gt; element</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">return context;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function usePrefetchBehavior(prefetch, theirElementProps) {</span><span class="s2">\n  </span><span class="s1">let frameworkContext = React9.useContext(FrameworkContext);</span><span class="s2">\n  </span><span class="s1">let [maybePrefetch, setMaybePrefetch] = React9.useState(false);</span><span class="s2">\n  </span><span class="s1">let [shouldPrefetch, setShouldPrefetch] = React9.useState(false);</span><span class="s2">\n  </span><span class="s1">let {</span><span class="s2">\n    </span><span class="s1">onFocus,</span><span class="s2">\n    </span><span class="s1">onBlur,</span><span class="s2">\n    </span><span class="s1">onMouseEnter,</span><span class="s2">\n    </span><span class="s1">onMouseLeave,</span><span class="s2">\n    </span><span class="s1">onTouchStart</span><span class="s2">\n  </span><span class="s1">} = theirElementProps;</span><span class="s2">\n  </span><span class="s1">let ref = React9.useRef(null);</span><span class="s2">\n  </span><span class="s1">React9.useEffect(() =&gt; {</span><span class="s2">\n    </span><span class="s1">if (prefetch === </span><span class="s2">\&quot;</span><span class="s1">render</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">setShouldPrefetch(true);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (prefetch === </span><span class="s2">\&quot;</span><span class="s1">viewport</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">let callback = entries =&gt; {</span><span class="s2">\n        </span><span class="s1">entries.forEach(entry =&gt; {</span><span class="s2">\n          </span><span class="s1">setShouldPrefetch(entry.isIntersecting);</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">let observer = new IntersectionObserver(callback, {</span><span class="s2">\n        </span><span class="s1">threshold: 0.5</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">if (ref.current) observer.observe(ref.current);</span><span class="s2">\n      </span><span class="s1">return () =&gt; {</span><span class="s2">\n        </span><span class="s1">observer.disconnect();</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}, [prefetch]);</span><span class="s2">\n  </span><span class="s1">React9.useEffect(() =&gt; {</span><span class="s2">\n    </span><span class="s1">if (maybePrefetch) {</span><span class="s2">\n      </span><span class="s1">let id = setTimeout(() =&gt; {</span><span class="s2">\n        </span><span class="s1">setShouldPrefetch(true);</span><span class="s2">\n      </span><span class="s1">}, 100);</span><span class="s2">\n      </span><span class="s1">return () =&gt; {</span><span class="s2">\n        </span><span class="s1">clearTimeout(id);</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}, [maybePrefetch]);</span><span class="s2">\n  </span><span class="s1">let setIntent = () =&gt; {</span><span class="s2">\n    </span><span class="s1">setMaybePrefetch(true);</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">let cancelIntent = () =&gt; {</span><span class="s2">\n    </span><span class="s1">setMaybePrefetch(false);</span><span class="s2">\n    </span><span class="s1">setShouldPrefetch(false);</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">if (!frameworkContext) {</span><span class="s2">\n    </span><span class="s1">return [false, ref, {}];</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (prefetch !== </span><span class="s2">\&quot;</span><span class="s1">intent</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">return [shouldPrefetch, ref, {}];</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return [shouldPrefetch, ref, {</span><span class="s2">\n    </span><span class="s1">onFocus: composeEventHandlers(onFocus, setIntent),</span><span class="s2">\n    </span><span class="s1">onBlur: composeEventHandlers(onBlur, cancelIntent),</span><span class="s2">\n    </span><span class="s1">onMouseEnter: composeEventHandlers(onMouseEnter, setIntent),</span><span class="s2">\n    </span><span class="s1">onMouseLeave: composeEventHandlers(onMouseLeave, cancelIntent),</span><span class="s2">\n    </span><span class="s1">onTouchStart: composeEventHandlers(onTouchStart, setIntent)</span><span class="s2">\n  </span><span class="s1">}];</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function composeEventHandlers(theirHandler, ourHandler) {</span><span class="s2">\n  </span><span class="s1">return event =&gt; {</span><span class="s2">\n    </span><span class="s1">theirHandler &amp;&amp; theirHandler(event);</span><span class="s2">\n    </span><span class="s1">if (!event.defaultPrevented) {</span><span class="s2">\n      </span><span class="s1">ourHandler(event);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getActiveMatches(matches, errors, isSpaMode) {</span><span class="s2">\n  </span><span class="s1">if (isSpaMode &amp;&amp; !isHydrated) {</span><span class="s2">\n    </span><span class="s1">return [matches[0]];</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (errors) {</span><span class="s2">\n    </span><span class="s1">let errorIdx = matches.findIndex(m =&gt; errors[m.route.id] !== void 0);</span><span class="s2">\n    </span><span class="s1">return matches.slice(0, errorIdx + 1);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return matches;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function Links() {</span><span class="s2">\n  </span><span class="s1">let {</span><span class="s2">\n    </span><span class="s1">isSpaMode,</span><span class="s2">\n    </span><span class="s1">manifest,</span><span class="s2">\n    </span><span class="s1">routeModules,</span><span class="s2">\n    </span><span class="s1">criticalCss</span><span class="s2">\n  </span><span class="s1">} = useFrameworkContext();</span><span class="s2">\n  </span><span class="s1">let {</span><span class="s2">\n    </span><span class="s1">errors,</span><span class="s2">\n    </span><span class="s1">matches: routerMatches</span><span class="s2">\n  </span><span class="s1">} = useDataRouterStateContext();</span><span class="s2">\n  </span><span class="s1">let matches = getActiveMatches(routerMatches, errors, isSpaMode);</span><span class="s2">\n  </span><span class="s1">let keyedLinks = React9.useMemo(() =&gt; getKeyedLinksForMatches(matches, routeModules, manifest), [matches, routeModules, manifest]);</span><span class="s2">\n  </span><span class="s1">return /* @__PURE__ */React9.createElement(React9.Fragment, null, typeof criticalCss === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">? /* @__PURE__ */React9.createElement(</span><span class="s2">\&quot;</span><span class="s1">style</span><span class="s2">\&quot;</span><span class="s1">, {</span><span class="s2">\n    </span><span class="s1">dangerouslySetInnerHTML: {</span><span class="s2">\n      </span><span class="s1">__html: criticalCss</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}) : null, typeof criticalCss === </span><span class="s2">\&quot;</span><span class="s1">object</span><span class="s2">\&quot; </span><span class="s1">? /* @__PURE__ */React9.createElement(</span><span class="s2">\&quot;</span><span class="s1">link</span><span class="s2">\&quot;</span><span class="s1">, {</span><span class="s2">\n    </span><span class="s1">rel: </span><span class="s2">\&quot;</span><span class="s1">stylesheet</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">href: criticalCss.href</span><span class="s2">\n  </span><span class="s1">}) : null, keyedLinks.map(({</span><span class="s2">\n    </span><span class="s1">key,</span><span class="s2">\n    </span><span class="s1">link</span><span class="s2">\n  </span><span class="s1">}) =&gt; isPageLinkDescriptor(link) ? /* @__PURE__ */React9.createElement(PrefetchPageLinks, {</span><span class="s2">\n    </span><span class="s1">key,</span><span class="s2">\n    </span><span class="s1">...link</span><span class="s2">\n  </span><span class="s1">}) : /* @__PURE__ */React9.createElement(</span><span class="s2">\&quot;</span><span class="s1">link</span><span class="s2">\&quot;</span><span class="s1">, {</span><span class="s2">\n    </span><span class="s1">key,</span><span class="s2">\n    </span><span class="s1">...link</span><span class="s2">\n  </span><span class="s1">})));</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function PrefetchPageLinks({</span><span class="s2">\n  </span><span class="s1">page,</span><span class="s2">\n  </span><span class="s1">...dataLinkProps</span><span class="s2">\n</span><span class="s1">}) {</span><span class="s2">\n  </span><span class="s1">let {</span><span class="s2">\n    </span><span class="s1">router</span><span class="s2">\n  </span><span class="s1">} = useDataRouterContext2();</span><span class="s2">\n  </span><span class="s1">let matches = React9.useMemo(() =&gt; matchRoutes(router.routes, page, router.basename), [router.routes, page, router.basename]);</span><span class="s2">\n  </span><span class="s1">if (!matches) {</span><span class="s2">\n    </span><span class="s1">return null;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return /* @__PURE__ */React9.createElement(PrefetchPageLinksImpl, {</span><span class="s2">\n    </span><span class="s1">page,</span><span class="s2">\n    </span><span class="s1">matches,</span><span class="s2">\n    </span><span class="s1">...dataLinkProps</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useKeyedPrefetchLinks(matches) {</span><span class="s2">\n  </span><span class="s1">let {</span><span class="s2">\n    </span><span class="s1">manifest,</span><span class="s2">\n    </span><span class="s1">routeModules</span><span class="s2">\n  </span><span class="s1">} = useFrameworkContext();</span><span class="s2">\n  </span><span class="s1">let [keyedPrefetchLinks, setKeyedPrefetchLinks] = React9.useState([]);</span><span class="s2">\n  </span><span class="s1">React9.useEffect(() =&gt; {</span><span class="s2">\n    </span><span class="s1">let interrupted = false;</span><span class="s2">\n    </span><span class="s1">void getKeyedPrefetchLinks(matches, manifest, routeModules).then(links =&gt; {</span><span class="s2">\n      </span><span class="s1">if (!interrupted) {</span><span class="s2">\n        </span><span class="s1">setKeyedPrefetchLinks(links);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">return () =&gt; {</span><span class="s2">\n      </span><span class="s1">interrupted = true;</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}, [matches, manifest, routeModules]);</span><span class="s2">\n  </span><span class="s1">return keyedPrefetchLinks;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function PrefetchPageLinksImpl({</span><span class="s2">\n  </span><span class="s1">page,</span><span class="s2">\n  </span><span class="s1">matches: nextMatches,</span><span class="s2">\n  </span><span class="s1">...linkProps</span><span class="s2">\n</span><span class="s1">}) {</span><span class="s2">\n  </span><span class="s1">let location = useLocation();</span><span class="s2">\n  </span><span class="s1">let {</span><span class="s2">\n    </span><span class="s1">manifest,</span><span class="s2">\n    </span><span class="s1">routeModules</span><span class="s2">\n  </span><span class="s1">} = useFrameworkContext();</span><span class="s2">\n  </span><span class="s1">let {</span><span class="s2">\n    </span><span class="s1">basename</span><span class="s2">\n  </span><span class="s1">} = useDataRouterContext2();</span><span class="s2">\n  </span><span class="s1">let {</span><span class="s2">\n    </span><span class="s1">loaderData,</span><span class="s2">\n    </span><span class="s1">matches</span><span class="s2">\n  </span><span class="s1">} = useDataRouterStateContext();</span><span class="s2">\n  </span><span class="s1">let newMatchesForData = React9.useMemo(() =&gt; getNewMatchesForLinks(page, nextMatches, matches, manifest, location, </span><span class="s2">\&quot;</span><span class="s1">data</span><span class="s2">\&quot;</span><span class="s1">), [page, nextMatches, matches, manifest, location]);</span><span class="s2">\n  </span><span class="s1">let newMatchesForAssets = React9.useMemo(() =&gt; getNewMatchesForLinks(page, nextMatches, matches, manifest, location, </span><span class="s2">\&quot;</span><span class="s1">assets</span><span class="s2">\&quot;</span><span class="s1">), [page, nextMatches, matches, manifest, location]);</span><span class="s2">\n  </span><span class="s1">let dataHrefs = React9.useMemo(() =&gt; {</span><span class="s2">\n    </span><span class="s1">if (page === location.pathname + location.search + location.hash) {</span><span class="s2">\n      </span><span class="s1">return [];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let routesParams = /* @__PURE__ */new Set();</span><span class="s2">\n    </span><span class="s1">let foundOptOutRoute = false;</span><span class="s2">\n    </span><span class="s1">nextMatches.forEach(m =&gt; {</span><span class="s2">\n      </span><span class="s1">let manifestRoute = manifest.routes[m.route.id];</span><span class="s2">\n      </span><span class="s1">if (!manifestRoute || !manifestRoute.hasLoader) {</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (!newMatchesForData.some(m2 =&gt; m2.route.id === m.route.id) &amp;&amp; m.route.id in loaderData &amp;&amp; routeModules[m.route.id]?.shouldRevalidate) {</span><span class="s2">\n        </span><span class="s1">foundOptOutRoute = true;</span><span class="s2">\n      </span><span class="s1">} else if (manifestRoute.hasClientLoader) {</span><span class="s2">\n        </span><span class="s1">foundOptOutRoute = true;</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">routesParams.add(m.route.id);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">if (routesParams.size === 0) {</span><span class="s2">\n      </span><span class="s1">return [];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let url = singleFetchUrl(page, basename);</span><span class="s2">\n    </span><span class="s1">if (foundOptOutRoute &amp;&amp; routesParams.size &gt; 0) {</span><span class="s2">\n      </span><span class="s1">url.searchParams.set(</span><span class="s2">\&quot;</span><span class="s1">_routes</span><span class="s2">\&quot;</span><span class="s1">, nextMatches.filter(m =&gt; routesParams.has(m.route.id)).map(m =&gt; m.route.id).join(</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\&quot;</span><span class="s1">));</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return [url.pathname + url.search];</span><span class="s2">\n  </span><span class="s1">}, [basename, loaderData, location, manifest, newMatchesForData, nextMatches, page, routeModules]);</span><span class="s2">\n  </span><span class="s1">let moduleHrefs = React9.useMemo(() =&gt; getModuleLinkHrefs(newMatchesForAssets, manifest), [newMatchesForAssets, manifest]);</span><span class="s2">\n  </span><span class="s1">let keyedPrefetchLinks = useKeyedPrefetchLinks(newMatchesForAssets);</span><span class="s2">\n  </span><span class="s1">return /* @__PURE__ */React9.createElement(React9.Fragment, null, dataHrefs.map(href2 =&gt; /* @__PURE__ */React9.createElement(</span><span class="s2">\&quot;</span><span class="s1">link</span><span class="s2">\&quot;</span><span class="s1">, {</span><span class="s2">\n    </span><span class="s1">key: href2,</span><span class="s2">\n    </span><span class="s1">rel: </span><span class="s2">\&quot;</span><span class="s1">prefetch</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">as: </span><span class="s2">\&quot;</span><span class="s1">fetch</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">href: href2,</span><span class="s2">\n    </span><span class="s1">...linkProps</span><span class="s2">\n  </span><span class="s1">})), moduleHrefs.map(href2 =&gt; /* @__PURE__ */React9.createElement(</span><span class="s2">\&quot;</span><span class="s1">link</span><span class="s2">\&quot;</span><span class="s1">, {</span><span class="s2">\n    </span><span class="s1">key: href2,</span><span class="s2">\n    </span><span class="s1">rel: </span><span class="s2">\&quot;</span><span class="s1">modulepreload</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">href: href2,</span><span class="s2">\n    </span><span class="s1">...linkProps</span><span class="s2">\n  </span><span class="s1">})), keyedPrefetchLinks.map(({</span><span class="s2">\n    </span><span class="s1">key,</span><span class="s2">\n    </span><span class="s1">link</span><span class="s2">\n  </span><span class="s1">}) =&gt;</span><span class="s2">\n  </span><span class="s1">// these don't spread `linkProps` because they are full link descriptors</span><span class="s2">\n  </span><span class="s1">// already with their own props</span><span class="s2">\n  </span><span class="s1">/* @__PURE__ */</span><span class="s2">\n  </span><span class="s1">React9.createElement(</span><span class="s2">\&quot;</span><span class="s1">link</span><span class="s2">\&quot;</span><span class="s1">, {</span><span class="s2">\n    </span><span class="s1">key,</span><span class="s2">\n    </span><span class="s1">...link</span><span class="s2">\n  </span><span class="s1">})));</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function Meta() {</span><span class="s2">\n  </span><span class="s1">let {</span><span class="s2">\n    </span><span class="s1">isSpaMode,</span><span class="s2">\n    </span><span class="s1">routeModules</span><span class="s2">\n  </span><span class="s1">} = useFrameworkContext();</span><span class="s2">\n  </span><span class="s1">let {</span><span class="s2">\n    </span><span class="s1">errors,</span><span class="s2">\n    </span><span class="s1">matches: routerMatches,</span><span class="s2">\n    </span><span class="s1">loaderData</span><span class="s2">\n  </span><span class="s1">} = useDataRouterStateContext();</span><span class="s2">\n  </span><span class="s1">let location = useLocation();</span><span class="s2">\n  </span><span class="s1">let _matches = getActiveMatches(routerMatches, errors, isSpaMode);</span><span class="s2">\n  </span><span class="s1">let error = null;</span><span class="s2">\n  </span><span class="s1">if (errors) {</span><span class="s2">\n    </span><span class="s1">error = errors[_matches[_matches.length - 1].route.id];</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let meta = [];</span><span class="s2">\n  </span><span class="s1">let leafMeta = null;</span><span class="s2">\n  </span><span class="s1">let matches = [];</span><span class="s2">\n  </span><span class="s1">for (let i = 0; i &lt; _matches.length; i++) {</span><span class="s2">\n    </span><span class="s1">let _match = _matches[i];</span><span class="s2">\n    </span><span class="s1">let routeId = _match.route.id;</span><span class="s2">\n    </span><span class="s1">let data2 = loaderData[routeId];</span><span class="s2">\n    </span><span class="s1">let params = _match.params;</span><span class="s2">\n    </span><span class="s1">let routeModule = routeModules[routeId];</span><span class="s2">\n    </span><span class="s1">let routeMeta = [];</span><span class="s2">\n    </span><span class="s1">let match = {</span><span class="s2">\n      </span><span class="s1">id: routeId,</span><span class="s2">\n      </span><span class="s1">data: data2,</span><span class="s2">\n      </span><span class="s1">meta: [],</span><span class="s2">\n      </span><span class="s1">params: _match.params,</span><span class="s2">\n      </span><span class="s1">pathname: _match.pathname,</span><span class="s2">\n      </span><span class="s1">handle: _match.route.handle,</span><span class="s2">\n      </span><span class="s1">error</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">matches[i] = match;</span><span class="s2">\n    </span><span class="s1">if (routeModule?.meta) {</span><span class="s2">\n      </span><span class="s1">routeMeta = typeof routeModule.meta === </span><span class="s2">\&quot;</span><span class="s1">function</span><span class="s2">\&quot; </span><span class="s1">? routeModule.meta({</span><span class="s2">\n        </span><span class="s1">data: data2,</span><span class="s2">\n        </span><span class="s1">params,</span><span class="s2">\n        </span><span class="s1">location,</span><span class="s2">\n        </span><span class="s1">matches,</span><span class="s2">\n        </span><span class="s1">error</span><span class="s2">\n      </span><span class="s1">}) : Array.isArray(routeModule.meta) ? [...routeModule.meta] : routeModule.meta;</span><span class="s2">\n    </span><span class="s1">} else if (leafMeta) {</span><span class="s2">\n      </span><span class="s1">routeMeta = [...leafMeta];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">routeMeta = routeMeta || [];</span><span class="s2">\n    </span><span class="s1">if (!Array.isArray(routeMeta)) {</span><span class="s2">\n      </span><span class="s1">throw new Error(</span><span class="s2">\&quot;</span><span class="s1">The route at </span><span class="s2">\&quot; </span><span class="s1">+ _match.route.path + </span><span class="s2">\&quot; </span><span class="s1">returns an invalid value. All route meta functions must return an array of meta objects.</span><span class="s2">\\</span><span class="s1">n</span><span class="s2">\\</span><span class="s1">nTo reference the meta function API, see https://remix.run/route/meta</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">match.meta = routeMeta;</span><span class="s2">\n    </span><span class="s1">matches[i] = match;</span><span class="s2">\n    </span><span class="s1">meta = [...routeMeta];</span><span class="s2">\n    </span><span class="s1">leafMeta = meta;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return /* @__PURE__ */React9.createElement(React9.Fragment, null, meta.flat().map(metaProps =&gt; {</span><span class="s2">\n    </span><span class="s1">if (!metaProps) {</span><span class="s2">\n      </span><span class="s1">return null;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (</span><span class="s2">\&quot;</span><span class="s1">tagName</span><span class="s2">\&quot; </span><span class="s1">in metaProps) {</span><span class="s2">\n      </span><span class="s1">let {</span><span class="s2">\n        </span><span class="s1">tagName,</span><span class="s2">\n        </span><span class="s1">...rest</span><span class="s2">\n      </span><span class="s1">} = metaProps;</span><span class="s2">\n      </span><span class="s1">if (!isValidMetaTag(tagName)) {</span><span class="s2">\n        </span><span class="s1">console.warn(`A meta object uses an invalid tagName: ${tagName}. Expected either 'link' or 'meta'`);</span><span class="s2">\n        </span><span class="s1">return null;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">let Comp = tagName;</span><span class="s2">\n      </span><span class="s1">return /* @__PURE__ */React9.createElement(Comp, {</span><span class="s2">\n        </span><span class="s1">key: JSON.stringify(rest),</span><span class="s2">\n        </span><span class="s1">...rest</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (</span><span class="s2">\&quot;</span><span class="s1">title</span><span class="s2">\&quot; </span><span class="s1">in metaProps) {</span><span class="s2">\n      </span><span class="s1">return /* @__PURE__ */React9.createElement(</span><span class="s2">\&quot;</span><span class="s1">title</span><span class="s2">\&quot;</span><span class="s1">, {</span><span class="s2">\n        </span><span class="s1">key: </span><span class="s2">\&quot;</span><span class="s1">title</span><span class="s2">\&quot;\n      </span><span class="s1">}, String(metaProps.title));</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (</span><span class="s2">\&quot;</span><span class="s1">charset</span><span class="s2">\&quot; </span><span class="s1">in metaProps) {</span><span class="s2">\n      </span><span class="s1">metaProps.charSet ?? (metaProps.charSet = metaProps.charset);</span><span class="s2">\n      </span><span class="s1">delete metaProps.charset;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (</span><span class="s2">\&quot;</span><span class="s1">charSet</span><span class="s2">\&quot; </span><span class="s1">in metaProps &amp;&amp; metaProps.charSet != null) {</span><span class="s2">\n      </span><span class="s1">return typeof metaProps.charSet === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">? /* @__PURE__ */React9.createElement(</span><span class="s2">\&quot;</span><span class="s1">meta</span><span class="s2">\&quot;</span><span class="s1">, {</span><span class="s2">\n        </span><span class="s1">key: </span><span class="s2">\&quot;</span><span class="s1">charSet</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        </span><span class="s1">charSet: metaProps.charSet</span><span class="s2">\n      </span><span class="s1">}) : null;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (</span><span class="s2">\&quot;</span><span class="s1">script:ld+json</span><span class="s2">\&quot; </span><span class="s1">in metaProps) {</span><span class="s2">\n      </span><span class="s1">try {</span><span class="s2">\n        </span><span class="s1">let json = JSON.stringify(metaProps[</span><span class="s2">\&quot;</span><span class="s1">script:ld+json</span><span class="s2">\&quot;</span><span class="s1">]);</span><span class="s2">\n        </span><span class="s1">return /* @__PURE__ */React9.createElement(</span><span class="s2">\&quot;</span><span class="s1">script</span><span class="s2">\&quot;</span><span class="s1">, {</span><span class="s2">\n          </span><span class="s1">key: `script:ld+json:${json}`,</span><span class="s2">\n          </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">application/ld+json</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n          </span><span class="s1">dangerouslySetInnerHTML: {</span><span class="s2">\n            </span><span class="s1">__html: json</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">} catch (err) {</span><span class="s2">\n        </span><span class="s1">return null;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return /* @__PURE__ */React9.createElement(</span><span class="s2">\&quot;</span><span class="s1">meta</span><span class="s2">\&quot;</span><span class="s1">, {</span><span class="s2">\n      </span><span class="s1">key: JSON.stringify(metaProps),</span><span class="s2">\n      </span><span class="s1">...metaProps</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}));</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isValidMetaTag(tagName) {</span><span class="s2">\n  </span><span class="s1">return typeof tagName === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; /^(meta|link)$/.test(tagName);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var isHydrated = false;</span><span class="s2">\n</span><span class="s1">function Scripts(props) {</span><span class="s2">\n  </span><span class="s1">let {</span><span class="s2">\n    </span><span class="s1">manifest,</span><span class="s2">\n    </span><span class="s1">serverHandoffString,</span><span class="s2">\n    </span><span class="s1">isSpaMode,</span><span class="s2">\n    </span><span class="s1">renderMeta,</span><span class="s2">\n    </span><span class="s1">routeDiscovery,</span><span class="s2">\n    </span><span class="s1">ssr</span><span class="s2">\n  </span><span class="s1">} = useFrameworkContext();</span><span class="s2">\n  </span><span class="s1">let {</span><span class="s2">\n    </span><span class="s1">router,</span><span class="s2">\n    </span><span class="s1">static: isStatic,</span><span class="s2">\n    </span><span class="s1">staticContext</span><span class="s2">\n  </span><span class="s1">} = useDataRouterContext2();</span><span class="s2">\n  </span><span class="s1">let {</span><span class="s2">\n    </span><span class="s1">matches: routerMatches</span><span class="s2">\n  </span><span class="s1">} = useDataRouterStateContext();</span><span class="s2">\n  </span><span class="s1">let enableFogOfWar = isFogOfWarEnabled(routeDiscovery, ssr);</span><span class="s2">\n  </span><span class="s1">if (renderMeta) {</span><span class="s2">\n    </span><span class="s1">renderMeta.didRenderScripts = true;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let matches = getActiveMatches(routerMatches, null, isSpaMode);</span><span class="s2">\n  </span><span class="s1">React9.useEffect(() =&gt; {</span><span class="s2">\n    </span><span class="s1">isHydrated = true;</span><span class="s2">\n  </span><span class="s1">}, []);</span><span class="s2">\n  </span><span class="s1">let initialScripts = React9.useMemo(() =&gt; {</span><span class="s2">\n    </span><span class="s1">let streamScript = </span><span class="s2">\&quot;</span><span class="s1">window.__reactRouterContext.stream = new ReadableStream({start(controller){window.__reactRouterContext.streamController = controller;}}).pipeThrough(new TextEncoderStream());</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">let contextScript = staticContext ? `window.__reactRouterContext = ${serverHandoffString};${streamScript}` : </span><span class="s2">\&quot; \&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">let routeModulesScript = !isStatic ? </span><span class="s2">\&quot; \&quot; </span><span class="s1">: `${manifest.hmr?.runtime ? `import ${JSON.stringify(manifest.hmr.runtime)};` : </span><span class="s2">\&quot;\&quot;</span><span class="s1">}${!enableFogOfWar ? `import ${JSON.stringify(manifest.url)}` : </span><span class="s2">\&quot;\&quot;</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">${matches.map((match, routeIndex) =&gt; {</span><span class="s2">\n      </span><span class="s1">let routeVarName = `route${routeIndex}`;</span><span class="s2">\n      </span><span class="s1">let manifestEntry = manifest.routes[match.route.id];</span><span class="s2">\n      </span><span class="s1">invariant2(manifestEntry, `Route ${match.route.id} not found in manifest`);</span><span class="s2">\n      </span><span class="s1">let {</span><span class="s2">\n        </span><span class="s1">clientActionModule,</span><span class="s2">\n        </span><span class="s1">clientLoaderModule,</span><span class="s2">\n        </span><span class="s1">clientMiddlewareModule,</span><span class="s2">\n        </span><span class="s1">hydrateFallbackModule,</span><span class="s2">\n        </span><span class="s1">module</span><span class="s2">\n      </span><span class="s1">} = manifestEntry;</span><span class="s2">\n      </span><span class="s1">let chunks = [...(clientActionModule ? [{</span><span class="s2">\n        </span><span class="s1">module: clientActionModule,</span><span class="s2">\n        </span><span class="s1">varName: `${routeVarName}_clientAction`</span><span class="s2">\n      </span><span class="s1">}] : []), ...(clientLoaderModule ? [{</span><span class="s2">\n        </span><span class="s1">module: clientLoaderModule,</span><span class="s2">\n        </span><span class="s1">varName: `${routeVarName}_clientLoader`</span><span class="s2">\n      </span><span class="s1">}] : []), ...(clientMiddlewareModule ? [{</span><span class="s2">\n        </span><span class="s1">module: clientMiddlewareModule,</span><span class="s2">\n        </span><span class="s1">varName: `${routeVarName}_clientMiddleware`</span><span class="s2">\n      </span><span class="s1">}] : []), ...(hydrateFallbackModule ? [{</span><span class="s2">\n        </span><span class="s1">module: hydrateFallbackModule,</span><span class="s2">\n        </span><span class="s1">varName: `${routeVarName}_HydrateFallback`</span><span class="s2">\n      </span><span class="s1">}] : []), {</span><span class="s2">\n        </span><span class="s1">module,</span><span class="s2">\n        </span><span class="s1">varName: `${routeVarName}_main`</span><span class="s2">\n      </span><span class="s1">}];</span><span class="s2">\n      </span><span class="s1">if (chunks.length === 1) {</span><span class="s2">\n        </span><span class="s1">return `import * as ${routeVarName} from ${JSON.stringify(module)};`;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">let chunkImportsSnippet = chunks.map(chunk =&gt; `import * as ${chunk.varName} from </span><span class="s2">\&quot;</span><span class="s1">${chunk.module}</span><span class="s2">\&quot;</span><span class="s1">;`).join(</span><span class="s2">\&quot;\\</span><span class="s1">n</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">let mergedChunksSnippet = `const ${routeVarName} = {${chunks.map(chunk =&gt; `...${chunk.varName}`).join(</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\&quot;</span><span class="s1">)}};`;</span><span class="s2">\n      </span><span class="s1">return [chunkImportsSnippet, mergedChunksSnippet].join(</span><span class="s2">\&quot;\\</span><span class="s1">n</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}).join(</span><span class="s2">\&quot;\\</span><span class="s1">n</span><span class="s2">\&quot;</span><span class="s1">)}</span><span class="s2">\n  </span><span class="s1">${enableFogOfWar ?</span><span class="s2">\n    </span><span class="s1">// Inline a minimal manifest with the SSR matches</span><span class="s2">\n    </span><span class="s1">`window.__reactRouterManifest = ${JSON.stringify(getPartialManifest(manifest, router), null, 2)};` : </span><span class="s2">\&quot;\&quot;</span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">window.__reactRouterRouteModules = {${matches.map((match, index) =&gt; `${JSON.stringify(match.route.id)}:route${index}`).join(</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\&quot;</span><span class="s1">)}};</span><span class="s2">\n\n</span><span class="s1">import(${JSON.stringify(manifest.entry.module)});`;</span><span class="s2">\n    </span><span class="s1">return /* @__PURE__ */React9.createElement(React9.Fragment, null, /* @__PURE__ */React9.createElement(</span><span class="s2">\&quot;</span><span class="s1">script</span><span class="s2">\&quot;</span><span class="s1">, {</span><span class="s2">\n      </span><span class="s1">...props,</span><span class="s2">\n      </span><span class="s1">suppressHydrationWarning: true,</span><span class="s2">\n      </span><span class="s1">dangerouslySetInnerHTML: createHtml(contextScript),</span><span class="s2">\n      </span><span class="s1">type: void 0</span><span class="s2">\n    </span><span class="s1">}), /* @__PURE__ */React9.createElement(</span><span class="s2">\&quot;</span><span class="s1">script</span><span class="s2">\&quot;</span><span class="s1">, {</span><span class="s2">\n      </span><span class="s1">...props,</span><span class="s2">\n      </span><span class="s1">suppressHydrationWarning: true,</span><span class="s2">\n      </span><span class="s1">dangerouslySetInnerHTML: createHtml(routeModulesScript),</span><span class="s2">\n      </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">module</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">async: true</span><span class="s2">\n    </span><span class="s1">}));</span><span class="s2">\n  </span><span class="s1">}, []);</span><span class="s2">\n  </span><span class="s1">let preloads = isHydrated ? [] : dedupe(manifest.entry.imports.concat(getModuleLinkHrefs(matches, manifest, {</span><span class="s2">\n    </span><span class="s1">includeHydrateFallback: true</span><span class="s2">\n  </span><span class="s1">})));</span><span class="s2">\n  </span><span class="s1">let sri = typeof manifest.sri === </span><span class="s2">\&quot;</span><span class="s1">object</span><span class="s2">\&quot; </span><span class="s1">? manifest.sri : {};</span><span class="s2">\n  </span><span class="s1">return isHydrated ? null : /* @__PURE__ */React9.createElement(React9.Fragment, null, typeof manifest.sri === </span><span class="s2">\&quot;</span><span class="s1">object</span><span class="s2">\&quot; </span><span class="s1">? /* @__PURE__ */React9.createElement(</span><span class="s2">\&quot;</span><span class="s1">script</span><span class="s2">\&quot;</span><span class="s1">, {</span><span class="s2">\n    \&quot;</span><span class="s1">rr-importmap</span><span class="s2">\&quot;</span><span class="s1">: </span><span class="s2">\&quot;\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">importmap</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">suppressHydrationWarning: true,</span><span class="s2">\n    </span><span class="s1">dangerouslySetInnerHTML: {</span><span class="s2">\n      </span><span class="s1">__html: JSON.stringify({</span><span class="s2">\n        </span><span class="s1">integrity: sri</span><span class="s2">\n      </span><span class="s1">})</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}) : null, !enableFogOfWar ? /* @__PURE__ */React9.createElement(</span><span class="s2">\&quot;</span><span class="s1">link</span><span class="s2">\&quot;</span><span class="s1">, {</span><span class="s2">\n    </span><span class="s1">rel: </span><span class="s2">\&quot;</span><span class="s1">modulepreload</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">href: manifest.url,</span><span class="s2">\n    </span><span class="s1">crossOrigin: props.crossOrigin,</span><span class="s2">\n    </span><span class="s1">integrity: sri[manifest.url],</span><span class="s2">\n    </span><span class="s1">suppressHydrationWarning: true</span><span class="s2">\n  </span><span class="s1">}) : null, /* @__PURE__ */React9.createElement(</span><span class="s2">\&quot;</span><span class="s1">link</span><span class="s2">\&quot;</span><span class="s1">, {</span><span class="s2">\n    </span><span class="s1">rel: </span><span class="s2">\&quot;</span><span class="s1">modulepreload</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">href: manifest.entry.module,</span><span class="s2">\n    </span><span class="s1">crossOrigin: props.crossOrigin,</span><span class="s2">\n    </span><span class="s1">integrity: sri[manifest.entry.module],</span><span class="s2">\n    </span><span class="s1">suppressHydrationWarning: true</span><span class="s2">\n  </span><span class="s1">}), preloads.map(path =&gt; /* @__PURE__ */React9.createElement(</span><span class="s2">\&quot;</span><span class="s1">link</span><span class="s2">\&quot;</span><span class="s1">, {</span><span class="s2">\n    </span><span class="s1">key: path,</span><span class="s2">\n    </span><span class="s1">rel: </span><span class="s2">\&quot;</span><span class="s1">modulepreload</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">href: path,</span><span class="s2">\n    </span><span class="s1">crossOrigin: props.crossOrigin,</span><span class="s2">\n    </span><span class="s1">integrity: sri[path],</span><span class="s2">\n    </span><span class="s1">suppressHydrationWarning: true</span><span class="s2">\n  </span><span class="s1">})), initialScripts);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function dedupe(array) {</span><span class="s2">\n  </span><span class="s1">return [...new Set(array)];</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function mergeRefs(...refs) {</span><span class="s2">\n  </span><span class="s1">return value =&gt; {</span><span class="s2">\n    </span><span class="s1">refs.forEach(ref =&gt; {</span><span class="s2">\n      </span><span class="s1">if (typeof ref === </span><span class="s2">\&quot;</span><span class="s1">function</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">ref(value);</span><span class="s2">\n      </span><span class="s1">} else if (ref != null) {</span><span class="s2">\n        </span><span class="s1">ref.current = value;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/dom/lib.tsx</span><span class="s2">\n</span><span class="s1">var isBrowser = typeof window !== </span><span class="s2">\&quot;</span><span class="s1">undefined</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; typeof window.document !== </span><span class="s2">\&quot;</span><span class="s1">undefined</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; typeof window.document.createElement !== </span><span class="s2">\&quot;</span><span class="s1">undefined</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">try {</span><span class="s2">\n  </span><span class="s1">if (isBrowser) {</span><span class="s2">\n    </span><span class="s1">window.__reactRouterVersion = </span><span class="s2">\&quot;</span><span class="s1">7.6.0</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">} catch (e) {}</span><span class="s2">\n</span><span class="s1">function createBrowserRouter(routes, opts) {</span><span class="s2">\n  </span><span class="s1">return createRouter({</span><span class="s2">\n    </span><span class="s1">basename: opts?.basename,</span><span class="s2">\n    </span><span class="s1">unstable_getContext: opts?.unstable_getContext,</span><span class="s2">\n    </span><span class="s1">future: opts?.future,</span><span class="s2">\n    </span><span class="s1">history: createBrowserHistory({</span><span class="s2">\n      </span><span class="s1">window: opts?.window</span><span class="s2">\n    </span><span class="s1">}),</span><span class="s2">\n    </span><span class="s1">hydrationData: opts?.hydrationData || parseHydrationData(),</span><span class="s2">\n    </span><span class="s1">routes,</span><span class="s2">\n    </span><span class="s1">mapRouteProperties,</span><span class="s2">\n    </span><span class="s1">hydrationRouteProperties,</span><span class="s2">\n    </span><span class="s1">dataStrategy: opts?.dataStrategy,</span><span class="s2">\n    </span><span class="s1">patchRoutesOnNavigation: opts?.patchRoutesOnNavigation,</span><span class="s2">\n    </span><span class="s1">window: opts?.window</span><span class="s2">\n  </span><span class="s1">}).initialize();</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createHashRouter(routes, opts) {</span><span class="s2">\n  </span><span class="s1">return createRouter({</span><span class="s2">\n    </span><span class="s1">basename: opts?.basename,</span><span class="s2">\n    </span><span class="s1">unstable_getContext: opts?.unstable_getContext,</span><span class="s2">\n    </span><span class="s1">future: opts?.future,</span><span class="s2">\n    </span><span class="s1">history: createHashHistory({</span><span class="s2">\n      </span><span class="s1">window: opts?.window</span><span class="s2">\n    </span><span class="s1">}),</span><span class="s2">\n    </span><span class="s1">hydrationData: opts?.hydrationData || parseHydrationData(),</span><span class="s2">\n    </span><span class="s1">routes,</span><span class="s2">\n    </span><span class="s1">mapRouteProperties,</span><span class="s2">\n    </span><span class="s1">hydrationRouteProperties,</span><span class="s2">\n    </span><span class="s1">dataStrategy: opts?.dataStrategy,</span><span class="s2">\n    </span><span class="s1">patchRoutesOnNavigation: opts?.patchRoutesOnNavigation,</span><span class="s2">\n    </span><span class="s1">window: opts?.window</span><span class="s2">\n  </span><span class="s1">}).initialize();</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function parseHydrationData() {</span><span class="s2">\n  </span><span class="s1">let state = window?.__staticRouterHydrationData;</span><span class="s2">\n  </span><span class="s1">if (state &amp;&amp; state.errors) {</span><span class="s2">\n    </span><span class="s1">state = {</span><span class="s2">\n      </span><span class="s1">...state,</span><span class="s2">\n      </span><span class="s1">errors: deserializeErrors(state.errors)</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return state;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function deserializeErrors(errors) {</span><span class="s2">\n  </span><span class="s1">if (!errors) return null;</span><span class="s2">\n  </span><span class="s1">let entries = Object.entries(errors);</span><span class="s2">\n  </span><span class="s1">let serialized = {};</span><span class="s2">\n  </span><span class="s1">for (let [key, val] of entries) {</span><span class="s2">\n    </span><span class="s1">if (val &amp;&amp; val.__type === </span><span class="s2">\&quot;</span><span class="s1">RouteErrorResponse</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">serialized[key] = new ErrorResponseImpl(val.status, val.statusText, val.data, val.internal === true);</span><span class="s2">\n    </span><span class="s1">} else if (val &amp;&amp; val.__type === </span><span class="s2">\&quot;</span><span class="s1">Error</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">if (val.__subType) {</span><span class="s2">\n        </span><span class="s1">let ErrorConstructor = window[val.__subType];</span><span class="s2">\n        </span><span class="s1">if (typeof ErrorConstructor === </span><span class="s2">\&quot;</span><span class="s1">function</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">try {</span><span class="s2">\n            </span><span class="s1">let error = new ErrorConstructor(val.message);</span><span class="s2">\n            </span><span class="s1">error.stack = </span><span class="s2">\&quot;\&quot;</span><span class="s1">;</span><span class="s2">\n            </span><span class="s1">serialized[key] = error;</span><span class="s2">\n          </span><span class="s1">} catch (e) {}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (serialized[key] == null) {</span><span class="s2">\n        </span><span class="s1">let error = new Error(val.message);</span><span class="s2">\n        </span><span class="s1">error.stack = </span><span class="s2">\&quot;\&quot;</span><span class="s1">;</span><span class="s2">\n        </span><span class="s1">serialized[key] = error;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">serialized[key] = val;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return serialized;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function BrowserRouter({</span><span class="s2">\n  </span><span class="s1">basename,</span><span class="s2">\n  </span><span class="s1">children,</span><span class="s2">\n  </span><span class="s1">window: window2</span><span class="s2">\n</span><span class="s1">}) {</span><span class="s2">\n  </span><span class="s1">let historyRef = React10.useRef();</span><span class="s2">\n  </span><span class="s1">if (historyRef.current == null) {</span><span class="s2">\n    </span><span class="s1">historyRef.current = createBrowserHistory({</span><span class="s2">\n      </span><span class="s1">window: window2,</span><span class="s2">\n      </span><span class="s1">v5Compat: true</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let history = historyRef.current;</span><span class="s2">\n  </span><span class="s1">let [state, setStateImpl] = React10.useState({</span><span class="s2">\n    </span><span class="s1">action: history.action,</span><span class="s2">\n    </span><span class="s1">location: history.location</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">let setState = React10.useCallback(newState =&gt; {</span><span class="s2">\n    </span><span class="s1">React10.startTransition(() =&gt; setStateImpl(newState));</span><span class="s2">\n  </span><span class="s1">}, [setStateImpl]);</span><span class="s2">\n  </span><span class="s1">React10.useLayoutEffect(() =&gt; history.listen(setState), [history, setState]);</span><span class="s2">\n  </span><span class="s1">return /* @__PURE__ */React10.createElement(Router, {</span><span class="s2">\n    </span><span class="s1">basename,</span><span class="s2">\n    </span><span class="s1">children,</span><span class="s2">\n    </span><span class="s1">location: state.location,</span><span class="s2">\n    </span><span class="s1">navigationType: state.action,</span><span class="s2">\n    </span><span class="s1">navigator: history</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function HashRouter({</span><span class="s2">\n  </span><span class="s1">basename,</span><span class="s2">\n  </span><span class="s1">children,</span><span class="s2">\n  </span><span class="s1">window: window2</span><span class="s2">\n</span><span class="s1">}) {</span><span class="s2">\n  </span><span class="s1">let historyRef = React10.useRef();</span><span class="s2">\n  </span><span class="s1">if (historyRef.current == null) {</span><span class="s2">\n    </span><span class="s1">historyRef.current = createHashHistory({</span><span class="s2">\n      </span><span class="s1">window: window2,</span><span class="s2">\n      </span><span class="s1">v5Compat: true</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let history = historyRef.current;</span><span class="s2">\n  </span><span class="s1">let [state, setStateImpl] = React10.useState({</span><span class="s2">\n    </span><span class="s1">action: history.action,</span><span class="s2">\n    </span><span class="s1">location: history.location</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">let setState = React10.useCallback(newState =&gt; {</span><span class="s2">\n    </span><span class="s1">React10.startTransition(() =&gt; setStateImpl(newState));</span><span class="s2">\n  </span><span class="s1">}, [setStateImpl]);</span><span class="s2">\n  </span><span class="s1">React10.useLayoutEffect(() =&gt; history.listen(setState), [history, setState]);</span><span class="s2">\n  </span><span class="s1">return /* @__PURE__ */React10.createElement(Router, {</span><span class="s2">\n    </span><span class="s1">basename,</span><span class="s2">\n    </span><span class="s1">children,</span><span class="s2">\n    </span><span class="s1">location: state.location,</span><span class="s2">\n    </span><span class="s1">navigationType: state.action,</span><span class="s2">\n    </span><span class="s1">navigator: history</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function HistoryRouter({</span><span class="s2">\n  </span><span class="s1">basename,</span><span class="s2">\n  </span><span class="s1">children,</span><span class="s2">\n  </span><span class="s1">history</span><span class="s2">\n</span><span class="s1">}) {</span><span class="s2">\n  </span><span class="s1">let [state, setStateImpl] = React10.useState({</span><span class="s2">\n    </span><span class="s1">action: history.action,</span><span class="s2">\n    </span><span class="s1">location: history.location</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">let setState = React10.useCallback(newState =&gt; {</span><span class="s2">\n    </span><span class="s1">React10.startTransition(() =&gt; setStateImpl(newState));</span><span class="s2">\n  </span><span class="s1">}, [setStateImpl]);</span><span class="s2">\n  </span><span class="s1">React10.useLayoutEffect(() =&gt; history.listen(setState), [history, setState]);</span><span class="s2">\n  </span><span class="s1">return /* @__PURE__ */React10.createElement(Router, {</span><span class="s2">\n    </span><span class="s1">basename,</span><span class="s2">\n    </span><span class="s1">children,</span><span class="s2">\n    </span><span class="s1">location: state.location,</span><span class="s2">\n    </span><span class="s1">navigationType: state.action,</span><span class="s2">\n    </span><span class="s1">navigator: history</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">HistoryRouter.displayName = </span><span class="s2">\&quot;</span><span class="s1">unstable_HistoryRouter</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">var ABSOLUTE_URL_REGEX2 = /^(?:[a-z][a-z0-9+.-]*:|</span><span class="s2">\\</span><span class="s1">/</span><span class="s2">\\</span><span class="s1">/)/i;</span><span class="s2">\n</span><span class="s1">var Link = React10.forwardRef(function LinkWithRef({</span><span class="s2">\n  </span><span class="s1">onClick,</span><span class="s2">\n  </span><span class="s1">discover = </span><span class="s2">\&quot;</span><span class="s1">render</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">prefetch = </span><span class="s2">\&quot;</span><span class="s1">none</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">relative,</span><span class="s2">\n  </span><span class="s1">reloadDocument,</span><span class="s2">\n  </span><span class="s1">replace: replace2,</span><span class="s2">\n  </span><span class="s1">state,</span><span class="s2">\n  </span><span class="s1">target,</span><span class="s2">\n  </span><span class="s1">to,</span><span class="s2">\n  </span><span class="s1">preventScrollReset,</span><span class="s2">\n  </span><span class="s1">viewTransition,</span><span class="s2">\n  </span><span class="s1">...rest</span><span class="s2">\n</span><span class="s1">}, forwardedRef) {</span><span class="s2">\n  </span><span class="s1">let {</span><span class="s2">\n    </span><span class="s1">basename</span><span class="s2">\n  </span><span class="s1">} = React10.useContext(NavigationContext);</span><span class="s2">\n  </span><span class="s1">let isAbsolute = typeof to === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; ABSOLUTE_URL_REGEX2.test(to);</span><span class="s2">\n  </span><span class="s1">let absoluteHref;</span><span class="s2">\n  </span><span class="s1">let isExternal = false;</span><span class="s2">\n  </span><span class="s1">if (typeof to === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; isAbsolute) {</span><span class="s2">\n    </span><span class="s1">absoluteHref = to;</span><span class="s2">\n    </span><span class="s1">if (isBrowser) {</span><span class="s2">\n      </span><span class="s1">try {</span><span class="s2">\n        </span><span class="s1">let currentUrl = new URL(window.location.href);</span><span class="s2">\n        </span><span class="s1">let targetUrl = to.startsWith(</span><span class="s2">\&quot;</span><span class="s1">//</span><span class="s2">\&quot;</span><span class="s1">) ? new URL(currentUrl.protocol + to) : new URL(to);</span><span class="s2">\n        </span><span class="s1">let path = stripBasename(targetUrl.pathname, basename);</span><span class="s2">\n        </span><span class="s1">if (targetUrl.origin === currentUrl.origin &amp;&amp; path != null) {</span><span class="s2">\n          </span><span class="s1">to = path + targetUrl.search + targetUrl.hash;</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">isExternal = true;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">} catch (e) {</span><span class="s2">\n        </span><span class="s1">warning(false, `&lt;Link to=</span><span class="s2">\&quot;</span><span class="s1">${to}</span><span class="s2">\&quot;</span><span class="s1">&gt; contains an invalid URL which will probably break when clicked - please update to a valid URL path.`);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let href2 = useHref(to, {</span><span class="s2">\n    </span><span class="s1">relative</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">let [shouldPrefetch, prefetchRef, prefetchHandlers] = usePrefetchBehavior(prefetch, rest);</span><span class="s2">\n  </span><span class="s1">let internalOnClick = useLinkClickHandler(to, {</span><span class="s2">\n    </span><span class="s1">replace: replace2,</span><span class="s2">\n    </span><span class="s1">state,</span><span class="s2">\n    </span><span class="s1">target,</span><span class="s2">\n    </span><span class="s1">preventScrollReset,</span><span class="s2">\n    </span><span class="s1">relative,</span><span class="s2">\n    </span><span class="s1">viewTransition</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">function handleClick(event) {</span><span class="s2">\n    </span><span class="s1">if (onClick) onClick(event);</span><span class="s2">\n    </span><span class="s1">if (!event.defaultPrevented) {</span><span class="s2">\n      </span><span class="s1">internalOnClick(event);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let link =</span><span class="s2">\n  </span><span class="s1">// eslint-disable-next-line jsx-a11y/anchor-has-content</span><span class="s2">\n  </span><span class="s1">/* @__PURE__ */</span><span class="s2">\n  </span><span class="s1">React10.createElement(</span><span class="s2">\&quot;</span><span class="s1">a</span><span class="s2">\&quot;</span><span class="s1">, {</span><span class="s2">\n    </span><span class="s1">...rest,</span><span class="s2">\n    </span><span class="s1">...prefetchHandlers,</span><span class="s2">\n    </span><span class="s1">href: absoluteHref || href2,</span><span class="s2">\n    </span><span class="s1">onClick: isExternal || reloadDocument ? onClick : handleClick,</span><span class="s2">\n    </span><span class="s1">ref: mergeRefs(forwardedRef, prefetchRef),</span><span class="s2">\n    </span><span class="s1">target,</span><span class="s2">\n    \&quot;</span><span class="s1">data-discover</span><span class="s2">\&quot;</span><span class="s1">: !isAbsolute &amp;&amp; discover === </span><span class="s2">\&quot;</span><span class="s1">render</span><span class="s2">\&quot; </span><span class="s1">? </span><span class="s2">\&quot;</span><span class="s1">true</span><span class="s2">\&quot; </span><span class="s1">: void 0</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">return shouldPrefetch &amp;&amp; !isAbsolute ? /* @__PURE__ */React10.createElement(React10.Fragment, null, link, /* @__PURE__ */React10.createElement(PrefetchPageLinks, {</span><span class="s2">\n    </span><span class="s1">page: href2</span><span class="s2">\n  </span><span class="s1">})) : link;</span><span class="s2">\n</span><span class="s1">});</span><span class="s2">\n</span><span class="s1">Link.displayName = </span><span class="s2">\&quot;</span><span class="s1">Link</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">var NavLink = React10.forwardRef(function NavLinkWithRef({</span><span class="s2">\n  \&quot;</span><span class="s1">aria-current</span><span class="s2">\&quot;</span><span class="s1">: ariaCurrentProp = </span><span class="s2">\&quot;</span><span class="s1">page</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">caseSensitive = false,</span><span class="s2">\n  </span><span class="s1">className: classNameProp = </span><span class="s2">\&quot;\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">end = false,</span><span class="s2">\n  </span><span class="s1">style: styleProp,</span><span class="s2">\n  </span><span class="s1">to,</span><span class="s2">\n  </span><span class="s1">viewTransition,</span><span class="s2">\n  </span><span class="s1">children,</span><span class="s2">\n  </span><span class="s1">...rest</span><span class="s2">\n</span><span class="s1">}, ref) {</span><span class="s2">\n  </span><span class="s1">let path = useResolvedPath(to, {</span><span class="s2">\n    </span><span class="s1">relative: rest.relative</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">let location = useLocation();</span><span class="s2">\n  </span><span class="s1">let routerState = React10.useContext(DataRouterStateContext);</span><span class="s2">\n  </span><span class="s1">let {</span><span class="s2">\n    </span><span class="s1">navigator,</span><span class="s2">\n    </span><span class="s1">basename</span><span class="s2">\n  </span><span class="s1">} = React10.useContext(NavigationContext);</span><span class="s2">\n  </span><span class="s1">let isTransitioning = routerState != null &amp;&amp;</span><span class="s2">\n  </span><span class="s1">// Conditional usage is OK here because the usage of a data router is static</span><span class="s2">\n  </span><span class="s1">// eslint-disable-next-line react-hooks/rules-of-hooks</span><span class="s2">\n  </span><span class="s1">useViewTransitionState(path) &amp;&amp; viewTransition === true;</span><span class="s2">\n  </span><span class="s1">let toPathname = navigator.encodeLocation ? navigator.encodeLocation(path).pathname : path.pathname;</span><span class="s2">\n  </span><span class="s1">let locationPathname = location.pathname;</span><span class="s2">\n  </span><span class="s1">let nextLocationPathname = routerState &amp;&amp; routerState.navigation &amp;&amp; routerState.navigation.location ? routerState.navigation.location.pathname : null;</span><span class="s2">\n  </span><span class="s1">if (!caseSensitive) {</span><span class="s2">\n    </span><span class="s1">locationPathname = locationPathname.toLowerCase();</span><span class="s2">\n    </span><span class="s1">nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;</span><span class="s2">\n    </span><span class="s1">toPathname = toPathname.toLowerCase();</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (nextLocationPathname &amp;&amp; basename) {</span><span class="s2">\n    </span><span class="s1">nextLocationPathname = stripBasename(nextLocationPathname, basename) || nextLocationPathname;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">const endSlashPosition = toPathname !== </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; toPathname.endsWith(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">) ? toPathname.length - 1 : toPathname.length;</span><span class="s2">\n  </span><span class="s1">let isActive = locationPathname === toPathname || !end &amp;&amp; locationPathname.startsWith(toPathname) &amp;&amp; locationPathname.charAt(endSlashPosition) === </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">let isPending = nextLocationPathname != null &amp;&amp; (nextLocationPathname === toPathname || !end &amp;&amp; nextLocationPathname.startsWith(toPathname) &amp;&amp; nextLocationPathname.charAt(toPathname.length) === </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let renderProps = {</span><span class="s2">\n    </span><span class="s1">isActive,</span><span class="s2">\n    </span><span class="s1">isPending,</span><span class="s2">\n    </span><span class="s1">isTransitioning</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">let ariaCurrent = isActive ? ariaCurrentProp : void 0;</span><span class="s2">\n  </span><span class="s1">let className;</span><span class="s2">\n  </span><span class="s1">if (typeof classNameProp === </span><span class="s2">\&quot;</span><span class="s1">function</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">className = classNameProp(renderProps);</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">className = [classNameProp, isActive ? </span><span class="s2">\&quot;</span><span class="s1">active</span><span class="s2">\&quot; </span><span class="s1">: null, isPending ? </span><span class="s2">\&quot;</span><span class="s1">pending</span><span class="s2">\&quot; </span><span class="s1">: null, isTransitioning ? </span><span class="s2">\&quot;</span><span class="s1">transitioning</span><span class="s2">\&quot; </span><span class="s1">: null].filter(Boolean).join(</span><span class="s2">\&quot; \&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let style = typeof styleProp === </span><span class="s2">\&quot;</span><span class="s1">function</span><span class="s2">\&quot; </span><span class="s1">? styleProp(renderProps) : styleProp;</span><span class="s2">\n  </span><span class="s1">return /* @__PURE__ */React10.createElement(Link, {</span><span class="s2">\n    </span><span class="s1">...rest,</span><span class="s2">\n    \&quot;</span><span class="s1">aria-current</span><span class="s2">\&quot;</span><span class="s1">: ariaCurrent,</span><span class="s2">\n    </span><span class="s1">className,</span><span class="s2">\n    </span><span class="s1">ref,</span><span class="s2">\n    </span><span class="s1">style,</span><span class="s2">\n    </span><span class="s1">to,</span><span class="s2">\n    </span><span class="s1">viewTransition</span><span class="s2">\n  </span><span class="s1">}, typeof children === </span><span class="s2">\&quot;</span><span class="s1">function</span><span class="s2">\&quot; </span><span class="s1">? children(renderProps) : children);</span><span class="s2">\n</span><span class="s1">});</span><span class="s2">\n</span><span class="s1">NavLink.displayName = </span><span class="s2">\&quot;</span><span class="s1">NavLink</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">var Form = React10.forwardRef(({</span><span class="s2">\n  </span><span class="s1">discover = </span><span class="s2">\&quot;</span><span class="s1">render</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">fetcherKey,</span><span class="s2">\n  </span><span class="s1">navigate,</span><span class="s2">\n  </span><span class="s1">reloadDocument,</span><span class="s2">\n  </span><span class="s1">replace: replace2,</span><span class="s2">\n  </span><span class="s1">state,</span><span class="s2">\n  </span><span class="s1">method = defaultMethod,</span><span class="s2">\n  </span><span class="s1">action,</span><span class="s2">\n  </span><span class="s1">onSubmit,</span><span class="s2">\n  </span><span class="s1">relative,</span><span class="s2">\n  </span><span class="s1">preventScrollReset,</span><span class="s2">\n  </span><span class="s1">viewTransition,</span><span class="s2">\n  </span><span class="s1">...props</span><span class="s2">\n</span><span class="s1">}, forwardedRef) =&gt; {</span><span class="s2">\n  </span><span class="s1">let submit = useSubmit();</span><span class="s2">\n  </span><span class="s1">let formAction = useFormAction(action, {</span><span class="s2">\n    </span><span class="s1">relative</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">let formMethod = method.toLowerCase() === </span><span class="s2">\&quot;</span><span class="s1">get</span><span class="s2">\&quot; </span><span class="s1">? </span><span class="s2">\&quot;</span><span class="s1">get</span><span class="s2">\&quot; </span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">post</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">let isAbsolute = typeof action === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; ABSOLUTE_URL_REGEX2.test(action);</span><span class="s2">\n  </span><span class="s1">let submitHandler = event =&gt; {</span><span class="s2">\n    </span><span class="s1">onSubmit &amp;&amp; onSubmit(event);</span><span class="s2">\n    </span><span class="s1">if (event.defaultPrevented) return;</span><span class="s2">\n    </span><span class="s1">event.preventDefault();</span><span class="s2">\n    </span><span class="s1">let submitter = event.nativeEvent.submitter;</span><span class="s2">\n    </span><span class="s1">let submitMethod = submitter?.getAttribute(</span><span class="s2">\&quot;</span><span class="s1">formmethod</span><span class="s2">\&quot;</span><span class="s1">) || method;</span><span class="s2">\n    </span><span class="s1">submit(submitter || event.currentTarget, {</span><span class="s2">\n      </span><span class="s1">fetcherKey,</span><span class="s2">\n      </span><span class="s1">method: submitMethod,</span><span class="s2">\n      </span><span class="s1">navigate,</span><span class="s2">\n      </span><span class="s1">replace: replace2,</span><span class="s2">\n      </span><span class="s1">state,</span><span class="s2">\n      </span><span class="s1">relative,</span><span class="s2">\n      </span><span class="s1">preventScrollReset,</span><span class="s2">\n      </span><span class="s1">viewTransition</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">return /* @__PURE__ */React10.createElement(</span><span class="s2">\&quot;</span><span class="s1">form</span><span class="s2">\&quot;</span><span class="s1">, {</span><span class="s2">\n    </span><span class="s1">ref: forwardedRef,</span><span class="s2">\n    </span><span class="s1">method: formMethod,</span><span class="s2">\n    </span><span class="s1">action: formAction,</span><span class="s2">\n    </span><span class="s1">onSubmit: reloadDocument ? onSubmit : submitHandler,</span><span class="s2">\n    </span><span class="s1">...props,</span><span class="s2">\n    \&quot;</span><span class="s1">data-discover</span><span class="s2">\&quot;</span><span class="s1">: !isAbsolute &amp;&amp; discover === </span><span class="s2">\&quot;</span><span class="s1">render</span><span class="s2">\&quot; </span><span class="s1">? </span><span class="s2">\&quot;</span><span class="s1">true</span><span class="s2">\&quot; </span><span class="s1">: void 0</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">});</span><span class="s2">\n</span><span class="s1">Form.displayName = </span><span class="s2">\&quot;</span><span class="s1">Form</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">function ScrollRestoration({</span><span class="s2">\n  </span><span class="s1">getKey,</span><span class="s2">\n  </span><span class="s1">storageKey,</span><span class="s2">\n  </span><span class="s1">...props</span><span class="s2">\n</span><span class="s1">}) {</span><span class="s2">\n  </span><span class="s1">let remixContext = React10.useContext(FrameworkContext);</span><span class="s2">\n  </span><span class="s1">let {</span><span class="s2">\n    </span><span class="s1">basename</span><span class="s2">\n  </span><span class="s1">} = React10.useContext(NavigationContext);</span><span class="s2">\n  </span><span class="s1">let location = useLocation();</span><span class="s2">\n  </span><span class="s1">let matches = useMatches();</span><span class="s2">\n  </span><span class="s1">useScrollRestoration({</span><span class="s2">\n    </span><span class="s1">getKey,</span><span class="s2">\n    </span><span class="s1">storageKey</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">let ssrKey = React10.useMemo(() =&gt; {</span><span class="s2">\n    </span><span class="s1">if (!remixContext || !getKey) return null;</span><span class="s2">\n    </span><span class="s1">let userKey = getScrollRestorationKey(location, matches, basename, getKey);</span><span class="s2">\n    </span><span class="s1">return userKey !== location.key ? userKey : null;</span><span class="s2">\n  </span><span class="s1">},</span><span class="s2">\n  </span><span class="s1">// Nah, we only need this the first time for the SSR render</span><span class="s2">\n  </span><span class="s1">// eslint-disable-next-line react-hooks/exhaustive-deps</span><span class="s2">\n  </span><span class="s1">[]);</span><span class="s2">\n  </span><span class="s1">if (!remixContext || remixContext.isSpaMode) {</span><span class="s2">\n    </span><span class="s1">return null;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let restoreScroll = ((storageKey2, restoreKey) =&gt; {</span><span class="s2">\n    </span><span class="s1">if (!window.history.state || !window.history.state.key) {</span><span class="s2">\n      </span><span class="s1">let key = Math.random().toString(32).slice(2);</span><span class="s2">\n      </span><span class="s1">window.history.replaceState({</span><span class="s2">\n        </span><span class="s1">key</span><span class="s2">\n      </span><span class="s1">}, </span><span class="s2">\&quot;\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">try {</span><span class="s2">\n      </span><span class="s1">let positions = JSON.parse(sessionStorage.getItem(storageKey2) || </span><span class="s2">\&quot;</span><span class="s1">{}</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">let storedY = positions[restoreKey || window.history.state.key];</span><span class="s2">\n      </span><span class="s1">if (typeof storedY === </span><span class="s2">\&quot;</span><span class="s1">number</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">window.scrollTo(0, storedY);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} catch (error) {</span><span class="s2">\n      </span><span class="s1">console.error(error);</span><span class="s2">\n      </span><span class="s1">sessionStorage.removeItem(storageKey2);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}).toString();</span><span class="s2">\n  </span><span class="s1">return /* @__PURE__ */React10.createElement(</span><span class="s2">\&quot;</span><span class="s1">script</span><span class="s2">\&quot;</span><span class="s1">, {</span><span class="s2">\n    </span><span class="s1">...props,</span><span class="s2">\n    </span><span class="s1">suppressHydrationWarning: true,</span><span class="s2">\n    </span><span class="s1">dangerouslySetInnerHTML: {</span><span class="s2">\n      </span><span class="s1">__html: `(${restoreScroll})(${JSON.stringify(storageKey || SCROLL_RESTORATION_STORAGE_KEY)}, ${JSON.stringify(ssrKey)})`</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">ScrollRestoration.displayName = </span><span class="s2">\&quot;</span><span class="s1">ScrollRestoration</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">function getDataRouterConsoleError2(hookName) {</span><span class="s2">\n  </span><span class="s1">return `${hookName} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useDataRouterContext3(hookName) {</span><span class="s2">\n  </span><span class="s1">let ctx = React10.useContext(DataRouterContext);</span><span class="s2">\n  </span><span class="s1">invariant(ctx, getDataRouterConsoleError2(hookName));</span><span class="s2">\n  </span><span class="s1">return ctx;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useDataRouterState2(hookName) {</span><span class="s2">\n  </span><span class="s1">let state = React10.useContext(DataRouterStateContext);</span><span class="s2">\n  </span><span class="s1">invariant(state, getDataRouterConsoleError2(hookName));</span><span class="s2">\n  </span><span class="s1">return state;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useLinkClickHandler(to, {</span><span class="s2">\n  </span><span class="s1">target,</span><span class="s2">\n  </span><span class="s1">replace: replaceProp,</span><span class="s2">\n  </span><span class="s1">state,</span><span class="s2">\n  </span><span class="s1">preventScrollReset,</span><span class="s2">\n  </span><span class="s1">relative,</span><span class="s2">\n  </span><span class="s1">viewTransition</span><span class="s2">\n</span><span class="s1">} = {}) {</span><span class="s2">\n  </span><span class="s1">let navigate = useNavigate();</span><span class="s2">\n  </span><span class="s1">let location = useLocation();</span><span class="s2">\n  </span><span class="s1">let path = useResolvedPath(to, {</span><span class="s2">\n    </span><span class="s1">relative</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">return React10.useCallback(event =&gt; {</span><span class="s2">\n    </span><span class="s1">if (shouldProcessLinkClick(event, target)) {</span><span class="s2">\n      </span><span class="s1">event.preventDefault();</span><span class="s2">\n      </span><span class="s1">let replace2 = replaceProp !== void 0 ? replaceProp : createPath(location) === createPath(path);</span><span class="s2">\n      </span><span class="s1">navigate(to, {</span><span class="s2">\n        </span><span class="s1">replace: replace2,</span><span class="s2">\n        </span><span class="s1">state,</span><span class="s2">\n        </span><span class="s1">preventScrollReset,</span><span class="s2">\n        </span><span class="s1">relative,</span><span class="s2">\n        </span><span class="s1">viewTransition</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}, [location, navigate, path, replaceProp, state, target, to, preventScrollReset, relative, viewTransition]);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useSearchParams(defaultInit) {</span><span class="s2">\n  </span><span class="s1">warning(typeof URLSearchParams !== </span><span class="s2">\&quot;</span><span class="s1">undefined</span><span class="s2">\&quot;</span><span class="s1">, `You cannot use the </span><span class="s2">\\</span><span class="s1">`useSearchParams</span><span class="s2">\\</span><span class="s1">` hook in a browser that does not support the URLSearchParams API. If you need to support Internet Explorer 11, we recommend you load a polyfill such as https://github.com/ungap/url-search-params.`);</span><span class="s2">\n  </span><span class="s1">let defaultSearchParamsRef = React10.useRef(createSearchParams(defaultInit));</span><span class="s2">\n  </span><span class="s1">let hasSetSearchParamsRef = React10.useRef(false);</span><span class="s2">\n  </span><span class="s1">let location = useLocation();</span><span class="s2">\n  </span><span class="s1">let searchParams = React10.useMemo(() =&gt;</span><span class="s2">\n  </span><span class="s1">// Only merge in the defaults if we haven't yet called setSearchParams.</span><span class="s2">\n  </span><span class="s1">// Once we call that we want those to take precedence, otherwise you can't</span><span class="s2">\n  </span><span class="s1">// remove a param with setSearchParams({}) if it has an initial value</span><span class="s2">\n  </span><span class="s1">getSearchParamsForLocation(location.search, hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current), [location.search]);</span><span class="s2">\n  </span><span class="s1">let navigate = useNavigate();</span><span class="s2">\n  </span><span class="s1">let setSearchParams = React10.useCallback((nextInit, navigateOptions) =&gt; {</span><span class="s2">\n    </span><span class="s1">const newSearchParams = createSearchParams(typeof nextInit === </span><span class="s2">\&quot;</span><span class="s1">function</span><span class="s2">\&quot; </span><span class="s1">? nextInit(searchParams) : nextInit);</span><span class="s2">\n    </span><span class="s1">hasSetSearchParamsRef.current = true;</span><span class="s2">\n    </span><span class="s1">navigate(</span><span class="s2">\&quot;</span><span class="s1">?</span><span class="s2">\&quot; </span><span class="s1">+ newSearchParams, navigateOptions);</span><span class="s2">\n  </span><span class="s1">}, [navigate, searchParams]);</span><span class="s2">\n  </span><span class="s1">return [searchParams, setSearchParams];</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var fetcherId = 0;</span><span class="s2">\n</span><span class="s1">var getUniqueFetcherId = () =&gt; `__${String(++fetcherId)}__`;</span><span class="s2">\n</span><span class="s1">function useSubmit() {</span><span class="s2">\n  </span><span class="s1">let {</span><span class="s2">\n    </span><span class="s1">router</span><span class="s2">\n  </span><span class="s1">} = useDataRouterContext3(</span><span class="s2">\&quot;</span><span class="s1">useSubmit</span><span class="s2">\&quot; </span><span class="s1">/* UseSubmit */);</span><span class="s2">\n  </span><span class="s1">let {</span><span class="s2">\n    </span><span class="s1">basename</span><span class="s2">\n  </span><span class="s1">} = React10.useContext(NavigationContext);</span><span class="s2">\n  </span><span class="s1">let currentRouteId = useRouteId();</span><span class="s2">\n  </span><span class="s1">return React10.useCallback(async (target, options = {}) =&gt; {</span><span class="s2">\n    </span><span class="s1">let {</span><span class="s2">\n      </span><span class="s1">action,</span><span class="s2">\n      </span><span class="s1">method,</span><span class="s2">\n      </span><span class="s1">encType,</span><span class="s2">\n      </span><span class="s1">formData,</span><span class="s2">\n      </span><span class="s1">body</span><span class="s2">\n    </span><span class="s1">} = getFormSubmissionInfo(target, basename);</span><span class="s2">\n    </span><span class="s1">if (options.navigate === false) {</span><span class="s2">\n      </span><span class="s1">let key = options.fetcherKey || getUniqueFetcherId();</span><span class="s2">\n      </span><span class="s1">await router.fetch(key, currentRouteId, options.action || action, {</span><span class="s2">\n        </span><span class="s1">preventScrollReset: options.preventScrollReset,</span><span class="s2">\n        </span><span class="s1">formData,</span><span class="s2">\n        </span><span class="s1">body,</span><span class="s2">\n        </span><span class="s1">formMethod: options.method || method,</span><span class="s2">\n        </span><span class="s1">formEncType: options.encType || encType,</span><span class="s2">\n        </span><span class="s1">flushSync: options.flushSync</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">await router.navigate(options.action || action, {</span><span class="s2">\n        </span><span class="s1">preventScrollReset: options.preventScrollReset,</span><span class="s2">\n        </span><span class="s1">formData,</span><span class="s2">\n        </span><span class="s1">body,</span><span class="s2">\n        </span><span class="s1">formMethod: options.method || method,</span><span class="s2">\n        </span><span class="s1">formEncType: options.encType || encType,</span><span class="s2">\n        </span><span class="s1">replace: options.replace,</span><span class="s2">\n        </span><span class="s1">state: options.state,</span><span class="s2">\n        </span><span class="s1">fromRouteId: currentRouteId,</span><span class="s2">\n        </span><span class="s1">flushSync: options.flushSync,</span><span class="s2">\n        </span><span class="s1">viewTransition: options.viewTransition</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}, [router, basename, currentRouteId]);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useFormAction(action, {</span><span class="s2">\n  </span><span class="s1">relative</span><span class="s2">\n</span><span class="s1">} = {}) {</span><span class="s2">\n  </span><span class="s1">let {</span><span class="s2">\n    </span><span class="s1">basename</span><span class="s2">\n  </span><span class="s1">} = React10.useContext(NavigationContext);</span><span class="s2">\n  </span><span class="s1">let routeContext = React10.useContext(RouteContext);</span><span class="s2">\n  </span><span class="s1">invariant(routeContext, </span><span class="s2">\&quot;</span><span class="s1">useFormAction must be used inside a RouteContext</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let [match] = routeContext.matches.slice(-1);</span><span class="s2">\n  </span><span class="s1">let path = {</span><span class="s2">\n    </span><span class="s1">...useResolvedPath(action ? action : </span><span class="s2">\&quot;</span><span class="s1">.</span><span class="s2">\&quot;</span><span class="s1">, {</span><span class="s2">\n      </span><span class="s1">relative</span><span class="s2">\n    </span><span class="s1">})</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">let location = useLocation();</span><span class="s2">\n  </span><span class="s1">if (action == null) {</span><span class="s2">\n    </span><span class="s1">path.search = location.search;</span><span class="s2">\n    </span><span class="s1">let params = new URLSearchParams(path.search);</span><span class="s2">\n    </span><span class="s1">let indexValues = params.getAll(</span><span class="s2">\&quot;</span><span class="s1">index</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">let hasNakedIndexParam = indexValues.some(v =&gt; v === </span><span class="s2">\&quot;\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">if (hasNakedIndexParam) {</span><span class="s2">\n      </span><span class="s1">params.delete(</span><span class="s2">\&quot;</span><span class="s1">index</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">indexValues.filter(v =&gt; v).forEach(v =&gt; params.append(</span><span class="s2">\&quot;</span><span class="s1">index</span><span class="s2">\&quot;</span><span class="s1">, v));</span><span class="s2">\n      </span><span class="s1">let qs = params.toString();</span><span class="s2">\n      </span><span class="s1">path.search = qs ? `?${qs}` : </span><span class="s2">\&quot;\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if ((!action || action === </span><span class="s2">\&quot;</span><span class="s1">.</span><span class="s2">\&quot;</span><span class="s1">) &amp;&amp; match.route.index) {</span><span class="s2">\n    </span><span class="s1">path.search = path.search ? path.search.replace(/^</span><span class="s2">\\</span><span class="s1">?/, </span><span class="s2">\&quot;</span><span class="s1">?index&amp;</span><span class="s2">\&quot;</span><span class="s1">) : </span><span class="s2">\&quot;</span><span class="s1">?index</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (basename !== </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">path.pathname = path.pathname === </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot; </span><span class="s1">? basename : joinPaths([basename, path.pathname]);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return createPath(path);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useFetcher({</span><span class="s2">\n  </span><span class="s1">key</span><span class="s2">\n</span><span class="s1">} = {}) {</span><span class="s2">\n  </span><span class="s1">let {</span><span class="s2">\n    </span><span class="s1">router</span><span class="s2">\n  </span><span class="s1">} = useDataRouterContext3(</span><span class="s2">\&quot;</span><span class="s1">useFetcher</span><span class="s2">\&quot; </span><span class="s1">/* UseFetcher */);</span><span class="s2">\n  </span><span class="s1">let state = useDataRouterState2(</span><span class="s2">\&quot;</span><span class="s1">useFetcher</span><span class="s2">\&quot; </span><span class="s1">/* UseFetcher */);</span><span class="s2">\n  </span><span class="s1">let fetcherData = React10.useContext(FetchersContext);</span><span class="s2">\n  </span><span class="s1">let route = React10.useContext(RouteContext);</span><span class="s2">\n  </span><span class="s1">let routeId = route.matches[route.matches.length - 1]?.route.id;</span><span class="s2">\n  </span><span class="s1">invariant(fetcherData, `useFetcher must be used inside a FetchersContext`);</span><span class="s2">\n  </span><span class="s1">invariant(route, `useFetcher must be used inside a RouteContext`);</span><span class="s2">\n  </span><span class="s1">invariant(routeId != null, `useFetcher can only be used on routes that contain a unique </span><span class="s2">\&quot;</span><span class="s1">id</span><span class="s2">\&quot;</span><span class="s1">`);</span><span class="s2">\n  </span><span class="s1">let defaultKey = React10.useId();</span><span class="s2">\n  </span><span class="s1">let [fetcherKey, setFetcherKey] = React10.useState(key || defaultKey);</span><span class="s2">\n  </span><span class="s1">if (key &amp;&amp; key !== fetcherKey) {</span><span class="s2">\n    </span><span class="s1">setFetcherKey(key);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">React10.useEffect(() =&gt; {</span><span class="s2">\n    </span><span class="s1">router.getFetcher(fetcherKey);</span><span class="s2">\n    </span><span class="s1">return () =&gt; router.deleteFetcher(fetcherKey);</span><span class="s2">\n  </span><span class="s1">}, [router, fetcherKey]);</span><span class="s2">\n  </span><span class="s1">let load = React10.useCallback(async (href2, opts) =&gt; {</span><span class="s2">\n    </span><span class="s1">invariant(routeId, </span><span class="s2">\&quot;</span><span class="s1">No routeId available for fetcher.load()</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">await router.fetch(fetcherKey, routeId, href2, opts);</span><span class="s2">\n  </span><span class="s1">}, [fetcherKey, routeId, router]);</span><span class="s2">\n  </span><span class="s1">let submitImpl = useSubmit();</span><span class="s2">\n  </span><span class="s1">let submit = React10.useCallback(async (target, opts) =&gt; {</span><span class="s2">\n    </span><span class="s1">await submitImpl(target, {</span><span class="s2">\n      </span><span class="s1">...opts,</span><span class="s2">\n      </span><span class="s1">navigate: false,</span><span class="s2">\n      </span><span class="s1">fetcherKey</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}, [fetcherKey, submitImpl]);</span><span class="s2">\n  </span><span class="s1">let FetcherForm = React10.useMemo(() =&gt; {</span><span class="s2">\n    </span><span class="s1">let FetcherForm2 = React10.forwardRef((props, ref) =&gt; {</span><span class="s2">\n      </span><span class="s1">return /* @__PURE__ */React10.createElement(Form, {</span><span class="s2">\n        </span><span class="s1">...props,</span><span class="s2">\n        </span><span class="s1">navigate: false,</span><span class="s2">\n        </span><span class="s1">fetcherKey,</span><span class="s2">\n        </span><span class="s1">ref</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">FetcherForm2.displayName = </span><span class="s2">\&quot;</span><span class="s1">fetcher.Form</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">return FetcherForm2;</span><span class="s2">\n  </span><span class="s1">}, [fetcherKey]);</span><span class="s2">\n  </span><span class="s1">let fetcher = state.fetchers.get(fetcherKey) || IDLE_FETCHER;</span><span class="s2">\n  </span><span class="s1">let data2 = fetcherData.get(fetcherKey);</span><span class="s2">\n  </span><span class="s1">let fetcherWithComponents = React10.useMemo(() =&gt; ({</span><span class="s2">\n    </span><span class="s1">Form: FetcherForm,</span><span class="s2">\n    </span><span class="s1">submit,</span><span class="s2">\n    </span><span class="s1">load,</span><span class="s2">\n    </span><span class="s1">...fetcher,</span><span class="s2">\n    </span><span class="s1">data: data2</span><span class="s2">\n  </span><span class="s1">}), [FetcherForm, submit, load, fetcher, data2]);</span><span class="s2">\n  </span><span class="s1">return fetcherWithComponents;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useFetchers() {</span><span class="s2">\n  </span><span class="s1">let state = useDataRouterState2(</span><span class="s2">\&quot;</span><span class="s1">useFetchers</span><span class="s2">\&quot; </span><span class="s1">/* UseFetchers */);</span><span class="s2">\n  </span><span class="s1">return Array.from(state.fetchers.entries()).map(([key, fetcher]) =&gt; ({</span><span class="s2">\n    </span><span class="s1">...fetcher,</span><span class="s2">\n    </span><span class="s1">key</span><span class="s2">\n  </span><span class="s1">}));</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var SCROLL_RESTORATION_STORAGE_KEY = </span><span class="s2">\&quot;</span><span class="s1">react-router-scroll-positions</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">var savedScrollPositions = {};</span><span class="s2">\n</span><span class="s1">function getScrollRestorationKey(location, matches, basename, getKey) {</span><span class="s2">\n  </span><span class="s1">let key = null;</span><span class="s2">\n  </span><span class="s1">if (getKey) {</span><span class="s2">\n    </span><span class="s1">if (basename !== </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">key = getKey({</span><span class="s2">\n        </span><span class="s1">...location,</span><span class="s2">\n        </span><span class="s1">pathname: stripBasename(location.pathname, basename) || location.pathname</span><span class="s2">\n      </span><span class="s1">}, matches);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">key = getKey(location, matches);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (key == null) {</span><span class="s2">\n    </span><span class="s1">key = location.key;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return key;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useScrollRestoration({</span><span class="s2">\n  </span><span class="s1">getKey,</span><span class="s2">\n  </span><span class="s1">storageKey</span><span class="s2">\n</span><span class="s1">} = {}) {</span><span class="s2">\n  </span><span class="s1">let {</span><span class="s2">\n    </span><span class="s1">router</span><span class="s2">\n  </span><span class="s1">} = useDataRouterContext3(</span><span class="s2">\&quot;</span><span class="s1">useScrollRestoration</span><span class="s2">\&quot; </span><span class="s1">/* UseScrollRestoration */);</span><span class="s2">\n  </span><span class="s1">let {</span><span class="s2">\n    </span><span class="s1">restoreScrollPosition,</span><span class="s2">\n    </span><span class="s1">preventScrollReset</span><span class="s2">\n  </span><span class="s1">} = useDataRouterState2(</span><span class="s2">\&quot;</span><span class="s1">useScrollRestoration</span><span class="s2">\&quot; </span><span class="s1">/* UseScrollRestoration */);</span><span class="s2">\n  </span><span class="s1">let {</span><span class="s2">\n    </span><span class="s1">basename</span><span class="s2">\n  </span><span class="s1">} = React10.useContext(NavigationContext);</span><span class="s2">\n  </span><span class="s1">let location = useLocation();</span><span class="s2">\n  </span><span class="s1">let matches = useMatches();</span><span class="s2">\n  </span><span class="s1">let navigation = useNavigation();</span><span class="s2">\n  </span><span class="s1">React10.useEffect(() =&gt; {</span><span class="s2">\n    </span><span class="s1">window.history.scrollRestoration = </span><span class="s2">\&quot;</span><span class="s1">manual</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">return () =&gt; {</span><span class="s2">\n      </span><span class="s1">window.history.scrollRestoration = </span><span class="s2">\&quot;</span><span class="s1">auto</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}, []);</span><span class="s2">\n  </span><span class="s1">usePageHide(React10.useCallback(() =&gt; {</span><span class="s2">\n    </span><span class="s1">if (navigation.state === </span><span class="s2">\&quot;</span><span class="s1">idle</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">let key = getScrollRestorationKey(location, matches, basename, getKey);</span><span class="s2">\n      </span><span class="s1">savedScrollPositions[key] = window.scrollY;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">try {</span><span class="s2">\n      </span><span class="s1">sessionStorage.setItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY, JSON.stringify(savedScrollPositions));</span><span class="s2">\n    </span><span class="s1">} catch (error) {</span><span class="s2">\n      </span><span class="s1">warning(false, `Failed to save scroll positions in sessionStorage, &lt;ScrollRestoration /&gt; will not work properly (${error}).`);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">window.history.scrollRestoration = </span><span class="s2">\&quot;</span><span class="s1">auto</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">}, [navigation.state, getKey, basename, location, matches, storageKey]));</span><span class="s2">\n  </span><span class="s1">if (typeof document !== </span><span class="s2">\&quot;</span><span class="s1">undefined</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">React10.useLayoutEffect(() =&gt; {</span><span class="s2">\n      </span><span class="s1">try {</span><span class="s2">\n        </span><span class="s1">let sessionPositions = sessionStorage.getItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY);</span><span class="s2">\n        </span><span class="s1">if (sessionPositions) {</span><span class="s2">\n          </span><span class="s1">savedScrollPositions = JSON.parse(sessionPositions);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">} catch (e) {}</span><span class="s2">\n    </span><span class="s1">}, [storageKey]);</span><span class="s2">\n    </span><span class="s1">React10.useLayoutEffect(() =&gt; {</span><span class="s2">\n      </span><span class="s1">let disableScrollRestoration = router?.enableScrollRestoration(savedScrollPositions, () =&gt; window.scrollY, getKey ? (location2, matches2) =&gt; getScrollRestorationKey(location2, matches2, basename, getKey) : void 0);</span><span class="s2">\n      </span><span class="s1">return () =&gt; disableScrollRestoration &amp;&amp; disableScrollRestoration();</span><span class="s2">\n    </span><span class="s1">}, [router, basename, getKey]);</span><span class="s2">\n    </span><span class="s1">React10.useLayoutEffect(() =&gt; {</span><span class="s2">\n      </span><span class="s1">if (restoreScrollPosition === false) {</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (typeof restoreScrollPosition === </span><span class="s2">\&quot;</span><span class="s1">number</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">window.scrollTo(0, restoreScrollPosition);</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (location.hash) {</span><span class="s2">\n        </span><span class="s1">let el = document.getElementById(decodeURIComponent(location.hash.slice(1)));</span><span class="s2">\n        </span><span class="s1">if (el) {</span><span class="s2">\n          </span><span class="s1">el.scrollIntoView();</span><span class="s2">\n          </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (preventScrollReset === true) {</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">window.scrollTo(0, 0);</span><span class="s2">\n    </span><span class="s1">}, [location, restoreScrollPosition, preventScrollReset]);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useBeforeUnload(callback, options) {</span><span class="s2">\n  </span><span class="s1">let {</span><span class="s2">\n    </span><span class="s1">capture</span><span class="s2">\n  </span><span class="s1">} = options || {};</span><span class="s2">\n  </span><span class="s1">React10.useEffect(() =&gt; {</span><span class="s2">\n    </span><span class="s1">let opts = capture != null ? {</span><span class="s2">\n      </span><span class="s1">capture</span><span class="s2">\n    </span><span class="s1">} : void 0;</span><span class="s2">\n    </span><span class="s1">window.addEventListener(</span><span class="s2">\&quot;</span><span class="s1">beforeunload</span><span class="s2">\&quot;</span><span class="s1">, callback, opts);</span><span class="s2">\n    </span><span class="s1">return () =&gt; {</span><span class="s2">\n      </span><span class="s1">window.removeEventListener(</span><span class="s2">\&quot;</span><span class="s1">beforeunload</span><span class="s2">\&quot;</span><span class="s1">, callback, opts);</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}, [callback, capture]);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function usePageHide(callback, options) {</span><span class="s2">\n  </span><span class="s1">let {</span><span class="s2">\n    </span><span class="s1">capture</span><span class="s2">\n  </span><span class="s1">} = options || {};</span><span class="s2">\n  </span><span class="s1">React10.useEffect(() =&gt; {</span><span class="s2">\n    </span><span class="s1">let opts = capture != null ? {</span><span class="s2">\n      </span><span class="s1">capture</span><span class="s2">\n    </span><span class="s1">} : void 0;</span><span class="s2">\n    </span><span class="s1">window.addEventListener(</span><span class="s2">\&quot;</span><span class="s1">pagehide</span><span class="s2">\&quot;</span><span class="s1">, callback, opts);</span><span class="s2">\n    </span><span class="s1">return () =&gt; {</span><span class="s2">\n      </span><span class="s1">window.removeEventListener(</span><span class="s2">\&quot;</span><span class="s1">pagehide</span><span class="s2">\&quot;</span><span class="s1">, callback, opts);</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}, [callback, capture]);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function usePrompt({</span><span class="s2">\n  </span><span class="s1">when,</span><span class="s2">\n  </span><span class="s1">message</span><span class="s2">\n</span><span class="s1">}) {</span><span class="s2">\n  </span><span class="s1">let blocker = useBlocker(when);</span><span class="s2">\n  </span><span class="s1">React10.useEffect(() =&gt; {</span><span class="s2">\n    </span><span class="s1">if (blocker.state === </span><span class="s2">\&quot;</span><span class="s1">blocked</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">let proceed = window.confirm(message);</span><span class="s2">\n      </span><span class="s1">if (proceed) {</span><span class="s2">\n        </span><span class="s1">setTimeout(blocker.proceed, 0);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">blocker.reset();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}, [blocker, message]);</span><span class="s2">\n  </span><span class="s1">React10.useEffect(() =&gt; {</span><span class="s2">\n    </span><span class="s1">if (blocker.state === </span><span class="s2">\&quot;</span><span class="s1">blocked</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; !when) {</span><span class="s2">\n      </span><span class="s1">blocker.reset();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}, [blocker, when]);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useViewTransitionState(to, opts = {}) {</span><span class="s2">\n  </span><span class="s1">let vtContext = React10.useContext(ViewTransitionContext);</span><span class="s2">\n  </span><span class="s1">invariant(vtContext != null, </span><span class="s2">\&quot;</span><span class="s1">`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let {</span><span class="s2">\n    </span><span class="s1">basename</span><span class="s2">\n  </span><span class="s1">} = useDataRouterContext3(</span><span class="s2">\&quot;</span><span class="s1">useViewTransitionState</span><span class="s2">\&quot; </span><span class="s1">/* useViewTransitionState */);</span><span class="s2">\n  </span><span class="s1">let path = useResolvedPath(to, {</span><span class="s2">\n    </span><span class="s1">relative: opts.relative</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">if (!vtContext.isTransitioning) {</span><span class="s2">\n    </span><span class="s1">return false;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let currentPath = stripBasename(vtContext.currentLocation.pathname, basename) || vtContext.currentLocation.pathname;</span><span class="s2">\n  </span><span class="s1">let nextPath = stripBasename(vtContext.nextLocation.pathname, basename) || vtContext.nextLocation.pathname;</span><span class="s2">\n  </span><span class="s1">return matchPath(path.pathname, nextPath) != null || matchPath(path.pathname, currentPath) != null;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/dom/server.tsx</span><span class="s2">\n</span><span class="s1">import * as React11 from </span><span class="s2">\&quot;</span><span class="s1">react</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">function StaticRouter({</span><span class="s2">\n  </span><span class="s1">basename,</span><span class="s2">\n  </span><span class="s1">children,</span><span class="s2">\n  </span><span class="s1">location: locationProp = </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;\n</span><span class="s1">}) {</span><span class="s2">\n  </span><span class="s1">if (typeof locationProp === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">locationProp = parsePath(locationProp);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let action = </span><span class="s2">\&quot;</span><span class="s1">POP</span><span class="s2">\&quot; </span><span class="s1">/* Pop */;</span><span class="s2">\n  </span><span class="s1">let location = {</span><span class="s2">\n    </span><span class="s1">pathname: locationProp.pathname || </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">search: locationProp.search || </span><span class="s2">\&quot;\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">hash: locationProp.hash || </span><span class="s2">\&quot;\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">state: locationProp.state != null ? locationProp.state : null,</span><span class="s2">\n    </span><span class="s1">key: locationProp.key || </span><span class="s2">\&quot;</span><span class="s1">default</span><span class="s2">\&quot;\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">let staticNavigator = getStatelessNavigator();</span><span class="s2">\n  </span><span class="s1">return /* @__PURE__ */React11.createElement(Router, {</span><span class="s2">\n    </span><span class="s1">basename,</span><span class="s2">\n    </span><span class="s1">children,</span><span class="s2">\n    </span><span class="s1">location,</span><span class="s2">\n    </span><span class="s1">navigationType: action,</span><span class="s2">\n    </span><span class="s1">navigator: staticNavigator,</span><span class="s2">\n    </span><span class="s1">static: true</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function StaticRouterProvider({</span><span class="s2">\n  </span><span class="s1">context,</span><span class="s2">\n  </span><span class="s1">router,</span><span class="s2">\n  </span><span class="s1">hydrate: hydrate2 = true,</span><span class="s2">\n  </span><span class="s1">nonce</span><span class="s2">\n</span><span class="s1">}) {</span><span class="s2">\n  </span><span class="s1">invariant(router &amp;&amp; context, </span><span class="s2">\&quot;</span><span class="s1">You must provide `router` and `context` to &lt;StaticRouterProvider&gt;</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let dataRouterContext = {</span><span class="s2">\n    </span><span class="s1">router,</span><span class="s2">\n    </span><span class="s1">navigator: getStatelessNavigator(),</span><span class="s2">\n    </span><span class="s1">static: true,</span><span class="s2">\n    </span><span class="s1">staticContext: context,</span><span class="s2">\n    </span><span class="s1">basename: context.basename || </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">let fetchersContext = /* @__PURE__ */new Map();</span><span class="s2">\n  </span><span class="s1">let hydrateScript = </span><span class="s2">\&quot;\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">if (hydrate2 !== false) {</span><span class="s2">\n    </span><span class="s1">let data2 = {</span><span class="s2">\n      </span><span class="s1">loaderData: context.loaderData,</span><span class="s2">\n      </span><span class="s1">actionData: context.actionData,</span><span class="s2">\n      </span><span class="s1">errors: serializeErrors(context.errors)</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">let json = htmlEscape(JSON.stringify(JSON.stringify(data2)));</span><span class="s2">\n    </span><span class="s1">hydrateScript = `window.__staticRouterHydrationData = JSON.parse(${json});`;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let {</span><span class="s2">\n    </span><span class="s1">state</span><span class="s2">\n  </span><span class="s1">} = dataRouterContext.router;</span><span class="s2">\n  </span><span class="s1">return /* @__PURE__ */React11.createElement(React11.Fragment, null, /* @__PURE__ */React11.createElement(DataRouterContext.Provider, {</span><span class="s2">\n    </span><span class="s1">value: dataRouterContext</span><span class="s2">\n  </span><span class="s1">}, /* @__PURE__ */React11.createElement(DataRouterStateContext.Provider, {</span><span class="s2">\n    </span><span class="s1">value: state</span><span class="s2">\n  </span><span class="s1">}, /* @__PURE__ */React11.createElement(FetchersContext.Provider, {</span><span class="s2">\n    </span><span class="s1">value: fetchersContext</span><span class="s2">\n  </span><span class="s1">}, /* @__PURE__ */React11.createElement(ViewTransitionContext.Provider, {</span><span class="s2">\n    </span><span class="s1">value: {</span><span class="s2">\n      </span><span class="s1">isTransitioning: false</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}, /* @__PURE__ */React11.createElement(Router, {</span><span class="s2">\n    </span><span class="s1">basename: dataRouterContext.basename,</span><span class="s2">\n    </span><span class="s1">location: state.location,</span><span class="s2">\n    </span><span class="s1">navigationType: state.historyAction,</span><span class="s2">\n    </span><span class="s1">navigator: dataRouterContext.navigator,</span><span class="s2">\n    </span><span class="s1">static: dataRouterContext.static</span><span class="s2">\n  </span><span class="s1">}, /* @__PURE__ */React11.createElement(DataRoutes2, {</span><span class="s2">\n    </span><span class="s1">routes: router.routes,</span><span class="s2">\n    </span><span class="s1">future: router.future,</span><span class="s2">\n    </span><span class="s1">state</span><span class="s2">\n  </span><span class="s1">})))))), hydrateScript ? /* @__PURE__ */React11.createElement(</span><span class="s2">\&quot;</span><span class="s1">script</span><span class="s2">\&quot;</span><span class="s1">, {</span><span class="s2">\n    </span><span class="s1">suppressHydrationWarning: true,</span><span class="s2">\n    </span><span class="s1">nonce,</span><span class="s2">\n    </span><span class="s1">dangerouslySetInnerHTML: {</span><span class="s2">\n      </span><span class="s1">__html: hydrateScript</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}) : null);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function DataRoutes2({</span><span class="s2">\n  </span><span class="s1">routes,</span><span class="s2">\n  </span><span class="s1">future,</span><span class="s2">\n  </span><span class="s1">state</span><span class="s2">\n</span><span class="s1">}) {</span><span class="s2">\n  </span><span class="s1">return useRoutesImpl(routes, void 0, state, future);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function serializeErrors(errors) {</span><span class="s2">\n  </span><span class="s1">if (!errors) return null;</span><span class="s2">\n  </span><span class="s1">let entries = Object.entries(errors);</span><span class="s2">\n  </span><span class="s1">let serialized = {};</span><span class="s2">\n  </span><span class="s1">for (let [key, val] of entries) {</span><span class="s2">\n    </span><span class="s1">if (isRouteErrorResponse(val)) {</span><span class="s2">\n      </span><span class="s1">serialized[key] = {</span><span class="s2">\n        </span><span class="s1">...val,</span><span class="s2">\n        </span><span class="s1">__type: </span><span class="s2">\&quot;</span><span class="s1">RouteErrorResponse</span><span class="s2">\&quot;\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">} else if (val instanceof Error) {</span><span class="s2">\n      </span><span class="s1">serialized[key] = {</span><span class="s2">\n        </span><span class="s1">message: val.message,</span><span class="s2">\n        </span><span class="s1">__type: </span><span class="s2">\&quot;</span><span class="s1">Error</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        </span><span class="s1">// If this is a subclass (i.e., ReferenceError), send up the type so we</span><span class="s2">\n        </span><span class="s1">// can re-create the same type during hydration.</span><span class="s2">\n        </span><span class="s1">...(val.name !== </span><span class="s2">\&quot;</span><span class="s1">Error</span><span class="s2">\&quot; </span><span class="s1">? {</span><span class="s2">\n          </span><span class="s1">__subType: val.name</span><span class="s2">\n        </span><span class="s1">} : {})</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">serialized[key] = val;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return serialized;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getStatelessNavigator() {</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">createHref,</span><span class="s2">\n    </span><span class="s1">encodeLocation,</span><span class="s2">\n    </span><span class="s1">push(to) {</span><span class="s2">\n      </span><span class="s1">throw new Error(`You cannot use navigator.push() on the server because it is a stateless environment. This error was probably triggered when you did a </span><span class="s2">\\</span><span class="s1">`navigate(${JSON.stringify(to)})</span><span class="s2">\\</span><span class="s1">` somewhere in your app.`);</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">replace(to) {</span><span class="s2">\n      </span><span class="s1">throw new Error(`You cannot use navigator.replace() on the server because it is a stateless environment. This error was probably triggered when you did a </span><span class="s2">\\</span><span class="s1">`navigate(${JSON.stringify(to)}, { replace: true })</span><span class="s2">\\</span><span class="s1">` somewhere in your app.`);</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">go(delta) {</span><span class="s2">\n      </span><span class="s1">throw new Error(`You cannot use navigator.go() on the server because it is a stateless environment. This error was probably triggered when you did a </span><span class="s2">\\</span><span class="s1">`navigate(${delta})</span><span class="s2">\\</span><span class="s1">` somewhere in your app.`);</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">back() {</span><span class="s2">\n      </span><span class="s1">throw new Error(`You cannot use navigator.back() on the server because it is a stateless environment.`);</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">forward() {</span><span class="s2">\n      </span><span class="s1">throw new Error(`You cannot use navigator.forward() on the server because it is a stateless environment.`);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createStaticHandler2(routes, opts) {</span><span class="s2">\n  </span><span class="s1">return createStaticHandler(routes, {</span><span class="s2">\n    </span><span class="s1">...opts,</span><span class="s2">\n    </span><span class="s1">mapRouteProperties</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createStaticRouter(routes, context, opts = {}) {</span><span class="s2">\n  </span><span class="s1">let manifest = {};</span><span class="s2">\n  </span><span class="s1">let dataRoutes = convertRoutesToDataRoutes(routes, mapRouteProperties, void 0, manifest);</span><span class="s2">\n  </span><span class="s1">let matches = context.matches.map(match =&gt; {</span><span class="s2">\n    </span><span class="s1">let route = manifest[match.route.id] || match.route;</span><span class="s2">\n    </span><span class="s1">return {</span><span class="s2">\n      </span><span class="s1">...match,</span><span class="s2">\n      </span><span class="s1">route</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">let msg = method =&gt; `You cannot use router.${method}() on the server because it is a stateless environment`;</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">get basename() {</span><span class="s2">\n      </span><span class="s1">return context.basename;</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">get future() {</span><span class="s2">\n      </span><span class="s1">return {</span><span class="s2">\n        </span><span class="s1">unstable_middleware: false,</span><span class="s2">\n        </span><span class="s1">...opts?.future</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">get state() {</span><span class="s2">\n      </span><span class="s1">return {</span><span class="s2">\n        </span><span class="s1">historyAction: </span><span class="s2">\&quot;</span><span class="s1">POP</span><span class="s2">\&quot; </span><span class="s1">/* Pop */,</span><span class="s2">\n        </span><span class="s1">location: context.location,</span><span class="s2">\n        </span><span class="s1">matches,</span><span class="s2">\n        </span><span class="s1">loaderData: context.loaderData,</span><span class="s2">\n        </span><span class="s1">actionData: context.actionData,</span><span class="s2">\n        </span><span class="s1">errors: context.errors,</span><span class="s2">\n        </span><span class="s1">initialized: true,</span><span class="s2">\n        </span><span class="s1">navigation: IDLE_NAVIGATION,</span><span class="s2">\n        </span><span class="s1">restoreScrollPosition: null,</span><span class="s2">\n        </span><span class="s1">preventScrollReset: false,</span><span class="s2">\n        </span><span class="s1">revalidation: </span><span class="s2">\&quot;</span><span class="s1">idle</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        </span><span class="s1">fetchers: /* @__PURE__ */new Map(),</span><span class="s2">\n        </span><span class="s1">blockers: /* @__PURE__ */new Map()</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">get routes() {</span><span class="s2">\n      </span><span class="s1">return dataRoutes;</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">get window() {</span><span class="s2">\n      </span><span class="s1">return void 0;</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">initialize() {</span><span class="s2">\n      </span><span class="s1">throw msg(</span><span class="s2">\&quot;</span><span class="s1">initialize</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">subscribe() {</span><span class="s2">\n      </span><span class="s1">throw msg(</span><span class="s2">\&quot;</span><span class="s1">subscribe</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">enableScrollRestoration() {</span><span class="s2">\n      </span><span class="s1">throw msg(</span><span class="s2">\&quot;</span><span class="s1">enableScrollRestoration</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">navigate() {</span><span class="s2">\n      </span><span class="s1">throw msg(</span><span class="s2">\&quot;</span><span class="s1">navigate</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">fetch() {</span><span class="s2">\n      </span><span class="s1">throw msg(</span><span class="s2">\&quot;</span><span class="s1">fetch</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">revalidate() {</span><span class="s2">\n      </span><span class="s1">throw msg(</span><span class="s2">\&quot;</span><span class="s1">revalidate</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">createHref,</span><span class="s2">\n    </span><span class="s1">encodeLocation,</span><span class="s2">\n    </span><span class="s1">getFetcher() {</span><span class="s2">\n      </span><span class="s1">return IDLE_FETCHER;</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">deleteFetcher() {</span><span class="s2">\n      </span><span class="s1">throw msg(</span><span class="s2">\&quot;</span><span class="s1">deleteFetcher</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">dispose() {</span><span class="s2">\n      </span><span class="s1">throw msg(</span><span class="s2">\&quot;</span><span class="s1">dispose</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">getBlocker() {</span><span class="s2">\n      </span><span class="s1">return IDLE_BLOCKER;</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">deleteBlocker() {</span><span class="s2">\n      </span><span class="s1">throw msg(</span><span class="s2">\&quot;</span><span class="s1">deleteBlocker</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">patchRoutes() {</span><span class="s2">\n      </span><span class="s1">throw msg(</span><span class="s2">\&quot;</span><span class="s1">patchRoutes</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">_internalFetchControllers: /* @__PURE__ */new Map(),</span><span class="s2">\n    </span><span class="s1">_internalSetRoutes() {</span><span class="s2">\n      </span><span class="s1">throw msg(</span><span class="s2">\&quot;</span><span class="s1">_internalSetRoutes</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createHref(to) {</span><span class="s2">\n  </span><span class="s1">return typeof to === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">? to : createPath(to);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function encodeLocation(to) {</span><span class="s2">\n  </span><span class="s1">let href2 = typeof to === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">? to : createPath(to);</span><span class="s2">\n  </span><span class="s1">href2 = href2.replace(/ $/, </span><span class="s2">\&quot;</span><span class="s1">%20</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let encoded = ABSOLUTE_URL_REGEX3.test(href2) ? new URL(href2) : new URL(href2, </span><span class="s2">\&quot;</span><span class="s1">http://localhost</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">pathname: encoded.pathname,</span><span class="s2">\n    </span><span class="s1">search: encoded.search,</span><span class="s2">\n    </span><span class="s1">hash: encoded.hash</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var ABSOLUTE_URL_REGEX3 = /^(?:[a-z][a-z0-9+.-]*:|</span><span class="s2">\\</span><span class="s1">/</span><span class="s2">\\</span><span class="s1">/)/i;</span><span class="s2">\n</span><span class="s1">var ESCAPE_LOOKUP2 = {</span><span class="s2">\n  \&quot;</span><span class="s1">&amp;</span><span class="s2">\&quot;</span><span class="s1">: </span><span class="s2">\&quot;\\\\</span><span class="s1">u0026</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">&gt;</span><span class="s2">\&quot;</span><span class="s1">: </span><span class="s2">\&quot;\\\\</span><span class="s1">u003e</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">&lt;</span><span class="s2">\&quot;</span><span class="s1">: </span><span class="s2">\&quot;\\\\</span><span class="s1">u003c</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;\\</span><span class="s1">u2028</span><span class="s2">\&quot;</span><span class="s1">: </span><span class="s2">\&quot;\\\\</span><span class="s1">u2028</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;\\</span><span class="s1">u2029</span><span class="s2">\&quot;</span><span class="s1">: </span><span class="s2">\&quot;\\\\</span><span class="s1">u2029</span><span class="s2">\&quot;\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">var ESCAPE_REGEX2 = /[&amp;&gt;&lt;</span><span class="s2">\\</span><span class="s1">u2028</span><span class="s2">\\</span><span class="s1">u2029]/g;</span><span class="s2">\n</span><span class="s1">function htmlEscape(str) {</span><span class="s2">\n  </span><span class="s1">return str.replace(ESCAPE_REGEX2, match =&gt; ESCAPE_LOOKUP2[match]);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/dom/ssr/server.tsx</span><span class="s2">\n</span><span class="s1">import * as React12 from </span><span class="s2">\&quot;</span><span class="s1">react</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">function ServerRouter({</span><span class="s2">\n  </span><span class="s1">context,</span><span class="s2">\n  </span><span class="s1">url,</span><span class="s2">\n  </span><span class="s1">nonce</span><span class="s2">\n</span><span class="s1">}) {</span><span class="s2">\n  </span><span class="s1">if (typeof url === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">url = new URL(url);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let {</span><span class="s2">\n    </span><span class="s1">manifest,</span><span class="s2">\n    </span><span class="s1">routeModules,</span><span class="s2">\n    </span><span class="s1">criticalCss,</span><span class="s2">\n    </span><span class="s1">serverHandoffString</span><span class="s2">\n  </span><span class="s1">} = context;</span><span class="s2">\n  </span><span class="s1">let routes = createServerRoutes(manifest.routes, routeModules, context.future, context.isSpaMode);</span><span class="s2">\n  </span><span class="s1">context.staticHandlerContext.loaderData = {</span><span class="s2">\n    </span><span class="s1">...context.staticHandlerContext.loaderData</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">for (let match of context.staticHandlerContext.matches) {</span><span class="s2">\n    </span><span class="s1">let routeId = match.route.id;</span><span class="s2">\n    </span><span class="s1">let route = routeModules[routeId];</span><span class="s2">\n    </span><span class="s1">let manifestRoute = context.manifest.routes[routeId];</span><span class="s2">\n    </span><span class="s1">if (route &amp;&amp; manifestRoute &amp;&amp; shouldHydrateRouteLoader(routeId, route.clientLoader, manifestRoute.hasLoader, context.isSpaMode) &amp;&amp; (route.HydrateFallback || !manifestRoute.hasLoader)) {</span><span class="s2">\n      </span><span class="s1">delete context.staticHandlerContext.loaderData[routeId];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let router = createStaticRouter(routes, context.staticHandlerContext);</span><span class="s2">\n  </span><span class="s1">return /* @__PURE__ */React12.createElement(React12.Fragment, null, /* @__PURE__ */React12.createElement(FrameworkContext.Provider, {</span><span class="s2">\n    </span><span class="s1">value: {</span><span class="s2">\n      </span><span class="s1">manifest,</span><span class="s2">\n      </span><span class="s1">routeModules,</span><span class="s2">\n      </span><span class="s1">criticalCss,</span><span class="s2">\n      </span><span class="s1">serverHandoffString,</span><span class="s2">\n      </span><span class="s1">future: context.future,</span><span class="s2">\n      </span><span class="s1">ssr: context.ssr,</span><span class="s2">\n      </span><span class="s1">isSpaMode: context.isSpaMode,</span><span class="s2">\n      </span><span class="s1">routeDiscovery: context.routeDiscovery,</span><span class="s2">\n      </span><span class="s1">serializeError: context.serializeError,</span><span class="s2">\n      </span><span class="s1">renderMeta: context.renderMeta</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}, /* @__PURE__ */React12.createElement(RemixErrorBoundary, {</span><span class="s2">\n    </span><span class="s1">location: router.state.location</span><span class="s2">\n  </span><span class="s1">}, /* @__PURE__ */React12.createElement(StaticRouterProvider, {</span><span class="s2">\n    </span><span class="s1">router,</span><span class="s2">\n    </span><span class="s1">context: context.staticHandlerContext,</span><span class="s2">\n    </span><span class="s1">hydrate: false</span><span class="s2">\n  </span><span class="s1">}))), context.serverHandoffStream ? /* @__PURE__ */React12.createElement(React12.Suspense, null, /* @__PURE__ */React12.createElement(StreamTransfer, {</span><span class="s2">\n    </span><span class="s1">context,</span><span class="s2">\n    </span><span class="s1">identifier: 0,</span><span class="s2">\n    </span><span class="s1">reader: context.serverHandoffStream.getReader(),</span><span class="s2">\n    </span><span class="s1">textDecoder: new TextDecoder(),</span><span class="s2">\n    </span><span class="s1">nonce</span><span class="s2">\n  </span><span class="s1">})) : null);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/dom/ssr/routes-test-stub.tsx</span><span class="s2">\n</span><span class="s1">import * as React13 from </span><span class="s2">\&quot;</span><span class="s1">react</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">function createRoutesStub(routes, unstable_getContext) {</span><span class="s2">\n  </span><span class="s1">return function RoutesTestStub({</span><span class="s2">\n    </span><span class="s1">initialEntries,</span><span class="s2">\n    </span><span class="s1">initialIndex,</span><span class="s2">\n    </span><span class="s1">hydrationData,</span><span class="s2">\n    </span><span class="s1">future</span><span class="s2">\n  </span><span class="s1">}) {</span><span class="s2">\n    </span><span class="s1">let routerRef = React13.useRef();</span><span class="s2">\n    </span><span class="s1">let remixContextRef = React13.useRef();</span><span class="s2">\n    </span><span class="s1">if (routerRef.current == null) {</span><span class="s2">\n      </span><span class="s1">remixContextRef.current = {</span><span class="s2">\n        </span><span class="s1">future: {</span><span class="s2">\n          </span><span class="s1">unstable_subResourceIntegrity: future?.unstable_subResourceIntegrity === true,</span><span class="s2">\n          </span><span class="s1">unstable_middleware: future?.unstable_middleware === true</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">manifest: {</span><span class="s2">\n          </span><span class="s1">routes: {},</span><span class="s2">\n          </span><span class="s1">entry: {</span><span class="s2">\n            </span><span class="s1">imports: [],</span><span class="s2">\n            </span><span class="s1">module: </span><span class="s2">\&quot;\&quot;\n          </span><span class="s1">},</span><span class="s2">\n          </span><span class="s1">url: </span><span class="s2">\&quot;\&quot;</span><span class="s1">,</span><span class="s2">\n          </span><span class="s1">version: </span><span class="s2">\&quot;\&quot;\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">routeModules: {},</span><span class="s2">\n        </span><span class="s1">ssr: false,</span><span class="s2">\n        </span><span class="s1">isSpaMode: false,</span><span class="s2">\n        </span><span class="s1">routeDiscovery: {</span><span class="s2">\n          </span><span class="s1">mode: </span><span class="s2">\&quot;</span><span class="s1">lazy</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n          </span><span class="s1">manifestPath: </span><span class="s2">\&quot;</span><span class="s1">/__manifest</span><span class="s2">\&quot;\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">let patched = processRoutes(</span><span class="s2">\n      </span><span class="s1">// @ts-expect-error `StubRouteObject` is stricter about `loader`/`action`</span><span class="s2">\n      </span><span class="s1">// types compared to `AgnosticRouteObject`</span><span class="s2">\n      </span><span class="s1">convertRoutesToDataRoutes(routes, r =&gt; r), remixContextRef.current.manifest, remixContextRef.current.routeModules);</span><span class="s2">\n      </span><span class="s1">routerRef.current = createMemoryRouter(patched, {</span><span class="s2">\n        </span><span class="s1">unstable_getContext,</span><span class="s2">\n        </span><span class="s1">initialEntries,</span><span class="s2">\n        </span><span class="s1">initialIndex,</span><span class="s2">\n        </span><span class="s1">hydrationData</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return /* @__PURE__ */React13.createElement(FrameworkContext.Provider, {</span><span class="s2">\n      </span><span class="s1">value: remixContextRef.current</span><span class="s2">\n    </span><span class="s1">}, /* @__PURE__ */React13.createElement(RouterProvider, {</span><span class="s2">\n      </span><span class="s1">router: routerRef.current</span><span class="s2">\n    </span><span class="s1">}));</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function withComponentProps(Component4) {</span><span class="s2">\n  </span><span class="s1">return function Wrapped() {</span><span class="s2">\n    </span><span class="s1">return React13.createElement(Component4, {</span><span class="s2">\n      </span><span class="s1">params: useParams(),</span><span class="s2">\n      </span><span class="s1">loaderData: useLoaderData(),</span><span class="s2">\n      </span><span class="s1">actionData: useActionData(),</span><span class="s2">\n      </span><span class="s1">matches: useMatches()</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function withHydrateFallbackProps(HydrateFallback) {</span><span class="s2">\n  </span><span class="s1">return function Wrapped() {</span><span class="s2">\n    </span><span class="s1">const props = {</span><span class="s2">\n      </span><span class="s1">params: useParams(),</span><span class="s2">\n      </span><span class="s1">loaderData: useLoaderData(),</span><span class="s2">\n      </span><span class="s1">actionData: useActionData()</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">return React13.createElement(HydrateFallback, props);</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function withErrorBoundaryProps(ErrorBoundary) {</span><span class="s2">\n  </span><span class="s1">return function Wrapped() {</span><span class="s2">\n    </span><span class="s1">const props = {</span><span class="s2">\n      </span><span class="s1">params: useParams(),</span><span class="s2">\n      </span><span class="s1">loaderData: useLoaderData(),</span><span class="s2">\n      </span><span class="s1">actionData: useActionData(),</span><span class="s2">\n      </span><span class="s1">error: useRouteError()</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">return React13.createElement(ErrorBoundary, props);</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function processRoutes(routes, manifest, routeModules, parentId) {</span><span class="s2">\n  </span><span class="s1">return routes.map(route =&gt; {</span><span class="s2">\n    </span><span class="s1">if (!route.id) {</span><span class="s2">\n      </span><span class="s1">throw new Error(</span><span class="s2">\&quot;</span><span class="s1">Expected a route.id in @remix-run/testing processRoutes() function</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let newRoute = {</span><span class="s2">\n      </span><span class="s1">id: route.id,</span><span class="s2">\n      </span><span class="s1">path: route.path,</span><span class="s2">\n      </span><span class="s1">index: route.index,</span><span class="s2">\n      </span><span class="s1">Component: route.Component ? withComponentProps(route.Component) : void 0,</span><span class="s2">\n      </span><span class="s1">HydrateFallback: route.HydrateFallback ? withHydrateFallbackProps(route.HydrateFallback) : void 0,</span><span class="s2">\n      </span><span class="s1">ErrorBoundary: route.ErrorBoundary ? withErrorBoundaryProps(route.ErrorBoundary) : void 0,</span><span class="s2">\n      </span><span class="s1">action: route.action,</span><span class="s2">\n      </span><span class="s1">loader: route.loader,</span><span class="s2">\n      </span><span class="s1">handle: route.handle,</span><span class="s2">\n      </span><span class="s1">shouldRevalidate: route.shouldRevalidate</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">let entryRoute = {</span><span class="s2">\n      </span><span class="s1">id: route.id,</span><span class="s2">\n      </span><span class="s1">path: route.path,</span><span class="s2">\n      </span><span class="s1">index: route.index,</span><span class="s2">\n      </span><span class="s1">parentId,</span><span class="s2">\n      </span><span class="s1">hasAction: route.action != null,</span><span class="s2">\n      </span><span class="s1">hasLoader: route.loader != null,</span><span class="s2">\n      </span><span class="s1">// When testing routes, you should be stubbing loader/action/middleware,</span><span class="s2">\n      </span><span class="s1">// not trying to re-implement the full loader/clientLoader/SSR/hydration</span><span class="s2">\n      </span><span class="s1">// flow. That is better tested via E2E tests.</span><span class="s2">\n      </span><span class="s1">hasClientAction: false,</span><span class="s2">\n      </span><span class="s1">hasClientLoader: false,</span><span class="s2">\n      </span><span class="s1">hasClientMiddleware: false,</span><span class="s2">\n      </span><span class="s1">hasErrorBoundary: route.ErrorBoundary != null,</span><span class="s2">\n      </span><span class="s1">// any need for these?</span><span class="s2">\n      </span><span class="s1">module: </span><span class="s2">\&quot;</span><span class="s1">build/stub-path-to-module.js</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">clientActionModule: void 0,</span><span class="s2">\n      </span><span class="s1">clientLoaderModule: void 0,</span><span class="s2">\n      </span><span class="s1">clientMiddlewareModule: void 0,</span><span class="s2">\n      </span><span class="s1">hydrateFallbackModule: void 0</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">manifest.routes[newRoute.id] = entryRoute;</span><span class="s2">\n    </span><span class="s1">routeModules[route.id] = {</span><span class="s2">\n      </span><span class="s1">default: newRoute.Component || Outlet,</span><span class="s2">\n      </span><span class="s1">ErrorBoundary: newRoute.ErrorBoundary || void 0,</span><span class="s2">\n      </span><span class="s1">handle: route.handle,</span><span class="s2">\n      </span><span class="s1">links: route.links,</span><span class="s2">\n      </span><span class="s1">meta: route.meta,</span><span class="s2">\n      </span><span class="s1">shouldRevalidate: route.shouldRevalidate</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">if (route.children) {</span><span class="s2">\n      </span><span class="s1">newRoute.children = processRoutes(route.children, manifest, routeModules, newRoute.id);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return newRoute;</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/server-runtime/cookies.ts</span><span class="s2">\n</span><span class="s1">import { parse, serialize } from </span><span class="s2">\&quot;</span><span class="s1">cookie</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n</span><span class="s1">// lib/server-runtime/crypto.ts</span><span class="s2">\n</span><span class="s1">var encoder = /* @__PURE__ */new TextEncoder();</span><span class="s2">\n</span><span class="s1">var sign = async (value, secret) =&gt; {</span><span class="s2">\n  </span><span class="s1">let data2 = encoder.encode(value);</span><span class="s2">\n  </span><span class="s1">let key = await createKey2(secret, [</span><span class="s2">\&quot;</span><span class="s1">sign</span><span class="s2">\&quot;</span><span class="s1">]);</span><span class="s2">\n  </span><span class="s1">let signature = await crypto.subtle.sign(</span><span class="s2">\&quot;</span><span class="s1">HMAC</span><span class="s2">\&quot;</span><span class="s1">, key, data2);</span><span class="s2">\n  </span><span class="s1">let hash = btoa(String.fromCharCode(...new Uint8Array(signature))).replace(/=+$/, </span><span class="s2">\&quot;\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">return value + </span><span class="s2">\&quot;</span><span class="s1">.</span><span class="s2">\&quot; </span><span class="s1">+ hash;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">var unsign = async (cookie, secret) =&gt; {</span><span class="s2">\n  </span><span class="s1">let index = cookie.lastIndexOf(</span><span class="s2">\&quot;</span><span class="s1">.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let value = cookie.slice(0, index);</span><span class="s2">\n  </span><span class="s1">let hash = cookie.slice(index + 1);</span><span class="s2">\n  </span><span class="s1">let data2 = encoder.encode(value);</span><span class="s2">\n  </span><span class="s1">let key = await createKey2(secret, [</span><span class="s2">\&quot;</span><span class="s1">verify</span><span class="s2">\&quot;</span><span class="s1">]);</span><span class="s2">\n  </span><span class="s1">let signature = byteStringToUint8Array(atob(hash));</span><span class="s2">\n  </span><span class="s1">let valid = await crypto.subtle.verify(</span><span class="s2">\&quot;</span><span class="s1">HMAC</span><span class="s2">\&quot;</span><span class="s1">, key, signature, data2);</span><span class="s2">\n  </span><span class="s1">return valid ? value : false;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">var createKey2 = async (secret, usages) =&gt; crypto.subtle.importKey(</span><span class="s2">\&quot;</span><span class="s1">raw</span><span class="s2">\&quot;</span><span class="s1">, encoder.encode(secret), {</span><span class="s2">\n  </span><span class="s1">name: </span><span class="s2">\&quot;</span><span class="s1">HMAC</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">hash: </span><span class="s2">\&quot;</span><span class="s1">SHA-256</span><span class="s2">\&quot;\n</span><span class="s1">}, false, usages);</span><span class="s2">\n</span><span class="s1">function byteStringToUint8Array(byteString) {</span><span class="s2">\n  </span><span class="s1">let array = new Uint8Array(byteString.length);</span><span class="s2">\n  </span><span class="s1">for (let i = 0; i &lt; byteString.length; i++) {</span><span class="s2">\n    </span><span class="s1">array[i] = byteString.charCodeAt(i);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return array;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/server-runtime/cookies.ts</span><span class="s2">\n</span><span class="s1">var createCookie = (name, cookieOptions = {}) =&gt; {</span><span class="s2">\n  </span><span class="s1">let {</span><span class="s2">\n    </span><span class="s1">secrets = [],</span><span class="s2">\n    </span><span class="s1">...options</span><span class="s2">\n  </span><span class="s1">} = {</span><span class="s2">\n    </span><span class="s1">path: </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">sameSite: </span><span class="s2">\&quot;</span><span class="s1">lax</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">...cookieOptions</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">warnOnceAboutExpiresCookie(name, options.expires);</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">get name() {</span><span class="s2">\n      </span><span class="s1">return name;</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">get isSigned() {</span><span class="s2">\n      </span><span class="s1">return secrets.length &gt; 0;</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">get expires() {</span><span class="s2">\n      </span><span class="s1">return typeof options.maxAge !== </span><span class="s2">\&quot;</span><span class="s1">undefined</span><span class="s2">\&quot; </span><span class="s1">? new Date(Date.now() + options.maxAge * 1e3) : options.expires;</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">async parse(cookieHeader, parseOptions) {</span><span class="s2">\n      </span><span class="s1">if (!cookieHeader) return null;</span><span class="s2">\n      </span><span class="s1">let cookies = parse(cookieHeader, {</span><span class="s2">\n        </span><span class="s1">...options,</span><span class="s2">\n        </span><span class="s1">...parseOptions</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">if (name in cookies) {</span><span class="s2">\n        </span><span class="s1">let value = cookies[name];</span><span class="s2">\n        </span><span class="s1">if (typeof value === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; value !== </span><span class="s2">\&quot;\&quot;</span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">let decoded = await decodeCookieValue(value, secrets);</span><span class="s2">\n          </span><span class="s1">return decoded;</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">return </span><span class="s2">\&quot;\&quot;</span><span class="s1">;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">return null;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">async serialize(value, serializeOptions) {</span><span class="s2">\n      </span><span class="s1">return serialize(name, value === </span><span class="s2">\&quot;\&quot; </span><span class="s1">? </span><span class="s2">\&quot;\&quot; </span><span class="s1">: await encodeCookieValue(value, secrets), {</span><span class="s2">\n        </span><span class="s1">...options,</span><span class="s2">\n        </span><span class="s1">...serializeOptions</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">var isCookie = object =&gt; {</span><span class="s2">\n  </span><span class="s1">return object != null &amp;&amp; typeof object.name === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; typeof object.isSigned === </span><span class="s2">\&quot;</span><span class="s1">boolean</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; typeof object.parse === </span><span class="s2">\&quot;</span><span class="s1">function</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; typeof object.serialize === </span><span class="s2">\&quot;</span><span class="s1">function</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">async function encodeCookieValue(value, secrets) {</span><span class="s2">\n  </span><span class="s1">let encoded = encodeData(value);</span><span class="s2">\n  </span><span class="s1">if (secrets.length &gt; 0) {</span><span class="s2">\n    </span><span class="s1">encoded = await sign(encoded, secrets[0]);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return encoded;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">async function decodeCookieValue(value, secrets) {</span><span class="s2">\n  </span><span class="s1">if (secrets.length &gt; 0) {</span><span class="s2">\n    </span><span class="s1">for (let secret of secrets) {</span><span class="s2">\n      </span><span class="s1">let unsignedValue = await unsign(value, secret);</span><span class="s2">\n      </span><span class="s1">if (unsignedValue !== false) {</span><span class="s2">\n        </span><span class="s1">return decodeData(unsignedValue);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return null;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return decodeData(value);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function encodeData(value) {</span><span class="s2">\n  </span><span class="s1">return btoa(myUnescape(encodeURIComponent(JSON.stringify(value))));</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function decodeData(value) {</span><span class="s2">\n  </span><span class="s1">try {</span><span class="s2">\n    </span><span class="s1">return JSON.parse(decodeURIComponent(myEscape(atob(value))));</span><span class="s2">\n  </span><span class="s1">} catch (error) {</span><span class="s2">\n    </span><span class="s1">return {};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function myEscape(value) {</span><span class="s2">\n  </span><span class="s1">let str = value.toString();</span><span class="s2">\n  </span><span class="s1">let result = </span><span class="s2">\&quot;\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">let index = 0;</span><span class="s2">\n  </span><span class="s1">let chr, code;</span><span class="s2">\n  </span><span class="s1">while (index &lt; str.length) {</span><span class="s2">\n    </span><span class="s1">chr = str.charAt(index++);</span><span class="s2">\n    </span><span class="s1">if (/[</span><span class="s2">\\</span><span class="s1">w*+</span><span class="s2">\\</span><span class="s1">-./@]/.exec(chr)) {</span><span class="s2">\n      </span><span class="s1">result += chr;</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">code = chr.charCodeAt(0);</span><span class="s2">\n      </span><span class="s1">if (code &lt; 256) {</span><span class="s2">\n        </span><span class="s1">result += </span><span class="s2">\&quot;</span><span class="s1">%</span><span class="s2">\&quot; </span><span class="s1">+ hex(code, 2);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">result += </span><span class="s2">\&quot;</span><span class="s1">%u</span><span class="s2">\&quot; </span><span class="s1">+ hex(code, 4).toUpperCase();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return result;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function hex(code, length) {</span><span class="s2">\n  </span><span class="s1">let result = code.toString(16);</span><span class="s2">\n  </span><span class="s1">while (result.length &lt; length) result = </span><span class="s2">\&quot;</span><span class="s1">0</span><span class="s2">\&quot; </span><span class="s1">+ result;</span><span class="s2">\n  </span><span class="s1">return result;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function myUnescape(value) {</span><span class="s2">\n  </span><span class="s1">let str = value.toString();</span><span class="s2">\n  </span><span class="s1">let result = </span><span class="s2">\&quot;\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">let index = 0;</span><span class="s2">\n  </span><span class="s1">let chr, part;</span><span class="s2">\n  </span><span class="s1">while (index &lt; str.length) {</span><span class="s2">\n    </span><span class="s1">chr = str.charAt(index++);</span><span class="s2">\n    </span><span class="s1">if (chr === </span><span class="s2">\&quot;</span><span class="s1">%</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">if (str.charAt(index) === </span><span class="s2">\&quot;</span><span class="s1">u</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">part = str.slice(index + 1, index + 5);</span><span class="s2">\n        </span><span class="s1">if (/^[</span><span class="s2">\\</span><span class="s1">da-f]{4}$/i.exec(part)) {</span><span class="s2">\n          </span><span class="s1">result += String.fromCharCode(parseInt(part, 16));</span><span class="s2">\n          </span><span class="s1">index += 5;</span><span class="s2">\n          </span><span class="s1">continue;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">part = str.slice(index, index + 2);</span><span class="s2">\n        </span><span class="s1">if (/^[</span><span class="s2">\\</span><span class="s1">da-f]{2}$/i.exec(part)) {</span><span class="s2">\n          </span><span class="s1">result += String.fromCharCode(parseInt(part, 16));</span><span class="s2">\n          </span><span class="s1">index += 2;</span><span class="s2">\n          </span><span class="s1">continue;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">result += chr;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return result;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function warnOnceAboutExpiresCookie(name, expires) {</span><span class="s2">\n  </span><span class="s1">warnOnce(!expires, `The </span><span class="s2">\&quot;</span><span class="s1">${name}</span><span class="s2">\&quot; </span><span class="s1">cookie has an </span><span class="s2">\&quot;</span><span class="s1">expires</span><span class="s2">\&quot; </span><span class="s1">property set. This will cause the expires value to not be updated when the session is committed. Instead, you should set the expires value when serializing the cookie. You can use </span><span class="s2">\\</span><span class="s1">`commitSession(session, { expires })</span><span class="s2">\\</span><span class="s1">` if using a session storage object, or </span><span class="s2">\\</span><span class="s1">`cookie.serialize(</span><span class="s2">\&quot;</span><span class="s1">value</span><span class="s2">\&quot;</span><span class="s1">, { expires })</span><span class="s2">\\</span><span class="s1">` if you're using the cookie directly.`);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/server-runtime/entry.ts</span><span class="s2">\n</span><span class="s1">function createEntryRouteModules(manifest) {</span><span class="s2">\n  </span><span class="s1">return Object.keys(manifest).reduce((memo2, routeId) =&gt; {</span><span class="s2">\n    </span><span class="s1">let route = manifest[routeId];</span><span class="s2">\n    </span><span class="s1">if (route) {</span><span class="s2">\n      </span><span class="s1">memo2[routeId] = route.module;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return memo2;</span><span class="s2">\n  </span><span class="s1">}, {});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/server-runtime/mode.ts</span><span class="s2">\n</span><span class="s1">var ServerMode = /* @__PURE__ */(ServerMode2 =&gt; {</span><span class="s2">\n  </span><span class="s1">ServerMode2[</span><span class="s2">\&quot;</span><span class="s1">Development</span><span class="s2">\&quot;</span><span class="s1">] = </span><span class="s2">\&quot;</span><span class="s1">development</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">ServerMode2[</span><span class="s2">\&quot;</span><span class="s1">Production</span><span class="s2">\&quot;</span><span class="s1">] = </span><span class="s2">\&quot;</span><span class="s1">production</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">ServerMode2[</span><span class="s2">\&quot;</span><span class="s1">Test</span><span class="s2">\&quot;</span><span class="s1">] = </span><span class="s2">\&quot;</span><span class="s1">test</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">return ServerMode2;</span><span class="s2">\n</span><span class="s1">})(ServerMode || {});</span><span class="s2">\n</span><span class="s1">function isServerMode(value) {</span><span class="s2">\n  </span><span class="s1">return value === </span><span class="s2">\&quot;</span><span class="s1">development</span><span class="s2">\&quot; </span><span class="s1">/* Development */ || value === </span><span class="s2">\&quot;</span><span class="s1">production</span><span class="s2">\&quot; </span><span class="s1">/* Production */ || value === </span><span class="s2">\&quot;</span><span class="s1">test</span><span class="s2">\&quot; </span><span class="s1">/* Test */;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/server-runtime/errors.ts</span><span class="s2">\n</span><span class="s1">function sanitizeError(error, serverMode) {</span><span class="s2">\n  </span><span class="s1">if (error instanceof Error &amp;&amp; serverMode !== </span><span class="s2">\&quot;</span><span class="s1">development</span><span class="s2">\&quot; </span><span class="s1">/* Development */) {</span><span class="s2">\n    </span><span class="s1">let sanitized = new Error(</span><span class="s2">\&quot;</span><span class="s1">Unexpected Server Error</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">sanitized.stack = void 0;</span><span class="s2">\n    </span><span class="s1">return sanitized;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return error;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function sanitizeErrors(errors, serverMode) {</span><span class="s2">\n  </span><span class="s1">return Object.entries(errors).reduce((acc, [routeId, error]) =&gt; {</span><span class="s2">\n    </span><span class="s1">return Object.assign(acc, {</span><span class="s2">\n      </span><span class="s1">[routeId]: sanitizeError(error, serverMode)</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}, {});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function serializeError(error, serverMode) {</span><span class="s2">\n  </span><span class="s1">let sanitized = sanitizeError(error, serverMode);</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">message: sanitized.message,</span><span class="s2">\n    </span><span class="s1">stack: sanitized.stack</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function serializeErrors2(errors, serverMode) {</span><span class="s2">\n  </span><span class="s1">if (!errors) return null;</span><span class="s2">\n  </span><span class="s1">let entries = Object.entries(errors);</span><span class="s2">\n  </span><span class="s1">let serialized = {};</span><span class="s2">\n  </span><span class="s1">for (let [key, val] of entries) {</span><span class="s2">\n    </span><span class="s1">if (isRouteErrorResponse(val)) {</span><span class="s2">\n      </span><span class="s1">serialized[key] = {</span><span class="s2">\n        </span><span class="s1">...val,</span><span class="s2">\n        </span><span class="s1">__type: </span><span class="s2">\&quot;</span><span class="s1">RouteErrorResponse</span><span class="s2">\&quot;\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">} else if (val instanceof Error) {</span><span class="s2">\n      </span><span class="s1">let sanitized = sanitizeError(val, serverMode);</span><span class="s2">\n      </span><span class="s1">serialized[key] = {</span><span class="s2">\n        </span><span class="s1">message: sanitized.message,</span><span class="s2">\n        </span><span class="s1">stack: sanitized.stack,</span><span class="s2">\n        </span><span class="s1">__type: </span><span class="s2">\&quot;</span><span class="s1">Error</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        </span><span class="s1">// If this is a subclass (i.e., ReferenceError), send up the type so we</span><span class="s2">\n        </span><span class="s1">// can re-create the same type during hydration.  This will only apply</span><span class="s2">\n        </span><span class="s1">// in dev mode since all production errors are sanitized to normal</span><span class="s2">\n        </span><span class="s1">// Error instances</span><span class="s2">\n        </span><span class="s1">...(sanitized.name !== </span><span class="s2">\&quot;</span><span class="s1">Error</span><span class="s2">\&quot; </span><span class="s1">? {</span><span class="s2">\n          </span><span class="s1">__subType: sanitized.name</span><span class="s2">\n        </span><span class="s1">} : {})</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">serialized[key] = val;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return serialized;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/server-runtime/routeMatching.ts</span><span class="s2">\n</span><span class="s1">function matchServerRoutes(routes, pathname, basename) {</span><span class="s2">\n  </span><span class="s1">let matches = matchRoutes(routes, pathname, basename);</span><span class="s2">\n  </span><span class="s1">if (!matches) return null;</span><span class="s2">\n  </span><span class="s1">return matches.map(match =&gt; ({</span><span class="s2">\n    </span><span class="s1">params: match.params,</span><span class="s2">\n    </span><span class="s1">pathname: match.pathname,</span><span class="s2">\n    </span><span class="s1">route: match.route</span><span class="s2">\n  </span><span class="s1">}));</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/server-runtime/data.ts</span><span class="s2">\n</span><span class="s1">async function callRouteHandler(handler, args) {</span><span class="s2">\n  </span><span class="s1">let result = await handler({</span><span class="s2">\n    </span><span class="s1">request: stripRoutesParam(stripIndexParam2(args.request)),</span><span class="s2">\n    </span><span class="s1">params: args.params,</span><span class="s2">\n    </span><span class="s1">context: args.context</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">if (isDataWithResponseInit(result) &amp;&amp; result.init &amp;&amp; result.init.status &amp;&amp; isRedirectStatusCode(result.init.status)) {</span><span class="s2">\n    </span><span class="s1">throw new Response(null, result.init);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return result;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function stripIndexParam2(request) {</span><span class="s2">\n  </span><span class="s1">let url = new URL(request.url);</span><span class="s2">\n  </span><span class="s1">let indexValues = url.searchParams.getAll(</span><span class="s2">\&quot;</span><span class="s1">index</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">url.searchParams.delete(</span><span class="s2">\&quot;</span><span class="s1">index</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let indexValuesToKeep = [];</span><span class="s2">\n  </span><span class="s1">for (let indexValue of indexValues) {</span><span class="s2">\n    </span><span class="s1">if (indexValue) {</span><span class="s2">\n      </span><span class="s1">indexValuesToKeep.push(indexValue);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">for (let toKeep of indexValuesToKeep) {</span><span class="s2">\n    </span><span class="s1">url.searchParams.append(</span><span class="s2">\&quot;</span><span class="s1">index</span><span class="s2">\&quot;</span><span class="s1">, toKeep);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let init = {</span><span class="s2">\n    </span><span class="s1">method: request.method,</span><span class="s2">\n    </span><span class="s1">body: request.body,</span><span class="s2">\n    </span><span class="s1">headers: request.headers,</span><span class="s2">\n    </span><span class="s1">signal: request.signal</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">if (init.body) {</span><span class="s2">\n    </span><span class="s1">init.duplex = </span><span class="s2">\&quot;</span><span class="s1">half</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return new Request(url.href, init);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function stripRoutesParam(request) {</span><span class="s2">\n  </span><span class="s1">let url = new URL(request.url);</span><span class="s2">\n  </span><span class="s1">url.searchParams.delete(</span><span class="s2">\&quot;</span><span class="s1">_routes</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let init = {</span><span class="s2">\n    </span><span class="s1">method: request.method,</span><span class="s2">\n    </span><span class="s1">body: request.body,</span><span class="s2">\n    </span><span class="s1">headers: request.headers,</span><span class="s2">\n    </span><span class="s1">signal: request.signal</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">if (init.body) {</span><span class="s2">\n    </span><span class="s1">init.duplex = </span><span class="s2">\&quot;</span><span class="s1">half</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return new Request(url.href, init);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/server-runtime/invariant.ts</span><span class="s2">\n</span><span class="s1">function invariant3(value, message) {</span><span class="s2">\n  </span><span class="s1">if (value === false || value === null || typeof value === </span><span class="s2">\&quot;</span><span class="s1">undefined</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">console.error(</span><span class="s2">\&quot;</span><span class="s1">The following error is a bug in React Router; please open an issue! https://github.com/remix-run/react-router/issues/new/choose</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">throw new Error(message);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/server-runtime/dev.ts</span><span class="s2">\n</span><span class="s1">var globalDevServerHooksKey = </span><span class="s2">\&quot;</span><span class="s1">__reactRouterDevServerHooks</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">function setDevServerHooks(devServerHooks) {</span><span class="s2">\n  </span><span class="s1">globalThis[globalDevServerHooksKey] = devServerHooks;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getDevServerHooks() {</span><span class="s2">\n  </span><span class="s1">return globalThis[globalDevServerHooksKey];</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getBuildTimeHeader(request, headerName) {</span><span class="s2">\n  </span><span class="s1">if (typeof process !== </span><span class="s2">\&quot;</span><span class="s1">undefined</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">try {</span><span class="s2">\n      </span><span class="s1">if (process.env?.IS_RR_BUILD_REQUEST === </span><span class="s2">\&quot;</span><span class="s1">yes</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">return request.headers.get(headerName);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} catch (e) {}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return null;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/server-runtime/routes.ts</span><span class="s2">\n</span><span class="s1">function groupRoutesByParentId2(manifest) {</span><span class="s2">\n  </span><span class="s1">let routes = {};</span><span class="s2">\n  </span><span class="s1">Object.values(manifest).forEach(route =&gt; {</span><span class="s2">\n    </span><span class="s1">if (route) {</span><span class="s2">\n      </span><span class="s1">let parentId = route.parentId || </span><span class="s2">\&quot;\&quot;</span><span class="s1">;</span><span class="s2">\n      </span><span class="s1">if (!routes[parentId]) {</span><span class="s2">\n        </span><span class="s1">routes[parentId] = [];</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">routes[parentId].push(route);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">return routes;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createRoutes(manifest, parentId = </span><span class="s2">\&quot;\&quot;</span><span class="s1">, routesByParentId = groupRoutesByParentId2(manifest)) {</span><span class="s2">\n  </span><span class="s1">return (routesByParentId[parentId] || []).map(route =&gt; ({</span><span class="s2">\n    </span><span class="s1">...route,</span><span class="s2">\n    </span><span class="s1">children: createRoutes(manifest, route.id, routesByParentId)</span><span class="s2">\n  </span><span class="s1">}));</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createStaticHandlerDataRoutes(manifest, future, parentId = </span><span class="s2">\&quot;\&quot;</span><span class="s1">, routesByParentId = groupRoutesByParentId2(manifest)) {</span><span class="s2">\n  </span><span class="s1">return (routesByParentId[parentId] || []).map(route =&gt; {</span><span class="s2">\n    </span><span class="s1">let commonRoute = {</span><span class="s2">\n      </span><span class="s1">// Always include root due to default boundaries</span><span class="s2">\n      </span><span class="s1">hasErrorBoundary: route.id === </span><span class="s2">\&quot;</span><span class="s1">root</span><span class="s2">\&quot; </span><span class="s1">|| route.module.ErrorBoundary != null,</span><span class="s2">\n      </span><span class="s1">id: route.id,</span><span class="s2">\n      </span><span class="s1">path: route.path,</span><span class="s2">\n      </span><span class="s1">unstable_middleware: route.module.unstable_middleware,</span><span class="s2">\n      </span><span class="s1">// Need to use RR's version in the param typed here to permit the optional</span><span class="s2">\n      </span><span class="s1">// context even though we know it'll always be provided in remix</span><span class="s2">\n      </span><span class="s1">loader: route.module.loader ? async args =&gt; {</span><span class="s2">\n        </span><span class="s1">let preRenderedData = getBuildTimeHeader(args.request, </span><span class="s2">\&quot;</span><span class="s1">X-React-Router-Prerender-Data</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">if (preRenderedData != null) {</span><span class="s2">\n          </span><span class="s1">let encoded = preRenderedData ? decodeURI(preRenderedData) : preRenderedData;</span><span class="s2">\n          </span><span class="s1">invariant3(encoded, </span><span class="s2">\&quot;</span><span class="s1">Missing prerendered data for route</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">let uint8array = new TextEncoder().encode(encoded);</span><span class="s2">\n          </span><span class="s1">let stream = new ReadableStream({</span><span class="s2">\n            </span><span class="s1">start(controller) {</span><span class="s2">\n              </span><span class="s1">controller.enqueue(uint8array);</span><span class="s2">\n              </span><span class="s1">controller.close();</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n          </span><span class="s1">let decoded = await decodeViaTurboStream(stream, global);</span><span class="s2">\n          </span><span class="s1">let data2 = decoded.value;</span><span class="s2">\n          </span><span class="s1">if (data2 &amp;&amp; SingleFetchRedirectSymbol in data2) {</span><span class="s2">\n            </span><span class="s1">let result = data2[SingleFetchRedirectSymbol];</span><span class="s2">\n            </span><span class="s1">let init = {</span><span class="s2">\n              </span><span class="s1">status: result.status</span><span class="s2">\n            </span><span class="s1">};</span><span class="s2">\n            </span><span class="s1">if (result.reload) {</span><span class="s2">\n              </span><span class="s1">throw redirectDocument(result.redirect, init);</span><span class="s2">\n            </span><span class="s1">} else if (result.replace) {</span><span class="s2">\n              </span><span class="s1">throw replace(result.redirect, init);</span><span class="s2">\n            </span><span class="s1">} else {</span><span class="s2">\n              </span><span class="s1">throw redirect(result.redirect, init);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">} else {</span><span class="s2">\n            </span><span class="s1">invariant3(data2 &amp;&amp; route.id in data2, </span><span class="s2">\&quot;</span><span class="s1">Unable to decode prerendered data</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n            </span><span class="s1">let result = data2[route.id];</span><span class="s2">\n            </span><span class="s1">invariant3(</span><span class="s2">\&quot;</span><span class="s1">data</span><span class="s2">\&quot; </span><span class="s1">in result, </span><span class="s2">\&quot;</span><span class="s1">Unable to process prerendered data</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n            </span><span class="s1">return result.data;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">let val = await callRouteHandler(route.module.loader, args);</span><span class="s2">\n        </span><span class="s1">return val;</span><span class="s2">\n      </span><span class="s1">} : void 0,</span><span class="s2">\n      </span><span class="s1">action: route.module.action ? args =&gt; callRouteHandler(route.module.action, args) : void 0,</span><span class="s2">\n      </span><span class="s1">handle: route.module.handle</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">return route.index ? {</span><span class="s2">\n      </span><span class="s1">index: true,</span><span class="s2">\n      </span><span class="s1">...commonRoute</span><span class="s2">\n    </span><span class="s1">} : {</span><span class="s2">\n      </span><span class="s1">caseSensitive: route.caseSensitive,</span><span class="s2">\n      </span><span class="s1">children: createStaticHandlerDataRoutes(manifest, future, route.id, routesByParentId),</span><span class="s2">\n      </span><span class="s1">...commonRoute</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/server-runtime/markup.ts</span><span class="s2">\n</span><span class="s1">var ESCAPE_LOOKUP3 = {</span><span class="s2">\n  \&quot;</span><span class="s1">&amp;</span><span class="s2">\&quot;</span><span class="s1">: </span><span class="s2">\&quot;\\\\</span><span class="s1">u0026</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">&gt;</span><span class="s2">\&quot;</span><span class="s1">: </span><span class="s2">\&quot;\\\\</span><span class="s1">u003e</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">&lt;</span><span class="s2">\&quot;</span><span class="s1">: </span><span class="s2">\&quot;\\\\</span><span class="s1">u003c</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;\\</span><span class="s1">u2028</span><span class="s2">\&quot;</span><span class="s1">: </span><span class="s2">\&quot;\\\\</span><span class="s1">u2028</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;\\</span><span class="s1">u2029</span><span class="s2">\&quot;</span><span class="s1">: </span><span class="s2">\&quot;\\\\</span><span class="s1">u2029</span><span class="s2">\&quot;\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">var ESCAPE_REGEX3 = /[&amp;&gt;&lt;</span><span class="s2">\\</span><span class="s1">u2028</span><span class="s2">\\</span><span class="s1">u2029]/g;</span><span class="s2">\n</span><span class="s1">function escapeHtml2(html) {</span><span class="s2">\n  </span><span class="s1">return html.replace(ESCAPE_REGEX3, match =&gt; ESCAPE_LOOKUP3[match]);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/server-runtime/serverHandoff.ts</span><span class="s2">\n</span><span class="s1">function createServerHandoffString(serverHandoff) {</span><span class="s2">\n  </span><span class="s1">return escapeHtml2(JSON.stringify(serverHandoff));</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/server-runtime/headers.ts</span><span class="s2">\n</span><span class="s1">import { splitCookiesString } from </span><span class="s2">\&quot;</span><span class="s1">set-cookie-parser</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">function getDocumentHeaders(build, context) {</span><span class="s2">\n  </span><span class="s1">let boundaryIdx = context.errors ? context.matches.findIndex(m =&gt; context.errors[m.route.id]) : -1;</span><span class="s2">\n  </span><span class="s1">let matches = boundaryIdx &gt;= 0 ? context.matches.slice(0, boundaryIdx + 1) : context.matches;</span><span class="s2">\n  </span><span class="s1">let errorHeaders;</span><span class="s2">\n  </span><span class="s1">if (boundaryIdx &gt;= 0) {</span><span class="s2">\n    </span><span class="s1">let {</span><span class="s2">\n      </span><span class="s1">actionHeaders,</span><span class="s2">\n      </span><span class="s1">actionData,</span><span class="s2">\n      </span><span class="s1">loaderHeaders,</span><span class="s2">\n      </span><span class="s1">loaderData</span><span class="s2">\n    </span><span class="s1">} = context;</span><span class="s2">\n    </span><span class="s1">context.matches.slice(boundaryIdx).some(match =&gt; {</span><span class="s2">\n      </span><span class="s1">let id = match.route.id;</span><span class="s2">\n      </span><span class="s1">if (actionHeaders[id] &amp;&amp; (!actionData || !actionData.hasOwnProperty(id))) {</span><span class="s2">\n        </span><span class="s1">errorHeaders = actionHeaders[id];</span><span class="s2">\n      </span><span class="s1">} else if (loaderHeaders[id] &amp;&amp; !loaderData.hasOwnProperty(id)) {</span><span class="s2">\n        </span><span class="s1">errorHeaders = loaderHeaders[id];</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return errorHeaders != null;</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return matches.reduce((parentHeaders, match, idx) =&gt; {</span><span class="s2">\n    </span><span class="s1">let {</span><span class="s2">\n      </span><span class="s1">id</span><span class="s2">\n    </span><span class="s1">} = match.route;</span><span class="s2">\n    </span><span class="s1">let route = build.routes[id];</span><span class="s2">\n    </span><span class="s1">invariant3(route, `Route with id </span><span class="s2">\&quot;</span><span class="s1">${id}</span><span class="s2">\&quot; </span><span class="s1">not found in build`);</span><span class="s2">\n    </span><span class="s1">let routeModule = route.module;</span><span class="s2">\n    </span><span class="s1">let loaderHeaders = context.loaderHeaders[id] || new Headers();</span><span class="s2">\n    </span><span class="s1">let actionHeaders = context.actionHeaders[id] || new Headers();</span><span class="s2">\n    </span><span class="s1">let includeErrorHeaders = errorHeaders != null &amp;&amp; idx === matches.length - 1;</span><span class="s2">\n    </span><span class="s1">let includeErrorCookies = includeErrorHeaders &amp;&amp; errorHeaders !== loaderHeaders &amp;&amp; errorHeaders !== actionHeaders;</span><span class="s2">\n    </span><span class="s1">if (routeModule.headers == null) {</span><span class="s2">\n      </span><span class="s1">let headers2 = new Headers(parentHeaders);</span><span class="s2">\n      </span><span class="s1">if (includeErrorCookies) {</span><span class="s2">\n        </span><span class="s1">prependCookies(errorHeaders, headers2);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">prependCookies(actionHeaders, headers2);</span><span class="s2">\n      </span><span class="s1">prependCookies(loaderHeaders, headers2);</span><span class="s2">\n      </span><span class="s1">return headers2;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let headers = new Headers(routeModule.headers ? typeof routeModule.headers === </span><span class="s2">\&quot;</span><span class="s1">function</span><span class="s2">\&quot; </span><span class="s1">? routeModule.headers({</span><span class="s2">\n      </span><span class="s1">loaderHeaders,</span><span class="s2">\n      </span><span class="s1">parentHeaders,</span><span class="s2">\n      </span><span class="s1">actionHeaders,</span><span class="s2">\n      </span><span class="s1">errorHeaders: includeErrorHeaders ? errorHeaders : void 0</span><span class="s2">\n    </span><span class="s1">}) : routeModule.headers : void 0);</span><span class="s2">\n    </span><span class="s1">if (includeErrorCookies) {</span><span class="s2">\n      </span><span class="s1">prependCookies(errorHeaders, headers);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">prependCookies(actionHeaders, headers);</span><span class="s2">\n    </span><span class="s1">prependCookies(loaderHeaders, headers);</span><span class="s2">\n    </span><span class="s1">prependCookies(parentHeaders, headers);</span><span class="s2">\n    </span><span class="s1">return headers;</span><span class="s2">\n  </span><span class="s1">}, new Headers());</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function prependCookies(parentHeaders, childHeaders) {</span><span class="s2">\n  </span><span class="s1">let parentSetCookieString = parentHeaders.get(</span><span class="s2">\&quot;</span><span class="s1">Set-Cookie</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">if (parentSetCookieString) {</span><span class="s2">\n    </span><span class="s1">let cookies = splitCookiesString(parentSetCookieString);</span><span class="s2">\n    </span><span class="s1">let childCookies = new Set(childHeaders.getSetCookie());</span><span class="s2">\n    </span><span class="s1">cookies.forEach(cookie =&gt; {</span><span class="s2">\n      </span><span class="s1">if (!childCookies.has(cookie)) {</span><span class="s2">\n        </span><span class="s1">childHeaders.append(</span><span class="s2">\&quot;</span><span class="s1">Set-Cookie</span><span class="s2">\&quot;</span><span class="s1">, cookie);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/server-runtime/single-fetch.ts</span><span class="s2">\n</span><span class="s1">var SERVER_NO_BODY_STATUS_CODES = /* @__PURE__ */new Set([...NO_BODY_STATUS_CODES, 304]);</span><span class="s2">\n</span><span class="s1">async function singleFetchAction(build, serverMode, staticHandler, request, handlerUrl, loadContext, handleError) {</span><span class="s2">\n  </span><span class="s1">try {</span><span class="s2">\n    </span><span class="s1">let respond2 = function (context) {</span><span class="s2">\n      </span><span class="s1">let headers = getDocumentHeaders(build, context);</span><span class="s2">\n      </span><span class="s1">if (isRedirectStatusCode(context.statusCode) &amp;&amp; headers.has(</span><span class="s2">\&quot;</span><span class="s1">Location</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n        </span><span class="s1">return generateSingleFetchResponse(request, build, serverMode, {</span><span class="s2">\n          </span><span class="s1">result: getSingleFetchRedirect(context.statusCode, headers, build.basename),</span><span class="s2">\n          </span><span class="s1">headers,</span><span class="s2">\n          </span><span class="s1">status: SINGLE_FETCH_REDIRECT_STATUS</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (context.errors) {</span><span class="s2">\n        </span><span class="s1">Object.values(context.errors).forEach(err =&gt; {</span><span class="s2">\n          </span><span class="s1">if (!isRouteErrorResponse(err) || err.error) {</span><span class="s2">\n            </span><span class="s1">handleError(err);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">context.errors = sanitizeErrors(context.errors, serverMode);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">let singleFetchResult;</span><span class="s2">\n      </span><span class="s1">if (context.errors) {</span><span class="s2">\n        </span><span class="s1">singleFetchResult = {</span><span class="s2">\n          </span><span class="s1">error: Object.values(context.errors)[0]</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">singleFetchResult = {</span><span class="s2">\n          </span><span class="s1">data: Object.values(context.actionData || {})[0]</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return generateSingleFetchResponse(request, build, serverMode, {</span><span class="s2">\n        </span><span class="s1">result: singleFetchResult,</span><span class="s2">\n        </span><span class="s1">headers,</span><span class="s2">\n        </span><span class="s1">status: context.statusCode</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">var respond = respond2;</span><span class="s2">\n    </span><span class="s1">let handlerRequest = new Request(handlerUrl, {</span><span class="s2">\n      </span><span class="s1">method: request.method,</span><span class="s2">\n      </span><span class="s1">body: request.body,</span><span class="s2">\n      </span><span class="s1">headers: request.headers,</span><span class="s2">\n      </span><span class="s1">signal: request.signal,</span><span class="s2">\n      </span><span class="s1">...(request.body ? {</span><span class="s2">\n        </span><span class="s1">duplex: </span><span class="s2">\&quot;</span><span class="s1">half</span><span class="s2">\&quot;\n      </span><span class="s1">} : void 0)</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">let result = await staticHandler.query(handlerRequest, {</span><span class="s2">\n      </span><span class="s1">requestContext: loadContext,</span><span class="s2">\n      </span><span class="s1">skipLoaderErrorBubbling: true,</span><span class="s2">\n      </span><span class="s1">skipRevalidation: true,</span><span class="s2">\n      </span><span class="s1">unstable_respond: respond2</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">if (!isResponse(result)) {</span><span class="s2">\n      </span><span class="s1">result = respond2(result);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (isRedirectResponse(result)) {</span><span class="s2">\n      </span><span class="s1">return generateSingleFetchResponse(request, build, serverMode, {</span><span class="s2">\n        </span><span class="s1">result: getSingleFetchRedirect(result.status, result.headers, build.basename),</span><span class="s2">\n        </span><span class="s1">headers: result.headers,</span><span class="s2">\n        </span><span class="s1">status: SINGLE_FETCH_REDIRECT_STATUS</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return result;</span><span class="s2">\n  </span><span class="s1">} catch (error) {</span><span class="s2">\n    </span><span class="s1">handleError(error);</span><span class="s2">\n    </span><span class="s1">return generateSingleFetchResponse(request, build, serverMode, {</span><span class="s2">\n      </span><span class="s1">result: {</span><span class="s2">\n        </span><span class="s1">error</span><span class="s2">\n      </span><span class="s1">},</span><span class="s2">\n      </span><span class="s1">headers: new Headers(),</span><span class="s2">\n      </span><span class="s1">status: 500</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">async function singleFetchLoaders(build, serverMode, staticHandler, request, handlerUrl, loadContext, handleError) {</span><span class="s2">\n  </span><span class="s1">try {</span><span class="s2">\n    </span><span class="s1">let respond2 = function (context) {</span><span class="s2">\n      </span><span class="s1">let headers = getDocumentHeaders(build, context);</span><span class="s2">\n      </span><span class="s1">if (isRedirectStatusCode(context.statusCode) &amp;&amp; headers.has(</span><span class="s2">\&quot;</span><span class="s1">Location</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n        </span><span class="s1">return generateSingleFetchResponse(request, build, serverMode, {</span><span class="s2">\n          </span><span class="s1">result: {</span><span class="s2">\n            </span><span class="s1">[SingleFetchRedirectSymbol]: getSingleFetchRedirect(context.statusCode, headers, build.basename)</span><span class="s2">\n          </span><span class="s1">},</span><span class="s2">\n          </span><span class="s1">headers,</span><span class="s2">\n          </span><span class="s1">status: SINGLE_FETCH_REDIRECT_STATUS</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (context.errors) {</span><span class="s2">\n        </span><span class="s1">Object.values(context.errors).forEach(err =&gt; {</span><span class="s2">\n          </span><span class="s1">if (!isRouteErrorResponse(err) || err.error) {</span><span class="s2">\n            </span><span class="s1">handleError(err);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">context.errors = sanitizeErrors(context.errors, serverMode);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">let results = {};</span><span class="s2">\n      </span><span class="s1">let loadedMatches = new Set(context.matches.filter(m =&gt; loadRouteIds ? loadRouteIds.has(m.route.id) : m.route.loader != null).map(m =&gt; m.route.id));</span><span class="s2">\n      </span><span class="s1">if (context.errors) {</span><span class="s2">\n        </span><span class="s1">for (let [id, error] of Object.entries(context.errors)) {</span><span class="s2">\n          </span><span class="s1">results[id] = {</span><span class="s2">\n            </span><span class="s1">error</span><span class="s2">\n          </span><span class="s1">};</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">for (let [id, data2] of Object.entries(context.loaderData)) {</span><span class="s2">\n        </span><span class="s1">if (!(id in results) &amp;&amp; loadedMatches.has(id)) {</span><span class="s2">\n          </span><span class="s1">results[id] = {</span><span class="s2">\n            </span><span class="s1">data: data2</span><span class="s2">\n          </span><span class="s1">};</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return generateSingleFetchResponse(request, build, serverMode, {</span><span class="s2">\n        </span><span class="s1">result: results,</span><span class="s2">\n        </span><span class="s1">headers,</span><span class="s2">\n        </span><span class="s1">status: context.statusCode</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">var respond = respond2;</span><span class="s2">\n    </span><span class="s1">let handlerRequest = new Request(handlerUrl, {</span><span class="s2">\n      </span><span class="s1">headers: request.headers,</span><span class="s2">\n      </span><span class="s1">signal: request.signal</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">let routesParam = new URL(request.url).searchParams.get(</span><span class="s2">\&quot;</span><span class="s1">_routes</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">let loadRouteIds = routesParam ? new Set(routesParam.split(</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\&quot;</span><span class="s1">)) : null;</span><span class="s2">\n    </span><span class="s1">let result = await staticHandler.query(handlerRequest, {</span><span class="s2">\n      </span><span class="s1">requestContext: loadContext,</span><span class="s2">\n      </span><span class="s1">filterMatchesToLoad: m =&gt; !loadRouteIds || loadRouteIds.has(m.route.id),</span><span class="s2">\n      </span><span class="s1">skipLoaderErrorBubbling: true,</span><span class="s2">\n      </span><span class="s1">unstable_respond: respond2</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">if (!isResponse(result)) {</span><span class="s2">\n      </span><span class="s1">result = respond2(result);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (isRedirectResponse(result)) {</span><span class="s2">\n      </span><span class="s1">return generateSingleFetchResponse(request, build, serverMode, {</span><span class="s2">\n        </span><span class="s1">result: {</span><span class="s2">\n          </span><span class="s1">[SingleFetchRedirectSymbol]: getSingleFetchRedirect(result.status, result.headers, build.basename)</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">headers: result.headers,</span><span class="s2">\n        </span><span class="s1">status: SINGLE_FETCH_REDIRECT_STATUS</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return result;</span><span class="s2">\n  </span><span class="s1">} catch (error) {</span><span class="s2">\n    </span><span class="s1">handleError(error);</span><span class="s2">\n    </span><span class="s1">return generateSingleFetchResponse(request, build, serverMode, {</span><span class="s2">\n      </span><span class="s1">result: {</span><span class="s2">\n        </span><span class="s1">root: {</span><span class="s2">\n          </span><span class="s1">error</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">},</span><span class="s2">\n      </span><span class="s1">headers: new Headers(),</span><span class="s2">\n      </span><span class="s1">status: 500</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function generateSingleFetchResponse(request, build, serverMode, {</span><span class="s2">\n  </span><span class="s1">result,</span><span class="s2">\n  </span><span class="s1">headers,</span><span class="s2">\n  </span><span class="s1">status</span><span class="s2">\n</span><span class="s1">}) {</span><span class="s2">\n  </span><span class="s1">let resultHeaders = new Headers(headers);</span><span class="s2">\n  </span><span class="s1">resultHeaders.set(</span><span class="s2">\&quot;</span><span class="s1">X-Remix-Response</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">yes</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">if (SERVER_NO_BODY_STATUS_CODES.has(status)) {</span><span class="s2">\n    </span><span class="s1">return new Response(null, {</span><span class="s2">\n      </span><span class="s1">status,</span><span class="s2">\n      </span><span class="s1">headers: resultHeaders</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">resultHeaders.set(</span><span class="s2">\&quot;</span><span class="s1">Content-Type</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">text/x-script</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">return new Response(encodeViaTurboStream(result, request.signal, build.entry.module.streamTimeout, serverMode), {</span><span class="s2">\n    </span><span class="s1">status: status || 200,</span><span class="s2">\n    </span><span class="s1">headers: resultHeaders</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getSingleFetchRedirect(status, headers, basename) {</span><span class="s2">\n  </span><span class="s1">let redirect2 = headers.get(</span><span class="s2">\&quot;</span><span class="s1">Location</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">if (basename) {</span><span class="s2">\n    </span><span class="s1">redirect2 = stripBasename(redirect2, basename) || redirect2;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">redirect: redirect2,</span><span class="s2">\n    </span><span class="s1">status,</span><span class="s2">\n    </span><span class="s1">revalidate:</span><span class="s2">\n    </span><span class="s1">// Technically X-Remix-Revalidate isn't needed here - that was an implementation</span><span class="s2">\n    </span><span class="s1">// detail of ?_data requests as our way to tell the front end to revalidate when</span><span class="s2">\n    </span><span class="s1">// we didn't have a response body to include that information in.</span><span class="s2">\n    </span><span class="s1">// With single fetch, we tell the front end via this revalidate boolean field.</span><span class="s2">\n    </span><span class="s1">// However, we're respecting it for now because it may be something folks have</span><span class="s2">\n    </span><span class="s1">// used in their own responses</span><span class="s2">\n    </span><span class="s1">// TODO(v3): Consider removing or making this official public API</span><span class="s2">\n    </span><span class="s1">headers.has(</span><span class="s2">\&quot;</span><span class="s1">X-Remix-Revalidate</span><span class="s2">\&quot;</span><span class="s1">) || headers.has(</span><span class="s2">\&quot;</span><span class="s1">Set-Cookie</span><span class="s2">\&quot;</span><span class="s1">),</span><span class="s2">\n    </span><span class="s1">reload: headers.has(</span><span class="s2">\&quot;</span><span class="s1">X-Remix-Reload-Document</span><span class="s2">\&quot;</span><span class="s1">),</span><span class="s2">\n    </span><span class="s1">replace: headers.has(</span><span class="s2">\&quot;</span><span class="s1">X-Remix-Replace</span><span class="s2">\&quot;</span><span class="s1">)</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function encodeViaTurboStream(data2, requestSignal, streamTimeout, serverMode) {</span><span class="s2">\n  </span><span class="s1">let controller = new AbortController();</span><span class="s2">\n  </span><span class="s1">let timeoutId = setTimeout(() =&gt; controller.abort(new Error(</span><span class="s2">\&quot;</span><span class="s1">Server Timeout</span><span class="s2">\&quot;</span><span class="s1">)), typeof streamTimeout === </span><span class="s2">\&quot;</span><span class="s1">number</span><span class="s2">\&quot; </span><span class="s1">? streamTimeout : 4950);</span><span class="s2">\n  </span><span class="s1">requestSignal.addEventListener(</span><span class="s2">\&quot;</span><span class="s1">abort</span><span class="s2">\&quot;</span><span class="s1">, () =&gt; clearTimeout(timeoutId));</span><span class="s2">\n  </span><span class="s1">return encode(data2, {</span><span class="s2">\n    </span><span class="s1">signal: controller.signal,</span><span class="s2">\n    </span><span class="s1">plugins: [value =&gt; {</span><span class="s2">\n      </span><span class="s1">if (value instanceof Error) {</span><span class="s2">\n        </span><span class="s1">let {</span><span class="s2">\n          </span><span class="s1">name,</span><span class="s2">\n          </span><span class="s1">message,</span><span class="s2">\n          </span><span class="s1">stack</span><span class="s2">\n        </span><span class="s1">} = serverMode === </span><span class="s2">\&quot;</span><span class="s1">production</span><span class="s2">\&quot; </span><span class="s1">/* Production */ ? sanitizeError(value, serverMode) : value;</span><span class="s2">\n        </span><span class="s1">return [</span><span class="s2">\&quot;</span><span class="s1">SanitizedError</span><span class="s2">\&quot;</span><span class="s1">, name, message, stack];</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (value instanceof ErrorResponseImpl) {</span><span class="s2">\n        </span><span class="s1">let {</span><span class="s2">\n          </span><span class="s1">data: data3,</span><span class="s2">\n          </span><span class="s1">status,</span><span class="s2">\n          </span><span class="s1">statusText</span><span class="s2">\n        </span><span class="s1">} = value;</span><span class="s2">\n        </span><span class="s1">return [</span><span class="s2">\&quot;</span><span class="s1">ErrorResponse</span><span class="s2">\&quot;</span><span class="s1">, data3, status, statusText];</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (value &amp;&amp; typeof value === </span><span class="s2">\&quot;</span><span class="s1">object</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; SingleFetchRedirectSymbol in value) {</span><span class="s2">\n        </span><span class="s1">return [</span><span class="s2">\&quot;</span><span class="s1">SingleFetchRedirect</span><span class="s2">\&quot;</span><span class="s1">, value[SingleFetchRedirectSymbol]];</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}],</span><span class="s2">\n    </span><span class="s1">postPlugins: [value =&gt; {</span><span class="s2">\n      </span><span class="s1">if (!value) return;</span><span class="s2">\n      </span><span class="s1">if (typeof value !== </span><span class="s2">\&quot;</span><span class="s1">object</span><span class="s2">\&quot;</span><span class="s1">) return;</span><span class="s2">\n      </span><span class="s1">return [</span><span class="s2">\&quot;</span><span class="s1">SingleFetchClassInstance</span><span class="s2">\&quot;</span><span class="s1">, Object.fromEntries(Object.entries(value))];</span><span class="s2">\n    </span><span class="s1">}, () =&gt; [</span><span class="s2">\&quot;</span><span class="s1">SingleFetchFallback</span><span class="s2">\&quot;</span><span class="s1">]]</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/server-runtime/server.ts</span><span class="s2">\n</span><span class="s1">function derive(build, mode) {</span><span class="s2">\n  </span><span class="s1">let routes = createRoutes(build.routes);</span><span class="s2">\n  </span><span class="s1">let dataRoutes = createStaticHandlerDataRoutes(build.routes, build.future);</span><span class="s2">\n  </span><span class="s1">let serverMode = isServerMode(mode) ? mode : </span><span class="s2">\&quot;</span><span class="s1">production</span><span class="s2">\&quot; </span><span class="s1">/* Production */;</span><span class="s2">\n  </span><span class="s1">let staticHandler = createStaticHandler(dataRoutes, {</span><span class="s2">\n    </span><span class="s1">basename: build.basename</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">let errorHandler = build.entry.module.handleError || ((error, {</span><span class="s2">\n    </span><span class="s1">request</span><span class="s2">\n  </span><span class="s1">}) =&gt; {</span><span class="s2">\n    </span><span class="s1">if (serverMode !== </span><span class="s2">\&quot;</span><span class="s1">test</span><span class="s2">\&quot; </span><span class="s1">/* Test */ &amp;&amp; !request.signal.aborted) {</span><span class="s2">\n      </span><span class="s1">console.error(</span><span class="s2">\n      </span><span class="s1">// @ts-expect-error This is </span><span class="s2">\&quot;</span><span class="s1">private</span><span class="s2">\&quot; </span><span class="s1">from users but intended for internal use</span><span class="s2">\n      </span><span class="s1">isRouteErrorResponse(error) &amp;&amp; error.error ? error.error : error);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">routes,</span><span class="s2">\n    </span><span class="s1">dataRoutes,</span><span class="s2">\n    </span><span class="s1">serverMode,</span><span class="s2">\n    </span><span class="s1">staticHandler,</span><span class="s2">\n    </span><span class="s1">errorHandler</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var createRequestHandler = (build, mode) =&gt; {</span><span class="s2">\n  </span><span class="s1">let _build;</span><span class="s2">\n  </span><span class="s1">let routes;</span><span class="s2">\n  </span><span class="s1">let serverMode;</span><span class="s2">\n  </span><span class="s1">let staticHandler;</span><span class="s2">\n  </span><span class="s1">let errorHandler;</span><span class="s2">\n  </span><span class="s1">return async function requestHandler(request, initialContext) {</span><span class="s2">\n    </span><span class="s1">_build = typeof build === </span><span class="s2">\&quot;</span><span class="s1">function</span><span class="s2">\&quot; </span><span class="s1">? await build() : build;</span><span class="s2">\n    </span><span class="s1">if (typeof build === </span><span class="s2">\&quot;</span><span class="s1">function</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">let derived = derive(_build, mode);</span><span class="s2">\n      </span><span class="s1">routes = derived.routes;</span><span class="s2">\n      </span><span class="s1">serverMode = derived.serverMode;</span><span class="s2">\n      </span><span class="s1">staticHandler = derived.staticHandler;</span><span class="s2">\n      </span><span class="s1">errorHandler = derived.errorHandler;</span><span class="s2">\n    </span><span class="s1">} else if (!routes || !serverMode || !staticHandler || !errorHandler) {</span><span class="s2">\n      </span><span class="s1">let derived = derive(_build, mode);</span><span class="s2">\n      </span><span class="s1">routes = derived.routes;</span><span class="s2">\n      </span><span class="s1">serverMode = derived.serverMode;</span><span class="s2">\n      </span><span class="s1">staticHandler = derived.staticHandler;</span><span class="s2">\n      </span><span class="s1">errorHandler = derived.errorHandler;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let params = {};</span><span class="s2">\n    </span><span class="s1">let loadContext;</span><span class="s2">\n    </span><span class="s1">let handleError = error =&gt; {</span><span class="s2">\n      </span><span class="s1">if (mode === </span><span class="s2">\&quot;</span><span class="s1">development</span><span class="s2">\&quot; </span><span class="s1">/* Development */) {</span><span class="s2">\n        </span><span class="s1">getDevServerHooks()?.processRequestError?.(error);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">errorHandler(error, {</span><span class="s2">\n        </span><span class="s1">context: loadContext,</span><span class="s2">\n        </span><span class="s1">params,</span><span class="s2">\n        </span><span class="s1">request</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">if (_build.future.unstable_middleware) {</span><span class="s2">\n      </span><span class="s1">if (initialContext == null) {</span><span class="s2">\n        </span><span class="s1">loadContext = new unstable_RouterContextProvider();</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">try {</span><span class="s2">\n          </span><span class="s1">loadContext = new unstable_RouterContextProvider(initialContext);</span><span class="s2">\n        </span><span class="s1">} catch (e) {</span><span class="s2">\n          </span><span class="s1">let error = new Error(`Unable to create initial </span><span class="s2">\\</span><span class="s1">`unstable_RouterContextProvider</span><span class="s2">\\</span><span class="s1">` instance. Please confirm you are returning an instance of </span><span class="s2">\\</span><span class="s1">`Map&lt;unstable_routerContext, unknown&gt;</span><span class="s2">\\</span><span class="s1">` from your </span><span class="s2">\\</span><span class="s1">`getLoadContext</span><span class="s2">\\</span><span class="s1">` function.</span><span class="s2">\n\n</span><span class="s1">Error: ${e instanceof Error ? e.toString() : e}`);</span><span class="s2">\n          </span><span class="s1">handleError(error);</span><span class="s2">\n          </span><span class="s1">return returnLastResortErrorResponse(error, serverMode);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">loadContext = initialContext || {};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let url = new URL(request.url);</span><span class="s2">\n    </span><span class="s1">let normalizedBasename = _build.basename || </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">let normalizedPath = url.pathname;</span><span class="s2">\n    </span><span class="s1">if (stripBasename(normalizedPath, normalizedBasename) === </span><span class="s2">\&quot;</span><span class="s1">/_root.data</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">normalizedPath = normalizedBasename;</span><span class="s2">\n    </span><span class="s1">} else if (normalizedPath.endsWith(</span><span class="s2">\&quot;</span><span class="s1">.data</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n      </span><span class="s1">normalizedPath = normalizedPath.replace(/</span><span class="s2">\\</span><span class="s1">.data$/, </span><span class="s2">\&quot;\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (stripBasename(normalizedPath, normalizedBasename) !== </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; normalizedPath.endsWith(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n      </span><span class="s1">normalizedPath = normalizedPath.slice(0, -1);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let isSpaMode = getBuildTimeHeader(request, </span><span class="s2">\&quot;</span><span class="s1">X-React-Router-SPA-Mode</span><span class="s2">\&quot;</span><span class="s1">) === </span><span class="s2">\&quot;</span><span class="s1">yes</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">if (!_build.ssr) {</span><span class="s2">\n      </span><span class="s1">if (_build.prerender.length === 0) {</span><span class="s2">\n        </span><span class="s1">isSpaMode = true;</span><span class="s2">\n      </span><span class="s1">} else if (!_build.prerender.includes(normalizedPath) &amp;&amp; !_build.prerender.includes(normalizedPath + </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n        </span><span class="s1">if (url.pathname.endsWith(</span><span class="s2">\&quot;</span><span class="s1">.data</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n          </span><span class="s1">errorHandler(new ErrorResponseImpl(404, </span><span class="s2">\&quot;</span><span class="s1">Not Found</span><span class="s2">\&quot;</span><span class="s1">, `Refusing to SSR the path </span><span class="s2">\\</span><span class="s1">`${normalizedPath}</span><span class="s2">\\</span><span class="s1">` because </span><span class="s2">\\</span><span class="s1">`ssr:false</span><span class="s2">\\</span><span class="s1">` is set and the path is not included in the </span><span class="s2">\\</span><span class="s1">`prerender</span><span class="s2">\\</span><span class="s1">` config, so in production the path will be a 404.`), {</span><span class="s2">\n            </span><span class="s1">context: loadContext,</span><span class="s2">\n            </span><span class="s1">params,</span><span class="s2">\n            </span><span class="s1">request</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n          </span><span class="s1">return new Response(</span><span class="s2">\&quot;</span><span class="s1">Not Found</span><span class="s2">\&quot;</span><span class="s1">, {</span><span class="s2">\n            </span><span class="s1">status: 404,</span><span class="s2">\n            </span><span class="s1">statusText: </span><span class="s2">\&quot;</span><span class="s1">Not Found</span><span class="s2">\&quot;\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">isSpaMode = true;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let manifestUrl = getManifestPath(_build.routeDiscovery.manifestPath, normalizedBasename);</span><span class="s2">\n    </span><span class="s1">if (url.pathname === manifestUrl) {</span><span class="s2">\n      </span><span class="s1">try {</span><span class="s2">\n        </span><span class="s1">let res = await handleManifestRequest(_build, routes, url);</span><span class="s2">\n        </span><span class="s1">return res;</span><span class="s2">\n      </span><span class="s1">} catch (e) {</span><span class="s2">\n        </span><span class="s1">handleError(e);</span><span class="s2">\n        </span><span class="s1">return new Response(</span><span class="s2">\&quot;</span><span class="s1">Unknown Server Error</span><span class="s2">\&quot;</span><span class="s1">, {</span><span class="s2">\n          </span><span class="s1">status: 500</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let matches = matchServerRoutes(routes, normalizedPath, _build.basename);</span><span class="s2">\n    </span><span class="s1">if (matches &amp;&amp; matches.length &gt; 0) {</span><span class="s2">\n      </span><span class="s1">Object.assign(params, matches[0].params);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let response;</span><span class="s2">\n    </span><span class="s1">if (url.pathname.endsWith(</span><span class="s2">\&quot;</span><span class="s1">.data</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n      </span><span class="s1">let handlerUrl = new URL(request.url);</span><span class="s2">\n      </span><span class="s1">handlerUrl.pathname = normalizedPath;</span><span class="s2">\n      </span><span class="s1">let singleFetchMatches = matchServerRoutes(routes, handlerUrl.pathname, _build.basename);</span><span class="s2">\n      </span><span class="s1">response = await handleSingleFetchRequest(serverMode, _build, staticHandler, request, handlerUrl, loadContext, handleError);</span><span class="s2">\n      </span><span class="s1">if (_build.entry.module.handleDataRequest) {</span><span class="s2">\n        </span><span class="s1">response = await _build.entry.module.handleDataRequest(response, {</span><span class="s2">\n          </span><span class="s1">context: loadContext,</span><span class="s2">\n          </span><span class="s1">params: singleFetchMatches ? singleFetchMatches[0].params : {},</span><span class="s2">\n          </span><span class="s1">request</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">if (isRedirectResponse(response)) {</span><span class="s2">\n          </span><span class="s1">let result = getSingleFetchRedirect(response.status, response.headers, _build.basename);</span><span class="s2">\n          </span><span class="s1">if (request.method === </span><span class="s2">\&quot;</span><span class="s1">GET</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n            </span><span class="s1">result = {</span><span class="s2">\n              </span><span class="s1">[SingleFetchRedirectSymbol]: result</span><span class="s2">\n            </span><span class="s1">};</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">let headers = new Headers(response.headers);</span><span class="s2">\n          </span><span class="s1">headers.set(</span><span class="s2">\&quot;</span><span class="s1">Content-Type</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">text/x-script</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">return new Response(encodeViaTurboStream(result, request.signal, _build.entry.module.streamTimeout, serverMode), {</span><span class="s2">\n            </span><span class="s1">status: SINGLE_FETCH_REDIRECT_STATUS,</span><span class="s2">\n            </span><span class="s1">headers</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else if (!isSpaMode &amp;&amp; matches &amp;&amp; matches[matches.length - 1].route.module.default == null &amp;&amp; matches[matches.length - 1].route.module.ErrorBoundary == null) {</span><span class="s2">\n      </span><span class="s1">response = await handleResourceRequest(serverMode, _build, staticHandler, matches.slice(-1)[0].route.id, request, loadContext, handleError);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">let {</span><span class="s2">\n        </span><span class="s1">pathname</span><span class="s2">\n      </span><span class="s1">} = url;</span><span class="s2">\n      </span><span class="s1">let criticalCss = void 0;</span><span class="s2">\n      </span><span class="s1">if (_build.unstable_getCriticalCss) {</span><span class="s2">\n        </span><span class="s1">criticalCss = await _build.unstable_getCriticalCss({</span><span class="s2">\n          </span><span class="s1">pathname</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">} else if (mode === </span><span class="s2">\&quot;</span><span class="s1">development</span><span class="s2">\&quot; </span><span class="s1">/* Development */ &amp;&amp; getDevServerHooks()?.getCriticalCss) {</span><span class="s2">\n        </span><span class="s1">criticalCss = await getDevServerHooks()?.getCriticalCss?.(pathname);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">response = await handleDocumentRequest(serverMode, _build, staticHandler, request, loadContext, handleError, isSpaMode, criticalCss);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (request.method === </span><span class="s2">\&quot;</span><span class="s1">HEAD</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">return new Response(null, {</span><span class="s2">\n        </span><span class="s1">headers: response.headers,</span><span class="s2">\n        </span><span class="s1">status: response.status,</span><span class="s2">\n        </span><span class="s1">statusText: response.statusText</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return response;</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">async function handleManifestRequest(build, routes, url) {</span><span class="s2">\n  </span><span class="s1">if (build.assets.version !== url.searchParams.get(</span><span class="s2">\&quot;</span><span class="s1">version</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n    </span><span class="s1">return new Response(null, {</span><span class="s2">\n      </span><span class="s1">status: 204,</span><span class="s2">\n      </span><span class="s1">headers: {</span><span class="s2">\n        \&quot;</span><span class="s1">X-Remix-Reload-Document</span><span class="s2">\&quot;</span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">true</span><span class="s2">\&quot;\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let patches = {};</span><span class="s2">\n  </span><span class="s1">if (url.searchParams.has(</span><span class="s2">\&quot;</span><span class="s1">p</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n    </span><span class="s1">let paths = /* @__PURE__ */new Set();</span><span class="s2">\n    </span><span class="s1">url.searchParams.getAll(</span><span class="s2">\&quot;</span><span class="s1">p</span><span class="s2">\&quot;</span><span class="s1">).forEach(path =&gt; {</span><span class="s2">\n      </span><span class="s1">if (!path.startsWith(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n        </span><span class="s1">path = `/${path}`;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">let segments = path.split(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">).slice(1);</span><span class="s2">\n      </span><span class="s1">segments.forEach((_, i) =&gt; {</span><span class="s2">\n        </span><span class="s1">let partialPath = segments.slice(0, i + 1).join(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">paths.add(`/${partialPath}`);</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">for (let path of paths) {</span><span class="s2">\n      </span><span class="s1">let matches = matchServerRoutes(routes, path, build.basename);</span><span class="s2">\n      </span><span class="s1">if (matches) {</span><span class="s2">\n        </span><span class="s1">for (let match of matches) {</span><span class="s2">\n          </span><span class="s1">let routeId = match.route.id;</span><span class="s2">\n          </span><span class="s1">let route = build.assets.routes[routeId];</span><span class="s2">\n          </span><span class="s1">if (route) {</span><span class="s2">\n            </span><span class="s1">patches[routeId] = route;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return Response.json(patches, {</span><span class="s2">\n      </span><span class="s1">headers: {</span><span class="s2">\n        \&quot;</span><span class="s1">Cache-Control</span><span class="s2">\&quot;</span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">public, max-age=31536000, immutable</span><span class="s2">\&quot;\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return new Response(</span><span class="s2">\&quot;</span><span class="s1">Invalid Request</span><span class="s2">\&quot;</span><span class="s1">, {</span><span class="s2">\n    </span><span class="s1">status: 400</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">async function handleSingleFetchRequest(serverMode, build, staticHandler, request, handlerUrl, loadContext, handleError) {</span><span class="s2">\n  </span><span class="s1">let response = request.method !== </span><span class="s2">\&quot;</span><span class="s1">GET</span><span class="s2">\&quot; </span><span class="s1">? await singleFetchAction(build, serverMode, staticHandler, request, handlerUrl, loadContext, handleError) : await singleFetchLoaders(build, serverMode, staticHandler, request, handlerUrl, loadContext, handleError);</span><span class="s2">\n  </span><span class="s1">return response;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">async function handleDocumentRequest(serverMode, build, staticHandler, request, loadContext, handleError, isSpaMode, criticalCss) {</span><span class="s2">\n  </span><span class="s1">try {</span><span class="s2">\n    </span><span class="s1">let response = await staticHandler.query(request, {</span><span class="s2">\n      </span><span class="s1">requestContext: loadContext,</span><span class="s2">\n      </span><span class="s1">unstable_respond: build.future.unstable_middleware ? ctx =&gt; renderHtml(ctx, isSpaMode) : void 0</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">return isResponse(response) ? response : renderHtml(response, isSpaMode);</span><span class="s2">\n  </span><span class="s1">} catch (error) {</span><span class="s2">\n    </span><span class="s1">handleError(error);</span><span class="s2">\n    </span><span class="s1">return new Response(null, {</span><span class="s2">\n      </span><span class="s1">status: 500</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">async function renderHtml(context, isSpaMode2) {</span><span class="s2">\n    </span><span class="s1">if (isResponse(context)) {</span><span class="s2">\n      </span><span class="s1">return context;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let headers = getDocumentHeaders(build, context);</span><span class="s2">\n    </span><span class="s1">if (SERVER_NO_BODY_STATUS_CODES.has(context.statusCode)) {</span><span class="s2">\n      </span><span class="s1">return new Response(null, {</span><span class="s2">\n        </span><span class="s1">status: context.statusCode,</span><span class="s2">\n        </span><span class="s1">headers</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (context.errors) {</span><span class="s2">\n      </span><span class="s1">Object.values(context.errors).forEach(err =&gt; {</span><span class="s2">\n        </span><span class="s1">if (!isRouteErrorResponse(err) || err.error) {</span><span class="s2">\n          </span><span class="s1">handleError(err);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">context.errors = sanitizeErrors(context.errors, serverMode);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let state = {</span><span class="s2">\n      </span><span class="s1">loaderData: context.loaderData,</span><span class="s2">\n      </span><span class="s1">actionData: context.actionData,</span><span class="s2">\n      </span><span class="s1">errors: serializeErrors2(context.errors, serverMode)</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">let baseServerHandoff = {</span><span class="s2">\n      </span><span class="s1">basename: build.basename,</span><span class="s2">\n      </span><span class="s1">future: build.future,</span><span class="s2">\n      </span><span class="s1">routeDiscovery: build.routeDiscovery,</span><span class="s2">\n      </span><span class="s1">ssr: build.ssr,</span><span class="s2">\n      </span><span class="s1">isSpaMode: isSpaMode2</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">let entryContext = {</span><span class="s2">\n      </span><span class="s1">manifest: build.assets,</span><span class="s2">\n      </span><span class="s1">routeModules: createEntryRouteModules(build.routes),</span><span class="s2">\n      </span><span class="s1">staticHandlerContext: context,</span><span class="s2">\n      </span><span class="s1">criticalCss,</span><span class="s2">\n      </span><span class="s1">serverHandoffString: createServerHandoffString({</span><span class="s2">\n        </span><span class="s1">...baseServerHandoff,</span><span class="s2">\n        </span><span class="s1">criticalCss</span><span class="s2">\n      </span><span class="s1">}),</span><span class="s2">\n      </span><span class="s1">serverHandoffStream: encodeViaTurboStream(state, request.signal, build.entry.module.streamTimeout, serverMode),</span><span class="s2">\n      </span><span class="s1">renderMeta: {},</span><span class="s2">\n      </span><span class="s1">future: build.future,</span><span class="s2">\n      </span><span class="s1">ssr: build.ssr,</span><span class="s2">\n      </span><span class="s1">routeDiscovery: build.routeDiscovery,</span><span class="s2">\n      </span><span class="s1">isSpaMode: isSpaMode2,</span><span class="s2">\n      </span><span class="s1">serializeError: err =&gt; serializeError(err, serverMode)</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">let handleDocumentRequestFunction = build.entry.module.default;</span><span class="s2">\n    </span><span class="s1">try {</span><span class="s2">\n      </span><span class="s1">return await handleDocumentRequestFunction(request, context.statusCode, headers, entryContext, loadContext);</span><span class="s2">\n    </span><span class="s1">} catch (error) {</span><span class="s2">\n      </span><span class="s1">handleError(error);</span><span class="s2">\n      </span><span class="s1">let errorForSecondRender = error;</span><span class="s2">\n      </span><span class="s1">if (isResponse(error)) {</span><span class="s2">\n        </span><span class="s1">try {</span><span class="s2">\n          </span><span class="s1">let data2 = await unwrapResponse(error);</span><span class="s2">\n          </span><span class="s1">errorForSecondRender = new ErrorResponseImpl(error.status, error.statusText, data2);</span><span class="s2">\n        </span><span class="s1">} catch (e) {}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">context = getStaticContextFromError(staticHandler.dataRoutes, context, errorForSecondRender);</span><span class="s2">\n      </span><span class="s1">if (context.errors) {</span><span class="s2">\n        </span><span class="s1">context.errors = sanitizeErrors(context.errors, serverMode);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">let state2 = {</span><span class="s2">\n        </span><span class="s1">loaderData: context.loaderData,</span><span class="s2">\n        </span><span class="s1">actionData: context.actionData,</span><span class="s2">\n        </span><span class="s1">errors: serializeErrors2(context.errors, serverMode)</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">entryContext = {</span><span class="s2">\n        </span><span class="s1">...entryContext,</span><span class="s2">\n        </span><span class="s1">staticHandlerContext: context,</span><span class="s2">\n        </span><span class="s1">serverHandoffString: createServerHandoffString(baseServerHandoff),</span><span class="s2">\n        </span><span class="s1">serverHandoffStream: encodeViaTurboStream(state2, request.signal, build.entry.module.streamTimeout, serverMode),</span><span class="s2">\n        </span><span class="s1">renderMeta: {}</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">try {</span><span class="s2">\n        </span><span class="s1">return await handleDocumentRequestFunction(request, context.statusCode, headers, entryContext, loadContext);</span><span class="s2">\n      </span><span class="s1">} catch (error2) {</span><span class="s2">\n        </span><span class="s1">handleError(error2);</span><span class="s2">\n        </span><span class="s1">return returnLastResortErrorResponse(error2, serverMode);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">async function handleResourceRequest(serverMode, build, staticHandler, routeId, request, loadContext, handleError) {</span><span class="s2">\n  </span><span class="s1">try {</span><span class="s2">\n    </span><span class="s1">let response = await staticHandler.queryRoute(request, {</span><span class="s2">\n      </span><span class="s1">routeId,</span><span class="s2">\n      </span><span class="s1">requestContext: loadContext,</span><span class="s2">\n      </span><span class="s1">unstable_respond: build.future.unstable_middleware ? ctx =&gt; ctx : void 0</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">if (isResponse(response)) {</span><span class="s2">\n      </span><span class="s1">return response;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (typeof response === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">return new Response(response);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return Response.json(response);</span><span class="s2">\n  </span><span class="s1">} catch (error) {</span><span class="s2">\n    </span><span class="s1">if (isResponse(error)) {</span><span class="s2">\n      </span><span class="s1">error.headers.set(</span><span class="s2">\&quot;</span><span class="s1">X-Remix-Catch</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">yes</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">return error;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (isRouteErrorResponse(error)) {</span><span class="s2">\n      </span><span class="s1">if (error) {</span><span class="s2">\n        </span><span class="s1">handleError(error);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return errorResponseToJson(error, serverMode);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (error instanceof Error &amp;&amp; error.message === </span><span class="s2">\&quot;</span><span class="s1">Expected a response from queryRoute</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">let newError = new Error(</span><span class="s2">\&quot;</span><span class="s1">Expected a Response to be returned from resource route handler</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">handleError(newError);</span><span class="s2">\n      </span><span class="s1">return returnLastResortErrorResponse(newError, serverMode);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">handleError(error);</span><span class="s2">\n    </span><span class="s1">return returnLastResortErrorResponse(error, serverMode);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function errorResponseToJson(errorResponse, serverMode) {</span><span class="s2">\n  </span><span class="s1">return Response.json(serializeError(</span><span class="s2">\n  </span><span class="s1">// @ts-expect-error This is </span><span class="s2">\&quot;</span><span class="s1">private</span><span class="s2">\&quot; </span><span class="s1">from users but intended for internal use</span><span class="s2">\n  </span><span class="s1">errorResponse.error || new Error(</span><span class="s2">\&quot;</span><span class="s1">Unexpected Server Error</span><span class="s2">\&quot;</span><span class="s1">), serverMode), {</span><span class="s2">\n    </span><span class="s1">status: errorResponse.status,</span><span class="s2">\n    </span><span class="s1">statusText: errorResponse.statusText,</span><span class="s2">\n    </span><span class="s1">headers: {</span><span class="s2">\n      \&quot;</span><span class="s1">X-Remix-Error</span><span class="s2">\&quot;</span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">yes</span><span class="s2">\&quot;\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function returnLastResortErrorResponse(error, serverMode) {</span><span class="s2">\n  </span><span class="s1">let message = </span><span class="s2">\&quot;</span><span class="s1">Unexpected Server Error</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">if (serverMode !== </span><span class="s2">\&quot;</span><span class="s1">production</span><span class="s2">\&quot; </span><span class="s1">/* Production */) {</span><span class="s2">\n    </span><span class="s1">message += `</span><span class="s2">\n\n</span><span class="s1">${String(error)}`;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return new Response(message, {</span><span class="s2">\n    </span><span class="s1">status: 500,</span><span class="s2">\n    </span><span class="s1">headers: {</span><span class="s2">\n      \&quot;</span><span class="s1">Content-Type</span><span class="s2">\&quot;</span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">text/plain</span><span class="s2">\&quot;\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function unwrapResponse(response) {</span><span class="s2">\n  </span><span class="s1">let contentType = response.headers.get(</span><span class="s2">\&quot;</span><span class="s1">Content-Type</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">return contentType &amp;&amp; /</span><span class="s2">\\</span><span class="s1">bapplication</span><span class="s2">\\</span><span class="s1">/json</span><span class="s2">\\</span><span class="s1">b/.test(contentType) ? response.body == null ? null : response.json() : response.text();</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/server-runtime/sessions.ts</span><span class="s2">\n</span><span class="s1">function flash(name) {</span><span class="s2">\n  </span><span class="s1">return `__flash_${name}__`;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var createSession = (initialData = {}, id = </span><span class="s2">\&quot;\&quot;</span><span class="s1">) =&gt; {</span><span class="s2">\n  </span><span class="s1">let map = new Map(Object.entries(initialData));</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">get id() {</span><span class="s2">\n      </span><span class="s1">return id;</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">get data() {</span><span class="s2">\n      </span><span class="s1">return Object.fromEntries(map);</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">has(name) {</span><span class="s2">\n      </span><span class="s1">return map.has(name) || map.has(flash(name));</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">get(name) {</span><span class="s2">\n      </span><span class="s1">if (map.has(name)) return map.get(name);</span><span class="s2">\n      </span><span class="s1">let flashName = flash(name);</span><span class="s2">\n      </span><span class="s1">if (map.has(flashName)) {</span><span class="s2">\n        </span><span class="s1">let value = map.get(flashName);</span><span class="s2">\n        </span><span class="s1">map.delete(flashName);</span><span class="s2">\n        </span><span class="s1">return value;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return void 0;</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">set(name, value) {</span><span class="s2">\n      </span><span class="s1">map.set(name, value);</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">flash(name, value) {</span><span class="s2">\n      </span><span class="s1">map.set(flash(name), value);</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">unset(name) {</span><span class="s2">\n      </span><span class="s1">map.delete(name);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">var isSession = object =&gt; {</span><span class="s2">\n  </span><span class="s1">return object != null &amp;&amp; typeof object.id === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; typeof object.data !== </span><span class="s2">\&quot;</span><span class="s1">undefined</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; typeof object.has === </span><span class="s2">\&quot;</span><span class="s1">function</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; typeof object.get === </span><span class="s2">\&quot;</span><span class="s1">function</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; typeof object.set === </span><span class="s2">\&quot;</span><span class="s1">function</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; typeof object.flash === </span><span class="s2">\&quot;</span><span class="s1">function</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; typeof object.unset === </span><span class="s2">\&quot;</span><span class="s1">function</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">function createSessionStorage({</span><span class="s2">\n  </span><span class="s1">cookie: cookieArg,</span><span class="s2">\n  </span><span class="s1">createData,</span><span class="s2">\n  </span><span class="s1">readData,</span><span class="s2">\n  </span><span class="s1">updateData,</span><span class="s2">\n  </span><span class="s1">deleteData</span><span class="s2">\n</span><span class="s1">}) {</span><span class="s2">\n  </span><span class="s1">let cookie = isCookie(cookieArg) ? cookieArg : createCookie(cookieArg?.name || </span><span class="s2">\&quot;</span><span class="s1">__session</span><span class="s2">\&quot;</span><span class="s1">, cookieArg);</span><span class="s2">\n  </span><span class="s1">warnOnceAboutSigningSessionCookie(cookie);</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">async getSession(cookieHeader, options) {</span><span class="s2">\n      </span><span class="s1">let id = cookieHeader &amp;&amp; (await cookie.parse(cookieHeader, options));</span><span class="s2">\n      </span><span class="s1">let data2 = id &amp;&amp; (await readData(id));</span><span class="s2">\n      </span><span class="s1">return createSession(data2 || {}, id || </span><span class="s2">\&quot;\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">async commitSession(session, options) {</span><span class="s2">\n      </span><span class="s1">let {</span><span class="s2">\n        </span><span class="s1">id,</span><span class="s2">\n        </span><span class="s1">data: data2</span><span class="s2">\n      </span><span class="s1">} = session;</span><span class="s2">\n      </span><span class="s1">let expires = options?.maxAge != null ? new Date(Date.now() + options.maxAge * 1e3) : options?.expires != null ? options.expires : cookie.expires;</span><span class="s2">\n      </span><span class="s1">if (id) {</span><span class="s2">\n        </span><span class="s1">await updateData(id, data2, expires);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">id = await createData(data2, expires);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return cookie.serialize(id, options);</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">async destroySession(session, options) {</span><span class="s2">\n      </span><span class="s1">await deleteData(session.id);</span><span class="s2">\n      </span><span class="s1">return cookie.serialize(</span><span class="s2">\&quot;\&quot;</span><span class="s1">, {</span><span class="s2">\n        </span><span class="s1">...options,</span><span class="s2">\n        </span><span class="s1">maxAge: void 0,</span><span class="s2">\n        </span><span class="s1">expires: /* @__PURE__ */new Date(0)</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function warnOnceAboutSigningSessionCookie(cookie) {</span><span class="s2">\n  </span><span class="s1">warnOnce(cookie.isSigned, `The </span><span class="s2">\&quot;</span><span class="s1">${cookie.name}</span><span class="s2">\&quot; </span><span class="s1">cookie is not signed, but session cookies should be signed to prevent tampering on the client before they are sent back to the server. See https://reactrouter.com/explanation/sessions-and-cookies#signing-cookies for more information.`);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/server-runtime/sessions/cookieStorage.ts</span><span class="s2">\n</span><span class="s1">function createCookieSessionStorage({</span><span class="s2">\n  </span><span class="s1">cookie: cookieArg</span><span class="s2">\n</span><span class="s1">} = {}) {</span><span class="s2">\n  </span><span class="s1">let cookie = isCookie(cookieArg) ? cookieArg : createCookie(cookieArg?.name || </span><span class="s2">\&quot;</span><span class="s1">__session</span><span class="s2">\&quot;</span><span class="s1">, cookieArg);</span><span class="s2">\n  </span><span class="s1">warnOnceAboutSigningSessionCookie(cookie);</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">async getSession(cookieHeader, options) {</span><span class="s2">\n      </span><span class="s1">return createSession(cookieHeader &amp;&amp; (await cookie.parse(cookieHeader, options)) || {});</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">async commitSession(session, options) {</span><span class="s2">\n      </span><span class="s1">let serializedCookie = await cookie.serialize(session.data, options);</span><span class="s2">\n      </span><span class="s1">if (serializedCookie.length &gt; 4096) {</span><span class="s2">\n        </span><span class="s1">throw new Error(</span><span class="s2">\&quot;</span><span class="s1">Cookie length will exceed browser maximum. Length: </span><span class="s2">\&quot; </span><span class="s1">+ serializedCookie.length);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return serializedCookie;</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">async destroySession(_session, options) {</span><span class="s2">\n      </span><span class="s1">return cookie.serialize(</span><span class="s2">\&quot;\&quot;</span><span class="s1">, {</span><span class="s2">\n        </span><span class="s1">...options,</span><span class="s2">\n        </span><span class="s1">maxAge: void 0,</span><span class="s2">\n        </span><span class="s1">expires: /* @__PURE__ */new Date(0)</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/server-runtime/sessions/memoryStorage.ts</span><span class="s2">\n</span><span class="s1">function createMemorySessionStorage({</span><span class="s2">\n  </span><span class="s1">cookie</span><span class="s2">\n</span><span class="s1">} = {}) {</span><span class="s2">\n  </span><span class="s1">let map = /* @__PURE__ */new Map();</span><span class="s2">\n  </span><span class="s1">return createSessionStorage({</span><span class="s2">\n    </span><span class="s1">cookie,</span><span class="s2">\n    </span><span class="s1">async createData(data2, expires) {</span><span class="s2">\n      </span><span class="s1">let id = Math.random().toString(36).substring(2, 10);</span><span class="s2">\n      </span><span class="s1">map.set(id, {</span><span class="s2">\n        </span><span class="s1">data: data2,</span><span class="s2">\n        </span><span class="s1">expires</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">return id;</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">async readData(id) {</span><span class="s2">\n      </span><span class="s1">if (map.has(id)) {</span><span class="s2">\n        </span><span class="s1">let {</span><span class="s2">\n          </span><span class="s1">data: data2,</span><span class="s2">\n          </span><span class="s1">expires</span><span class="s2">\n        </span><span class="s1">} = map.get(id);</span><span class="s2">\n        </span><span class="s1">if (!expires || expires &gt; /* @__PURE__ */new Date()) {</span><span class="s2">\n          </span><span class="s1">return data2;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (expires) map.delete(id);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return null;</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">async updateData(id, data2, expires) {</span><span class="s2">\n      </span><span class="s1">map.set(id, {</span><span class="s2">\n        </span><span class="s1">data: data2,</span><span class="s2">\n        </span><span class="s1">expires</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">async deleteData(id) {</span><span class="s2">\n      </span><span class="s1">map.delete(id);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/href.ts</span><span class="s2">\n</span><span class="s1">function href(path, ...args) {</span><span class="s2">\n  </span><span class="s1">let params = args[0];</span><span class="s2">\n  </span><span class="s1">return path.split(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">).map(segment =&gt; {</span><span class="s2">\n    </span><span class="s1">const match = segment.match(/^:([</span><span class="s2">\\</span><span class="s1">w-]+)(</span><span class="s2">\\</span><span class="s1">?)?/);</span><span class="s2">\n    </span><span class="s1">if (!match) return segment;</span><span class="s2">\n    </span><span class="s1">const param = match[1];</span><span class="s2">\n    </span><span class="s1">const value = params ? params[param] : void 0;</span><span class="s2">\n    </span><span class="s1">const isRequired = match[2] === void 0;</span><span class="s2">\n    </span><span class="s1">if (isRequired &amp;&amp; value === void 0) {</span><span class="s2">\n      </span><span class="s1">throw Error(`Path '${path}' requires param '${param}' but it was not provided`);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return value;</span><span class="s2">\n  </span><span class="s1">}).filter(segment =&gt; segment !== void 0).join(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/dom/ssr/errors.ts</span><span class="s2">\n</span><span class="s1">function deserializeErrors2(errors) {</span><span class="s2">\n  </span><span class="s1">if (!errors) return null;</span><span class="s2">\n  </span><span class="s1">let entries = Object.entries(errors);</span><span class="s2">\n  </span><span class="s1">let serialized = {};</span><span class="s2">\n  </span><span class="s1">for (let [key, val] of entries) {</span><span class="s2">\n    </span><span class="s1">if (val &amp;&amp; val.__type === </span><span class="s2">\&quot;</span><span class="s1">RouteErrorResponse</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">serialized[key] = new ErrorResponseImpl(val.status, val.statusText, val.data, val.internal === true);</span><span class="s2">\n    </span><span class="s1">} else if (val &amp;&amp; val.__type === </span><span class="s2">\&quot;</span><span class="s1">Error</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">if (val.__subType) {</span><span class="s2">\n        </span><span class="s1">let ErrorConstructor = window[val.__subType];</span><span class="s2">\n        </span><span class="s1">if (typeof ErrorConstructor === </span><span class="s2">\&quot;</span><span class="s1">function</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">try {</span><span class="s2">\n            </span><span class="s1">let error = new ErrorConstructor(val.message);</span><span class="s2">\n            </span><span class="s1">error.stack = val.stack;</span><span class="s2">\n            </span><span class="s1">serialized[key] = error;</span><span class="s2">\n          </span><span class="s1">} catch (e) {}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (serialized[key] == null) {</span><span class="s2">\n        </span><span class="s1">let error = new Error(val.message);</span><span class="s2">\n        </span><span class="s1">error.stack = val.stack;</span><span class="s2">\n        </span><span class="s1">serialized[key] = error;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">serialized[key] = val;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return serialized;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/dom/ssr/hydration.tsx</span><span class="s2">\n</span><span class="s1">function getHydrationData(state, routes, getRouteInfo, location, basename, isSpaMode) {</span><span class="s2">\n  </span><span class="s1">let hydrationData = {</span><span class="s2">\n    </span><span class="s1">...state,</span><span class="s2">\n    </span><span class="s1">loaderData: {</span><span class="s2">\n      </span><span class="s1">...state.loaderData</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">let initialMatches = matchRoutes(routes, location, basename);</span><span class="s2">\n  </span><span class="s1">if (initialMatches) {</span><span class="s2">\n    </span><span class="s1">for (let match of initialMatches) {</span><span class="s2">\n      </span><span class="s1">let routeId = match.route.id;</span><span class="s2">\n      </span><span class="s1">let routeInfo = getRouteInfo(routeId);</span><span class="s2">\n      </span><span class="s1">if (shouldHydrateRouteLoader(routeId, routeInfo.clientLoader, routeInfo.hasLoader, isSpaMode) &amp;&amp; (routeInfo.hasHydrateFallback || !routeInfo.hasLoader)) {</span><span class="s2">\n        </span><span class="s1">delete hydrationData.loaderData[routeId];</span><span class="s2">\n      </span><span class="s1">} else if (!routeInfo.hasLoader) {</span><span class="s2">\n        </span><span class="s1">hydrationData.loaderData[routeId] = null;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return hydrationData;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">export { Action, createBrowserHistory, invariant, createPath, parsePath, unstable_createContext, unstable_RouterContextProvider, matchRoutes, generatePath, matchPath, resolvePath, data, redirect, redirectDocument, replace, ErrorResponseImpl, isRouteErrorResponse, IDLE_NAVIGATION, IDLE_FETCHER, IDLE_BLOCKER, createRouter, DataRouterContext, DataRouterStateContext, ViewTransitionContext, FetchersContext, NavigationContext, LocationContext, RouteContext, useHref, useInRouterContext, useLocation, useNavigationType, useMatch, useNavigate, useOutletContext, useOutlet, useParams, useResolvedPath, useRoutes, useNavigation, useRevalidator, useMatches, useLoaderData, useRouteLoaderData, useActionData, useRouteError, useAsyncValue, useAsyncError, useBlocker, mapRouteProperties, hydrationRouteProperties, createMemoryRouter, RouterProvider, MemoryRouter, Navigate, Outlet, Route, Router, Routes, Await, createRoutesFromChildren, createRoutesFromElements, renderMatches, createSearchParams, SingleFetchRedirectSymbol, getTurboStreamSingleFetchDataStrategy, decodeViaTurboStream, RemixErrorBoundary, createClientRoutesWithHMRRevalidationOptOut, createClientRoutes, shouldHydrateRouteLoader, getPatchRoutesOnNavigationFunction, useFogOFWarDiscovery, FrameworkContext, Links, PrefetchPageLinks, Meta, Scripts, createBrowserRouter, createHashRouter, BrowserRouter, HashRouter, HistoryRouter, Link, NavLink, Form, ScrollRestoration, useLinkClickHandler, useSearchParams, useSubmit, useFormAction, useFetcher, useFetchers, useScrollRestoration, useBeforeUnload, usePrompt, useViewTransitionState, StaticRouter, StaticRouterProvider, createStaticHandler2 as createStaticHandler, createStaticRouter, ServerRouter, createRoutesStub, createCookie, isCookie, ServerMode, setDevServerHooks, createRequestHandler, createSession, isSession, createSessionStorage, createCookieSessionStorage, createMemorySessionStorage, href, deserializeErrors2 as deserializeErrors, getHydrationData };&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">:{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s3">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;__typeError&quot;</span><span class="s0">,</span><span class="s1">&quot;msg&quot;</span><span class="s0">,</span><span class="s1">&quot;TypeError&quot;</span><span class="s0">,</span><span class="s1">&quot;__accessCheck&quot;</span><span class="s0">,</span><span class="s1">&quot;obj&quot;</span><span class="s0">,</span><span class="s1">&quot;member&quot;</span><span class="s0">,</span><span class="s1">&quot;has&quot;</span><span class="s0">,</span><span class="s1">&quot;__privateGet&quot;</span><span class="s0">,</span><span class="s1">&quot;getter&quot;</span><span class="s0">,</span><span class="s1">&quot;call&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;__privateAdd&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;WeakSet&quot;</span><span class="s0">,</span><span class="s1">&quot;add&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;Action&quot;</span><span class="s0">,</span><span class="s1">&quot;Action2&quot;</span><span class="s0">,</span><span class="s1">&quot;PopStateEventType&quot;</span><span class="s0">,</span><span class="s1">&quot;createMemoryHistory&quot;</span><span class="s0">,</span><span class="s1">&quot;options&quot;</span><span class="s0">,</span><span class="s1">&quot;initialEntries&quot;</span><span class="s0">,</span><span class="s1">&quot;initialIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;v5Compat&quot;</span><span class="s0">,</span><span class="s1">&quot;entries&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;entry&quot;</span><span class="s0">,</span><span class="s1">&quot;index2&quot;</span><span class="s0">,</span><span class="s1">&quot;createMemoryLocation&quot;</span><span class="s0">,</span><span class="s1">&quot;state&quot;</span><span class="s0">,</span><span class="s1">&quot;index&quot;</span><span class="s0">,</span><span class="s1">&quot;clampIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;action&quot;</span><span class="s0">,</span><span class="s1">&quot;listener&quot;</span><span class="s0">,</span><span class="s1">&quot;n&quot;</span><span class="s0">,</span><span class="s1">&quot;Math&quot;</span><span class="s0">,</span><span class="s1">&quot;min&quot;</span><span class="s0">,</span><span class="s1">&quot;max&quot;</span><span class="s0">,</span><span class="s1">&quot;getCurrentLocation&quot;</span><span class="s0">,</span><span class="s1">&quot;to&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;location&quot;</span><span class="s0">,</span><span class="s1">&quot;createLocation&quot;</span><span class="s0">,</span><span class="s1">&quot;pathname&quot;</span><span class="s0">,</span><span class="s1">&quot;warning&quot;</span><span class="s0">,</span><span class="s1">&quot;charAt&quot;</span><span class="s0">,</span><span class="s1">&quot;JSON&quot;</span><span class="s0">,</span><span class="s1">&quot;stringify&quot;</span><span class="s0">,</span><span class="s1">&quot;createHref2&quot;</span><span class="s0">,</span><span class="s1">&quot;createPath&quot;</span><span class="s0">,</span><span class="s1">&quot;history&quot;</span><span class="s0">,</span><span class="s1">&quot;createHref&quot;</span><span class="s0">,</span><span class="s1">&quot;createURL&quot;</span><span class="s0">,</span><span class="s1">&quot;URL&quot;</span><span class="s0">,</span><span class="s1">&quot;encodeLocation&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;parsePath&quot;</span><span class="s0">,</span><span class="s1">&quot;search&quot;</span><span class="s0">,</span><span class="s1">&quot;hash&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;nextLocation&quot;</span><span class="s0">,</span><span class="s1">&quot;splice&quot;</span><span class="s0">,</span><span class="s1">&quot;delta&quot;</span><span class="s0">,</span><span class="s1">&quot;replace&quot;</span><span class="s0">,</span><span class="s1">&quot;go&quot;</span><span class="s0">,</span><span class="s1">&quot;nextIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;listen&quot;</span><span class="s0">,</span><span class="s1">&quot;fn&quot;</span><span class="s0">,</span><span class="s1">&quot;createBrowserHistory&quot;</span><span class="s0">,</span><span class="s1">&quot;createBrowserLocation&quot;</span><span class="s0">,</span><span class="s1">&quot;window2&quot;</span><span class="s0">,</span><span class="s1">&quot;globalHistory&quot;</span><span class="s0">,</span><span class="s1">&quot;usr&quot;</span><span class="s0">,</span><span class="s1">&quot;createBrowserHref&quot;</span><span class="s0">,</span><span class="s1">&quot;getUrlBasedHistory&quot;</span><span class="s0">,</span><span class="s1">&quot;createHashHistory&quot;</span><span class="s0">,</span><span class="s1">&quot;createHashLocation&quot;</span><span class="s0">,</span><span class="s1">&quot;substring&quot;</span><span class="s0">,</span><span class="s1">&quot;startsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;createHashHref&quot;</span><span class="s0">,</span><span class="s1">&quot;base&quot;</span><span class="s0">,</span><span class="s1">&quot;document&quot;</span><span class="s0">,</span><span class="s1">&quot;querySelector&quot;</span><span class="s0">,</span><span class="s1">&quot;href2&quot;</span><span class="s0">,</span><span class="s1">&quot;getAttribute&quot;</span><span class="s0">,</span><span class="s1">&quot;url&quot;</span><span class="s0">,</span><span class="s1">&quot;href&quot;</span><span class="s0">,</span><span class="s1">&quot;hashIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;indexOf&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;validateHashLocation&quot;</span><span class="s0">,</span><span class="s1">&quot;invariant&quot;</span><span class="s0">,</span><span class="s1">&quot;message&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;cond&quot;</span><span class="s0">,</span><span class="s1">&quot;console&quot;</span><span class="s0">,</span><span class="s1">&quot;warn&quot;</span><span class="s0">,</span><span class="s1">&quot;e&quot;</span><span class="s0">,</span><span class="s1">&quot;createKey&quot;</span><span class="s0">,</span><span class="s1">&quot;random&quot;</span><span class="s0">,</span><span class="s1">&quot;toString&quot;</span><span class="s0">,</span><span class="s1">&quot;getHistoryState&quot;</span><span class="s0">,</span><span class="s1">&quot;idx&quot;</span><span class="s0">,</span><span class="s1">&quot;current&quot;</span><span class="s0">,</span><span class="s1">&quot;parsedPath&quot;</span><span class="s0">,</span><span class="s1">&quot;searchIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;getLocation&quot;</span><span class="s0">,</span><span class="s1">&quot;validateLocation&quot;</span><span class="s0">,</span><span class="s1">&quot;window&quot;</span><span class="s0">,</span><span class="s1">&quot;defaultView&quot;</span><span class="s0">,</span><span class="s1">&quot;getIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceState&quot;</span><span class="s0">,</span><span class="s1">&quot;handlePop&quot;</span><span class="s0">,</span><span class="s1">&quot;historyState&quot;</span><span class="s0">,</span><span class="s1">&quot;pushState&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">,</span><span class="s1">&quot;DOMException&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;assign&quot;</span><span class="s0">,</span><span class="s1">&quot;replace2&quot;</span><span class="s0">,</span><span class="s1">&quot;createBrowserURLImpl&quot;</span><span class="s0">,</span><span class="s1">&quot;addEventListener&quot;</span><span class="s0">,</span><span class="s1">&quot;removeEventListener&quot;</span><span class="s0">,</span><span class="s1">&quot;isAbsolute&quot;</span><span class="s0">,</span><span class="s1">&quot;origin&quot;</span><span class="s0">,</span><span class="s1">&quot;unstable_createContext&quot;</span><span class="s0">,</span><span class="s1">&quot;defaultValue&quot;</span><span class="s0">,</span><span class="s1">&quot;_map&quot;</span><span class="s0">,</span><span class="s1">&quot;unstable_RouterContextProvider&quot;</span><span class="s0">,</span><span class="s1">&quot;constructor&quot;</span><span class="s0">,</span><span class="s1">&quot;init&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;context&quot;</span><span class="s0">,</span><span class="s1">&quot;WeakMap&quot;</span><span class="s0">,</span><span class="s1">&quot;unsupportedLazyRouteObjectKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;Set&quot;</span><span class="s0">,</span><span class="s1">&quot;isUnsupportedLazyRouteObjectKey&quot;</span><span class="s0">,</span><span class="s1">&quot;unsupportedLazyRouteFunctionKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;isUnsupportedLazyRouteFunctionKey&quot;</span><span class="s0">,</span><span class="s1">&quot;isIndexRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;route&quot;</span><span class="s0">,</span><span class="s1">&quot;convertRoutesToDataRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;routes&quot;</span><span class="s0">,</span><span class="s1">&quot;mapRouteProperties2&quot;</span><span class="s0">,</span><span class="s1">&quot;parentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;manifest&quot;</span><span class="s0">,</span><span class="s1">&quot;treePath&quot;</span><span class="s0">,</span><span class="s1">&quot;String&quot;</span><span class="s0">,</span><span class="s1">&quot;id&quot;</span><span class="s0">,</span><span class="s1">&quot;join&quot;</span><span class="s0">,</span><span class="s1">&quot;children&quot;</span><span class="s0">,</span><span class="s1">&quot;indexRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;pathOrLayoutRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;matchRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;locationArg&quot;</span><span class="s0">,</span><span class="s1">&quot;basename&quot;</span><span class="s0">,</span><span class="s1">&quot;matchRoutesImpl&quot;</span><span class="s0">,</span><span class="s1">&quot;allowPartial&quot;</span><span class="s0">,</span><span class="s1">&quot;stripBasename&quot;</span><span class="s0">,</span><span class="s1">&quot;branches&quot;</span><span class="s0">,</span><span class="s1">&quot;flattenRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;rankRouteBranches&quot;</span><span class="s0">,</span><span class="s1">&quot;matches&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;decoded&quot;</span><span class="s0">,</span><span class="s1">&quot;decodePath&quot;</span><span class="s0">,</span><span class="s1">&quot;matchRouteBranch&quot;</span><span class="s0">,</span><span class="s1">&quot;convertRouteMatchToUiMatch&quot;</span><span class="s0">,</span><span class="s1">&quot;match&quot;</span><span class="s0">,</span><span class="s1">&quot;loaderData&quot;</span><span class="s0">,</span><span class="s1">&quot;params&quot;</span><span class="s0">,</span><span class="s1">&quot;data&quot;</span><span class="s0">,</span><span class="s1">&quot;handle&quot;</span><span class="s0">,</span><span class="s1">&quot;parentsMeta&quot;</span><span class="s0">,</span><span class="s1">&quot;flattenRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;relativePath&quot;</span><span class="s0">,</span><span class="s1">&quot;meta&quot;</span><span class="s0">,</span><span class="s1">&quot;caseSensitive&quot;</span><span class="s0">,</span><span class="s1">&quot;childrenIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;joinPaths&quot;</span><span class="s0">,</span><span class="s1">&quot;routesMeta&quot;</span><span class="s0">,</span><span class="s1">&quot;concat&quot;</span><span class="s0">,</span><span class="s1">&quot;score&quot;</span><span class="s0">,</span><span class="s1">&quot;computeScore&quot;</span><span class="s0">,</span><span class="s1">&quot;forEach&quot;</span><span class="s0">,</span><span class="s1">&quot;includes&quot;</span><span class="s0">,</span><span class="s1">&quot;exploded&quot;</span><span class="s0">,</span><span class="s1">&quot;explodeOptionalSegments&quot;</span><span class="s0">,</span><span class="s1">&quot;segments&quot;</span><span class="s0">,</span><span class="s1">&quot;split&quot;</span><span class="s0">,</span><span class="s1">&quot;first&quot;</span><span class="s0">,</span><span class="s1">&quot;rest&quot;</span><span class="s0">,</span><span class="s1">&quot;isOptional&quot;</span><span class="s0">,</span><span class="s1">&quot;endsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;required&quot;</span><span class="s0">,</span><span class="s1">&quot;restExploded&quot;</span><span class="s0">,</span><span class="s1">&quot;result&quot;</span><span class="s0">,</span><span class="s1">&quot;subpath&quot;</span><span class="s0">,</span><span class="s1">&quot;sort&quot;</span><span class="s0">,</span><span class="s1">&quot;a&quot;</span><span class="s0">,</span><span class="s1">&quot;b&quot;</span><span class="s0">,</span><span class="s1">&quot;compareIndexes&quot;</span><span class="s0">,</span><span class="s1">&quot;paramRe&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicSegmentValue&quot;</span><span class="s0">,</span><span class="s1">&quot;indexRouteValue&quot;</span><span class="s0">,</span><span class="s1">&quot;emptySegmentValue&quot;</span><span class="s0">,</span><span class="s1">&quot;staticSegmentValue&quot;</span><span class="s0">,</span><span class="s1">&quot;splatPenalty&quot;</span><span class="s0">,</span><span class="s1">&quot;isSplat&quot;</span><span class="s0">,</span><span class="s1">&quot;s&quot;</span><span class="s0">,</span><span class="s1">&quot;initialScore&quot;</span><span class="s0">,</span><span class="s1">&quot;some&quot;</span><span class="s0">,</span><span class="s1">&quot;filter&quot;</span><span class="s0">,</span><span class="s1">&quot;reduce&quot;</span><span class="s0">,</span><span class="s1">&quot;segment&quot;</span><span class="s0">,</span><span class="s1">&quot;test&quot;</span><span class="s0">,</span><span class="s1">&quot;siblings&quot;</span><span class="s0">,</span><span class="s1">&quot;every&quot;</span><span class="s0">,</span><span class="s1">&quot;branch&quot;</span><span class="s0">,</span><span class="s1">&quot;matchedParams&quot;</span><span class="s0">,</span><span class="s1">&quot;matchedPathname&quot;</span><span class="s0">,</span><span class="s1">&quot;end&quot;</span><span class="s0">,</span><span class="s1">&quot;remainingPathname&quot;</span><span class="s0">,</span><span class="s1">&quot;matchPath&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;pathnameBase&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizePathname&quot;</span><span class="s0">,</span><span class="s1">&quot;generatePath&quot;</span><span class="s0">,</span><span class="s1">&quot;originalPath&quot;</span><span class="s0">,</span><span class="s1">&quot;prefix&quot;</span><span class="s0">,</span><span class="s1">&quot;stringify2&quot;</span><span class="s0">,</span><span class="s1">&quot;p&quot;</span><span class="s0">,</span><span class="s1">&quot;array&quot;</span><span class="s0">,</span><span class="s1">&quot;isLastSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;star&quot;</span><span class="s0">,</span><span class="s1">&quot;keyMatch&quot;</span><span class="s0">,</span><span class="s1">&quot;optional&quot;</span><span class="s0">,</span><span class="s1">&quot;param&quot;</span><span class="s0">,</span><span class="s1">&quot;pattern&quot;</span><span class="s0">,</span><span class="s1">&quot;matcher&quot;</span><span class="s0">,</span><span class="s1">&quot;compiledParams&quot;</span><span class="s0">,</span><span class="s1">&quot;compilePath&quot;</span><span class="s0">,</span><span class="s1">&quot;captureGroups&quot;</span><span class="s0">,</span><span class="s1">&quot;memo2&quot;</span><span class="s0">,</span><span class="s1">&quot;paramName&quot;</span><span class="s0">,</span><span class="s1">&quot;splatValue&quot;</span><span class="s0">,</span><span class="s1">&quot;regexpSource&quot;</span><span class="s0">,</span><span class="s1">&quot;_&quot;</span><span class="s0">,</span><span class="s1">&quot;RegExp&quot;</span><span class="s0">,</span><span class="s1">&quot;v&quot;</span><span class="s0">,</span><span class="s1">&quot;decodeURIComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;toLowerCase&quot;</span><span class="s0">,</span><span class="s1">&quot;startIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;nextChar&quot;</span><span class="s0">,</span><span class="s1">&quot;resolvePath&quot;</span><span class="s0">,</span><span class="s1">&quot;fromPathname&quot;</span><span class="s0">,</span><span class="s1">&quot;toPathname&quot;</span><span class="s0">,</span><span class="s1">&quot;resolvePathname&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeSearch&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeHash&quot;</span><span class="s0">,</span><span class="s1">&quot;relativeSegments&quot;</span><span class="s0">,</span><span class="s1">&quot;pop&quot;</span><span class="s0">,</span><span class="s1">&quot;getInvalidPathError&quot;</span><span class="s0">,</span><span class="s1">&quot;char&quot;</span><span class="s0">,</span><span class="s1">&quot;field&quot;</span><span class="s0">,</span><span class="s1">&quot;dest&quot;</span><span class="s0">,</span><span class="s1">&quot;getPathContributingMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;getResolveToMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;pathMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;resolveTo&quot;</span><span class="s0">,</span><span class="s1">&quot;toArg&quot;</span><span class="s0">,</span><span class="s1">&quot;routePathnames&quot;</span><span class="s0">,</span><span class="s1">&quot;locationPathname&quot;</span><span class="s0">,</span><span class="s1">&quot;isPathRelative&quot;</span><span class="s0">,</span><span class="s1">&quot;isEmptyPath&quot;</span><span class="s0">,</span><span class="s1">&quot;from&quot;</span><span class="s0">,</span><span class="s1">&quot;routePathnameIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;toSegments&quot;</span><span class="s0">,</span><span class="s1">&quot;shift&quot;</span><span class="s0">,</span><span class="s1">&quot;hasExplicitTrailingSlash&quot;</span><span class="s0">,</span><span class="s1">&quot;hasCurrentTrailingSlash&quot;</span><span class="s0">,</span><span class="s1">&quot;paths&quot;</span><span class="s0">,</span><span class="s1">&quot;DataWithResponseInit&quot;</span><span class="s0">,</span><span class="s1">&quot;data2&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;status&quot;</span><span class="s0">,</span><span class="s1">&quot;redirect&quot;</span><span class="s0">,</span><span class="s1">&quot;responseInit&quot;</span><span class="s0">,</span><span class="s1">&quot;headers&quot;</span><span class="s0">,</span><span class="s1">&quot;Headers&quot;</span><span class="s0">,</span><span class="s1">&quot;Response&quot;</span><span class="s0">,</span><span class="s1">&quot;redirectDocument&quot;</span><span class="s0">,</span><span class="s1">&quot;response&quot;</span><span class="s0">,</span><span class="s1">&quot;ErrorResponseImpl&quot;</span><span class="s0">,</span><span class="s1">&quot;statusText&quot;</span><span class="s0">,</span><span class="s1">&quot;internal&quot;</span><span class="s0">,</span><span class="s1">&quot;isRouteErrorResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;validMutationMethodsArr&quot;</span><span class="s0">,</span><span class="s1">&quot;validMutationMethods&quot;</span><span class="s0">,</span><span class="s1">&quot;validRequestMethodsArr&quot;</span><span class="s0">,</span><span class="s1">&quot;validRequestMethods&quot;</span><span class="s0">,</span><span class="s1">&quot;redirectStatusCodes&quot;</span><span class="s0">,</span><span class="s1">&quot;redirectPreserveMethodStatusCodes&quot;</span><span class="s0">,</span><span class="s1">&quot;IDLE_NAVIGATION&quot;</span><span class="s0">,</span><span class="s1">&quot;formMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;formAction&quot;</span><span class="s0">,</span><span class="s1">&quot;formEncType&quot;</span><span class="s0">,</span><span class="s1">&quot;formData&quot;</span><span class="s0">,</span><span class="s1">&quot;json&quot;</span><span class="s0">,</span><span class="s1">&quot;text&quot;</span><span class="s0">,</span><span class="s1">&quot;IDLE_FETCHER&quot;</span><span class="s0">,</span><span class="s1">&quot;IDLE_BLOCKER&quot;</span><span class="s0">,</span><span class="s1">&quot;proceed&quot;</span><span class="s0">,</span><span class="s1">&quot;reset&quot;</span><span class="s0">,</span><span class="s1">&quot;ABSOLUTE_URL_REGEX&quot;</span><span class="s0">,</span><span class="s1">&quot;defaultMapRouteProperties&quot;</span><span class="s0">,</span><span class="s1">&quot;hasErrorBoundary&quot;</span><span class="s0">,</span><span class="s1">&quot;Boolean&quot;</span><span class="s0">,</span><span class="s1">&quot;TRANSITIONS_STORAGE_KEY&quot;</span><span class="s0">,</span><span class="s1">&quot;ResetLoaderDataSymbol&quot;</span><span class="s0">,</span><span class="s1">&quot;Symbol&quot;</span><span class="s0">,</span><span class="s1">&quot;createRouter&quot;</span><span class="s0">,</span><span class="s1">&quot;routerWindow&quot;</span><span class="s0">,</span><span class="s1">&quot;isBrowser2&quot;</span><span class="s0">,</span><span class="s1">&quot;createElement&quot;</span><span class="s0">,</span><span class="s1">&quot;hydrationRouteProperties2&quot;</span><span class="s0">,</span><span class="s1">&quot;hydrationRouteProperties&quot;</span><span class="s0">,</span><span class="s1">&quot;mapRouteProperties&quot;</span><span class="s0">,</span><span class="s1">&quot;dataRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;inFlightDataRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;dataStrategyImpl&quot;</span><span class="s0">,</span><span class="s1">&quot;dataStrategy&quot;</span><span class="s0">,</span><span class="s1">&quot;defaultDataStrategyWithMiddleware&quot;</span><span class="s0">,</span><span class="s1">&quot;future&quot;</span><span class="s0">,</span><span class="s1">&quot;unstable_middleware&quot;</span><span class="s0">,</span><span class="s1">&quot;unlistenHistory&quot;</span><span class="s0">,</span><span class="s1">&quot;subscribers&quot;</span><span class="s0">,</span><span class="s1">&quot;savedScrollPositions2&quot;</span><span class="s0">,</span><span class="s1">&quot;getScrollRestorationKey2&quot;</span><span class="s0">,</span><span class="s1">&quot;getScrollPosition&quot;</span><span class="s0">,</span><span class="s1">&quot;initialScrollRestored&quot;</span><span class="s0">,</span><span class="s1">&quot;hydrationData&quot;</span><span class="s0">,</span><span class="s1">&quot;initialMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;initialMatchesIsFOW&quot;</span><span class="s0">,</span><span class="s1">&quot;initialErrors&quot;</span><span class="s0">,</span><span class="s1">&quot;initialized&quot;</span><span class="s0">,</span><span class="s1">&quot;patchRoutesOnNavigation&quot;</span><span class="s0">,</span><span class="s1">&quot;getInternalRouterError&quot;</span><span class="s0">,</span><span class="s1">&quot;getShortCircuitMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;fogOfWar&quot;</span><span class="s0">,</span><span class="s1">&quot;checkFogOfWar&quot;</span><span class="s0">,</span><span class="s1">&quot;active&quot;</span><span class="s0">,</span><span class="s1">&quot;m&quot;</span><span class="s0">,</span><span class="s1">&quot;lazy&quot;</span><span class="s0">,</span><span class="s1">&quot;loader&quot;</span><span class="s0">,</span><span class="s1">&quot;errors&quot;</span><span class="s0">,</span><span class="s1">&quot;findIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldLoadRouteOnHydration&quot;</span><span class="s0">,</span><span class="s1">&quot;router&quot;</span><span class="s0">,</span><span class="s1">&quot;historyAction&quot;</span><span class="s0">,</span><span class="s1">&quot;navigation&quot;</span><span class="s0">,</span><span class="s1">&quot;restoreScrollPosition&quot;</span><span class="s0">,</span><span class="s1">&quot;preventScrollReset&quot;</span><span class="s0">,</span><span class="s1">&quot;revalidation&quot;</span><span class="s0">,</span><span class="s1">&quot;actionData&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchers&quot;</span><span class="s0">,</span><span class="s1">&quot;blockers&quot;</span><span class="s0">,</span><span class="s1">&quot;pendingAction&quot;</span><span class="s0">,</span><span class="s1">&quot;pendingPreventScrollReset&quot;</span><span class="s0">,</span><span class="s1">&quot;pendingNavigationController&quot;</span><span class="s0">,</span><span class="s1">&quot;pendingViewTransitionEnabled&quot;</span><span class="s0">,</span><span class="s1">&quot;appliedViewTransitions&quot;</span><span class="s0">,</span><span class="s1">&quot;removePageHideEventListener&quot;</span><span class="s0">,</span><span class="s1">&quot;isUninterruptedRevalidation&quot;</span><span class="s0">,</span><span class="s1">&quot;isRevalidationRequired&quot;</span><span class="s0">,</span><span class="s1">&quot;cancelledFetcherLoads&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchControllers&quot;</span><span class="s0">,</span><span class="s1">&quot;incrementingLoadId&quot;</span><span class="s0">,</span><span class="s1">&quot;pendingNavigationLoadId&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchReloadIds&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchRedirectIds&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchLoadMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;activeFetchers&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchersQueuedForDeletion&quot;</span><span class="s0">,</span><span class="s1">&quot;blockerFunctions&quot;</span><span class="s0">,</span><span class="s1">&quot;unblockBlockerHistoryUpdate&quot;</span><span class="s0">,</span><span class="s1">&quot;pendingRevalidationDfd&quot;</span><span class="s0">,</span><span class="s1">&quot;initialize&quot;</span><span class="s0">,</span><span class="s1">&quot;size&quot;</span><span class="s0">,</span><span class="s1">&quot;blockerKey&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldBlockNavigation&quot;</span><span class="s0">,</span><span class="s1">&quot;currentLocation&quot;</span><span class="s0">,</span><span class="s1">&quot;nextHistoryUpdatePromise&quot;</span><span class="s0">,</span><span class="s1">&quot;Promise&quot;</span><span class="s0">,</span><span class="s1">&quot;resolve&quot;</span><span class="s0">,</span><span class="s1">&quot;updateBlocker&quot;</span><span class="s0">,</span><span class="s1">&quot;then&quot;</span><span class="s0">,</span><span class="s1">&quot;updateState&quot;</span><span class="s0">,</span><span class="s1">&quot;startNavigation&quot;</span><span class="s0">,</span><span class="s1">&quot;restoreAppliedTransitions&quot;</span><span class="s0">,</span><span class="s1">&quot;_saveAppliedTransitions&quot;</span><span class="s0">,</span><span class="s1">&quot;persistAppliedTransitions&quot;</span><span class="s0">,</span><span class="s1">&quot;initialHydration&quot;</span><span class="s0">,</span><span class="s1">&quot;dispose&quot;</span><span class="s0">,</span><span class="s1">&quot;clear&quot;</span><span class="s0">,</span><span class="s1">&quot;abort&quot;</span><span class="s0">,</span><span class="s1">&quot;deleteFetcher&quot;</span><span class="s0">,</span><span class="s1">&quot;deleteBlocker&quot;</span><span class="s0">,</span><span class="s1">&quot;subscribe&quot;</span><span class="s0">,</span><span class="s1">&quot;delete&quot;</span><span class="s0">,</span><span class="s1">&quot;newState&quot;</span><span class="s0">,</span><span class="s1">&quot;opts&quot;</span><span class="s0">,</span><span class="s1">&quot;unmountedFetchers&quot;</span><span class="s0">,</span><span class="s1">&quot;mountedFetchers&quot;</span><span class="s0">,</span><span class="s1">&quot;fetcher&quot;</span><span class="s0">,</span><span class="s1">&quot;subscriber&quot;</span><span class="s0">,</span><span class="s1">&quot;deletedFetchers&quot;</span><span class="s0">,</span><span class="s1">&quot;viewTransitionOpts&quot;</span><span class="s0">,</span><span class="s1">&quot;flushSync&quot;</span><span class="s0">,</span><span class="s1">&quot;completeNavigation&quot;</span><span class="s0">,</span><span class="s1">&quot;isActionReload&quot;</span><span class="s0">,</span><span class="s1">&quot;isMutationMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;_isRedirect&quot;</span><span class="s0">,</span><span class="s1">&quot;keys&quot;</span><span class="s0">,</span><span class="s1">&quot;mergeLoaderData&quot;</span><span class="s0">,</span><span class="s1">&quot;k&quot;</span><span class="s0">,</span><span class="s1">&quot;priorPaths&quot;</span><span class="s0">,</span><span class="s1">&quot;toPaths&quot;</span><span class="s0">,</span><span class="s1">&quot;getSavedScrollPosition&quot;</span><span class="s0">,</span><span class="s1">&quot;navigate&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizedPath&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeTo&quot;</span><span class="s0">,</span><span class="s1">&quot;fromRouteId&quot;</span><span class="s0">,</span><span class="s1">&quot;relative&quot;</span><span class="s0">,</span><span class="s1">&quot;submission&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeNavigateOptions&quot;</span><span class="s0">,</span><span class="s1">&quot;userReplace&quot;</span><span class="s0">,</span><span class="s1">&quot;pendingError&quot;</span><span class="s0">,</span><span class="s1">&quot;enableViewTransition&quot;</span><span class="s0">,</span><span class="s1">&quot;viewTransition&quot;</span><span class="s0">,</span><span class="s1">&quot;revalidate&quot;</span><span class="s0">,</span><span class="s1">&quot;createDeferred&quot;</span><span class="s0">,</span><span class="s1">&quot;interruptActiveLoads&quot;</span><span class="s0">,</span><span class="s1">&quot;promise&quot;</span><span class="s0">,</span><span class="s1">&quot;startUninterruptedRevalidation&quot;</span><span class="s0">,</span><span class="s1">&quot;overrideNavigation&quot;</span><span class="s0">,</span><span class="s1">&quot;saveScrollPosition&quot;</span><span class="s0">,</span><span class="s1">&quot;routesToUse&quot;</span><span class="s0">,</span><span class="s1">&quot;loadingNavigation&quot;</span><span class="s0">,</span><span class="s1">&quot;isHashChangeOnly&quot;</span><span class="s0">,</span><span class="s1">&quot;notFoundMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;handleNavigational404&quot;</span><span class="s0">,</span><span class="s1">&quot;AbortController&quot;</span><span class="s0">,</span><span class="s1">&quot;request&quot;</span><span class="s0">,</span><span class="s1">&quot;createClientSideRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;signal&quot;</span><span class="s0">,</span><span class="s1">&quot;scopedContext&quot;</span><span class="s0">,</span><span class="s1">&quot;unstable_getContext&quot;</span><span class="s0">,</span><span class="s1">&quot;pendingActionResult&quot;</span><span class="s0">,</span><span class="s1">&quot;findNearestBoundary&quot;</span><span class="s0">,</span><span class="s1">&quot;actionResult&quot;</span><span class="s0">,</span><span class="s1">&quot;handleAction&quot;</span><span class="s0">,</span><span class="s1">&quot;shortCircuited&quot;</span><span class="s0">,</span><span class="s1">&quot;routeId&quot;</span><span class="s0">,</span><span class="s1">&quot;isErrorResult&quot;</span><span class="s0">,</span><span class="s1">&quot;getLoadingNavigation&quot;</span><span class="s0">,</span><span class="s1">&quot;updatedMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;handleLoaders&quot;</span><span class="s0">,</span><span class="s1">&quot;fetcherSubmission&quot;</span><span class="s0">,</span><span class="s1">&quot;getActionDataForCommit&quot;</span><span class="s0">,</span><span class="s1">&quot;isFogOfWar&quot;</span><span class="s0">,</span><span class="s1">&quot;getSubmittingNavigation&quot;</span><span class="s0">,</span><span class="s1">&quot;discoverResult&quot;</span><span class="s0">,</span><span class="s1">&quot;discoverRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;boundaryId&quot;</span><span class="s0">,</span><span class="s1">&quot;partialMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;actionMatch&quot;</span><span class="s0">,</span><span class="s1">&quot;getTargetMatch&quot;</span><span class="s0">,</span><span class="s1">&quot;method&quot;</span><span class="s0">,</span><span class="s1">&quot;dsMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;getTargetedDataStrategyMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;results&quot;</span><span class="s0">,</span><span class="s1">&quot;callDataStrategy&quot;</span><span class="s0">,</span><span class="s1">&quot;aborted&quot;</span><span class="s0">,</span><span class="s1">&quot;isRedirectResult&quot;</span><span class="s0">,</span><span class="s1">&quot;location2&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeRedirectLocation&quot;</span><span class="s0">,</span><span class="s1">&quot;startRedirectNavigation&quot;</span><span class="s0">,</span><span class="s1">&quot;boundaryMatch&quot;</span><span class="s0">,</span><span class="s1">&quot;activeSubmission&quot;</span><span class="s0">,</span><span class="s1">&quot;getSubmissionFromNavigation&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldUpdateNavigationState&quot;</span><span class="s0">,</span><span class="s1">&quot;getUpdatedActionData&quot;</span><span class="s0">,</span><span class="s1">&quot;revalidatingFetchers&quot;</span><span class="s0">,</span><span class="s1">&quot;getMatchesToLoad&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldLoad&quot;</span><span class="s0">,</span><span class="s1">&quot;updatedFetchers2&quot;</span><span class="s0">,</span><span class="s1">&quot;markFetchRedirectsDone&quot;</span><span class="s0">,</span><span class="s1">&quot;updates&quot;</span><span class="s0">,</span><span class="s1">&quot;getUpdatedRevalidatingFetchers&quot;</span><span class="s0">,</span><span class="s1">&quot;rf&quot;</span><span class="s0">,</span><span class="s1">&quot;abortFetcher&quot;</span><span class="s0">,</span><span class="s1">&quot;controller&quot;</span><span class="s0">,</span><span class="s1">&quot;abortPendingFetchRevalidations&quot;</span><span class="s0">,</span><span class="s1">&quot;f&quot;</span><span class="s0">,</span><span class="s1">&quot;loaderResults&quot;</span><span class="s0">,</span><span class="s1">&quot;fetcherResults&quot;</span><span class="s0">,</span><span class="s1">&quot;callLoadersAndMaybeResolveData&quot;</span><span class="s0">,</span><span class="s1">&quot;redirect2&quot;</span><span class="s0">,</span><span class="s1">&quot;findRedirect&quot;</span><span class="s0">,</span><span class="s1">&quot;processLoaderData&quot;</span><span class="s0">,</span><span class="s1">&quot;updatedFetchers&quot;</span><span class="s0">,</span><span class="s1">&quot;didAbortFetchLoads&quot;</span><span class="s0">,</span><span class="s1">&quot;abortStaleFetchLoads&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldUpdateFetchers&quot;</span><span class="s0">,</span><span class="s1">&quot;revalidatingFetcher&quot;</span><span class="s0">,</span><span class="s1">&quot;getLoadingFetcher&quot;</span><span class="s0">,</span><span class="s1">&quot;fetch2&quot;</span><span class="s0">,</span><span class="s1">&quot;setFetcherError&quot;</span><span class="s0">,</span><span class="s1">&quot;handleFetcherAction&quot;</span><span class="s0">,</span><span class="s1">&quot;handleFetcherLoader&quot;</span><span class="s0">,</span><span class="s1">&quot;requestMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;detectAndHandle405Error&quot;</span><span class="s0">,</span><span class="s1">&quot;existingFetcher&quot;</span><span class="s0">,</span><span class="s1">&quot;updateFetcherState&quot;</span><span class="s0">,</span><span class="s1">&quot;getSubmittingFetcher&quot;</span><span class="s0">,</span><span class="s1">&quot;abortController&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;originatingLoadId&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;actionResults&quot;</span><span class="s0">,</span><span class="s1">&quot;getDoneFetcher&quot;</span><span class="s0">,</span><span class="s1">&quot;revalidationRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;loadId&quot;</span><span class="s0">,</span><span class="s1">&quot;loadFetcher&quot;</span><span class="s0">,</span><span class="s1">&quot;staleKey&quot;</span><span class="s0">,</span><span class="s1">&quot;existingFetcher2&quot;</span><span class="s0">,</span><span class="s1">&quot;r&quot;</span><span class="s0">,</span><span class="s1">&quot;doneFetcher&quot;</span><span class="s0">,</span><span class="s1">&quot;isNavigation&quot;</span><span class="s0">,</span><span class="s1">&quot;redirectLocation&quot;</span><span class="s0">,</span><span class="s1">&quot;isDocumentReload&quot;</span><span class="s0">,</span><span class="s1">&quot;redirectNavigationType&quot;</span><span class="s0">,</span><span class="s1">&quot;fetcherKey&quot;</span><span class="s0">,</span><span class="s1">&quot;dataResults&quot;</span><span class="s0">,</span><span class="s1">&quot;callDataStrategyImpl&quot;</span><span class="s0">,</span><span class="s1">&quot;isRedirectDataStrategyResult&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeRelativeRoutingRedirectResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;convertDataStrategyResultToDataResult&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchersToLoad&quot;</span><span class="s0">,</span><span class="s1">&quot;loaderResultsPromise&quot;</span><span class="s0">,</span><span class="s1">&quot;fetcherResultsPromise&quot;</span><span class="s0">,</span><span class="s1">&quot;all&quot;</span><span class="s0">,</span><span class="s1">&quot;acc&quot;</span><span class="s0">,</span><span class="s1">&quot;getFetcher&quot;</span><span class="s0">,</span><span class="s1">&quot;queueFetcherForDeletion&quot;</span><span class="s0">,</span><span class="s1">&quot;count&quot;</span><span class="s0">,</span><span class="s1">&quot;markFetchersDone&quot;</span><span class="s0">,</span><span class="s1">&quot;doneKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;landedId&quot;</span><span class="s0">,</span><span class="s1">&quot;yeetedKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;getBlocker&quot;</span><span class="s0">,</span><span class="s1">&quot;blocker&quot;</span><span class="s0">,</span><span class="s1">&quot;newBlocker&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;blockerFunction&quot;</span><span class="s0">,</span><span class="s1">&quot;enableScrollRestoration&quot;</span><span class="s0">,</span><span class="s1">&quot;positions&quot;</span><span class="s0">,</span><span class="s1">&quot;getPosition&quot;</span><span class="s0">,</span><span class="s1">&quot;getKey&quot;</span><span class="s0">,</span><span class="s1">&quot;y&quot;</span><span class="s0">,</span><span class="s1">&quot;getScrollKey&quot;</span><span class="s0">,</span><span class="s1">&quot;fogMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;isNonHMR&quot;</span><span class="s0">,</span><span class="s1">&quot;localManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;patch&quot;</span><span class="s0">,</span><span class="s1">&quot;patchRoutesImpl&quot;</span><span class="s0">,</span><span class="s1">&quot;newMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;newPartialMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;_internalSetRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;newRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;patchRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;fetch&quot;</span><span class="s0">,</span><span class="s1">&quot;_internalFetchControllers&quot;</span><span class="s0">,</span><span class="s1">&quot;createStaticHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;query&quot;</span><span class="s0">,</span><span class="s1">&quot;requestContext&quot;</span><span class="s0">,</span><span class="s1">&quot;filterMatchesToLoad&quot;</span><span class="s0">,</span><span class="s1">&quot;skipLoaderErrorBubbling&quot;</span><span class="s0">,</span><span class="s1">&quot;skipRevalidation&quot;</span><span class="s0">,</span><span class="s1">&quot;unstable_respond&quot;</span><span class="s0">,</span><span class="s1">&quot;respond&quot;</span><span class="s0">,</span><span class="s1">&quot;isValidMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;methodNotAllowedMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;staticContext&quot;</span><span class="s0">,</span><span class="s1">&quot;statusCode&quot;</span><span class="s0">,</span><span class="s1">&quot;loaderHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;actionHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;loadLazyMiddlewareForMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;renderedStaticContext&quot;</span><span class="s0">,</span><span class="s1">&quot;runMiddlewarePipeline&quot;</span><span class="s0">,</span><span class="s1">&quot;result2&quot;</span><span class="s0">,</span><span class="s1">&quot;queryImpl&quot;</span><span class="s0">,</span><span class="s1">&quot;isResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;res&quot;</span><span class="s0">,</span><span class="s1">&quot;getStaticContextFromError&quot;</span><span class="s0">,</span><span class="s1">&quot;boundaryRouteId&quot;</span><span class="s0">,</span><span class="s1">&quot;find&quot;</span><span class="s0">,</span><span class="s1">&quot;queryRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;error2&quot;</span><span class="s0">,</span><span class="s1">&quot;values&quot;</span><span class="s0">,</span><span class="s1">&quot;routeMatch&quot;</span><span class="s0">,</span><span class="s1">&quot;submit&quot;</span><span class="s0">,</span><span class="s1">&quot;loadRouteData&quot;</span><span class="s0">,</span><span class="s1">&quot;isDataStrategyResult&quot;</span><span class="s0">,</span><span class="s1">&quot;isRedirectResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;isRouteRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;throwStaticHandlerAbortedError&quot;</span><span class="s0">,</span><span class="s1">&quot;Location&quot;</span><span class="s0">,</span><span class="s1">&quot;loaderRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;Request&quot;</span><span class="s0">,</span><span class="s1">&quot;handlerContext2&quot;</span><span class="s0">,</span><span class="s1">&quot;handlerContext&quot;</span><span class="s0">,</span><span class="s1">&quot;maxIdx&quot;</span><span class="s0">,</span><span class="s1">&quot;getDataStrategyMatch&quot;</span><span class="s0">,</span><span class="s1">&quot;processRouteLoaderData&quot;</span><span class="s0">,</span><span class="s1">&quot;defaultDataStrategy&quot;</span><span class="s0">,</span><span class="s1">&quot;errorBoundaryId&quot;</span><span class="s0">,</span><span class="s1">&quot;_deepestRenderedBoundaryId&quot;</span><span class="s0">,</span><span class="s1">&quot;reason&quot;</span><span class="s0">,</span><span class="s1">&quot;isSubmissionNavigation&quot;</span><span class="s0">,</span><span class="s1">&quot;body&quot;</span><span class="s0">,</span><span class="s1">&quot;contextualMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;activeRouteMatch&quot;</span><span class="s0">,</span><span class="s1">&quot;nakedIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;hasNakedIndexQuery&quot;</span><span class="s0">,</span><span class="s1">&quot;URLSearchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;indexValues&quot;</span><span class="s0">,</span><span class="s1">&quot;getAll&quot;</span><span class="s0">,</span><span class="s1">&quot;append&quot;</span><span class="s0">,</span><span class="s1">&quot;qs&quot;</span><span class="s0">,</span><span class="s1">&quot;isFetcher&quot;</span><span class="s0">,</span><span class="s1">&quot;getInvalidBodyError&quot;</span><span class="s0">,</span><span class="s1">&quot;rawFormMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;toUpperCase&quot;</span><span class="s0">,</span><span class="s1">&quot;stripHashFromPath&quot;</span><span class="s0">,</span><span class="s1">&quot;FormData&quot;</span><span class="s0">,</span><span class="s1">&quot;parse&quot;</span><span class="s0">,</span><span class="s1">&quot;searchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;convertFormDataToSearchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;convertSearchParamsToFormData&quot;</span><span class="s0">,</span><span class="s1">&quot;lazyRoutePropertiesToSkip&quot;</span><span class="s0">,</span><span class="s1">&quot;currentUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;nextUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;actionStatus&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldSkipRevalidation&quot;</span><span class="s0">,</span><span class="s1">&quot;baseShouldRevalidateArgs&quot;</span><span class="s0">,</span><span class="s1">&quot;currentParams&quot;</span><span class="s0">,</span><span class="s1">&quot;nextParams&quot;</span><span class="s0">,</span><span class="s1">&quot;forceShouldLoad&quot;</span><span class="s0">,</span><span class="s1">&quot;isNewLoader&quot;</span><span class="s0">,</span><span class="s1">&quot;defaultShouldRevalidate&quot;</span><span class="s0">,</span><span class="s1">&quot;isNewRouteInstance&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldRevalidateArgs&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldRevalidateLoader&quot;</span><span class="s0">,</span><span class="s1">&quot;fetcherMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;fetcherMatch&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchController&quot;</span><span class="s0">,</span><span class="s1">&quot;fetcherDsMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;hasData&quot;</span><span class="s0">,</span><span class="s1">&quot;hasError&quot;</span><span class="s0">,</span><span class="s1">&quot;hydrate&quot;</span><span class="s0">,</span><span class="s1">&quot;currentLoaderData&quot;</span><span class="s0">,</span><span class="s1">&quot;currentMatch&quot;</span><span class="s0">,</span><span class="s1">&quot;isNew&quot;</span><span class="s0">,</span><span class="s1">&quot;isMissingData&quot;</span><span class="s0">,</span><span class="s1">&quot;hasOwnProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;currentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;loaderMatch&quot;</span><span class="s0">,</span><span class="s1">&quot;arg&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldRevalidate&quot;</span><span class="s0">,</span><span class="s1">&quot;routeChoice&quot;</span><span class="s0">,</span><span class="s1">&quot;childrenToPatch&quot;</span><span class="s0">,</span><span class="s1">&quot;uniqueChildren&quot;</span><span class="s0">,</span><span class="s1">&quot;newRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;existingRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;isSameRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;aChild&quot;</span><span class="s0">,</span><span class="s1">&quot;bChild&quot;</span><span class="s0">,</span><span class="s1">&quot;lazyRoutePropertyCache&quot;</span><span class="s0">,</span><span class="s1">&quot;loadLazyRouteProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;routeToUpdate&quot;</span><span class="s0">,</span><span class="s1">&quot;lazyFn&quot;</span><span class="s0">,</span><span class="s1">&quot;cache&quot;</span><span class="s0">,</span><span class="s1">&quot;cachedPromise&quot;</span><span class="s0">,</span><span class="s1">&quot;propertyPromise&quot;</span><span class="s0">,</span><span class="s1">&quot;isUnsupported&quot;</span><span class="s0">,</span><span class="s1">&quot;staticRouteValue&quot;</span><span class="s0">,</span><span class="s1">&quot;isStaticallyDefined&quot;</span><span class="s0">,</span><span class="s1">&quot;lazyRouteFunctionCache&quot;</span><span class="s0">,</span><span class="s1">&quot;loadLazyRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;lazyRoutePromise&quot;</span><span class="s0">,</span><span class="s1">&quot;lazyHandlerPromise&quot;</span><span class="s0">,</span><span class="s1">&quot;lazyRoutePromise2&quot;</span><span class="s0">,</span><span class="s1">&quot;lazyRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;routeUpdates&quot;</span><span class="s0">,</span><span class="s1">&quot;lazyRouteProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;lazyValue&quot;</span><span class="s0">,</span><span class="s1">&quot;catch&quot;</span><span class="s0">,</span><span class="s1">&quot;lazyKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;lazyPropertyPromises&quot;</span><span class="s0">,</span><span class="s1">&quot;isNonNullable&quot;</span><span class="s0">,</span><span class="s1">&quot;promises&quot;</span><span class="s0">,</span><span class="s1">&quot;args&quot;</span><span class="s0">,</span><span class="s1">&quot;matchesToLoad&quot;</span><span class="s0">,</span><span class="s1">&quot;keyedResults&quot;</span><span class="s0">,</span><span class="s1">&quot;propagateResult&quot;</span><span class="s0">,</span><span class="s1">&quot;handler&quot;</span><span class="s0">,</span><span class="s1">&quot;errorHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;middlewareState&quot;</span><span class="s0">,</span><span class="s1">&quot;handlerResult&quot;</span><span class="s0">,</span><span class="s1">&quot;tuples&quot;</span><span class="s0">,</span><span class="s1">&quot;flatMap&quot;</span><span class="s0">,</span><span class="s1">&quot;callRouteMiddleware&quot;</span><span class="s0">,</span><span class="s1">&quot;middlewareError&quot;</span><span class="s0">,</span><span class="s1">&quot;middlewares&quot;</span><span class="s0">,</span><span class="s1">&quot;tuple&quot;</span><span class="s0">,</span><span class="s1">&quot;middleware&quot;</span><span class="s0">,</span><span class="s1">&quot;nextCalled&quot;</span><span class="s0">,</span><span class="s1">&quot;nextResult&quot;</span><span class="s0">,</span><span class="s1">&quot;next&quot;</span><span class="s0">,</span><span class="s1">&quot;getDataStrategyMatchLazyPromises&quot;</span><span class="s0">,</span><span class="s1">&quot;lazyMiddlewarePromise&quot;</span><span class="s0">,</span><span class="s1">&quot;lazyRoutePromises&quot;</span><span class="s0">,</span><span class="s1">&quot;unstable_shouldRevalidateArgs&quot;</span><span class="s0">,</span><span class="s1">&quot;isUsingNewApi&quot;</span><span class="s0">,</span><span class="s1">&quot;_lazyPromises&quot;</span><span class="s0">,</span><span class="s1">&quot;unstable_shouldCallHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;handlerOverride&quot;</span><span class="s0">,</span><span class="s1">&quot;callLoaderOrAction&quot;</span><span class="s0">,</span><span class="s1">&quot;targetMatch&quot;</span><span class="s0">,</span><span class="s1">&quot;isStaticHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;dataStrategyArgs&quot;</span><span class="s0">,</span><span class="s1">&quot;unstable_runClientMiddleware&quot;</span><span class="s0">,</span><span class="s1">&quot;cb&quot;</span><span class="s0">,</span><span class="s1">&quot;typedDataStrategyArgs&quot;</span><span class="s0">,</span><span class="s1">&quot;onReject&quot;</span><span class="s0">,</span><span class="s1">&quot;isAction&quot;</span><span class="s0">,</span><span class="s1">&quot;runHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;reject&quot;</span><span class="s0">,</span><span class="s1">&quot;abortPromise&quot;</span><span class="s0">,</span><span class="s1">&quot;actualHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;ctx&quot;</span><span class="s0">,</span><span class="s1">&quot;handlerPromise&quot;</span><span class="s0">,</span><span class="s1">&quot;val&quot;</span><span class="s0">,</span><span class="s1">&quot;race&quot;</span><span class="s0">,</span><span class="s1">&quot;handlerError&quot;</span><span class="s0">,</span><span class="s1">&quot;handler2&quot;</span><span class="s0">,</span><span class="s1">&quot;dataStrategyResult&quot;</span><span class="s0">,</span><span class="s1">&quot;contentType&quot;</span><span class="s0">,</span><span class="s1">&quot;isDataWithResponseInit&quot;</span><span class="s0">,</span><span class="s1">&quot;trimmedMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizedLocation&quot;</span><span class="s0">,</span><span class="s1">&quot;protocol&quot;</span><span class="s0">,</span><span class="s1">&quot;isSameBasename&quot;</span><span class="s0">,</span><span class="s1">&quot;foundError&quot;</span><span class="s0">,</span><span class="s1">&quot;newLoaderData&quot;</span><span class="s0">,</span><span class="s1">&quot;mergedLoaderData&quot;</span><span class="s0">,</span><span class="s1">&quot;merged&quot;</span><span class="s0">,</span><span class="s1">&quot;eligibleMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;reverse&quot;</span><span class="s0">,</span><span class="s1">&quot;errorMessage&quot;</span><span class="s0">,</span><span class="s1">&quot;isRedirectStatusCode&quot;</span><span class="s0">,</span><span class="s1">&quot;_window&quot;</span><span class="s0">,</span><span class="s1">&quot;transitions&quot;</span><span class="s0">,</span><span class="s1">&quot;sessionPositions&quot;</span><span class="s0">,</span><span class="s1">&quot;sessionStorage&quot;</span><span class="s0">,</span><span class="s1">&quot;getItem&quot;</span><span class="s0">,</span><span class="s1">&quot;isArray&quot;</span><span class="s0">,</span><span class="s1">&quot;setItem&quot;</span><span class="s0">,</span><span class="s1">&quot;rej&quot;</span><span class="s0">,</span><span class="s1">&quot;React3&quot;</span><span class="s0">,</span><span class="s1">&quot;React&quot;</span><span class="s0">,</span><span class="s1">&quot;DataRouterContext&quot;</span><span class="s0">,</span><span class="s1">&quot;createContext&quot;</span><span class="s0">,</span><span class="s1">&quot;displayName&quot;</span><span class="s0">,</span><span class="s1">&quot;DataRouterStateContext&quot;</span><span class="s0">,</span><span class="s1">&quot;ViewTransitionContext&quot;</span><span class="s0">,</span><span class="s1">&quot;isTransitioning&quot;</span><span class="s0">,</span><span class="s1">&quot;FetchersContext&quot;</span><span class="s0">,</span><span class="s1">&quot;AwaitContext&quot;</span><span class="s0">,</span><span class="s1">&quot;NavigationContext&quot;</span><span class="s0">,</span><span class="s1">&quot;LocationContext&quot;</span><span class="s0">,</span><span class="s1">&quot;RouteContext&quot;</span><span class="s0">,</span><span class="s1">&quot;outlet&quot;</span><span class="s0">,</span><span class="s1">&quot;isDataRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;RouteErrorContext&quot;</span><span class="s0">,</span><span class="s1">&quot;ENABLE_DEV_WARNINGS&quot;</span><span class="s0">,</span><span class="s1">&quot;React2&quot;</span><span class="s0">,</span><span class="s1">&quot;useHref&quot;</span><span class="s0">,</span><span class="s1">&quot;useInRouterContext&quot;</span><span class="s0">,</span><span class="s1">&quot;navigator&quot;</span><span class="s0">,</span><span class="s1">&quot;useContext&quot;</span><span class="s0">,</span><span class="s1">&quot;useResolvedPath&quot;</span><span class="s0">,</span><span class="s1">&quot;joinedPathname&quot;</span><span class="s0">,</span><span class="s1">&quot;useLocation&quot;</span><span class="s0">,</span><span class="s1">&quot;useNavigationType&quot;</span><span class="s0">,</span><span class="s1">&quot;navigationType&quot;</span><span class="s0">,</span><span class="s1">&quot;useMatch&quot;</span><span class="s0">,</span><span class="s1">&quot;useMemo&quot;</span><span class="s0">,</span><span class="s1">&quot;navigateEffectWarning&quot;</span><span class="s0">,</span><span class="s1">&quot;useIsomorphicLayoutEffect&quot;</span><span class="s0">,</span><span class="s1">&quot;isStatic&quot;</span><span class="s0">,</span><span class="s1">&quot;static&quot;</span><span class="s0">,</span><span class="s1">&quot;useLayoutEffect&quot;</span><span class="s0">,</span><span class="s1">&quot;useNavigate&quot;</span><span class="s0">,</span><span class="s1">&quot;useNavigateStable&quot;</span><span class="s0">,</span><span class="s1">&quot;useNavigateUnstable&quot;</span><span class="s0">,</span><span class="s1">&quot;dataRouterContext&quot;</span><span class="s0">,</span><span class="s1">&quot;routePathnamesJson&quot;</span><span class="s0">,</span><span class="s1">&quot;activeRef&quot;</span><span class="s0">,</span><span class="s1">&quot;useRef&quot;</span><span class="s0">,</span><span class="s1">&quot;useCallback&quot;</span><span class="s0">,</span><span class="s1">&quot;OutletContext&quot;</span><span class="s0">,</span><span class="s1">&quot;useOutletContext&quot;</span><span class="s0">,</span><span class="s1">&quot;useOutlet&quot;</span><span class="s0">,</span><span class="s1">&quot;Provider&quot;</span><span class="s0">,</span><span class="s1">&quot;useParams&quot;</span><span class="s0">,</span><span class="s1">&quot;useRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;useRoutesImpl&quot;</span><span class="s0">,</span><span class="s1">&quot;dataRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;parentMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;parentParams&quot;</span><span class="s0">,</span><span class="s1">&quot;parentPathname&quot;</span><span class="s0">,</span><span class="s1">&quot;parentPathnameBase&quot;</span><span class="s0">,</span><span class="s1">&quot;parentRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;warningOnce&quot;</span><span class="s0">,</span><span class="s1">&quot;locationFromContext&quot;</span><span class="s0">,</span><span class="s1">&quot;parsedLocationArg&quot;</span><span class="s0">,</span><span class="s1">&quot;parentSegments&quot;</span><span class="s0">,</span><span class="s1">&quot;element&quot;</span><span class="s0">,</span><span class="s1">&quot;Component&quot;</span><span class="s0">,</span><span class="s1">&quot;renderedMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;_renderMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;DefaultErrorComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;useRouteError&quot;</span><span class="s0">,</span><span class="s1">&quot;stack&quot;</span><span class="s0">,</span><span class="s1">&quot;lightgrey&quot;</span><span class="s0">,</span><span class="s1">&quot;preStyles&quot;</span><span class="s0">,</span><span class="s1">&quot;padding&quot;</span><span class="s0">,</span><span class="s1">&quot;backgroundColor&quot;</span><span class="s0">,</span><span class="s1">&quot;codeStyles&quot;</span><span class="s0">,</span><span class="s1">&quot;devInfo&quot;</span><span class="s0">,</span><span class="s1">&quot;Fragment&quot;</span><span class="s0">,</span><span class="s1">&quot;style&quot;</span><span class="s0">,</span><span class="s1">&quot;fontStyle&quot;</span><span class="s0">,</span><span class="s1">&quot;defaultErrorElement&quot;</span><span class="s0">,</span><span class="s1">&quot;RenderErrorBoundary&quot;</span><span class="s0">,</span><span class="s1">&quot;props&quot;</span><span class="s0">,</span><span class="s1">&quot;getDerivedStateFromError&quot;</span><span class="s0">,</span><span class="s1">&quot;getDerivedStateFromProps&quot;</span><span class="s0">,</span><span class="s1">&quot;componentDidCatch&quot;</span><span class="s0">,</span><span class="s1">&quot;errorInfo&quot;</span><span class="s0">,</span><span class="s1">&quot;render&quot;</span><span class="s0">,</span><span class="s1">&quot;routeContext&quot;</span><span class="s0">,</span><span class="s1">&quot;component&quot;</span><span class="s0">,</span><span class="s1">&quot;RenderedRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;errorElement&quot;</span><span class="s0">,</span><span class="s1">&quot;ErrorBoundary&quot;</span><span class="s0">,</span><span class="s1">&quot;errorIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;renderFallback&quot;</span><span class="s0">,</span><span class="s1">&quot;fallbackIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;HydrateFallback&quot;</span><span class="s0">,</span><span class="s1">&quot;hydrateFallbackElement&quot;</span><span class="s0">,</span><span class="s1">&quot;errors2&quot;</span><span class="s0">,</span><span class="s1">&quot;needsToRunLoader&quot;</span><span class="s0">,</span><span class="s1">&quot;reduceRight&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldRenderHydrateFallback&quot;</span><span class="s0">,</span><span class="s1">&quot;matches2&quot;</span><span class="s0">,</span><span class="s1">&quot;getChildren&quot;</span><span class="s0">,</span><span class="s1">&quot;getDataRouterConsoleError&quot;</span><span class="s0">,</span><span class="s1">&quot;hookName&quot;</span><span class="s0">,</span><span class="s1">&quot;useDataRouterContext&quot;</span><span class="s0">,</span><span class="s1">&quot;useDataRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;useRouteContext&quot;</span><span class="s0">,</span><span class="s1">&quot;useCurrentRouteId&quot;</span><span class="s0">,</span><span class="s1">&quot;thisRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;useRouteId&quot;</span><span class="s0">,</span><span class="s1">&quot;useNavigation&quot;</span><span class="s0">,</span><span class="s1">&quot;useRevalidator&quot;</span><span class="s0">,</span><span class="s1">&quot;useMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;useLoaderData&quot;</span><span class="s0">,</span><span class="s1">&quot;useRouteLoaderData&quot;</span><span class="s0">,</span><span class="s1">&quot;useActionData&quot;</span><span class="s0">,</span><span class="s1">&quot;useAsyncValue&quot;</span><span class="s0">,</span><span class="s1">&quot;_data&quot;</span><span class="s0">,</span><span class="s1">&quot;useAsyncError&quot;</span><span class="s0">,</span><span class="s1">&quot;_error&quot;</span><span class="s0">,</span><span class="s1">&quot;blockerId&quot;</span><span class="s0">,</span><span class="s1">&quot;useBlocker&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldBlock&quot;</span><span class="s0">,</span><span class="s1">&quot;setBlockerKey&quot;</span><span class="s0">,</span><span class="s1">&quot;useState&quot;</span><span class="s0">,</span><span class="s1">&quot;useEffect&quot;</span><span class="s0">,</span><span class="s1">&quot;alreadyWarned&quot;</span><span class="s0">,</span><span class="s1">&quot;alreadyWarned2&quot;</span><span class="s0">,</span><span class="s1">&quot;warnOnce&quot;</span><span class="s0">,</span><span class="s1">&quot;condition&quot;</span><span class="s0">,</span><span class="s1">&quot;createMemoryRouter&quot;</span><span class="s0">,</span><span class="s1">&quot;Deferred&quot;</span><span class="s0">,</span><span class="s1">&quot;RouterProvider&quot;</span><span class="s0">,</span><span class="s1">&quot;reactDomFlushSyncImpl&quot;</span><span class="s0">,</span><span class="s1">&quot;setStateImpl&quot;</span><span class="s0">,</span><span class="s1">&quot;pendingState&quot;</span><span class="s0">,</span><span class="s1">&quot;setPendingState&quot;</span><span class="s0">,</span><span class="s1">&quot;vtContext&quot;</span><span class="s0">,</span><span class="s1">&quot;setVtContext&quot;</span><span class="s0">,</span><span class="s1">&quot;renderDfd&quot;</span><span class="s0">,</span><span class="s1">&quot;setRenderDfd&quot;</span><span class="s0">,</span><span class="s1">&quot;transition&quot;</span><span class="s0">,</span><span class="s1">&quot;setTransition&quot;</span><span class="s0">,</span><span class="s1">&quot;interruption&quot;</span><span class="s0">,</span><span class="s1">&quot;setInterruption&quot;</span><span class="s0">,</span><span class="s1">&quot;fetcherData&quot;</span><span class="s0">,</span><span class="s1">&quot;setState&quot;</span><span class="s0">,</span><span class="s1">&quot;isViewTransitionAvailable&quot;</span><span class="s0">,</span><span class="s1">&quot;startViewTransition&quot;</span><span class="s0">,</span><span class="s1">&quot;startTransition&quot;</span><span class="s0">,</span><span class="s1">&quot;skipTransition&quot;</span><span class="s0">,</span><span class="s1">&quot;t&quot;</span><span class="s0">,</span><span class="s1">&quot;finished&quot;</span><span class="s0">,</span><span class="s1">&quot;finally&quot;</span><span class="s0">,</span><span class="s1">&quot;renderPromise&quot;</span><span class="s0">,</span><span class="s1">&quot;transition2&quot;</span><span class="s0">,</span><span class="s1">&quot;state2&quot;</span><span class="s0">,</span><span class="s1">&quot;Router&quot;</span><span class="s0">,</span><span class="s1">&quot;MemoizedDataRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;memo&quot;</span><span class="s0">,</span><span class="s1">&quot;DataRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;MemoryRouter&quot;</span><span class="s0">,</span><span class="s1">&quot;historyRef&quot;</span><span class="s0">,</span><span class="s1">&quot;Navigate&quot;</span><span class="s0">,</span><span class="s1">&quot;jsonPath&quot;</span><span class="s0">,</span><span class="s1">&quot;Outlet&quot;</span><span class="s0">,</span><span class="s1">&quot;Route&quot;</span><span class="s0">,</span><span class="s1">&quot;_props&quot;</span><span class="s0">,</span><span class="s1">&quot;basenameProp&quot;</span><span class="s0">,</span><span class="s1">&quot;locationProp&quot;</span><span class="s0">,</span><span class="s1">&quot;staticProp&quot;</span><span class="s0">,</span><span class="s1">&quot;navigationContext&quot;</span><span class="s0">,</span><span class="s1">&quot;locationContext&quot;</span><span class="s0">,</span><span class="s1">&quot;trailingPathname&quot;</span><span class="s0">,</span><span class="s1">&quot;Routes&quot;</span><span class="s0">,</span><span class="s1">&quot;createRoutesFromChildren&quot;</span><span class="s0">,</span><span class="s1">&quot;Await&quot;</span><span class="s0">,</span><span class="s1">&quot;AwaitErrorBoundary&quot;</span><span class="s0">,</span><span class="s1">&quot;ResolveAwait&quot;</span><span class="s0">,</span><span class="s1">&quot;defineProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;renderError&quot;</span><span class="s0">,</span><span class="s1">&quot;_tracked&quot;</span><span class="s0">,</span><span class="s1">&quot;toRender&quot;</span><span class="s0">,</span><span class="s1">&quot;Children&quot;</span><span class="s0">,</span><span class="s1">&quot;isValidElement&quot;</span><span class="s0">,</span><span class="s1">&quot;apply&quot;</span><span class="s0">,</span><span class="s1">&quot;createRoutesFromElements&quot;</span><span class="s0">,</span><span class="s1">&quot;renderMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;React10&quot;</span><span class="s0">,</span><span class="s1">&quot;defaultMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;defaultEncType&quot;</span><span class="s0">,</span><span class="s1">&quot;isHtmlElement&quot;</span><span class="s0">,</span><span class="s1">&quot;object&quot;</span><span class="s0">,</span><span class="s1">&quot;tagName&quot;</span><span class="s0">,</span><span class="s1">&quot;isButtonElement&quot;</span><span class="s0">,</span><span class="s1">&quot;isFormElement&quot;</span><span class="s0">,</span><span class="s1">&quot;isInputElement&quot;</span><span class="s0">,</span><span class="s1">&quot;isModifiedEvent&quot;</span><span class="s0">,</span><span class="s1">&quot;event&quot;</span><span class="s0">,</span><span class="s1">&quot;metaKey&quot;</span><span class="s0">,</span><span class="s1">&quot;altKey&quot;</span><span class="s0">,</span><span class="s1">&quot;ctrlKey&quot;</span><span class="s0">,</span><span class="s1">&quot;shiftKey&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldProcessLinkClick&quot;</span><span class="s0">,</span><span class="s1">&quot;target&quot;</span><span class="s0">,</span><span class="s1">&quot;button&quot;</span><span class="s0">,</span><span class="s1">&quot;createSearchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;getSearchParamsForLocation&quot;</span><span class="s0">,</span><span class="s1">&quot;locationSearch&quot;</span><span class="s0">,</span><span class="s1">&quot;defaultSearchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;_formDataSupportsSubmitter&quot;</span><span class="s0">,</span><span class="s1">&quot;isFormDataSubmitterSupported&quot;</span><span class="s0">,</span><span class="s1">&quot;supportedFormEncTypes&quot;</span><span class="s0">,</span><span class="s1">&quot;getFormEncType&quot;</span><span class="s0">,</span><span class="s1">&quot;encType&quot;</span><span class="s0">,</span><span class="s1">&quot;getFormSubmissionInfo&quot;</span><span class="s0">,</span><span class="s1">&quot;attr&quot;</span><span class="s0">,</span><span class="s1">&quot;form&quot;</span><span class="s0">,</span><span class="s1">&quot;React9&quot;</span><span class="s0">,</span><span class="s1">&quot;invariant2&quot;</span><span class="s0">,</span><span class="s1">&quot;loadRouteModule&quot;</span><span class="s0">,</span><span class="s1">&quot;routeModulesCache&quot;</span><span class="s0">,</span><span class="s1">&quot;routeModule&quot;</span><span class="s0">,</span><span class="s1">&quot;module&quot;</span><span class="s0">,</span><span class="s1">&quot;__reactRouterContext&quot;</span><span class="s0">,</span><span class="s1">&quot;isSpaMode&quot;</span><span class="s0">,</span><span class="s1">&quot;import&quot;</span><span class="s0">,</span><span class="s1">&quot;hot&quot;</span><span class="s0">,</span><span class="s1">&quot;reload&quot;</span><span class="s0">,</span><span class="s1">&quot;getKeyedLinksForMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;routeModules&quot;</span><span class="s0">,</span><span class="s1">&quot;descriptors&quot;</span><span class="s0">,</span><span class="s1">&quot;css&quot;</span><span class="s0">,</span><span class="s1">&quot;rel&quot;</span><span class="s0">,</span><span class="s1">&quot;links&quot;</span><span class="s0">,</span><span class="s1">&quot;flat&quot;</span><span class="s0">,</span><span class="s1">&quot;preloads&quot;</span><span class="s0">,</span><span class="s1">&quot;getModuleLinkHrefs&quot;</span><span class="s0">,</span><span class="s1">&quot;dedupeLinkDescriptors&quot;</span><span class="s0">,</span><span class="s1">&quot;getRouteCssDescriptors&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchRouteCss&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchStyleLink&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchStyleLinks&quot;</span><span class="s0">,</span><span class="s1">&quot;isPreloadSupported&quot;</span><span class="s0">,</span><span class="s1">&quot;styleLinks&quot;</span><span class="s0">,</span><span class="s1">&quot;descriptor&quot;</span><span class="s0">,</span><span class="s1">&quot;isPageLinkDescriptor&quot;</span><span class="s0">,</span><span class="s1">&quot;as&quot;</span><span class="s0">,</span><span class="s1">&quot;media&quot;</span><span class="s0">,</span><span class="s1">&quot;matchMedia&quot;</span><span class="s0">,</span><span class="s1">&quot;link&quot;</span><span class="s0">,</span><span class="s1">&quot;removeLink&quot;</span><span class="s0">,</span><span class="s1">&quot;head&quot;</span><span class="s0">,</span><span class="s1">&quot;contains&quot;</span><span class="s0">,</span><span class="s1">&quot;removeChild&quot;</span><span class="s0">,</span><span class="s1">&quot;onload&quot;</span><span class="s0">,</span><span class="s1">&quot;onerror&quot;</span><span class="s0">,</span><span class="s1">&quot;appendChild&quot;</span><span class="s0">,</span><span class="s1">&quot;page&quot;</span><span class="s0">,</span><span class="s1">&quot;isHtmlLinkDescriptor&quot;</span><span class="s0">,</span><span class="s1">&quot;imageSrcSet&quot;</span><span class="s0">,</span><span class="s1">&quot;imageSizes&quot;</span><span class="s0">,</span><span class="s1">&quot;getKeyedPrefetchLinks&quot;</span><span class="s0">,</span><span class="s1">&quot;mod&quot;</span><span class="s0">,</span><span class="s1">&quot;getNewMatchesForLinks&quot;</span><span class="s0">,</span><span class="s1">&quot;nextMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;currentMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;mode&quot;</span><span class="s0">,</span><span class="s1">&quot;matchPathChanged&quot;</span><span class="s0">,</span><span class="s1">&quot;manifestRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;hasLoader&quot;</span><span class="s0">,</span><span class="s1">&quot;includeHydrateFallback&quot;</span><span class="s0">,</span><span class="s1">&quot;dedupeHrefs&quot;</span><span class="s0">,</span><span class="s1">&quot;hrefs&quot;</span><span class="s0">,</span><span class="s1">&quot;clientActionModule&quot;</span><span class="s0">,</span><span class="s1">&quot;clientLoaderModule&quot;</span><span class="s0">,</span><span class="s1">&quot;hydrateFallbackModule&quot;</span><span class="s0">,</span><span class="s1">&quot;imports&quot;</span><span class="s0">,</span><span class="s1">&quot;sortKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;sorted&quot;</span><span class="s0">,</span><span class="s1">&quot;preloadsSet&quot;</span><span class="s0">,</span><span class="s1">&quot;deduped&quot;</span><span class="s0">,</span><span class="s1">&quot;alreadyModulePreload&quot;</span><span class="s0">,</span><span class="s1">&quot;_isPreloadSupported&quot;</span><span class="s0">,</span><span class="s1">&quot;el&quot;</span><span class="s0">,</span><span class="s1">&quot;relList&quot;</span><span class="s0">,</span><span class="s1">&quot;supports&quot;</span><span class="s0">,</span><span class="s1">&quot;ESCAPE_LOOKUP&quot;</span><span class="s0">,</span><span class="s1">&quot;ESCAPE_REGEX&quot;</span><span class="s0">,</span><span class="s1">&quot;escapeHtml&quot;</span><span class="s0">,</span><span class="s1">&quot;html&quot;</span><span class="s0">,</span><span class="s1">&quot;createHtml&quot;</span><span class="s0">,</span><span class="s1">&quot;__html&quot;</span><span class="s0">,</span><span class="s1">&quot;React4&quot;</span><span class="s0">,</span><span class="s1">&quot;HOLE&quot;</span><span class="s0">,</span><span class="s1">&quot;NAN&quot;</span><span class="s0">,</span><span class="s1">&quot;NEGATIVE_INFINITY&quot;</span><span class="s0">,</span><span class="s1">&quot;NEGATIVE_ZERO&quot;</span><span class="s0">,</span><span class="s1">&quot;NULL&quot;</span><span class="s0">,</span><span class="s1">&quot;POSITIVE_INFINITY&quot;</span><span class="s0">,</span><span class="s1">&quot;UNDEFINED&quot;</span><span class="s0">,</span><span class="s1">&quot;TYPE_BIGINT&quot;</span><span class="s0">,</span><span class="s1">&quot;TYPE_DATE&quot;</span><span class="s0">,</span><span class="s1">&quot;TYPE_ERROR&quot;</span><span class="s0">,</span><span class="s1">&quot;TYPE_MAP&quot;</span><span class="s0">,</span><span class="s1">&quot;TYPE_NULL_OBJECT&quot;</span><span class="s0">,</span><span class="s1">&quot;TYPE_PROMISE&quot;</span><span class="s0">,</span><span class="s1">&quot;TYPE_REGEXP&quot;</span><span class="s0">,</span><span class="s1">&quot;TYPE_SET&quot;</span><span class="s0">,</span><span class="s1">&quot;TYPE_SYMBOL&quot;</span><span class="s0">,</span><span class="s1">&quot;TYPE_URL&quot;</span><span class="s0">,</span><span class="s1">&quot;TYPE_PREVIOUS_RESOLVED&quot;</span><span class="s0">,</span><span class="s1">&quot;Deferred2&quot;</span><span class="s0">,</span><span class="s1">&quot;createLineSplittingTransform&quot;</span><span class="s0">,</span><span class="s1">&quot;decoder&quot;</span><span class="s0">,</span><span class="s1">&quot;TextDecoder&quot;</span><span class="s0">,</span><span class="s1">&quot;leftover&quot;</span><span class="s0">,</span><span class="s1">&quot;TransformStream&quot;</span><span class="s0">,</span><span class="s1">&quot;transform&quot;</span><span class="s0">,</span><span class="s1">&quot;chunk&quot;</span><span class="s0">,</span><span class="s1">&quot;str&quot;</span><span class="s0">,</span><span class="s1">&quot;decode&quot;</span><span class="s0">,</span><span class="s1">&quot;stream&quot;</span><span class="s0">,</span><span class="s1">&quot;parts&quot;</span><span class="s0">,</span><span class="s1">&quot;part&quot;</span><span class="s0">,</span><span class="s1">&quot;enqueue&quot;</span><span class="s0">,</span><span class="s1">&quot;flush&quot;</span><span class="s0">,</span><span class="s1">&quot;flatten&quot;</span><span class="s0">,</span><span class="s1">&quot;input&quot;</span><span class="s0">,</span><span class="s1">&quot;indices&quot;</span><span class="s0">,</span><span class="s1">&quot;existing&quot;</span><span class="s0">,</span><span class="s1">&quot;Number&quot;</span><span class="s0">,</span><span class="s1">&quot;isNaN&quot;</span><span class="s0">,</span><span class="s1">&quot;deferred&quot;</span><span class="s0">,</span><span class="s1">&quot;plugins&quot;</span><span class="s0">,</span><span class="s1">&quot;postPlugins&quot;</span><span class="s0">,</span><span class="s1">&quot;stringified&quot;</span><span class="s0">,</span><span class="s1">&quot;input2&quot;</span><span class="s0">,</span><span class="s1">&quot;partsForObj&quot;</span><span class="s0">,</span><span class="s1">&quot;keyFor&quot;</span><span class="s0">,</span><span class="s1">&quot;pluginHandled&quot;</span><span class="s0">,</span><span class="s1">&quot;plugin&quot;</span><span class="s0">,</span><span class="s1">&quot;pluginResult&quot;</span><span class="s0">,</span><span class="s1">&quot;pluginIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;Date&quot;</span><span class="s0">,</span><span class="s1">&quot;getTime&quot;</span><span class="s0">,</span><span class="s1">&quot;source&quot;</span><span class="s0">,</span><span class="s1">&quot;flags&quot;</span><span class="s0">,</span><span class="s1">&quot;getPrototypeOf&quot;</span><span class="s0">,</span><span class="s1">&quot;isPlainObject&quot;</span><span class="s0">,</span><span class="s1">&quot;objectProtoNames&quot;</span><span class="s0">,</span><span class="s1">&quot;getOwnPropertyNames&quot;</span><span class="s0">,</span><span class="s1">&quot;prototype&quot;</span><span class="s0">,</span><span class="s1">&quot;thing&quot;</span><span class="s0">,</span><span class="s1">&quot;proto&quot;</span><span class="s0">,</span><span class="s1">&quot;globalObj&quot;</span><span class="s0">,</span><span class="s1">&quot;globalThis&quot;</span><span class="s0">,</span><span class="s1">&quot;unflatten&quot;</span><span class="s0">,</span><span class="s1">&quot;parsed&quot;</span><span class="s0">,</span><span class="s1">&quot;hydrated&quot;</span><span class="s0">,</span><span class="s1">&quot;SyntaxError&quot;</span><span class="s0">,</span><span class="s1">&quot;postRun&quot;</span><span class="s0">,</span><span class="s1">&quot;NaN&quot;</span><span class="s0">,</span><span class="s1">&quot;Infinity&quot;</span><span class="s0">,</span><span class="s1">&quot;c&quot;</span><span class="s0">,</span><span class="s1">&quot;BigInt&quot;</span><span class="s0">,</span><span class="s1">&quot;for&quot;</span><span class="s0">,</span><span class="s1">&quot;newSet&quot;</span><span class="s0">,</span><span class="s1">&quot;create&quot;</span><span class="s0">,</span><span class="s1">&quot;d&quot;</span><span class="s0">,</span><span class="s1">&quot;errorType&quot;</span><span class="s0">,</span><span class="s1">&quot;vals&quot;</span><span class="s0">,</span><span class="s1">&quot;v2&quot;</span><span class="s0">,</span><span class="s1">&quot;readable&quot;</span><span class="s0">,</span><span class="s1">&quot;done&quot;</span><span class="s0">,</span><span class="s1">&quot;reader&quot;</span><span class="s0">,</span><span class="s1">&quot;pipeThrough&quot;</span><span class="s0">,</span><span class="s1">&quot;getReader&quot;</span><span class="s0">,</span><span class="s1">&quot;decodeInitial&quot;</span><span class="s0">,</span><span class="s1">&quot;donePromise&quot;</span><span class="s0">,</span><span class="s1">&quot;decodeDeferred&quot;</span><span class="s0">,</span><span class="s1">&quot;closed&quot;</span><span class="s0">,</span><span class="s1">&quot;read&quot;</span><span class="s0">,</span><span class="s1">&quot;line&quot;</span><span class="s0">,</span><span class="s1">&quot;colonIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;deferredId&quot;</span><span class="s0">,</span><span class="s1">&quot;lineData&quot;</span><span class="s0">,</span><span class="s1">&quot;jsonLine&quot;</span><span class="s0">,</span><span class="s1">&quot;encode&quot;</span><span class="s0">,</span><span class="s1">&quot;encoder2&quot;</span><span class="s0">,</span><span class="s1">&quot;textEncoder&quot;</span><span class="s0">,</span><span class="s1">&quot;TextEncoder&quot;</span><span class="s0">,</span><span class="s1">&quot;lastSentIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;ReadableStream&quot;</span><span class="s0">,</span><span class="s1">&quot;start&quot;</span><span class="s0">,</span><span class="s1">&quot;seenPromises&quot;</span><span class="s0">,</span><span class="s1">&quot;raceDone&quot;</span><span class="s0">,</span><span class="s1">&quot;racePromise&quot;</span><span class="s0">,</span><span class="s1">&quot;rejectPromise&quot;</span><span class="s0">,</span><span class="s1">&quot;resolved&quot;</span><span class="s0">,</span><span class="s1">&quot;id2&quot;</span><span class="s0">,</span><span class="s1">&quot;close&quot;</span><span class="s0">,</span><span class="s1">&quot;createRequestInit&quot;</span><span class="s0">,</span><span class="s1">&quot;SingleFetchRedirectSymbol&quot;</span><span class="s0">,</span><span class="s1">&quot;SingleFetchNoResultError&quot;</span><span class="s0">,</span><span class="s1">&quot;SINGLE_FETCH_REDIRECT_STATUS&quot;</span><span class="s0">,</span><span class="s1">&quot;NO_BODY_STATUS_CODES&quot;</span><span class="s0">,</span><span class="s1">&quot;StreamTransfer&quot;</span><span class="s0">,</span><span class="s1">&quot;identifier&quot;</span><span class="s0">,</span><span class="s1">&quot;textDecoder&quot;</span><span class="s0">,</span><span class="s1">&quot;nonce&quot;</span><span class="s0">,</span><span class="s1">&quot;renderMeta&quot;</span><span class="s0">,</span><span class="s1">&quot;didRenderScripts&quot;</span><span class="s0">,</span><span class="s1">&quot;streamCache&quot;</span><span class="s0">,</span><span class="s1">&quot;scriptTag&quot;</span><span class="s0">,</span><span class="s1">&quot;dangerouslySetInnerHTML&quot;</span><span class="s0">,</span><span class="s1">&quot;Suspense&quot;</span><span class="s0">,</span><span class="s1">&quot;getTurboStreamSingleFetchDataStrategy&quot;</span><span class="s0">,</span><span class="s1">&quot;getRouter&quot;</span><span class="s0">,</span><span class="s1">&quot;ssr&quot;</span><span class="s0">,</span><span class="s1">&quot;getSingleFetchDataStrategyImpl&quot;</span><span class="s0">,</span><span class="s1">&quot;hasClientLoader&quot;</span><span class="s0">,</span><span class="s1">&quot;hasShouldRevalidate&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchAndDecodeViaTurboStream&quot;</span><span class="s0">,</span><span class="s1">&quot;getRouteInfo&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchAndDecode&quot;</span><span class="s0">,</span><span class="s1">&quot;singleFetchActionStrategy&quot;</span><span class="s0">,</span><span class="s1">&quot;foundRevalidatingServerLoader&quot;</span><span class="s0">,</span><span class="s1">&quot;nonSsrStrategy&quot;</span><span class="s0">,</span><span class="s1">&quot;singleFetchLoaderFetcherStrategy&quot;</span><span class="s0">,</span><span class="s1">&quot;singleFetchLoaderNavigationStrategy&quot;</span><span class="s0">,</span><span class="s1">&quot;unwrapSingleFetchResult&quot;</span><span class="s0">,</span><span class="s1">&quot;routesParams&quot;</span><span class="s0">,</span><span class="s1">&quot;foundOptOutRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;routeDfds&quot;</span><span class="s0">,</span><span class="s1">&quot;createDeferred2&quot;</span><span class="s0">,</span><span class="s1">&quot;singleFetchDfd&quot;</span><span class="s0">,</span><span class="s1">&quot;resolvePromise&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldCall&quot;</span><span class="s0">,</span><span class="s1">&quot;isInitialLoad&quot;</span><span class="s0">,</span><span class="s1">&quot;__reactRouterHdrActive&quot;</span><span class="s0">,</span><span class="s1">&quot;targetRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;bubbleMiddlewareErrors&quot;</span><span class="s0">,</span><span class="s1">&quot;singleFetchPromise&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchedData&quot;</span><span class="s0">,</span><span class="s1">&quot;routeResult&quot;</span><span class="s0">,</span><span class="s1">&quot;stripIndexParam&quot;</span><span class="s0">,</span><span class="s1">&quot;indexValuesToKeep&quot;</span><span class="s0">,</span><span class="s1">&quot;indexValue&quot;</span><span class="s0">,</span><span class="s1">&quot;toKeep&quot;</span><span class="s0">,</span><span class="s1">&quot;singleFetchUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;reqUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;decodeViaTurboStream&quot;</span><span class="s0">,</span><span class="s1">&quot;typed&quot;</span><span class="s0">,</span><span class="s1">&quot;global2&quot;</span><span class="s0">,</span><span class="s1">&quot;Constructor&quot;</span><span class="s0">,</span><span class="s1">&quot;React8&quot;</span><span class="s0">,</span><span class="s1">&quot;React7&quot;</span><span class="s0">,</span><span class="s1">&quot;React5&quot;</span><span class="s0">,</span><span class="s1">&quot;RemixErrorBoundary&quot;</span><span class="s0">,</span><span class="s1">&quot;RemixRootDefaultErrorBoundary&quot;</span><span class="s0">,</span><span class="s1">&quot;isOutsideRemixApp&quot;</span><span class="s0">,</span><span class="s1">&quot;heyDeveloper&quot;</span><span class="s0">,</span><span class="s1">&quot;BoundaryShell&quot;</span><span class="s0">,</span><span class="s1">&quot;title&quot;</span><span class="s0">,</span><span class="s1">&quot;fontSize&quot;</span><span class="s0">,</span><span class="s1">&quot;errorInstance&quot;</span><span class="s0">,</span><span class="s1">&quot;errorString&quot;</span><span class="s0">,</span><span class="s1">&quot;background&quot;</span><span class="s0">,</span><span class="s1">&quot;color&quot;</span><span class="s0">,</span><span class="s1">&quot;overflow&quot;</span><span class="s0">,</span><span class="s1">&quot;renderScripts&quot;</span><span class="s0">,</span><span class="s1">&quot;useFrameworkContext&quot;</span><span class="s0">,</span><span class="s1">&quot;root&quot;</span><span class="s0">,</span><span class="s1">&quot;Layout&quot;</span><span class="s0">,</span><span class="s1">&quot;lang&quot;</span><span class="s0">,</span><span class="s1">&quot;charSet&quot;</span><span class="s0">,</span><span class="s1">&quot;content&quot;</span><span class="s0">,</span><span class="s1">&quot;fontFamily&quot;</span><span class="s0">,</span><span class="s1">&quot;Scripts&quot;</span><span class="s0">,</span><span class="s1">&quot;React6&quot;</span><span class="s0">,</span><span class="s1">&quot;RemixRootDefaultHydrateFallback&quot;</span><span class="s0">,</span><span class="s1">&quot;groupRoutesByParentId&quot;</span><span class="s0">,</span><span class="s1">&quot;parentId&quot;</span><span class="s0">,</span><span class="s1">&quot;getRouteComponents&quot;</span><span class="s0">,</span><span class="s1">&quot;Component4&quot;</span><span class="s0">,</span><span class="s1">&quot;getRouteModuleComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;createServerRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;routesByParentId&quot;</span><span class="s0">,</span><span class="s1">&quot;spaModeLazyPromise&quot;</span><span class="s0">,</span><span class="s1">&quot;dataRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;createClientRoutesWithHMRRevalidationOptOut&quot;</span><span class="s0">,</span><span class="s1">&quot;needsRevalidation&quot;</span><span class="s0">,</span><span class="s1">&quot;initialState&quot;</span><span class="s0">,</span><span class="s1">&quot;createClientRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;preventInvalidServerHandlerCall&quot;</span><span class="s0">,</span><span class="s1">&quot;hasAction&quot;</span><span class="s0">,</span><span class="s1">&quot;noActionDefinedError&quot;</span><span class="s0">,</span><span class="s1">&quot;article&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchServerHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;singleFetch&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchServerLoader&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchServerAction&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchModule&quot;</span><span class="s0">,</span><span class="s1">&quot;modulePath&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchRouteModuleChunks&quot;</span><span class="s0">,</span><span class="s1">&quot;route2&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchStylesAndCallHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;cachedModule&quot;</span><span class="s0">,</span><span class="s1">&quot;linkPrefetchPromise&quot;</span><span class="s0">,</span><span class="s1">&quot;unstable_clientMiddleware&quot;</span><span class="s0">,</span><span class="s1">&quot;getShouldRevalidateFunction&quot;</span><span class="s0">,</span><span class="s1">&quot;hasInitialData&quot;</span><span class="s0">,</span><span class="s1">&quot;initialData&quot;</span><span class="s0">,</span><span class="s1">&quot;hasInitialError&quot;</span><span class="s0">,</span><span class="s1">&quot;initialError&quot;</span><span class="s0">,</span><span class="s1">&quot;isHydrationRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;clientLoader&quot;</span><span class="s0">,</span><span class="s1">&quot;serverLoader&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldHydrateRouteLoader&quot;</span><span class="s0">,</span><span class="s1">&quot;clientAction&quot;</span><span class="s0">,</span><span class="s1">&quot;serverAction&quot;</span><span class="s0">,</span><span class="s1">&quot;hasClientAction&quot;</span><span class="s0">,</span><span class="s1">&quot;getLazyRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;setTimeout&quot;</span><span class="s0">,</span><span class="s1">&quot;routeModulePromise&quot;</span><span class="s0">,</span><span class="s1">&quot;loadRouteModuleWithBlockingLinks&quot;</span><span class="s0">,</span><span class="s1">&quot;clientActionPromise&quot;</span><span class="s0">,</span><span class="s1">&quot;hasClientMiddleware&quot;</span><span class="s0">,</span><span class="s1">&quot;clientMiddlewareModule&quot;</span><span class="s0">,</span><span class="s1">&quot;wrapShouldRevalidateForHdr&quot;</span><span class="s0">,</span><span class="s1">&quot;myParams&quot;</span><span class="s0">,</span><span class="s1">&quot;didParamsChange&quot;</span><span class="s0">,</span><span class="s1">&quot;routeShouldRevalidate&quot;</span><span class="s0">,</span><span class="s1">&quot;handledRevalidation&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchRouteCssPromise&quot;</span><span class="s0">,</span><span class="s1">&quot;default&quot;</span><span class="s0">,</span><span class="s1">&quot;isEmptyObject&quot;</span><span class="s0">,</span><span class="s1">&quot;nextPaths&quot;</span><span class="s0">,</span><span class="s1">&quot;discoveredPathsMaxSize&quot;</span><span class="s0">,</span><span class="s1">&quot;discoveredPaths&quot;</span><span class="s0">,</span><span class="s1">&quot;URL_LIMIT&quot;</span><span class="s0">,</span><span class="s1">&quot;isFogOfWarEnabled&quot;</span><span class="s0">,</span><span class="s1">&quot;routeDiscovery&quot;</span><span class="s0">,</span><span class="s1">&quot;getPartialManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;sri&quot;</span><span class="s0">,</span><span class="s1">&quot;routeIds&quot;</span><span class="s0">,</span><span class="s1">&quot;initialRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;getPatchRoutesOnNavigationFunction&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchAndApplyManifestPatches&quot;</span><span class="s0">,</span><span class="s1">&quot;manifestPath&quot;</span><span class="s0">,</span><span class="s1">&quot;useFogOFWarDiscovery&quot;</span><span class="s0">,</span><span class="s1">&quot;connection&quot;</span><span class="s0">,</span><span class="s1">&quot;saveData&quot;</span><span class="s0">,</span><span class="s1">&quot;registerElement&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchPatches&quot;</span><span class="s0">,</span><span class="s1">&quot;querySelectorAll&quot;</span><span class="s0">,</span><span class="s1">&quot;lazyPaths&quot;</span><span class="s0">,</span><span class="s1">&quot;debouncedFetchPatches&quot;</span><span class="s0">,</span><span class="s1">&quot;debounce&quot;</span><span class="s0">,</span><span class="s1">&quot;observer&quot;</span><span class="s0">,</span><span class="s1">&quot;MutationObserver&quot;</span><span class="s0">,</span><span class="s1">&quot;observe&quot;</span><span class="s0">,</span><span class="s1">&quot;documentElement&quot;</span><span class="s0">,</span><span class="s1">&quot;subtree&quot;</span><span class="s0">,</span><span class="s1">&quot;childList&quot;</span><span class="s0">,</span><span class="s1">&quot;attributes&quot;</span><span class="s0">,</span><span class="s1">&quot;attributeFilter&quot;</span><span class="s0">,</span><span class="s1">&quot;disconnect&quot;</span><span class="s0">,</span><span class="s1">&quot;getManifestPath&quot;</span><span class="s0">,</span><span class="s1">&quot;_manifestPath&quot;</span><span class="s0">,</span><span class="s1">&quot;MANIFEST_VERSION_STORAGE_KEY&quot;</span><span class="s0">,</span><span class="s1">&quot;errorReloadPath&quot;</span><span class="s0">,</span><span class="s1">&quot;version&quot;</span><span class="s0">,</span><span class="s1">&quot;serverPatches&quot;</span><span class="s0">,</span><span class="s1">&quot;ok&quot;</span><span class="s0">,</span><span class="s1">&quot;removeItem&quot;</span><span class="s0">,</span><span class="s1">&quot;knownRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;patches&quot;</span><span class="s0">,</span><span class="s1">&quot;addToFifoQueue&quot;</span><span class="s0">,</span><span class="s1">&quot;parentIds&quot;</span><span class="s0">,</span><span class="s1">&quot;queue&quot;</span><span class="s0">,</span><span class="s1">&quot;callback&quot;</span><span class="s0">,</span><span class="s1">&quot;wait&quot;</span><span class="s0">,</span><span class="s1">&quot;timeoutId&quot;</span><span class="s0">,</span><span class="s1">&quot;clearTimeout&quot;</span><span class="s0">,</span><span class="s1">&quot;useDataRouterContext2&quot;</span><span class="s0">,</span><span class="s1">&quot;useDataRouterStateContext&quot;</span><span class="s0">,</span><span class="s1">&quot;FrameworkContext&quot;</span><span class="s0">,</span><span class="s1">&quot;usePrefetchBehavior&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetch&quot;</span><span class="s0">,</span><span class="s1">&quot;theirElementProps&quot;</span><span class="s0">,</span><span class="s1">&quot;frameworkContext&quot;</span><span class="s0">,</span><span class="s1">&quot;maybePrefetch&quot;</span><span class="s0">,</span><span class="s1">&quot;setMaybePrefetch&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldPrefetch&quot;</span><span class="s0">,</span><span class="s1">&quot;setShouldPrefetch&quot;</span><span class="s0">,</span><span class="s1">&quot;onFocus&quot;</span><span class="s0">,</span><span class="s1">&quot;onBlur&quot;</span><span class="s0">,</span><span class="s1">&quot;onMouseEnter&quot;</span><span class="s0">,</span><span class="s1">&quot;onMouseLeave&quot;</span><span class="s0">,</span><span class="s1">&quot;onTouchStart&quot;</span><span class="s0">,</span><span class="s1">&quot;ref&quot;</span><span class="s0">,</span><span class="s1">&quot;isIntersecting&quot;</span><span class="s0">,</span><span class="s1">&quot;IntersectionObserver&quot;</span><span class="s0">,</span><span class="s1">&quot;threshold&quot;</span><span class="s0">,</span><span class="s1">&quot;setIntent&quot;</span><span class="s0">,</span><span class="s1">&quot;cancelIntent&quot;</span><span class="s0">,</span><span class="s1">&quot;composeEventHandlers&quot;</span><span class="s0">,</span><span class="s1">&quot;theirHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;ourHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;defaultPrevented&quot;</span><span class="s0">,</span><span class="s1">&quot;getActiveMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;isHydrated&quot;</span><span class="s0">,</span><span class="s1">&quot;errorIdx&quot;</span><span class="s0">,</span><span class="s1">&quot;Links&quot;</span><span class="s0">,</span><span class="s1">&quot;criticalCss&quot;</span><span class="s0">,</span><span class="s1">&quot;routerMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;keyedLinks&quot;</span><span class="s0">,</span><span class="s1">&quot;PrefetchPageLinks&quot;</span><span class="s0">,</span><span class="s1">&quot;dataLinkProps&quot;</span><span class="s0">,</span><span class="s1">&quot;PrefetchPageLinksImpl&quot;</span><span class="s0">,</span><span class="s1">&quot;useKeyedPrefetchLinks&quot;</span><span class="s0">,</span><span class="s1">&quot;keyedPrefetchLinks&quot;</span><span class="s0">,</span><span class="s1">&quot;setKeyedPrefetchLinks&quot;</span><span class="s0">,</span><span class="s1">&quot;interrupted&quot;</span><span class="s0">,</span><span class="s1">&quot;linkProps&quot;</span><span class="s0">,</span><span class="s1">&quot;newMatchesForData&quot;</span><span class="s0">,</span><span class="s1">&quot;newMatchesForAssets&quot;</span><span class="s0">,</span><span class="s1">&quot;dataHrefs&quot;</span><span class="s0">,</span><span class="s1">&quot;m2&quot;</span><span class="s0">,</span><span class="s1">&quot;moduleHrefs&quot;</span><span class="s0">,</span><span class="s1">&quot;Meta&quot;</span><span class="s0">,</span><span class="s1">&quot;_matches&quot;</span><span class="s0">,</span><span class="s1">&quot;leafMeta&quot;</span><span class="s0">,</span><span class="s1">&quot;_match&quot;</span><span class="s0">,</span><span class="s1">&quot;routeMeta&quot;</span><span class="s0">,</span><span class="s1">&quot;metaProps&quot;</span><span class="s0">,</span><span class="s1">&quot;isValidMetaTag&quot;</span><span class="s0">,</span><span class="s1">&quot;Comp&quot;</span><span class="s0">,</span><span class="s1">&quot;charset&quot;</span><span class="s0">,</span><span class="s1">&quot;err&quot;</span><span class="s0">,</span><span class="s1">&quot;serverHandoffString&quot;</span><span class="s0">,</span><span class="s1">&quot;enableFogOfWar&quot;</span><span class="s0">,</span><span class="s1">&quot;initialScripts&quot;</span><span class="s0">,</span><span class="s1">&quot;streamScript&quot;</span><span class="s0">,</span><span class="s1">&quot;contextScript&quot;</span><span class="s0">,</span><span class="s1">&quot;routeModulesScript&quot;</span><span class="s0">,</span><span class="s1">&quot;hmr&quot;</span><span class="s0">,</span><span class="s1">&quot;runtime&quot;</span><span class="s0">,</span><span class="s1">&quot;routeIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;routeVarName&quot;</span><span class="s0">,</span><span class="s1">&quot;manifestEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;chunks&quot;</span><span class="s0">,</span><span class="s1">&quot;varName&quot;</span><span class="s0">,</span><span class="s1">&quot;chunkImportsSnippet&quot;</span><span class="s0">,</span><span class="s1">&quot;mergedChunksSnippet&quot;</span><span class="s0">,</span><span class="s1">&quot;suppressHydrationWarning&quot;</span><span class="s0">,</span><span class="s1">&quot;async&quot;</span><span class="s0">,</span><span class="s1">&quot;dedupe&quot;</span><span class="s0">,</span><span class="s1">&quot;integrity&quot;</span><span class="s0">,</span><span class="s1">&quot;crossOrigin&quot;</span><span class="s0">,</span><span class="s1">&quot;mergeRefs&quot;</span><span class="s0">,</span><span class="s1">&quot;refs&quot;</span><span class="s0">,</span><span class="s1">&quot;isBrowser&quot;</span><span class="s0">,</span><span class="s1">&quot;__reactRouterVersion&quot;</span><span class="s0">,</span><span class="s1">&quot;createBrowserRouter&quot;</span><span class="s0">,</span><span class="s1">&quot;parseHydrationData&quot;</span><span class="s0">,</span><span class="s1">&quot;createHashRouter&quot;</span><span class="s0">,</span><span class="s1">&quot;__staticRouterHydrationData&quot;</span><span class="s0">,</span><span class="s1">&quot;deserializeErrors&quot;</span><span class="s0">,</span><span class="s1">&quot;serialized&quot;</span><span class="s0">,</span><span class="s1">&quot;__type&quot;</span><span class="s0">,</span><span class="s1">&quot;__subType&quot;</span><span class="s0">,</span><span class="s1">&quot;ErrorConstructor&quot;</span><span class="s0">,</span><span class="s1">&quot;BrowserRouter&quot;</span><span class="s0">,</span><span class="s1">&quot;HashRouter&quot;</span><span class="s0">,</span><span class="s1">&quot;HistoryRouter&quot;</span><span class="s0">,</span><span class="s1">&quot;ABSOLUTE_URL_REGEX2&quot;</span><span class="s0">,</span><span class="s1">&quot;Link&quot;</span><span class="s0">,</span><span class="s1">&quot;forwardRef&quot;</span><span class="s0">,</span><span class="s1">&quot;LinkWithRef&quot;</span><span class="s0">,</span><span class="s1">&quot;onClick&quot;</span><span class="s0">,</span><span class="s1">&quot;discover&quot;</span><span class="s0">,</span><span class="s1">&quot;reloadDocument&quot;</span><span class="s0">,</span><span class="s1">&quot;forwardedRef&quot;</span><span class="s0">,</span><span class="s1">&quot;absoluteHref&quot;</span><span class="s0">,</span><span class="s1">&quot;isExternal&quot;</span><span class="s0">,</span><span class="s1">&quot;targetUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchRef&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchHandlers&quot;</span><span class="s0">,</span><span class="s1">&quot;internalOnClick&quot;</span><span class="s0">,</span><span class="s1">&quot;useLinkClickHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;handleClick&quot;</span><span class="s0">,</span><span class="s1">&quot;NavLink&quot;</span><span class="s0">,</span><span class="s1">&quot;NavLinkWithRef&quot;</span><span class="s0">,</span><span class="s1">&quot;ariaCurrentProp&quot;</span><span class="s0">,</span><span class="s1">&quot;className&quot;</span><span class="s0">,</span><span class="s1">&quot;classNameProp&quot;</span><span class="s0">,</span><span class="s1">&quot;styleProp&quot;</span><span class="s0">,</span><span class="s1">&quot;routerState&quot;</span><span class="s0">,</span><span class="s1">&quot;useViewTransitionState&quot;</span><span class="s0">,</span><span class="s1">&quot;nextLocationPathname&quot;</span><span class="s0">,</span><span class="s1">&quot;endSlashPosition&quot;</span><span class="s0">,</span><span class="s1">&quot;isActive&quot;</span><span class="s0">,</span><span class="s1">&quot;isPending&quot;</span><span class="s0">,</span><span class="s1">&quot;renderProps&quot;</span><span class="s0">,</span><span class="s1">&quot;ariaCurrent&quot;</span><span class="s0">,</span><span class="s1">&quot;Form&quot;</span><span class="s0">,</span><span class="s1">&quot;onSubmit&quot;</span><span class="s0">,</span><span class="s1">&quot;useSubmit&quot;</span><span class="s0">,</span><span class="s1">&quot;useFormAction&quot;</span><span class="s0">,</span><span class="s1">&quot;submitHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;preventDefault&quot;</span><span class="s0">,</span><span class="s1">&quot;submitter&quot;</span><span class="s0">,</span><span class="s1">&quot;nativeEvent&quot;</span><span class="s0">,</span><span class="s1">&quot;submitMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;currentTarget&quot;</span><span class="s0">,</span><span class="s1">&quot;ScrollRestoration&quot;</span><span class="s0">,</span><span class="s1">&quot;storageKey&quot;</span><span class="s0">,</span><span class="s1">&quot;remixContext&quot;</span><span class="s0">,</span><span class="s1">&quot;useScrollRestoration&quot;</span><span class="s0">,</span><span class="s1">&quot;ssrKey&quot;</span><span class="s0">,</span><span class="s1">&quot;userKey&quot;</span><span class="s0">,</span><span class="s1">&quot;getScrollRestorationKey&quot;</span><span class="s0">,</span><span class="s1">&quot;restoreScroll&quot;</span><span class="s0">,</span><span class="s1">&quot;storageKey2&quot;</span><span class="s0">,</span><span class="s1">&quot;restoreKey&quot;</span><span class="s0">,</span><span class="s1">&quot;storedY&quot;</span><span class="s0">,</span><span class="s1">&quot;scrollTo&quot;</span><span class="s0">,</span><span class="s1">&quot;SCROLL_RESTORATION_STORAGE_KEY&quot;</span><span class="s0">,</span><span class="s1">&quot;getDataRouterConsoleError2&quot;</span><span class="s0">,</span><span class="s1">&quot;useDataRouterContext3&quot;</span><span class="s0">,</span><span class="s1">&quot;useDataRouterState2&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceProp&quot;</span><span class="s0">,</span><span class="s1">&quot;useSearchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;defaultInit&quot;</span><span class="s0">,</span><span class="s1">&quot;defaultSearchParamsRef&quot;</span><span class="s0">,</span><span class="s1">&quot;hasSetSearchParamsRef&quot;</span><span class="s0">,</span><span class="s1">&quot;setSearchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;nextInit&quot;</span><span class="s0">,</span><span class="s1">&quot;navigateOptions&quot;</span><span class="s0">,</span><span class="s1">&quot;newSearchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;fetcherId&quot;</span><span class="s0">,</span><span class="s1">&quot;getUniqueFetcherId&quot;</span><span class="s0">,</span><span class="s1">&quot;currentRouteId&quot;</span><span class="s0">,</span><span class="s1">&quot;hasNakedIndexParam&quot;</span><span class="s0">,</span><span class="s1">&quot;useFetcher&quot;</span><span class="s0">,</span><span class="s1">&quot;defaultKey&quot;</span><span class="s0">,</span><span class="s1">&quot;useId&quot;</span><span class="s0">,</span><span class="s1">&quot;setFetcherKey&quot;</span><span class="s0">,</span><span class="s1">&quot;load&quot;</span><span class="s0">,</span><span class="s1">&quot;submitImpl&quot;</span><span class="s0">,</span><span class="s1">&quot;FetcherForm&quot;</span><span class="s0">,</span><span class="s1">&quot;FetcherForm2&quot;</span><span class="s0">,</span><span class="s1">&quot;fetcherWithComponents&quot;</span><span class="s0">,</span><span class="s1">&quot;useFetchers&quot;</span><span class="s0">,</span><span class="s1">&quot;savedScrollPositions&quot;</span><span class="s0">,</span><span class="s1">&quot;scrollRestoration&quot;</span><span class="s0">,</span><span class="s1">&quot;usePageHide&quot;</span><span class="s0">,</span><span class="s1">&quot;scrollY&quot;</span><span class="s0">,</span><span class="s1">&quot;disableScrollRestoration&quot;</span><span class="s0">,</span><span class="s1">&quot;getElementById&quot;</span><span class="s0">,</span><span class="s1">&quot;scrollIntoView&quot;</span><span class="s0">,</span><span class="s1">&quot;useBeforeUnload&quot;</span><span class="s0">,</span><span class="s1">&quot;capture&quot;</span><span class="s0">,</span><span class="s1">&quot;usePrompt&quot;</span><span class="s0">,</span><span class="s1">&quot;when&quot;</span><span class="s0">,</span><span class="s1">&quot;confirm&quot;</span><span class="s0">,</span><span class="s1">&quot;nextPath&quot;</span><span class="s0">,</span><span class="s1">&quot;React11&quot;</span><span class="s0">,</span><span class="s1">&quot;StaticRouter&quot;</span><span class="s0">,</span><span class="s1">&quot;staticNavigator&quot;</span><span class="s0">,</span><span class="s1">&quot;getStatelessNavigator&quot;</span><span class="s0">,</span><span class="s1">&quot;StaticRouterProvider&quot;</span><span class="s0">,</span><span class="s1">&quot;hydrate2&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchersContext&quot;</span><span class="s0">,</span><span class="s1">&quot;hydrateScript&quot;</span><span class="s0">,</span><span class="s1">&quot;serializeErrors&quot;</span><span class="s0">,</span><span class="s1">&quot;htmlEscape&quot;</span><span class="s0">,</span><span class="s1">&quot;DataRoutes2&quot;</span><span class="s0">,</span><span class="s1">&quot;back&quot;</span><span class="s0">,</span><span class="s1">&quot;forward&quot;</span><span class="s0">,</span><span class="s1">&quot;createStaticHandler2&quot;</span><span class="s0">,</span><span class="s1">&quot;createStaticRouter&quot;</span><span class="s0">,</span><span class="s1">&quot;encoded&quot;</span><span class="s0">,</span><span class="s1">&quot;ABSOLUTE_URL_REGEX3&quot;</span><span class="s0">,</span><span class="s1">&quot;ESCAPE_LOOKUP2&quot;</span><span class="s0">,</span><span class="s1">&quot;ESCAPE_REGEX2&quot;</span><span class="s0">,</span><span class="s1">&quot;React12&quot;</span><span class="s0">,</span><span class="s1">&quot;ServerRouter&quot;</span><span class="s0">,</span><span class="s1">&quot;staticHandlerContext&quot;</span><span class="s0">,</span><span class="s1">&quot;serializeError&quot;</span><span class="s0">,</span><span class="s1">&quot;serverHandoffStream&quot;</span><span class="s0">,</span><span class="s1">&quot;React13&quot;</span><span class="s0">,</span><span class="s1">&quot;createRoutesStub&quot;</span><span class="s0">,</span><span class="s1">&quot;RoutesTestStub&quot;</span><span class="s0">,</span><span class="s1">&quot;routerRef&quot;</span><span class="s0">,</span><span class="s1">&quot;remixContextRef&quot;</span><span class="s0">,</span><span class="s1">&quot;unstable_subResourceIntegrity&quot;</span><span class="s0">,</span><span class="s1">&quot;patched&quot;</span><span class="s0">,</span><span class="s1">&quot;processRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;withComponentProps&quot;</span><span class="s0">,</span><span class="s1">&quot;Wrapped&quot;</span><span class="s0">,</span><span class="s1">&quot;withHydrateFallbackProps&quot;</span><span class="s0">,</span><span class="s1">&quot;withErrorBoundaryProps&quot;</span><span class="s0">,</span><span class="s1">&quot;entryRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;serialize&quot;</span><span class="s0">,</span><span class="s1">&quot;encoder&quot;</span><span class="s0">,</span><span class="s1">&quot;sign&quot;</span><span class="s0">,</span><span class="s1">&quot;secret&quot;</span><span class="s0">,</span><span class="s1">&quot;createKey2&quot;</span><span class="s0">,</span><span class="s1">&quot;signature&quot;</span><span class="s0">,</span><span class="s1">&quot;crypto&quot;</span><span class="s0">,</span><span class="s1">&quot;subtle&quot;</span><span class="s0">,</span><span class="s1">&quot;btoa&quot;</span><span class="s0">,</span><span class="s1">&quot;fromCharCode&quot;</span><span class="s0">,</span><span class="s1">&quot;Uint8Array&quot;</span><span class="s0">,</span><span class="s1">&quot;unsign&quot;</span><span class="s0">,</span><span class="s1">&quot;cookie&quot;</span><span class="s0">,</span><span class="s1">&quot;lastIndexOf&quot;</span><span class="s0">,</span><span class="s1">&quot;byteStringToUint8Array&quot;</span><span class="s0">,</span><span class="s1">&quot;atob&quot;</span><span class="s0">,</span><span class="s1">&quot;valid&quot;</span><span class="s0">,</span><span class="s1">&quot;verify&quot;</span><span class="s0">,</span><span class="s1">&quot;usages&quot;</span><span class="s0">,</span><span class="s1">&quot;importKey&quot;</span><span class="s0">,</span><span class="s1">&quot;byteString&quot;</span><span class="s0">,</span><span class="s1">&quot;charCodeAt&quot;</span><span class="s0">,</span><span class="s1">&quot;createCookie&quot;</span><span class="s0">,</span><span class="s1">&quot;cookieOptions&quot;</span><span class="s0">,</span><span class="s1">&quot;secrets&quot;</span><span class="s0">,</span><span class="s1">&quot;sameSite&quot;</span><span class="s0">,</span><span class="s1">&quot;warnOnceAboutExpiresCookie&quot;</span><span class="s0">,</span><span class="s1">&quot;expires&quot;</span><span class="s0">,</span><span class="s1">&quot;isSigned&quot;</span><span class="s0">,</span><span class="s1">&quot;maxAge&quot;</span><span class="s0">,</span><span class="s1">&quot;now&quot;</span><span class="s0">,</span><span class="s1">&quot;cookieHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;parseOptions&quot;</span><span class="s0">,</span><span class="s1">&quot;cookies&quot;</span><span class="s0">,</span><span class="s1">&quot;decodeCookieValue&quot;</span><span class="s0">,</span><span class="s1">&quot;serializeOptions&quot;</span><span class="s0">,</span><span class="s1">&quot;encodeCookieValue&quot;</span><span class="s0">,</span><span class="s1">&quot;isCookie&quot;</span><span class="s0">,</span><span class="s1">&quot;encodeData&quot;</span><span class="s0">,</span><span class="s1">&quot;unsignedValue&quot;</span><span class="s0">,</span><span class="s1">&quot;decodeData&quot;</span><span class="s0">,</span><span class="s1">&quot;myUnescape&quot;</span><span class="s0">,</span><span class="s1">&quot;encodeURIComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;myEscape&quot;</span><span class="s0">,</span><span class="s1">&quot;chr&quot;</span><span class="s0">,</span><span class="s1">&quot;code&quot;</span><span class="s0">,</span><span class="s1">&quot;exec&quot;</span><span class="s0">,</span><span class="s1">&quot;hex&quot;</span><span class="s0">,</span><span class="s1">&quot;parseInt&quot;</span><span class="s0">,</span><span class="s1">&quot;createEntryRouteModules&quot;</span><span class="s0">,</span><span class="s1">&quot;ServerMode&quot;</span><span class="s0">,</span><span class="s1">&quot;ServerMode2&quot;</span><span class="s0">,</span><span class="s1">&quot;isServerMode&quot;</span><span class="s0">,</span><span class="s1">&quot;sanitizeError&quot;</span><span class="s0">,</span><span class="s1">&quot;serverMode&quot;</span><span class="s0">,</span><span class="s1">&quot;sanitized&quot;</span><span class="s0">,</span><span class="s1">&quot;sanitizeErrors&quot;</span><span class="s0">,</span><span class="s1">&quot;serializeErrors2&quot;</span><span class="s0">,</span><span class="s1">&quot;matchServerRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;callRouteHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;stripRoutesParam&quot;</span><span class="s0">,</span><span class="s1">&quot;stripIndexParam2&quot;</span><span class="s0">,</span><span class="s1">&quot;duplex&quot;</span><span class="s0">,</span><span class="s1">&quot;invariant3&quot;</span><span class="s0">,</span><span class="s1">&quot;globalDevServerHooksKey&quot;</span><span class="s0">,</span><span class="s1">&quot;setDevServerHooks&quot;</span><span class="s0">,</span><span class="s1">&quot;devServerHooks&quot;</span><span class="s0">,</span><span class="s1">&quot;getDevServerHooks&quot;</span><span class="s0">,</span><span class="s1">&quot;getBuildTimeHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;headerName&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;IS_RR_BUILD_REQUEST&quot;</span><span class="s0">,</span><span class="s1">&quot;groupRoutesByParentId2&quot;</span><span class="s0">,</span><span class="s1">&quot;createRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;createStaticHandlerDataRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;commonRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;preRenderedData&quot;</span><span class="s0">,</span><span class="s1">&quot;decodeURI&quot;</span><span class="s0">,</span><span class="s1">&quot;uint8array&quot;</span><span class="s0">,</span><span class="s1">&quot;global&quot;</span><span class="s0">,</span><span class="s1">&quot;ESCAPE_LOOKUP3&quot;</span><span class="s0">,</span><span class="s1">&quot;ESCAPE_REGEX3&quot;</span><span class="s0">,</span><span class="s1">&quot;escapeHtml2&quot;</span><span class="s0">,</span><span class="s1">&quot;createServerHandoffString&quot;</span><span class="s0">,</span><span class="s1">&quot;serverHandoff&quot;</span><span class="s0">,</span><span class="s1">&quot;splitCookiesString&quot;</span><span class="s0">,</span><span class="s1">&quot;getDocumentHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;build&quot;</span><span class="s0">,</span><span class="s1">&quot;boundaryIdx&quot;</span><span class="s0">,</span><span class="s1">&quot;errorHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;parentHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;includeErrorHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;includeErrorCookies&quot;</span><span class="s0">,</span><span class="s1">&quot;headers2&quot;</span><span class="s0">,</span><span class="s1">&quot;prependCookies&quot;</span><span class="s0">,</span><span class="s1">&quot;childHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;parentSetCookieString&quot;</span><span class="s0">,</span><span class="s1">&quot;childCookies&quot;</span><span class="s0">,</span><span class="s1">&quot;getSetCookie&quot;</span><span class="s0">,</span><span class="s1">&quot;SERVER_NO_BODY_STATUS_CODES&quot;</span><span class="s0">,</span><span class="s1">&quot;singleFetchAction&quot;</span><span class="s0">,</span><span class="s1">&quot;staticHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;handlerUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;loadContext&quot;</span><span class="s0">,</span><span class="s1">&quot;handleError&quot;</span><span class="s0">,</span><span class="s1">&quot;respond2&quot;</span><span class="s0">,</span><span class="s1">&quot;generateSingleFetchResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;getSingleFetchRedirect&quot;</span><span class="s0">,</span><span class="s1">&quot;singleFetchResult&quot;</span><span class="s0">,</span><span class="s1">&quot;handlerRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;singleFetchLoaders&quot;</span><span class="s0">,</span><span class="s1">&quot;loadedMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;loadRouteIds&quot;</span><span class="s0">,</span><span class="s1">&quot;routesParam&quot;</span><span class="s0">,</span><span class="s1">&quot;resultHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;encodeViaTurboStream&quot;</span><span class="s0">,</span><span class="s1">&quot;streamTimeout&quot;</span><span class="s0">,</span><span class="s1">&quot;requestSignal&quot;</span><span class="s0">,</span><span class="s1">&quot;data3&quot;</span><span class="s0">,</span><span class="s1">&quot;fromEntries&quot;</span><span class="s0">,</span><span class="s1">&quot;derive&quot;</span><span class="s0">,</span><span class="s1">&quot;createRequestHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;_build&quot;</span><span class="s0">,</span><span class="s1">&quot;requestHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;initialContext&quot;</span><span class="s0">,</span><span class="s1">&quot;derived&quot;</span><span class="s0">,</span><span class="s1">&quot;processRequestError&quot;</span><span class="s0">,</span><span class="s1">&quot;returnLastResortErrorResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizedBasename&quot;</span><span class="s0">,</span><span class="s1">&quot;prerender&quot;</span><span class="s0">,</span><span class="s1">&quot;manifestUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;handleManifestRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;singleFetchMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;handleSingleFetchRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;handleDataRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;handleResourceRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;unstable_getCriticalCss&quot;</span><span class="s0">,</span><span class="s1">&quot;getCriticalCss&quot;</span><span class="s0">,</span><span class="s1">&quot;handleDocumentRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;assets&quot;</span><span class="s0">,</span><span class="s1">&quot;partialPath&quot;</span><span class="s0">,</span><span class="s1">&quot;renderHtml&quot;</span><span class="s0">,</span><span class="s1">&quot;isSpaMode2&quot;</span><span class="s0">,</span><span class="s1">&quot;baseServerHandoff&quot;</span><span class="s0">,</span><span class="s1">&quot;entryContext&quot;</span><span class="s0">,</span><span class="s1">&quot;handleDocumentRequestFunction&quot;</span><span class="s0">,</span><span class="s1">&quot;errorForSecondRender&quot;</span><span class="s0">,</span><span class="s1">&quot;unwrapResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;errorResponseToJson&quot;</span><span class="s0">,</span><span class="s1">&quot;newError&quot;</span><span class="s0">,</span><span class="s1">&quot;errorResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;flash&quot;</span><span class="s0">,</span><span class="s1">&quot;createSession&quot;</span><span class="s0">,</span><span class="s1">&quot;flashName&quot;</span><span class="s0">,</span><span class="s1">&quot;unset&quot;</span><span class="s0">,</span><span class="s1">&quot;isSession&quot;</span><span class="s0">,</span><span class="s1">&quot;createSessionStorage&quot;</span><span class="s0">,</span><span class="s1">&quot;cookieArg&quot;</span><span class="s0">,</span><span class="s1">&quot;createData&quot;</span><span class="s0">,</span><span class="s1">&quot;readData&quot;</span><span class="s0">,</span><span class="s1">&quot;updateData&quot;</span><span class="s0">,</span><span class="s1">&quot;deleteData&quot;</span><span class="s0">,</span><span class="s1">&quot;warnOnceAboutSigningSessionCookie&quot;</span><span class="s0">,</span><span class="s1">&quot;getSession&quot;</span><span class="s0">,</span><span class="s1">&quot;commitSession&quot;</span><span class="s0">,</span><span class="s1">&quot;session&quot;</span><span class="s0">,</span><span class="s1">&quot;destroySession&quot;</span><span class="s0">,</span><span class="s1">&quot;createCookieSessionStorage&quot;</span><span class="s0">,</span><span class="s1">&quot;serializedCookie&quot;</span><span class="s0">,</span><span class="s1">&quot;_session&quot;</span><span class="s0">,</span><span class="s1">&quot;createMemorySessionStorage&quot;</span><span class="s0">,</span><span class="s1">&quot;isRequired&quot;</span><span class="s0">,</span><span class="s1">&quot;deserializeErrors2&quot;</span><span class="s0">,</span><span class="s1">&quot;getHydrationData&quot;</span><span class="s0">,</span><span class="s1">&quot;routeInfo&quot;</span><span class="s0">,</span><span class="s1">&quot;hasHydrateFallback&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;C:/School/LEIM/10Sem/Proj_Final/soundsprout_front_end/node_modules/react-router/dist/development/chunk-D4RADZKF.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;/**</span><span class="s2">\n </span><span class="s1">* react-router v7.6.0</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* Copyright (c) Remix Software Inc.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* This source code is licensed under the MIT license found in the</span><span class="s2">\n </span><span class="s1">* LICENSE.md file in the root directory of this source tree.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @license MIT</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">var __typeError = (msg) =&gt; {</span><span class="s2">\n  </span><span class="s1">throw TypeError(msg);</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">var __accessCheck = (obj, member, msg) =&gt; member.has(obj) || __typeError(</span><span class="s2">\&quot;</span><span class="s1">Cannot </span><span class="s2">\&quot; </span><span class="s1">+ msg);</span><span class="s2">\n</span><span class="s1">var __privateGet = (obj, member, getter) =&gt; (__accessCheck(obj, member, </span><span class="s2">\&quot;</span><span class="s1">read from private field</span><span class="s2">\&quot;</span><span class="s1">), getter ? getter.call(obj) : member.get(obj));</span><span class="s2">\n</span><span class="s1">var __privateAdd = (obj, member, value) =&gt; member.has(obj) ? __typeError(</span><span class="s2">\&quot;</span><span class="s1">Cannot add the same private member more than once</span><span class="s2">\&quot;</span><span class="s1">) : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);</span><span class="s2">\n\n</span><span class="s1">// lib/router/history.ts</span><span class="s2">\n</span><span class="s1">var Action = /* @__PURE__ */ ((Action2) =&gt; {</span><span class="s2">\n  </span><span class="s1">Action2[</span><span class="s2">\&quot;</span><span class="s1">Pop</span><span class="s2">\&quot;</span><span class="s1">] = </span><span class="s2">\&quot;</span><span class="s1">POP</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">Action2[</span><span class="s2">\&quot;</span><span class="s1">Push</span><span class="s2">\&quot;</span><span class="s1">] = </span><span class="s2">\&quot;</span><span class="s1">PUSH</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">Action2[</span><span class="s2">\&quot;</span><span class="s1">Replace</span><span class="s2">\&quot;</span><span class="s1">] = </span><span class="s2">\&quot;</span><span class="s1">REPLACE</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">return Action2;</span><span class="s2">\n</span><span class="s1">})(Action || {});</span><span class="s2">\n</span><span class="s1">var PopStateEventType = </span><span class="s2">\&quot;</span><span class="s1">popstate</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">function createMemoryHistory(options = {}) {</span><span class="s2">\n  </span><span class="s1">let { initialEntries = [</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">], initialIndex, v5Compat = false } = options;</span><span class="s2">\n  </span><span class="s1">let entries;</span><span class="s2">\n  </span><span class="s1">entries = initialEntries.map(</span><span class="s2">\n    </span><span class="s1">(entry, index2) =&gt; createMemoryLocation(</span><span class="s2">\n      </span><span class="s1">entry,</span><span class="s2">\n      </span><span class="s1">typeof entry === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">? null : entry.state,</span><span class="s2">\n      </span><span class="s1">index2 === 0 ? </span><span class="s2">\&quot;</span><span class="s1">default</span><span class="s2">\&quot; </span><span class="s1">: void 0</span><span class="s2">\n    </span><span class="s1">)</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let index = clampIndex(</span><span class="s2">\n    </span><span class="s1">initialIndex == null ? entries.length - 1 : initialIndex</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let action = </span><span class="s2">\&quot;</span><span class="s1">POP</span><span class="s2">\&quot; </span><span class="s1">/* Pop */;</span><span class="s2">\n  </span><span class="s1">let listener = null;</span><span class="s2">\n  </span><span class="s1">function clampIndex(n) {</span><span class="s2">\n    </span><span class="s1">return Math.min(Math.max(n, 0), entries.length - 1);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function getCurrentLocation() {</span><span class="s2">\n    </span><span class="s1">return entries[index];</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function createMemoryLocation(to, state = null, key) {</span><span class="s2">\n    </span><span class="s1">let location = createLocation(</span><span class="s2">\n      </span><span class="s1">entries ? getCurrentLocation().pathname : </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">to,</span><span class="s2">\n      </span><span class="s1">state,</span><span class="s2">\n      </span><span class="s1">key</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">warning(</span><span class="s2">\n      </span><span class="s1">location.pathname.charAt(0) === </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">`relative pathnames are not supported in memory history: ${JSON.stringify(</span><span class="s2">\n        </span><span class="s1">to</span><span class="s2">\n      </span><span class="s1">)}`</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">return location;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function createHref2(to) {</span><span class="s2">\n    </span><span class="s1">return typeof to === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">? to : createPath(to);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let history = {</span><span class="s2">\n    </span><span class="s1">get index() {</span><span class="s2">\n      </span><span class="s1">return index;</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">get action() {</span><span class="s2">\n      </span><span class="s1">return action;</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">get location() {</span><span class="s2">\n      </span><span class="s1">return getCurrentLocation();</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">createHref: createHref2,</span><span class="s2">\n    </span><span class="s1">createURL(to) {</span><span class="s2">\n      </span><span class="s1">return new URL(createHref2(to), </span><span class="s2">\&quot;</span><span class="s1">http://localhost</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">encodeLocation(to) {</span><span class="s2">\n      </span><span class="s1">let path = typeof to === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">? parsePath(to) : to;</span><span class="s2">\n      </span><span class="s1">return {</span><span class="s2">\n        </span><span class="s1">pathname: path.pathname || </span><span class="s2">\&quot;\&quot;</span><span class="s1">,</span><span class="s2">\n        </span><span class="s1">search: path.search || </span><span class="s2">\&quot;\&quot;</span><span class="s1">,</span><span class="s2">\n        </span><span class="s1">hash: path.hash || </span><span class="s2">\&quot;\&quot;\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">push(to, state) {</span><span class="s2">\n      </span><span class="s1">action = </span><span class="s2">\&quot;</span><span class="s1">PUSH</span><span class="s2">\&quot; </span><span class="s1">/* Push */;</span><span class="s2">\n      </span><span class="s1">let nextLocation = createMemoryLocation(to, state);</span><span class="s2">\n      </span><span class="s1">index += 1;</span><span class="s2">\n      </span><span class="s1">entries.splice(index, entries.length, nextLocation);</span><span class="s2">\n      </span><span class="s1">if (v5Compat &amp;&amp; listener) {</span><span class="s2">\n        </span><span class="s1">listener({ action, location: nextLocation, delta: 1 });</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">replace(to, state) {</span><span class="s2">\n      </span><span class="s1">action = </span><span class="s2">\&quot;</span><span class="s1">REPLACE</span><span class="s2">\&quot; </span><span class="s1">/* Replace */;</span><span class="s2">\n      </span><span class="s1">let nextLocation = createMemoryLocation(to, state);</span><span class="s2">\n      </span><span class="s1">entries[index] = nextLocation;</span><span class="s2">\n      </span><span class="s1">if (v5Compat &amp;&amp; listener) {</span><span class="s2">\n        </span><span class="s1">listener({ action, location: nextLocation, delta: 0 });</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">go(delta) {</span><span class="s2">\n      </span><span class="s1">action = </span><span class="s2">\&quot;</span><span class="s1">POP</span><span class="s2">\&quot; </span><span class="s1">/* Pop */;</span><span class="s2">\n      </span><span class="s1">let nextIndex = clampIndex(index + delta);</span><span class="s2">\n      </span><span class="s1">let nextLocation = entries[nextIndex];</span><span class="s2">\n      </span><span class="s1">index = nextIndex;</span><span class="s2">\n      </span><span class="s1">if (listener) {</span><span class="s2">\n        </span><span class="s1">listener({ action, location: nextLocation, delta });</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">listen(fn) {</span><span class="s2">\n      </span><span class="s1">listener = fn;</span><span class="s2">\n      </span><span class="s1">return () =&gt; {</span><span class="s2">\n        </span><span class="s1">listener = null;</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">return history;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createBrowserHistory(options = {}) {</span><span class="s2">\n  </span><span class="s1">function createBrowserLocation(window2, globalHistory) {</span><span class="s2">\n    </span><span class="s1">let { pathname, search, hash } = window2.location;</span><span class="s2">\n    </span><span class="s1">return createLocation(</span><span class="s2">\n      \&quot;\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">{ pathname, search, hash },</span><span class="s2">\n      </span><span class="s1">// state defaults to `null` because `window.history.state` does</span><span class="s2">\n      </span><span class="s1">globalHistory.state &amp;&amp; globalHistory.state.usr || null,</span><span class="s2">\n      </span><span class="s1">globalHistory.state &amp;&amp; globalHistory.state.key || </span><span class="s2">\&quot;</span><span class="s1">default</span><span class="s2">\&quot;\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function createBrowserHref(window2, to) {</span><span class="s2">\n    </span><span class="s1">return typeof to === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">? to : createPath(to);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return getUrlBasedHistory(</span><span class="s2">\n    </span><span class="s1">createBrowserLocation,</span><span class="s2">\n    </span><span class="s1">createBrowserHref,</span><span class="s2">\n    </span><span class="s1">null,</span><span class="s2">\n    </span><span class="s1">options</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createHashHistory(options = {}) {</span><span class="s2">\n  </span><span class="s1">function createHashLocation(window2, globalHistory) {</span><span class="s2">\n    </span><span class="s1">let {</span><span class="s2">\n      </span><span class="s1">pathname = </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">search = </span><span class="s2">\&quot;\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">hash = </span><span class="s2">\&quot;\&quot;\n    </span><span class="s1">} = parsePath(window2.location.hash.substring(1));</span><span class="s2">\n    </span><span class="s1">if (!pathname.startsWith(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">) &amp;&amp; !pathname.startsWith(</span><span class="s2">\&quot;</span><span class="s1">.</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n      </span><span class="s1">pathname = </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot; </span><span class="s1">+ pathname;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return createLocation(</span><span class="s2">\n      \&quot;\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">{ pathname, search, hash },</span><span class="s2">\n      </span><span class="s1">// state defaults to `null` because `window.history.state` does</span><span class="s2">\n      </span><span class="s1">globalHistory.state &amp;&amp; globalHistory.state.usr || null,</span><span class="s2">\n      </span><span class="s1">globalHistory.state &amp;&amp; globalHistory.state.key || </span><span class="s2">\&quot;</span><span class="s1">default</span><span class="s2">\&quot;\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function createHashHref(window2, to) {</span><span class="s2">\n    </span><span class="s1">let base = window2.document.querySelector(</span><span class="s2">\&quot;</span><span class="s1">base</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">let href2 = </span><span class="s2">\&quot;\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">if (base &amp;&amp; base.getAttribute(</span><span class="s2">\&quot;</span><span class="s1">href</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n      </span><span class="s1">let url = window2.location.href;</span><span class="s2">\n      </span><span class="s1">let hashIndex = url.indexOf(</span><span class="s2">\&quot;</span><span class="s1">#</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">href2 = hashIndex === -1 ? url : url.slice(0, hashIndex);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return href2 + </span><span class="s2">\&quot;</span><span class="s1">#</span><span class="s2">\&quot; </span><span class="s1">+ (typeof to === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">? to : createPath(to));</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function validateHashLocation(location, to) {</span><span class="s2">\n    </span><span class="s1">warning(</span><span class="s2">\n      </span><span class="s1">location.pathname.charAt(0) === </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">`relative pathnames are not supported in hash history.push(${JSON.stringify(</span><span class="s2">\n        </span><span class="s1">to</span><span class="s2">\n      </span><span class="s1">)})`</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return getUrlBasedHistory(</span><span class="s2">\n    </span><span class="s1">createHashLocation,</span><span class="s2">\n    </span><span class="s1">createHashHref,</span><span class="s2">\n    </span><span class="s1">validateHashLocation,</span><span class="s2">\n    </span><span class="s1">options</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function invariant(value, message) {</span><span class="s2">\n  </span><span class="s1">if (value === false || value === null || typeof value === </span><span class="s2">\&quot;</span><span class="s1">undefined</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">throw new Error(message);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function warning(cond, message) {</span><span class="s2">\n  </span><span class="s1">if (!cond) {</span><span class="s2">\n    </span><span class="s1">if (typeof console !== </span><span class="s2">\&quot;</span><span class="s1">undefined</span><span class="s2">\&quot;</span><span class="s1">) console.warn(message);</span><span class="s2">\n    </span><span class="s1">try {</span><span class="s2">\n      </span><span class="s1">throw new Error(message);</span><span class="s2">\n    </span><span class="s1">} catch (e) {</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createKey() {</span><span class="s2">\n  </span><span class="s1">return Math.random().toString(36).substring(2, 10);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getHistoryState(location, index) {</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">usr: location.state,</span><span class="s2">\n    </span><span class="s1">key: location.key,</span><span class="s2">\n    </span><span class="s1">idx: index</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createLocation(current, to, state = null, key) {</span><span class="s2">\n  </span><span class="s1">let location = {</span><span class="s2">\n    </span><span class="s1">pathname: typeof current === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">? current : current.pathname,</span><span class="s2">\n    </span><span class="s1">search: </span><span class="s2">\&quot;\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">hash: </span><span class="s2">\&quot;\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">...typeof to === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">? parsePath(to) : to,</span><span class="s2">\n    </span><span class="s1">state,</span><span class="s2">\n    </span><span class="s1">// TODO: This could be cleaned up.  push/replace should probably just take</span><span class="s2">\n    </span><span class="s1">// full Locations now and avoid the need to run through this flow at all</span><span class="s2">\n    </span><span class="s1">// But that's a pretty big refactor to the current test suite so going to</span><span class="s2">\n    </span><span class="s1">// keep as is for the time being and just let any incoming keys take precedence</span><span class="s2">\n    </span><span class="s1">key: to &amp;&amp; to.key || key || createKey()</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">return location;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createPath({</span><span class="s2">\n  </span><span class="s1">pathname = </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">search = </span><span class="s2">\&quot;\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">hash = </span><span class="s2">\&quot;\&quot;\n</span><span class="s1">}) {</span><span class="s2">\n  </span><span class="s1">if (search &amp;&amp; search !== </span><span class="s2">\&quot;</span><span class="s1">?</span><span class="s2">\&quot;</span><span class="s1">)</span><span class="s2">\n    </span><span class="s1">pathname += search.charAt(0) === </span><span class="s2">\&quot;</span><span class="s1">?</span><span class="s2">\&quot; </span><span class="s1">? search : </span><span class="s2">\&quot;</span><span class="s1">?</span><span class="s2">\&quot; </span><span class="s1">+ search;</span><span class="s2">\n  </span><span class="s1">if (hash &amp;&amp; hash !== </span><span class="s2">\&quot;</span><span class="s1">#</span><span class="s2">\&quot;</span><span class="s1">)</span><span class="s2">\n    </span><span class="s1">pathname += hash.charAt(0) === </span><span class="s2">\&quot;</span><span class="s1">#</span><span class="s2">\&quot; </span><span class="s1">? hash : </span><span class="s2">\&quot;</span><span class="s1">#</span><span class="s2">\&quot; </span><span class="s1">+ hash;</span><span class="s2">\n  </span><span class="s1">return pathname;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function parsePath(path) {</span><span class="s2">\n  </span><span class="s1">let parsedPath = {};</span><span class="s2">\n  </span><span class="s1">if (path) {</span><span class="s2">\n    </span><span class="s1">let hashIndex = path.indexOf(</span><span class="s2">\&quot;</span><span class="s1">#</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">if (hashIndex &gt;= 0) {</span><span class="s2">\n      </span><span class="s1">parsedPath.hash = path.substring(hashIndex);</span><span class="s2">\n      </span><span class="s1">path = path.substring(0, hashIndex);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let searchIndex = path.indexOf(</span><span class="s2">\&quot;</span><span class="s1">?</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">if (searchIndex &gt;= 0) {</span><span class="s2">\n      </span><span class="s1">parsedPath.search = path.substring(searchIndex);</span><span class="s2">\n      </span><span class="s1">path = path.substring(0, searchIndex);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (path) {</span><span class="s2">\n      </span><span class="s1">parsedPath.pathname = path;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return parsedPath;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getUrlBasedHistory(getLocation, createHref2, validateLocation, options = {}) {</span><span class="s2">\n  </span><span class="s1">let { window: window2 = document.defaultView, v5Compat = false } = options;</span><span class="s2">\n  </span><span class="s1">let globalHistory = window2.history;</span><span class="s2">\n  </span><span class="s1">let action = </span><span class="s2">\&quot;</span><span class="s1">POP</span><span class="s2">\&quot; </span><span class="s1">/* Pop */;</span><span class="s2">\n  </span><span class="s1">let listener = null;</span><span class="s2">\n  </span><span class="s1">let index = getIndex();</span><span class="s2">\n  </span><span class="s1">if (index == null) {</span><span class="s2">\n    </span><span class="s1">index = 0;</span><span class="s2">\n    </span><span class="s1">globalHistory.replaceState({ ...globalHistory.state, idx: index }, </span><span class="s2">\&quot;\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function getIndex() {</span><span class="s2">\n    </span><span class="s1">let state = globalHistory.state || { idx: null };</span><span class="s2">\n    </span><span class="s1">return state.idx;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function handlePop() {</span><span class="s2">\n    </span><span class="s1">action = </span><span class="s2">\&quot;</span><span class="s1">POP</span><span class="s2">\&quot; </span><span class="s1">/* Pop */;</span><span class="s2">\n    </span><span class="s1">let nextIndex = getIndex();</span><span class="s2">\n    </span><span class="s1">let delta = nextIndex == null ? null : nextIndex - index;</span><span class="s2">\n    </span><span class="s1">index = nextIndex;</span><span class="s2">\n    </span><span class="s1">if (listener) {</span><span class="s2">\n      </span><span class="s1">listener({ action, location: history.location, delta });</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function push(to, state) {</span><span class="s2">\n    </span><span class="s1">action = </span><span class="s2">\&quot;</span><span class="s1">PUSH</span><span class="s2">\&quot; </span><span class="s1">/* Push */;</span><span class="s2">\n    </span><span class="s1">let location = createLocation(history.location, to, state);</span><span class="s2">\n    </span><span class="s1">if (validateLocation) validateLocation(location, to);</span><span class="s2">\n    </span><span class="s1">index = getIndex() + 1;</span><span class="s2">\n    </span><span class="s1">let historyState = getHistoryState(location, index);</span><span class="s2">\n    </span><span class="s1">let url = history.createHref(location);</span><span class="s2">\n    </span><span class="s1">try {</span><span class="s2">\n      </span><span class="s1">globalHistory.pushState(historyState, </span><span class="s2">\&quot;\&quot;</span><span class="s1">, url);</span><span class="s2">\n    </span><span class="s1">} catch (error) {</span><span class="s2">\n      </span><span class="s1">if (error instanceof DOMException &amp;&amp; error.name === </span><span class="s2">\&quot;</span><span class="s1">DataCloneError</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">throw error;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">window2.location.assign(url);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (v5Compat &amp;&amp; listener) {</span><span class="s2">\n      </span><span class="s1">listener({ action, location: history.location, delta: 1 });</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function replace2(to, state) {</span><span class="s2">\n    </span><span class="s1">action = </span><span class="s2">\&quot;</span><span class="s1">REPLACE</span><span class="s2">\&quot; </span><span class="s1">/* Replace */;</span><span class="s2">\n    </span><span class="s1">let location = createLocation(history.location, to, state);</span><span class="s2">\n    </span><span class="s1">if (validateLocation) validateLocation(location, to);</span><span class="s2">\n    </span><span class="s1">index = getIndex();</span><span class="s2">\n    </span><span class="s1">let historyState = getHistoryState(location, index);</span><span class="s2">\n    </span><span class="s1">let url = history.createHref(location);</span><span class="s2">\n    </span><span class="s1">globalHistory.replaceState(historyState, </span><span class="s2">\&quot;\&quot;</span><span class="s1">, url);</span><span class="s2">\n    </span><span class="s1">if (v5Compat &amp;&amp; listener) {</span><span class="s2">\n      </span><span class="s1">listener({ action, location: history.location, delta: 0 });</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function createURL(to) {</span><span class="s2">\n    </span><span class="s1">return createBrowserURLImpl(to);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let history = {</span><span class="s2">\n    </span><span class="s1">get action() {</span><span class="s2">\n      </span><span class="s1">return action;</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">get location() {</span><span class="s2">\n      </span><span class="s1">return getLocation(window2, globalHistory);</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">listen(fn) {</span><span class="s2">\n      </span><span class="s1">if (listener) {</span><span class="s2">\n        </span><span class="s1">throw new Error(</span><span class="s2">\&quot;</span><span class="s1">A history only accepts one active listener</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">window2.addEventListener(PopStateEventType, handlePop);</span><span class="s2">\n      </span><span class="s1">listener = fn;</span><span class="s2">\n      </span><span class="s1">return () =&gt; {</span><span class="s2">\n        </span><span class="s1">window2.removeEventListener(PopStateEventType, handlePop);</span><span class="s2">\n        </span><span class="s1">listener = null;</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">createHref(to) {</span><span class="s2">\n      </span><span class="s1">return createHref2(window2, to);</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">createURL,</span><span class="s2">\n    </span><span class="s1">encodeLocation(to) {</span><span class="s2">\n      </span><span class="s1">let url = createURL(to);</span><span class="s2">\n      </span><span class="s1">return {</span><span class="s2">\n        </span><span class="s1">pathname: url.pathname,</span><span class="s2">\n        </span><span class="s1">search: url.search,</span><span class="s2">\n        </span><span class="s1">hash: url.hash</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">push,</span><span class="s2">\n    </span><span class="s1">replace: replace2,</span><span class="s2">\n    </span><span class="s1">go(n) {</span><span class="s2">\n      </span><span class="s1">return globalHistory.go(n);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">return history;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createBrowserURLImpl(to, isAbsolute = false) {</span><span class="s2">\n  </span><span class="s1">let base = </span><span class="s2">\&quot;</span><span class="s1">http://localhost</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">if (typeof window !== </span><span class="s2">\&quot;</span><span class="s1">undefined</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">base = window.location.origin !== </span><span class="s2">\&quot;</span><span class="s1">null</span><span class="s2">\&quot; </span><span class="s1">? window.location.origin : window.location.href;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">invariant(base, </span><span class="s2">\&quot;</span><span class="s1">No window.location.(origin|href) available to create URL</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let href2 = typeof to === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">? to : createPath(to);</span><span class="s2">\n  </span><span class="s1">href2 = href2.replace(/ $/, </span><span class="s2">\&quot;</span><span class="s1">%20</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">if (!isAbsolute &amp;&amp; href2.startsWith(</span><span class="s2">\&quot;</span><span class="s1">//</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n    </span><span class="s1">href2 = base + href2;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return new URL(href2, base);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/router/utils.ts</span><span class="s2">\n</span><span class="s1">function unstable_createContext(defaultValue) {</span><span class="s2">\n  </span><span class="s1">return { defaultValue };</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var _map;</span><span class="s2">\n</span><span class="s1">var unstable_RouterContextProvider = class {</span><span class="s2">\n  </span><span class="s1">constructor(init) {</span><span class="s2">\n    </span><span class="s1">__privateAdd(this, _map, /* @__PURE__ */ new Map());</span><span class="s2">\n    </span><span class="s1">if (init) {</span><span class="s2">\n      </span><span class="s1">for (let [context, value] of init) {</span><span class="s2">\n        </span><span class="s1">this.set(context, value);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">get(context) {</span><span class="s2">\n    </span><span class="s1">if (__privateGet(this, _map).has(context)) {</span><span class="s2">\n      </span><span class="s1">return __privateGet(this, _map).get(context);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (context.defaultValue !== void 0) {</span><span class="s2">\n      </span><span class="s1">return context.defaultValue;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">throw new Error(</span><span class="s2">\&quot;</span><span class="s1">No value found for context</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">set(context, value) {</span><span class="s2">\n    </span><span class="s1">__privateGet(this, _map).set(context, value);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">_map = new WeakMap();</span><span class="s2">\n</span><span class="s1">var unsupportedLazyRouteObjectKeys = /* @__PURE__ */ new Set([</span><span class="s2">\n  \&quot;</span><span class="s1">lazy</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">caseSensitive</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">path</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">id</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">index</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">children</span><span class="s2">\&quot;\n</span><span class="s1">]);</span><span class="s2">\n</span><span class="s1">function isUnsupportedLazyRouteObjectKey(key) {</span><span class="s2">\n  </span><span class="s1">return unsupportedLazyRouteObjectKeys.has(</span><span class="s2">\n    </span><span class="s1">key</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var unsupportedLazyRouteFunctionKeys = /* @__PURE__ */ new Set([</span><span class="s2">\n  \&quot;</span><span class="s1">lazy</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">caseSensitive</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">path</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">id</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">index</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">unstable_middleware</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">children</span><span class="s2">\&quot;\n</span><span class="s1">]);</span><span class="s2">\n</span><span class="s1">function isUnsupportedLazyRouteFunctionKey(key) {</span><span class="s2">\n  </span><span class="s1">return unsupportedLazyRouteFunctionKeys.has(</span><span class="s2">\n    </span><span class="s1">key</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isIndexRoute(route) {</span><span class="s2">\n  </span><span class="s1">return route.index === true;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function convertRoutesToDataRoutes(routes, mapRouteProperties2, parentPath = [], manifest = {}) {</span><span class="s2">\n  </span><span class="s1">return routes.map((route, index) =&gt; {</span><span class="s2">\n    </span><span class="s1">let treePath = [...parentPath, String(index)];</span><span class="s2">\n    </span><span class="s1">let id = typeof route.id === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">? route.id : treePath.join(</span><span class="s2">\&quot;</span><span class="s1">-</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">invariant(</span><span class="s2">\n      </span><span class="s1">route.index !== true || !route.children,</span><span class="s2">\n      </span><span class="s1">`Cannot specify children on an index route`</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">invariant(</span><span class="s2">\n      </span><span class="s1">!manifest[id],</span><span class="s2">\n      </span><span class="s1">`Found a route id collision on id </span><span class="s2">\&quot;</span><span class="s1">${id}</span><span class="s2">\&quot;</span><span class="s1">.  Route id's must be globally unique within Data Router usages`</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">if (isIndexRoute(route)) {</span><span class="s2">\n      </span><span class="s1">let indexRoute = {</span><span class="s2">\n        </span><span class="s1">...route,</span><span class="s2">\n        </span><span class="s1">...mapRouteProperties2(route),</span><span class="s2">\n        </span><span class="s1">id</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">manifest[id] = indexRoute;</span><span class="s2">\n      </span><span class="s1">return indexRoute;</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">let pathOrLayoutRoute = {</span><span class="s2">\n        </span><span class="s1">...route,</span><span class="s2">\n        </span><span class="s1">...mapRouteProperties2(route),</span><span class="s2">\n        </span><span class="s1">id,</span><span class="s2">\n        </span><span class="s1">children: void 0</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">manifest[id] = pathOrLayoutRoute;</span><span class="s2">\n      </span><span class="s1">if (route.children) {</span><span class="s2">\n        </span><span class="s1">pathOrLayoutRoute.children = convertRoutesToDataRoutes(</span><span class="s2">\n          </span><span class="s1">route.children,</span><span class="s2">\n          </span><span class="s1">mapRouteProperties2,</span><span class="s2">\n          </span><span class="s1">treePath,</span><span class="s2">\n          </span><span class="s1">manifest</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return pathOrLayoutRoute;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function matchRoutes(routes, locationArg, basename = </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n  </span><span class="s1">return matchRoutesImpl(routes, locationArg, basename, false);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function matchRoutesImpl(routes, locationArg, basename, allowPartial) {</span><span class="s2">\n  </span><span class="s1">let location = typeof locationArg === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">? parsePath(locationArg) : locationArg;</span><span class="s2">\n  </span><span class="s1">let pathname = stripBasename(location.pathname || </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">, basename);</span><span class="s2">\n  </span><span class="s1">if (pathname == null) {</span><span class="s2">\n    </span><span class="s1">return null;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let branches = flattenRoutes(routes);</span><span class="s2">\n  </span><span class="s1">rankRouteBranches(branches);</span><span class="s2">\n  </span><span class="s1">let matches = null;</span><span class="s2">\n  </span><span class="s1">for (let i = 0; matches == null &amp;&amp; i &lt; branches.length; ++i) {</span><span class="s2">\n    </span><span class="s1">let decoded = decodePath(pathname);</span><span class="s2">\n    </span><span class="s1">matches = matchRouteBranch(</span><span class="s2">\n      </span><span class="s1">branches[i],</span><span class="s2">\n      </span><span class="s1">decoded,</span><span class="s2">\n      </span><span class="s1">allowPartial</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return matches;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function convertRouteMatchToUiMatch(match, loaderData) {</span><span class="s2">\n  </span><span class="s1">let { route, pathname, params } = match;</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">id: route.id,</span><span class="s2">\n    </span><span class="s1">pathname,</span><span class="s2">\n    </span><span class="s1">params,</span><span class="s2">\n    </span><span class="s1">data: loaderData[route.id],</span><span class="s2">\n    </span><span class="s1">handle: route.handle</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function flattenRoutes(routes, branches = [], parentsMeta = [], parentPath = </span><span class="s2">\&quot;\&quot;</span><span class="s1">) {</span><span class="s2">\n  </span><span class="s1">let flattenRoute = (route, index, relativePath) =&gt; {</span><span class="s2">\n    </span><span class="s1">let meta = {</span><span class="s2">\n      </span><span class="s1">relativePath: relativePath === void 0 ? route.path || </span><span class="s2">\&quot;\&quot; </span><span class="s1">: relativePath,</span><span class="s2">\n      </span><span class="s1">caseSensitive: route.caseSensitive === true,</span><span class="s2">\n      </span><span class="s1">childrenIndex: index,</span><span class="s2">\n      </span><span class="s1">route</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">if (meta.relativePath.startsWith(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n      </span><span class="s1">invariant(</span><span class="s2">\n        </span><span class="s1">meta.relativePath.startsWith(parentPath),</span><span class="s2">\n        </span><span class="s1">`Absolute route path </span><span class="s2">\&quot;</span><span class="s1">${meta.relativePath}</span><span class="s2">\&quot; </span><span class="s1">nested under path </span><span class="s2">\&quot;</span><span class="s1">${parentPath}</span><span class="s2">\&quot; </span><span class="s1">is not valid. An absolute child route path must start with the combined path of all its parent routes.`</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">meta.relativePath = meta.relativePath.slice(parentPath.length);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let path = joinPaths([parentPath, meta.relativePath]);</span><span class="s2">\n    </span><span class="s1">let routesMeta = parentsMeta.concat(meta);</span><span class="s2">\n    </span><span class="s1">if (route.children &amp;&amp; route.children.length &gt; 0) {</span><span class="s2">\n      </span><span class="s1">invariant(</span><span class="s2">\n        </span><span class="s1">// Our types know better, but runtime JS may not!</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error</span><span class="s2">\n        </span><span class="s1">route.index !== true,</span><span class="s2">\n        </span><span class="s1">`Index routes must not have child routes. Please remove all child routes from route path </span><span class="s2">\&quot;</span><span class="s1">${path}</span><span class="s2">\&quot;</span><span class="s1">.`</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">flattenRoutes(route.children, branches, routesMeta, path);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (route.path == null &amp;&amp; !route.index) {</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">branches.push({</span><span class="s2">\n      </span><span class="s1">path,</span><span class="s2">\n      </span><span class="s1">score: computeScore(path, route.index),</span><span class="s2">\n      </span><span class="s1">routesMeta</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">routes.forEach((route, index) =&gt; {</span><span class="s2">\n    </span><span class="s1">if (route.path === </span><span class="s2">\&quot;\&quot; </span><span class="s1">|| !route.path?.includes(</span><span class="s2">\&quot;</span><span class="s1">?</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n      </span><span class="s1">flattenRoute(route, index);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">for (let exploded of explodeOptionalSegments(route.path)) {</span><span class="s2">\n        </span><span class="s1">flattenRoute(route, index, exploded);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">return branches;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function explodeOptionalSegments(path) {</span><span class="s2">\n  </span><span class="s1">let segments = path.split(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">if (segments.length === 0) return [];</span><span class="s2">\n  </span><span class="s1">let [first, ...rest] = segments;</span><span class="s2">\n  </span><span class="s1">let isOptional = first.endsWith(</span><span class="s2">\&quot;</span><span class="s1">?</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let required = first.replace(/</span><span class="s2">\\</span><span class="s1">?$/, </span><span class="s2">\&quot;\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">if (rest.length === 0) {</span><span class="s2">\n    </span><span class="s1">return isOptional ? [required, </span><span class="s2">\&quot;\&quot;</span><span class="s1">] : [required];</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let restExploded = explodeOptionalSegments(rest.join(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">));</span><span class="s2">\n  </span><span class="s1">let result = [];</span><span class="s2">\n  </span><span class="s1">result.push(</span><span class="s2">\n    </span><span class="s1">...restExploded.map(</span><span class="s2">\n      </span><span class="s1">(subpath) =&gt; subpath === </span><span class="s2">\&quot;\&quot; </span><span class="s1">? required : [required, subpath].join(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">)</span><span class="s2">\n    </span><span class="s1">)</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">if (isOptional) {</span><span class="s2">\n    </span><span class="s1">result.push(...restExploded);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return result.map(</span><span class="s2">\n    </span><span class="s1">(exploded) =&gt; path.startsWith(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">) &amp;&amp; exploded === </span><span class="s2">\&quot;\&quot; </span><span class="s1">? </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot; </span><span class="s1">: exploded</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function rankRouteBranches(branches) {</span><span class="s2">\n  </span><span class="s1">branches.sort(</span><span class="s2">\n    </span><span class="s1">(a, b) =&gt; a.score !== b.score ? b.score - a.score : compareIndexes(</span><span class="s2">\n      </span><span class="s1">a.routesMeta.map((meta) =&gt; meta.childrenIndex),</span><span class="s2">\n      </span><span class="s1">b.routesMeta.map((meta) =&gt; meta.childrenIndex)</span><span class="s2">\n    </span><span class="s1">)</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var paramRe = /^:[</span><span class="s2">\\</span><span class="s1">w-]+$/;</span><span class="s2">\n</span><span class="s1">var dynamicSegmentValue = 3;</span><span class="s2">\n</span><span class="s1">var indexRouteValue = 2;</span><span class="s2">\n</span><span class="s1">var emptySegmentValue = 1;</span><span class="s2">\n</span><span class="s1">var staticSegmentValue = 10;</span><span class="s2">\n</span><span class="s1">var splatPenalty = -2;</span><span class="s2">\n</span><span class="s1">var isSplat = (s) =&gt; s === </span><span class="s2">\&quot;</span><span class="s1">*</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">function computeScore(path, index) {</span><span class="s2">\n  </span><span class="s1">let segments = path.split(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let initialScore = segments.length;</span><span class="s2">\n  </span><span class="s1">if (segments.some(isSplat)) {</span><span class="s2">\n    </span><span class="s1">initialScore += splatPenalty;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (index) {</span><span class="s2">\n    </span><span class="s1">initialScore += indexRouteValue;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return segments.filter((s) =&gt; !isSplat(s)).reduce(</span><span class="s2">\n    </span><span class="s1">(score, segment) =&gt; score + (paramRe.test(segment) ? dynamicSegmentValue : segment === </span><span class="s2">\&quot;\&quot; </span><span class="s1">? emptySegmentValue : staticSegmentValue),</span><span class="s2">\n    </span><span class="s1">initialScore</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function compareIndexes(a, b) {</span><span class="s2">\n  </span><span class="s1">let siblings = a.length === b.length &amp;&amp; a.slice(0, -1).every((n, i) =&gt; n === b[i]);</span><span class="s2">\n  </span><span class="s1">return siblings ? (</span><span class="s2">\n    </span><span class="s1">// If two routes are siblings, we should try to match the earlier sibling</span><span class="s2">\n    </span><span class="s1">// first. This allows people to have fine-grained control over the matching</span><span class="s2">\n    </span><span class="s1">// behavior by simply putting routes with identical paths in the order they</span><span class="s2">\n    </span><span class="s1">// want them tried.</span><span class="s2">\n    </span><span class="s1">a[a.length - 1] - b[b.length - 1]</span><span class="s2">\n  </span><span class="s1">) : (</span><span class="s2">\n    </span><span class="s1">// Otherwise, it doesn't really make sense to rank non-siblings by index,</span><span class="s2">\n    </span><span class="s1">// so they sort equally.</span><span class="s2">\n    </span><span class="s1">0</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function matchRouteBranch(branch, pathname, allowPartial = false) {</span><span class="s2">\n  </span><span class="s1">let { routesMeta } = branch;</span><span class="s2">\n  </span><span class="s1">let matchedParams = {};</span><span class="s2">\n  </span><span class="s1">let matchedPathname = </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">let matches = [];</span><span class="s2">\n  </span><span class="s1">for (let i = 0; i &lt; routesMeta.length; ++i) {</span><span class="s2">\n    </span><span class="s1">let meta = routesMeta[i];</span><span class="s2">\n    </span><span class="s1">let end = i === routesMeta.length - 1;</span><span class="s2">\n    </span><span class="s1">let remainingPathname = matchedPathname === </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot; </span><span class="s1">? pathname : pathname.slice(matchedPathname.length) || </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">let match = matchPath(</span><span class="s2">\n      </span><span class="s1">{ path: meta.relativePath, caseSensitive: meta.caseSensitive, end },</span><span class="s2">\n      </span><span class="s1">remainingPathname</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">let route = meta.route;</span><span class="s2">\n    </span><span class="s1">if (!match &amp;&amp; end &amp;&amp; allowPartial &amp;&amp; !routesMeta[routesMeta.length - 1].route.index) {</span><span class="s2">\n      </span><span class="s1">match = matchPath(</span><span class="s2">\n        </span><span class="s1">{</span><span class="s2">\n          </span><span class="s1">path: meta.relativePath,</span><span class="s2">\n          </span><span class="s1">caseSensitive: meta.caseSensitive,</span><span class="s2">\n          </span><span class="s1">end: false</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">remainingPathname</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (!match) {</span><span class="s2">\n      </span><span class="s1">return null;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">Object.assign(matchedParams, match.params);</span><span class="s2">\n    </span><span class="s1">matches.push({</span><span class="s2">\n      </span><span class="s1">// TODO: Can this as be avoided?</span><span class="s2">\n      </span><span class="s1">params: matchedParams,</span><span class="s2">\n      </span><span class="s1">pathname: joinPaths([matchedPathname, match.pathname]),</span><span class="s2">\n      </span><span class="s1">pathnameBase: normalizePathname(</span><span class="s2">\n        </span><span class="s1">joinPaths([matchedPathname, match.pathnameBase])</span><span class="s2">\n      </span><span class="s1">),</span><span class="s2">\n      </span><span class="s1">route</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">if (match.pathnameBase !== </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return matches;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function generatePath(originalPath, params = {}) {</span><span class="s2">\n  </span><span class="s1">let path = originalPath;</span><span class="s2">\n  </span><span class="s1">if (path.endsWith(</span><span class="s2">\&quot;</span><span class="s1">*</span><span class="s2">\&quot;</span><span class="s1">) &amp;&amp; path !== </span><span class="s2">\&quot;</span><span class="s1">*</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; !path.endsWith(</span><span class="s2">\&quot;</span><span class="s1">/*</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n    </span><span class="s1">warning(</span><span class="s2">\n      </span><span class="s1">false,</span><span class="s2">\n      </span><span class="s1">`Route path </span><span class="s2">\&quot;</span><span class="s1">${path}</span><span class="s2">\&quot; </span><span class="s1">will be treated as if it were </span><span class="s2">\&quot;</span><span class="s1">${path.replace(/</span><span class="s2">\\</span><span class="s1">*$/, </span><span class="s2">\&quot;</span><span class="s1">/*</span><span class="s2">\&quot;</span><span class="s1">)}</span><span class="s2">\&quot; </span><span class="s1">because the </span><span class="s2">\\</span><span class="s1">`*</span><span class="s2">\\</span><span class="s1">` character must always follow a </span><span class="s2">\\</span><span class="s1">`/</span><span class="s2">\\</span><span class="s1">` in the pattern. To get rid of this warning, please change the route path to </span><span class="s2">\&quot;</span><span class="s1">${path.replace(/</span><span class="s2">\\</span><span class="s1">*$/, </span><span class="s2">\&quot;</span><span class="s1">/*</span><span class="s2">\&quot;</span><span class="s1">)}</span><span class="s2">\&quot;</span><span class="s1">.`</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">path = path.replace(/</span><span class="s2">\\</span><span class="s1">*$/, </span><span class="s2">\&quot;</span><span class="s1">/*</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">const prefix = path.startsWith(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">) ? </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot; </span><span class="s1">: </span><span class="s2">\&quot;\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">const stringify2 = (p) =&gt; p == null ? </span><span class="s2">\&quot;\&quot; </span><span class="s1">: typeof p === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">? p : String(p);</span><span class="s2">\n  </span><span class="s1">const segments = path.split(/</span><span class="s2">\\</span><span class="s1">/+/).map((segment, index, array) =&gt; {</span><span class="s2">\n    </span><span class="s1">const isLastSegment = index === array.length - 1;</span><span class="s2">\n    </span><span class="s1">if (isLastSegment &amp;&amp; segment === </span><span class="s2">\&quot;</span><span class="s1">*</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">const star = </span><span class="s2">\&quot;</span><span class="s1">*</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n      </span><span class="s1">return stringify2(params[star]);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">const keyMatch = segment.match(/^:([</span><span class="s2">\\</span><span class="s1">w-]+)(</span><span class="s2">\\</span><span class="s1">??)$/);</span><span class="s2">\n    </span><span class="s1">if (keyMatch) {</span><span class="s2">\n      </span><span class="s1">const [, key, optional] = keyMatch;</span><span class="s2">\n      </span><span class="s1">let param = params[key];</span><span class="s2">\n      </span><span class="s1">invariant(optional === </span><span class="s2">\&quot;</span><span class="s1">?</span><span class="s2">\&quot; </span><span class="s1">|| param != null, `Missing </span><span class="s2">\&quot;</span><span class="s1">:${key}</span><span class="s2">\&quot; </span><span class="s1">param`);</span><span class="s2">\n      </span><span class="s1">return stringify2(param);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return segment.replace(/</span><span class="s2">\\</span><span class="s1">?$/g, </span><span class="s2">\&quot;\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}).filter((segment) =&gt; !!segment);</span><span class="s2">\n  </span><span class="s1">return prefix + segments.join(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function matchPath(pattern, pathname) {</span><span class="s2">\n  </span><span class="s1">if (typeof pattern === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">pattern = { path: pattern, caseSensitive: false, end: true };</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let [matcher, compiledParams] = compilePath(</span><span class="s2">\n    </span><span class="s1">pattern.path,</span><span class="s2">\n    </span><span class="s1">pattern.caseSensitive,</span><span class="s2">\n    </span><span class="s1">pattern.end</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let match = pathname.match(matcher);</span><span class="s2">\n  </span><span class="s1">if (!match) return null;</span><span class="s2">\n  </span><span class="s1">let matchedPathname = match[0];</span><span class="s2">\n  </span><span class="s1">let pathnameBase = matchedPathname.replace(/(.)</span><span class="s2">\\</span><span class="s1">/+$/, </span><span class="s2">\&quot;</span><span class="s1">$1</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let captureGroups = match.slice(1);</span><span class="s2">\n  </span><span class="s1">let params = compiledParams.reduce(</span><span class="s2">\n    </span><span class="s1">(memo2, { paramName, isOptional }, index) =&gt; {</span><span class="s2">\n      </span><span class="s1">if (paramName === </span><span class="s2">\&quot;</span><span class="s1">*</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">let splatValue = captureGroups[index] || </span><span class="s2">\&quot;\&quot;</span><span class="s1">;</span><span class="s2">\n        </span><span class="s1">pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)</span><span class="s2">\\</span><span class="s1">/+$/, </span><span class="s2">\&quot;</span><span class="s1">$1</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">const value = captureGroups[index];</span><span class="s2">\n      </span><span class="s1">if (isOptional &amp;&amp; !value) {</span><span class="s2">\n        </span><span class="s1">memo2[paramName] = void 0;</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">memo2[paramName] = (value || </span><span class="s2">\&quot;\&quot;</span><span class="s1">).replace(/%2F/g, </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return memo2;</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">{}</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">params,</span><span class="s2">\n    </span><span class="s1">pathname: matchedPathname,</span><span class="s2">\n    </span><span class="s1">pathnameBase,</span><span class="s2">\n    </span><span class="s1">pattern</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function compilePath(path, caseSensitive = false, end = true) {</span><span class="s2">\n  </span><span class="s1">warning(</span><span class="s2">\n    </span><span class="s1">path === </span><span class="s2">\&quot;</span><span class="s1">*</span><span class="s2">\&quot; </span><span class="s1">|| !path.endsWith(</span><span class="s2">\&quot;</span><span class="s1">*</span><span class="s2">\&quot;</span><span class="s1">) || path.endsWith(</span><span class="s2">\&quot;</span><span class="s1">/*</span><span class="s2">\&quot;</span><span class="s1">),</span><span class="s2">\n    </span><span class="s1">`Route path </span><span class="s2">\&quot;</span><span class="s1">${path}</span><span class="s2">\&quot; </span><span class="s1">will be treated as if it were </span><span class="s2">\&quot;</span><span class="s1">${path.replace(/</span><span class="s2">\\</span><span class="s1">*$/, </span><span class="s2">\&quot;</span><span class="s1">/*</span><span class="s2">\&quot;</span><span class="s1">)}</span><span class="s2">\&quot; </span><span class="s1">because the </span><span class="s2">\\</span><span class="s1">`*</span><span class="s2">\\</span><span class="s1">` character must always follow a </span><span class="s2">\\</span><span class="s1">`/</span><span class="s2">\\</span><span class="s1">` in the pattern. To get rid of this warning, please change the route path to </span><span class="s2">\&quot;</span><span class="s1">${path.replace(/</span><span class="s2">\\</span><span class="s1">*$/, </span><span class="s2">\&quot;</span><span class="s1">/*</span><span class="s2">\&quot;</span><span class="s1">)}</span><span class="s2">\&quot;</span><span class="s1">.`</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let params = [];</span><span class="s2">\n  </span><span class="s1">let regexpSource = </span><span class="s2">\&quot;</span><span class="s1">^</span><span class="s2">\&quot; </span><span class="s1">+ path.replace(/</span><span class="s2">\\</span><span class="s1">/*</span><span class="s2">\\</span><span class="s1">*?$/, </span><span class="s2">\&quot;\&quot;</span><span class="s1">).replace(/^</span><span class="s2">\\</span><span class="s1">/*/, </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">).replace(/[</span><span class="s2">\\\\</span><span class="s1">.*+^${}|()[</span><span class="s2">\\</span><span class="s1">]]/g, </span><span class="s2">\&quot;\\\\</span><span class="s1">$&amp;</span><span class="s2">\&quot;</span><span class="s1">).replace(</span><span class="s2">\n    </span><span class="s1">/</span><span class="s2">\\</span><span class="s1">/:([</span><span class="s2">\\</span><span class="s1">w-]+)(</span><span class="s2">\\</span><span class="s1">?)?/g,</span><span class="s2">\n    </span><span class="s1">(_, paramName, isOptional) =&gt; {</span><span class="s2">\n      </span><span class="s1">params.push({ paramName, isOptional: isOptional != null });</span><span class="s2">\n      </span><span class="s1">return isOptional ? </span><span class="s2">\&quot;</span><span class="s1">/?([^</span><span class="s2">\\\\</span><span class="s1">/]+)?</span><span class="s2">\&quot; </span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">/([^</span><span class="s2">\\\\</span><span class="s1">/]+)</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">if (path.endsWith(</span><span class="s2">\&quot;</span><span class="s1">*</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n    </span><span class="s1">params.push({ paramName: </span><span class="s2">\&quot;</span><span class="s1">*</span><span class="s2">\&quot; </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">regexpSource += path === </span><span class="s2">\&quot;</span><span class="s1">*</span><span class="s2">\&quot; </span><span class="s1">|| path === </span><span class="s2">\&quot;</span><span class="s1">/*</span><span class="s2">\&quot; </span><span class="s1">? </span><span class="s2">\&quot;</span><span class="s1">(.*)$</span><span class="s2">\&quot; </span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">(?:</span><span class="s2">\\\\</span><span class="s1">/(.+)|</span><span class="s2">\\\\</span><span class="s1">/*)$</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">} else if (end) {</span><span class="s2">\n    </span><span class="s1">regexpSource += </span><span class="s2">\&quot;\\\\</span><span class="s1">/*$</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">} else if (path !== </span><span class="s2">\&quot;\&quot; </span><span class="s1">&amp;&amp; path !== </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">regexpSource += </span><span class="s2">\&quot;</span><span class="s1">(?:(?=</span><span class="s2">\\\\</span><span class="s1">/|$))</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : </span><span class="s2">\&quot;</span><span class="s1">i</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">return [matcher, params];</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function decodePath(value) {</span><span class="s2">\n  </span><span class="s1">try {</span><span class="s2">\n    </span><span class="s1">return value.split(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">).map((v) =&gt; decodeURIComponent(v).replace(/</span><span class="s2">\\</span><span class="s1">//g, </span><span class="s2">\&quot;</span><span class="s1">%2F</span><span class="s2">\&quot;</span><span class="s1">)).join(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">} catch (error) {</span><span class="s2">\n    </span><span class="s1">warning(</span><span class="s2">\n      </span><span class="s1">false,</span><span class="s2">\n      </span><span class="s1">`The URL path </span><span class="s2">\&quot;</span><span class="s1">${value}</span><span class="s2">\&quot; </span><span class="s1">could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${error}).`</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">return value;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function stripBasename(pathname, basename) {</span><span class="s2">\n  </span><span class="s1">if (basename === </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">) return pathname;</span><span class="s2">\n  </span><span class="s1">if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {</span><span class="s2">\n    </span><span class="s1">return null;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let startIndex = basename.endsWith(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">) ? basename.length - 1 : basename.length;</span><span class="s2">\n  </span><span class="s1">let nextChar = pathname.charAt(startIndex);</span><span class="s2">\n  </span><span class="s1">if (nextChar &amp;&amp; nextChar !== </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">return null;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return pathname.slice(startIndex) || </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function resolvePath(to, fromPathname = </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n  </span><span class="s1">let {</span><span class="s2">\n    </span><span class="s1">pathname: toPathname,</span><span class="s2">\n    </span><span class="s1">search = </span><span class="s2">\&quot;\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">hash = </span><span class="s2">\&quot;\&quot;\n  </span><span class="s1">} = typeof to === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">? parsePath(to) : to;</span><span class="s2">\n  </span><span class="s1">let pathname = toPathname ? toPathname.startsWith(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">) ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">pathname,</span><span class="s2">\n    </span><span class="s1">search: normalizeSearch(search),</span><span class="s2">\n    </span><span class="s1">hash: normalizeHash(hash)</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function resolvePathname(relativePath, fromPathname) {</span><span class="s2">\n  </span><span class="s1">let segments = fromPathname.replace(/</span><span class="s2">\\</span><span class="s1">/+$/, </span><span class="s2">\&quot;\&quot;</span><span class="s1">).split(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let relativeSegments = relativePath.split(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">relativeSegments.forEach((segment) =&gt; {</span><span class="s2">\n    </span><span class="s1">if (segment === </span><span class="s2">\&quot;</span><span class="s1">..</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">if (segments.length &gt; 1) segments.pop();</span><span class="s2">\n    </span><span class="s1">} else if (segment !== </span><span class="s2">\&quot;</span><span class="s1">.</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">segments.push(segment);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">return segments.length &gt; 1 ? segments.join(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">) : </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getInvalidPathError(char, field, dest, path) {</span><span class="s2">\n  </span><span class="s1">return `Cannot include a '${char}' character in a manually specified </span><span class="s2">\\</span><span class="s1">`to.${field}</span><span class="s2">\\</span><span class="s1">` field [${JSON.stringify(</span><span class="s2">\n    </span><span class="s1">path</span><span class="s2">\n  </span><span class="s1">)}].  Please separate it out to the </span><span class="s2">\\</span><span class="s1">`to.${dest}</span><span class="s2">\\</span><span class="s1">` field. Alternatively you may provide the full path as a string in &lt;Link to=</span><span class="s2">\&quot;</span><span class="s1">...</span><span class="s2">\&quot;</span><span class="s1">&gt; and the router will parse it for you.`;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getPathContributingMatches(matches) {</span><span class="s2">\n  </span><span class="s1">return matches.filter(</span><span class="s2">\n    </span><span class="s1">(match, index) =&gt; index === 0 || match.route.path &amp;&amp; match.route.path.length &gt; 0</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getResolveToMatches(matches) {</span><span class="s2">\n  </span><span class="s1">let pathMatches = getPathContributingMatches(matches);</span><span class="s2">\n  </span><span class="s1">return pathMatches.map(</span><span class="s2">\n    </span><span class="s1">(match, idx) =&gt; idx === pathMatches.length - 1 ? match.pathname : match.pathnameBase</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function resolveTo(toArg, routePathnames, locationPathname, isPathRelative = false) {</span><span class="s2">\n  </span><span class="s1">let to;</span><span class="s2">\n  </span><span class="s1">if (typeof toArg === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">to = parsePath(toArg);</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">to = { ...toArg };</span><span class="s2">\n    </span><span class="s1">invariant(</span><span class="s2">\n      </span><span class="s1">!to.pathname || !to.pathname.includes(</span><span class="s2">\&quot;</span><span class="s1">?</span><span class="s2">\&quot;</span><span class="s1">),</span><span class="s2">\n      </span><span class="s1">getInvalidPathError(</span><span class="s2">\&quot;</span><span class="s1">?</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">pathname</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">search</span><span class="s2">\&quot;</span><span class="s1">, to)</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">invariant(</span><span class="s2">\n      </span><span class="s1">!to.pathname || !to.pathname.includes(</span><span class="s2">\&quot;</span><span class="s1">#</span><span class="s2">\&quot;</span><span class="s1">),</span><span class="s2">\n      </span><span class="s1">getInvalidPathError(</span><span class="s2">\&quot;</span><span class="s1">#</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">pathname</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">hash</span><span class="s2">\&quot;</span><span class="s1">, to)</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">invariant(</span><span class="s2">\n      </span><span class="s1">!to.search || !to.search.includes(</span><span class="s2">\&quot;</span><span class="s1">#</span><span class="s2">\&quot;</span><span class="s1">),</span><span class="s2">\n      </span><span class="s1">getInvalidPathError(</span><span class="s2">\&quot;</span><span class="s1">#</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">search</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">hash</span><span class="s2">\&quot;</span><span class="s1">, to)</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let isEmptyPath = toArg === </span><span class="s2">\&quot;\&quot; </span><span class="s1">|| to.pathname === </span><span class="s2">\&quot;\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">let toPathname = isEmptyPath ? </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot; </span><span class="s1">: to.pathname;</span><span class="s2">\n  </span><span class="s1">let from;</span><span class="s2">\n  </span><span class="s1">if (toPathname == null) {</span><span class="s2">\n    </span><span class="s1">from = locationPathname;</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">let routePathnameIndex = routePathnames.length - 1;</span><span class="s2">\n    </span><span class="s1">if (!isPathRelative &amp;&amp; toPathname.startsWith(</span><span class="s2">\&quot;</span><span class="s1">..</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n      </span><span class="s1">let toSegments = toPathname.split(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">while (toSegments[0] === </span><span class="s2">\&quot;</span><span class="s1">..</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">toSegments.shift();</span><span class="s2">\n        </span><span class="s1">routePathnameIndex -= 1;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">to.pathname = toSegments.join(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">from = routePathnameIndex &gt;= 0 ? routePathnames[routePathnameIndex] : </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let path = resolvePath(to, from);</span><span class="s2">\n  </span><span class="s1">let hasExplicitTrailingSlash = toPathname &amp;&amp; toPathname !== </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; toPathname.endsWith(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let hasCurrentTrailingSlash = (isEmptyPath || toPathname === </span><span class="s2">\&quot;</span><span class="s1">.</span><span class="s2">\&quot;</span><span class="s1">) &amp;&amp; locationPathname.endsWith(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">if (!path.pathname.endsWith(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">) &amp;&amp; (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {</span><span class="s2">\n    </span><span class="s1">path.pathname += </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return path;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var joinPaths = (paths) =&gt; paths.join(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">).replace(/</span><span class="s2">\\</span><span class="s1">/</span><span class="s2">\\</span><span class="s1">/+/g, </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n</span><span class="s1">var normalizePathname = (pathname) =&gt; pathname.replace(/</span><span class="s2">\\</span><span class="s1">/+$/, </span><span class="s2">\&quot;\&quot;</span><span class="s1">).replace(/^</span><span class="s2">\\</span><span class="s1">/*/, </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n</span><span class="s1">var normalizeSearch = (search) =&gt; !search || search === </span><span class="s2">\&quot;</span><span class="s1">?</span><span class="s2">\&quot; </span><span class="s1">? </span><span class="s2">\&quot;\&quot; </span><span class="s1">: search.startsWith(</span><span class="s2">\&quot;</span><span class="s1">?</span><span class="s2">\&quot;</span><span class="s1">) ? search : </span><span class="s2">\&quot;</span><span class="s1">?</span><span class="s2">\&quot; </span><span class="s1">+ search;</span><span class="s2">\n</span><span class="s1">var normalizeHash = (hash) =&gt; !hash || hash === </span><span class="s2">\&quot;</span><span class="s1">#</span><span class="s2">\&quot; </span><span class="s1">? </span><span class="s2">\&quot;\&quot; </span><span class="s1">: hash.startsWith(</span><span class="s2">\&quot;</span><span class="s1">#</span><span class="s2">\&quot;</span><span class="s1">) ? hash : </span><span class="s2">\&quot;</span><span class="s1">#</span><span class="s2">\&quot; </span><span class="s1">+ hash;</span><span class="s2">\n</span><span class="s1">var DataWithResponseInit = class {</span><span class="s2">\n  </span><span class="s1">constructor(data2, init) {</span><span class="s2">\n    </span><span class="s1">this.type = </span><span class="s2">\&quot;</span><span class="s1">DataWithResponseInit</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">this.data = data2;</span><span class="s2">\n    </span><span class="s1">this.init = init || null;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">function data(data2, init) {</span><span class="s2">\n  </span><span class="s1">return new DataWithResponseInit(</span><span class="s2">\n    </span><span class="s1">data2,</span><span class="s2">\n    </span><span class="s1">typeof init === </span><span class="s2">\&quot;</span><span class="s1">number</span><span class="s2">\&quot; </span><span class="s1">? { status: init } : init</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var redirect = (url, init = 302) =&gt; {</span><span class="s2">\n  </span><span class="s1">let responseInit = init;</span><span class="s2">\n  </span><span class="s1">if (typeof responseInit === </span><span class="s2">\&quot;</span><span class="s1">number</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">responseInit = { status: responseInit };</span><span class="s2">\n  </span><span class="s1">} else if (typeof responseInit.status === </span><span class="s2">\&quot;</span><span class="s1">undefined</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">responseInit.status = 302;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let headers = new Headers(responseInit.headers);</span><span class="s2">\n  </span><span class="s1">headers.set(</span><span class="s2">\&quot;</span><span class="s1">Location</span><span class="s2">\&quot;</span><span class="s1">, url);</span><span class="s2">\n  </span><span class="s1">return new Response(null, { ...responseInit, headers });</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">var redirectDocument = (url, init) =&gt; {</span><span class="s2">\n  </span><span class="s1">let response = redirect(url, init);</span><span class="s2">\n  </span><span class="s1">response.headers.set(</span><span class="s2">\&quot;</span><span class="s1">X-Remix-Reload-Document</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">true</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">return response;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">var replace = (url, init) =&gt; {</span><span class="s2">\n  </span><span class="s1">let response = redirect(url, init);</span><span class="s2">\n  </span><span class="s1">response.headers.set(</span><span class="s2">\&quot;</span><span class="s1">X-Remix-Replace</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">true</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">return response;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">var ErrorResponseImpl = class {</span><span class="s2">\n  </span><span class="s1">constructor(status, statusText, data2, internal = false) {</span><span class="s2">\n    </span><span class="s1">this.status = status;</span><span class="s2">\n    </span><span class="s1">this.statusText = statusText || </span><span class="s2">\&quot;\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">this.internal = internal;</span><span class="s2">\n    </span><span class="s1">if (data2 instanceof Error) {</span><span class="s2">\n      </span><span class="s1">this.data = data2.toString();</span><span class="s2">\n      </span><span class="s1">this.error = data2;</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">this.data = data2;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">function isRouteErrorResponse(error) {</span><span class="s2">\n  </span><span class="s1">return error != null &amp;&amp; typeof error.status === </span><span class="s2">\&quot;</span><span class="s1">number</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; typeof error.statusText === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; typeof error.internal === </span><span class="s2">\&quot;</span><span class="s1">boolean</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; </span><span class="s2">\&quot;</span><span class="s1">data</span><span class="s2">\&quot; </span><span class="s1">in error;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/router/router.ts</span><span class="s2">\n</span><span class="s1">var validMutationMethodsArr = [</span><span class="s2">\n  \&quot;</span><span class="s1">POST</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">PUT</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">PATCH</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">DELETE</span><span class="s2">\&quot;\n</span><span class="s1">];</span><span class="s2">\n</span><span class="s1">var validMutationMethods = new Set(</span><span class="s2">\n  </span><span class="s1">validMutationMethodsArr</span><span class="s2">\n</span><span class="s1">);</span><span class="s2">\n</span><span class="s1">var validRequestMethodsArr = [</span><span class="s2">\n  \&quot;</span><span class="s1">GET</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">...validMutationMethodsArr</span><span class="s2">\n</span><span class="s1">];</span><span class="s2">\n</span><span class="s1">var validRequestMethods = new Set(validRequestMethodsArr);</span><span class="s2">\n</span><span class="s1">var redirectStatusCodes = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]);</span><span class="s2">\n</span><span class="s1">var redirectPreserveMethodStatusCodes = /* @__PURE__ */ new Set([307, 308]);</span><span class="s2">\n</span><span class="s1">var IDLE_NAVIGATION = {</span><span class="s2">\n  </span><span class="s1">state: </span><span class="s2">\&quot;</span><span class="s1">idle</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">location: void 0,</span><span class="s2">\n  </span><span class="s1">formMethod: void 0,</span><span class="s2">\n  </span><span class="s1">formAction: void 0,</span><span class="s2">\n  </span><span class="s1">formEncType: void 0,</span><span class="s2">\n  </span><span class="s1">formData: void 0,</span><span class="s2">\n  </span><span class="s1">json: void 0,</span><span class="s2">\n  </span><span class="s1">text: void 0</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">var IDLE_FETCHER = {</span><span class="s2">\n  </span><span class="s1">state: </span><span class="s2">\&quot;</span><span class="s1">idle</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">data: void 0,</span><span class="s2">\n  </span><span class="s1">formMethod: void 0,</span><span class="s2">\n  </span><span class="s1">formAction: void 0,</span><span class="s2">\n  </span><span class="s1">formEncType: void 0,</span><span class="s2">\n  </span><span class="s1">formData: void 0,</span><span class="s2">\n  </span><span class="s1">json: void 0,</span><span class="s2">\n  </span><span class="s1">text: void 0</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">var IDLE_BLOCKER = {</span><span class="s2">\n  </span><span class="s1">state: </span><span class="s2">\&quot;</span><span class="s1">unblocked</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">proceed: void 0,</span><span class="s2">\n  </span><span class="s1">reset: void 0,</span><span class="s2">\n  </span><span class="s1">location: void 0</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">var ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|</span><span class="s2">\\</span><span class="s1">/</span><span class="s2">\\</span><span class="s1">/)/i;</span><span class="s2">\n</span><span class="s1">var defaultMapRouteProperties = (route) =&gt; ({</span><span class="s2">\n  </span><span class="s1">hasErrorBoundary: Boolean(route.hasErrorBoundary)</span><span class="s2">\n</span><span class="s1">});</span><span class="s2">\n</span><span class="s1">var TRANSITIONS_STORAGE_KEY = </span><span class="s2">\&quot;</span><span class="s1">remix-router-transitions</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">var ResetLoaderDataSymbol = Symbol(</span><span class="s2">\&quot;</span><span class="s1">ResetLoaderData</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n</span><span class="s1">function createRouter(init) {</span><span class="s2">\n  </span><span class="s1">const routerWindow = init.window ? init.window : typeof window !== </span><span class="s2">\&quot;</span><span class="s1">undefined</span><span class="s2">\&quot; </span><span class="s1">? window : void 0;</span><span class="s2">\n  </span><span class="s1">const isBrowser2 = typeof routerWindow !== </span><span class="s2">\&quot;</span><span class="s1">undefined</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; typeof routerWindow.document !== </span><span class="s2">\&quot;</span><span class="s1">undefined</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; typeof routerWindow.document.createElement !== </span><span class="s2">\&quot;</span><span class="s1">undefined</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">invariant(</span><span class="s2">\n    </span><span class="s1">init.routes.length &gt; 0,</span><span class="s2">\n    \&quot;</span><span class="s1">You must provide a non-empty routes array to createRouter</span><span class="s2">\&quot;\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let hydrationRouteProperties2 = init.hydrationRouteProperties || [];</span><span class="s2">\n  </span><span class="s1">let mapRouteProperties2 = init.mapRouteProperties || defaultMapRouteProperties;</span><span class="s2">\n  </span><span class="s1">let manifest = {};</span><span class="s2">\n  </span><span class="s1">let dataRoutes = convertRoutesToDataRoutes(</span><span class="s2">\n    </span><span class="s1">init.routes,</span><span class="s2">\n    </span><span class="s1">mapRouteProperties2,</span><span class="s2">\n    </span><span class="s1">void 0,</span><span class="s2">\n    </span><span class="s1">manifest</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let inFlightDataRoutes;</span><span class="s2">\n  </span><span class="s1">let basename = init.basename || </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">let dataStrategyImpl = init.dataStrategy || defaultDataStrategyWithMiddleware;</span><span class="s2">\n  </span><span class="s1">let future = {</span><span class="s2">\n    </span><span class="s1">unstable_middleware: false,</span><span class="s2">\n    </span><span class="s1">...init.future</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">let unlistenHistory = null;</span><span class="s2">\n  </span><span class="s1">let subscribers = /* @__PURE__ */ new Set();</span><span class="s2">\n  </span><span class="s1">let savedScrollPositions2 = null;</span><span class="s2">\n  </span><span class="s1">let getScrollRestorationKey2 = null;</span><span class="s2">\n  </span><span class="s1">let getScrollPosition = null;</span><span class="s2">\n  </span><span class="s1">let initialScrollRestored = init.hydrationData != null;</span><span class="s2">\n  </span><span class="s1">let initialMatches = matchRoutes(dataRoutes, init.history.location, basename);</span><span class="s2">\n  </span><span class="s1">let initialMatchesIsFOW = false;</span><span class="s2">\n  </span><span class="s1">let initialErrors = null;</span><span class="s2">\n  </span><span class="s1">let initialized;</span><span class="s2">\n  </span><span class="s1">if (initialMatches == null &amp;&amp; !init.patchRoutesOnNavigation) {</span><span class="s2">\n    </span><span class="s1">let error = getInternalRouterError(404, {</span><span class="s2">\n      </span><span class="s1">pathname: init.history.location.pathname</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">let { matches, route } = getShortCircuitMatches(dataRoutes);</span><span class="s2">\n    </span><span class="s1">initialized = true;</span><span class="s2">\n    </span><span class="s1">initialMatches = matches;</span><span class="s2">\n    </span><span class="s1">initialErrors = { [route.id]: error };</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">if (initialMatches &amp;&amp; !init.hydrationData) {</span><span class="s2">\n      </span><span class="s1">let fogOfWar = checkFogOfWar(</span><span class="s2">\n        </span><span class="s1">initialMatches,</span><span class="s2">\n        </span><span class="s1">dataRoutes,</span><span class="s2">\n        </span><span class="s1">init.history.location.pathname</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">if (fogOfWar.active) {</span><span class="s2">\n        </span><span class="s1">initialMatches = null;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (!initialMatches) {</span><span class="s2">\n      </span><span class="s1">initialized = false;</span><span class="s2">\n      </span><span class="s1">initialMatches = [];</span><span class="s2">\n      </span><span class="s1">let fogOfWar = checkFogOfWar(</span><span class="s2">\n        </span><span class="s1">null,</span><span class="s2">\n        </span><span class="s1">dataRoutes,</span><span class="s2">\n        </span><span class="s1">init.history.location.pathname</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">if (fogOfWar.active &amp;&amp; fogOfWar.matches) {</span><span class="s2">\n        </span><span class="s1">initialMatchesIsFOW = true;</span><span class="s2">\n        </span><span class="s1">initialMatches = fogOfWar.matches;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else if (initialMatches.some((m) =&gt; m.route.lazy)) {</span><span class="s2">\n      </span><span class="s1">initialized = false;</span><span class="s2">\n    </span><span class="s1">} else if (!initialMatches.some((m) =&gt; m.route.loader)) {</span><span class="s2">\n      </span><span class="s1">initialized = true;</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">let loaderData = init.hydrationData ? init.hydrationData.loaderData : null;</span><span class="s2">\n      </span><span class="s1">let errors = init.hydrationData ? init.hydrationData.errors : null;</span><span class="s2">\n      </span><span class="s1">if (errors) {</span><span class="s2">\n        </span><span class="s1">let idx = initialMatches.findIndex(</span><span class="s2">\n          </span><span class="s1">(m) =&gt; errors[m.route.id] !== void 0</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">initialized = initialMatches.slice(0, idx + 1).every(</span><span class="s2">\n          </span><span class="s1">(m) =&gt; !shouldLoadRouteOnHydration(m.route, loaderData, errors)</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">initialized = initialMatches.every(</span><span class="s2">\n          </span><span class="s1">(m) =&gt; !shouldLoadRouteOnHydration(m.route, loaderData, errors)</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let router;</span><span class="s2">\n  </span><span class="s1">let state = {</span><span class="s2">\n    </span><span class="s1">historyAction: init.history.action,</span><span class="s2">\n    </span><span class="s1">location: init.history.location,</span><span class="s2">\n    </span><span class="s1">matches: initialMatches,</span><span class="s2">\n    </span><span class="s1">initialized,</span><span class="s2">\n    </span><span class="s1">navigation: IDLE_NAVIGATION,</span><span class="s2">\n    </span><span class="s1">// Don't restore on initial updateState() if we were SSR'd</span><span class="s2">\n    </span><span class="s1">restoreScrollPosition: init.hydrationData != null ? false : null,</span><span class="s2">\n    </span><span class="s1">preventScrollReset: false,</span><span class="s2">\n    </span><span class="s1">revalidation: </span><span class="s2">\&quot;</span><span class="s1">idle</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">loaderData: init.hydrationData &amp;&amp; init.hydrationData.loaderData || {},</span><span class="s2">\n    </span><span class="s1">actionData: init.hydrationData &amp;&amp; init.hydrationData.actionData || null,</span><span class="s2">\n    </span><span class="s1">errors: init.hydrationData &amp;&amp; init.hydrationData.errors || initialErrors,</span><span class="s2">\n    </span><span class="s1">fetchers: /* @__PURE__ */ new Map(),</span><span class="s2">\n    </span><span class="s1">blockers: /* @__PURE__ */ new Map()</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">let pendingAction = </span><span class="s2">\&quot;</span><span class="s1">POP</span><span class="s2">\&quot; </span><span class="s1">/* Pop */;</span><span class="s2">\n  </span><span class="s1">let pendingPreventScrollReset = false;</span><span class="s2">\n  </span><span class="s1">let pendingNavigationController;</span><span class="s2">\n  </span><span class="s1">let pendingViewTransitionEnabled = false;</span><span class="s2">\n  </span><span class="s1">let appliedViewTransitions = /* @__PURE__ */ new Map();</span><span class="s2">\n  </span><span class="s1">let removePageHideEventListener = null;</span><span class="s2">\n  </span><span class="s1">let isUninterruptedRevalidation = false;</span><span class="s2">\n  </span><span class="s1">let isRevalidationRequired = false;</span><span class="s2">\n  </span><span class="s1">let cancelledFetcherLoads = /* @__PURE__ */ new Set();</span><span class="s2">\n  </span><span class="s1">let fetchControllers = /* @__PURE__ */ new Map();</span><span class="s2">\n  </span><span class="s1">let incrementingLoadId = 0;</span><span class="s2">\n  </span><span class="s1">let pendingNavigationLoadId = -1;</span><span class="s2">\n  </span><span class="s1">let fetchReloadIds = /* @__PURE__ */ new Map();</span><span class="s2">\n  </span><span class="s1">let fetchRedirectIds = /* @__PURE__ */ new Set();</span><span class="s2">\n  </span><span class="s1">let fetchLoadMatches = /* @__PURE__ */ new Map();</span><span class="s2">\n  </span><span class="s1">let activeFetchers = /* @__PURE__ */ new Map();</span><span class="s2">\n  </span><span class="s1">let fetchersQueuedForDeletion = /* @__PURE__ */ new Set();</span><span class="s2">\n  </span><span class="s1">let blockerFunctions = /* @__PURE__ */ new Map();</span><span class="s2">\n  </span><span class="s1">let unblockBlockerHistoryUpdate = void 0;</span><span class="s2">\n  </span><span class="s1">let pendingRevalidationDfd = null;</span><span class="s2">\n  </span><span class="s1">function initialize() {</span><span class="s2">\n    </span><span class="s1">unlistenHistory = init.history.listen(</span><span class="s2">\n      </span><span class="s1">({ action: historyAction, location, delta }) =&gt; {</span><span class="s2">\n        </span><span class="s1">if (unblockBlockerHistoryUpdate) {</span><span class="s2">\n          </span><span class="s1">unblockBlockerHistoryUpdate();</span><span class="s2">\n          </span><span class="s1">unblockBlockerHistoryUpdate = void 0;</span><span class="s2">\n          </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">warning(</span><span class="s2">\n          </span><span class="s1">blockerFunctions.size === 0 || delta != null,</span><span class="s2">\n          \&quot;</span><span class="s1">You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL.</span><span class="s2">\&quot;\n        </span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">let blockerKey = shouldBlockNavigation({</span><span class="s2">\n          </span><span class="s1">currentLocation: state.location,</span><span class="s2">\n          </span><span class="s1">nextLocation: location,</span><span class="s2">\n          </span><span class="s1">historyAction</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">if (blockerKey &amp;&amp; delta != null) {</span><span class="s2">\n          </span><span class="s1">let nextHistoryUpdatePromise = new Promise((resolve) =&gt; {</span><span class="s2">\n            </span><span class="s1">unblockBlockerHistoryUpdate = resolve;</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n          </span><span class="s1">init.history.go(delta * -1);</span><span class="s2">\n          </span><span class="s1">updateBlocker(blockerKey, {</span><span class="s2">\n            </span><span class="s1">state: </span><span class="s2">\&quot;</span><span class="s1">blocked</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n            </span><span class="s1">location,</span><span class="s2">\n            </span><span class="s1">proceed() {</span><span class="s2">\n              </span><span class="s1">updateBlocker(blockerKey, {</span><span class="s2">\n                </span><span class="s1">state: </span><span class="s2">\&quot;</span><span class="s1">proceeding</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n                </span><span class="s1">proceed: void 0,</span><span class="s2">\n                </span><span class="s1">reset: void 0,</span><span class="s2">\n                </span><span class="s1">location</span><span class="s2">\n              </span><span class="s1">});</span><span class="s2">\n              </span><span class="s1">nextHistoryUpdatePromise.then(() =&gt; init.history.go(delta));</span><span class="s2">\n            </span><span class="s1">},</span><span class="s2">\n            </span><span class="s1">reset() {</span><span class="s2">\n              </span><span class="s1">let blockers = new Map(state.blockers);</span><span class="s2">\n              </span><span class="s1">blockers.set(blockerKey, IDLE_BLOCKER);</span><span class="s2">\n              </span><span class="s1">updateState({ blockers });</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n          </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return startNavigation(historyAction, location);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">if (isBrowser2) {</span><span class="s2">\n      </span><span class="s1">restoreAppliedTransitions(routerWindow, appliedViewTransitions);</span><span class="s2">\n      </span><span class="s1">let _saveAppliedTransitions = () =&gt; persistAppliedTransitions(routerWindow, appliedViewTransitions);</span><span class="s2">\n      </span><span class="s1">routerWindow.addEventListener(</span><span class="s2">\&quot;</span><span class="s1">pagehide</span><span class="s2">\&quot;</span><span class="s1">, _saveAppliedTransitions);</span><span class="s2">\n      </span><span class="s1">removePageHideEventListener = () =&gt; routerWindow.removeEventListener(</span><span class="s2">\&quot;</span><span class="s1">pagehide</span><span class="s2">\&quot;</span><span class="s1">, _saveAppliedTransitions);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (!state.initialized) {</span><span class="s2">\n      </span><span class="s1">startNavigation(</span><span class="s2">\&quot;</span><span class="s1">POP</span><span class="s2">\&quot; </span><span class="s1">/* Pop */, state.location, {</span><span class="s2">\n        </span><span class="s1">initialHydration: true</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return router;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function dispose() {</span><span class="s2">\n    </span><span class="s1">if (unlistenHistory) {</span><span class="s2">\n      </span><span class="s1">unlistenHistory();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (removePageHideEventListener) {</span><span class="s2">\n      </span><span class="s1">removePageHideEventListener();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">subscribers.clear();</span><span class="s2">\n    </span><span class="s1">pendingNavigationController &amp;&amp; pendingNavigationController.abort();</span><span class="s2">\n    </span><span class="s1">state.fetchers.forEach((_, key) =&gt; deleteFetcher(key));</span><span class="s2">\n    </span><span class="s1">state.blockers.forEach((_, key) =&gt; deleteBlocker(key));</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function subscribe(fn) {</span><span class="s2">\n    </span><span class="s1">subscribers.add(fn);</span><span class="s2">\n    </span><span class="s1">return () =&gt; subscribers.delete(fn);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function updateState(newState, opts = {}) {</span><span class="s2">\n    </span><span class="s1">state = {</span><span class="s2">\n      </span><span class="s1">...state,</span><span class="s2">\n      </span><span class="s1">...newState</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">let unmountedFetchers = [];</span><span class="s2">\n    </span><span class="s1">let mountedFetchers = [];</span><span class="s2">\n    </span><span class="s1">state.fetchers.forEach((fetcher, key) =&gt; {</span><span class="s2">\n      </span><span class="s1">if (fetcher.state === </span><span class="s2">\&quot;</span><span class="s1">idle</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">if (fetchersQueuedForDeletion.has(key)) {</span><span class="s2">\n          </span><span class="s1">unmountedFetchers.push(key);</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">mountedFetchers.push(key);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">fetchersQueuedForDeletion.forEach((key) =&gt; {</span><span class="s2">\n      </span><span class="s1">if (!state.fetchers.has(key) &amp;&amp; !fetchControllers.has(key)) {</span><span class="s2">\n        </span><span class="s1">unmountedFetchers.push(key);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">[...subscribers].forEach(</span><span class="s2">\n      </span><span class="s1">(subscriber) =&gt; subscriber(state, {</span><span class="s2">\n        </span><span class="s1">deletedFetchers: unmountedFetchers,</span><span class="s2">\n        </span><span class="s1">viewTransitionOpts: opts.viewTransitionOpts,</span><span class="s2">\n        </span><span class="s1">flushSync: opts.flushSync === true</span><span class="s2">\n      </span><span class="s1">})</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">unmountedFetchers.forEach((key) =&gt; deleteFetcher(key));</span><span class="s2">\n    </span><span class="s1">mountedFetchers.forEach((key) =&gt; state.fetchers.delete(key));</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function completeNavigation(location, newState, { flushSync } = {}) {</span><span class="s2">\n    </span><span class="s1">let isActionReload = state.actionData != null &amp;&amp; state.navigation.formMethod != null &amp;&amp; isMutationMethod(state.navigation.formMethod) &amp;&amp; state.navigation.state === </span><span class="s2">\&quot;</span><span class="s1">loading</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; location.state?._isRedirect !== true;</span><span class="s2">\n    </span><span class="s1">let actionData;</span><span class="s2">\n    </span><span class="s1">if (newState.actionData) {</span><span class="s2">\n      </span><span class="s1">if (Object.keys(newState.actionData).length &gt; 0) {</span><span class="s2">\n        </span><span class="s1">actionData = newState.actionData;</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">actionData = null;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else if (isActionReload) {</span><span class="s2">\n      </span><span class="s1">actionData = state.actionData;</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">actionData = null;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let loaderData = newState.loaderData ? mergeLoaderData(</span><span class="s2">\n      </span><span class="s1">state.loaderData,</span><span class="s2">\n      </span><span class="s1">newState.loaderData,</span><span class="s2">\n      </span><span class="s1">newState.matches || [],</span><span class="s2">\n      </span><span class="s1">newState.errors</span><span class="s2">\n    </span><span class="s1">) : state.loaderData;</span><span class="s2">\n    </span><span class="s1">let blockers = state.blockers;</span><span class="s2">\n    </span><span class="s1">if (blockers.size &gt; 0) {</span><span class="s2">\n      </span><span class="s1">blockers = new Map(blockers);</span><span class="s2">\n      </span><span class="s1">blockers.forEach((_, k) =&gt; blockers.set(k, IDLE_BLOCKER));</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let preventScrollReset = pendingPreventScrollReset === true || state.navigation.formMethod != null &amp;&amp; isMutationMethod(state.navigation.formMethod) &amp;&amp; location.state?._isRedirect !== true;</span><span class="s2">\n    </span><span class="s1">if (inFlightDataRoutes) {</span><span class="s2">\n      </span><span class="s1">dataRoutes = inFlightDataRoutes;</span><span class="s2">\n      </span><span class="s1">inFlightDataRoutes = void 0;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (isUninterruptedRevalidation) {</span><span class="s2">\n    </span><span class="s1">} else if (pendingAction === </span><span class="s2">\&quot;</span><span class="s1">POP</span><span class="s2">\&quot; </span><span class="s1">/* Pop */) {</span><span class="s2">\n    </span><span class="s1">} else if (pendingAction === </span><span class="s2">\&quot;</span><span class="s1">PUSH</span><span class="s2">\&quot; </span><span class="s1">/* Push */) {</span><span class="s2">\n      </span><span class="s1">init.history.push(location, location.state);</span><span class="s2">\n    </span><span class="s1">} else if (pendingAction === </span><span class="s2">\&quot;</span><span class="s1">REPLACE</span><span class="s2">\&quot; </span><span class="s1">/* Replace */) {</span><span class="s2">\n      </span><span class="s1">init.history.replace(location, location.state);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let viewTransitionOpts;</span><span class="s2">\n    </span><span class="s1">if (pendingAction === </span><span class="s2">\&quot;</span><span class="s1">POP</span><span class="s2">\&quot; </span><span class="s1">/* Pop */) {</span><span class="s2">\n      </span><span class="s1">let priorPaths = appliedViewTransitions.get(state.location.pathname);</span><span class="s2">\n      </span><span class="s1">if (priorPaths &amp;&amp; priorPaths.has(location.pathname)) {</span><span class="s2">\n        </span><span class="s1">viewTransitionOpts = {</span><span class="s2">\n          </span><span class="s1">currentLocation: state.location,</span><span class="s2">\n          </span><span class="s1">nextLocation: location</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">} else if (appliedViewTransitions.has(location.pathname)) {</span><span class="s2">\n        </span><span class="s1">viewTransitionOpts = {</span><span class="s2">\n          </span><span class="s1">currentLocation: location,</span><span class="s2">\n          </span><span class="s1">nextLocation: state.location</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else if (pendingViewTransitionEnabled) {</span><span class="s2">\n      </span><span class="s1">let toPaths = appliedViewTransitions.get(state.location.pathname);</span><span class="s2">\n      </span><span class="s1">if (toPaths) {</span><span class="s2">\n        </span><span class="s1">toPaths.add(location.pathname);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">toPaths = /* @__PURE__ */ new Set([location.pathname]);</span><span class="s2">\n        </span><span class="s1">appliedViewTransitions.set(state.location.pathname, toPaths);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">viewTransitionOpts = {</span><span class="s2">\n        </span><span class="s1">currentLocation: state.location,</span><span class="s2">\n        </span><span class="s1">nextLocation: location</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">updateState(</span><span class="s2">\n      </span><span class="s1">{</span><span class="s2">\n        </span><span class="s1">...newState,</span><span class="s2">\n        </span><span class="s1">// matches, errors, fetchers go through as-is</span><span class="s2">\n        </span><span class="s1">actionData,</span><span class="s2">\n        </span><span class="s1">loaderData,</span><span class="s2">\n        </span><span class="s1">historyAction: pendingAction,</span><span class="s2">\n        </span><span class="s1">location,</span><span class="s2">\n        </span><span class="s1">initialized: true,</span><span class="s2">\n        </span><span class="s1">navigation: IDLE_NAVIGATION,</span><span class="s2">\n        </span><span class="s1">revalidation: </span><span class="s2">\&quot;</span><span class="s1">idle</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        </span><span class="s1">restoreScrollPosition: getSavedScrollPosition(</span><span class="s2">\n          </span><span class="s1">location,</span><span class="s2">\n          </span><span class="s1">newState.matches || state.matches</span><span class="s2">\n        </span><span class="s1">),</span><span class="s2">\n        </span><span class="s1">preventScrollReset,</span><span class="s2">\n        </span><span class="s1">blockers</span><span class="s2">\n      </span><span class="s1">},</span><span class="s2">\n      </span><span class="s1">{</span><span class="s2">\n        </span><span class="s1">viewTransitionOpts,</span><span class="s2">\n        </span><span class="s1">flushSync: flushSync === true</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">pendingAction = </span><span class="s2">\&quot;</span><span class="s1">POP</span><span class="s2">\&quot; </span><span class="s1">/* Pop */;</span><span class="s2">\n    </span><span class="s1">pendingPreventScrollReset = false;</span><span class="s2">\n    </span><span class="s1">pendingViewTransitionEnabled = false;</span><span class="s2">\n    </span><span class="s1">isUninterruptedRevalidation = false;</span><span class="s2">\n    </span><span class="s1">isRevalidationRequired = false;</span><span class="s2">\n    </span><span class="s1">pendingRevalidationDfd?.resolve();</span><span class="s2">\n    </span><span class="s1">pendingRevalidationDfd = null;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">async function navigate(to, opts) {</span><span class="s2">\n    </span><span class="s1">if (typeof to === </span><span class="s2">\&quot;</span><span class="s1">number</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">init.history.go(to);</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let normalizedPath = normalizeTo(</span><span class="s2">\n      </span><span class="s1">state.location,</span><span class="s2">\n      </span><span class="s1">state.matches,</span><span class="s2">\n      </span><span class="s1">basename,</span><span class="s2">\n      </span><span class="s1">to,</span><span class="s2">\n      </span><span class="s1">opts?.fromRouteId,</span><span class="s2">\n      </span><span class="s1">opts?.relative</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">let { path, submission, error } = normalizeNavigateOptions(</span><span class="s2">\n      </span><span class="s1">false,</span><span class="s2">\n      </span><span class="s1">normalizedPath,</span><span class="s2">\n      </span><span class="s1">opts</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">let currentLocation = state.location;</span><span class="s2">\n    </span><span class="s1">let nextLocation = createLocation(state.location, path, opts &amp;&amp; opts.state);</span><span class="s2">\n    </span><span class="s1">nextLocation = {</span><span class="s2">\n      </span><span class="s1">...nextLocation,</span><span class="s2">\n      </span><span class="s1">...init.history.encodeLocation(nextLocation)</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">let userReplace = opts &amp;&amp; opts.replace != null ? opts.replace : void 0;</span><span class="s2">\n    </span><span class="s1">let historyAction = </span><span class="s2">\&quot;</span><span class="s1">PUSH</span><span class="s2">\&quot; </span><span class="s1">/* Push */;</span><span class="s2">\n    </span><span class="s1">if (userReplace === true) {</span><span class="s2">\n      </span><span class="s1">historyAction = </span><span class="s2">\&quot;</span><span class="s1">REPLACE</span><span class="s2">\&quot; </span><span class="s1">/* Replace */;</span><span class="s2">\n    </span><span class="s1">} else if (userReplace === false) {</span><span class="s2">\n    </span><span class="s1">} else if (submission != null &amp;&amp; isMutationMethod(submission.formMethod) &amp;&amp; submission.formAction === state.location.pathname + state.location.search) {</span><span class="s2">\n      </span><span class="s1">historyAction = </span><span class="s2">\&quot;</span><span class="s1">REPLACE</span><span class="s2">\&quot; </span><span class="s1">/* Replace */;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let preventScrollReset = opts &amp;&amp; </span><span class="s2">\&quot;</span><span class="s1">preventScrollReset</span><span class="s2">\&quot; </span><span class="s1">in opts ? opts.preventScrollReset === true : void 0;</span><span class="s2">\n    </span><span class="s1">let flushSync = (opts &amp;&amp; opts.flushSync) === true;</span><span class="s2">\n    </span><span class="s1">let blockerKey = shouldBlockNavigation({</span><span class="s2">\n      </span><span class="s1">currentLocation,</span><span class="s2">\n      </span><span class="s1">nextLocation,</span><span class="s2">\n      </span><span class="s1">historyAction</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">if (blockerKey) {</span><span class="s2">\n      </span><span class="s1">updateBlocker(blockerKey, {</span><span class="s2">\n        </span><span class="s1">state: </span><span class="s2">\&quot;</span><span class="s1">blocked</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        </span><span class="s1">location: nextLocation,</span><span class="s2">\n        </span><span class="s1">proceed() {</span><span class="s2">\n          </span><span class="s1">updateBlocker(blockerKey, {</span><span class="s2">\n            </span><span class="s1">state: </span><span class="s2">\&quot;</span><span class="s1">proceeding</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n            </span><span class="s1">proceed: void 0,</span><span class="s2">\n            </span><span class="s1">reset: void 0,</span><span class="s2">\n            </span><span class="s1">location: nextLocation</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n          </span><span class="s1">navigate(to, opts);</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">reset() {</span><span class="s2">\n          </span><span class="s1">let blockers = new Map(state.blockers);</span><span class="s2">\n          </span><span class="s1">blockers.set(blockerKey, IDLE_BLOCKER);</span><span class="s2">\n          </span><span class="s1">updateState({ blockers });</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">await startNavigation(historyAction, nextLocation, {</span><span class="s2">\n      </span><span class="s1">submission,</span><span class="s2">\n      </span><span class="s1">// Send through the formData serialization error if we have one so we can</span><span class="s2">\n      </span><span class="s1">// render at the right error boundary after we match routes</span><span class="s2">\n      </span><span class="s1">pendingError: error,</span><span class="s2">\n      </span><span class="s1">preventScrollReset,</span><span class="s2">\n      </span><span class="s1">replace: opts &amp;&amp; opts.replace,</span><span class="s2">\n      </span><span class="s1">enableViewTransition: opts &amp;&amp; opts.viewTransition,</span><span class="s2">\n      </span><span class="s1">flushSync</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function revalidate() {</span><span class="s2">\n    </span><span class="s1">if (!pendingRevalidationDfd) {</span><span class="s2">\n      </span><span class="s1">pendingRevalidationDfd = createDeferred();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">interruptActiveLoads();</span><span class="s2">\n    </span><span class="s1">updateState({ revalidation: </span><span class="s2">\&quot;</span><span class="s1">loading</span><span class="s2">\&quot; </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">let promise = pendingRevalidationDfd.promise;</span><span class="s2">\n    </span><span class="s1">if (state.navigation.state === </span><span class="s2">\&quot;</span><span class="s1">submitting</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">return promise;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (state.navigation.state === </span><span class="s2">\&quot;</span><span class="s1">idle</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">startNavigation(state.historyAction, state.location, {</span><span class="s2">\n        </span><span class="s1">startUninterruptedRevalidation: true</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">return promise;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">startNavigation(</span><span class="s2">\n      </span><span class="s1">pendingAction || state.historyAction,</span><span class="s2">\n      </span><span class="s1">state.navigation.location,</span><span class="s2">\n      </span><span class="s1">{</span><span class="s2">\n        </span><span class="s1">overrideNavigation: state.navigation,</span><span class="s2">\n        </span><span class="s1">// Proxy through any rending view transition</span><span class="s2">\n        </span><span class="s1">enableViewTransition: pendingViewTransitionEnabled === true</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">return promise;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">async function startNavigation(historyAction, location, opts) {</span><span class="s2">\n    </span><span class="s1">pendingNavigationController &amp;&amp; pendingNavigationController.abort();</span><span class="s2">\n    </span><span class="s1">pendingNavigationController = null;</span><span class="s2">\n    </span><span class="s1">pendingAction = historyAction;</span><span class="s2">\n    </span><span class="s1">isUninterruptedRevalidation = (opts &amp;&amp; opts.startUninterruptedRevalidation) === true;</span><span class="s2">\n    </span><span class="s1">saveScrollPosition(state.location, state.matches);</span><span class="s2">\n    </span><span class="s1">pendingPreventScrollReset = (opts &amp;&amp; opts.preventScrollReset) === true;</span><span class="s2">\n    </span><span class="s1">pendingViewTransitionEnabled = (opts &amp;&amp; opts.enableViewTransition) === true;</span><span class="s2">\n    </span><span class="s1">let routesToUse = inFlightDataRoutes || dataRoutes;</span><span class="s2">\n    </span><span class="s1">let loadingNavigation = opts &amp;&amp; opts.overrideNavigation;</span><span class="s2">\n    </span><span class="s1">let matches = opts?.initialHydration &amp;&amp; state.matches &amp;&amp; state.matches.length &gt; 0 &amp;&amp; !initialMatchesIsFOW ? (</span><span class="s2">\n      </span><span class="s1">// `matchRoutes()` has already been called if we're in here via `router.initialize()`</span><span class="s2">\n      </span><span class="s1">state.matches</span><span class="s2">\n    </span><span class="s1">) : matchRoutes(routesToUse, location, basename);</span><span class="s2">\n    </span><span class="s1">let flushSync = (opts &amp;&amp; opts.flushSync) === true;</span><span class="s2">\n    </span><span class="s1">if (matches &amp;&amp; state.initialized &amp;&amp; !isRevalidationRequired &amp;&amp; isHashChangeOnly(state.location, location) &amp;&amp; !(opts &amp;&amp; opts.submission &amp;&amp; isMutationMethod(opts.submission.formMethod))) {</span><span class="s2">\n      </span><span class="s1">completeNavigation(location, { matches }, { flushSync });</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let fogOfWar = checkFogOfWar(matches, routesToUse, location.pathname);</span><span class="s2">\n    </span><span class="s1">if (fogOfWar.active &amp;&amp; fogOfWar.matches) {</span><span class="s2">\n      </span><span class="s1">matches = fogOfWar.matches;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (!matches) {</span><span class="s2">\n      </span><span class="s1">let { error, notFoundMatches, route } = handleNavigational404(</span><span class="s2">\n        </span><span class="s1">location.pathname</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">completeNavigation(</span><span class="s2">\n        </span><span class="s1">location,</span><span class="s2">\n        </span><span class="s1">{</span><span class="s2">\n          </span><span class="s1">matches: notFoundMatches,</span><span class="s2">\n          </span><span class="s1">loaderData: {},</span><span class="s2">\n          </span><span class="s1">errors: {</span><span class="s2">\n            </span><span class="s1">[route.id]: error</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">{ flushSync }</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">pendingNavigationController = new AbortController();</span><span class="s2">\n    </span><span class="s1">let request = createClientSideRequest(</span><span class="s2">\n      </span><span class="s1">init.history,</span><span class="s2">\n      </span><span class="s1">location,</span><span class="s2">\n      </span><span class="s1">pendingNavigationController.signal,</span><span class="s2">\n      </span><span class="s1">opts &amp;&amp; opts.submission</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">let scopedContext = new unstable_RouterContextProvider(</span><span class="s2">\n      </span><span class="s1">init.unstable_getContext ? await init.unstable_getContext() : void 0</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">let pendingActionResult;</span><span class="s2">\n    </span><span class="s1">if (opts &amp;&amp; opts.pendingError) {</span><span class="s2">\n      </span><span class="s1">pendingActionResult = [</span><span class="s2">\n        </span><span class="s1">findNearestBoundary(matches).route.id,</span><span class="s2">\n        </span><span class="s1">{ type: </span><span class="s2">\&quot;</span><span class="s1">error</span><span class="s2">\&quot; </span><span class="s1">/* error */, error: opts.pendingError }</span><span class="s2">\n      </span><span class="s1">];</span><span class="s2">\n    </span><span class="s1">} else if (opts &amp;&amp; opts.submission &amp;&amp; isMutationMethod(opts.submission.formMethod)) {</span><span class="s2">\n      </span><span class="s1">let actionResult = await handleAction(</span><span class="s2">\n        </span><span class="s1">request,</span><span class="s2">\n        </span><span class="s1">location,</span><span class="s2">\n        </span><span class="s1">opts.submission,</span><span class="s2">\n        </span><span class="s1">matches,</span><span class="s2">\n        </span><span class="s1">scopedContext,</span><span class="s2">\n        </span><span class="s1">fogOfWar.active,</span><span class="s2">\n        </span><span class="s1">opts &amp;&amp; opts.initialHydration === true,</span><span class="s2">\n        </span><span class="s1">{ replace: opts.replace, flushSync }</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">if (actionResult.shortCircuited) {</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (actionResult.pendingActionResult) {</span><span class="s2">\n        </span><span class="s1">let [routeId, result] = actionResult.pendingActionResult;</span><span class="s2">\n        </span><span class="s1">if (isErrorResult(result) &amp;&amp; isRouteErrorResponse(result.error) &amp;&amp; result.error.status === 404) {</span><span class="s2">\n          </span><span class="s1">pendingNavigationController = null;</span><span class="s2">\n          </span><span class="s1">completeNavigation(location, {</span><span class="s2">\n            </span><span class="s1">matches: actionResult.matches,</span><span class="s2">\n            </span><span class="s1">loaderData: {},</span><span class="s2">\n            </span><span class="s1">errors: {</span><span class="s2">\n              </span><span class="s1">[routeId]: result.error</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n          </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">matches = actionResult.matches || matches;</span><span class="s2">\n      </span><span class="s1">pendingActionResult = actionResult.pendingActionResult;</span><span class="s2">\n      </span><span class="s1">loadingNavigation = getLoadingNavigation(location, opts.submission);</span><span class="s2">\n      </span><span class="s1">flushSync = false;</span><span class="s2">\n      </span><span class="s1">fogOfWar.active = false;</span><span class="s2">\n      </span><span class="s1">request = createClientSideRequest(</span><span class="s2">\n        </span><span class="s1">init.history,</span><span class="s2">\n        </span><span class="s1">request.url,</span><span class="s2">\n        </span><span class="s1">request.signal</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let {</span><span class="s2">\n      </span><span class="s1">shortCircuited,</span><span class="s2">\n      </span><span class="s1">matches: updatedMatches,</span><span class="s2">\n      </span><span class="s1">loaderData,</span><span class="s2">\n      </span><span class="s1">errors</span><span class="s2">\n    </span><span class="s1">} = await handleLoaders(</span><span class="s2">\n      </span><span class="s1">request,</span><span class="s2">\n      </span><span class="s1">location,</span><span class="s2">\n      </span><span class="s1">matches,</span><span class="s2">\n      </span><span class="s1">scopedContext,</span><span class="s2">\n      </span><span class="s1">fogOfWar.active,</span><span class="s2">\n      </span><span class="s1">loadingNavigation,</span><span class="s2">\n      </span><span class="s1">opts &amp;&amp; opts.submission,</span><span class="s2">\n      </span><span class="s1">opts &amp;&amp; opts.fetcherSubmission,</span><span class="s2">\n      </span><span class="s1">opts &amp;&amp; opts.replace,</span><span class="s2">\n      </span><span class="s1">opts &amp;&amp; opts.initialHydration === true,</span><span class="s2">\n      </span><span class="s1">flushSync,</span><span class="s2">\n      </span><span class="s1">pendingActionResult</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">if (shortCircuited) {</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">pendingNavigationController = null;</span><span class="s2">\n    </span><span class="s1">completeNavigation(location, {</span><span class="s2">\n      </span><span class="s1">matches: updatedMatches || matches,</span><span class="s2">\n      </span><span class="s1">...getActionDataForCommit(pendingActionResult),</span><span class="s2">\n      </span><span class="s1">loaderData,</span><span class="s2">\n      </span><span class="s1">errors</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">async function handleAction(request, location, submission, matches, scopedContext, isFogOfWar, initialHydration, opts = {}) {</span><span class="s2">\n    </span><span class="s1">interruptActiveLoads();</span><span class="s2">\n    </span><span class="s1">let navigation = getSubmittingNavigation(location, submission);</span><span class="s2">\n    </span><span class="s1">updateState({ navigation }, { flushSync: opts.flushSync === true });</span><span class="s2">\n    </span><span class="s1">if (isFogOfWar) {</span><span class="s2">\n      </span><span class="s1">let discoverResult = await discoverRoutes(</span><span class="s2">\n        </span><span class="s1">matches,</span><span class="s2">\n        </span><span class="s1">location.pathname,</span><span class="s2">\n        </span><span class="s1">request.signal</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">if (discoverResult.type === </span><span class="s2">\&quot;</span><span class="s1">aborted</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">return { shortCircuited: true };</span><span class="s2">\n      </span><span class="s1">} else if (discoverResult.type === </span><span class="s2">\&quot;</span><span class="s1">error</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">let boundaryId = findNearestBoundary(discoverResult.partialMatches).route.id;</span><span class="s2">\n        </span><span class="s1">return {</span><span class="s2">\n          </span><span class="s1">matches: discoverResult.partialMatches,</span><span class="s2">\n          </span><span class="s1">pendingActionResult: [</span><span class="s2">\n            </span><span class="s1">boundaryId,</span><span class="s2">\n            </span><span class="s1">{</span><span class="s2">\n              </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">error</span><span class="s2">\&quot; </span><span class="s1">/* error */,</span><span class="s2">\n              </span><span class="s1">error: discoverResult.error</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">]</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">} else if (!discoverResult.matches) {</span><span class="s2">\n        </span><span class="s1">let { notFoundMatches, error, route } = handleNavigational404(</span><span class="s2">\n          </span><span class="s1">location.pathname</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">return {</span><span class="s2">\n          </span><span class="s1">matches: notFoundMatches,</span><span class="s2">\n          </span><span class="s1">pendingActionResult: [</span><span class="s2">\n            </span><span class="s1">route.id,</span><span class="s2">\n            </span><span class="s1">{</span><span class="s2">\n              </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">error</span><span class="s2">\&quot; </span><span class="s1">/* error */,</span><span class="s2">\n              </span><span class="s1">error</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">]</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">matches = discoverResult.matches;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let result;</span><span class="s2">\n    </span><span class="s1">let actionMatch = getTargetMatch(matches, location);</span><span class="s2">\n    </span><span class="s1">if (!actionMatch.route.action &amp;&amp; !actionMatch.route.lazy) {</span><span class="s2">\n      </span><span class="s1">result = {</span><span class="s2">\n        </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">error</span><span class="s2">\&quot; </span><span class="s1">/* error */,</span><span class="s2">\n        </span><span class="s1">error: getInternalRouterError(405, {</span><span class="s2">\n          </span><span class="s1">method: request.method,</span><span class="s2">\n          </span><span class="s1">pathname: location.pathname,</span><span class="s2">\n          </span><span class="s1">routeId: actionMatch.route.id</span><span class="s2">\n        </span><span class="s1">})</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">let dsMatches = getTargetedDataStrategyMatches(</span><span class="s2">\n        </span><span class="s1">mapRouteProperties2,</span><span class="s2">\n        </span><span class="s1">manifest,</span><span class="s2">\n        </span><span class="s1">request,</span><span class="s2">\n        </span><span class="s1">matches,</span><span class="s2">\n        </span><span class="s1">actionMatch,</span><span class="s2">\n        </span><span class="s1">initialHydration ? [] : hydrationRouteProperties2,</span><span class="s2">\n        </span><span class="s1">scopedContext</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">let results = await callDataStrategy(</span><span class="s2">\n        </span><span class="s1">request,</span><span class="s2">\n        </span><span class="s1">dsMatches,</span><span class="s2">\n        </span><span class="s1">scopedContext,</span><span class="s2">\n        </span><span class="s1">null</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">result = results[actionMatch.route.id];</span><span class="s2">\n      </span><span class="s1">if (!result) {</span><span class="s2">\n        </span><span class="s1">for (let match of matches) {</span><span class="s2">\n          </span><span class="s1">if (results[match.route.id]) {</span><span class="s2">\n            </span><span class="s1">result = results[match.route.id];</span><span class="s2">\n            </span><span class="s1">break;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (request.signal.aborted) {</span><span class="s2">\n        </span><span class="s1">return { shortCircuited: true };</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (isRedirectResult(result)) {</span><span class="s2">\n      </span><span class="s1">let replace2;</span><span class="s2">\n      </span><span class="s1">if (opts &amp;&amp; opts.replace != null) {</span><span class="s2">\n        </span><span class="s1">replace2 = opts.replace;</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">let location2 = normalizeRedirectLocation(</span><span class="s2">\n          </span><span class="s1">result.response.headers.get(</span><span class="s2">\&quot;</span><span class="s1">Location</span><span class="s2">\&quot;</span><span class="s1">),</span><span class="s2">\n          </span><span class="s1">new URL(request.url),</span><span class="s2">\n          </span><span class="s1">basename</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">replace2 = location2 === state.location.pathname + state.location.search;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">await startRedirectNavigation(request, result, true, {</span><span class="s2">\n        </span><span class="s1">submission,</span><span class="s2">\n        </span><span class="s1">replace: replace2</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">return { shortCircuited: true };</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (isErrorResult(result)) {</span><span class="s2">\n      </span><span class="s1">let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);</span><span class="s2">\n      </span><span class="s1">if ((opts &amp;&amp; opts.replace) !== true) {</span><span class="s2">\n        </span><span class="s1">pendingAction = </span><span class="s2">\&quot;</span><span class="s1">PUSH</span><span class="s2">\&quot; </span><span class="s1">/* Push */;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return {</span><span class="s2">\n        </span><span class="s1">matches,</span><span class="s2">\n        </span><span class="s1">pendingActionResult: [</span><span class="s2">\n          </span><span class="s1">boundaryMatch.route.id,</span><span class="s2">\n          </span><span class="s1">result,</span><span class="s2">\n          </span><span class="s1">actionMatch.route.id</span><span class="s2">\n        </span><span class="s1">]</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return {</span><span class="s2">\n      </span><span class="s1">matches,</span><span class="s2">\n      </span><span class="s1">pendingActionResult: [actionMatch.route.id, result]</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">async function handleLoaders(request, location, matches, scopedContext, isFogOfWar, overrideNavigation, submission, fetcherSubmission, replace2, initialHydration, flushSync, pendingActionResult) {</span><span class="s2">\n    </span><span class="s1">let loadingNavigation = overrideNavigation || getLoadingNavigation(location, submission);</span><span class="s2">\n    </span><span class="s1">let activeSubmission = submission || fetcherSubmission || getSubmissionFromNavigation(loadingNavigation);</span><span class="s2">\n    </span><span class="s1">let shouldUpdateNavigationState = !isUninterruptedRevalidation &amp;&amp; !initialHydration;</span><span class="s2">\n    </span><span class="s1">if (isFogOfWar) {</span><span class="s2">\n      </span><span class="s1">if (shouldUpdateNavigationState) {</span><span class="s2">\n        </span><span class="s1">let actionData = getUpdatedActionData(pendingActionResult);</span><span class="s2">\n        </span><span class="s1">updateState(</span><span class="s2">\n          </span><span class="s1">{</span><span class="s2">\n            </span><span class="s1">navigation: loadingNavigation,</span><span class="s2">\n            </span><span class="s1">...actionData !== void 0 ? { actionData } : {}</span><span class="s2">\n          </span><span class="s1">},</span><span class="s2">\n          </span><span class="s1">{</span><span class="s2">\n            </span><span class="s1">flushSync</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">let discoverResult = await discoverRoutes(</span><span class="s2">\n        </span><span class="s1">matches,</span><span class="s2">\n        </span><span class="s1">location.pathname,</span><span class="s2">\n        </span><span class="s1">request.signal</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">if (discoverResult.type === </span><span class="s2">\&quot;</span><span class="s1">aborted</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">return { shortCircuited: true };</span><span class="s2">\n      </span><span class="s1">} else if (discoverResult.type === </span><span class="s2">\&quot;</span><span class="s1">error</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">let boundaryId = findNearestBoundary(discoverResult.partialMatches).route.id;</span><span class="s2">\n        </span><span class="s1">return {</span><span class="s2">\n          </span><span class="s1">matches: discoverResult.partialMatches,</span><span class="s2">\n          </span><span class="s1">loaderData: {},</span><span class="s2">\n          </span><span class="s1">errors: {</span><span class="s2">\n            </span><span class="s1">[boundaryId]: discoverResult.error</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">} else if (!discoverResult.matches) {</span><span class="s2">\n        </span><span class="s1">let { error, notFoundMatches, route } = handleNavigational404(</span><span class="s2">\n          </span><span class="s1">location.pathname</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">return {</span><span class="s2">\n          </span><span class="s1">matches: notFoundMatches,</span><span class="s2">\n          </span><span class="s1">loaderData: {},</span><span class="s2">\n          </span><span class="s1">errors: {</span><span class="s2">\n            </span><span class="s1">[route.id]: error</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">matches = discoverResult.matches;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let routesToUse = inFlightDataRoutes || dataRoutes;</span><span class="s2">\n    </span><span class="s1">let { dsMatches, revalidatingFetchers } = getMatchesToLoad(</span><span class="s2">\n      </span><span class="s1">request,</span><span class="s2">\n      </span><span class="s1">scopedContext,</span><span class="s2">\n      </span><span class="s1">mapRouteProperties2,</span><span class="s2">\n      </span><span class="s1">manifest,</span><span class="s2">\n      </span><span class="s1">init.history,</span><span class="s2">\n      </span><span class="s1">state,</span><span class="s2">\n      </span><span class="s1">matches,</span><span class="s2">\n      </span><span class="s1">activeSubmission,</span><span class="s2">\n      </span><span class="s1">location,</span><span class="s2">\n      </span><span class="s1">initialHydration ? [] : hydrationRouteProperties2,</span><span class="s2">\n      </span><span class="s1">initialHydration === true,</span><span class="s2">\n      </span><span class="s1">isRevalidationRequired,</span><span class="s2">\n      </span><span class="s1">cancelledFetcherLoads,</span><span class="s2">\n      </span><span class="s1">fetchersQueuedForDeletion,</span><span class="s2">\n      </span><span class="s1">fetchLoadMatches,</span><span class="s2">\n      </span><span class="s1">fetchRedirectIds,</span><span class="s2">\n      </span><span class="s1">routesToUse,</span><span class="s2">\n      </span><span class="s1">basename,</span><span class="s2">\n      </span><span class="s1">pendingActionResult</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">pendingNavigationLoadId = ++incrementingLoadId;</span><span class="s2">\n    </span><span class="s1">if (!init.dataStrategy &amp;&amp; !dsMatches.some((m) =&gt; m.shouldLoad) &amp;&amp; revalidatingFetchers.length === 0) {</span><span class="s2">\n      </span><span class="s1">let updatedFetchers2 = markFetchRedirectsDone();</span><span class="s2">\n      </span><span class="s1">completeNavigation(</span><span class="s2">\n        </span><span class="s1">location,</span><span class="s2">\n        </span><span class="s1">{</span><span class="s2">\n          </span><span class="s1">matches,</span><span class="s2">\n          </span><span class="s1">loaderData: {},</span><span class="s2">\n          </span><span class="s1">// Commit pending error if we're short circuiting</span><span class="s2">\n          </span><span class="s1">errors: pendingActionResult &amp;&amp; isErrorResult(pendingActionResult[1]) ? { [pendingActionResult[0]]: pendingActionResult[1].error } : null,</span><span class="s2">\n          </span><span class="s1">...getActionDataForCommit(pendingActionResult),</span><span class="s2">\n          </span><span class="s1">...updatedFetchers2 ? { fetchers: new Map(state.fetchers) } : {}</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">{ flushSync }</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">return { shortCircuited: true };</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (shouldUpdateNavigationState) {</span><span class="s2">\n      </span><span class="s1">let updates = {};</span><span class="s2">\n      </span><span class="s1">if (!isFogOfWar) {</span><span class="s2">\n        </span><span class="s1">updates.navigation = loadingNavigation;</span><span class="s2">\n        </span><span class="s1">let actionData = getUpdatedActionData(pendingActionResult);</span><span class="s2">\n        </span><span class="s1">if (actionData !== void 0) {</span><span class="s2">\n          </span><span class="s1">updates.actionData = actionData;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (revalidatingFetchers.length &gt; 0) {</span><span class="s2">\n        </span><span class="s1">updates.fetchers = getUpdatedRevalidatingFetchers(revalidatingFetchers);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">updateState(updates, { flushSync });</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">revalidatingFetchers.forEach((rf) =&gt; {</span><span class="s2">\n      </span><span class="s1">abortFetcher(rf.key);</span><span class="s2">\n      </span><span class="s1">if (rf.controller) {</span><span class="s2">\n        </span><span class="s1">fetchControllers.set(rf.key, rf.controller);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">let abortPendingFetchRevalidations = () =&gt; revalidatingFetchers.forEach((f) =&gt; abortFetcher(f.key));</span><span class="s2">\n    </span><span class="s1">if (pendingNavigationController) {</span><span class="s2">\n      </span><span class="s1">pendingNavigationController.signal.addEventListener(</span><span class="s2">\n        \&quot;</span><span class="s1">abort</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        </span><span class="s1">abortPendingFetchRevalidations</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let { loaderResults, fetcherResults } = await callLoadersAndMaybeResolveData(</span><span class="s2">\n      </span><span class="s1">dsMatches,</span><span class="s2">\n      </span><span class="s1">revalidatingFetchers,</span><span class="s2">\n      </span><span class="s1">request,</span><span class="s2">\n      </span><span class="s1">scopedContext</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">if (request.signal.aborted) {</span><span class="s2">\n      </span><span class="s1">return { shortCircuited: true };</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (pendingNavigationController) {</span><span class="s2">\n      </span><span class="s1">pendingNavigationController.signal.removeEventListener(</span><span class="s2">\n        \&quot;</span><span class="s1">abort</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        </span><span class="s1">abortPendingFetchRevalidations</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">revalidatingFetchers.forEach((rf) =&gt; fetchControllers.delete(rf.key));</span><span class="s2">\n    </span><span class="s1">let redirect2 = findRedirect(loaderResults);</span><span class="s2">\n    </span><span class="s1">if (redirect2) {</span><span class="s2">\n      </span><span class="s1">await startRedirectNavigation(request, redirect2.result, true, {</span><span class="s2">\n        </span><span class="s1">replace: replace2</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">return { shortCircuited: true };</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">redirect2 = findRedirect(fetcherResults);</span><span class="s2">\n    </span><span class="s1">if (redirect2) {</span><span class="s2">\n      </span><span class="s1">fetchRedirectIds.add(redirect2.key);</span><span class="s2">\n      </span><span class="s1">await startRedirectNavigation(request, redirect2.result, true, {</span><span class="s2">\n        </span><span class="s1">replace: replace2</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">return { shortCircuited: true };</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let { loaderData, errors } = processLoaderData(</span><span class="s2">\n      </span><span class="s1">state,</span><span class="s2">\n      </span><span class="s1">matches,</span><span class="s2">\n      </span><span class="s1">loaderResults,</span><span class="s2">\n      </span><span class="s1">pendingActionResult,</span><span class="s2">\n      </span><span class="s1">revalidatingFetchers,</span><span class="s2">\n      </span><span class="s1">fetcherResults</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">if (initialHydration &amp;&amp; state.errors) {</span><span class="s2">\n      </span><span class="s1">errors = { ...state.errors, ...errors };</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let updatedFetchers = markFetchRedirectsDone();</span><span class="s2">\n    </span><span class="s1">let didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId);</span><span class="s2">\n    </span><span class="s1">let shouldUpdateFetchers = updatedFetchers || didAbortFetchLoads || revalidatingFetchers.length &gt; 0;</span><span class="s2">\n    </span><span class="s1">return {</span><span class="s2">\n      </span><span class="s1">matches,</span><span class="s2">\n      </span><span class="s1">loaderData,</span><span class="s2">\n      </span><span class="s1">errors,</span><span class="s2">\n      </span><span class="s1">...shouldUpdateFetchers ? { fetchers: new Map(state.fetchers) } : {}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function getUpdatedActionData(pendingActionResult) {</span><span class="s2">\n    </span><span class="s1">if (pendingActionResult &amp;&amp; !isErrorResult(pendingActionResult[1])) {</span><span class="s2">\n      </span><span class="s1">return {</span><span class="s2">\n        </span><span class="s1">[pendingActionResult[0]]: pendingActionResult[1].data</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">} else if (state.actionData) {</span><span class="s2">\n      </span><span class="s1">if (Object.keys(state.actionData).length === 0) {</span><span class="s2">\n        </span><span class="s1">return null;</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">return state.actionData;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function getUpdatedRevalidatingFetchers(revalidatingFetchers) {</span><span class="s2">\n    </span><span class="s1">revalidatingFetchers.forEach((rf) =&gt; {</span><span class="s2">\n      </span><span class="s1">let fetcher = state.fetchers.get(rf.key);</span><span class="s2">\n      </span><span class="s1">let revalidatingFetcher = getLoadingFetcher(</span><span class="s2">\n        </span><span class="s1">void 0,</span><span class="s2">\n        </span><span class="s1">fetcher ? fetcher.data : void 0</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">state.fetchers.set(rf.key, revalidatingFetcher);</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">return new Map(state.fetchers);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">async function fetch2(key, routeId, href2, opts) {</span><span class="s2">\n    </span><span class="s1">abortFetcher(key);</span><span class="s2">\n    </span><span class="s1">let flushSync = (opts &amp;&amp; opts.flushSync) === true;</span><span class="s2">\n    </span><span class="s1">let routesToUse = inFlightDataRoutes || dataRoutes;</span><span class="s2">\n    </span><span class="s1">let normalizedPath = normalizeTo(</span><span class="s2">\n      </span><span class="s1">state.location,</span><span class="s2">\n      </span><span class="s1">state.matches,</span><span class="s2">\n      </span><span class="s1">basename,</span><span class="s2">\n      </span><span class="s1">href2,</span><span class="s2">\n      </span><span class="s1">routeId,</span><span class="s2">\n      </span><span class="s1">opts?.relative</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">let matches = matchRoutes(routesToUse, normalizedPath, basename);</span><span class="s2">\n    </span><span class="s1">let fogOfWar = checkFogOfWar(matches, routesToUse, normalizedPath);</span><span class="s2">\n    </span><span class="s1">if (fogOfWar.active &amp;&amp; fogOfWar.matches) {</span><span class="s2">\n      </span><span class="s1">matches = fogOfWar.matches;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (!matches) {</span><span class="s2">\n      </span><span class="s1">setFetcherError(</span><span class="s2">\n        </span><span class="s1">key,</span><span class="s2">\n        </span><span class="s1">routeId,</span><span class="s2">\n        </span><span class="s1">getInternalRouterError(404, { pathname: normalizedPath }),</span><span class="s2">\n        </span><span class="s1">{ flushSync }</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let { path, submission, error } = normalizeNavigateOptions(</span><span class="s2">\n      </span><span class="s1">true,</span><span class="s2">\n      </span><span class="s1">normalizedPath,</span><span class="s2">\n      </span><span class="s1">opts</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">if (error) {</span><span class="s2">\n      </span><span class="s1">setFetcherError(key, routeId, error, { flushSync });</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let match = getTargetMatch(matches, path);</span><span class="s2">\n    </span><span class="s1">let scopedContext = new unstable_RouterContextProvider(</span><span class="s2">\n      </span><span class="s1">init.unstable_getContext ? await init.unstable_getContext() : void 0</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">let preventScrollReset = (opts &amp;&amp; opts.preventScrollReset) === true;</span><span class="s2">\n    </span><span class="s1">if (submission &amp;&amp; isMutationMethod(submission.formMethod)) {</span><span class="s2">\n      </span><span class="s1">await handleFetcherAction(</span><span class="s2">\n        </span><span class="s1">key,</span><span class="s2">\n        </span><span class="s1">routeId,</span><span class="s2">\n        </span><span class="s1">path,</span><span class="s2">\n        </span><span class="s1">match,</span><span class="s2">\n        </span><span class="s1">matches,</span><span class="s2">\n        </span><span class="s1">scopedContext,</span><span class="s2">\n        </span><span class="s1">fogOfWar.active,</span><span class="s2">\n        </span><span class="s1">flushSync,</span><span class="s2">\n        </span><span class="s1">preventScrollReset,</span><span class="s2">\n        </span><span class="s1">submission</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">fetchLoadMatches.set(key, { routeId, path });</span><span class="s2">\n    </span><span class="s1">await handleFetcherLoader(</span><span class="s2">\n      </span><span class="s1">key,</span><span class="s2">\n      </span><span class="s1">routeId,</span><span class="s2">\n      </span><span class="s1">path,</span><span class="s2">\n      </span><span class="s1">match,</span><span class="s2">\n      </span><span class="s1">matches,</span><span class="s2">\n      </span><span class="s1">scopedContext,</span><span class="s2">\n      </span><span class="s1">fogOfWar.active,</span><span class="s2">\n      </span><span class="s1">flushSync,</span><span class="s2">\n      </span><span class="s1">preventScrollReset,</span><span class="s2">\n      </span><span class="s1">submission</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">async function handleFetcherAction(key, routeId, path, match, requestMatches, scopedContext, isFogOfWar, flushSync, preventScrollReset, submission) {</span><span class="s2">\n    </span><span class="s1">interruptActiveLoads();</span><span class="s2">\n    </span><span class="s1">fetchLoadMatches.delete(key);</span><span class="s2">\n    </span><span class="s1">function detectAndHandle405Error(m) {</span><span class="s2">\n      </span><span class="s1">if (!m.route.action &amp;&amp; !m.route.lazy) {</span><span class="s2">\n        </span><span class="s1">let error = getInternalRouterError(405, {</span><span class="s2">\n          </span><span class="s1">method: submission.formMethod,</span><span class="s2">\n          </span><span class="s1">pathname: path,</span><span class="s2">\n          </span><span class="s1">routeId</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">setFetcherError(key, routeId, error, { flushSync });</span><span class="s2">\n        </span><span class="s1">return true;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return false;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (!isFogOfWar &amp;&amp; detectAndHandle405Error(match)) {</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let existingFetcher = state.fetchers.get(key);</span><span class="s2">\n    </span><span class="s1">updateFetcherState(key, getSubmittingFetcher(submission, existingFetcher), {</span><span class="s2">\n      </span><span class="s1">flushSync</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">let abortController = new AbortController();</span><span class="s2">\n    </span><span class="s1">let fetchRequest = createClientSideRequest(</span><span class="s2">\n      </span><span class="s1">init.history,</span><span class="s2">\n      </span><span class="s1">path,</span><span class="s2">\n      </span><span class="s1">abortController.signal,</span><span class="s2">\n      </span><span class="s1">submission</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">if (isFogOfWar) {</span><span class="s2">\n      </span><span class="s1">let discoverResult = await discoverRoutes(</span><span class="s2">\n        </span><span class="s1">requestMatches,</span><span class="s2">\n        </span><span class="s1">path,</span><span class="s2">\n        </span><span class="s1">fetchRequest.signal,</span><span class="s2">\n        </span><span class="s1">key</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">if (discoverResult.type === </span><span class="s2">\&quot;</span><span class="s1">aborted</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">} else if (discoverResult.type === </span><span class="s2">\&quot;</span><span class="s1">error</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">setFetcherError(key, routeId, discoverResult.error, { flushSync });</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">} else if (!discoverResult.matches) {</span><span class="s2">\n        </span><span class="s1">setFetcherError(</span><span class="s2">\n          </span><span class="s1">key,</span><span class="s2">\n          </span><span class="s1">routeId,</span><span class="s2">\n          </span><span class="s1">getInternalRouterError(404, { pathname: path }),</span><span class="s2">\n          </span><span class="s1">{ flushSync }</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">requestMatches = discoverResult.matches;</span><span class="s2">\n        </span><span class="s1">match = getTargetMatch(requestMatches, path);</span><span class="s2">\n        </span><span class="s1">if (detectAndHandle405Error(match)) {</span><span class="s2">\n          </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">fetchControllers.set(key, abortController);</span><span class="s2">\n    </span><span class="s1">let originatingLoadId = incrementingLoadId;</span><span class="s2">\n    </span><span class="s1">let fetchMatches = getTargetedDataStrategyMatches(</span><span class="s2">\n      </span><span class="s1">mapRouteProperties2,</span><span class="s2">\n      </span><span class="s1">manifest,</span><span class="s2">\n      </span><span class="s1">fetchRequest,</span><span class="s2">\n      </span><span class="s1">requestMatches,</span><span class="s2">\n      </span><span class="s1">match,</span><span class="s2">\n      </span><span class="s1">hydrationRouteProperties2,</span><span class="s2">\n      </span><span class="s1">scopedContext</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">let actionResults = await callDataStrategy(</span><span class="s2">\n      </span><span class="s1">fetchRequest,</span><span class="s2">\n      </span><span class="s1">fetchMatches,</span><span class="s2">\n      </span><span class="s1">scopedContext,</span><span class="s2">\n      </span><span class="s1">key</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">let actionResult = actionResults[match.route.id];</span><span class="s2">\n    </span><span class="s1">if (fetchRequest.signal.aborted) {</span><span class="s2">\n      </span><span class="s1">if (fetchControllers.get(key) === abortController) {</span><span class="s2">\n        </span><span class="s1">fetchControllers.delete(key);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (fetchersQueuedForDeletion.has(key)) {</span><span class="s2">\n      </span><span class="s1">if (isRedirectResult(actionResult) || isErrorResult(actionResult)) {</span><span class="s2">\n        </span><span class="s1">updateFetcherState(key, getDoneFetcher(void 0));</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">if (isRedirectResult(actionResult)) {</span><span class="s2">\n        </span><span class="s1">fetchControllers.delete(key);</span><span class="s2">\n        </span><span class="s1">if (pendingNavigationLoadId &gt; originatingLoadId) {</span><span class="s2">\n          </span><span class="s1">updateFetcherState(key, getDoneFetcher(void 0));</span><span class="s2">\n          </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">fetchRedirectIds.add(key);</span><span class="s2">\n          </span><span class="s1">updateFetcherState(key, getLoadingFetcher(submission));</span><span class="s2">\n          </span><span class="s1">return startRedirectNavigation(fetchRequest, actionResult, false, {</span><span class="s2">\n            </span><span class="s1">fetcherSubmission: submission,</span><span class="s2">\n            </span><span class="s1">preventScrollReset</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (isErrorResult(actionResult)) {</span><span class="s2">\n        </span><span class="s1">setFetcherError(key, routeId, actionResult.error);</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let nextLocation = state.navigation.location || state.location;</span><span class="s2">\n    </span><span class="s1">let revalidationRequest = createClientSideRequest(</span><span class="s2">\n      </span><span class="s1">init.history,</span><span class="s2">\n      </span><span class="s1">nextLocation,</span><span class="s2">\n      </span><span class="s1">abortController.signal</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">let routesToUse = inFlightDataRoutes || dataRoutes;</span><span class="s2">\n    </span><span class="s1">let matches = state.navigation.state !== </span><span class="s2">\&quot;</span><span class="s1">idle</span><span class="s2">\&quot; </span><span class="s1">? matchRoutes(routesToUse, state.navigation.location, basename) : state.matches;</span><span class="s2">\n    </span><span class="s1">invariant(matches, </span><span class="s2">\&quot;</span><span class="s1">Didn't find any matches after fetcher action</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">let loadId = ++incrementingLoadId;</span><span class="s2">\n    </span><span class="s1">fetchReloadIds.set(key, loadId);</span><span class="s2">\n    </span><span class="s1">let loadFetcher = getLoadingFetcher(submission, actionResult.data);</span><span class="s2">\n    </span><span class="s1">state.fetchers.set(key, loadFetcher);</span><span class="s2">\n    </span><span class="s1">let { dsMatches, revalidatingFetchers } = getMatchesToLoad(</span><span class="s2">\n      </span><span class="s1">revalidationRequest,</span><span class="s2">\n      </span><span class="s1">scopedContext,</span><span class="s2">\n      </span><span class="s1">mapRouteProperties2,</span><span class="s2">\n      </span><span class="s1">manifest,</span><span class="s2">\n      </span><span class="s1">init.history,</span><span class="s2">\n      </span><span class="s1">state,</span><span class="s2">\n      </span><span class="s1">matches,</span><span class="s2">\n      </span><span class="s1">submission,</span><span class="s2">\n      </span><span class="s1">nextLocation,</span><span class="s2">\n      </span><span class="s1">hydrationRouteProperties2,</span><span class="s2">\n      </span><span class="s1">false,</span><span class="s2">\n      </span><span class="s1">isRevalidationRequired,</span><span class="s2">\n      </span><span class="s1">cancelledFetcherLoads,</span><span class="s2">\n      </span><span class="s1">fetchersQueuedForDeletion,</span><span class="s2">\n      </span><span class="s1">fetchLoadMatches,</span><span class="s2">\n      </span><span class="s1">fetchRedirectIds,</span><span class="s2">\n      </span><span class="s1">routesToUse,</span><span class="s2">\n      </span><span class="s1">basename,</span><span class="s2">\n      </span><span class="s1">[match.route.id, actionResult]</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">revalidatingFetchers.filter((rf) =&gt; rf.key !== key).forEach((rf) =&gt; {</span><span class="s2">\n      </span><span class="s1">let staleKey = rf.key;</span><span class="s2">\n      </span><span class="s1">let existingFetcher2 = state.fetchers.get(staleKey);</span><span class="s2">\n      </span><span class="s1">let revalidatingFetcher = getLoadingFetcher(</span><span class="s2">\n        </span><span class="s1">void 0,</span><span class="s2">\n        </span><span class="s1">existingFetcher2 ? existingFetcher2.data : void 0</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">state.fetchers.set(staleKey, revalidatingFetcher);</span><span class="s2">\n      </span><span class="s1">abortFetcher(staleKey);</span><span class="s2">\n      </span><span class="s1">if (rf.controller) {</span><span class="s2">\n        </span><span class="s1">fetchControllers.set(staleKey, rf.controller);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">updateState({ fetchers: new Map(state.fetchers) });</span><span class="s2">\n    </span><span class="s1">let abortPendingFetchRevalidations = () =&gt; revalidatingFetchers.forEach((rf) =&gt; abortFetcher(rf.key));</span><span class="s2">\n    </span><span class="s1">abortController.signal.addEventListener(</span><span class="s2">\n      \&quot;</span><span class="s1">abort</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">abortPendingFetchRevalidations</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">let { loaderResults, fetcherResults } = await callLoadersAndMaybeResolveData(</span><span class="s2">\n      </span><span class="s1">dsMatches,</span><span class="s2">\n      </span><span class="s1">revalidatingFetchers,</span><span class="s2">\n      </span><span class="s1">revalidationRequest,</span><span class="s2">\n      </span><span class="s1">scopedContext</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">if (abortController.signal.aborted) {</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">abortController.signal.removeEventListener(</span><span class="s2">\n      \&quot;</span><span class="s1">abort</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">abortPendingFetchRevalidations</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">fetchReloadIds.delete(key);</span><span class="s2">\n    </span><span class="s1">fetchControllers.delete(key);</span><span class="s2">\n    </span><span class="s1">revalidatingFetchers.forEach((r) =&gt; fetchControllers.delete(r.key));</span><span class="s2">\n    </span><span class="s1">if (state.fetchers.has(key)) {</span><span class="s2">\n      </span><span class="s1">let doneFetcher = getDoneFetcher(actionResult.data);</span><span class="s2">\n      </span><span class="s1">state.fetchers.set(key, doneFetcher);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let redirect2 = findRedirect(loaderResults);</span><span class="s2">\n    </span><span class="s1">if (redirect2) {</span><span class="s2">\n      </span><span class="s1">return startRedirectNavigation(</span><span class="s2">\n        </span><span class="s1">revalidationRequest,</span><span class="s2">\n        </span><span class="s1">redirect2.result,</span><span class="s2">\n        </span><span class="s1">false,</span><span class="s2">\n        </span><span class="s1">{ preventScrollReset }</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">redirect2 = findRedirect(fetcherResults);</span><span class="s2">\n    </span><span class="s1">if (redirect2) {</span><span class="s2">\n      </span><span class="s1">fetchRedirectIds.add(redirect2.key);</span><span class="s2">\n      </span><span class="s1">return startRedirectNavigation(</span><span class="s2">\n        </span><span class="s1">revalidationRequest,</span><span class="s2">\n        </span><span class="s1">redirect2.result,</span><span class="s2">\n        </span><span class="s1">false,</span><span class="s2">\n        </span><span class="s1">{ preventScrollReset }</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let { loaderData, errors } = processLoaderData(</span><span class="s2">\n      </span><span class="s1">state,</span><span class="s2">\n      </span><span class="s1">matches,</span><span class="s2">\n      </span><span class="s1">loaderResults,</span><span class="s2">\n      </span><span class="s1">void 0,</span><span class="s2">\n      </span><span class="s1">revalidatingFetchers,</span><span class="s2">\n      </span><span class="s1">fetcherResults</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">abortStaleFetchLoads(loadId);</span><span class="s2">\n    </span><span class="s1">if (state.navigation.state === </span><span class="s2">\&quot;</span><span class="s1">loading</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; loadId &gt; pendingNavigationLoadId) {</span><span class="s2">\n      </span><span class="s1">invariant(pendingAction, </span><span class="s2">\&quot;</span><span class="s1">Expected pending action</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">pendingNavigationController &amp;&amp; pendingNavigationController.abort();</span><span class="s2">\n      </span><span class="s1">completeNavigation(state.navigation.location, {</span><span class="s2">\n        </span><span class="s1">matches,</span><span class="s2">\n        </span><span class="s1">loaderData,</span><span class="s2">\n        </span><span class="s1">errors,</span><span class="s2">\n        </span><span class="s1">fetchers: new Map(state.fetchers)</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">updateState({</span><span class="s2">\n        </span><span class="s1">errors,</span><span class="s2">\n        </span><span class="s1">loaderData: mergeLoaderData(</span><span class="s2">\n          </span><span class="s1">state.loaderData,</span><span class="s2">\n          </span><span class="s1">loaderData,</span><span class="s2">\n          </span><span class="s1">matches,</span><span class="s2">\n          </span><span class="s1">errors</span><span class="s2">\n        </span><span class="s1">),</span><span class="s2">\n        </span><span class="s1">fetchers: new Map(state.fetchers)</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">isRevalidationRequired = false;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">async function handleFetcherLoader(key, routeId, path, match, matches, scopedContext, isFogOfWar, flushSync, preventScrollReset, submission) {</span><span class="s2">\n    </span><span class="s1">let existingFetcher = state.fetchers.get(key);</span><span class="s2">\n    </span><span class="s1">updateFetcherState(</span><span class="s2">\n      </span><span class="s1">key,</span><span class="s2">\n      </span><span class="s1">getLoadingFetcher(</span><span class="s2">\n        </span><span class="s1">submission,</span><span class="s2">\n        </span><span class="s1">existingFetcher ? existingFetcher.data : void 0</span><span class="s2">\n      </span><span class="s1">),</span><span class="s2">\n      </span><span class="s1">{ flushSync }</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">let abortController = new AbortController();</span><span class="s2">\n    </span><span class="s1">let fetchRequest = createClientSideRequest(</span><span class="s2">\n      </span><span class="s1">init.history,</span><span class="s2">\n      </span><span class="s1">path,</span><span class="s2">\n      </span><span class="s1">abortController.signal</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">if (isFogOfWar) {</span><span class="s2">\n      </span><span class="s1">let discoverResult = await discoverRoutes(</span><span class="s2">\n        </span><span class="s1">matches,</span><span class="s2">\n        </span><span class="s1">path,</span><span class="s2">\n        </span><span class="s1">fetchRequest.signal,</span><span class="s2">\n        </span><span class="s1">key</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">if (discoverResult.type === </span><span class="s2">\&quot;</span><span class="s1">aborted</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">} else if (discoverResult.type === </span><span class="s2">\&quot;</span><span class="s1">error</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">setFetcherError(key, routeId, discoverResult.error, { flushSync });</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">} else if (!discoverResult.matches) {</span><span class="s2">\n        </span><span class="s1">setFetcherError(</span><span class="s2">\n          </span><span class="s1">key,</span><span class="s2">\n          </span><span class="s1">routeId,</span><span class="s2">\n          </span><span class="s1">getInternalRouterError(404, { pathname: path }),</span><span class="s2">\n          </span><span class="s1">{ flushSync }</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">matches = discoverResult.matches;</span><span class="s2">\n        </span><span class="s1">match = getTargetMatch(matches, path);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">fetchControllers.set(key, abortController);</span><span class="s2">\n    </span><span class="s1">let originatingLoadId = incrementingLoadId;</span><span class="s2">\n    </span><span class="s1">let dsMatches = getTargetedDataStrategyMatches(</span><span class="s2">\n      </span><span class="s1">mapRouteProperties2,</span><span class="s2">\n      </span><span class="s1">manifest,</span><span class="s2">\n      </span><span class="s1">fetchRequest,</span><span class="s2">\n      </span><span class="s1">matches,</span><span class="s2">\n      </span><span class="s1">match,</span><span class="s2">\n      </span><span class="s1">hydrationRouteProperties2,</span><span class="s2">\n      </span><span class="s1">scopedContext</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">let results = await callDataStrategy(</span><span class="s2">\n      </span><span class="s1">fetchRequest,</span><span class="s2">\n      </span><span class="s1">dsMatches,</span><span class="s2">\n      </span><span class="s1">scopedContext,</span><span class="s2">\n      </span><span class="s1">key</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">let result = results[match.route.id];</span><span class="s2">\n    </span><span class="s1">if (fetchControllers.get(key) === abortController) {</span><span class="s2">\n      </span><span class="s1">fetchControllers.delete(key);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (fetchRequest.signal.aborted) {</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (fetchersQueuedForDeletion.has(key)) {</span><span class="s2">\n      </span><span class="s1">updateFetcherState(key, getDoneFetcher(void 0));</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (isRedirectResult(result)) {</span><span class="s2">\n      </span><span class="s1">if (pendingNavigationLoadId &gt; originatingLoadId) {</span><span class="s2">\n        </span><span class="s1">updateFetcherState(key, getDoneFetcher(void 0));</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">fetchRedirectIds.add(key);</span><span class="s2">\n        </span><span class="s1">await startRedirectNavigation(fetchRequest, result, false, {</span><span class="s2">\n          </span><span class="s1">preventScrollReset</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (isErrorResult(result)) {</span><span class="s2">\n      </span><span class="s1">setFetcherError(key, routeId, result.error);</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">updateFetcherState(key, getDoneFetcher(result.data));</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">async function startRedirectNavigation(request, redirect2, isNavigation, {</span><span class="s2">\n    </span><span class="s1">submission,</span><span class="s2">\n    </span><span class="s1">fetcherSubmission,</span><span class="s2">\n    </span><span class="s1">preventScrollReset,</span><span class="s2">\n    </span><span class="s1">replace: replace2</span><span class="s2">\n  </span><span class="s1">} = {}) {</span><span class="s2">\n    </span><span class="s1">if (redirect2.response.headers.has(</span><span class="s2">\&quot;</span><span class="s1">X-Remix-Revalidate</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n      </span><span class="s1">isRevalidationRequired = true;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let location = redirect2.response.headers.get(</span><span class="s2">\&quot;</span><span class="s1">Location</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">invariant(location, </span><span class="s2">\&quot;</span><span class="s1">Expected a Location header on the redirect Response</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">location = normalizeRedirectLocation(</span><span class="s2">\n      </span><span class="s1">location,</span><span class="s2">\n      </span><span class="s1">new URL(request.url),</span><span class="s2">\n      </span><span class="s1">basename</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">let redirectLocation = createLocation(state.location, location, {</span><span class="s2">\n      </span><span class="s1">_isRedirect: true</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">if (isBrowser2) {</span><span class="s2">\n      </span><span class="s1">let isDocumentReload = false;</span><span class="s2">\n      </span><span class="s1">if (redirect2.response.headers.has(</span><span class="s2">\&quot;</span><span class="s1">X-Remix-Reload-Document</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n        </span><span class="s1">isDocumentReload = true;</span><span class="s2">\n      </span><span class="s1">} else if (ABSOLUTE_URL_REGEX.test(location)) {</span><span class="s2">\n        </span><span class="s1">const url = createBrowserURLImpl(location, true);</span><span class="s2">\n        </span><span class="s1">isDocumentReload = // Hard reload if it's an absolute URL to a new origin</span><span class="s2">\n        </span><span class="s1">url.origin !== routerWindow.location.origin || // Hard reload if it's an absolute URL that does not match our basename</span><span class="s2">\n        </span><span class="s1">stripBasename(url.pathname, basename) == null;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (isDocumentReload) {</span><span class="s2">\n        </span><span class="s1">if (replace2) {</span><span class="s2">\n          </span><span class="s1">routerWindow.location.replace(location);</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">routerWindow.location.assign(location);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">pendingNavigationController = null;</span><span class="s2">\n    </span><span class="s1">let redirectNavigationType = replace2 === true || redirect2.response.headers.has(</span><span class="s2">\&quot;</span><span class="s1">X-Remix-Replace</span><span class="s2">\&quot;</span><span class="s1">) ? </span><span class="s2">\&quot;</span><span class="s1">REPLACE</span><span class="s2">\&quot; </span><span class="s1">/* Replace */ : </span><span class="s2">\&quot;</span><span class="s1">PUSH</span><span class="s2">\&quot; </span><span class="s1">/* Push */;</span><span class="s2">\n    </span><span class="s1">let { formMethod, formAction, formEncType } = state.navigation;</span><span class="s2">\n    </span><span class="s1">if (!submission &amp;&amp; !fetcherSubmission &amp;&amp; formMethod &amp;&amp; formAction &amp;&amp; formEncType) {</span><span class="s2">\n      </span><span class="s1">submission = getSubmissionFromNavigation(state.navigation);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let activeSubmission = submission || fetcherSubmission;</span><span class="s2">\n    </span><span class="s1">if (redirectPreserveMethodStatusCodes.has(redirect2.response.status) &amp;&amp; activeSubmission &amp;&amp; isMutationMethod(activeSubmission.formMethod)) {</span><span class="s2">\n      </span><span class="s1">await startNavigation(redirectNavigationType, redirectLocation, {</span><span class="s2">\n        </span><span class="s1">submission: {</span><span class="s2">\n          </span><span class="s1">...activeSubmission,</span><span class="s2">\n          </span><span class="s1">formAction: location</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">// Preserve these flags across redirects</span><span class="s2">\n        </span><span class="s1">preventScrollReset: preventScrollReset || pendingPreventScrollReset,</span><span class="s2">\n        </span><span class="s1">enableViewTransition: isNavigation ? pendingViewTransitionEnabled : void 0</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">let overrideNavigation = getLoadingNavigation(</span><span class="s2">\n        </span><span class="s1">redirectLocation,</span><span class="s2">\n        </span><span class="s1">submission</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">await startNavigation(redirectNavigationType, redirectLocation, {</span><span class="s2">\n        </span><span class="s1">overrideNavigation,</span><span class="s2">\n        </span><span class="s1">// Send fetcher submissions through for shouldRevalidate</span><span class="s2">\n        </span><span class="s1">fetcherSubmission,</span><span class="s2">\n        </span><span class="s1">// Preserve these flags across redirects</span><span class="s2">\n        </span><span class="s1">preventScrollReset: preventScrollReset || pendingPreventScrollReset,</span><span class="s2">\n        </span><span class="s1">enableViewTransition: isNavigation ? pendingViewTransitionEnabled : void 0</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">async function callDataStrategy(request, matches, scopedContext, fetcherKey) {</span><span class="s2">\n    </span><span class="s1">let results;</span><span class="s2">\n    </span><span class="s1">let dataResults = {};</span><span class="s2">\n    </span><span class="s1">try {</span><span class="s2">\n      </span><span class="s1">results = await callDataStrategyImpl(</span><span class="s2">\n        </span><span class="s1">dataStrategyImpl,</span><span class="s2">\n        </span><span class="s1">request,</span><span class="s2">\n        </span><span class="s1">matches,</span><span class="s2">\n        </span><span class="s1">fetcherKey,</span><span class="s2">\n        </span><span class="s1">scopedContext,</span><span class="s2">\n        </span><span class="s1">false</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">} catch (e) {</span><span class="s2">\n      </span><span class="s1">matches.filter((m) =&gt; m.shouldLoad).forEach((m) =&gt; {</span><span class="s2">\n        </span><span class="s1">dataResults[m.route.id] = {</span><span class="s2">\n          </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">error</span><span class="s2">\&quot; </span><span class="s1">/* error */,</span><span class="s2">\n          </span><span class="s1">error: e</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">return dataResults;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (request.signal.aborted) {</span><span class="s2">\n      </span><span class="s1">return dataResults;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">for (let [routeId, result] of Object.entries(results)) {</span><span class="s2">\n      </span><span class="s1">if (isRedirectDataStrategyResult(result)) {</span><span class="s2">\n        </span><span class="s1">let response = result.result;</span><span class="s2">\n        </span><span class="s1">dataResults[routeId] = {</span><span class="s2">\n          </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">redirect</span><span class="s2">\&quot; </span><span class="s1">/* redirect */,</span><span class="s2">\n          </span><span class="s1">response: normalizeRelativeRoutingRedirectResponse(</span><span class="s2">\n            </span><span class="s1">response,</span><span class="s2">\n            </span><span class="s1">request,</span><span class="s2">\n            </span><span class="s1">routeId,</span><span class="s2">\n            </span><span class="s1">matches,</span><span class="s2">\n            </span><span class="s1">basename</span><span class="s2">\n          </span><span class="s1">)</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">dataResults[routeId] = await convertDataStrategyResultToDataResult(</span><span class="s2">\n          </span><span class="s1">result</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return dataResults;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">async function callLoadersAndMaybeResolveData(matches, fetchersToLoad, request, scopedContext) {</span><span class="s2">\n    </span><span class="s1">let loaderResultsPromise = callDataStrategy(</span><span class="s2">\n      </span><span class="s1">request,</span><span class="s2">\n      </span><span class="s1">matches,</span><span class="s2">\n      </span><span class="s1">scopedContext,</span><span class="s2">\n      </span><span class="s1">null</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">let fetcherResultsPromise = Promise.all(</span><span class="s2">\n      </span><span class="s1">fetchersToLoad.map(async (f) =&gt; {</span><span class="s2">\n        </span><span class="s1">if (f.matches &amp;&amp; f.match &amp;&amp; f.request &amp;&amp; f.controller) {</span><span class="s2">\n          </span><span class="s1">let results = await callDataStrategy(</span><span class="s2">\n            </span><span class="s1">f.request,</span><span class="s2">\n            </span><span class="s1">f.matches,</span><span class="s2">\n            </span><span class="s1">scopedContext,</span><span class="s2">\n            </span><span class="s1">f.key</span><span class="s2">\n          </span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">let result = results[f.match.route.id];</span><span class="s2">\n          </span><span class="s1">return { [f.key]: result };</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">return Promise.resolve({</span><span class="s2">\n            </span><span class="s1">[f.key]: {</span><span class="s2">\n              </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">error</span><span class="s2">\&quot; </span><span class="s1">/* error */,</span><span class="s2">\n              </span><span class="s1">error: getInternalRouterError(404, {</span><span class="s2">\n                </span><span class="s1">pathname: f.path</span><span class="s2">\n              </span><span class="s1">})</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">})</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">let loaderResults = await loaderResultsPromise;</span><span class="s2">\n    </span><span class="s1">let fetcherResults = (await fetcherResultsPromise).reduce(</span><span class="s2">\n      </span><span class="s1">(acc, r) =&gt; Object.assign(acc, r),</span><span class="s2">\n      </span><span class="s1">{}</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">return {</span><span class="s2">\n      </span><span class="s1">loaderResults,</span><span class="s2">\n      </span><span class="s1">fetcherResults</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function interruptActiveLoads() {</span><span class="s2">\n    </span><span class="s1">isRevalidationRequired = true;</span><span class="s2">\n    </span><span class="s1">fetchLoadMatches.forEach((_, key) =&gt; {</span><span class="s2">\n      </span><span class="s1">if (fetchControllers.has(key)) {</span><span class="s2">\n        </span><span class="s1">cancelledFetcherLoads.add(key);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">abortFetcher(key);</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function updateFetcherState(key, fetcher, opts = {}) {</span><span class="s2">\n    </span><span class="s1">state.fetchers.set(key, fetcher);</span><span class="s2">\n    </span><span class="s1">updateState(</span><span class="s2">\n      </span><span class="s1">{ fetchers: new Map(state.fetchers) },</span><span class="s2">\n      </span><span class="s1">{ flushSync: (opts &amp;&amp; opts.flushSync) === true }</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function setFetcherError(key, routeId, error, opts = {}) {</span><span class="s2">\n    </span><span class="s1">let boundaryMatch = findNearestBoundary(state.matches, routeId);</span><span class="s2">\n    </span><span class="s1">deleteFetcher(key);</span><span class="s2">\n    </span><span class="s1">updateState(</span><span class="s2">\n      </span><span class="s1">{</span><span class="s2">\n        </span><span class="s1">errors: {</span><span class="s2">\n          </span><span class="s1">[boundaryMatch.route.id]: error</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">fetchers: new Map(state.fetchers)</span><span class="s2">\n      </span><span class="s1">},</span><span class="s2">\n      </span><span class="s1">{ flushSync: (opts &amp;&amp; opts.flushSync) === true }</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function getFetcher(key) {</span><span class="s2">\n    </span><span class="s1">activeFetchers.set(key, (activeFetchers.get(key) || 0) + 1);</span><span class="s2">\n    </span><span class="s1">if (fetchersQueuedForDeletion.has(key)) {</span><span class="s2">\n      </span><span class="s1">fetchersQueuedForDeletion.delete(key);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return state.fetchers.get(key) || IDLE_FETCHER;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function deleteFetcher(key) {</span><span class="s2">\n    </span><span class="s1">let fetcher = state.fetchers.get(key);</span><span class="s2">\n    </span><span class="s1">if (fetchControllers.has(key) &amp;&amp; !(fetcher &amp;&amp; fetcher.state === </span><span class="s2">\&quot;</span><span class="s1">loading</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; fetchReloadIds.has(key))) {</span><span class="s2">\n      </span><span class="s1">abortFetcher(key);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">fetchLoadMatches.delete(key);</span><span class="s2">\n    </span><span class="s1">fetchReloadIds.delete(key);</span><span class="s2">\n    </span><span class="s1">fetchRedirectIds.delete(key);</span><span class="s2">\n    </span><span class="s1">fetchersQueuedForDeletion.delete(key);</span><span class="s2">\n    </span><span class="s1">cancelledFetcherLoads.delete(key);</span><span class="s2">\n    </span><span class="s1">state.fetchers.delete(key);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function queueFetcherForDeletion(key) {</span><span class="s2">\n    </span><span class="s1">let count = (activeFetchers.get(key) || 0) - 1;</span><span class="s2">\n    </span><span class="s1">if (count &lt;= 0) {</span><span class="s2">\n      </span><span class="s1">activeFetchers.delete(key);</span><span class="s2">\n      </span><span class="s1">fetchersQueuedForDeletion.add(key);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">activeFetchers.set(key, count);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">updateState({ fetchers: new Map(state.fetchers) });</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function abortFetcher(key) {</span><span class="s2">\n    </span><span class="s1">let controller = fetchControllers.get(key);</span><span class="s2">\n    </span><span class="s1">if (controller) {</span><span class="s2">\n      </span><span class="s1">controller.abort();</span><span class="s2">\n      </span><span class="s1">fetchControllers.delete(key);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function markFetchersDone(keys) {</span><span class="s2">\n    </span><span class="s1">for (let key of keys) {</span><span class="s2">\n      </span><span class="s1">let fetcher = getFetcher(key);</span><span class="s2">\n      </span><span class="s1">let doneFetcher = getDoneFetcher(fetcher.data);</span><span class="s2">\n      </span><span class="s1">state.fetchers.set(key, doneFetcher);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function markFetchRedirectsDone() {</span><span class="s2">\n    </span><span class="s1">let doneKeys = [];</span><span class="s2">\n    </span><span class="s1">let updatedFetchers = false;</span><span class="s2">\n    </span><span class="s1">for (let key of fetchRedirectIds) {</span><span class="s2">\n      </span><span class="s1">let fetcher = state.fetchers.get(key);</span><span class="s2">\n      </span><span class="s1">invariant(fetcher, `Expected fetcher: ${key}`);</span><span class="s2">\n      </span><span class="s1">if (fetcher.state === </span><span class="s2">\&quot;</span><span class="s1">loading</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">fetchRedirectIds.delete(key);</span><span class="s2">\n        </span><span class="s1">doneKeys.push(key);</span><span class="s2">\n        </span><span class="s1">updatedFetchers = true;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">markFetchersDone(doneKeys);</span><span class="s2">\n    </span><span class="s1">return updatedFetchers;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function abortStaleFetchLoads(landedId) {</span><span class="s2">\n    </span><span class="s1">let yeetedKeys = [];</span><span class="s2">\n    </span><span class="s1">for (let [key, id] of fetchReloadIds) {</span><span class="s2">\n      </span><span class="s1">if (id &lt; landedId) {</span><span class="s2">\n        </span><span class="s1">let fetcher = state.fetchers.get(key);</span><span class="s2">\n        </span><span class="s1">invariant(fetcher, `Expected fetcher: ${key}`);</span><span class="s2">\n        </span><span class="s1">if (fetcher.state === </span><span class="s2">\&quot;</span><span class="s1">loading</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">abortFetcher(key);</span><span class="s2">\n          </span><span class="s1">fetchReloadIds.delete(key);</span><span class="s2">\n          </span><span class="s1">yeetedKeys.push(key);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">markFetchersDone(yeetedKeys);</span><span class="s2">\n    </span><span class="s1">return yeetedKeys.length &gt; 0;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function getBlocker(key, fn) {</span><span class="s2">\n    </span><span class="s1">let blocker = state.blockers.get(key) || IDLE_BLOCKER;</span><span class="s2">\n    </span><span class="s1">if (blockerFunctions.get(key) !== fn) {</span><span class="s2">\n      </span><span class="s1">blockerFunctions.set(key, fn);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return blocker;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function deleteBlocker(key) {</span><span class="s2">\n    </span><span class="s1">state.blockers.delete(key);</span><span class="s2">\n    </span><span class="s1">blockerFunctions.delete(key);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function updateBlocker(key, newBlocker) {</span><span class="s2">\n    </span><span class="s1">let blocker = state.blockers.get(key) || IDLE_BLOCKER;</span><span class="s2">\n    </span><span class="s1">invariant(</span><span class="s2">\n      </span><span class="s1">blocker.state === </span><span class="s2">\&quot;</span><span class="s1">unblocked</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; newBlocker.state === </span><span class="s2">\&quot;</span><span class="s1">blocked</span><span class="s2">\&quot; </span><span class="s1">|| blocker.state === </span><span class="s2">\&quot;</span><span class="s1">blocked</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; newBlocker.state === </span><span class="s2">\&quot;</span><span class="s1">blocked</span><span class="s2">\&quot; </span><span class="s1">|| blocker.state === </span><span class="s2">\&quot;</span><span class="s1">blocked</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; newBlocker.state === </span><span class="s2">\&quot;</span><span class="s1">proceeding</span><span class="s2">\&quot; </span><span class="s1">|| blocker.state === </span><span class="s2">\&quot;</span><span class="s1">blocked</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; newBlocker.state === </span><span class="s2">\&quot;</span><span class="s1">unblocked</span><span class="s2">\&quot; </span><span class="s1">|| blocker.state === </span><span class="s2">\&quot;</span><span class="s1">proceeding</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; newBlocker.state === </span><span class="s2">\&quot;</span><span class="s1">unblocked</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">`Invalid blocker state transition: ${blocker.state} -&gt; ${newBlocker.state}`</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">let blockers = new Map(state.blockers);</span><span class="s2">\n    </span><span class="s1">blockers.set(key, newBlocker);</span><span class="s2">\n    </span><span class="s1">updateState({ blockers });</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function shouldBlockNavigation({</span><span class="s2">\n    </span><span class="s1">currentLocation,</span><span class="s2">\n    </span><span class="s1">nextLocation,</span><span class="s2">\n    </span><span class="s1">historyAction</span><span class="s2">\n  </span><span class="s1">}) {</span><span class="s2">\n    </span><span class="s1">if (blockerFunctions.size === 0) {</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (blockerFunctions.size &gt; 1) {</span><span class="s2">\n      </span><span class="s1">warning(false, </span><span class="s2">\&quot;</span><span class="s1">A router only supports one blocker at a time</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let entries = Array.from(blockerFunctions.entries());</span><span class="s2">\n    </span><span class="s1">let [blockerKey, blockerFunction] = entries[entries.length - 1];</span><span class="s2">\n    </span><span class="s1">let blocker = state.blockers.get(blockerKey);</span><span class="s2">\n    </span><span class="s1">if (blocker &amp;&amp; blocker.state === </span><span class="s2">\&quot;</span><span class="s1">proceeding</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (blockerFunction({ currentLocation, nextLocation, historyAction })) {</span><span class="s2">\n      </span><span class="s1">return blockerKey;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function handleNavigational404(pathname) {</span><span class="s2">\n    </span><span class="s1">let error = getInternalRouterError(404, { pathname });</span><span class="s2">\n    </span><span class="s1">let routesToUse = inFlightDataRoutes || dataRoutes;</span><span class="s2">\n    </span><span class="s1">let { matches, route } = getShortCircuitMatches(routesToUse);</span><span class="s2">\n    </span><span class="s1">return { notFoundMatches: matches, route, error };</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function enableScrollRestoration(positions, getPosition, getKey) {</span><span class="s2">\n    </span><span class="s1">savedScrollPositions2 = positions;</span><span class="s2">\n    </span><span class="s1">getScrollPosition = getPosition;</span><span class="s2">\n    </span><span class="s1">getScrollRestorationKey2 = getKey || null;</span><span class="s2">\n    </span><span class="s1">if (!initialScrollRestored &amp;&amp; state.navigation === IDLE_NAVIGATION) {</span><span class="s2">\n      </span><span class="s1">initialScrollRestored = true;</span><span class="s2">\n      </span><span class="s1">let y = getSavedScrollPosition(state.location, state.matches);</span><span class="s2">\n      </span><span class="s1">if (y != null) {</span><span class="s2">\n        </span><span class="s1">updateState({ restoreScrollPosition: y });</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return () =&gt; {</span><span class="s2">\n      </span><span class="s1">savedScrollPositions2 = null;</span><span class="s2">\n      </span><span class="s1">getScrollPosition = null;</span><span class="s2">\n      </span><span class="s1">getScrollRestorationKey2 = null;</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function getScrollKey(location, matches) {</span><span class="s2">\n    </span><span class="s1">if (getScrollRestorationKey2) {</span><span class="s2">\n      </span><span class="s1">let key = getScrollRestorationKey2(</span><span class="s2">\n        </span><span class="s1">location,</span><span class="s2">\n        </span><span class="s1">matches.map((m) =&gt; convertRouteMatchToUiMatch(m, state.loaderData))</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">return key || location.key;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return location.key;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function saveScrollPosition(location, matches) {</span><span class="s2">\n    </span><span class="s1">if (savedScrollPositions2 &amp;&amp; getScrollPosition) {</span><span class="s2">\n      </span><span class="s1">let key = getScrollKey(location, matches);</span><span class="s2">\n      </span><span class="s1">savedScrollPositions2[key] = getScrollPosition();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function getSavedScrollPosition(location, matches) {</span><span class="s2">\n    </span><span class="s1">if (savedScrollPositions2) {</span><span class="s2">\n      </span><span class="s1">let key = getScrollKey(location, matches);</span><span class="s2">\n      </span><span class="s1">let y = savedScrollPositions2[key];</span><span class="s2">\n      </span><span class="s1">if (typeof y === </span><span class="s2">\&quot;</span><span class="s1">number</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">return y;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return null;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function checkFogOfWar(matches, routesToUse, pathname) {</span><span class="s2">\n    </span><span class="s1">if (init.patchRoutesOnNavigation) {</span><span class="s2">\n      </span><span class="s1">if (!matches) {</span><span class="s2">\n        </span><span class="s1">let fogMatches = matchRoutesImpl(</span><span class="s2">\n          </span><span class="s1">routesToUse,</span><span class="s2">\n          </span><span class="s1">pathname,</span><span class="s2">\n          </span><span class="s1">basename,</span><span class="s2">\n          </span><span class="s1">true</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">return { active: true, matches: fogMatches || [] };</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">if (Object.keys(matches[0].params).length &gt; 0) {</span><span class="s2">\n          </span><span class="s1">let partialMatches = matchRoutesImpl(</span><span class="s2">\n            </span><span class="s1">routesToUse,</span><span class="s2">\n            </span><span class="s1">pathname,</span><span class="s2">\n            </span><span class="s1">basename,</span><span class="s2">\n            </span><span class="s1">true</span><span class="s2">\n          </span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">return { active: true, matches: partialMatches };</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return { active: false, matches: null };</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">async function discoverRoutes(matches, pathname, signal, fetcherKey) {</span><span class="s2">\n    </span><span class="s1">if (!init.patchRoutesOnNavigation) {</span><span class="s2">\n      </span><span class="s1">return { type: </span><span class="s2">\&quot;</span><span class="s1">success</span><span class="s2">\&quot;</span><span class="s1">, matches };</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let partialMatches = matches;</span><span class="s2">\n    </span><span class="s1">while (true) {</span><span class="s2">\n      </span><span class="s1">let isNonHMR = inFlightDataRoutes == null;</span><span class="s2">\n      </span><span class="s1">let routesToUse = inFlightDataRoutes || dataRoutes;</span><span class="s2">\n      </span><span class="s1">let localManifest = manifest;</span><span class="s2">\n      </span><span class="s1">try {</span><span class="s2">\n        </span><span class="s1">await init.patchRoutesOnNavigation({</span><span class="s2">\n          </span><span class="s1">signal,</span><span class="s2">\n          </span><span class="s1">path: pathname,</span><span class="s2">\n          </span><span class="s1">matches: partialMatches,</span><span class="s2">\n          </span><span class="s1">fetcherKey,</span><span class="s2">\n          </span><span class="s1">patch: (routeId, children) =&gt; {</span><span class="s2">\n            </span><span class="s1">if (signal.aborted) return;</span><span class="s2">\n            </span><span class="s1">patchRoutesImpl(</span><span class="s2">\n              </span><span class="s1">routeId,</span><span class="s2">\n              </span><span class="s1">children,</span><span class="s2">\n              </span><span class="s1">routesToUse,</span><span class="s2">\n              </span><span class="s1">localManifest,</span><span class="s2">\n              </span><span class="s1">mapRouteProperties2</span><span class="s2">\n            </span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">} catch (e) {</span><span class="s2">\n        </span><span class="s1">return { type: </span><span class="s2">\&quot;</span><span class="s1">error</span><span class="s2">\&quot;</span><span class="s1">, error: e, partialMatches };</span><span class="s2">\n      </span><span class="s1">} finally {</span><span class="s2">\n        </span><span class="s1">if (isNonHMR &amp;&amp; !signal.aborted) {</span><span class="s2">\n          </span><span class="s1">dataRoutes = [...dataRoutes];</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (signal.aborted) {</span><span class="s2">\n        </span><span class="s1">return { type: </span><span class="s2">\&quot;</span><span class="s1">aborted</span><span class="s2">\&quot; </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">let newMatches = matchRoutes(routesToUse, pathname, basename);</span><span class="s2">\n      </span><span class="s1">if (newMatches) {</span><span class="s2">\n        </span><span class="s1">return { type: </span><span class="s2">\&quot;</span><span class="s1">success</span><span class="s2">\&quot;</span><span class="s1">, matches: newMatches };</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">let newPartialMatches = matchRoutesImpl(</span><span class="s2">\n        </span><span class="s1">routesToUse,</span><span class="s2">\n        </span><span class="s1">pathname,</span><span class="s2">\n        </span><span class="s1">basename,</span><span class="s2">\n        </span><span class="s1">true</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">if (!newPartialMatches || partialMatches.length === newPartialMatches.length &amp;&amp; partialMatches.every(</span><span class="s2">\n        </span><span class="s1">(m, i) =&gt; m.route.id === newPartialMatches[i].route.id</span><span class="s2">\n      </span><span class="s1">)) {</span><span class="s2">\n        </span><span class="s1">return { type: </span><span class="s2">\&quot;</span><span class="s1">success</span><span class="s2">\&quot;</span><span class="s1">, matches: null };</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">partialMatches = newPartialMatches;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function _internalSetRoutes(newRoutes) {</span><span class="s2">\n    </span><span class="s1">manifest = {};</span><span class="s2">\n    </span><span class="s1">inFlightDataRoutes = convertRoutesToDataRoutes(</span><span class="s2">\n      </span><span class="s1">newRoutes,</span><span class="s2">\n      </span><span class="s1">mapRouteProperties2,</span><span class="s2">\n      </span><span class="s1">void 0,</span><span class="s2">\n      </span><span class="s1">manifest</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">function patchRoutes(routeId, children) {</span><span class="s2">\n    </span><span class="s1">let isNonHMR = inFlightDataRoutes == null;</span><span class="s2">\n    </span><span class="s1">let routesToUse = inFlightDataRoutes || dataRoutes;</span><span class="s2">\n    </span><span class="s1">patchRoutesImpl(</span><span class="s2">\n      </span><span class="s1">routeId,</span><span class="s2">\n      </span><span class="s1">children,</span><span class="s2">\n      </span><span class="s1">routesToUse,</span><span class="s2">\n      </span><span class="s1">manifest,</span><span class="s2">\n      </span><span class="s1">mapRouteProperties2</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">if (isNonHMR) {</span><span class="s2">\n      </span><span class="s1">dataRoutes = [...dataRoutes];</span><span class="s2">\n      </span><span class="s1">updateState({});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">router = {</span><span class="s2">\n    </span><span class="s1">get basename() {</span><span class="s2">\n      </span><span class="s1">return basename;</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">get future() {</span><span class="s2">\n      </span><span class="s1">return future;</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">get state() {</span><span class="s2">\n      </span><span class="s1">return state;</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">get routes() {</span><span class="s2">\n      </span><span class="s1">return dataRoutes;</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">get window() {</span><span class="s2">\n      </span><span class="s1">return routerWindow;</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">initialize,</span><span class="s2">\n    </span><span class="s1">subscribe,</span><span class="s2">\n    </span><span class="s1">enableScrollRestoration,</span><span class="s2">\n    </span><span class="s1">navigate,</span><span class="s2">\n    </span><span class="s1">fetch: fetch2,</span><span class="s2">\n    </span><span class="s1">revalidate,</span><span class="s2">\n    </span><span class="s1">// Passthrough to history-aware createHref used by useHref so we get proper</span><span class="s2">\n    </span><span class="s1">// hash-aware URLs in DOM paths</span><span class="s2">\n    </span><span class="s1">createHref: (to) =&gt; init.history.createHref(to),</span><span class="s2">\n    </span><span class="s1">encodeLocation: (to) =&gt; init.history.encodeLocation(to),</span><span class="s2">\n    </span><span class="s1">getFetcher,</span><span class="s2">\n    </span><span class="s1">deleteFetcher: queueFetcherForDeletion,</span><span class="s2">\n    </span><span class="s1">dispose,</span><span class="s2">\n    </span><span class="s1">getBlocker,</span><span class="s2">\n    </span><span class="s1">deleteBlocker,</span><span class="s2">\n    </span><span class="s1">patchRoutes,</span><span class="s2">\n    </span><span class="s1">_internalFetchControllers: fetchControllers,</span><span class="s2">\n    </span><span class="s1">// TODO: Remove setRoutes, it's temporary to avoid dealing with</span><span class="s2">\n    </span><span class="s1">// updating the tree while validating the update algorithm.</span><span class="s2">\n    </span><span class="s1">_internalSetRoutes</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">return router;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createStaticHandler(routes, opts) {</span><span class="s2">\n  </span><span class="s1">invariant(</span><span class="s2">\n    </span><span class="s1">routes.length &gt; 0,</span><span class="s2">\n    \&quot;</span><span class="s1">You must provide a non-empty routes array to createStaticHandler</span><span class="s2">\&quot;\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let manifest = {};</span><span class="s2">\n  </span><span class="s1">let basename = (opts ? opts.basename : null) || </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">let mapRouteProperties2 = opts?.mapRouteProperties || defaultMapRouteProperties;</span><span class="s2">\n  </span><span class="s1">let dataRoutes = convertRoutesToDataRoutes(</span><span class="s2">\n    </span><span class="s1">routes,</span><span class="s2">\n    </span><span class="s1">mapRouteProperties2,</span><span class="s2">\n    </span><span class="s1">void 0,</span><span class="s2">\n    </span><span class="s1">manifest</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">async function query(request, {</span><span class="s2">\n    </span><span class="s1">requestContext,</span><span class="s2">\n    </span><span class="s1">filterMatchesToLoad,</span><span class="s2">\n    </span><span class="s1">skipLoaderErrorBubbling,</span><span class="s2">\n    </span><span class="s1">skipRevalidation,</span><span class="s2">\n    </span><span class="s1">dataStrategy,</span><span class="s2">\n    </span><span class="s1">unstable_respond: respond</span><span class="s2">\n  </span><span class="s1">} = {}) {</span><span class="s2">\n    </span><span class="s1">let url = new URL(request.url);</span><span class="s2">\n    </span><span class="s1">let method = request.method;</span><span class="s2">\n    </span><span class="s1">let location = createLocation(</span><span class="s2">\&quot;\&quot;</span><span class="s1">, createPath(url), null, </span><span class="s2">\&quot;</span><span class="s1">default</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">let matches = matchRoutes(dataRoutes, location, basename);</span><span class="s2">\n    </span><span class="s1">requestContext = requestContext != null ? requestContext : new unstable_RouterContextProvider();</span><span class="s2">\n    </span><span class="s1">if (!isValidMethod(method) &amp;&amp; method !== </span><span class="s2">\&quot;</span><span class="s1">HEAD</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">let error = getInternalRouterError(405, { method });</span><span class="s2">\n      </span><span class="s1">let { matches: methodNotAllowedMatches, route } = getShortCircuitMatches(dataRoutes);</span><span class="s2">\n      </span><span class="s1">let staticContext = {</span><span class="s2">\n        </span><span class="s1">basename,</span><span class="s2">\n        </span><span class="s1">location,</span><span class="s2">\n        </span><span class="s1">matches: methodNotAllowedMatches,</span><span class="s2">\n        </span><span class="s1">loaderData: {},</span><span class="s2">\n        </span><span class="s1">actionData: null,</span><span class="s2">\n        </span><span class="s1">errors: {</span><span class="s2">\n          </span><span class="s1">[route.id]: error</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">statusCode: error.status,</span><span class="s2">\n        </span><span class="s1">loaderHeaders: {},</span><span class="s2">\n        </span><span class="s1">actionHeaders: {}</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">return respond ? respond(staticContext) : staticContext;</span><span class="s2">\n    </span><span class="s1">} else if (!matches) {</span><span class="s2">\n      </span><span class="s1">let error = getInternalRouterError(404, { pathname: location.pathname });</span><span class="s2">\n      </span><span class="s1">let { matches: notFoundMatches, route } = getShortCircuitMatches(dataRoutes);</span><span class="s2">\n      </span><span class="s1">let staticContext = {</span><span class="s2">\n        </span><span class="s1">basename,</span><span class="s2">\n        </span><span class="s1">location,</span><span class="s2">\n        </span><span class="s1">matches: notFoundMatches,</span><span class="s2">\n        </span><span class="s1">loaderData: {},</span><span class="s2">\n        </span><span class="s1">actionData: null,</span><span class="s2">\n        </span><span class="s1">errors: {</span><span class="s2">\n          </span><span class="s1">[route.id]: error</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">statusCode: error.status,</span><span class="s2">\n        </span><span class="s1">loaderHeaders: {},</span><span class="s2">\n        </span><span class="s1">actionHeaders: {}</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">return respond ? respond(staticContext) : staticContext;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (respond &amp;&amp; matches.some(</span><span class="s2">\n      </span><span class="s1">(m) =&gt; m.route.unstable_middleware || typeof m.route.lazy === </span><span class="s2">\&quot;</span><span class="s1">object</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; m.route.lazy.unstable_middleware</span><span class="s2">\n    </span><span class="s1">)) {</span><span class="s2">\n      </span><span class="s1">invariant(</span><span class="s2">\n        </span><span class="s1">requestContext instanceof unstable_RouterContextProvider,</span><span class="s2">\n        \&quot;</span><span class="s1">When using middleware in `staticHandler.query()`, any provided `requestContext` must be an instance of `unstable_RouterContextProvider`</span><span class="s2">\&quot;\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">try {</span><span class="s2">\n        </span><span class="s1">await loadLazyMiddlewareForMatches(</span><span class="s2">\n          </span><span class="s1">matches,</span><span class="s2">\n          </span><span class="s1">manifest,</span><span class="s2">\n          </span><span class="s1">mapRouteProperties2</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">let renderedStaticContext;</span><span class="s2">\n        </span><span class="s1">let response = await runMiddlewarePipeline(</span><span class="s2">\n          </span><span class="s1">{</span><span class="s2">\n            </span><span class="s1">request,</span><span class="s2">\n            </span><span class="s1">matches,</span><span class="s2">\n            </span><span class="s1">params: matches[0].params,</span><span class="s2">\n            </span><span class="s1">// If we're calling middleware then it must be enabled so we can cast</span><span class="s2">\n            </span><span class="s1">// this to the proper type knowing it's not an `AppLoadContext`</span><span class="s2">\n            </span><span class="s1">context: requestContext</span><span class="s2">\n          </span><span class="s1">},</span><span class="s2">\n          </span><span class="s1">true,</span><span class="s2">\n          </span><span class="s1">async () =&gt; {</span><span class="s2">\n            </span><span class="s1">let result2 = await queryImpl(</span><span class="s2">\n              </span><span class="s1">request,</span><span class="s2">\n              </span><span class="s1">location,</span><span class="s2">\n              </span><span class="s1">matches,</span><span class="s2">\n              </span><span class="s1">requestContext,</span><span class="s2">\n              </span><span class="s1">dataStrategy || null,</span><span class="s2">\n              </span><span class="s1">skipLoaderErrorBubbling === true,</span><span class="s2">\n              </span><span class="s1">null,</span><span class="s2">\n              </span><span class="s1">filterMatchesToLoad || null,</span><span class="s2">\n              </span><span class="s1">skipRevalidation === true</span><span class="s2">\n            </span><span class="s1">);</span><span class="s2">\n            </span><span class="s1">if (isResponse(result2)) {</span><span class="s2">\n              </span><span class="s1">return result2;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">renderedStaticContext = { location, basename, ...result2 };</span><span class="s2">\n            </span><span class="s1">let res = await respond(renderedStaticContext);</span><span class="s2">\n            </span><span class="s1">return res;</span><span class="s2">\n          </span><span class="s1">},</span><span class="s2">\n          </span><span class="s1">async (error, routeId) =&gt; {</span><span class="s2">\n            </span><span class="s1">if (isResponse(error)) {</span><span class="s2">\n              </span><span class="s1">return error;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">if (renderedStaticContext) {</span><span class="s2">\n              </span><span class="s1">if (routeId in renderedStaticContext.loaderData) {</span><span class="s2">\n                </span><span class="s1">renderedStaticContext.loaderData[routeId] = void 0;</span><span class="s2">\n              </span><span class="s1">}</span><span class="s2">\n              </span><span class="s1">return respond(</span><span class="s2">\n                </span><span class="s1">getStaticContextFromError(</span><span class="s2">\n                  </span><span class="s1">dataRoutes,</span><span class="s2">\n                  </span><span class="s1">renderedStaticContext,</span><span class="s2">\n                  </span><span class="s1">error,</span><span class="s2">\n                  </span><span class="s1">skipLoaderErrorBubbling ? routeId : findNearestBoundary(matches, routeId).route.id</span><span class="s2">\n                </span><span class="s1">)</span><span class="s2">\n              </span><span class="s1">);</span><span class="s2">\n            </span><span class="s1">} else {</span><span class="s2">\n              </span><span class="s1">let boundaryRouteId = skipLoaderErrorBubbling ? routeId : findNearestBoundary(</span><span class="s2">\n                </span><span class="s1">matches,</span><span class="s2">\n                </span><span class="s1">matches.find(</span><span class="s2">\n                  </span><span class="s1">(m) =&gt; m.route.id === routeId || m.route.loader</span><span class="s2">\n                </span><span class="s1">)?.route.id || routeId</span><span class="s2">\n              </span><span class="s1">).route.id;</span><span class="s2">\n              </span><span class="s1">return respond({</span><span class="s2">\n                </span><span class="s1">matches,</span><span class="s2">\n                </span><span class="s1">location,</span><span class="s2">\n                </span><span class="s1">basename,</span><span class="s2">\n                </span><span class="s1">loaderData: {},</span><span class="s2">\n                </span><span class="s1">actionData: null,</span><span class="s2">\n                </span><span class="s1">errors: {</span><span class="s2">\n                  </span><span class="s1">[boundaryRouteId]: error</span><span class="s2">\n                </span><span class="s1">},</span><span class="s2">\n                </span><span class="s1">statusCode: isRouteErrorResponse(error) ? error.status : 500,</span><span class="s2">\n                </span><span class="s1">actionHeaders: {},</span><span class="s2">\n                </span><span class="s1">loaderHeaders: {}</span><span class="s2">\n              </span><span class="s1">});</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">invariant(isResponse(response), </span><span class="s2">\&quot;</span><span class="s1">Expected a response in query()</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">return response;</span><span class="s2">\n      </span><span class="s1">} catch (e) {</span><span class="s2">\n        </span><span class="s1">if (isResponse(e)) {</span><span class="s2">\n          </span><span class="s1">return e;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">throw e;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let result = await queryImpl(</span><span class="s2">\n      </span><span class="s1">request,</span><span class="s2">\n      </span><span class="s1">location,</span><span class="s2">\n      </span><span class="s1">matches,</span><span class="s2">\n      </span><span class="s1">requestContext,</span><span class="s2">\n      </span><span class="s1">dataStrategy || null,</span><span class="s2">\n      </span><span class="s1">skipLoaderErrorBubbling === true,</span><span class="s2">\n      </span><span class="s1">null,</span><span class="s2">\n      </span><span class="s1">filterMatchesToLoad || null,</span><span class="s2">\n      </span><span class="s1">skipRevalidation === true</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">if (isResponse(result)) {</span><span class="s2">\n      </span><span class="s1">return result;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return { location, basename, ...result };</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">async function queryRoute(request, {</span><span class="s2">\n    </span><span class="s1">routeId,</span><span class="s2">\n    </span><span class="s1">requestContext,</span><span class="s2">\n    </span><span class="s1">dataStrategy,</span><span class="s2">\n    </span><span class="s1">unstable_respond: respond</span><span class="s2">\n  </span><span class="s1">} = {}) {</span><span class="s2">\n    </span><span class="s1">let url = new URL(request.url);</span><span class="s2">\n    </span><span class="s1">let method = request.method;</span><span class="s2">\n    </span><span class="s1">let location = createLocation(</span><span class="s2">\&quot;\&quot;</span><span class="s1">, createPath(url), null, </span><span class="s2">\&quot;</span><span class="s1">default</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">let matches = matchRoutes(dataRoutes, location, basename);</span><span class="s2">\n    </span><span class="s1">requestContext = requestContext != null ? requestContext : new unstable_RouterContextProvider();</span><span class="s2">\n    </span><span class="s1">if (!isValidMethod(method) &amp;&amp; method !== </span><span class="s2">\&quot;</span><span class="s1">HEAD</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; method !== </span><span class="s2">\&quot;</span><span class="s1">OPTIONS</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">throw getInternalRouterError(405, { method });</span><span class="s2">\n    </span><span class="s1">} else if (!matches) {</span><span class="s2">\n      </span><span class="s1">throw getInternalRouterError(404, { pathname: location.pathname });</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let match = routeId ? matches.find((m) =&gt; m.route.id === routeId) : getTargetMatch(matches, location);</span><span class="s2">\n    </span><span class="s1">if (routeId &amp;&amp; !match) {</span><span class="s2">\n      </span><span class="s1">throw getInternalRouterError(403, {</span><span class="s2">\n        </span><span class="s1">pathname: location.pathname,</span><span class="s2">\n        </span><span class="s1">routeId</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">} else if (!match) {</span><span class="s2">\n      </span><span class="s1">throw getInternalRouterError(404, { pathname: location.pathname });</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (respond &amp;&amp; matches.some(</span><span class="s2">\n      </span><span class="s1">(m) =&gt; m.route.unstable_middleware || typeof m.route.lazy === </span><span class="s2">\&quot;</span><span class="s1">object</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; m.route.lazy.unstable_middleware</span><span class="s2">\n    </span><span class="s1">)) {</span><span class="s2">\n      </span><span class="s1">invariant(</span><span class="s2">\n        </span><span class="s1">requestContext instanceof unstable_RouterContextProvider,</span><span class="s2">\n        \&quot;</span><span class="s1">When using middleware in `staticHandler.queryRoute()`, any provided `requestContext` must be an instance of `unstable_RouterContextProvider`</span><span class="s2">\&quot;\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">await loadLazyMiddlewareForMatches(matches, manifest, mapRouteProperties2);</span><span class="s2">\n      </span><span class="s1">let response = await runMiddlewarePipeline(</span><span class="s2">\n        </span><span class="s1">{</span><span class="s2">\n          </span><span class="s1">request,</span><span class="s2">\n          </span><span class="s1">matches,</span><span class="s2">\n          </span><span class="s1">params: matches[0].params,</span><span class="s2">\n          </span><span class="s1">// If we're calling middleware then it must be enabled so we can cast</span><span class="s2">\n          </span><span class="s1">// this to the proper type knowing it's not an `AppLoadContext`</span><span class="s2">\n          </span><span class="s1">context: requestContext</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">true,</span><span class="s2">\n        </span><span class="s1">async () =&gt; {</span><span class="s2">\n          </span><span class="s1">let result2 = await queryImpl(</span><span class="s2">\n            </span><span class="s1">request,</span><span class="s2">\n            </span><span class="s1">location,</span><span class="s2">\n            </span><span class="s1">matches,</span><span class="s2">\n            </span><span class="s1">requestContext,</span><span class="s2">\n            </span><span class="s1">dataStrategy || null,</span><span class="s2">\n            </span><span class="s1">false,</span><span class="s2">\n            </span><span class="s1">match,</span><span class="s2">\n            </span><span class="s1">null,</span><span class="s2">\n            </span><span class="s1">false</span><span class="s2">\n          </span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">if (isResponse(result2)) {</span><span class="s2">\n            </span><span class="s1">return respond(result2);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">let error2 = result2.errors ? Object.values(result2.errors)[0] : void 0;</span><span class="s2">\n          </span><span class="s1">if (error2 !== void 0) {</span><span class="s2">\n            </span><span class="s1">throw error2;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">let value = result2.actionData ? Object.values(result2.actionData)[0] : Object.values(result2.loaderData)[0];</span><span class="s2">\n          </span><span class="s1">return typeof value === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">? new Response(value) : Response.json(value);</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">(error2) =&gt; {</span><span class="s2">\n          </span><span class="s1">if (isResponse(error2)) {</span><span class="s2">\n            </span><span class="s1">return respond(error2);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">return new Response(String(error2), {</span><span class="s2">\n            </span><span class="s1">status: 500,</span><span class="s2">\n            </span><span class="s1">statusText: </span><span class="s2">\&quot;</span><span class="s1">Unexpected Server Error</span><span class="s2">\&quot;\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">return response;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let result = await queryImpl(</span><span class="s2">\n      </span><span class="s1">request,</span><span class="s2">\n      </span><span class="s1">location,</span><span class="s2">\n      </span><span class="s1">matches,</span><span class="s2">\n      </span><span class="s1">requestContext,</span><span class="s2">\n      </span><span class="s1">dataStrategy || null,</span><span class="s2">\n      </span><span class="s1">false,</span><span class="s2">\n      </span><span class="s1">match,</span><span class="s2">\n      </span><span class="s1">null,</span><span class="s2">\n      </span><span class="s1">false</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">if (isResponse(result)) {</span><span class="s2">\n      </span><span class="s1">return result;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let error = result.errors ? Object.values(result.errors)[0] : void 0;</span><span class="s2">\n    </span><span class="s1">if (error !== void 0) {</span><span class="s2">\n      </span><span class="s1">throw error;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (result.actionData) {</span><span class="s2">\n      </span><span class="s1">return Object.values(result.actionData)[0];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (result.loaderData) {</span><span class="s2">\n      </span><span class="s1">return Object.values(result.loaderData)[0];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return void 0;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">async function queryImpl(request, location, matches, requestContext, dataStrategy, skipLoaderErrorBubbling, routeMatch, filterMatchesToLoad, skipRevalidation) {</span><span class="s2">\n    </span><span class="s1">invariant(</span><span class="s2">\n      </span><span class="s1">request.signal,</span><span class="s2">\n      \&quot;</span><span class="s1">query()/queryRoute() requests must contain an AbortController signal</span><span class="s2">\&quot;\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">try {</span><span class="s2">\n      </span><span class="s1">if (isMutationMethod(request.method)) {</span><span class="s2">\n        </span><span class="s1">let result2 = await submit(</span><span class="s2">\n          </span><span class="s1">request,</span><span class="s2">\n          </span><span class="s1">matches,</span><span class="s2">\n          </span><span class="s1">routeMatch || getTargetMatch(matches, location),</span><span class="s2">\n          </span><span class="s1">requestContext,</span><span class="s2">\n          </span><span class="s1">dataStrategy,</span><span class="s2">\n          </span><span class="s1">skipLoaderErrorBubbling,</span><span class="s2">\n          </span><span class="s1">routeMatch != null,</span><span class="s2">\n          </span><span class="s1">filterMatchesToLoad,</span><span class="s2">\n          </span><span class="s1">skipRevalidation</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">return result2;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">let result = await loadRouteData(</span><span class="s2">\n        </span><span class="s1">request,</span><span class="s2">\n        </span><span class="s1">matches,</span><span class="s2">\n        </span><span class="s1">requestContext,</span><span class="s2">\n        </span><span class="s1">dataStrategy,</span><span class="s2">\n        </span><span class="s1">skipLoaderErrorBubbling,</span><span class="s2">\n        </span><span class="s1">routeMatch,</span><span class="s2">\n        </span><span class="s1">filterMatchesToLoad</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">return isResponse(result) ? result : {</span><span class="s2">\n        </span><span class="s1">...result,</span><span class="s2">\n        </span><span class="s1">actionData: null,</span><span class="s2">\n        </span><span class="s1">actionHeaders: {}</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">} catch (e) {</span><span class="s2">\n      </span><span class="s1">if (isDataStrategyResult(e) &amp;&amp; isResponse(e.result)) {</span><span class="s2">\n        </span><span class="s1">if (e.type === </span><span class="s2">\&quot;</span><span class="s1">error</span><span class="s2">\&quot; </span><span class="s1">/* error */) {</span><span class="s2">\n          </span><span class="s1">throw e.result;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return e.result;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (isRedirectResponse(e)) {</span><span class="s2">\n        </span><span class="s1">return e;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">throw e;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">async function submit(request, matches, actionMatch, requestContext, dataStrategy, skipLoaderErrorBubbling, isRouteRequest, filterMatchesToLoad, skipRevalidation) {</span><span class="s2">\n    </span><span class="s1">let result;</span><span class="s2">\n    </span><span class="s1">if (!actionMatch.route.action &amp;&amp; !actionMatch.route.lazy) {</span><span class="s2">\n      </span><span class="s1">let error = getInternalRouterError(405, {</span><span class="s2">\n        </span><span class="s1">method: request.method,</span><span class="s2">\n        </span><span class="s1">pathname: new URL(request.url).pathname,</span><span class="s2">\n        </span><span class="s1">routeId: actionMatch.route.id</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">if (isRouteRequest) {</span><span class="s2">\n        </span><span class="s1">throw error;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">result = {</span><span class="s2">\n        </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">error</span><span class="s2">\&quot; </span><span class="s1">/* error */,</span><span class="s2">\n        </span><span class="s1">error</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">let dsMatches = getTargetedDataStrategyMatches(</span><span class="s2">\n        </span><span class="s1">mapRouteProperties2,</span><span class="s2">\n        </span><span class="s1">manifest,</span><span class="s2">\n        </span><span class="s1">request,</span><span class="s2">\n        </span><span class="s1">matches,</span><span class="s2">\n        </span><span class="s1">actionMatch,</span><span class="s2">\n        </span><span class="s1">[],</span><span class="s2">\n        </span><span class="s1">requestContext</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">let results = await callDataStrategy(</span><span class="s2">\n        </span><span class="s1">request,</span><span class="s2">\n        </span><span class="s1">dsMatches,</span><span class="s2">\n        </span><span class="s1">isRouteRequest,</span><span class="s2">\n        </span><span class="s1">requestContext,</span><span class="s2">\n        </span><span class="s1">dataStrategy</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">result = results[actionMatch.route.id];</span><span class="s2">\n      </span><span class="s1">if (request.signal.aborted) {</span><span class="s2">\n        </span><span class="s1">throwStaticHandlerAbortedError(request, isRouteRequest);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (isRedirectResult(result)) {</span><span class="s2">\n      </span><span class="s1">throw new Response(null, {</span><span class="s2">\n        </span><span class="s1">status: result.response.status,</span><span class="s2">\n        </span><span class="s1">headers: {</span><span class="s2">\n          </span><span class="s1">Location: result.response.headers.get(</span><span class="s2">\&quot;</span><span class="s1">Location</span><span class="s2">\&quot;</span><span class="s1">)</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (isRouteRequest) {</span><span class="s2">\n      </span><span class="s1">if (isErrorResult(result)) {</span><span class="s2">\n        </span><span class="s1">throw result.error;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return {</span><span class="s2">\n        </span><span class="s1">matches: [actionMatch],</span><span class="s2">\n        </span><span class="s1">loaderData: {},</span><span class="s2">\n        </span><span class="s1">actionData: { [actionMatch.route.id]: result.data },</span><span class="s2">\n        </span><span class="s1">errors: null,</span><span class="s2">\n        </span><span class="s1">// Note: statusCode + headers are unused here since queryRoute will</span><span class="s2">\n        </span><span class="s1">// return the raw Response or value</span><span class="s2">\n        </span><span class="s1">statusCode: 200,</span><span class="s2">\n        </span><span class="s1">loaderHeaders: {},</span><span class="s2">\n        </span><span class="s1">actionHeaders: {}</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (skipRevalidation) {</span><span class="s2">\n      </span><span class="s1">if (isErrorResult(result)) {</span><span class="s2">\n        </span><span class="s1">let boundaryMatch = skipLoaderErrorBubbling ? actionMatch : findNearestBoundary(matches, actionMatch.route.id);</span><span class="s2">\n        </span><span class="s1">return {</span><span class="s2">\n          </span><span class="s1">statusCode: isRouteErrorResponse(result.error) ? result.error.status : result.statusCode != null ? result.statusCode : 500,</span><span class="s2">\n          </span><span class="s1">actionData: null,</span><span class="s2">\n          </span><span class="s1">actionHeaders: {</span><span class="s2">\n            </span><span class="s1">...result.headers ? { [actionMatch.route.id]: result.headers } : {}</span><span class="s2">\n          </span><span class="s1">},</span><span class="s2">\n          </span><span class="s1">matches,</span><span class="s2">\n          </span><span class="s1">loaderData: {},</span><span class="s2">\n          </span><span class="s1">errors: {</span><span class="s2">\n            </span><span class="s1">[boundaryMatch.route.id]: result.error</span><span class="s2">\n          </span><span class="s1">},</span><span class="s2">\n          </span><span class="s1">loaderHeaders: {}</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">return {</span><span class="s2">\n          </span><span class="s1">actionData: {</span><span class="s2">\n            </span><span class="s1">[actionMatch.route.id]: result.data</span><span class="s2">\n          </span><span class="s1">},</span><span class="s2">\n          </span><span class="s1">actionHeaders: result.headers ? { [actionMatch.route.id]: result.headers } : {},</span><span class="s2">\n          </span><span class="s1">matches,</span><span class="s2">\n          </span><span class="s1">loaderData: {},</span><span class="s2">\n          </span><span class="s1">errors: null,</span><span class="s2">\n          </span><span class="s1">statusCode: result.statusCode || 200,</span><span class="s2">\n          </span><span class="s1">loaderHeaders: {}</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let loaderRequest = new Request(request.url, {</span><span class="s2">\n      </span><span class="s1">headers: request.headers,</span><span class="s2">\n      </span><span class="s1">redirect: request.redirect,</span><span class="s2">\n      </span><span class="s1">signal: request.signal</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">if (isErrorResult(result)) {</span><span class="s2">\n      </span><span class="s1">let boundaryMatch = skipLoaderErrorBubbling ? actionMatch : findNearestBoundary(matches, actionMatch.route.id);</span><span class="s2">\n      </span><span class="s1">let handlerContext2 = await loadRouteData(</span><span class="s2">\n        </span><span class="s1">loaderRequest,</span><span class="s2">\n        </span><span class="s1">matches,</span><span class="s2">\n        </span><span class="s1">requestContext,</span><span class="s2">\n        </span><span class="s1">dataStrategy,</span><span class="s2">\n        </span><span class="s1">skipLoaderErrorBubbling,</span><span class="s2">\n        </span><span class="s1">null,</span><span class="s2">\n        </span><span class="s1">filterMatchesToLoad,</span><span class="s2">\n        </span><span class="s1">[boundaryMatch.route.id, result]</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">return {</span><span class="s2">\n        </span><span class="s1">...handlerContext2,</span><span class="s2">\n        </span><span class="s1">statusCode: isRouteErrorResponse(result.error) ? result.error.status : result.statusCode != null ? result.statusCode : 500,</span><span class="s2">\n        </span><span class="s1">actionData: null,</span><span class="s2">\n        </span><span class="s1">actionHeaders: {</span><span class="s2">\n          </span><span class="s1">...result.headers ? { [actionMatch.route.id]: result.headers } : {}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let handlerContext = await loadRouteData(</span><span class="s2">\n      </span><span class="s1">loaderRequest,</span><span class="s2">\n      </span><span class="s1">matches,</span><span class="s2">\n      </span><span class="s1">requestContext,</span><span class="s2">\n      </span><span class="s1">dataStrategy,</span><span class="s2">\n      </span><span class="s1">skipLoaderErrorBubbling,</span><span class="s2">\n      </span><span class="s1">null,</span><span class="s2">\n      </span><span class="s1">filterMatchesToLoad</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">return {</span><span class="s2">\n      </span><span class="s1">...handlerContext,</span><span class="s2">\n      </span><span class="s1">actionData: {</span><span class="s2">\n        </span><span class="s1">[actionMatch.route.id]: result.data</span><span class="s2">\n      </span><span class="s1">},</span><span class="s2">\n      </span><span class="s1">// action status codes take precedence over loader status codes</span><span class="s2">\n      </span><span class="s1">...result.statusCode ? { statusCode: result.statusCode } : {},</span><span class="s2">\n      </span><span class="s1">actionHeaders: result.headers ? { [actionMatch.route.id]: result.headers } : {}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">async function loadRouteData(request, matches, requestContext, dataStrategy, skipLoaderErrorBubbling, routeMatch, filterMatchesToLoad, pendingActionResult) {</span><span class="s2">\n    </span><span class="s1">let isRouteRequest = routeMatch != null;</span><span class="s2">\n    </span><span class="s1">if (isRouteRequest &amp;&amp; !routeMatch?.route.loader &amp;&amp; !routeMatch?.route.lazy) {</span><span class="s2">\n      </span><span class="s1">throw getInternalRouterError(400, {</span><span class="s2">\n        </span><span class="s1">method: request.method,</span><span class="s2">\n        </span><span class="s1">pathname: new URL(request.url).pathname,</span><span class="s2">\n        </span><span class="s1">routeId: routeMatch?.route.id</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let dsMatches;</span><span class="s2">\n    </span><span class="s1">if (routeMatch) {</span><span class="s2">\n      </span><span class="s1">dsMatches = getTargetedDataStrategyMatches(</span><span class="s2">\n        </span><span class="s1">mapRouteProperties2,</span><span class="s2">\n        </span><span class="s1">manifest,</span><span class="s2">\n        </span><span class="s1">request,</span><span class="s2">\n        </span><span class="s1">matches,</span><span class="s2">\n        </span><span class="s1">routeMatch,</span><span class="s2">\n        </span><span class="s1">[],</span><span class="s2">\n        </span><span class="s1">requestContext</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">let maxIdx = pendingActionResult &amp;&amp; isErrorResult(pendingActionResult[1]) ? (</span><span class="s2">\n        </span><span class="s1">// Up to but not including the boundary</span><span class="s2">\n        </span><span class="s1">matches.findIndex((m) =&gt; m.route.id === pendingActionResult[0]) - 1</span><span class="s2">\n      </span><span class="s1">) : void 0;</span><span class="s2">\n      </span><span class="s1">dsMatches = matches.map((match, index) =&gt; {</span><span class="s2">\n        </span><span class="s1">if (maxIdx != null &amp;&amp; index &gt; maxIdx) {</span><span class="s2">\n          </span><span class="s1">return getDataStrategyMatch(</span><span class="s2">\n            </span><span class="s1">mapRouteProperties2,</span><span class="s2">\n            </span><span class="s1">manifest,</span><span class="s2">\n            </span><span class="s1">request,</span><span class="s2">\n            </span><span class="s1">match,</span><span class="s2">\n            </span><span class="s1">[],</span><span class="s2">\n            </span><span class="s1">requestContext,</span><span class="s2">\n            </span><span class="s1">false</span><span class="s2">\n          </span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return getDataStrategyMatch(</span><span class="s2">\n          </span><span class="s1">mapRouteProperties2,</span><span class="s2">\n          </span><span class="s1">manifest,</span><span class="s2">\n          </span><span class="s1">request,</span><span class="s2">\n          </span><span class="s1">match,</span><span class="s2">\n          </span><span class="s1">[],</span><span class="s2">\n          </span><span class="s1">requestContext,</span><span class="s2">\n          </span><span class="s1">(match.route.loader || match.route.lazy) != null &amp;&amp; (!filterMatchesToLoad || filterMatchesToLoad(match))</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (!dataStrategy &amp;&amp; !dsMatches.some((m) =&gt; m.shouldLoad)) {</span><span class="s2">\n      </span><span class="s1">return {</span><span class="s2">\n        </span><span class="s1">matches,</span><span class="s2">\n        </span><span class="s1">loaderData: {},</span><span class="s2">\n        </span><span class="s1">errors: pendingActionResult &amp;&amp; isErrorResult(pendingActionResult[1]) ? {</span><span class="s2">\n          </span><span class="s1">[pendingActionResult[0]]: pendingActionResult[1].error</span><span class="s2">\n        </span><span class="s1">} : null,</span><span class="s2">\n        </span><span class="s1">statusCode: 200,</span><span class="s2">\n        </span><span class="s1">loaderHeaders: {}</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let results = await callDataStrategy(</span><span class="s2">\n      </span><span class="s1">request,</span><span class="s2">\n      </span><span class="s1">dsMatches,</span><span class="s2">\n      </span><span class="s1">isRouteRequest,</span><span class="s2">\n      </span><span class="s1">requestContext,</span><span class="s2">\n      </span><span class="s1">dataStrategy</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">if (request.signal.aborted) {</span><span class="s2">\n      </span><span class="s1">throwStaticHandlerAbortedError(request, isRouteRequest);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let handlerContext = processRouteLoaderData(</span><span class="s2">\n      </span><span class="s1">matches,</span><span class="s2">\n      </span><span class="s1">results,</span><span class="s2">\n      </span><span class="s1">pendingActionResult,</span><span class="s2">\n      </span><span class="s1">true,</span><span class="s2">\n      </span><span class="s1">skipLoaderErrorBubbling</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">return {</span><span class="s2">\n      </span><span class="s1">...handlerContext,</span><span class="s2">\n      </span><span class="s1">matches</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">async function callDataStrategy(request, matches, isRouteRequest, requestContext, dataStrategy) {</span><span class="s2">\n    </span><span class="s1">let results = await callDataStrategyImpl(</span><span class="s2">\n      </span><span class="s1">dataStrategy || defaultDataStrategy,</span><span class="s2">\n      </span><span class="s1">request,</span><span class="s2">\n      </span><span class="s1">matches,</span><span class="s2">\n      </span><span class="s1">null,</span><span class="s2">\n      </span><span class="s1">requestContext,</span><span class="s2">\n      </span><span class="s1">true</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">let dataResults = {};</span><span class="s2">\n    </span><span class="s1">await Promise.all(</span><span class="s2">\n      </span><span class="s1">matches.map(async (match) =&gt; {</span><span class="s2">\n        </span><span class="s1">if (!(match.route.id in results)) {</span><span class="s2">\n          </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">let result = results[match.route.id];</span><span class="s2">\n        </span><span class="s1">if (isRedirectDataStrategyResult(result)) {</span><span class="s2">\n          </span><span class="s1">let response = result.result;</span><span class="s2">\n          </span><span class="s1">throw normalizeRelativeRoutingRedirectResponse(</span><span class="s2">\n            </span><span class="s1">response,</span><span class="s2">\n            </span><span class="s1">request,</span><span class="s2">\n            </span><span class="s1">match.route.id,</span><span class="s2">\n            </span><span class="s1">matches,</span><span class="s2">\n            </span><span class="s1">basename</span><span class="s2">\n          </span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (isResponse(result.result) &amp;&amp; isRouteRequest) {</span><span class="s2">\n          </span><span class="s1">throw result;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">dataResults[match.route.id] = await convertDataStrategyResultToDataResult(result);</span><span class="s2">\n      </span><span class="s1">})</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">return dataResults;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">dataRoutes,</span><span class="s2">\n    </span><span class="s1">query,</span><span class="s2">\n    </span><span class="s1">queryRoute</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getStaticContextFromError(routes, handlerContext, error, boundaryId) {</span><span class="s2">\n  </span><span class="s1">let errorBoundaryId = boundaryId || handlerContext._deepestRenderedBoundaryId || routes[0].id;</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">...handlerContext,</span><span class="s2">\n    </span><span class="s1">statusCode: isRouteErrorResponse(error) ? error.status : 500,</span><span class="s2">\n    </span><span class="s1">errors: {</span><span class="s2">\n      </span><span class="s1">[errorBoundaryId]: error</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function throwStaticHandlerAbortedError(request, isRouteRequest) {</span><span class="s2">\n  </span><span class="s1">if (request.signal.reason !== void 0) {</span><span class="s2">\n    </span><span class="s1">throw request.signal.reason;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let method = isRouteRequest ? </span><span class="s2">\&quot;</span><span class="s1">queryRoute</span><span class="s2">\&quot; </span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">query</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">throw new Error(</span><span class="s2">\n    </span><span class="s1">`${method}() call aborted without an </span><span class="s2">\\</span><span class="s1">`AbortSignal.reason</span><span class="s2">\\</span><span class="s1">`: ${request.method} ${request.url}`</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isSubmissionNavigation(opts) {</span><span class="s2">\n  </span><span class="s1">return opts != null &amp;&amp; (</span><span class="s2">\&quot;</span><span class="s1">formData</span><span class="s2">\&quot; </span><span class="s1">in opts &amp;&amp; opts.formData != null || </span><span class="s2">\&quot;</span><span class="s1">body</span><span class="s2">\&quot; </span><span class="s1">in opts &amp;&amp; opts.body !== void 0);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function normalizeTo(location, matches, basename, to, fromRouteId, relative) {</span><span class="s2">\n  </span><span class="s1">let contextualMatches;</span><span class="s2">\n  </span><span class="s1">let activeRouteMatch;</span><span class="s2">\n  </span><span class="s1">if (fromRouteId) {</span><span class="s2">\n    </span><span class="s1">contextualMatches = [];</span><span class="s2">\n    </span><span class="s1">for (let match of matches) {</span><span class="s2">\n      </span><span class="s1">contextualMatches.push(match);</span><span class="s2">\n      </span><span class="s1">if (match.route.id === fromRouteId) {</span><span class="s2">\n        </span><span class="s1">activeRouteMatch = match;</span><span class="s2">\n        </span><span class="s1">break;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">contextualMatches = matches;</span><span class="s2">\n    </span><span class="s1">activeRouteMatch = matches[matches.length - 1];</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let path = resolveTo(</span><span class="s2">\n    </span><span class="s1">to ? to : </span><span class="s2">\&quot;</span><span class="s1">.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">getResolveToMatches(contextualMatches),</span><span class="s2">\n    </span><span class="s1">stripBasename(location.pathname, basename) || location.pathname,</span><span class="s2">\n    </span><span class="s1">relative === </span><span class="s2">\&quot;</span><span class="s1">path</span><span class="s2">\&quot;\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">if (to == null) {</span><span class="s2">\n    </span><span class="s1">path.search = location.search;</span><span class="s2">\n    </span><span class="s1">path.hash = location.hash;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if ((to == null || to === </span><span class="s2">\&quot;\&quot; </span><span class="s1">|| to === </span><span class="s2">\&quot;</span><span class="s1">.</span><span class="s2">\&quot;</span><span class="s1">) &amp;&amp; activeRouteMatch) {</span><span class="s2">\n    </span><span class="s1">let nakedIndex = hasNakedIndexQuery(path.search);</span><span class="s2">\n    </span><span class="s1">if (activeRouteMatch.route.index &amp;&amp; !nakedIndex) {</span><span class="s2">\n      </span><span class="s1">path.search = path.search ? path.search.replace(/^</span><span class="s2">\\</span><span class="s1">?/, </span><span class="s2">\&quot;</span><span class="s1">?index&amp;</span><span class="s2">\&quot;</span><span class="s1">) : </span><span class="s2">\&quot;</span><span class="s1">?index</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">} else if (!activeRouteMatch.route.index &amp;&amp; nakedIndex) {</span><span class="s2">\n      </span><span class="s1">let params = new URLSearchParams(path.search);</span><span class="s2">\n      </span><span class="s1">let indexValues = params.getAll(</span><span class="s2">\&quot;</span><span class="s1">index</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">params.delete(</span><span class="s2">\&quot;</span><span class="s1">index</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">indexValues.filter((v) =&gt; v).forEach((v) =&gt; params.append(</span><span class="s2">\&quot;</span><span class="s1">index</span><span class="s2">\&quot;</span><span class="s1">, v));</span><span class="s2">\n      </span><span class="s1">let qs = params.toString();</span><span class="s2">\n      </span><span class="s1">path.search = qs ? `?${qs}` : </span><span class="s2">\&quot;\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (basename !== </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">path.pathname = path.pathname === </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot; </span><span class="s1">? basename : joinPaths([basename, path.pathname]);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return createPath(path);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function normalizeNavigateOptions(isFetcher, path, opts) {</span><span class="s2">\n  </span><span class="s1">if (!opts || !isSubmissionNavigation(opts)) {</span><span class="s2">\n    </span><span class="s1">return { path };</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (opts.formMethod &amp;&amp; !isValidMethod(opts.formMethod)) {</span><span class="s2">\n    </span><span class="s1">return {</span><span class="s2">\n      </span><span class="s1">path,</span><span class="s2">\n      </span><span class="s1">error: getInternalRouterError(405, { method: opts.formMethod })</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let getInvalidBodyError = () =&gt; ({</span><span class="s2">\n    </span><span class="s1">path,</span><span class="s2">\n    </span><span class="s1">error: getInternalRouterError(400, { type: </span><span class="s2">\&quot;</span><span class="s1">invalid-body</span><span class="s2">\&quot; </span><span class="s1">})</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">let rawFormMethod = opts.formMethod || </span><span class="s2">\&quot;</span><span class="s1">get</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">let formMethod = rawFormMethod.toUpperCase();</span><span class="s2">\n  </span><span class="s1">let formAction = stripHashFromPath(path);</span><span class="s2">\n  </span><span class="s1">if (opts.body !== void 0) {</span><span class="s2">\n    </span><span class="s1">if (opts.formEncType === </span><span class="s2">\&quot;</span><span class="s1">text/plain</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">if (!isMutationMethod(formMethod)) {</span><span class="s2">\n        </span><span class="s1">return getInvalidBodyError();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">let text = typeof opts.body === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">? opts.body : opts.body instanceof FormData || opts.body instanceof URLSearchParams ? (</span><span class="s2">\n        </span><span class="s1">// https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#plain-text-form-data</span><span class="s2">\n        </span><span class="s1">Array.from(opts.body.entries()).reduce(</span><span class="s2">\n          </span><span class="s1">(acc, [name, value]) =&gt; `${acc}${name}=${value}</span><span class="s2">\n</span><span class="s1">`,</span><span class="s2">\n          \&quot;\&quot;\n        </span><span class="s1">)</span><span class="s2">\n      </span><span class="s1">) : String(opts.body);</span><span class="s2">\n      </span><span class="s1">return {</span><span class="s2">\n        </span><span class="s1">path,</span><span class="s2">\n        </span><span class="s1">submission: {</span><span class="s2">\n          </span><span class="s1">formMethod,</span><span class="s2">\n          </span><span class="s1">formAction,</span><span class="s2">\n          </span><span class="s1">formEncType: opts.formEncType,</span><span class="s2">\n          </span><span class="s1">formData: void 0,</span><span class="s2">\n          </span><span class="s1">json: void 0,</span><span class="s2">\n          </span><span class="s1">text</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">} else if (opts.formEncType === </span><span class="s2">\&quot;</span><span class="s1">application/json</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">if (!isMutationMethod(formMethod)) {</span><span class="s2">\n        </span><span class="s1">return getInvalidBodyError();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">try {</span><span class="s2">\n        </span><span class="s1">let json = typeof opts.body === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">? JSON.parse(opts.body) : opts.body;</span><span class="s2">\n        </span><span class="s1">return {</span><span class="s2">\n          </span><span class="s1">path,</span><span class="s2">\n          </span><span class="s1">submission: {</span><span class="s2">\n            </span><span class="s1">formMethod,</span><span class="s2">\n            </span><span class="s1">formAction,</span><span class="s2">\n            </span><span class="s1">formEncType: opts.formEncType,</span><span class="s2">\n            </span><span class="s1">formData: void 0,</span><span class="s2">\n            </span><span class="s1">json,</span><span class="s2">\n            </span><span class="s1">text: void 0</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">} catch (e) {</span><span class="s2">\n        </span><span class="s1">return getInvalidBodyError();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">invariant(</span><span class="s2">\n    </span><span class="s1">typeof FormData === </span><span class="s2">\&quot;</span><span class="s1">function</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    \&quot;</span><span class="s1">FormData is not available in this environment</span><span class="s2">\&quot;\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let searchParams;</span><span class="s2">\n  </span><span class="s1">let formData;</span><span class="s2">\n  </span><span class="s1">if (opts.formData) {</span><span class="s2">\n    </span><span class="s1">searchParams = convertFormDataToSearchParams(opts.formData);</span><span class="s2">\n    </span><span class="s1">formData = opts.formData;</span><span class="s2">\n  </span><span class="s1">} else if (opts.body instanceof FormData) {</span><span class="s2">\n    </span><span class="s1">searchParams = convertFormDataToSearchParams(opts.body);</span><span class="s2">\n    </span><span class="s1">formData = opts.body;</span><span class="s2">\n  </span><span class="s1">} else if (opts.body instanceof URLSearchParams) {</span><span class="s2">\n    </span><span class="s1">searchParams = opts.body;</span><span class="s2">\n    </span><span class="s1">formData = convertSearchParamsToFormData(searchParams);</span><span class="s2">\n  </span><span class="s1">} else if (opts.body == null) {</span><span class="s2">\n    </span><span class="s1">searchParams = new URLSearchParams();</span><span class="s2">\n    </span><span class="s1">formData = new FormData();</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">try {</span><span class="s2">\n      </span><span class="s1">searchParams = new URLSearchParams(opts.body);</span><span class="s2">\n      </span><span class="s1">formData = convertSearchParamsToFormData(searchParams);</span><span class="s2">\n    </span><span class="s1">} catch (e) {</span><span class="s2">\n      </span><span class="s1">return getInvalidBodyError();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let submission = {</span><span class="s2">\n    </span><span class="s1">formMethod,</span><span class="s2">\n    </span><span class="s1">formAction,</span><span class="s2">\n    </span><span class="s1">formEncType: opts &amp;&amp; opts.formEncType || </span><span class="s2">\&quot;</span><span class="s1">application/x-www-form-urlencoded</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">formData,</span><span class="s2">\n    </span><span class="s1">json: void 0,</span><span class="s2">\n    </span><span class="s1">text: void 0</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">if (isMutationMethod(submission.formMethod)) {</span><span class="s2">\n    </span><span class="s1">return { path, submission };</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let parsedPath = parsePath(path);</span><span class="s2">\n  </span><span class="s1">if (isFetcher &amp;&amp; parsedPath.search &amp;&amp; hasNakedIndexQuery(parsedPath.search)) {</span><span class="s2">\n    </span><span class="s1">searchParams.append(</span><span class="s2">\&quot;</span><span class="s1">index</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">parsedPath.search = `?${searchParams}`;</span><span class="s2">\n  </span><span class="s1">return { path: createPath(parsedPath), submission };</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getMatchesToLoad(request, scopedContext, mapRouteProperties2, manifest, history, state, matches, submission, location, lazyRoutePropertiesToSkip, initialHydration, isRevalidationRequired, cancelledFetcherLoads, fetchersQueuedForDeletion, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionResult) {</span><span class="s2">\n  </span><span class="s1">let actionResult = pendingActionResult ? isErrorResult(pendingActionResult[1]) ? pendingActionResult[1].error : pendingActionResult[1].data : void 0;</span><span class="s2">\n  </span><span class="s1">let currentUrl = history.createURL(state.location);</span><span class="s2">\n  </span><span class="s1">let nextUrl = history.createURL(location);</span><span class="s2">\n  </span><span class="s1">let maxIdx;</span><span class="s2">\n  </span><span class="s1">if (initialHydration &amp;&amp; state.errors) {</span><span class="s2">\n    </span><span class="s1">let boundaryId = Object.keys(state.errors)[0];</span><span class="s2">\n    </span><span class="s1">maxIdx = matches.findIndex((m) =&gt; m.route.id === boundaryId);</span><span class="s2">\n  </span><span class="s1">} else if (pendingActionResult &amp;&amp; isErrorResult(pendingActionResult[1])) {</span><span class="s2">\n    </span><span class="s1">let boundaryId = pendingActionResult[0];</span><span class="s2">\n    </span><span class="s1">maxIdx = matches.findIndex((m) =&gt; m.route.id === boundaryId) - 1;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let actionStatus = pendingActionResult ? pendingActionResult[1].statusCode : void 0;</span><span class="s2">\n  </span><span class="s1">let shouldSkipRevalidation = actionStatus &amp;&amp; actionStatus &gt;= 400;</span><span class="s2">\n  </span><span class="s1">let baseShouldRevalidateArgs = {</span><span class="s2">\n    </span><span class="s1">currentUrl,</span><span class="s2">\n    </span><span class="s1">currentParams: state.matches[0]?.params || {},</span><span class="s2">\n    </span><span class="s1">nextUrl,</span><span class="s2">\n    </span><span class="s1">nextParams: matches[0].params,</span><span class="s2">\n    </span><span class="s1">...submission,</span><span class="s2">\n    </span><span class="s1">actionResult,</span><span class="s2">\n    </span><span class="s1">actionStatus</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">let dsMatches = matches.map((match, index) =&gt; {</span><span class="s2">\n    </span><span class="s1">let { route } = match;</span><span class="s2">\n    </span><span class="s1">let forceShouldLoad = null;</span><span class="s2">\n    </span><span class="s1">if (maxIdx != null &amp;&amp; index &gt; maxIdx) {</span><span class="s2">\n      </span><span class="s1">forceShouldLoad = false;</span><span class="s2">\n    </span><span class="s1">} else if (route.lazy) {</span><span class="s2">\n      </span><span class="s1">forceShouldLoad = true;</span><span class="s2">\n    </span><span class="s1">} else if (route.loader == null) {</span><span class="s2">\n      </span><span class="s1">forceShouldLoad = false;</span><span class="s2">\n    </span><span class="s1">} else if (initialHydration) {</span><span class="s2">\n      </span><span class="s1">forceShouldLoad = shouldLoadRouteOnHydration(</span><span class="s2">\n        </span><span class="s1">route,</span><span class="s2">\n        </span><span class="s1">state.loaderData,</span><span class="s2">\n        </span><span class="s1">state.errors</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">} else if (isNewLoader(state.loaderData, state.matches[index], match)) {</span><span class="s2">\n      </span><span class="s1">forceShouldLoad = true;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (forceShouldLoad !== null) {</span><span class="s2">\n      </span><span class="s1">return getDataStrategyMatch(</span><span class="s2">\n        </span><span class="s1">mapRouteProperties2,</span><span class="s2">\n        </span><span class="s1">manifest,</span><span class="s2">\n        </span><span class="s1">request,</span><span class="s2">\n        </span><span class="s1">match,</span><span class="s2">\n        </span><span class="s1">lazyRoutePropertiesToSkip,</span><span class="s2">\n        </span><span class="s1">scopedContext,</span><span class="s2">\n        </span><span class="s1">forceShouldLoad</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let defaultShouldRevalidate = shouldSkipRevalidation ? false : (</span><span class="s2">\n      </span><span class="s1">// Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate</span><span class="s2">\n      </span><span class="s1">isRevalidationRequired || currentUrl.pathname + currentUrl.search === nextUrl.pathname + nextUrl.search || // Search params affect all loaders</span><span class="s2">\n      </span><span class="s1">currentUrl.search !== nextUrl.search || isNewRouteInstance(state.matches[index], match)</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">let shouldRevalidateArgs = {</span><span class="s2">\n      </span><span class="s1">...baseShouldRevalidateArgs,</span><span class="s2">\n      </span><span class="s1">defaultShouldRevalidate</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">let shouldLoad = shouldRevalidateLoader(match, shouldRevalidateArgs);</span><span class="s2">\n    </span><span class="s1">return getDataStrategyMatch(</span><span class="s2">\n      </span><span class="s1">mapRouteProperties2,</span><span class="s2">\n      </span><span class="s1">manifest,</span><span class="s2">\n      </span><span class="s1">request,</span><span class="s2">\n      </span><span class="s1">match,</span><span class="s2">\n      </span><span class="s1">lazyRoutePropertiesToSkip,</span><span class="s2">\n      </span><span class="s1">scopedContext,</span><span class="s2">\n      </span><span class="s1">shouldLoad,</span><span class="s2">\n      </span><span class="s1">shouldRevalidateArgs</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">let revalidatingFetchers = [];</span><span class="s2">\n  </span><span class="s1">fetchLoadMatches.forEach((f, key) =&gt; {</span><span class="s2">\n    </span><span class="s1">if (initialHydration || !matches.some((m) =&gt; m.route.id === f.routeId) || fetchersQueuedForDeletion.has(key)) {</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let fetcherMatches = matchRoutes(routesToUse, f.path, basename);</span><span class="s2">\n    </span><span class="s1">if (!fetcherMatches) {</span><span class="s2">\n      </span><span class="s1">revalidatingFetchers.push({</span><span class="s2">\n        </span><span class="s1">key,</span><span class="s2">\n        </span><span class="s1">routeId: f.routeId,</span><span class="s2">\n        </span><span class="s1">path: f.path,</span><span class="s2">\n        </span><span class="s1">matches: null,</span><span class="s2">\n        </span><span class="s1">match: null,</span><span class="s2">\n        </span><span class="s1">request: null,</span><span class="s2">\n        </span><span class="s1">controller: null</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (fetchRedirectIds.has(key)) {</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let fetcher = state.fetchers.get(key);</span><span class="s2">\n    </span><span class="s1">let fetcherMatch = getTargetMatch(fetcherMatches, f.path);</span><span class="s2">\n    </span><span class="s1">let fetchController = new AbortController();</span><span class="s2">\n    </span><span class="s1">let fetchRequest = createClientSideRequest(</span><span class="s2">\n      </span><span class="s1">history,</span><span class="s2">\n      </span><span class="s1">f.path,</span><span class="s2">\n      </span><span class="s1">fetchController.signal</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">let fetcherDsMatches = null;</span><span class="s2">\n    </span><span class="s1">if (cancelledFetcherLoads.has(key)) {</span><span class="s2">\n      </span><span class="s1">cancelledFetcherLoads.delete(key);</span><span class="s2">\n      </span><span class="s1">fetcherDsMatches = getTargetedDataStrategyMatches(</span><span class="s2">\n        </span><span class="s1">mapRouteProperties2,</span><span class="s2">\n        </span><span class="s1">manifest,</span><span class="s2">\n        </span><span class="s1">fetchRequest,</span><span class="s2">\n        </span><span class="s1">fetcherMatches,</span><span class="s2">\n        </span><span class="s1">fetcherMatch,</span><span class="s2">\n        </span><span class="s1">lazyRoutePropertiesToSkip,</span><span class="s2">\n        </span><span class="s1">scopedContext</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">} else if (fetcher &amp;&amp; fetcher.state !== </span><span class="s2">\&quot;</span><span class="s1">idle</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; fetcher.data === void 0) {</span><span class="s2">\n      </span><span class="s1">if (isRevalidationRequired) {</span><span class="s2">\n        </span><span class="s1">fetcherDsMatches = getTargetedDataStrategyMatches(</span><span class="s2">\n          </span><span class="s1">mapRouteProperties2,</span><span class="s2">\n          </span><span class="s1">manifest,</span><span class="s2">\n          </span><span class="s1">fetchRequest,</span><span class="s2">\n          </span><span class="s1">fetcherMatches,</span><span class="s2">\n          </span><span class="s1">fetcherMatch,</span><span class="s2">\n          </span><span class="s1">lazyRoutePropertiesToSkip,</span><span class="s2">\n          </span><span class="s1">scopedContext</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">let shouldRevalidateArgs = {</span><span class="s2">\n        </span><span class="s1">...baseShouldRevalidateArgs,</span><span class="s2">\n        </span><span class="s1">defaultShouldRevalidate: shouldSkipRevalidation ? false : isRevalidationRequired</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">if (shouldRevalidateLoader(fetcherMatch, shouldRevalidateArgs)) {</span><span class="s2">\n        </span><span class="s1">fetcherDsMatches = getTargetedDataStrategyMatches(</span><span class="s2">\n          </span><span class="s1">mapRouteProperties2,</span><span class="s2">\n          </span><span class="s1">manifest,</span><span class="s2">\n          </span><span class="s1">fetchRequest,</span><span class="s2">\n          </span><span class="s1">fetcherMatches,</span><span class="s2">\n          </span><span class="s1">fetcherMatch,</span><span class="s2">\n          </span><span class="s1">lazyRoutePropertiesToSkip,</span><span class="s2">\n          </span><span class="s1">scopedContext,</span><span class="s2">\n          </span><span class="s1">shouldRevalidateArgs</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (fetcherDsMatches) {</span><span class="s2">\n      </span><span class="s1">revalidatingFetchers.push({</span><span class="s2">\n        </span><span class="s1">key,</span><span class="s2">\n        </span><span class="s1">routeId: f.routeId,</span><span class="s2">\n        </span><span class="s1">path: f.path,</span><span class="s2">\n        </span><span class="s1">matches: fetcherDsMatches,</span><span class="s2">\n        </span><span class="s1">match: fetcherMatch,</span><span class="s2">\n        </span><span class="s1">request: fetchRequest,</span><span class="s2">\n        </span><span class="s1">controller: fetchController</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">return { dsMatches, revalidatingFetchers };</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function shouldLoadRouteOnHydration(route, loaderData, errors) {</span><span class="s2">\n  </span><span class="s1">if (route.lazy) {</span><span class="s2">\n    </span><span class="s1">return true;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (!route.loader) {</span><span class="s2">\n    </span><span class="s1">return false;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let hasData = loaderData != null &amp;&amp; route.id in loaderData;</span><span class="s2">\n  </span><span class="s1">let hasError = errors != null &amp;&amp; errors[route.id] !== void 0;</span><span class="s2">\n  </span><span class="s1">if (!hasData &amp;&amp; hasError) {</span><span class="s2">\n    </span><span class="s1">return false;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (typeof route.loader === </span><span class="s2">\&quot;</span><span class="s1">function</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; route.loader.hydrate === true) {</span><span class="s2">\n    </span><span class="s1">return true;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return !hasData &amp;&amp; !hasError;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isNewLoader(currentLoaderData, currentMatch, match) {</span><span class="s2">\n  </span><span class="s1">let isNew = (</span><span class="s2">\n    </span><span class="s1">// [a] -&gt; [a, b]</span><span class="s2">\n    </span><span class="s1">!currentMatch || // [a, b] -&gt; [a, c]</span><span class="s2">\n    </span><span class="s1">match.route.id !== currentMatch.route.id</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let isMissingData = !currentLoaderData.hasOwnProperty(match.route.id);</span><span class="s2">\n  </span><span class="s1">return isNew || isMissingData;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isNewRouteInstance(currentMatch, match) {</span><span class="s2">\n  </span><span class="s1">let currentPath = currentMatch.route.path;</span><span class="s2">\n  </span><span class="s1">return (</span><span class="s2">\n    </span><span class="s1">// param change for this match, /users/123 -&gt; /users/456</span><span class="s2">\n    </span><span class="s1">currentMatch.pathname !== match.pathname || // splat param changed, which is not present in match.path</span><span class="s2">\n    </span><span class="s1">// e.g. /files/images/avatar.jpg -&gt; files/finances.xls</span><span class="s2">\n    </span><span class="s1">currentPath != null &amp;&amp; currentPath.endsWith(</span><span class="s2">\&quot;</span><span class="s1">*</span><span class="s2">\&quot;</span><span class="s1">) &amp;&amp; currentMatch.params[</span><span class="s2">\&quot;</span><span class="s1">*</span><span class="s2">\&quot;</span><span class="s1">] !== match.params[</span><span class="s2">\&quot;</span><span class="s1">*</span><span class="s2">\&quot;</span><span class="s1">]</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function shouldRevalidateLoader(loaderMatch, arg) {</span><span class="s2">\n  </span><span class="s1">if (loaderMatch.route.shouldRevalidate) {</span><span class="s2">\n    </span><span class="s1">let routeChoice = loaderMatch.route.shouldRevalidate(arg);</span><span class="s2">\n    </span><span class="s1">if (typeof routeChoice === </span><span class="s2">\&quot;</span><span class="s1">boolean</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">return routeChoice;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return arg.defaultShouldRevalidate;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function patchRoutesImpl(routeId, children, routesToUse, manifest, mapRouteProperties2) {</span><span class="s2">\n  </span><span class="s1">let childrenToPatch;</span><span class="s2">\n  </span><span class="s1">if (routeId) {</span><span class="s2">\n    </span><span class="s1">let route = manifest[routeId];</span><span class="s2">\n    </span><span class="s1">invariant(</span><span class="s2">\n      </span><span class="s1">route,</span><span class="s2">\n      </span><span class="s1">`No route found to patch children into: routeId = ${routeId}`</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">if (!route.children) {</span><span class="s2">\n      </span><span class="s1">route.children = [];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">childrenToPatch = route.children;</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">childrenToPatch = routesToUse;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let uniqueChildren = children.filter(</span><span class="s2">\n    </span><span class="s1">(newRoute) =&gt; !childrenToPatch.some(</span><span class="s2">\n      </span><span class="s1">(existingRoute) =&gt; isSameRoute(newRoute, existingRoute)</span><span class="s2">\n    </span><span class="s1">)</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let newRoutes = convertRoutesToDataRoutes(</span><span class="s2">\n    </span><span class="s1">uniqueChildren,</span><span class="s2">\n    </span><span class="s1">mapRouteProperties2,</span><span class="s2">\n    </span><span class="s1">[routeId || </span><span class="s2">\&quot;</span><span class="s1">_</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">patch</span><span class="s2">\&quot;</span><span class="s1">, String(childrenToPatch?.length || </span><span class="s2">\&quot;</span><span class="s1">0</span><span class="s2">\&quot;</span><span class="s1">)],</span><span class="s2">\n    </span><span class="s1">manifest</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">childrenToPatch.push(...newRoutes);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isSameRoute(newRoute, existingRoute) {</span><span class="s2">\n  </span><span class="s1">if (</span><span class="s2">\&quot;</span><span class="s1">id</span><span class="s2">\&quot; </span><span class="s1">in newRoute &amp;&amp; </span><span class="s2">\&quot;</span><span class="s1">id</span><span class="s2">\&quot; </span><span class="s1">in existingRoute &amp;&amp; newRoute.id === existingRoute.id) {</span><span class="s2">\n    </span><span class="s1">return true;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (!(newRoute.index === existingRoute.index &amp;&amp; newRoute.path === existingRoute.path &amp;&amp; newRoute.caseSensitive === existingRoute.caseSensitive)) {</span><span class="s2">\n    </span><span class="s1">return false;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if ((!newRoute.children || newRoute.children.length === 0) &amp;&amp; (!existingRoute.children || existingRoute.children.length === 0)) {</span><span class="s2">\n    </span><span class="s1">return true;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return newRoute.children.every(</span><span class="s2">\n    </span><span class="s1">(aChild, i) =&gt; existingRoute.children?.some((bChild) =&gt; isSameRoute(aChild, bChild))</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var lazyRoutePropertyCache = /* @__PURE__ */ new WeakMap();</span><span class="s2">\n</span><span class="s1">var loadLazyRouteProperty = ({</span><span class="s2">\n  </span><span class="s1">key,</span><span class="s2">\n  </span><span class="s1">route,</span><span class="s2">\n  </span><span class="s1">manifest,</span><span class="s2">\n  </span><span class="s1">mapRouteProperties: mapRouteProperties2</span><span class="s2">\n</span><span class="s1">}) =&gt; {</span><span class="s2">\n  </span><span class="s1">let routeToUpdate = manifest[route.id];</span><span class="s2">\n  </span><span class="s1">invariant(routeToUpdate, </span><span class="s2">\&quot;</span><span class="s1">No route found in manifest</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">if (!routeToUpdate.lazy || typeof routeToUpdate.lazy !== </span><span class="s2">\&quot;</span><span class="s1">object</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">return;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let lazyFn = routeToUpdate.lazy[key];</span><span class="s2">\n  </span><span class="s1">if (!lazyFn) {</span><span class="s2">\n    </span><span class="s1">return;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let cache = lazyRoutePropertyCache.get(routeToUpdate);</span><span class="s2">\n  </span><span class="s1">if (!cache) {</span><span class="s2">\n    </span><span class="s1">cache = {};</span><span class="s2">\n    </span><span class="s1">lazyRoutePropertyCache.set(routeToUpdate, cache);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let cachedPromise = cache[key];</span><span class="s2">\n  </span><span class="s1">if (cachedPromise) {</span><span class="s2">\n    </span><span class="s1">return cachedPromise;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let propertyPromise = (async () =&gt; {</span><span class="s2">\n    </span><span class="s1">let isUnsupported = isUnsupportedLazyRouteObjectKey(key);</span><span class="s2">\n    </span><span class="s1">let staticRouteValue = routeToUpdate[key];</span><span class="s2">\n    </span><span class="s1">let isStaticallyDefined = staticRouteValue !== void 0 &amp;&amp; key !== </span><span class="s2">\&quot;</span><span class="s1">hasErrorBoundary</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">if (isUnsupported) {</span><span class="s2">\n      </span><span class="s1">warning(</span><span class="s2">\n        </span><span class="s1">!isUnsupported,</span><span class="s2">\n        \&quot;</span><span class="s1">Route property </span><span class="s2">\&quot; </span><span class="s1">+ key + </span><span class="s2">\&quot; </span><span class="s1">is not a supported lazy route property. This property will be ignored.</span><span class="s2">\&quot;\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">cache[key] = Promise.resolve();</span><span class="s2">\n    </span><span class="s1">} else if (isStaticallyDefined) {</span><span class="s2">\n      </span><span class="s1">warning(</span><span class="s2">\n        </span><span class="s1">false,</span><span class="s2">\n        </span><span class="s1">`Route </span><span class="s2">\&quot;</span><span class="s1">${routeToUpdate.id}</span><span class="s2">\&quot; </span><span class="s1">has a static property </span><span class="s2">\&quot;</span><span class="s1">${key}</span><span class="s2">\&quot; </span><span class="s1">defined. The lazy property will be ignored.`</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">let value = await lazyFn();</span><span class="s2">\n      </span><span class="s1">if (value != null) {</span><span class="s2">\n        </span><span class="s1">Object.assign(routeToUpdate, { [key]: value });</span><span class="s2">\n        </span><span class="s1">Object.assign(routeToUpdate, mapRouteProperties2(routeToUpdate));</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (typeof routeToUpdate.lazy === </span><span class="s2">\&quot;</span><span class="s1">object</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">routeToUpdate.lazy[key] = void 0;</span><span class="s2">\n      </span><span class="s1">if (Object.values(routeToUpdate.lazy).every((value) =&gt; value === void 0)) {</span><span class="s2">\n        </span><span class="s1">routeToUpdate.lazy = void 0;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">})();</span><span class="s2">\n  </span><span class="s1">cache[key] = propertyPromise;</span><span class="s2">\n  </span><span class="s1">return propertyPromise;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">var lazyRouteFunctionCache = /* @__PURE__ */ new WeakMap();</span><span class="s2">\n</span><span class="s1">function loadLazyRoute(route, type, manifest, mapRouteProperties2, lazyRoutePropertiesToSkip) {</span><span class="s2">\n  </span><span class="s1">let routeToUpdate = manifest[route.id];</span><span class="s2">\n  </span><span class="s1">invariant(routeToUpdate, </span><span class="s2">\&quot;</span><span class="s1">No route found in manifest</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">if (!route.lazy) {</span><span class="s2">\n    </span><span class="s1">return {</span><span class="s2">\n      </span><span class="s1">lazyRoutePromise: void 0,</span><span class="s2">\n      </span><span class="s1">lazyHandlerPromise: void 0</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (typeof route.lazy === </span><span class="s2">\&quot;</span><span class="s1">function</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">let cachedPromise = lazyRouteFunctionCache.get(routeToUpdate);</span><span class="s2">\n    </span><span class="s1">if (cachedPromise) {</span><span class="s2">\n      </span><span class="s1">return {</span><span class="s2">\n        </span><span class="s1">lazyRoutePromise: cachedPromise,</span><span class="s2">\n        </span><span class="s1">lazyHandlerPromise: cachedPromise</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let lazyRoutePromise2 = (async () =&gt; {</span><span class="s2">\n      </span><span class="s1">invariant(</span><span class="s2">\n        </span><span class="s1">typeof route.lazy === </span><span class="s2">\&quot;</span><span class="s1">function</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        \&quot;</span><span class="s1">No lazy route function found</span><span class="s2">\&quot;\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">let lazyRoute = await route.lazy();</span><span class="s2">\n      </span><span class="s1">let routeUpdates = {};</span><span class="s2">\n      </span><span class="s1">for (let lazyRouteProperty in lazyRoute) {</span><span class="s2">\n        </span><span class="s1">let lazyValue = lazyRoute[lazyRouteProperty];</span><span class="s2">\n        </span><span class="s1">if (lazyValue === void 0) {</span><span class="s2">\n          </span><span class="s1">continue;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">let isUnsupported = isUnsupportedLazyRouteFunctionKey(lazyRouteProperty);</span><span class="s2">\n        </span><span class="s1">let staticRouteValue = routeToUpdate[lazyRouteProperty];</span><span class="s2">\n        </span><span class="s1">let isStaticallyDefined = staticRouteValue !== void 0 &amp;&amp; // This property isn't static since it should always be updated based</span><span class="s2">\n        </span><span class="s1">// on the route updates</span><span class="s2">\n        </span><span class="s1">lazyRouteProperty !== </span><span class="s2">\&quot;</span><span class="s1">hasErrorBoundary</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n        </span><span class="s1">if (isUnsupported) {</span><span class="s2">\n          </span><span class="s1">warning(</span><span class="s2">\n            </span><span class="s1">!isUnsupported,</span><span class="s2">\n            \&quot;</span><span class="s1">Route property </span><span class="s2">\&quot; </span><span class="s1">+ lazyRouteProperty + </span><span class="s2">\&quot; </span><span class="s1">is not a supported property to be returned from a lazy route function. This property will be ignored.</span><span class="s2">\&quot;\n          </span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">} else if (isStaticallyDefined) {</span><span class="s2">\n          </span><span class="s1">warning(</span><span class="s2">\n            </span><span class="s1">!isStaticallyDefined,</span><span class="s2">\n            </span><span class="s1">`Route </span><span class="s2">\&quot;</span><span class="s1">${routeToUpdate.id}</span><span class="s2">\&quot; </span><span class="s1">has a static property </span><span class="s2">\&quot;</span><span class="s1">${lazyRouteProperty}</span><span class="s2">\&quot; </span><span class="s1">defined but its lazy function is also returning a value for this property. The lazy route property </span><span class="s2">\&quot;</span><span class="s1">${lazyRouteProperty}</span><span class="s2">\&quot; </span><span class="s1">will be ignored.`</span><span class="s2">\n          </span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">routeUpdates[lazyRouteProperty] = lazyValue;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">Object.assign(routeToUpdate, routeUpdates);</span><span class="s2">\n      </span><span class="s1">Object.assign(routeToUpdate, {</span><span class="s2">\n        </span><span class="s1">// To keep things framework agnostic, we use the provided `mapRouteProperties`</span><span class="s2">\n        </span><span class="s1">// function to set the framework-aware properties (`element`/`hasErrorBoundary`)</span><span class="s2">\n        </span><span class="s1">// since the logic will differ between frameworks.</span><span class="s2">\n        </span><span class="s1">...mapRouteProperties2(routeToUpdate),</span><span class="s2">\n        </span><span class="s1">lazy: void 0</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">})();</span><span class="s2">\n    </span><span class="s1">lazyRouteFunctionCache.set(routeToUpdate, lazyRoutePromise2);</span><span class="s2">\n    </span><span class="s1">lazyRoutePromise2.catch(() =&gt; {</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">return {</span><span class="s2">\n      </span><span class="s1">lazyRoutePromise: lazyRoutePromise2,</span><span class="s2">\n      </span><span class="s1">lazyHandlerPromise: lazyRoutePromise2</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let lazyKeys = Object.keys(route.lazy);</span><span class="s2">\n  </span><span class="s1">let lazyPropertyPromises = [];</span><span class="s2">\n  </span><span class="s1">let lazyHandlerPromise = void 0;</span><span class="s2">\n  </span><span class="s1">for (let key of lazyKeys) {</span><span class="s2">\n    </span><span class="s1">if (lazyRoutePropertiesToSkip &amp;&amp; lazyRoutePropertiesToSkip.includes(key)) {</span><span class="s2">\n      </span><span class="s1">continue;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let promise = loadLazyRouteProperty({</span><span class="s2">\n      </span><span class="s1">key,</span><span class="s2">\n      </span><span class="s1">route,</span><span class="s2">\n      </span><span class="s1">manifest,</span><span class="s2">\n      </span><span class="s1">mapRouteProperties: mapRouteProperties2</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">if (promise) {</span><span class="s2">\n      </span><span class="s1">lazyPropertyPromises.push(promise);</span><span class="s2">\n      </span><span class="s1">if (key === type) {</span><span class="s2">\n        </span><span class="s1">lazyHandlerPromise = promise;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let lazyRoutePromise = lazyPropertyPromises.length &gt; 0 ? Promise.all(lazyPropertyPromises).then(() =&gt; {</span><span class="s2">\n  </span><span class="s1">}) : void 0;</span><span class="s2">\n  </span><span class="s1">lazyRoutePromise?.catch(() =&gt; {</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">lazyHandlerPromise?.catch(() =&gt; {</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">lazyRoutePromise,</span><span class="s2">\n    </span><span class="s1">lazyHandlerPromise</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isNonNullable(value) {</span><span class="s2">\n  </span><span class="s1">return value !== void 0;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function loadLazyMiddlewareForMatches(matches, manifest, mapRouteProperties2) {</span><span class="s2">\n  </span><span class="s1">let promises = matches.map(({ route }) =&gt; {</span><span class="s2">\n    </span><span class="s1">if (typeof route.lazy !== </span><span class="s2">\&quot;</span><span class="s1">object</span><span class="s2">\&quot; </span><span class="s1">|| !route.lazy.unstable_middleware) {</span><span class="s2">\n      </span><span class="s1">return void 0;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return loadLazyRouteProperty({</span><span class="s2">\n      </span><span class="s1">key: </span><span class="s2">\&quot;</span><span class="s1">unstable_middleware</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">route,</span><span class="s2">\n      </span><span class="s1">manifest,</span><span class="s2">\n      </span><span class="s1">mapRouteProperties: mapRouteProperties2</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}).filter(isNonNullable);</span><span class="s2">\n  </span><span class="s1">return promises.length &gt; 0 ? Promise.all(promises) : void 0;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">async function defaultDataStrategy(args) {</span><span class="s2">\n  </span><span class="s1">let matchesToLoad = args.matches.filter((m) =&gt; m.shouldLoad);</span><span class="s2">\n  </span><span class="s1">let keyedResults = {};</span><span class="s2">\n  </span><span class="s1">let results = await Promise.all(matchesToLoad.map((m) =&gt; m.resolve()));</span><span class="s2">\n  </span><span class="s1">results.forEach((result, i) =&gt; {</span><span class="s2">\n    </span><span class="s1">keyedResults[matchesToLoad[i].route.id] = result;</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">return keyedResults;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">async function defaultDataStrategyWithMiddleware(args) {</span><span class="s2">\n  </span><span class="s1">if (!args.matches.some((m) =&gt; m.route.unstable_middleware)) {</span><span class="s2">\n    </span><span class="s1">return defaultDataStrategy(args);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return runMiddlewarePipeline(</span><span class="s2">\n    </span><span class="s1">args,</span><span class="s2">\n    </span><span class="s1">false,</span><span class="s2">\n    </span><span class="s1">() =&gt; defaultDataStrategy(args),</span><span class="s2">\n    </span><span class="s1">(error, routeId) =&gt; ({ [routeId]: { type: </span><span class="s2">\&quot;</span><span class="s1">error</span><span class="s2">\&quot;</span><span class="s1">, result: error } })</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">async function runMiddlewarePipeline(args, propagateResult, handler, errorHandler) {</span><span class="s2">\n  </span><span class="s1">let { matches, request, params, context } = args;</span><span class="s2">\n  </span><span class="s1">let middlewareState = {</span><span class="s2">\n    </span><span class="s1">handlerResult: void 0</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">try {</span><span class="s2">\n    </span><span class="s1">let tuples = matches.flatMap(</span><span class="s2">\n      </span><span class="s1">(m) =&gt; m.route.unstable_middleware ? m.route.unstable_middleware.map((fn) =&gt; [m.route.id, fn]) : []</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">let result = await callRouteMiddleware(</span><span class="s2">\n      </span><span class="s1">{ request, params, context },</span><span class="s2">\n      </span><span class="s1">tuples,</span><span class="s2">\n      </span><span class="s1">propagateResult,</span><span class="s2">\n      </span><span class="s1">middlewareState,</span><span class="s2">\n      </span><span class="s1">handler</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">return propagateResult ? result : middlewareState.handlerResult;</span><span class="s2">\n  </span><span class="s1">} catch (e) {</span><span class="s2">\n    </span><span class="s1">if (!middlewareState.middlewareError) {</span><span class="s2">\n      </span><span class="s1">throw e;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let result = await errorHandler(</span><span class="s2">\n      </span><span class="s1">middlewareState.middlewareError.error,</span><span class="s2">\n      </span><span class="s1">middlewareState.middlewareError.routeId</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">if (propagateResult || !middlewareState.handlerResult) {</span><span class="s2">\n      </span><span class="s1">return result;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return Object.assign(middlewareState.handlerResult, result);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">async function callRouteMiddleware(args, middlewares, propagateResult, middlewareState, handler, idx = 0) {</span><span class="s2">\n  </span><span class="s1">let { request } = args;</span><span class="s2">\n  </span><span class="s1">if (request.signal.aborted) {</span><span class="s2">\n    </span><span class="s1">if (request.signal.reason) {</span><span class="s2">\n      </span><span class="s1">throw request.signal.reason;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">throw new Error(</span><span class="s2">\n      </span><span class="s1">`Request aborted without an </span><span class="s2">\\</span><span class="s1">`AbortSignal.reason</span><span class="s2">\\</span><span class="s1">`: ${request.method} ${request.url}`</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let tuple = middlewares[idx];</span><span class="s2">\n  </span><span class="s1">if (!tuple) {</span><span class="s2">\n    </span><span class="s1">middlewareState.handlerResult = await handler();</span><span class="s2">\n    </span><span class="s1">return middlewareState.handlerResult;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let [routeId, middleware] = tuple;</span><span class="s2">\n  </span><span class="s1">let nextCalled = false;</span><span class="s2">\n  </span><span class="s1">let nextResult = void 0;</span><span class="s2">\n  </span><span class="s1">let next = async () =&gt; {</span><span class="s2">\n    </span><span class="s1">if (nextCalled) {</span><span class="s2">\n      </span><span class="s1">throw new Error(</span><span class="s2">\&quot;</span><span class="s1">You may only call `next()` once per middleware</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">nextCalled = true;</span><span class="s2">\n    </span><span class="s1">let result = await callRouteMiddleware(</span><span class="s2">\n      </span><span class="s1">args,</span><span class="s2">\n      </span><span class="s1">middlewares,</span><span class="s2">\n      </span><span class="s1">propagateResult,</span><span class="s2">\n      </span><span class="s1">middlewareState,</span><span class="s2">\n      </span><span class="s1">handler,</span><span class="s2">\n      </span><span class="s1">idx + 1</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">if (propagateResult) {</span><span class="s2">\n      </span><span class="s1">nextResult = result;</span><span class="s2">\n      </span><span class="s1">return nextResult;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">try {</span><span class="s2">\n    </span><span class="s1">let result = await middleware(</span><span class="s2">\n      </span><span class="s1">{</span><span class="s2">\n        </span><span class="s1">request: args.request,</span><span class="s2">\n        </span><span class="s1">params: args.params,</span><span class="s2">\n        </span><span class="s1">context: args.context</span><span class="s2">\n      </span><span class="s1">},</span><span class="s2">\n      </span><span class="s1">next</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">if (nextCalled) {</span><span class="s2">\n      </span><span class="s1">if (result === void 0) {</span><span class="s2">\n        </span><span class="s1">return nextResult;</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">return result;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">return next();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">} catch (error) {</span><span class="s2">\n    </span><span class="s1">if (!middlewareState.middlewareError) {</span><span class="s2">\n      </span><span class="s1">middlewareState.middlewareError = { routeId, error };</span><span class="s2">\n    </span><span class="s1">} else if (middlewareState.middlewareError.error !== error) {</span><span class="s2">\n      </span><span class="s1">middlewareState.middlewareError = { routeId, error };</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">throw error;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getDataStrategyMatchLazyPromises(mapRouteProperties2, manifest, request, match, lazyRoutePropertiesToSkip) {</span><span class="s2">\n  </span><span class="s1">let lazyMiddlewarePromise = loadLazyRouteProperty({</span><span class="s2">\n    </span><span class="s1">key: </span><span class="s2">\&quot;</span><span class="s1">unstable_middleware</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">route: match.route,</span><span class="s2">\n    </span><span class="s1">manifest,</span><span class="s2">\n    </span><span class="s1">mapRouteProperties: mapRouteProperties2</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">let lazyRoutePromises = loadLazyRoute(</span><span class="s2">\n    </span><span class="s1">match.route,</span><span class="s2">\n    </span><span class="s1">isMutationMethod(request.method) ? </span><span class="s2">\&quot;</span><span class="s1">action</span><span class="s2">\&quot; </span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">loader</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">manifest,</span><span class="s2">\n    </span><span class="s1">mapRouteProperties2,</span><span class="s2">\n    </span><span class="s1">lazyRoutePropertiesToSkip</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">middleware: lazyMiddlewarePromise,</span><span class="s2">\n    </span><span class="s1">route: lazyRoutePromises.lazyRoutePromise,</span><span class="s2">\n    </span><span class="s1">handler: lazyRoutePromises.lazyHandlerPromise</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getDataStrategyMatch(mapRouteProperties2, manifest, request, match, lazyRoutePropertiesToSkip, scopedContext, shouldLoad, unstable_shouldRevalidateArgs = null) {</span><span class="s2">\n  </span><span class="s1">let isUsingNewApi = false;</span><span class="s2">\n  </span><span class="s1">let _lazyPromises = getDataStrategyMatchLazyPromises(</span><span class="s2">\n    </span><span class="s1">mapRouteProperties2,</span><span class="s2">\n    </span><span class="s1">manifest,</span><span class="s2">\n    </span><span class="s1">request,</span><span class="s2">\n    </span><span class="s1">match,</span><span class="s2">\n    </span><span class="s1">lazyRoutePropertiesToSkip</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">...match,</span><span class="s2">\n    </span><span class="s1">_lazyPromises,</span><span class="s2">\n    </span><span class="s1">shouldLoad,</span><span class="s2">\n    </span><span class="s1">unstable_shouldRevalidateArgs,</span><span class="s2">\n    </span><span class="s1">unstable_shouldCallHandler(defaultShouldRevalidate) {</span><span class="s2">\n      </span><span class="s1">isUsingNewApi = true;</span><span class="s2">\n      </span><span class="s1">if (!unstable_shouldRevalidateArgs) {</span><span class="s2">\n        </span><span class="s1">return shouldLoad;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (typeof defaultShouldRevalidate === </span><span class="s2">\&quot;</span><span class="s1">boolean</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">return shouldRevalidateLoader(match, {</span><span class="s2">\n          </span><span class="s1">...unstable_shouldRevalidateArgs,</span><span class="s2">\n          </span><span class="s1">defaultShouldRevalidate</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return shouldRevalidateLoader(match, unstable_shouldRevalidateArgs);</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">resolve(handlerOverride) {</span><span class="s2">\n      </span><span class="s1">if (isUsingNewApi || shouldLoad || handlerOverride &amp;&amp; request.method === </span><span class="s2">\&quot;</span><span class="s1">GET</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; (match.route.lazy || match.route.loader)) {</span><span class="s2">\n        </span><span class="s1">return callLoaderOrAction({</span><span class="s2">\n          </span><span class="s1">request,</span><span class="s2">\n          </span><span class="s1">match,</span><span class="s2">\n          </span><span class="s1">lazyHandlerPromise: _lazyPromises?.handler,</span><span class="s2">\n          </span><span class="s1">lazyRoutePromise: _lazyPromises?.route,</span><span class="s2">\n          </span><span class="s1">handlerOverride,</span><span class="s2">\n          </span><span class="s1">scopedContext</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return Promise.resolve({ type: </span><span class="s2">\&quot;</span><span class="s1">data</span><span class="s2">\&quot; </span><span class="s1">/* data */, result: void 0 });</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getTargetedDataStrategyMatches(mapRouteProperties2, manifest, request, matches, targetMatch, lazyRoutePropertiesToSkip, scopedContext, shouldRevalidateArgs = null) {</span><span class="s2">\n  </span><span class="s1">return matches.map((match) =&gt; {</span><span class="s2">\n    </span><span class="s1">if (match.route.id !== targetMatch.route.id) {</span><span class="s2">\n      </span><span class="s1">return {</span><span class="s2">\n        </span><span class="s1">...match,</span><span class="s2">\n        </span><span class="s1">shouldLoad: false,</span><span class="s2">\n        </span><span class="s1">unstable_shouldRevalidateArgs: shouldRevalidateArgs,</span><span class="s2">\n        </span><span class="s1">unstable_shouldCallHandler: () =&gt; false,</span><span class="s2">\n        </span><span class="s1">_lazyPromises: getDataStrategyMatchLazyPromises(</span><span class="s2">\n          </span><span class="s1">mapRouteProperties2,</span><span class="s2">\n          </span><span class="s1">manifest,</span><span class="s2">\n          </span><span class="s1">request,</span><span class="s2">\n          </span><span class="s1">match,</span><span class="s2">\n          </span><span class="s1">lazyRoutePropertiesToSkip</span><span class="s2">\n        </span><span class="s1">),</span><span class="s2">\n        </span><span class="s1">resolve: () =&gt; Promise.resolve({ type: </span><span class="s2">\&quot;</span><span class="s1">data</span><span class="s2">\&quot;</span><span class="s1">, result: void 0 })</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return getDataStrategyMatch(</span><span class="s2">\n      </span><span class="s1">mapRouteProperties2,</span><span class="s2">\n      </span><span class="s1">manifest,</span><span class="s2">\n      </span><span class="s1">request,</span><span class="s2">\n      </span><span class="s1">match,</span><span class="s2">\n      </span><span class="s1">lazyRoutePropertiesToSkip,</span><span class="s2">\n      </span><span class="s1">scopedContext,</span><span class="s2">\n      </span><span class="s1">true,</span><span class="s2">\n      </span><span class="s1">shouldRevalidateArgs</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">async function callDataStrategyImpl(dataStrategyImpl, request, matches, fetcherKey, scopedContext, isStaticHandler) {</span><span class="s2">\n  </span><span class="s1">if (matches.some((m) =&gt; m._lazyPromises?.middleware)) {</span><span class="s2">\n    </span><span class="s1">await Promise.all(matches.map((m) =&gt; m._lazyPromises?.middleware));</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let dataStrategyArgs = {</span><span class="s2">\n    </span><span class="s1">request,</span><span class="s2">\n    </span><span class="s1">params: matches[0].params,</span><span class="s2">\n    </span><span class="s1">context: scopedContext,</span><span class="s2">\n    </span><span class="s1">matches</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">let unstable_runClientMiddleware = isStaticHandler ? () =&gt; {</span><span class="s2">\n    </span><span class="s1">throw new Error(</span><span class="s2">\n      \&quot;</span><span class="s1">You cannot call `unstable_runClientMiddleware()` from a static handler `dataStrategy`. Middleware is run outside of `dataStrategy` during SSR in order to bubble up the Response.  You can enable middleware via the `respond` API in `query`/`queryRoute`</span><span class="s2">\&quot;\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">} : (cb) =&gt; {</span><span class="s2">\n    </span><span class="s1">let typedDataStrategyArgs = dataStrategyArgs;</span><span class="s2">\n    </span><span class="s1">return runMiddlewarePipeline(</span><span class="s2">\n      </span><span class="s1">typedDataStrategyArgs,</span><span class="s2">\n      </span><span class="s1">false,</span><span class="s2">\n      </span><span class="s1">() =&gt; cb({</span><span class="s2">\n        </span><span class="s1">...typedDataStrategyArgs,</span><span class="s2">\n        </span><span class="s1">fetcherKey,</span><span class="s2">\n        </span><span class="s1">unstable_runClientMiddleware: () =&gt; {</span><span class="s2">\n          </span><span class="s1">throw new Error(</span><span class="s2">\n            \&quot;</span><span class="s1">Cannot call `unstable_runClientMiddleware()` from within an `unstable_runClientMiddleware` handler</span><span class="s2">\&quot;\n          </span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}),</span><span class="s2">\n      </span><span class="s1">(error, routeId) =&gt; ({</span><span class="s2">\n        </span><span class="s1">[routeId]: { type: </span><span class="s2">\&quot;</span><span class="s1">error</span><span class="s2">\&quot;</span><span class="s1">, result: error }</span><span class="s2">\n      </span><span class="s1">})</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">let results = await dataStrategyImpl({</span><span class="s2">\n    </span><span class="s1">...dataStrategyArgs,</span><span class="s2">\n    </span><span class="s1">fetcherKey,</span><span class="s2">\n    </span><span class="s1">unstable_runClientMiddleware</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">try {</span><span class="s2">\n    </span><span class="s1">await Promise.all(</span><span class="s2">\n      </span><span class="s1">matches.flatMap((m) =&gt; [m._lazyPromises?.handler, m._lazyPromises?.route])</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">} catch (e) {</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return results;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">async function callLoaderOrAction({</span><span class="s2">\n  </span><span class="s1">request,</span><span class="s2">\n  </span><span class="s1">match,</span><span class="s2">\n  </span><span class="s1">lazyHandlerPromise,</span><span class="s2">\n  </span><span class="s1">lazyRoutePromise,</span><span class="s2">\n  </span><span class="s1">handlerOverride,</span><span class="s2">\n  </span><span class="s1">scopedContext</span><span class="s2">\n</span><span class="s1">}) {</span><span class="s2">\n  </span><span class="s1">let result;</span><span class="s2">\n  </span><span class="s1">let onReject;</span><span class="s2">\n  </span><span class="s1">let isAction = isMutationMethod(request.method);</span><span class="s2">\n  </span><span class="s1">let type = isAction ? </span><span class="s2">\&quot;</span><span class="s1">action</span><span class="s2">\&quot; </span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">loader</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">let runHandler = (handler) =&gt; {</span><span class="s2">\n    </span><span class="s1">let reject;</span><span class="s2">\n    </span><span class="s1">let abortPromise = new Promise((_, r) =&gt; reject = r);</span><span class="s2">\n    </span><span class="s1">onReject = () =&gt; reject();</span><span class="s2">\n    </span><span class="s1">request.signal.addEventListener(</span><span class="s2">\&quot;</span><span class="s1">abort</span><span class="s2">\&quot;</span><span class="s1">, onReject);</span><span class="s2">\n    </span><span class="s1">let actualHandler = (ctx) =&gt; {</span><span class="s2">\n      </span><span class="s1">if (typeof handler !== </span><span class="s2">\&quot;</span><span class="s1">function</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">return Promise.reject(</span><span class="s2">\n          </span><span class="s1">new Error(</span><span class="s2">\n            </span><span class="s1">`You cannot call the handler for a route which defines a boolean </span><span class="s2">\&quot;</span><span class="s1">${type}</span><span class="s2">\&quot; </span><span class="s1">[routeId: ${match.route.id}]`</span><span class="s2">\n          </span><span class="s1">)</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return handler(</span><span class="s2">\n        </span><span class="s1">{</span><span class="s2">\n          </span><span class="s1">request,</span><span class="s2">\n          </span><span class="s1">params: match.params,</span><span class="s2">\n          </span><span class="s1">context: scopedContext</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">...ctx !== void 0 ? [ctx] : []</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">let handlerPromise = (async () =&gt; {</span><span class="s2">\n      </span><span class="s1">try {</span><span class="s2">\n        </span><span class="s1">let val = await (handlerOverride ? handlerOverride((ctx) =&gt; actualHandler(ctx)) : actualHandler());</span><span class="s2">\n        </span><span class="s1">return { type: </span><span class="s2">\&quot;</span><span class="s1">data</span><span class="s2">\&quot;</span><span class="s1">, result: val };</span><span class="s2">\n      </span><span class="s1">} catch (e) {</span><span class="s2">\n        </span><span class="s1">return { type: </span><span class="s2">\&quot;</span><span class="s1">error</span><span class="s2">\&quot;</span><span class="s1">, result: e };</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">})();</span><span class="s2">\n    </span><span class="s1">return Promise.race([handlerPromise, abortPromise]);</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">try {</span><span class="s2">\n    </span><span class="s1">let handler = isAction ? match.route.action : match.route.loader;</span><span class="s2">\n    </span><span class="s1">if (lazyHandlerPromise || lazyRoutePromise) {</span><span class="s2">\n      </span><span class="s1">if (handler) {</span><span class="s2">\n        </span><span class="s1">let handlerError;</span><span class="s2">\n        </span><span class="s1">let [value] = await Promise.all([</span><span class="s2">\n          </span><span class="s1">// If the handler throws, don't let it immediately bubble out,</span><span class="s2">\n          </span><span class="s1">// since we need to let the lazy() execution finish so we know if this</span><span class="s2">\n          </span><span class="s1">// route has a boundary that can handle the error</span><span class="s2">\n          </span><span class="s1">runHandler(handler).catch((e) =&gt; {</span><span class="s2">\n            </span><span class="s1">handlerError = e;</span><span class="s2">\n          </span><span class="s1">}),</span><span class="s2">\n          </span><span class="s1">// Ensure all lazy route promises are resolved before continuing</span><span class="s2">\n          </span><span class="s1">lazyHandlerPromise,</span><span class="s2">\n          </span><span class="s1">lazyRoutePromise</span><span class="s2">\n        </span><span class="s1">]);</span><span class="s2">\n        </span><span class="s1">if (handlerError !== void 0) {</span><span class="s2">\n          </span><span class="s1">throw handlerError;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">result = value;</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">await lazyHandlerPromise;</span><span class="s2">\n        </span><span class="s1">let handler2 = isAction ? match.route.action : match.route.loader;</span><span class="s2">\n        </span><span class="s1">if (handler2) {</span><span class="s2">\n          </span><span class="s1">[result] = await Promise.all([runHandler(handler2), lazyRoutePromise]);</span><span class="s2">\n        </span><span class="s1">} else if (type === </span><span class="s2">\&quot;</span><span class="s1">action</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">let url = new URL(request.url);</span><span class="s2">\n          </span><span class="s1">let pathname = url.pathname + url.search;</span><span class="s2">\n          </span><span class="s1">throw getInternalRouterError(405, {</span><span class="s2">\n            </span><span class="s1">method: request.method,</span><span class="s2">\n            </span><span class="s1">pathname,</span><span class="s2">\n            </span><span class="s1">routeId: match.route.id</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">return { type: </span><span class="s2">\&quot;</span><span class="s1">data</span><span class="s2">\&quot; </span><span class="s1">/* data */, result: void 0 };</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else if (!handler) {</span><span class="s2">\n      </span><span class="s1">let url = new URL(request.url);</span><span class="s2">\n      </span><span class="s1">let pathname = url.pathname + url.search;</span><span class="s2">\n      </span><span class="s1">throw getInternalRouterError(404, {</span><span class="s2">\n        </span><span class="s1">pathname</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">result = await runHandler(handler);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">} catch (e) {</span><span class="s2">\n    </span><span class="s1">return { type: </span><span class="s2">\&quot;</span><span class="s1">error</span><span class="s2">\&quot; </span><span class="s1">/* error */, result: e };</span><span class="s2">\n  </span><span class="s1">} finally {</span><span class="s2">\n    </span><span class="s1">if (onReject) {</span><span class="s2">\n      </span><span class="s1">request.signal.removeEventListener(</span><span class="s2">\&quot;</span><span class="s1">abort</span><span class="s2">\&quot;</span><span class="s1">, onReject);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return result;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">async function convertDataStrategyResultToDataResult(dataStrategyResult) {</span><span class="s2">\n  </span><span class="s1">let { result, type } = dataStrategyResult;</span><span class="s2">\n  </span><span class="s1">if (isResponse(result)) {</span><span class="s2">\n    </span><span class="s1">let data2;</span><span class="s2">\n    </span><span class="s1">try {</span><span class="s2">\n      </span><span class="s1">let contentType = result.headers.get(</span><span class="s2">\&quot;</span><span class="s1">Content-Type</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">if (contentType &amp;&amp; /</span><span class="s2">\\</span><span class="s1">bapplication</span><span class="s2">\\</span><span class="s1">/json</span><span class="s2">\\</span><span class="s1">b/.test(contentType)) {</span><span class="s2">\n        </span><span class="s1">if (result.body == null) {</span><span class="s2">\n          </span><span class="s1">data2 = null;</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">data2 = await result.json();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">data2 = await result.text();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} catch (e) {</span><span class="s2">\n      </span><span class="s1">return { type: </span><span class="s2">\&quot;</span><span class="s1">error</span><span class="s2">\&quot; </span><span class="s1">/* error */, error: e };</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (type === </span><span class="s2">\&quot;</span><span class="s1">error</span><span class="s2">\&quot; </span><span class="s1">/* error */) {</span><span class="s2">\n      </span><span class="s1">return {</span><span class="s2">\n        </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">error</span><span class="s2">\&quot; </span><span class="s1">/* error */,</span><span class="s2">\n        </span><span class="s1">error: new ErrorResponseImpl(result.status, result.statusText, data2),</span><span class="s2">\n        </span><span class="s1">statusCode: result.status,</span><span class="s2">\n        </span><span class="s1">headers: result.headers</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return {</span><span class="s2">\n      </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">data</span><span class="s2">\&quot; </span><span class="s1">/* data */,</span><span class="s2">\n      </span><span class="s1">data: data2,</span><span class="s2">\n      </span><span class="s1">statusCode: result.status,</span><span class="s2">\n      </span><span class="s1">headers: result.headers</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (type === </span><span class="s2">\&quot;</span><span class="s1">error</span><span class="s2">\&quot; </span><span class="s1">/* error */) {</span><span class="s2">\n    </span><span class="s1">if (isDataWithResponseInit(result)) {</span><span class="s2">\n      </span><span class="s1">if (result.data instanceof Error) {</span><span class="s2">\n        </span><span class="s1">return {</span><span class="s2">\n          </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">error</span><span class="s2">\&quot; </span><span class="s1">/* error */,</span><span class="s2">\n          </span><span class="s1">error: result.data,</span><span class="s2">\n          </span><span class="s1">statusCode: result.init?.status,</span><span class="s2">\n          </span><span class="s1">headers: result.init?.headers ? new Headers(result.init.headers) : void 0</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return {</span><span class="s2">\n        </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">error</span><span class="s2">\&quot; </span><span class="s1">/* error */,</span><span class="s2">\n        </span><span class="s1">error: new ErrorResponseImpl(</span><span class="s2">\n          </span><span class="s1">result.init?.status || 500,</span><span class="s2">\n          </span><span class="s1">void 0,</span><span class="s2">\n          </span><span class="s1">result.data</span><span class="s2">\n        </span><span class="s1">),</span><span class="s2">\n        </span><span class="s1">statusCode: isRouteErrorResponse(result) ? result.status : void 0,</span><span class="s2">\n        </span><span class="s1">headers: result.init?.headers ? new Headers(result.init.headers) : void 0</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return {</span><span class="s2">\n      </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">error</span><span class="s2">\&quot; </span><span class="s1">/* error */,</span><span class="s2">\n      </span><span class="s1">error: result,</span><span class="s2">\n      </span><span class="s1">statusCode: isRouteErrorResponse(result) ? result.status : void 0</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (isDataWithResponseInit(result)) {</span><span class="s2">\n    </span><span class="s1">return {</span><span class="s2">\n      </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">data</span><span class="s2">\&quot; </span><span class="s1">/* data */,</span><span class="s2">\n      </span><span class="s1">data: result.data,</span><span class="s2">\n      </span><span class="s1">statusCode: result.init?.status,</span><span class="s2">\n      </span><span class="s1">headers: result.init?.headers ? new Headers(result.init.headers) : void 0</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return { type: </span><span class="s2">\&quot;</span><span class="s1">data</span><span class="s2">\&quot; </span><span class="s1">/* data */, data: result };</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function normalizeRelativeRoutingRedirectResponse(response, request, routeId, matches, basename) {</span><span class="s2">\n  </span><span class="s1">let location = response.headers.get(</span><span class="s2">\&quot;</span><span class="s1">Location</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">invariant(</span><span class="s2">\n    </span><span class="s1">location,</span><span class="s2">\n    \&quot;</span><span class="s1">Redirects returned/thrown from loaders/actions must have a Location header</span><span class="s2">\&quot;\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">if (!ABSOLUTE_URL_REGEX.test(location)) {</span><span class="s2">\n    </span><span class="s1">let trimmedMatches = matches.slice(</span><span class="s2">\n      </span><span class="s1">0,</span><span class="s2">\n      </span><span class="s1">matches.findIndex((m) =&gt; m.route.id === routeId) + 1</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">location = normalizeTo(</span><span class="s2">\n      </span><span class="s1">new URL(request.url),</span><span class="s2">\n      </span><span class="s1">trimmedMatches,</span><span class="s2">\n      </span><span class="s1">basename,</span><span class="s2">\n      </span><span class="s1">location</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">response.headers.set(</span><span class="s2">\&quot;</span><span class="s1">Location</span><span class="s2">\&quot;</span><span class="s1">, location);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return response;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function normalizeRedirectLocation(location, currentUrl, basename) {</span><span class="s2">\n  </span><span class="s1">if (ABSOLUTE_URL_REGEX.test(location)) {</span><span class="s2">\n    </span><span class="s1">let normalizedLocation = location;</span><span class="s2">\n    </span><span class="s1">let url = normalizedLocation.startsWith(</span><span class="s2">\&quot;</span><span class="s1">//</span><span class="s2">\&quot;</span><span class="s1">) ? new URL(currentUrl.protocol + normalizedLocation) : new URL(normalizedLocation);</span><span class="s2">\n    </span><span class="s1">let isSameBasename = stripBasename(url.pathname, basename) != null;</span><span class="s2">\n    </span><span class="s1">if (url.origin === currentUrl.origin &amp;&amp; isSameBasename) {</span><span class="s2">\n      </span><span class="s1">return url.pathname + url.search + url.hash;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return location;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createClientSideRequest(history, location, signal, submission) {</span><span class="s2">\n  </span><span class="s1">let url = history.createURL(stripHashFromPath(location)).toString();</span><span class="s2">\n  </span><span class="s1">let init = { signal };</span><span class="s2">\n  </span><span class="s1">if (submission &amp;&amp; isMutationMethod(submission.formMethod)) {</span><span class="s2">\n    </span><span class="s1">let { formMethod, formEncType } = submission;</span><span class="s2">\n    </span><span class="s1">init.method = formMethod.toUpperCase();</span><span class="s2">\n    </span><span class="s1">if (formEncType === </span><span class="s2">\&quot;</span><span class="s1">application/json</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">init.headers = new Headers({ </span><span class="s2">\&quot;</span><span class="s1">Content-Type</span><span class="s2">\&quot;</span><span class="s1">: formEncType });</span><span class="s2">\n      </span><span class="s1">init.body = JSON.stringify(submission.json);</span><span class="s2">\n    </span><span class="s1">} else if (formEncType === </span><span class="s2">\&quot;</span><span class="s1">text/plain</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">init.body = submission.text;</span><span class="s2">\n    </span><span class="s1">} else if (formEncType === </span><span class="s2">\&quot;</span><span class="s1">application/x-www-form-urlencoded</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; submission.formData) {</span><span class="s2">\n      </span><span class="s1">init.body = convertFormDataToSearchParams(submission.formData);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">init.body = submission.formData;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return new Request(url, init);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function convertFormDataToSearchParams(formData) {</span><span class="s2">\n  </span><span class="s1">let searchParams = new URLSearchParams();</span><span class="s2">\n  </span><span class="s1">for (let [key, value] of formData.entries()) {</span><span class="s2">\n    </span><span class="s1">searchParams.append(key, typeof value === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">? value : value.name);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return searchParams;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function convertSearchParamsToFormData(searchParams) {</span><span class="s2">\n  </span><span class="s1">let formData = new FormData();</span><span class="s2">\n  </span><span class="s1">for (let [key, value] of searchParams.entries()) {</span><span class="s2">\n    </span><span class="s1">formData.append(key, value);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return formData;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function processRouteLoaderData(matches, results, pendingActionResult, isStaticHandler = false, skipLoaderErrorBubbling = false) {</span><span class="s2">\n  </span><span class="s1">let loaderData = {};</span><span class="s2">\n  </span><span class="s1">let errors = null;</span><span class="s2">\n  </span><span class="s1">let statusCode;</span><span class="s2">\n  </span><span class="s1">let foundError = false;</span><span class="s2">\n  </span><span class="s1">let loaderHeaders = {};</span><span class="s2">\n  </span><span class="s1">let pendingError = pendingActionResult &amp;&amp; isErrorResult(pendingActionResult[1]) ? pendingActionResult[1].error : void 0;</span><span class="s2">\n  </span><span class="s1">matches.forEach((match) =&gt; {</span><span class="s2">\n    </span><span class="s1">if (!(match.route.id in results)) {</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let id = match.route.id;</span><span class="s2">\n    </span><span class="s1">let result = results[id];</span><span class="s2">\n    </span><span class="s1">invariant(</span><span class="s2">\n      </span><span class="s1">!isRedirectResult(result),</span><span class="s2">\n      \&quot;</span><span class="s1">Cannot handle redirect results in processLoaderData</span><span class="s2">\&quot;\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">if (isErrorResult(result)) {</span><span class="s2">\n      </span><span class="s1">let error = result.error;</span><span class="s2">\n      </span><span class="s1">if (pendingError !== void 0) {</span><span class="s2">\n        </span><span class="s1">error = pendingError;</span><span class="s2">\n        </span><span class="s1">pendingError = void 0;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">errors = errors || {};</span><span class="s2">\n      </span><span class="s1">if (skipLoaderErrorBubbling) {</span><span class="s2">\n        </span><span class="s1">errors[id] = error;</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">let boundaryMatch = findNearestBoundary(matches, id);</span><span class="s2">\n        </span><span class="s1">if (errors[boundaryMatch.route.id] == null) {</span><span class="s2">\n          </span><span class="s1">errors[boundaryMatch.route.id] = error;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (!isStaticHandler) {</span><span class="s2">\n        </span><span class="s1">loaderData[id] = ResetLoaderDataSymbol;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (!foundError) {</span><span class="s2">\n        </span><span class="s1">foundError = true;</span><span class="s2">\n        </span><span class="s1">statusCode = isRouteErrorResponse(result.error) ? result.error.status : 500;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (result.headers) {</span><span class="s2">\n        </span><span class="s1">loaderHeaders[id] = result.headers;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">loaderData[id] = result.data;</span><span class="s2">\n      </span><span class="s1">if (result.statusCode &amp;&amp; result.statusCode !== 200 &amp;&amp; !foundError) {</span><span class="s2">\n        </span><span class="s1">statusCode = result.statusCode;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (result.headers) {</span><span class="s2">\n        </span><span class="s1">loaderHeaders[id] = result.headers;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">if (pendingError !== void 0 &amp;&amp; pendingActionResult) {</span><span class="s2">\n    </span><span class="s1">errors = { [pendingActionResult[0]]: pendingError };</span><span class="s2">\n    </span><span class="s1">if (pendingActionResult[2]) {</span><span class="s2">\n      </span><span class="s1">loaderData[pendingActionResult[2]] = void 0;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">loaderData,</span><span class="s2">\n    </span><span class="s1">errors,</span><span class="s2">\n    </span><span class="s1">statusCode: statusCode || 200,</span><span class="s2">\n    </span><span class="s1">loaderHeaders</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function processLoaderData(state, matches, results, pendingActionResult, revalidatingFetchers, fetcherResults) {</span><span class="s2">\n  </span><span class="s1">let { loaderData, errors } = processRouteLoaderData(</span><span class="s2">\n    </span><span class="s1">matches,</span><span class="s2">\n    </span><span class="s1">results,</span><span class="s2">\n    </span><span class="s1">pendingActionResult</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">revalidatingFetchers.filter((f) =&gt; !f.matches || f.matches.some((m) =&gt; m.shouldLoad)).forEach((rf) =&gt; {</span><span class="s2">\n    </span><span class="s1">let { key, match, controller } = rf;</span><span class="s2">\n    </span><span class="s1">let result = fetcherResults[key];</span><span class="s2">\n    </span><span class="s1">invariant(result, </span><span class="s2">\&quot;</span><span class="s1">Did not find corresponding fetcher result</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">if (controller &amp;&amp; controller.signal.aborted) {</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">} else if (isErrorResult(result)) {</span><span class="s2">\n      </span><span class="s1">let boundaryMatch = findNearestBoundary(state.matches, match?.route.id);</span><span class="s2">\n      </span><span class="s1">if (!(errors &amp;&amp; errors[boundaryMatch.route.id])) {</span><span class="s2">\n        </span><span class="s1">errors = {</span><span class="s2">\n          </span><span class="s1">...errors,</span><span class="s2">\n          </span><span class="s1">[boundaryMatch.route.id]: result.error</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">state.fetchers.delete(key);</span><span class="s2">\n    </span><span class="s1">} else if (isRedirectResult(result)) {</span><span class="s2">\n      </span><span class="s1">invariant(false, </span><span class="s2">\&quot;</span><span class="s1">Unhandled fetcher revalidation redirect</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">let doneFetcher = getDoneFetcher(result.data);</span><span class="s2">\n      </span><span class="s1">state.fetchers.set(key, doneFetcher);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">return { loaderData, errors };</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function mergeLoaderData(loaderData, newLoaderData, matches, errors) {</span><span class="s2">\n  </span><span class="s1">let mergedLoaderData = Object.entries(newLoaderData).filter(([, v]) =&gt; v !== ResetLoaderDataSymbol).reduce((merged, [k, v]) =&gt; {</span><span class="s2">\n    </span><span class="s1">merged[k] = v;</span><span class="s2">\n    </span><span class="s1">return merged;</span><span class="s2">\n  </span><span class="s1">}, {});</span><span class="s2">\n  </span><span class="s1">for (let match of matches) {</span><span class="s2">\n    </span><span class="s1">let id = match.route.id;</span><span class="s2">\n    </span><span class="s1">if (!newLoaderData.hasOwnProperty(id) &amp;&amp; loaderData.hasOwnProperty(id) &amp;&amp; match.route.loader) {</span><span class="s2">\n      </span><span class="s1">mergedLoaderData[id] = loaderData[id];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (errors &amp;&amp; errors.hasOwnProperty(id)) {</span><span class="s2">\n      </span><span class="s1">break;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return mergedLoaderData;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getActionDataForCommit(pendingActionResult) {</span><span class="s2">\n  </span><span class="s1">if (!pendingActionResult) {</span><span class="s2">\n    </span><span class="s1">return {};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return isErrorResult(pendingActionResult[1]) ? {</span><span class="s2">\n    </span><span class="s1">// Clear out prior actionData on errors</span><span class="s2">\n    </span><span class="s1">actionData: {}</span><span class="s2">\n  </span><span class="s1">} : {</span><span class="s2">\n    </span><span class="s1">actionData: {</span><span class="s2">\n      </span><span class="s1">[pendingActionResult[0]]: pendingActionResult[1].data</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function findNearestBoundary(matches, routeId) {</span><span class="s2">\n  </span><span class="s1">let eligibleMatches = routeId ? matches.slice(0, matches.findIndex((m) =&gt; m.route.id === routeId) + 1) : [...matches];</span><span class="s2">\n  </span><span class="s1">return eligibleMatches.reverse().find((m) =&gt; m.route.hasErrorBoundary === true) || matches[0];</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getShortCircuitMatches(routes) {</span><span class="s2">\n  </span><span class="s1">let route = routes.length === 1 ? routes[0] : routes.find((r) =&gt; r.index || !r.path || r.path === </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">) || {</span><span class="s2">\n    </span><span class="s1">id: `__shim-error-route__`</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">matches: [</span><span class="s2">\n      </span><span class="s1">{</span><span class="s2">\n        </span><span class="s1">params: {},</span><span class="s2">\n        </span><span class="s1">pathname: </span><span class="s2">\&quot;\&quot;</span><span class="s1">,</span><span class="s2">\n        </span><span class="s1">pathnameBase: </span><span class="s2">\&quot;\&quot;</span><span class="s1">,</span><span class="s2">\n        </span><span class="s1">route</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">],</span><span class="s2">\n    </span><span class="s1">route</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getInternalRouterError(status, {</span><span class="s2">\n  </span><span class="s1">pathname,</span><span class="s2">\n  </span><span class="s1">routeId,</span><span class="s2">\n  </span><span class="s1">method,</span><span class="s2">\n  </span><span class="s1">type,</span><span class="s2">\n  </span><span class="s1">message</span><span class="s2">\n</span><span class="s1">} = {}) {</span><span class="s2">\n  </span><span class="s1">let statusText = </span><span class="s2">\&quot;</span><span class="s1">Unknown Server Error</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">let errorMessage = </span><span class="s2">\&quot;</span><span class="s1">Unknown @remix-run/router error</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">if (status === 400) {</span><span class="s2">\n    </span><span class="s1">statusText = </span><span class="s2">\&quot;</span><span class="s1">Bad Request</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">if (method &amp;&amp; pathname &amp;&amp; routeId) {</span><span class="s2">\n      </span><span class="s1">errorMessage = `You made a ${method} request to </span><span class="s2">\&quot;</span><span class="s1">${pathname}</span><span class="s2">\&quot; </span><span class="s1">but did not provide a </span><span class="s2">\\</span><span class="s1">`loader</span><span class="s2">\\</span><span class="s1">` for route </span><span class="s2">\&quot;</span><span class="s1">${routeId}</span><span class="s2">\&quot;</span><span class="s1">, so there is no way to handle the request.`;</span><span class="s2">\n    </span><span class="s1">} else if (type === </span><span class="s2">\&quot;</span><span class="s1">invalid-body</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">errorMessage = </span><span class="s2">\&quot;</span><span class="s1">Unable to encode submission body</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">} else if (status === 403) {</span><span class="s2">\n    </span><span class="s1">statusText = </span><span class="s2">\&quot;</span><span class="s1">Forbidden</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">errorMessage = `Route </span><span class="s2">\&quot;</span><span class="s1">${routeId}</span><span class="s2">\&quot; </span><span class="s1">does not match URL </span><span class="s2">\&quot;</span><span class="s1">${pathname}</span><span class="s2">\&quot;</span><span class="s1">`;</span><span class="s2">\n  </span><span class="s1">} else if (status === 404) {</span><span class="s2">\n    </span><span class="s1">statusText = </span><span class="s2">\&quot;</span><span class="s1">Not Found</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">errorMessage = `No route matches URL </span><span class="s2">\&quot;</span><span class="s1">${pathname}</span><span class="s2">\&quot;</span><span class="s1">`;</span><span class="s2">\n  </span><span class="s1">} else if (status === 405) {</span><span class="s2">\n    </span><span class="s1">statusText = </span><span class="s2">\&quot;</span><span class="s1">Method Not Allowed</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">if (method &amp;&amp; pathname &amp;&amp; routeId) {</span><span class="s2">\n      </span><span class="s1">errorMessage = `You made a ${method.toUpperCase()} request to </span><span class="s2">\&quot;</span><span class="s1">${pathname}</span><span class="s2">\&quot; </span><span class="s1">but did not provide an </span><span class="s2">\\</span><span class="s1">`action</span><span class="s2">\\</span><span class="s1">` for route </span><span class="s2">\&quot;</span><span class="s1">${routeId}</span><span class="s2">\&quot;</span><span class="s1">, so there is no way to handle the request.`;</span><span class="s2">\n    </span><span class="s1">} else if (method) {</span><span class="s2">\n      </span><span class="s1">errorMessage = `Invalid request method </span><span class="s2">\&quot;</span><span class="s1">${method.toUpperCase()}</span><span class="s2">\&quot;</span><span class="s1">`;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return new ErrorResponseImpl(</span><span class="s2">\n    </span><span class="s1">status || 500,</span><span class="s2">\n    </span><span class="s1">statusText,</span><span class="s2">\n    </span><span class="s1">new Error(errorMessage),</span><span class="s2">\n    </span><span class="s1">true</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function findRedirect(results) {</span><span class="s2">\n  </span><span class="s1">let entries = Object.entries(results);</span><span class="s2">\n  </span><span class="s1">for (let i = entries.length - 1; i &gt;= 0; i--) {</span><span class="s2">\n    </span><span class="s1">let [key, result] = entries[i];</span><span class="s2">\n    </span><span class="s1">if (isRedirectResult(result)) {</span><span class="s2">\n      </span><span class="s1">return { key, result };</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function stripHashFromPath(path) {</span><span class="s2">\n  </span><span class="s1">let parsedPath = typeof path === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">? parsePath(path) : path;</span><span class="s2">\n  </span><span class="s1">return createPath({ ...parsedPath, hash: </span><span class="s2">\&quot;\&quot; </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isHashChangeOnly(a, b) {</span><span class="s2">\n  </span><span class="s1">if (a.pathname !== b.pathname || a.search !== b.search) {</span><span class="s2">\n    </span><span class="s1">return false;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (a.hash === </span><span class="s2">\&quot;\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">return b.hash !== </span><span class="s2">\&quot;\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">} else if (a.hash === b.hash) {</span><span class="s2">\n    </span><span class="s1">return true;</span><span class="s2">\n  </span><span class="s1">} else if (b.hash !== </span><span class="s2">\&quot;\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">return true;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return false;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isDataStrategyResult(result) {</span><span class="s2">\n  </span><span class="s1">return result != null &amp;&amp; typeof result === </span><span class="s2">\&quot;</span><span class="s1">object</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; </span><span class="s2">\&quot;</span><span class="s1">type</span><span class="s2">\&quot; </span><span class="s1">in result &amp;&amp; </span><span class="s2">\&quot;</span><span class="s1">result</span><span class="s2">\&quot; </span><span class="s1">in result &amp;&amp; (result.type === </span><span class="s2">\&quot;</span><span class="s1">data</span><span class="s2">\&quot; </span><span class="s1">/* data */ || result.type === </span><span class="s2">\&quot;</span><span class="s1">error</span><span class="s2">\&quot; </span><span class="s1">/* error */);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isRedirectDataStrategyResult(result) {</span><span class="s2">\n  </span><span class="s1">return isResponse(result.result) &amp;&amp; redirectStatusCodes.has(result.result.status);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isErrorResult(result) {</span><span class="s2">\n  </span><span class="s1">return result.type === </span><span class="s2">\&quot;</span><span class="s1">error</span><span class="s2">\&quot; </span><span class="s1">/* error */;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isRedirectResult(result) {</span><span class="s2">\n  </span><span class="s1">return (result &amp;&amp; result.type) === </span><span class="s2">\&quot;</span><span class="s1">redirect</span><span class="s2">\&quot; </span><span class="s1">/* redirect */;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isDataWithResponseInit(value) {</span><span class="s2">\n  </span><span class="s1">return typeof value === </span><span class="s2">\&quot;</span><span class="s1">object</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; value != null &amp;&amp; </span><span class="s2">\&quot;</span><span class="s1">type</span><span class="s2">\&quot; </span><span class="s1">in value &amp;&amp; </span><span class="s2">\&quot;</span><span class="s1">data</span><span class="s2">\&quot; </span><span class="s1">in value &amp;&amp; </span><span class="s2">\&quot;</span><span class="s1">init</span><span class="s2">\&quot; </span><span class="s1">in value &amp;&amp; value.type === </span><span class="s2">\&quot;</span><span class="s1">DataWithResponseInit</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isResponse(value) {</span><span class="s2">\n  </span><span class="s1">return value != null &amp;&amp; typeof value.status === </span><span class="s2">\&quot;</span><span class="s1">number</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; typeof value.statusText === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; typeof value.headers === </span><span class="s2">\&quot;</span><span class="s1">object</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; typeof value.body !== </span><span class="s2">\&quot;</span><span class="s1">undefined</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isRedirectStatusCode(statusCode) {</span><span class="s2">\n  </span><span class="s1">return redirectStatusCodes.has(statusCode);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isRedirectResponse(result) {</span><span class="s2">\n  </span><span class="s1">return isResponse(result) &amp;&amp; isRedirectStatusCode(result.status) &amp;&amp; result.headers.has(</span><span class="s2">\&quot;</span><span class="s1">Location</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isValidMethod(method) {</span><span class="s2">\n  </span><span class="s1">return validRequestMethods.has(method.toUpperCase());</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isMutationMethod(method) {</span><span class="s2">\n  </span><span class="s1">return validMutationMethods.has(method.toUpperCase());</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function hasNakedIndexQuery(search) {</span><span class="s2">\n  </span><span class="s1">return new URLSearchParams(search).getAll(</span><span class="s2">\&quot;</span><span class="s1">index</span><span class="s2">\&quot;</span><span class="s1">).some((v) =&gt; v === </span><span class="s2">\&quot;\&quot;</span><span class="s1">);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getTargetMatch(matches, location) {</span><span class="s2">\n  </span><span class="s1">let search = typeof location === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">? parsePath(location).search : location.search;</span><span class="s2">\n  </span><span class="s1">if (matches[matches.length - 1].route.index &amp;&amp; hasNakedIndexQuery(search || </span><span class="s2">\&quot;\&quot;</span><span class="s1">)) {</span><span class="s2">\n    </span><span class="s1">return matches[matches.length - 1];</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let pathMatches = getPathContributingMatches(matches);</span><span class="s2">\n  </span><span class="s1">return pathMatches[pathMatches.length - 1];</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getSubmissionFromNavigation(navigation) {</span><span class="s2">\n  </span><span class="s1">let { formMethod, formAction, formEncType, text, formData, json } = navigation;</span><span class="s2">\n  </span><span class="s1">if (!formMethod || !formAction || !formEncType) {</span><span class="s2">\n    </span><span class="s1">return;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (text != null) {</span><span class="s2">\n    </span><span class="s1">return {</span><span class="s2">\n      </span><span class="s1">formMethod,</span><span class="s2">\n      </span><span class="s1">formAction,</span><span class="s2">\n      </span><span class="s1">formEncType,</span><span class="s2">\n      </span><span class="s1">formData: void 0,</span><span class="s2">\n      </span><span class="s1">json: void 0,</span><span class="s2">\n      </span><span class="s1">text</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">} else if (formData != null) {</span><span class="s2">\n    </span><span class="s1">return {</span><span class="s2">\n      </span><span class="s1">formMethod,</span><span class="s2">\n      </span><span class="s1">formAction,</span><span class="s2">\n      </span><span class="s1">formEncType,</span><span class="s2">\n      </span><span class="s1">formData,</span><span class="s2">\n      </span><span class="s1">json: void 0,</span><span class="s2">\n      </span><span class="s1">text: void 0</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">} else if (json !== void 0) {</span><span class="s2">\n    </span><span class="s1">return {</span><span class="s2">\n      </span><span class="s1">formMethod,</span><span class="s2">\n      </span><span class="s1">formAction,</span><span class="s2">\n      </span><span class="s1">formEncType,</span><span class="s2">\n      </span><span class="s1">formData: void 0,</span><span class="s2">\n      </span><span class="s1">json,</span><span class="s2">\n      </span><span class="s1">text: void 0</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getLoadingNavigation(location, submission) {</span><span class="s2">\n  </span><span class="s1">if (submission) {</span><span class="s2">\n    </span><span class="s1">let navigation = {</span><span class="s2">\n      </span><span class="s1">state: </span><span class="s2">\&quot;</span><span class="s1">loading</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">location,</span><span class="s2">\n      </span><span class="s1">formMethod: submission.formMethod,</span><span class="s2">\n      </span><span class="s1">formAction: submission.formAction,</span><span class="s2">\n      </span><span class="s1">formEncType: submission.formEncType,</span><span class="s2">\n      </span><span class="s1">formData: submission.formData,</span><span class="s2">\n      </span><span class="s1">json: submission.json,</span><span class="s2">\n      </span><span class="s1">text: submission.text</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">return navigation;</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">let navigation = {</span><span class="s2">\n      </span><span class="s1">state: </span><span class="s2">\&quot;</span><span class="s1">loading</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">location,</span><span class="s2">\n      </span><span class="s1">formMethod: void 0,</span><span class="s2">\n      </span><span class="s1">formAction: void 0,</span><span class="s2">\n      </span><span class="s1">formEncType: void 0,</span><span class="s2">\n      </span><span class="s1">formData: void 0,</span><span class="s2">\n      </span><span class="s1">json: void 0,</span><span class="s2">\n      </span><span class="s1">text: void 0</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">return navigation;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getSubmittingNavigation(location, submission) {</span><span class="s2">\n  </span><span class="s1">let navigation = {</span><span class="s2">\n    </span><span class="s1">state: </span><span class="s2">\&quot;</span><span class="s1">submitting</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">location,</span><span class="s2">\n    </span><span class="s1">formMethod: submission.formMethod,</span><span class="s2">\n    </span><span class="s1">formAction: submission.formAction,</span><span class="s2">\n    </span><span class="s1">formEncType: submission.formEncType,</span><span class="s2">\n    </span><span class="s1">formData: submission.formData,</span><span class="s2">\n    </span><span class="s1">json: submission.json,</span><span class="s2">\n    </span><span class="s1">text: submission.text</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">return navigation;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getLoadingFetcher(submission, data2) {</span><span class="s2">\n  </span><span class="s1">if (submission) {</span><span class="s2">\n    </span><span class="s1">let fetcher = {</span><span class="s2">\n      </span><span class="s1">state: </span><span class="s2">\&quot;</span><span class="s1">loading</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">formMethod: submission.formMethod,</span><span class="s2">\n      </span><span class="s1">formAction: submission.formAction,</span><span class="s2">\n      </span><span class="s1">formEncType: submission.formEncType,</span><span class="s2">\n      </span><span class="s1">formData: submission.formData,</span><span class="s2">\n      </span><span class="s1">json: submission.json,</span><span class="s2">\n      </span><span class="s1">text: submission.text,</span><span class="s2">\n      </span><span class="s1">data: data2</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">return fetcher;</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">let fetcher = {</span><span class="s2">\n      </span><span class="s1">state: </span><span class="s2">\&quot;</span><span class="s1">loading</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">formMethod: void 0,</span><span class="s2">\n      </span><span class="s1">formAction: void 0,</span><span class="s2">\n      </span><span class="s1">formEncType: void 0,</span><span class="s2">\n      </span><span class="s1">formData: void 0,</span><span class="s2">\n      </span><span class="s1">json: void 0,</span><span class="s2">\n      </span><span class="s1">text: void 0,</span><span class="s2">\n      </span><span class="s1">data: data2</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">return fetcher;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getSubmittingFetcher(submission, existingFetcher) {</span><span class="s2">\n  </span><span class="s1">let fetcher = {</span><span class="s2">\n    </span><span class="s1">state: </span><span class="s2">\&quot;</span><span class="s1">submitting</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">formMethod: submission.formMethod,</span><span class="s2">\n    </span><span class="s1">formAction: submission.formAction,</span><span class="s2">\n    </span><span class="s1">formEncType: submission.formEncType,</span><span class="s2">\n    </span><span class="s1">formData: submission.formData,</span><span class="s2">\n    </span><span class="s1">json: submission.json,</span><span class="s2">\n    </span><span class="s1">text: submission.text,</span><span class="s2">\n    </span><span class="s1">data: existingFetcher ? existingFetcher.data : void 0</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">return fetcher;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getDoneFetcher(data2) {</span><span class="s2">\n  </span><span class="s1">let fetcher = {</span><span class="s2">\n    </span><span class="s1">state: </span><span class="s2">\&quot;</span><span class="s1">idle</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">formMethod: void 0,</span><span class="s2">\n    </span><span class="s1">formAction: void 0,</span><span class="s2">\n    </span><span class="s1">formEncType: void 0,</span><span class="s2">\n    </span><span class="s1">formData: void 0,</span><span class="s2">\n    </span><span class="s1">json: void 0,</span><span class="s2">\n    </span><span class="s1">text: void 0,</span><span class="s2">\n    </span><span class="s1">data: data2</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">return fetcher;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function restoreAppliedTransitions(_window, transitions) {</span><span class="s2">\n  </span><span class="s1">try {</span><span class="s2">\n    </span><span class="s1">let sessionPositions = _window.sessionStorage.getItem(</span><span class="s2">\n      </span><span class="s1">TRANSITIONS_STORAGE_KEY</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">if (sessionPositions) {</span><span class="s2">\n      </span><span class="s1">let json = JSON.parse(sessionPositions);</span><span class="s2">\n      </span><span class="s1">for (let [k, v] of Object.entries(json || {})) {</span><span class="s2">\n        </span><span class="s1">if (v &amp;&amp; Array.isArray(v)) {</span><span class="s2">\n          </span><span class="s1">transitions.set(k, new Set(v || []));</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">} catch (e) {</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function persistAppliedTransitions(_window, transitions) {</span><span class="s2">\n  </span><span class="s1">if (transitions.size &gt; 0) {</span><span class="s2">\n    </span><span class="s1">let json = {};</span><span class="s2">\n    </span><span class="s1">for (let [k, v] of transitions) {</span><span class="s2">\n      </span><span class="s1">json[k] = [...v];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">try {</span><span class="s2">\n      </span><span class="s1">_window.sessionStorage.setItem(</span><span class="s2">\n        </span><span class="s1">TRANSITIONS_STORAGE_KEY,</span><span class="s2">\n        </span><span class="s1">JSON.stringify(json)</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">} catch (error) {</span><span class="s2">\n      </span><span class="s1">warning(</span><span class="s2">\n        </span><span class="s1">false,</span><span class="s2">\n        </span><span class="s1">`Failed to save applied view transitions in sessionStorage (${error}).`</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createDeferred() {</span><span class="s2">\n  </span><span class="s1">let resolve;</span><span class="s2">\n  </span><span class="s1">let reject;</span><span class="s2">\n  </span><span class="s1">let promise = new Promise((res, rej) =&gt; {</span><span class="s2">\n    </span><span class="s1">resolve = async (val) =&gt; {</span><span class="s2">\n      </span><span class="s1">res(val);</span><span class="s2">\n      </span><span class="s1">try {</span><span class="s2">\n        </span><span class="s1">await promise;</span><span class="s2">\n      </span><span class="s1">} catch (e) {</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">reject = async (error) =&gt; {</span><span class="s2">\n      </span><span class="s1">rej(error);</span><span class="s2">\n      </span><span class="s1">try {</span><span class="s2">\n        </span><span class="s1">await promise;</span><span class="s2">\n      </span><span class="s1">} catch (e) {</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">promise,</span><span class="s2">\n    </span><span class="s1">//@ts-ignore</span><span class="s2">\n    </span><span class="s1">resolve,</span><span class="s2">\n    </span><span class="s1">//@ts-ignore</span><span class="s2">\n    </span><span class="s1">reject</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/components.tsx</span><span class="s2">\n</span><span class="s1">import * as React3 from </span><span class="s2">\&quot;</span><span class="s1">react</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n</span><span class="s1">// lib/context.ts</span><span class="s2">\n</span><span class="s1">import * as React from </span><span class="s2">\&quot;</span><span class="s1">react</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">var DataRouterContext = React.createContext(null);</span><span class="s2">\n</span><span class="s1">DataRouterContext.displayName = </span><span class="s2">\&quot;</span><span class="s1">DataRouter</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">var DataRouterStateContext = React.createContext(null);</span><span class="s2">\n</span><span class="s1">DataRouterStateContext.displayName = </span><span class="s2">\&quot;</span><span class="s1">DataRouterState</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">var ViewTransitionContext = React.createContext({</span><span class="s2">\n  </span><span class="s1">isTransitioning: false</span><span class="s2">\n</span><span class="s1">});</span><span class="s2">\n</span><span class="s1">ViewTransitionContext.displayName = </span><span class="s2">\&quot;</span><span class="s1">ViewTransition</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">var FetchersContext = React.createContext(</span><span class="s2">\n  </span><span class="s1">/* @__PURE__ */ new Map()</span><span class="s2">\n</span><span class="s1">);</span><span class="s2">\n</span><span class="s1">FetchersContext.displayName = </span><span class="s2">\&quot;</span><span class="s1">Fetchers</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">var AwaitContext = React.createContext(null);</span><span class="s2">\n</span><span class="s1">AwaitContext.displayName = </span><span class="s2">\&quot;</span><span class="s1">Await</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">var NavigationContext = React.createContext(</span><span class="s2">\n  </span><span class="s1">null</span><span class="s2">\n</span><span class="s1">);</span><span class="s2">\n</span><span class="s1">NavigationContext.displayName = </span><span class="s2">\&quot;</span><span class="s1">Navigation</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">var LocationContext = React.createContext(</span><span class="s2">\n  </span><span class="s1">null</span><span class="s2">\n</span><span class="s1">);</span><span class="s2">\n</span><span class="s1">LocationContext.displayName = </span><span class="s2">\&quot;</span><span class="s1">Location</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">var RouteContext = React.createContext({</span><span class="s2">\n  </span><span class="s1">outlet: null,</span><span class="s2">\n  </span><span class="s1">matches: [],</span><span class="s2">\n  </span><span class="s1">isDataRoute: false</span><span class="s2">\n</span><span class="s1">});</span><span class="s2">\n</span><span class="s1">RouteContext.displayName = </span><span class="s2">\&quot;</span><span class="s1">Route</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">var RouteErrorContext = React.createContext(null);</span><span class="s2">\n</span><span class="s1">RouteErrorContext.displayName = </span><span class="s2">\&quot;</span><span class="s1">RouteError</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">var ENABLE_DEV_WARNINGS = true;</span><span class="s2">\n\n</span><span class="s1">// lib/hooks.tsx</span><span class="s2">\n</span><span class="s1">import * as React2 from </span><span class="s2">\&quot;</span><span class="s1">react</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">function useHref(to, { relative } = {}) {</span><span class="s2">\n  </span><span class="s1">invariant(</span><span class="s2">\n    </span><span class="s1">useInRouterContext(),</span><span class="s2">\n    </span><span class="s1">// TODO: This error is probably because they somehow have 2 versions of the</span><span class="s2">\n    </span><span class="s1">// router loaded. We can help them understand how to avoid that.</span><span class="s2">\n    </span><span class="s1">`useHref() may be used only in the context of a &lt;Router&gt; component.`</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let { basename, navigator } = React2.useContext(NavigationContext);</span><span class="s2">\n  </span><span class="s1">let { hash, pathname, search } = useResolvedPath(to, { relative });</span><span class="s2">\n  </span><span class="s1">let joinedPathname = pathname;</span><span class="s2">\n  </span><span class="s1">if (basename !== </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">joinedPathname = pathname === </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot; </span><span class="s1">? basename : joinPaths([basename, pathname]);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return navigator.createHref({ pathname: joinedPathname, search, hash });</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useInRouterContext() {</span><span class="s2">\n  </span><span class="s1">return React2.useContext(LocationContext) != null;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useLocation() {</span><span class="s2">\n  </span><span class="s1">invariant(</span><span class="s2">\n    </span><span class="s1">useInRouterContext(),</span><span class="s2">\n    </span><span class="s1">// TODO: This error is probably because they somehow have 2 versions of the</span><span class="s2">\n    </span><span class="s1">// router loaded. We can help them understand how to avoid that.</span><span class="s2">\n    </span><span class="s1">`useLocation() may be used only in the context of a &lt;Router&gt; component.`</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">return React2.useContext(LocationContext).location;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useNavigationType() {</span><span class="s2">\n  </span><span class="s1">return React2.useContext(LocationContext).navigationType;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useMatch(pattern) {</span><span class="s2">\n  </span><span class="s1">invariant(</span><span class="s2">\n    </span><span class="s1">useInRouterContext(),</span><span class="s2">\n    </span><span class="s1">// TODO: This error is probably because they somehow have 2 versions of the</span><span class="s2">\n    </span><span class="s1">// router loaded. We can help them understand how to avoid that.</span><span class="s2">\n    </span><span class="s1">`useMatch() may be used only in the context of a &lt;Router&gt; component.`</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let { pathname } = useLocation();</span><span class="s2">\n  </span><span class="s1">return React2.useMemo(</span><span class="s2">\n    </span><span class="s1">() =&gt; matchPath(pattern, decodePath(pathname)),</span><span class="s2">\n    </span><span class="s1">[pathname, pattern]</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var navigateEffectWarning = `You should call navigate() in a React.useEffect(), not when your component is first rendered.`;</span><span class="s2">\n</span><span class="s1">function useIsomorphicLayoutEffect(cb) {</span><span class="s2">\n  </span><span class="s1">let isStatic = React2.useContext(NavigationContext).static;</span><span class="s2">\n  </span><span class="s1">if (!isStatic) {</span><span class="s2">\n    </span><span class="s1">React2.useLayoutEffect(cb);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useNavigate() {</span><span class="s2">\n  </span><span class="s1">let { isDataRoute } = React2.useContext(RouteContext);</span><span class="s2">\n  </span><span class="s1">return isDataRoute ? useNavigateStable() : useNavigateUnstable();</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useNavigateUnstable() {</span><span class="s2">\n  </span><span class="s1">invariant(</span><span class="s2">\n    </span><span class="s1">useInRouterContext(),</span><span class="s2">\n    </span><span class="s1">// TODO: This error is probably because they somehow have 2 versions of the</span><span class="s2">\n    </span><span class="s1">// router loaded. We can help them understand how to avoid that.</span><span class="s2">\n    </span><span class="s1">`useNavigate() may be used only in the context of a &lt;Router&gt; component.`</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let dataRouterContext = React2.useContext(DataRouterContext);</span><span class="s2">\n  </span><span class="s1">let { basename, navigator } = React2.useContext(NavigationContext);</span><span class="s2">\n  </span><span class="s1">let { matches } = React2.useContext(RouteContext);</span><span class="s2">\n  </span><span class="s1">let { pathname: locationPathname } = useLocation();</span><span class="s2">\n  </span><span class="s1">let routePathnamesJson = JSON.stringify(getResolveToMatches(matches));</span><span class="s2">\n  </span><span class="s1">let activeRef = React2.useRef(false);</span><span class="s2">\n  </span><span class="s1">useIsomorphicLayoutEffect(() =&gt; {</span><span class="s2">\n    </span><span class="s1">activeRef.current = true;</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">let navigate = React2.useCallback(</span><span class="s2">\n    </span><span class="s1">(to, options = {}) =&gt; {</span><span class="s2">\n      </span><span class="s1">warning(activeRef.current, navigateEffectWarning);</span><span class="s2">\n      </span><span class="s1">if (!activeRef.current) return;</span><span class="s2">\n      </span><span class="s1">if (typeof to === </span><span class="s2">\&quot;</span><span class="s1">number</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">navigator.go(to);</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">let path = resolveTo(</span><span class="s2">\n        </span><span class="s1">to,</span><span class="s2">\n        </span><span class="s1">JSON.parse(routePathnamesJson),</span><span class="s2">\n        </span><span class="s1">locationPathname,</span><span class="s2">\n        </span><span class="s1">options.relative === </span><span class="s2">\&quot;</span><span class="s1">path</span><span class="s2">\&quot;\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">if (dataRouterContext == null &amp;&amp; basename !== </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">path.pathname = path.pathname === </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot; </span><span class="s1">? basename : joinPaths([basename, path.pathname]);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">(!!options.replace ? navigator.replace : navigator.push)(</span><span class="s2">\n        </span><span class="s1">path,</span><span class="s2">\n        </span><span class="s1">options.state,</span><span class="s2">\n        </span><span class="s1">options</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">[</span><span class="s2">\n      </span><span class="s1">basename,</span><span class="s2">\n      </span><span class="s1">navigator,</span><span class="s2">\n      </span><span class="s1">routePathnamesJson,</span><span class="s2">\n      </span><span class="s1">locationPathname,</span><span class="s2">\n      </span><span class="s1">dataRouterContext</span><span class="s2">\n    </span><span class="s1">]</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">return navigate;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var OutletContext = React2.createContext(null);</span><span class="s2">\n</span><span class="s1">function useOutletContext() {</span><span class="s2">\n  </span><span class="s1">return React2.useContext(OutletContext);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useOutlet(context) {</span><span class="s2">\n  </span><span class="s1">let outlet = React2.useContext(RouteContext).outlet;</span><span class="s2">\n  </span><span class="s1">if (outlet) {</span><span class="s2">\n    </span><span class="s1">return /* @__PURE__ */ React2.createElement(OutletContext.Provider, { value: context }, outlet);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return outlet;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useParams() {</span><span class="s2">\n  </span><span class="s1">let { matches } = React2.useContext(RouteContext);</span><span class="s2">\n  </span><span class="s1">let routeMatch = matches[matches.length - 1];</span><span class="s2">\n  </span><span class="s1">return routeMatch ? routeMatch.params : {};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useResolvedPath(to, { relative } = {}) {</span><span class="s2">\n  </span><span class="s1">let { matches } = React2.useContext(RouteContext);</span><span class="s2">\n  </span><span class="s1">let { pathname: locationPathname } = useLocation();</span><span class="s2">\n  </span><span class="s1">let routePathnamesJson = JSON.stringify(getResolveToMatches(matches));</span><span class="s2">\n  </span><span class="s1">return React2.useMemo(</span><span class="s2">\n    </span><span class="s1">() =&gt; resolveTo(</span><span class="s2">\n      </span><span class="s1">to,</span><span class="s2">\n      </span><span class="s1">JSON.parse(routePathnamesJson),</span><span class="s2">\n      </span><span class="s1">locationPathname,</span><span class="s2">\n      </span><span class="s1">relative === </span><span class="s2">\&quot;</span><span class="s1">path</span><span class="s2">\&quot;\n    </span><span class="s1">),</span><span class="s2">\n    </span><span class="s1">[to, routePathnamesJson, locationPathname, relative]</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useRoutes(routes, locationArg) {</span><span class="s2">\n  </span><span class="s1">return useRoutesImpl(routes, locationArg);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useRoutesImpl(routes, locationArg, dataRouterState, future) {</span><span class="s2">\n  </span><span class="s1">invariant(</span><span class="s2">\n    </span><span class="s1">useInRouterContext(),</span><span class="s2">\n    </span><span class="s1">// TODO: This error is probably because they somehow have 2 versions of the</span><span class="s2">\n    </span><span class="s1">// router loaded. We can help them understand how to avoid that.</span><span class="s2">\n    </span><span class="s1">`useRoutes() may be used only in the context of a &lt;Router&gt; component.`</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let { navigator, static: isStatic } = React2.useContext(NavigationContext);</span><span class="s2">\n  </span><span class="s1">let { matches: parentMatches } = React2.useContext(RouteContext);</span><span class="s2">\n  </span><span class="s1">let routeMatch = parentMatches[parentMatches.length - 1];</span><span class="s2">\n  </span><span class="s1">let parentParams = routeMatch ? routeMatch.params : {};</span><span class="s2">\n  </span><span class="s1">let parentPathname = routeMatch ? routeMatch.pathname : </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">let parentRoute = routeMatch &amp;&amp; routeMatch.route;</span><span class="s2">\n  </span><span class="s1">if (ENABLE_DEV_WARNINGS) {</span><span class="s2">\n    </span><span class="s1">let parentPath = parentRoute &amp;&amp; parentRoute.path || </span><span class="s2">\&quot;\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">warningOnce(</span><span class="s2">\n      </span><span class="s1">parentPathname,</span><span class="s2">\n      </span><span class="s1">!parentRoute || parentPath.endsWith(</span><span class="s2">\&quot;</span><span class="s1">*</span><span class="s2">\&quot;</span><span class="s1">) || parentPath.endsWith(</span><span class="s2">\&quot;</span><span class="s1">*?</span><span class="s2">\&quot;</span><span class="s1">),</span><span class="s2">\n      </span><span class="s1">`You rendered descendant &lt;Routes&gt; (or called </span><span class="s2">\\</span><span class="s1">`useRoutes()</span><span class="s2">\\</span><span class="s1">`) at </span><span class="s2">\&quot;</span><span class="s1">${parentPathname}</span><span class="s2">\&quot; </span><span class="s1">(under &lt;Route path=</span><span class="s2">\&quot;</span><span class="s1">${parentPath}</span><span class="s2">\&quot;</span><span class="s1">&gt;) but the parent route path has no trailing </span><span class="s2">\&quot;</span><span class="s1">*</span><span class="s2">\&quot;</span><span class="s1">. This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.</span><span class="s2">\n\n</span><span class="s1">Please change the parent &lt;Route path=</span><span class="s2">\&quot;</span><span class="s1">${parentPath}</span><span class="s2">\&quot;</span><span class="s1">&gt; to &lt;Route path=</span><span class="s2">\&quot;</span><span class="s1">${parentPath === </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot; </span><span class="s1">? </span><span class="s2">\&quot;</span><span class="s1">*</span><span class="s2">\&quot; </span><span class="s1">: `${parentPath}/*`}</span><span class="s2">\&quot;</span><span class="s1">&gt;.`</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let locationFromContext = useLocation();</span><span class="s2">\n  </span><span class="s1">let location;</span><span class="s2">\n  </span><span class="s1">if (locationArg) {</span><span class="s2">\n    </span><span class="s1">let parsedLocationArg = typeof locationArg === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">? parsePath(locationArg) : locationArg;</span><span class="s2">\n    </span><span class="s1">invariant(</span><span class="s2">\n      </span><span class="s1">parentPathnameBase === </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot; </span><span class="s1">|| parsedLocationArg.pathname?.startsWith(parentPathnameBase),</span><span class="s2">\n      </span><span class="s1">`When overriding the location using </span><span class="s2">\\</span><span class="s1">`&lt;Routes location&gt;</span><span class="s2">\\</span><span class="s1">` or </span><span class="s2">\\</span><span class="s1">`useRoutes(routes, location)</span><span class="s2">\\</span><span class="s1">`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is </span><span class="s2">\&quot;</span><span class="s1">${parentPathnameBase}</span><span class="s2">\&quot; </span><span class="s1">but pathname </span><span class="s2">\&quot;</span><span class="s1">${parsedLocationArg.pathname}</span><span class="s2">\&quot; </span><span class="s1">was given in the </span><span class="s2">\\</span><span class="s1">`location</span><span class="s2">\\</span><span class="s1">` prop.`</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">location = parsedLocationArg;</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">location = locationFromContext;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let pathname = location.pathname || </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">let remainingPathname = pathname;</span><span class="s2">\n  </span><span class="s1">if (parentPathnameBase !== </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">let parentSegments = parentPathnameBase.replace(/^</span><span class="s2">\\</span><span class="s1">//, </span><span class="s2">\&quot;\&quot;</span><span class="s1">).split(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">let segments = pathname.replace(/^</span><span class="s2">\\</span><span class="s1">//, </span><span class="s2">\&quot;\&quot;</span><span class="s1">).split(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">remainingPathname = </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot; </span><span class="s1">+ segments.slice(parentSegments.length).join(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let matches = !isStatic &amp;&amp; dataRouterState &amp;&amp; dataRouterState.matches &amp;&amp; dataRouterState.matches.length &gt; 0 ? dataRouterState.matches : matchRoutes(routes, { pathname: remainingPathname });</span><span class="s2">\n  </span><span class="s1">if (ENABLE_DEV_WARNINGS) {</span><span class="s2">\n    </span><span class="s1">warning(</span><span class="s2">\n      </span><span class="s1">parentRoute || matches != null,</span><span class="s2">\n      </span><span class="s1">`No routes matched location </span><span class="s2">\&quot;</span><span class="s1">${location.pathname}${location.search}${location.hash}</span><span class="s2">\&quot; </span><span class="s1">`</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">warning(</span><span class="s2">\n      </span><span class="s1">matches == null || matches[matches.length - 1].route.element !== void 0 || matches[matches.length - 1].route.Component !== void 0 || matches[matches.length - 1].route.lazy !== void 0,</span><span class="s2">\n      </span><span class="s1">`Matched leaf route at location </span><span class="s2">\&quot;</span><span class="s1">${location.pathname}${location.search}${location.hash}</span><span class="s2">\&quot; </span><span class="s1">does not have an element or Component. This means it will render an &lt;Outlet /&gt; with a null value by default resulting in an </span><span class="s2">\&quot;</span><span class="s1">empty</span><span class="s2">\&quot; </span><span class="s1">page.`</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let renderedMatches = _renderMatches(</span><span class="s2">\n    </span><span class="s1">matches &amp;&amp; matches.map(</span><span class="s2">\n      </span><span class="s1">(match) =&gt; Object.assign({}, match, {</span><span class="s2">\n        </span><span class="s1">params: Object.assign({}, parentParams, match.params),</span><span class="s2">\n        </span><span class="s1">pathname: joinPaths([</span><span class="s2">\n          </span><span class="s1">parentPathnameBase,</span><span class="s2">\n          </span><span class="s1">// Re-encode pathnames that were decoded inside matchRoutes</span><span class="s2">\n          </span><span class="s1">navigator.encodeLocation ? navigator.encodeLocation(match.pathname).pathname : match.pathname</span><span class="s2">\n        </span><span class="s1">]),</span><span class="s2">\n        </span><span class="s1">pathnameBase: match.pathnameBase === </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot; </span><span class="s1">? parentPathnameBase : joinPaths([</span><span class="s2">\n          </span><span class="s1">parentPathnameBase,</span><span class="s2">\n          </span><span class="s1">// Re-encode pathnames that were decoded inside matchRoutes</span><span class="s2">\n          </span><span class="s1">navigator.encodeLocation ? navigator.encodeLocation(match.pathnameBase).pathname : match.pathnameBase</span><span class="s2">\n        </span><span class="s1">])</span><span class="s2">\n      </span><span class="s1">})</span><span class="s2">\n    </span><span class="s1">),</span><span class="s2">\n    </span><span class="s1">parentMatches,</span><span class="s2">\n    </span><span class="s1">dataRouterState,</span><span class="s2">\n    </span><span class="s1">future</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">if (locationArg &amp;&amp; renderedMatches) {</span><span class="s2">\n    </span><span class="s1">return /* @__PURE__ */ React2.createElement(</span><span class="s2">\n      </span><span class="s1">LocationContext.Provider,</span><span class="s2">\n      </span><span class="s1">{</span><span class="s2">\n        </span><span class="s1">value: {</span><span class="s2">\n          </span><span class="s1">location: {</span><span class="s2">\n            </span><span class="s1">pathname: </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n            </span><span class="s1">search: </span><span class="s2">\&quot;\&quot;</span><span class="s1">,</span><span class="s2">\n            </span><span class="s1">hash: </span><span class="s2">\&quot;\&quot;</span><span class="s1">,</span><span class="s2">\n            </span><span class="s1">state: null,</span><span class="s2">\n            </span><span class="s1">key: </span><span class="s2">\&quot;</span><span class="s1">default</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n            </span><span class="s1">...location</span><span class="s2">\n          </span><span class="s1">},</span><span class="s2">\n          </span><span class="s1">navigationType: </span><span class="s2">\&quot;</span><span class="s1">POP</span><span class="s2">\&quot; </span><span class="s1">/* Pop */</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">},</span><span class="s2">\n      </span><span class="s1">renderedMatches</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return renderedMatches;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function DefaultErrorComponent() {</span><span class="s2">\n  </span><span class="s1">let error = useRouteError();</span><span class="s2">\n  </span><span class="s1">let message = isRouteErrorResponse(error) ? `${error.status} ${error.statusText}` : error instanceof Error ? error.message : JSON.stringify(error);</span><span class="s2">\n  </span><span class="s1">let stack = error instanceof Error ? error.stack : null;</span><span class="s2">\n  </span><span class="s1">let lightgrey = </span><span class="s2">\&quot;</span><span class="s1">rgba(200,200,200, 0.5)</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">let preStyles = { padding: </span><span class="s2">\&quot;</span><span class="s1">0.5rem</span><span class="s2">\&quot;</span><span class="s1">, backgroundColor: lightgrey };</span><span class="s2">\n  </span><span class="s1">let codeStyles = { padding: </span><span class="s2">\&quot;</span><span class="s1">2px 4px</span><span class="s2">\&quot;</span><span class="s1">, backgroundColor: lightgrey };</span><span class="s2">\n  </span><span class="s1">let devInfo = null;</span><span class="s2">\n  </span><span class="s1">if (ENABLE_DEV_WARNINGS) {</span><span class="s2">\n    </span><span class="s1">console.error(</span><span class="s2">\n      \&quot;</span><span class="s1">Error handled by React Router default ErrorBoundary:</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">error</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">devInfo = /* @__PURE__ */ React2.createElement(React2.Fragment, null, /* @__PURE__ */ React2.createElement(</span><span class="s2">\&quot;</span><span class="s1">p</span><span class="s2">\&quot;</span><span class="s1">, null, </span><span class="s2">\&quot;\\</span><span class="s1">u{1F4BF} Hey developer </span><span class="s2">\\</span><span class="s1">u{1F44B}</span><span class="s2">\&quot;</span><span class="s1">), /* @__PURE__ */ React2.createElement(</span><span class="s2">\&quot;</span><span class="s1">p</span><span class="s2">\&quot;</span><span class="s1">, null, </span><span class="s2">\&quot;</span><span class="s1">You can provide a way better UX than this when your app throws errors by providing your own </span><span class="s2">\&quot;</span><span class="s1">, /* @__PURE__ */ React2.createElement(</span><span class="s2">\&quot;</span><span class="s1">code</span><span class="s2">\&quot;</span><span class="s1">, { style: codeStyles }, </span><span class="s2">\&quot;</span><span class="s1">ErrorBoundary</span><span class="s2">\&quot;</span><span class="s1">), </span><span class="s2">\&quot; </span><span class="s1">or</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot; \&quot;</span><span class="s1">, /* @__PURE__ */ React2.createElement(</span><span class="s2">\&quot;</span><span class="s1">code</span><span class="s2">\&quot;</span><span class="s1">, { style: codeStyles }, </span><span class="s2">\&quot;</span><span class="s1">errorElement</span><span class="s2">\&quot;</span><span class="s1">), </span><span class="s2">\&quot; </span><span class="s1">prop on your route.</span><span class="s2">\&quot;</span><span class="s1">));</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return /* @__PURE__ */ React2.createElement(React2.Fragment, null, /* @__PURE__ */ React2.createElement(</span><span class="s2">\&quot;</span><span class="s1">h2</span><span class="s2">\&quot;</span><span class="s1">, null, </span><span class="s2">\&quot;</span><span class="s1">Unexpected Application Error!</span><span class="s2">\&quot;</span><span class="s1">), /* @__PURE__ */ React2.createElement(</span><span class="s2">\&quot;</span><span class="s1">h3</span><span class="s2">\&quot;</span><span class="s1">, { style: { fontStyle: </span><span class="s2">\&quot;</span><span class="s1">italic</span><span class="s2">\&quot; </span><span class="s1">} }, message), stack ? /* @__PURE__ */ React2.createElement(</span><span class="s2">\&quot;</span><span class="s1">pre</span><span class="s2">\&quot;</span><span class="s1">, { style: preStyles }, stack) : null, devInfo);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var defaultErrorElement = /* @__PURE__ */ React2.createElement(DefaultErrorComponent, null);</span><span class="s2">\n</span><span class="s1">var RenderErrorBoundary = class extends React2.Component {</span><span class="s2">\n  </span><span class="s1">constructor(props) {</span><span class="s2">\n    </span><span class="s1">super(props);</span><span class="s2">\n    </span><span class="s1">this.state = {</span><span class="s2">\n      </span><span class="s1">location: props.location,</span><span class="s2">\n      </span><span class="s1">revalidation: props.revalidation,</span><span class="s2">\n      </span><span class="s1">error: props.error</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">static getDerivedStateFromError(error) {</span><span class="s2">\n    </span><span class="s1">return { error };</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">static getDerivedStateFromProps(props, state) {</span><span class="s2">\n    </span><span class="s1">if (state.location !== props.location || state.revalidation !== </span><span class="s2">\&quot;</span><span class="s1">idle</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; props.revalidation === </span><span class="s2">\&quot;</span><span class="s1">idle</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">return {</span><span class="s2">\n        </span><span class="s1">error: props.error,</span><span class="s2">\n        </span><span class="s1">location: props.location,</span><span class="s2">\n        </span><span class="s1">revalidation: props.revalidation</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return {</span><span class="s2">\n      </span><span class="s1">error: props.error !== void 0 ? props.error : state.error,</span><span class="s2">\n      </span><span class="s1">location: state.location,</span><span class="s2">\n      </span><span class="s1">revalidation: props.revalidation || state.revalidation</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">componentDidCatch(error, errorInfo) {</span><span class="s2">\n    </span><span class="s1">console.error(</span><span class="s2">\n      \&quot;</span><span class="s1">React Router caught the following error during render</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">error,</span><span class="s2">\n      </span><span class="s1">errorInfo</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">render() {</span><span class="s2">\n    </span><span class="s1">return this.state.error !== void 0 ? /* @__PURE__ */ React2.createElement(RouteContext.Provider, { value: this.props.routeContext }, /* @__PURE__ */ React2.createElement(</span><span class="s2">\n      </span><span class="s1">RouteErrorContext.Provider,</span><span class="s2">\n      </span><span class="s1">{</span><span class="s2">\n        </span><span class="s1">value: this.state.error,</span><span class="s2">\n        </span><span class="s1">children: this.props.component</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">)) : this.props.children;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">function RenderedRoute({ routeContext, match, children }) {</span><span class="s2">\n  </span><span class="s1">let dataRouterContext = React2.useContext(DataRouterContext);</span><span class="s2">\n  </span><span class="s1">if (dataRouterContext &amp;&amp; dataRouterContext.static &amp;&amp; dataRouterContext.staticContext &amp;&amp; (match.route.errorElement || match.route.ErrorBoundary)) {</span><span class="s2">\n    </span><span class="s1">dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return /* @__PURE__ */ React2.createElement(RouteContext.Provider, { value: routeContext }, children);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function _renderMatches(matches, parentMatches = [], dataRouterState = null, future = null) {</span><span class="s2">\n  </span><span class="s1">if (matches == null) {</span><span class="s2">\n    </span><span class="s1">if (!dataRouterState) {</span><span class="s2">\n      </span><span class="s1">return null;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (dataRouterState.errors) {</span><span class="s2">\n      </span><span class="s1">matches = dataRouterState.matches;</span><span class="s2">\n    </span><span class="s1">} else if (parentMatches.length === 0 &amp;&amp; !dataRouterState.initialized &amp;&amp; dataRouterState.matches.length &gt; 0) {</span><span class="s2">\n      </span><span class="s1">matches = dataRouterState.matches;</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">return null;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let renderedMatches = matches;</span><span class="s2">\n  </span><span class="s1">let errors = dataRouterState?.errors;</span><span class="s2">\n  </span><span class="s1">if (errors != null) {</span><span class="s2">\n    </span><span class="s1">let errorIndex = renderedMatches.findIndex(</span><span class="s2">\n      </span><span class="s1">(m) =&gt; m.route.id &amp;&amp; errors?.[m.route.id] !== void 0</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">invariant(</span><span class="s2">\n      </span><span class="s1">errorIndex &gt;= 0,</span><span class="s2">\n      </span><span class="s1">`Could not find a matching route for errors on route IDs: ${Object.keys(</span><span class="s2">\n        </span><span class="s1">errors</span><span class="s2">\n      </span><span class="s1">).join(</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\&quot;</span><span class="s1">)}`</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">renderedMatches = renderedMatches.slice(</span><span class="s2">\n      </span><span class="s1">0,</span><span class="s2">\n      </span><span class="s1">Math.min(renderedMatches.length, errorIndex + 1)</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let renderFallback = false;</span><span class="s2">\n  </span><span class="s1">let fallbackIndex = -1;</span><span class="s2">\n  </span><span class="s1">if (dataRouterState) {</span><span class="s2">\n    </span><span class="s1">for (let i = 0; i &lt; renderedMatches.length; i++) {</span><span class="s2">\n      </span><span class="s1">let match = renderedMatches[i];</span><span class="s2">\n      </span><span class="s1">if (match.route.HydrateFallback || match.route.hydrateFallbackElement) {</span><span class="s2">\n        </span><span class="s1">fallbackIndex = i;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (match.route.id) {</span><span class="s2">\n        </span><span class="s1">let { loaderData, errors: errors2 } = dataRouterState;</span><span class="s2">\n        </span><span class="s1">let needsToRunLoader = match.route.loader &amp;&amp; !loaderData.hasOwnProperty(match.route.id) &amp;&amp; (!errors2 || errors2[match.route.id] === void 0);</span><span class="s2">\n        </span><span class="s1">if (match.route.lazy || needsToRunLoader) {</span><span class="s2">\n          </span><span class="s1">renderFallback = true;</span><span class="s2">\n          </span><span class="s1">if (fallbackIndex &gt;= 0) {</span><span class="s2">\n            </span><span class="s1">renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);</span><span class="s2">\n          </span><span class="s1">} else {</span><span class="s2">\n            </span><span class="s1">renderedMatches = [renderedMatches[0]];</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">break;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return renderedMatches.reduceRight((outlet, match, index) =&gt; {</span><span class="s2">\n    </span><span class="s1">let error;</span><span class="s2">\n    </span><span class="s1">let shouldRenderHydrateFallback = false;</span><span class="s2">\n    </span><span class="s1">let errorElement = null;</span><span class="s2">\n    </span><span class="s1">let hydrateFallbackElement = null;</span><span class="s2">\n    </span><span class="s1">if (dataRouterState) {</span><span class="s2">\n      </span><span class="s1">error = errors &amp;&amp; match.route.id ? errors[match.route.id] : void 0;</span><span class="s2">\n      </span><span class="s1">errorElement = match.route.errorElement || defaultErrorElement;</span><span class="s2">\n      </span><span class="s1">if (renderFallback) {</span><span class="s2">\n        </span><span class="s1">if (fallbackIndex &lt; 0 &amp;&amp; index === 0) {</span><span class="s2">\n          </span><span class="s1">warningOnce(</span><span class="s2">\n            \&quot;</span><span class="s1">route-fallback</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n            </span><span class="s1">false,</span><span class="s2">\n            \&quot;</span><span class="s1">No `HydrateFallback` element provided to render during initial hydration</span><span class="s2">\&quot;\n          </span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">shouldRenderHydrateFallback = true;</span><span class="s2">\n          </span><span class="s1">hydrateFallbackElement = null;</span><span class="s2">\n        </span><span class="s1">} else if (fallbackIndex === index) {</span><span class="s2">\n          </span><span class="s1">shouldRenderHydrateFallback = true;</span><span class="s2">\n          </span><span class="s1">hydrateFallbackElement = match.route.hydrateFallbackElement || null;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let matches2 = parentMatches.concat(renderedMatches.slice(0, index + 1));</span><span class="s2">\n    </span><span class="s1">let getChildren = () =&gt; {</span><span class="s2">\n      </span><span class="s1">let children;</span><span class="s2">\n      </span><span class="s1">if (error) {</span><span class="s2">\n        </span><span class="s1">children = errorElement;</span><span class="s2">\n      </span><span class="s1">} else if (shouldRenderHydrateFallback) {</span><span class="s2">\n        </span><span class="s1">children = hydrateFallbackElement;</span><span class="s2">\n      </span><span class="s1">} else if (match.route.Component) {</span><span class="s2">\n        </span><span class="s1">children = /* @__PURE__ */ React2.createElement(match.route.Component, null);</span><span class="s2">\n      </span><span class="s1">} else if (match.route.element) {</span><span class="s2">\n        </span><span class="s1">children = match.route.element;</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">children = outlet;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return /* @__PURE__ */ React2.createElement(</span><span class="s2">\n        </span><span class="s1">RenderedRoute,</span><span class="s2">\n        </span><span class="s1">{</span><span class="s2">\n          </span><span class="s1">match,</span><span class="s2">\n          </span><span class="s1">routeContext: {</span><span class="s2">\n            </span><span class="s1">outlet,</span><span class="s2">\n            </span><span class="s1">matches: matches2,</span><span class="s2">\n            </span><span class="s1">isDataRoute: dataRouterState != null</span><span class="s2">\n          </span><span class="s1">},</span><span class="s2">\n          </span><span class="s1">children</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">return dataRouterState &amp;&amp; (match.route.ErrorBoundary || match.route.errorElement || index === 0) ? /* @__PURE__ */ React2.createElement(</span><span class="s2">\n      </span><span class="s1">RenderErrorBoundary,</span><span class="s2">\n      </span><span class="s1">{</span><span class="s2">\n        </span><span class="s1">location: dataRouterState.location,</span><span class="s2">\n        </span><span class="s1">revalidation: dataRouterState.revalidation,</span><span class="s2">\n        </span><span class="s1">component: errorElement,</span><span class="s2">\n        </span><span class="s1">error,</span><span class="s2">\n        </span><span class="s1">children: getChildren(),</span><span class="s2">\n        </span><span class="s1">routeContext: { outlet: null, matches: matches2, isDataRoute: true }</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">) : getChildren();</span><span class="s2">\n  </span><span class="s1">}, null);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getDataRouterConsoleError(hookName) {</span><span class="s2">\n  </span><span class="s1">return `${hookName} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useDataRouterContext(hookName) {</span><span class="s2">\n  </span><span class="s1">let ctx = React2.useContext(DataRouterContext);</span><span class="s2">\n  </span><span class="s1">invariant(ctx, getDataRouterConsoleError(hookName));</span><span class="s2">\n  </span><span class="s1">return ctx;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useDataRouterState(hookName) {</span><span class="s2">\n  </span><span class="s1">let state = React2.useContext(DataRouterStateContext);</span><span class="s2">\n  </span><span class="s1">invariant(state, getDataRouterConsoleError(hookName));</span><span class="s2">\n  </span><span class="s1">return state;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useRouteContext(hookName) {</span><span class="s2">\n  </span><span class="s1">let route = React2.useContext(RouteContext);</span><span class="s2">\n  </span><span class="s1">invariant(route, getDataRouterConsoleError(hookName));</span><span class="s2">\n  </span><span class="s1">return route;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useCurrentRouteId(hookName) {</span><span class="s2">\n  </span><span class="s1">let route = useRouteContext(hookName);</span><span class="s2">\n  </span><span class="s1">let thisRoute = route.matches[route.matches.length - 1];</span><span class="s2">\n  </span><span class="s1">invariant(</span><span class="s2">\n    </span><span class="s1">thisRoute.route.id,</span><span class="s2">\n    </span><span class="s1">`${hookName} can only be used on routes that contain a unique </span><span class="s2">\&quot;</span><span class="s1">id</span><span class="s2">\&quot;</span><span class="s1">`</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">return thisRoute.route.id;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useRouteId() {</span><span class="s2">\n  </span><span class="s1">return useCurrentRouteId(</span><span class="s2">\&quot;</span><span class="s1">useRouteId</span><span class="s2">\&quot; </span><span class="s1">/* UseRouteId */);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useNavigation() {</span><span class="s2">\n  </span><span class="s1">let state = useDataRouterState(</span><span class="s2">\&quot;</span><span class="s1">useNavigation</span><span class="s2">\&quot; </span><span class="s1">/* UseNavigation */);</span><span class="s2">\n  </span><span class="s1">return state.navigation;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useRevalidator() {</span><span class="s2">\n  </span><span class="s1">let dataRouterContext = useDataRouterContext(</span><span class="s2">\&quot;</span><span class="s1">useRevalidator</span><span class="s2">\&quot; </span><span class="s1">/* UseRevalidator */);</span><span class="s2">\n  </span><span class="s1">let state = useDataRouterState(</span><span class="s2">\&quot;</span><span class="s1">useRevalidator</span><span class="s2">\&quot; </span><span class="s1">/* UseRevalidator */);</span><span class="s2">\n  </span><span class="s1">let revalidate = React2.useCallback(async () =&gt; {</span><span class="s2">\n    </span><span class="s1">await dataRouterContext.router.revalidate();</span><span class="s2">\n  </span><span class="s1">}, [dataRouterContext.router]);</span><span class="s2">\n  </span><span class="s1">return React2.useMemo(</span><span class="s2">\n    </span><span class="s1">() =&gt; ({ revalidate, state: state.revalidation }),</span><span class="s2">\n    </span><span class="s1">[revalidate, state.revalidation]</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useMatches() {</span><span class="s2">\n  </span><span class="s1">let { matches, loaderData } = useDataRouterState(</span><span class="s2">\n    \&quot;</span><span class="s1">useMatches</span><span class="s2">\&quot; </span><span class="s1">/* UseMatches */</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">return React2.useMemo(</span><span class="s2">\n    </span><span class="s1">() =&gt; matches.map((m) =&gt; convertRouteMatchToUiMatch(m, loaderData)),</span><span class="s2">\n    </span><span class="s1">[matches, loaderData]</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useLoaderData() {</span><span class="s2">\n  </span><span class="s1">let state = useDataRouterState(</span><span class="s2">\&quot;</span><span class="s1">useLoaderData</span><span class="s2">\&quot; </span><span class="s1">/* UseLoaderData */);</span><span class="s2">\n  </span><span class="s1">let routeId = useCurrentRouteId(</span><span class="s2">\&quot;</span><span class="s1">useLoaderData</span><span class="s2">\&quot; </span><span class="s1">/* UseLoaderData */);</span><span class="s2">\n  </span><span class="s1">return state.loaderData[routeId];</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useRouteLoaderData(routeId) {</span><span class="s2">\n  </span><span class="s1">let state = useDataRouterState(</span><span class="s2">\&quot;</span><span class="s1">useRouteLoaderData</span><span class="s2">\&quot; </span><span class="s1">/* UseRouteLoaderData */);</span><span class="s2">\n  </span><span class="s1">return state.loaderData[routeId];</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useActionData() {</span><span class="s2">\n  </span><span class="s1">let state = useDataRouterState(</span><span class="s2">\&quot;</span><span class="s1">useActionData</span><span class="s2">\&quot; </span><span class="s1">/* UseActionData */);</span><span class="s2">\n  </span><span class="s1">let routeId = useCurrentRouteId(</span><span class="s2">\&quot;</span><span class="s1">useLoaderData</span><span class="s2">\&quot; </span><span class="s1">/* UseLoaderData */);</span><span class="s2">\n  </span><span class="s1">return state.actionData ? state.actionData[routeId] : void 0;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useRouteError() {</span><span class="s2">\n  </span><span class="s1">let error = React2.useContext(RouteErrorContext);</span><span class="s2">\n  </span><span class="s1">let state = useDataRouterState(</span><span class="s2">\&quot;</span><span class="s1">useRouteError</span><span class="s2">\&quot; </span><span class="s1">/* UseRouteError */);</span><span class="s2">\n  </span><span class="s1">let routeId = useCurrentRouteId(</span><span class="s2">\&quot;</span><span class="s1">useRouteError</span><span class="s2">\&quot; </span><span class="s1">/* UseRouteError */);</span><span class="s2">\n  </span><span class="s1">if (error !== void 0) {</span><span class="s2">\n    </span><span class="s1">return error;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return state.errors?.[routeId];</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useAsyncValue() {</span><span class="s2">\n  </span><span class="s1">let value = React2.useContext(AwaitContext);</span><span class="s2">\n  </span><span class="s1">return value?._data;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useAsyncError() {</span><span class="s2">\n  </span><span class="s1">let value = React2.useContext(AwaitContext);</span><span class="s2">\n  </span><span class="s1">return value?._error;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var blockerId = 0;</span><span class="s2">\n</span><span class="s1">function useBlocker(shouldBlock) {</span><span class="s2">\n  </span><span class="s1">let { router, basename } = useDataRouterContext(</span><span class="s2">\&quot;</span><span class="s1">useBlocker</span><span class="s2">\&quot; </span><span class="s1">/* UseBlocker */);</span><span class="s2">\n  </span><span class="s1">let state = useDataRouterState(</span><span class="s2">\&quot;</span><span class="s1">useBlocker</span><span class="s2">\&quot; </span><span class="s1">/* UseBlocker */);</span><span class="s2">\n  </span><span class="s1">let [blockerKey, setBlockerKey] = React2.useState(</span><span class="s2">\&quot;\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let blockerFunction = React2.useCallback(</span><span class="s2">\n    </span><span class="s1">(arg) =&gt; {</span><span class="s2">\n      </span><span class="s1">if (typeof shouldBlock !== </span><span class="s2">\&quot;</span><span class="s1">function</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">return !!shouldBlock;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (basename === </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">return shouldBlock(arg);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">let { currentLocation, nextLocation, historyAction } = arg;</span><span class="s2">\n      </span><span class="s1">return shouldBlock({</span><span class="s2">\n        </span><span class="s1">currentLocation: {</span><span class="s2">\n          </span><span class="s1">...currentLocation,</span><span class="s2">\n          </span><span class="s1">pathname: stripBasename(currentLocation.pathname, basename) || currentLocation.pathname</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">nextLocation: {</span><span class="s2">\n          </span><span class="s1">...nextLocation,</span><span class="s2">\n          </span><span class="s1">pathname: stripBasename(nextLocation.pathname, basename) || nextLocation.pathname</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">historyAction</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">[basename, shouldBlock]</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">React2.useEffect(() =&gt; {</span><span class="s2">\n    </span><span class="s1">let key = String(++blockerId);</span><span class="s2">\n    </span><span class="s1">setBlockerKey(key);</span><span class="s2">\n    </span><span class="s1">return () =&gt; router.deleteBlocker(key);</span><span class="s2">\n  </span><span class="s1">}, [router]);</span><span class="s2">\n  </span><span class="s1">React2.useEffect(() =&gt; {</span><span class="s2">\n    </span><span class="s1">if (blockerKey !== </span><span class="s2">\&quot;\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">router.getBlocker(blockerKey, blockerFunction);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}, [router, blockerKey, blockerFunction]);</span><span class="s2">\n  </span><span class="s1">return blockerKey &amp;&amp; state.blockers.has(blockerKey) ? state.blockers.get(blockerKey) : IDLE_BLOCKER;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useNavigateStable() {</span><span class="s2">\n  </span><span class="s1">let { router } = useDataRouterContext(</span><span class="s2">\&quot;</span><span class="s1">useNavigate</span><span class="s2">\&quot; </span><span class="s1">/* UseNavigateStable */);</span><span class="s2">\n  </span><span class="s1">let id = useCurrentRouteId(</span><span class="s2">\&quot;</span><span class="s1">useNavigate</span><span class="s2">\&quot; </span><span class="s1">/* UseNavigateStable */);</span><span class="s2">\n  </span><span class="s1">let activeRef = React2.useRef(false);</span><span class="s2">\n  </span><span class="s1">useIsomorphicLayoutEffect(() =&gt; {</span><span class="s2">\n    </span><span class="s1">activeRef.current = true;</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">let navigate = React2.useCallback(</span><span class="s2">\n    </span><span class="s1">async (to, options = {}) =&gt; {</span><span class="s2">\n      </span><span class="s1">warning(activeRef.current, navigateEffectWarning);</span><span class="s2">\n      </span><span class="s1">if (!activeRef.current) return;</span><span class="s2">\n      </span><span class="s1">if (typeof to === </span><span class="s2">\&quot;</span><span class="s1">number</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">router.navigate(to);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">await router.navigate(to, { fromRouteId: id, ...options });</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">[router, id]</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">return navigate;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var alreadyWarned = {};</span><span class="s2">\n</span><span class="s1">function warningOnce(key, cond, message) {</span><span class="s2">\n  </span><span class="s1">if (!cond &amp;&amp; !alreadyWarned[key]) {</span><span class="s2">\n    </span><span class="s1">alreadyWarned[key] = true;</span><span class="s2">\n    </span><span class="s1">warning(false, message);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/server-runtime/warnings.ts</span><span class="s2">\n</span><span class="s1">var alreadyWarned2 = {};</span><span class="s2">\n</span><span class="s1">function warnOnce(condition, message) {</span><span class="s2">\n  </span><span class="s1">if (!condition &amp;&amp; !alreadyWarned2[message]) {</span><span class="s2">\n    </span><span class="s1">alreadyWarned2[message] = true;</span><span class="s2">\n    </span><span class="s1">console.warn(message);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/components.tsx</span><span class="s2">\n</span><span class="s1">function mapRouteProperties(route) {</span><span class="s2">\n  </span><span class="s1">let updates = {</span><span class="s2">\n    </span><span class="s1">// Note: this check also occurs in createRoutesFromChildren so update</span><span class="s2">\n    </span><span class="s1">// there if you change this -- please and thank you!</span><span class="s2">\n    </span><span class="s1">hasErrorBoundary: route.hasErrorBoundary || route.ErrorBoundary != null || route.errorElement != null</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">if (route.Component) {</span><span class="s2">\n    </span><span class="s1">if (ENABLE_DEV_WARNINGS) {</span><span class="s2">\n      </span><span class="s1">if (route.element) {</span><span class="s2">\n        </span><span class="s1">warning(</span><span class="s2">\n          </span><span class="s1">false,</span><span class="s2">\n          \&quot;</span><span class="s1">You should not include both `Component` and `element` on your route - `Component` will be used.</span><span class="s2">\&quot;\n        </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">Object.assign(updates, {</span><span class="s2">\n      </span><span class="s1">element: React3.createElement(route.Component),</span><span class="s2">\n      </span><span class="s1">Component: void 0</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (route.HydrateFallback) {</span><span class="s2">\n    </span><span class="s1">if (ENABLE_DEV_WARNINGS) {</span><span class="s2">\n      </span><span class="s1">if (route.hydrateFallbackElement) {</span><span class="s2">\n        </span><span class="s1">warning(</span><span class="s2">\n          </span><span class="s1">false,</span><span class="s2">\n          \&quot;</span><span class="s1">You should not include both `HydrateFallback` and `hydrateFallbackElement` on your route - `HydrateFallback` will be used.</span><span class="s2">\&quot;\n        </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">Object.assign(updates, {</span><span class="s2">\n      </span><span class="s1">hydrateFallbackElement: React3.createElement(route.HydrateFallback),</span><span class="s2">\n      </span><span class="s1">HydrateFallback: void 0</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (route.ErrorBoundary) {</span><span class="s2">\n    </span><span class="s1">if (ENABLE_DEV_WARNINGS) {</span><span class="s2">\n      </span><span class="s1">if (route.errorElement) {</span><span class="s2">\n        </span><span class="s1">warning(</span><span class="s2">\n          </span><span class="s1">false,</span><span class="s2">\n          \&quot;</span><span class="s1">You should not include both `ErrorBoundary` and `errorElement` on your route - `ErrorBoundary` will be used.</span><span class="s2">\&quot;\n        </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">Object.assign(updates, {</span><span class="s2">\n      </span><span class="s1">errorElement: React3.createElement(route.ErrorBoundary),</span><span class="s2">\n      </span><span class="s1">ErrorBoundary: void 0</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return updates;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var hydrationRouteProperties = [</span><span class="s2">\n  \&quot;</span><span class="s1">HydrateFallback</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">hydrateFallbackElement</span><span class="s2">\&quot;\n</span><span class="s1">];</span><span class="s2">\n</span><span class="s1">function createMemoryRouter(routes, opts) {</span><span class="s2">\n  </span><span class="s1">return createRouter({</span><span class="s2">\n    </span><span class="s1">basename: opts?.basename,</span><span class="s2">\n    </span><span class="s1">unstable_getContext: opts?.unstable_getContext,</span><span class="s2">\n    </span><span class="s1">future: opts?.future,</span><span class="s2">\n    </span><span class="s1">history: createMemoryHistory({</span><span class="s2">\n      </span><span class="s1">initialEntries: opts?.initialEntries,</span><span class="s2">\n      </span><span class="s1">initialIndex: opts?.initialIndex</span><span class="s2">\n    </span><span class="s1">}),</span><span class="s2">\n    </span><span class="s1">hydrationData: opts?.hydrationData,</span><span class="s2">\n    </span><span class="s1">routes,</span><span class="s2">\n    </span><span class="s1">hydrationRouteProperties,</span><span class="s2">\n    </span><span class="s1">mapRouteProperties,</span><span class="s2">\n    </span><span class="s1">dataStrategy: opts?.dataStrategy,</span><span class="s2">\n    </span><span class="s1">patchRoutesOnNavigation: opts?.patchRoutesOnNavigation</span><span class="s2">\n  </span><span class="s1">}).initialize();</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var Deferred = class {</span><span class="s2">\n  </span><span class="s1">constructor() {</span><span class="s2">\n    </span><span class="s1">this.status = </span><span class="s2">\&quot;</span><span class="s1">pending</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">this.promise = new Promise((resolve, reject) =&gt; {</span><span class="s2">\n      </span><span class="s1">this.resolve = (value) =&gt; {</span><span class="s2">\n        </span><span class="s1">if (this.status === </span><span class="s2">\&quot;</span><span class="s1">pending</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">this.status = </span><span class="s2">\&quot;</span><span class="s1">resolved</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n          </span><span class="s1">resolve(value);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">this.reject = (reason) =&gt; {</span><span class="s2">\n        </span><span class="s1">if (this.status === </span><span class="s2">\&quot;</span><span class="s1">pending</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">this.status = </span><span class="s2">\&quot;</span><span class="s1">rejected</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n          </span><span class="s1">reject(reason);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">function RouterProvider({</span><span class="s2">\n  </span><span class="s1">router,</span><span class="s2">\n  </span><span class="s1">flushSync: reactDomFlushSyncImpl</span><span class="s2">\n</span><span class="s1">}) {</span><span class="s2">\n  </span><span class="s1">let [state, setStateImpl] = React3.useState(router.state);</span><span class="s2">\n  </span><span class="s1">let [pendingState, setPendingState] = React3.useState();</span><span class="s2">\n  </span><span class="s1">let [vtContext, setVtContext] = React3.useState({</span><span class="s2">\n    </span><span class="s1">isTransitioning: false</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">let [renderDfd, setRenderDfd] = React3.useState();</span><span class="s2">\n  </span><span class="s1">let [transition, setTransition] = React3.useState();</span><span class="s2">\n  </span><span class="s1">let [interruption, setInterruption] = React3.useState();</span><span class="s2">\n  </span><span class="s1">let fetcherData = React3.useRef(/* @__PURE__ */ new Map());</span><span class="s2">\n  </span><span class="s1">let setState = React3.useCallback(</span><span class="s2">\n    </span><span class="s1">(newState, { deletedFetchers, flushSync, viewTransitionOpts }) =&gt; {</span><span class="s2">\n      </span><span class="s1">newState.fetchers.forEach((fetcher, key) =&gt; {</span><span class="s2">\n        </span><span class="s1">if (fetcher.data !== void 0) {</span><span class="s2">\n          </span><span class="s1">fetcherData.current.set(key, fetcher.data);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">deletedFetchers.forEach((key) =&gt; fetcherData.current.delete(key));</span><span class="s2">\n      </span><span class="s1">warnOnce(</span><span class="s2">\n        </span><span class="s1">flushSync === false || reactDomFlushSyncImpl != null,</span><span class="s2">\n        </span><span class="s1">'You provided the `flushSync` option to a router update, but you are not using the `&lt;RouterProvider&gt;` from `react-router/dom` so `ReactDOM.flushSync()` is unavailable.  Please update your app to `import { RouterProvider } from </span><span class="s2">\&quot;</span><span class="s1">react-router/dom</span><span class="s2">\&quot;</span><span class="s1">` and ensure you have `react-dom` installed as a dependency to use the `flushSync` option.'</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">let isViewTransitionAvailable = router.window != null &amp;&amp; router.window.document != null &amp;&amp; typeof router.window.document.startViewTransition === </span><span class="s2">\&quot;</span><span class="s1">function</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n      </span><span class="s1">warnOnce(</span><span class="s2">\n        </span><span class="s1">viewTransitionOpts == null || isViewTransitionAvailable,</span><span class="s2">\n        \&quot;</span><span class="s1">You provided the `viewTransition` option to a router update, but you do not appear to be running in a DOM environment as `window.startViewTransition` is not available.</span><span class="s2">\&quot;\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">if (!viewTransitionOpts || !isViewTransitionAvailable) {</span><span class="s2">\n        </span><span class="s1">if (reactDomFlushSyncImpl &amp;&amp; flushSync) {</span><span class="s2">\n          </span><span class="s1">reactDomFlushSyncImpl(() =&gt; setStateImpl(newState));</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">React3.startTransition(() =&gt; setStateImpl(newState));</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (reactDomFlushSyncImpl &amp;&amp; flushSync) {</span><span class="s2">\n        </span><span class="s1">reactDomFlushSyncImpl(() =&gt; {</span><span class="s2">\n          </span><span class="s1">if (transition) {</span><span class="s2">\n            </span><span class="s1">renderDfd &amp;&amp; renderDfd.resolve();</span><span class="s2">\n            </span><span class="s1">transition.skipTransition();</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">setVtContext({</span><span class="s2">\n            </span><span class="s1">isTransitioning: true,</span><span class="s2">\n            </span><span class="s1">flushSync: true,</span><span class="s2">\n            </span><span class="s1">currentLocation: viewTransitionOpts.currentLocation,</span><span class="s2">\n            </span><span class="s1">nextLocation: viewTransitionOpts.nextLocation</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">let t = router.window.document.startViewTransition(() =&gt; {</span><span class="s2">\n          </span><span class="s1">reactDomFlushSyncImpl(() =&gt; setStateImpl(newState));</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">t.finished.finally(() =&gt; {</span><span class="s2">\n          </span><span class="s1">reactDomFlushSyncImpl(() =&gt; {</span><span class="s2">\n            </span><span class="s1">setRenderDfd(void 0);</span><span class="s2">\n            </span><span class="s1">setTransition(void 0);</span><span class="s2">\n            </span><span class="s1">setPendingState(void 0);</span><span class="s2">\n            </span><span class="s1">setVtContext({ isTransitioning: false });</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">reactDomFlushSyncImpl(() =&gt; setTransition(t));</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (transition) {</span><span class="s2">\n        </span><span class="s1">renderDfd &amp;&amp; renderDfd.resolve();</span><span class="s2">\n        </span><span class="s1">transition.skipTransition();</span><span class="s2">\n        </span><span class="s1">setInterruption({</span><span class="s2">\n          </span><span class="s1">state: newState,</span><span class="s2">\n          </span><span class="s1">currentLocation: viewTransitionOpts.currentLocation,</span><span class="s2">\n          </span><span class="s1">nextLocation: viewTransitionOpts.nextLocation</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">setPendingState(newState);</span><span class="s2">\n        </span><span class="s1">setVtContext({</span><span class="s2">\n          </span><span class="s1">isTransitioning: true,</span><span class="s2">\n          </span><span class="s1">flushSync: false,</span><span class="s2">\n          </span><span class="s1">currentLocation: viewTransitionOpts.currentLocation,</span><span class="s2">\n          </span><span class="s1">nextLocation: viewTransitionOpts.nextLocation</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">[router.window, reactDomFlushSyncImpl, transition, renderDfd]</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">React3.useLayoutEffect(() =&gt; router.subscribe(setState), [router, setState]);</span><span class="s2">\n  </span><span class="s1">React3.useEffect(() =&gt; {</span><span class="s2">\n    </span><span class="s1">if (vtContext.isTransitioning &amp;&amp; !vtContext.flushSync) {</span><span class="s2">\n      </span><span class="s1">setRenderDfd(new Deferred());</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}, [vtContext]);</span><span class="s2">\n  </span><span class="s1">React3.useEffect(() =&gt; {</span><span class="s2">\n    </span><span class="s1">if (renderDfd &amp;&amp; pendingState &amp;&amp; router.window) {</span><span class="s2">\n      </span><span class="s1">let newState = pendingState;</span><span class="s2">\n      </span><span class="s1">let renderPromise = renderDfd.promise;</span><span class="s2">\n      </span><span class="s1">let transition2 = router.window.document.startViewTransition(async () =&gt; {</span><span class="s2">\n        </span><span class="s1">React3.startTransition(() =&gt; setStateImpl(newState));</span><span class="s2">\n        </span><span class="s1">await renderPromise;</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">transition2.finished.finally(() =&gt; {</span><span class="s2">\n        </span><span class="s1">setRenderDfd(void 0);</span><span class="s2">\n        </span><span class="s1">setTransition(void 0);</span><span class="s2">\n        </span><span class="s1">setPendingState(void 0);</span><span class="s2">\n        </span><span class="s1">setVtContext({ isTransitioning: false });</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">setTransition(transition2);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}, [pendingState, renderDfd, router.window]);</span><span class="s2">\n  </span><span class="s1">React3.useEffect(() =&gt; {</span><span class="s2">\n    </span><span class="s1">if (renderDfd &amp;&amp; pendingState &amp;&amp; state.location.key === pendingState.location.key) {</span><span class="s2">\n      </span><span class="s1">renderDfd.resolve();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}, [renderDfd, transition, state.location, pendingState]);</span><span class="s2">\n  </span><span class="s1">React3.useEffect(() =&gt; {</span><span class="s2">\n    </span><span class="s1">if (!vtContext.isTransitioning &amp;&amp; interruption) {</span><span class="s2">\n      </span><span class="s1">setPendingState(interruption.state);</span><span class="s2">\n      </span><span class="s1">setVtContext({</span><span class="s2">\n        </span><span class="s1">isTransitioning: true,</span><span class="s2">\n        </span><span class="s1">flushSync: false,</span><span class="s2">\n        </span><span class="s1">currentLocation: interruption.currentLocation,</span><span class="s2">\n        </span><span class="s1">nextLocation: interruption.nextLocation</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">setInterruption(void 0);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}, [vtContext.isTransitioning, interruption]);</span><span class="s2">\n  </span><span class="s1">let navigator = React3.useMemo(() =&gt; {</span><span class="s2">\n    </span><span class="s1">return {</span><span class="s2">\n      </span><span class="s1">createHref: router.createHref,</span><span class="s2">\n      </span><span class="s1">encodeLocation: router.encodeLocation,</span><span class="s2">\n      </span><span class="s1">go: (n) =&gt; router.navigate(n),</span><span class="s2">\n      </span><span class="s1">push: (to, state2, opts) =&gt; router.navigate(to, {</span><span class="s2">\n        </span><span class="s1">state: state2,</span><span class="s2">\n        </span><span class="s1">preventScrollReset: opts?.preventScrollReset</span><span class="s2">\n      </span><span class="s1">}),</span><span class="s2">\n      </span><span class="s1">replace: (to, state2, opts) =&gt; router.navigate(to, {</span><span class="s2">\n        </span><span class="s1">replace: true,</span><span class="s2">\n        </span><span class="s1">state: state2,</span><span class="s2">\n        </span><span class="s1">preventScrollReset: opts?.preventScrollReset</span><span class="s2">\n      </span><span class="s1">})</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}, [router]);</span><span class="s2">\n  </span><span class="s1">let basename = router.basename || </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">let dataRouterContext = React3.useMemo(</span><span class="s2">\n    </span><span class="s1">() =&gt; ({</span><span class="s2">\n      </span><span class="s1">router,</span><span class="s2">\n      </span><span class="s1">navigator,</span><span class="s2">\n      </span><span class="s1">static: false,</span><span class="s2">\n      </span><span class="s1">basename</span><span class="s2">\n    </span><span class="s1">}),</span><span class="s2">\n    </span><span class="s1">[router, navigator, basename]</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">return /* @__PURE__ */ React3.createElement(React3.Fragment, null, /* @__PURE__ */ React3.createElement(DataRouterContext.Provider, { value: dataRouterContext }, /* @__PURE__ */ React3.createElement(DataRouterStateContext.Provider, { value: state }, /* @__PURE__ */ React3.createElement(FetchersContext.Provider, { value: fetcherData.current }, /* @__PURE__ */ React3.createElement(ViewTransitionContext.Provider, { value: vtContext }, /* @__PURE__ */ React3.createElement(</span><span class="s2">\n    </span><span class="s1">Router,</span><span class="s2">\n    </span><span class="s1">{</span><span class="s2">\n      </span><span class="s1">basename,</span><span class="s2">\n      </span><span class="s1">location: state.location,</span><span class="s2">\n      </span><span class="s1">navigationType: state.historyAction,</span><span class="s2">\n      </span><span class="s1">navigator</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">/* @__PURE__ */ React3.createElement(</span><span class="s2">\n      </span><span class="s1">MemoizedDataRoutes,</span><span class="s2">\n      </span><span class="s1">{</span><span class="s2">\n        </span><span class="s1">routes: router.routes,</span><span class="s2">\n        </span><span class="s1">future: router.future,</span><span class="s2">\n        </span><span class="s1">state</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">)</span><span class="s2">\n  </span><span class="s1">))))), null);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var MemoizedDataRoutes = React3.memo(DataRoutes);</span><span class="s2">\n</span><span class="s1">function DataRoutes({</span><span class="s2">\n  </span><span class="s1">routes,</span><span class="s2">\n  </span><span class="s1">future,</span><span class="s2">\n  </span><span class="s1">state</span><span class="s2">\n</span><span class="s1">}) {</span><span class="s2">\n  </span><span class="s1">return useRoutesImpl(routes, void 0, state, future);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function MemoryRouter({</span><span class="s2">\n  </span><span class="s1">basename,</span><span class="s2">\n  </span><span class="s1">children,</span><span class="s2">\n  </span><span class="s1">initialEntries,</span><span class="s2">\n  </span><span class="s1">initialIndex</span><span class="s2">\n</span><span class="s1">}) {</span><span class="s2">\n  </span><span class="s1">let historyRef = React3.useRef();</span><span class="s2">\n  </span><span class="s1">if (historyRef.current == null) {</span><span class="s2">\n    </span><span class="s1">historyRef.current = createMemoryHistory({</span><span class="s2">\n      </span><span class="s1">initialEntries,</span><span class="s2">\n      </span><span class="s1">initialIndex,</span><span class="s2">\n      </span><span class="s1">v5Compat: true</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let history = historyRef.current;</span><span class="s2">\n  </span><span class="s1">let [state, setStateImpl] = React3.useState({</span><span class="s2">\n    </span><span class="s1">action: history.action,</span><span class="s2">\n    </span><span class="s1">location: history.location</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">let setState = React3.useCallback(</span><span class="s2">\n    </span><span class="s1">(newState) =&gt; {</span><span class="s2">\n      </span><span class="s1">React3.startTransition(() =&gt; setStateImpl(newState));</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">[setStateImpl]</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">React3.useLayoutEffect(() =&gt; history.listen(setState), [history, setState]);</span><span class="s2">\n  </span><span class="s1">return /* @__PURE__ */ React3.createElement(</span><span class="s2">\n    </span><span class="s1">Router,</span><span class="s2">\n    </span><span class="s1">{</span><span class="s2">\n      </span><span class="s1">basename,</span><span class="s2">\n      </span><span class="s1">children,</span><span class="s2">\n      </span><span class="s1">location: state.location,</span><span class="s2">\n      </span><span class="s1">navigationType: state.action,</span><span class="s2">\n      </span><span class="s1">navigator: history</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function Navigate({</span><span class="s2">\n  </span><span class="s1">to,</span><span class="s2">\n  </span><span class="s1">replace: replace2,</span><span class="s2">\n  </span><span class="s1">state,</span><span class="s2">\n  </span><span class="s1">relative</span><span class="s2">\n</span><span class="s1">}) {</span><span class="s2">\n  </span><span class="s1">invariant(</span><span class="s2">\n    </span><span class="s1">useInRouterContext(),</span><span class="s2">\n    </span><span class="s1">// TODO: This error is probably because they somehow have 2 versions of</span><span class="s2">\n    </span><span class="s1">// the router loaded. We can help them understand how to avoid that.</span><span class="s2">\n    </span><span class="s1">`&lt;Navigate&gt; may be used only in the context of a &lt;Router&gt; component.`</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let { static: isStatic } = React3.useContext(NavigationContext);</span><span class="s2">\n  </span><span class="s1">warning(</span><span class="s2">\n    </span><span class="s1">!isStatic,</span><span class="s2">\n    </span><span class="s1">`&lt;Navigate&gt; must not be used on the initial render in a &lt;StaticRouter&gt;. This is a no-op, but you should modify your code so the &lt;Navigate&gt; is only ever rendered in response to some user interaction or state change.`</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let { matches } = React3.useContext(RouteContext);</span><span class="s2">\n  </span><span class="s1">let { pathname: locationPathname } = useLocation();</span><span class="s2">\n  </span><span class="s1">let navigate = useNavigate();</span><span class="s2">\n  </span><span class="s1">let path = resolveTo(</span><span class="s2">\n    </span><span class="s1">to,</span><span class="s2">\n    </span><span class="s1">getResolveToMatches(matches),</span><span class="s2">\n    </span><span class="s1">locationPathname,</span><span class="s2">\n    </span><span class="s1">relative === </span><span class="s2">\&quot;</span><span class="s1">path</span><span class="s2">\&quot;\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let jsonPath = JSON.stringify(path);</span><span class="s2">\n  </span><span class="s1">React3.useEffect(() =&gt; {</span><span class="s2">\n    </span><span class="s1">navigate(JSON.parse(jsonPath), { replace: replace2, state, relative });</span><span class="s2">\n  </span><span class="s1">}, [navigate, jsonPath, relative, replace2, state]);</span><span class="s2">\n  </span><span class="s1">return null;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function Outlet(props) {</span><span class="s2">\n  </span><span class="s1">return useOutlet(props.context);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function Route(_props) {</span><span class="s2">\n  </span><span class="s1">invariant(</span><span class="s2">\n    </span><span class="s1">false,</span><span class="s2">\n    </span><span class="s1">`A &lt;Route&gt; is only ever to be used as the child of &lt;Routes&gt; element, never rendered directly. Please wrap your &lt;Route&gt; in a &lt;Routes&gt;.`</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function Router({</span><span class="s2">\n  </span><span class="s1">basename: basenameProp = </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">children = null,</span><span class="s2">\n  </span><span class="s1">location: locationProp,</span><span class="s2">\n  </span><span class="s1">navigationType = </span><span class="s2">\&quot;</span><span class="s1">POP</span><span class="s2">\&quot; </span><span class="s1">/* Pop */,</span><span class="s2">\n  </span><span class="s1">navigator,</span><span class="s2">\n  </span><span class="s1">static: staticProp = false</span><span class="s2">\n</span><span class="s1">}) {</span><span class="s2">\n  </span><span class="s1">invariant(</span><span class="s2">\n    </span><span class="s1">!useInRouterContext(),</span><span class="s2">\n    </span><span class="s1">`You cannot render a &lt;Router&gt; inside another &lt;Router&gt;. You should never have more than one in your app.`</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let basename = basenameProp.replace(/^</span><span class="s2">\\</span><span class="s1">/*/, </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let navigationContext = React3.useMemo(</span><span class="s2">\n    </span><span class="s1">() =&gt; ({</span><span class="s2">\n      </span><span class="s1">basename,</span><span class="s2">\n      </span><span class="s1">navigator,</span><span class="s2">\n      </span><span class="s1">static: staticProp,</span><span class="s2">\n      </span><span class="s1">future: {}</span><span class="s2">\n    </span><span class="s1">}),</span><span class="s2">\n    </span><span class="s1">[basename, navigator, staticProp]</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">if (typeof locationProp === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">locationProp = parsePath(locationProp);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let {</span><span class="s2">\n    </span><span class="s1">pathname = </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">search = </span><span class="s2">\&quot;\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">hash = </span><span class="s2">\&quot;\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">state = null,</span><span class="s2">\n    </span><span class="s1">key = </span><span class="s2">\&quot;</span><span class="s1">default</span><span class="s2">\&quot;\n  </span><span class="s1">} = locationProp;</span><span class="s2">\n  </span><span class="s1">let locationContext = React3.useMemo(() =&gt; {</span><span class="s2">\n    </span><span class="s1">let trailingPathname = stripBasename(pathname, basename);</span><span class="s2">\n    </span><span class="s1">if (trailingPathname == null) {</span><span class="s2">\n      </span><span class="s1">return null;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return {</span><span class="s2">\n      </span><span class="s1">location: {</span><span class="s2">\n        </span><span class="s1">pathname: trailingPathname,</span><span class="s2">\n        </span><span class="s1">search,</span><span class="s2">\n        </span><span class="s1">hash,</span><span class="s2">\n        </span><span class="s1">state,</span><span class="s2">\n        </span><span class="s1">key</span><span class="s2">\n      </span><span class="s1">},</span><span class="s2">\n      </span><span class="s1">navigationType</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}, [basename, pathname, search, hash, state, key, navigationType]);</span><span class="s2">\n  </span><span class="s1">warning(</span><span class="s2">\n    </span><span class="s1">locationContext != null,</span><span class="s2">\n    </span><span class="s1">`&lt;Router basename=</span><span class="s2">\&quot;</span><span class="s1">${basename}</span><span class="s2">\&quot;</span><span class="s1">&gt; is not able to match the URL </span><span class="s2">\&quot;</span><span class="s1">${pathname}${search}${hash}</span><span class="s2">\&quot; </span><span class="s1">because it does not start with the basename, so the &lt;Router&gt; won't render anything.`</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">if (locationContext == null) {</span><span class="s2">\n    </span><span class="s1">return null;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return /* @__PURE__ */ React3.createElement(NavigationContext.Provider, { value: navigationContext }, /* @__PURE__ */ React3.createElement(LocationContext.Provider, { children, value: locationContext }));</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function Routes({</span><span class="s2">\n  </span><span class="s1">children,</span><span class="s2">\n  </span><span class="s1">location</span><span class="s2">\n</span><span class="s1">}) {</span><span class="s2">\n  </span><span class="s1">return useRoutes(createRoutesFromChildren(children), location);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function Await({</span><span class="s2">\n  </span><span class="s1">children,</span><span class="s2">\n  </span><span class="s1">errorElement,</span><span class="s2">\n  </span><span class="s1">resolve</span><span class="s2">\n</span><span class="s1">}) {</span><span class="s2">\n  </span><span class="s1">return /* @__PURE__ */ React3.createElement(AwaitErrorBoundary, { resolve, errorElement }, /* @__PURE__ */ React3.createElement(ResolveAwait, null, children));</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var AwaitErrorBoundary = class extends React3.Component {</span><span class="s2">\n  </span><span class="s1">constructor(props) {</span><span class="s2">\n    </span><span class="s1">super(props);</span><span class="s2">\n    </span><span class="s1">this.state = { error: null };</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">static getDerivedStateFromError(error) {</span><span class="s2">\n    </span><span class="s1">return { error };</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">componentDidCatch(error, errorInfo) {</span><span class="s2">\n    </span><span class="s1">console.error(</span><span class="s2">\n      \&quot;</span><span class="s1">&lt;Await&gt; caught the following error during render</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">error,</span><span class="s2">\n      </span><span class="s1">errorInfo</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">render() {</span><span class="s2">\n    </span><span class="s1">let { children, errorElement, resolve } = this.props;</span><span class="s2">\n    </span><span class="s1">let promise = null;</span><span class="s2">\n    </span><span class="s1">let status = 0 /* pending */;</span><span class="s2">\n    </span><span class="s1">if (!(resolve instanceof Promise)) {</span><span class="s2">\n      </span><span class="s1">status = 1 /* success */;</span><span class="s2">\n      </span><span class="s1">promise = Promise.resolve();</span><span class="s2">\n      </span><span class="s1">Object.defineProperty(promise, </span><span class="s2">\&quot;</span><span class="s1">_tracked</span><span class="s2">\&quot;</span><span class="s1">, { get: () =&gt; true });</span><span class="s2">\n      </span><span class="s1">Object.defineProperty(promise, </span><span class="s2">\&quot;</span><span class="s1">_data</span><span class="s2">\&quot;</span><span class="s1">, { get: () =&gt; resolve });</span><span class="s2">\n    </span><span class="s1">} else if (this.state.error) {</span><span class="s2">\n      </span><span class="s1">status = 2 /* error */;</span><span class="s2">\n      </span><span class="s1">let renderError = this.state.error;</span><span class="s2">\n      </span><span class="s1">promise = Promise.reject().catch(() =&gt; {</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">Object.defineProperty(promise, </span><span class="s2">\&quot;</span><span class="s1">_tracked</span><span class="s2">\&quot;</span><span class="s1">, { get: () =&gt; true });</span><span class="s2">\n      </span><span class="s1">Object.defineProperty(promise, </span><span class="s2">\&quot;</span><span class="s1">_error</span><span class="s2">\&quot;</span><span class="s1">, { get: () =&gt; renderError });</span><span class="s2">\n    </span><span class="s1">} else if (resolve._tracked) {</span><span class="s2">\n      </span><span class="s1">promise = resolve;</span><span class="s2">\n      </span><span class="s1">status = </span><span class="s2">\&quot;</span><span class="s1">_error</span><span class="s2">\&quot; </span><span class="s1">in promise ? 2 /* error */ : </span><span class="s2">\&quot;</span><span class="s1">_data</span><span class="s2">\&quot; </span><span class="s1">in promise ? 1 /* success */ : 0 /* pending */;</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">status = 0 /* pending */;</span><span class="s2">\n      </span><span class="s1">Object.defineProperty(resolve, </span><span class="s2">\&quot;</span><span class="s1">_tracked</span><span class="s2">\&quot;</span><span class="s1">, { get: () =&gt; true });</span><span class="s2">\n      </span><span class="s1">promise = resolve.then(</span><span class="s2">\n        </span><span class="s1">(data2) =&gt; Object.defineProperty(resolve, </span><span class="s2">\&quot;</span><span class="s1">_data</span><span class="s2">\&quot;</span><span class="s1">, { get: () =&gt; data2 }),</span><span class="s2">\n        </span><span class="s1">(error) =&gt; Object.defineProperty(resolve, </span><span class="s2">\&quot;</span><span class="s1">_error</span><span class="s2">\&quot;</span><span class="s1">, { get: () =&gt; error })</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (status === 2 /* error */ &amp;&amp; !errorElement) {</span><span class="s2">\n      </span><span class="s1">throw promise._error;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (status === 2 /* error */) {</span><span class="s2">\n      </span><span class="s1">return /* @__PURE__ */ React3.createElement(AwaitContext.Provider, { value: promise, children: errorElement });</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (status === 1 /* success */) {</span><span class="s2">\n      </span><span class="s1">return /* @__PURE__ */ React3.createElement(AwaitContext.Provider, { value: promise, children });</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">throw promise;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">function ResolveAwait({</span><span class="s2">\n  </span><span class="s1">children</span><span class="s2">\n</span><span class="s1">}) {</span><span class="s2">\n  </span><span class="s1">let data2 = useAsyncValue();</span><span class="s2">\n  </span><span class="s1">let toRender = typeof children === </span><span class="s2">\&quot;</span><span class="s1">function</span><span class="s2">\&quot; </span><span class="s1">? children(data2) : children;</span><span class="s2">\n  </span><span class="s1">return /* @__PURE__ */ React3.createElement(React3.Fragment, null, toRender);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createRoutesFromChildren(children, parentPath = []) {</span><span class="s2">\n  </span><span class="s1">let routes = [];</span><span class="s2">\n  </span><span class="s1">React3.Children.forEach(children, (element, index) =&gt; {</span><span class="s2">\n    </span><span class="s1">if (!React3.isValidElement(element)) {</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let treePath = [...parentPath, index];</span><span class="s2">\n    </span><span class="s1">if (element.type === React3.Fragment) {</span><span class="s2">\n      </span><span class="s1">routes.push.apply(</span><span class="s2">\n        </span><span class="s1">routes,</span><span class="s2">\n        </span><span class="s1">createRoutesFromChildren(element.props.children, treePath)</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">invariant(</span><span class="s2">\n      </span><span class="s1">element.type === Route,</span><span class="s2">\n      </span><span class="s1">`[${typeof element.type === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">? element.type : element.type.name}] is not a &lt;Route&gt; component. All component children of &lt;Routes&gt; must be a &lt;Route&gt; or &lt;React.Fragment&gt;`</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">invariant(</span><span class="s2">\n      </span><span class="s1">!element.props.index || !element.props.children,</span><span class="s2">\n      \&quot;</span><span class="s1">An index route cannot have child routes.</span><span class="s2">\&quot;\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">let route = {</span><span class="s2">\n      </span><span class="s1">id: element.props.id || treePath.join(</span><span class="s2">\&quot;</span><span class="s1">-</span><span class="s2">\&quot;</span><span class="s1">),</span><span class="s2">\n      </span><span class="s1">caseSensitive: element.props.caseSensitive,</span><span class="s2">\n      </span><span class="s1">element: element.props.element,</span><span class="s2">\n      </span><span class="s1">Component: element.props.Component,</span><span class="s2">\n      </span><span class="s1">index: element.props.index,</span><span class="s2">\n      </span><span class="s1">path: element.props.path,</span><span class="s2">\n      </span><span class="s1">loader: element.props.loader,</span><span class="s2">\n      </span><span class="s1">action: element.props.action,</span><span class="s2">\n      </span><span class="s1">hydrateFallbackElement: element.props.hydrateFallbackElement,</span><span class="s2">\n      </span><span class="s1">HydrateFallback: element.props.HydrateFallback,</span><span class="s2">\n      </span><span class="s1">errorElement: element.props.errorElement,</span><span class="s2">\n      </span><span class="s1">ErrorBoundary: element.props.ErrorBoundary,</span><span class="s2">\n      </span><span class="s1">hasErrorBoundary: element.props.hasErrorBoundary === true || element.props.ErrorBoundary != null || element.props.errorElement != null,</span><span class="s2">\n      </span><span class="s1">shouldRevalidate: element.props.shouldRevalidate,</span><span class="s2">\n      </span><span class="s1">handle: element.props.handle,</span><span class="s2">\n      </span><span class="s1">lazy: element.props.lazy</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">if (element.props.children) {</span><span class="s2">\n      </span><span class="s1">route.children = createRoutesFromChildren(</span><span class="s2">\n        </span><span class="s1">element.props.children,</span><span class="s2">\n        </span><span class="s1">treePath</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">routes.push(route);</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">return routes;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var createRoutesFromElements = createRoutesFromChildren;</span><span class="s2">\n</span><span class="s1">function renderMatches(matches) {</span><span class="s2">\n  </span><span class="s1">return _renderMatches(matches);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/dom/lib.tsx</span><span class="s2">\n</span><span class="s1">import * as React10 from </span><span class="s2">\&quot;</span><span class="s1">react</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n</span><span class="s1">// lib/dom/dom.ts</span><span class="s2">\n</span><span class="s1">var defaultMethod = </span><span class="s2">\&quot;</span><span class="s1">get</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">var defaultEncType = </span><span class="s2">\&quot;</span><span class="s1">application/x-www-form-urlencoded</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">function isHtmlElement(object) {</span><span class="s2">\n  </span><span class="s1">return object != null &amp;&amp; typeof object.tagName === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isButtonElement(object) {</span><span class="s2">\n  </span><span class="s1">return isHtmlElement(object) &amp;&amp; object.tagName.toLowerCase() === </span><span class="s2">\&quot;</span><span class="s1">button</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isFormElement(object) {</span><span class="s2">\n  </span><span class="s1">return isHtmlElement(object) &amp;&amp; object.tagName.toLowerCase() === </span><span class="s2">\&quot;</span><span class="s1">form</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isInputElement(object) {</span><span class="s2">\n  </span><span class="s1">return isHtmlElement(object) &amp;&amp; object.tagName.toLowerCase() === </span><span class="s2">\&quot;</span><span class="s1">input</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isModifiedEvent(event) {</span><span class="s2">\n  </span><span class="s1">return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function shouldProcessLinkClick(event, target) {</span><span class="s2">\n  </span><span class="s1">return event.button === 0 &amp;&amp; // Ignore everything but left clicks</span><span class="s2">\n  </span><span class="s1">(!target || target === </span><span class="s2">\&quot;</span><span class="s1">_self</span><span class="s2">\&quot;</span><span class="s1">) &amp;&amp; // Let browser handle </span><span class="s2">\&quot;</span><span class="s1">target=_blank</span><span class="s2">\&quot; </span><span class="s1">etc.</span><span class="s2">\n  </span><span class="s1">!isModifiedEvent(event);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createSearchParams(init = </span><span class="s2">\&quot;\&quot;</span><span class="s1">) {</span><span class="s2">\n  </span><span class="s1">return new URLSearchParams(</span><span class="s2">\n    </span><span class="s1">typeof init === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">|| Array.isArray(init) || init instanceof URLSearchParams ? init : Object.keys(init).reduce((memo2, key) =&gt; {</span><span class="s2">\n      </span><span class="s1">let value = init[key];</span><span class="s2">\n      </span><span class="s1">return memo2.concat(</span><span class="s2">\n        </span><span class="s1">Array.isArray(value) ? value.map((v) =&gt; [key, v]) : [[key, value]]</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}, [])</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getSearchParamsForLocation(locationSearch, defaultSearchParams) {</span><span class="s2">\n  </span><span class="s1">let searchParams = createSearchParams(locationSearch);</span><span class="s2">\n  </span><span class="s1">if (defaultSearchParams) {</span><span class="s2">\n    </span><span class="s1">defaultSearchParams.forEach((_, key) =&gt; {</span><span class="s2">\n      </span><span class="s1">if (!searchParams.has(key)) {</span><span class="s2">\n        </span><span class="s1">defaultSearchParams.getAll(key).forEach((value) =&gt; {</span><span class="s2">\n          </span><span class="s1">searchParams.append(key, value);</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return searchParams;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var _formDataSupportsSubmitter = null;</span><span class="s2">\n</span><span class="s1">function isFormDataSubmitterSupported() {</span><span class="s2">\n  </span><span class="s1">if (_formDataSupportsSubmitter === null) {</span><span class="s2">\n    </span><span class="s1">try {</span><span class="s2">\n      </span><span class="s1">new FormData(</span><span class="s2">\n        </span><span class="s1">document.createElement(</span><span class="s2">\&quot;</span><span class="s1">form</span><span class="s2">\&quot;</span><span class="s1">),</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error if FormData supports the submitter parameter, this will throw</span><span class="s2">\n        </span><span class="s1">0</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">_formDataSupportsSubmitter = false;</span><span class="s2">\n    </span><span class="s1">} catch (e) {</span><span class="s2">\n      </span><span class="s1">_formDataSupportsSubmitter = true;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return _formDataSupportsSubmitter;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var supportedFormEncTypes = /* @__PURE__ */ new Set([</span><span class="s2">\n  \&quot;</span><span class="s1">application/x-www-form-urlencoded</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">multipart/form-data</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">text/plain</span><span class="s2">\&quot;\n</span><span class="s1">]);</span><span class="s2">\n</span><span class="s1">function getFormEncType(encType) {</span><span class="s2">\n  </span><span class="s1">if (encType != null &amp;&amp; !supportedFormEncTypes.has(encType)) {</span><span class="s2">\n    </span><span class="s1">warning(</span><span class="s2">\n      </span><span class="s1">false,</span><span class="s2">\n      </span><span class="s1">`</span><span class="s2">\&quot;</span><span class="s1">${encType}</span><span class="s2">\&quot; </span><span class="s1">is not a valid </span><span class="s2">\\</span><span class="s1">`encType</span><span class="s2">\\</span><span class="s1">` for </span><span class="s2">\\</span><span class="s1">`&lt;Form&gt;</span><span class="s2">\\</span><span class="s1">`/</span><span class="s2">\\</span><span class="s1">`&lt;fetcher.Form&gt;</span><span class="s2">\\</span><span class="s1">` and will default to </span><span class="s2">\&quot;</span><span class="s1">${defaultEncType}</span><span class="s2">\&quot;</span><span class="s1">`</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">return null;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return encType;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getFormSubmissionInfo(target, basename) {</span><span class="s2">\n  </span><span class="s1">let method;</span><span class="s2">\n  </span><span class="s1">let action;</span><span class="s2">\n  </span><span class="s1">let encType;</span><span class="s2">\n  </span><span class="s1">let formData;</span><span class="s2">\n  </span><span class="s1">let body;</span><span class="s2">\n  </span><span class="s1">if (isFormElement(target)) {</span><span class="s2">\n    </span><span class="s1">let attr = target.getAttribute(</span><span class="s2">\&quot;</span><span class="s1">action</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">action = attr ? stripBasename(attr, basename) : null;</span><span class="s2">\n    </span><span class="s1">method = target.getAttribute(</span><span class="s2">\&quot;</span><span class="s1">method</span><span class="s2">\&quot;</span><span class="s1">) || defaultMethod;</span><span class="s2">\n    </span><span class="s1">encType = getFormEncType(target.getAttribute(</span><span class="s2">\&quot;</span><span class="s1">enctype</span><span class="s2">\&quot;</span><span class="s1">)) || defaultEncType;</span><span class="s2">\n    </span><span class="s1">formData = new FormData(target);</span><span class="s2">\n  </span><span class="s1">} else if (isButtonElement(target) || isInputElement(target) &amp;&amp; (target.type === </span><span class="s2">\&quot;</span><span class="s1">submit</span><span class="s2">\&quot; </span><span class="s1">|| target.type === </span><span class="s2">\&quot;</span><span class="s1">image</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n    </span><span class="s1">let form = target.form;</span><span class="s2">\n    </span><span class="s1">if (form == null) {</span><span class="s2">\n      </span><span class="s1">throw new Error(</span><span class="s2">\n        </span><span class="s1">`Cannot submit a &lt;button&gt; or &lt;input type=</span><span class="s2">\&quot;</span><span class="s1">submit</span><span class="s2">\&quot;</span><span class="s1">&gt; without a &lt;form&gt;`</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let attr = target.getAttribute(</span><span class="s2">\&quot;</span><span class="s1">formaction</span><span class="s2">\&quot;</span><span class="s1">) || form.getAttribute(</span><span class="s2">\&quot;</span><span class="s1">action</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">action = attr ? stripBasename(attr, basename) : null;</span><span class="s2">\n    </span><span class="s1">method = target.getAttribute(</span><span class="s2">\&quot;</span><span class="s1">formmethod</span><span class="s2">\&quot;</span><span class="s1">) || form.getAttribute(</span><span class="s2">\&quot;</span><span class="s1">method</span><span class="s2">\&quot;</span><span class="s1">) || defaultMethod;</span><span class="s2">\n    </span><span class="s1">encType = getFormEncType(target.getAttribute(</span><span class="s2">\&quot;</span><span class="s1">formenctype</span><span class="s2">\&quot;</span><span class="s1">)) || getFormEncType(form.getAttribute(</span><span class="s2">\&quot;</span><span class="s1">enctype</span><span class="s2">\&quot;</span><span class="s1">)) || defaultEncType;</span><span class="s2">\n    </span><span class="s1">formData = new FormData(form, target);</span><span class="s2">\n    </span><span class="s1">if (!isFormDataSubmitterSupported()) {</span><span class="s2">\n      </span><span class="s1">let { name, type, value } = target;</span><span class="s2">\n      </span><span class="s1">if (type === </span><span class="s2">\&quot;</span><span class="s1">image</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">let prefix = name ? `${name}.` : </span><span class="s2">\&quot;\&quot;</span><span class="s1">;</span><span class="s2">\n        </span><span class="s1">formData.append(`${prefix}x`, </span><span class="s2">\&quot;</span><span class="s1">0</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">formData.append(`${prefix}y`, </span><span class="s2">\&quot;</span><span class="s1">0</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">} else if (name) {</span><span class="s2">\n        </span><span class="s1">formData.append(name, value);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">} else if (isHtmlElement(target)) {</span><span class="s2">\n    </span><span class="s1">throw new Error(</span><span class="s2">\n      </span><span class="s1">`Cannot submit element that is not &lt;form&gt;, &lt;button&gt;, or &lt;input type=</span><span class="s2">\&quot;</span><span class="s1">submit|image</span><span class="s2">\&quot;</span><span class="s1">&gt;`</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">method = defaultMethod;</span><span class="s2">\n    </span><span class="s1">action = null;</span><span class="s2">\n    </span><span class="s1">encType = defaultEncType;</span><span class="s2">\n    </span><span class="s1">body = target;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (formData &amp;&amp; encType === </span><span class="s2">\&quot;</span><span class="s1">text/plain</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">body = formData;</span><span class="s2">\n    </span><span class="s1">formData = void 0;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return { action, method: method.toLowerCase(), encType, formData, body };</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/dom/ssr/components.tsx</span><span class="s2">\n</span><span class="s1">import * as React9 from </span><span class="s2">\&quot;</span><span class="s1">react</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n</span><span class="s1">// lib/dom/ssr/invariant.ts</span><span class="s2">\n</span><span class="s1">function invariant2(value, message) {</span><span class="s2">\n  </span><span class="s1">if (value === false || value === null || typeof value === </span><span class="s2">\&quot;</span><span class="s1">undefined</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">throw new Error(message);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/dom/ssr/routeModules.ts</span><span class="s2">\n</span><span class="s1">async function loadRouteModule(route, routeModulesCache) {</span><span class="s2">\n  </span><span class="s1">if (route.id in routeModulesCache) {</span><span class="s2">\n    </span><span class="s1">return routeModulesCache[route.id];</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">try {</span><span class="s2">\n    </span><span class="s1">let routeModule = await import(</span><span class="s2">\n      </span><span class="s1">/* @vite-ignore */</span><span class="s2">\n      </span><span class="s1">/* webpackIgnore: true */</span><span class="s2">\n      </span><span class="s1">route.module</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">routeModulesCache[route.id] = routeModule;</span><span class="s2">\n    </span><span class="s1">return routeModule;</span><span class="s2">\n  </span><span class="s1">} catch (error) {</span><span class="s2">\n    </span><span class="s1">console.error(</span><span class="s2">\n      </span><span class="s1">`Error loading route module </span><span class="s2">\\</span><span class="s1">`${route.module}</span><span class="s2">\\</span><span class="s1">`, reloading page...`</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">console.error(error);</span><span class="s2">\n    </span><span class="s1">if (window.__reactRouterContext &amp;&amp; window.__reactRouterContext.isSpaMode &amp;&amp; // @ts-expect-error</span><span class="s2">\n    </span><span class="s1">import.meta.hot) {</span><span class="s2">\n      </span><span class="s1">throw error;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">window.location.reload();</span><span class="s2">\n    </span><span class="s1">return new Promise(() =&gt; {</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/dom/ssr/links.ts</span><span class="s2">\n</span><span class="s1">function getKeyedLinksForMatches(matches, routeModules, manifest) {</span><span class="s2">\n  </span><span class="s1">let descriptors = matches.map((match) =&gt; {</span><span class="s2">\n    </span><span class="s1">let module = routeModules[match.route.id];</span><span class="s2">\n    </span><span class="s1">let route = manifest.routes[match.route.id];</span><span class="s2">\n    </span><span class="s1">return [</span><span class="s2">\n      </span><span class="s1">route &amp;&amp; route.css ? route.css.map((href2) =&gt; ({ rel: </span><span class="s2">\&quot;</span><span class="s1">stylesheet</span><span class="s2">\&quot;</span><span class="s1">, href: href2 })) : [],</span><span class="s2">\n      </span><span class="s1">module?.links?.() || []</span><span class="s2">\n    </span><span class="s1">];</span><span class="s2">\n  </span><span class="s1">}).flat(2);</span><span class="s2">\n  </span><span class="s1">let preloads = getModuleLinkHrefs(matches, manifest);</span><span class="s2">\n  </span><span class="s1">return dedupeLinkDescriptors(descriptors, preloads);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getRouteCssDescriptors(route) {</span><span class="s2">\n  </span><span class="s1">if (!route.css) return [];</span><span class="s2">\n  </span><span class="s1">return route.css.map((href2) =&gt; ({ rel: </span><span class="s2">\&quot;</span><span class="s1">stylesheet</span><span class="s2">\&quot;</span><span class="s1">, href: href2 }));</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">async function prefetchRouteCss(route) {</span><span class="s2">\n  </span><span class="s1">if (!route.css) return;</span><span class="s2">\n  </span><span class="s1">let descriptors = getRouteCssDescriptors(route);</span><span class="s2">\n  </span><span class="s1">await Promise.all(descriptors.map(prefetchStyleLink));</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">async function prefetchStyleLinks(route, routeModule) {</span><span class="s2">\n  </span><span class="s1">if (!route.css &amp;&amp; !routeModule.links || !isPreloadSupported()) return;</span><span class="s2">\n  </span><span class="s1">let descriptors = [];</span><span class="s2">\n  </span><span class="s1">if (route.css) {</span><span class="s2">\n    </span><span class="s1">descriptors.push(...getRouteCssDescriptors(route));</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (routeModule.links) {</span><span class="s2">\n    </span><span class="s1">descriptors.push(...routeModule.links());</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (descriptors.length === 0) return;</span><span class="s2">\n  </span><span class="s1">let styleLinks = [];</span><span class="s2">\n  </span><span class="s1">for (let descriptor of descriptors) {</span><span class="s2">\n    </span><span class="s1">if (!isPageLinkDescriptor(descriptor) &amp;&amp; descriptor.rel === </span><span class="s2">\&quot;</span><span class="s1">stylesheet</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">styleLinks.push({</span><span class="s2">\n        </span><span class="s1">...descriptor,</span><span class="s2">\n        </span><span class="s1">rel: </span><span class="s2">\&quot;</span><span class="s1">preload</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        </span><span class="s1">as: </span><span class="s2">\&quot;</span><span class="s1">style</span><span class="s2">\&quot;\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">await Promise.all(styleLinks.map(prefetchStyleLink));</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">async function prefetchStyleLink(descriptor) {</span><span class="s2">\n  </span><span class="s1">return new Promise((resolve) =&gt; {</span><span class="s2">\n    </span><span class="s1">if (descriptor.media &amp;&amp; !window.matchMedia(descriptor.media).matches || document.querySelector(</span><span class="s2">\n      </span><span class="s1">`link[rel=</span><span class="s2">\&quot;</span><span class="s1">stylesheet</span><span class="s2">\&quot;</span><span class="s1">][href=</span><span class="s2">\&quot;</span><span class="s1">${descriptor.href}</span><span class="s2">\&quot;</span><span class="s1">]`</span><span class="s2">\n    </span><span class="s1">)) {</span><span class="s2">\n      </span><span class="s1">return resolve();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let link = document.createElement(</span><span class="s2">\&quot;</span><span class="s1">link</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">Object.assign(link, descriptor);</span><span class="s2">\n    </span><span class="s1">function removeLink() {</span><span class="s2">\n      </span><span class="s1">if (document.head.contains(link)) {</span><span class="s2">\n        </span><span class="s1">document.head.removeChild(link);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">link.onload = () =&gt; {</span><span class="s2">\n      </span><span class="s1">removeLink();</span><span class="s2">\n      </span><span class="s1">resolve();</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">link.onerror = () =&gt; {</span><span class="s2">\n      </span><span class="s1">removeLink();</span><span class="s2">\n      </span><span class="s1">resolve();</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">document.head.appendChild(link);</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isPageLinkDescriptor(object) {</span><span class="s2">\n  </span><span class="s1">return object != null &amp;&amp; typeof object.page === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isHtmlLinkDescriptor(object) {</span><span class="s2">\n  </span><span class="s1">if (object == null) {</span><span class="s2">\n    </span><span class="s1">return false;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (object.href == null) {</span><span class="s2">\n    </span><span class="s1">return object.rel === </span><span class="s2">\&quot;</span><span class="s1">preload</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; typeof object.imageSrcSet === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; typeof object.imageSizes === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return typeof object.rel === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; typeof object.href === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">async function getKeyedPrefetchLinks(matches, manifest, routeModules) {</span><span class="s2">\n  </span><span class="s1">let links = await Promise.all(</span><span class="s2">\n    </span><span class="s1">matches.map(async (match) =&gt; {</span><span class="s2">\n      </span><span class="s1">let route = manifest.routes[match.route.id];</span><span class="s2">\n      </span><span class="s1">if (route) {</span><span class="s2">\n        </span><span class="s1">let mod = await loadRouteModule(route, routeModules);</span><span class="s2">\n        </span><span class="s1">return mod.links ? mod.links() : [];</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return [];</span><span class="s2">\n    </span><span class="s1">})</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">return dedupeLinkDescriptors(</span><span class="s2">\n    </span><span class="s1">links.flat(1).filter(isHtmlLinkDescriptor).filter((link) =&gt; link.rel === </span><span class="s2">\&quot;</span><span class="s1">stylesheet</span><span class="s2">\&quot; </span><span class="s1">|| link.rel === </span><span class="s2">\&quot;</span><span class="s1">preload</span><span class="s2">\&quot;</span><span class="s1">).map(</span><span class="s2">\n      </span><span class="s1">(link) =&gt; link.rel === </span><span class="s2">\&quot;</span><span class="s1">stylesheet</span><span class="s2">\&quot; </span><span class="s1">? { ...link, rel: </span><span class="s2">\&quot;</span><span class="s1">prefetch</span><span class="s2">\&quot;</span><span class="s1">, as: </span><span class="s2">\&quot;</span><span class="s1">style</span><span class="s2">\&quot; </span><span class="s1">} : { ...link, rel: </span><span class="s2">\&quot;</span><span class="s1">prefetch</span><span class="s2">\&quot; </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">)</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getNewMatchesForLinks(page, nextMatches, currentMatches, manifest, location, mode) {</span><span class="s2">\n  </span><span class="s1">let isNew = (match, index) =&gt; {</span><span class="s2">\n    </span><span class="s1">if (!currentMatches[index]) return true;</span><span class="s2">\n    </span><span class="s1">return match.route.id !== currentMatches[index].route.id;</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">let matchPathChanged = (match, index) =&gt; {</span><span class="s2">\n    </span><span class="s1">return (</span><span class="s2">\n      </span><span class="s1">// param change, /users/123 -&gt; /users/456</span><span class="s2">\n      </span><span class="s1">currentMatches[index].pathname !== match.pathname || // splat param changed, which is not present in match.path</span><span class="s2">\n      </span><span class="s1">// e.g. /files/images/avatar.jpg -&gt; files/finances.xls</span><span class="s2">\n      </span><span class="s1">currentMatches[index].route.path?.endsWith(</span><span class="s2">\&quot;</span><span class="s1">*</span><span class="s2">\&quot;</span><span class="s1">) &amp;&amp; currentMatches[index].params[</span><span class="s2">\&quot;</span><span class="s1">*</span><span class="s2">\&quot;</span><span class="s1">] !== match.params[</span><span class="s2">\&quot;</span><span class="s1">*</span><span class="s2">\&quot;</span><span class="s1">]</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">if (mode === </span><span class="s2">\&quot;</span><span class="s1">assets</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">return nextMatches.filter(</span><span class="s2">\n      </span><span class="s1">(match, index) =&gt; isNew(match, index) || matchPathChanged(match, index)</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (mode === </span><span class="s2">\&quot;</span><span class="s1">data</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">return nextMatches.filter((match, index) =&gt; {</span><span class="s2">\n      </span><span class="s1">let manifestRoute = manifest.routes[match.route.id];</span><span class="s2">\n      </span><span class="s1">if (!manifestRoute || !manifestRoute.hasLoader) {</span><span class="s2">\n        </span><span class="s1">return false;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (isNew(match, index) || matchPathChanged(match, index)) {</span><span class="s2">\n        </span><span class="s1">return true;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (match.route.shouldRevalidate) {</span><span class="s2">\n        </span><span class="s1">let routeChoice = match.route.shouldRevalidate({</span><span class="s2">\n          </span><span class="s1">currentUrl: new URL(</span><span class="s2">\n            </span><span class="s1">location.pathname + location.search + location.hash,</span><span class="s2">\n            </span><span class="s1">window.origin</span><span class="s2">\n          </span><span class="s1">),</span><span class="s2">\n          </span><span class="s1">currentParams: currentMatches[0]?.params || {},</span><span class="s2">\n          </span><span class="s1">nextUrl: new URL(page, window.origin),</span><span class="s2">\n          </span><span class="s1">nextParams: match.params,</span><span class="s2">\n          </span><span class="s1">defaultShouldRevalidate: true</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">if (typeof routeChoice === </span><span class="s2">\&quot;</span><span class="s1">boolean</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">return routeChoice;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return true;</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return [];</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getModuleLinkHrefs(matches, manifest, { includeHydrateFallback } = {}) {</span><span class="s2">\n  </span><span class="s1">return dedupeHrefs(</span><span class="s2">\n    </span><span class="s1">matches.map((match) =&gt; {</span><span class="s2">\n      </span><span class="s1">let route = manifest.routes[match.route.id];</span><span class="s2">\n      </span><span class="s1">if (!route) return [];</span><span class="s2">\n      </span><span class="s1">let hrefs = [route.module];</span><span class="s2">\n      </span><span class="s1">if (route.clientActionModule) {</span><span class="s2">\n        </span><span class="s1">hrefs = hrefs.concat(route.clientActionModule);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (route.clientLoaderModule) {</span><span class="s2">\n        </span><span class="s1">hrefs = hrefs.concat(route.clientLoaderModule);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (includeHydrateFallback &amp;&amp; route.hydrateFallbackModule) {</span><span class="s2">\n        </span><span class="s1">hrefs = hrefs.concat(route.hydrateFallbackModule);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (route.imports) {</span><span class="s2">\n        </span><span class="s1">hrefs = hrefs.concat(route.imports);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return hrefs;</span><span class="s2">\n    </span><span class="s1">}).flat(1)</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function dedupeHrefs(hrefs) {</span><span class="s2">\n  </span><span class="s1">return [...new Set(hrefs)];</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function sortKeys(obj) {</span><span class="s2">\n  </span><span class="s1">let sorted = {};</span><span class="s2">\n  </span><span class="s1">let keys = Object.keys(obj).sort();</span><span class="s2">\n  </span><span class="s1">for (let key of keys) {</span><span class="s2">\n    </span><span class="s1">sorted[key] = obj[key];</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return sorted;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function dedupeLinkDescriptors(descriptors, preloads) {</span><span class="s2">\n  </span><span class="s1">let set = /* @__PURE__ */ new Set();</span><span class="s2">\n  </span><span class="s1">let preloadsSet = new Set(preloads);</span><span class="s2">\n  </span><span class="s1">return descriptors.reduce((deduped, descriptor) =&gt; {</span><span class="s2">\n    </span><span class="s1">let alreadyModulePreload = preloads &amp;&amp; !isPageLinkDescriptor(descriptor) &amp;&amp; descriptor.as === </span><span class="s2">\&quot;</span><span class="s1">script</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; descriptor.href &amp;&amp; preloadsSet.has(descriptor.href);</span><span class="s2">\n    </span><span class="s1">if (alreadyModulePreload) {</span><span class="s2">\n      </span><span class="s1">return deduped;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let key = JSON.stringify(sortKeys(descriptor));</span><span class="s2">\n    </span><span class="s1">if (!set.has(key)) {</span><span class="s2">\n      </span><span class="s1">set.add(key);</span><span class="s2">\n      </span><span class="s1">deduped.push({ key, link: descriptor });</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return deduped;</span><span class="s2">\n  </span><span class="s1">}, []);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var _isPreloadSupported;</span><span class="s2">\n</span><span class="s1">function isPreloadSupported() {</span><span class="s2">\n  </span><span class="s1">if (_isPreloadSupported !== void 0) {</span><span class="s2">\n    </span><span class="s1">return _isPreloadSupported;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let el = document.createElement(</span><span class="s2">\&quot;</span><span class="s1">link</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">_isPreloadSupported = el.relList.supports(</span><span class="s2">\&quot;</span><span class="s1">preload</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">el = null;</span><span class="s2">\n  </span><span class="s1">return _isPreloadSupported;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/dom/ssr/markup.ts</span><span class="s2">\n</span><span class="s1">var ESCAPE_LOOKUP = {</span><span class="s2">\n  \&quot;</span><span class="s1">&amp;</span><span class="s2">\&quot;</span><span class="s1">: </span><span class="s2">\&quot;\\\\</span><span class="s1">u0026</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">&gt;</span><span class="s2">\&quot;</span><span class="s1">: </span><span class="s2">\&quot;\\\\</span><span class="s1">u003e</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">&lt;</span><span class="s2">\&quot;</span><span class="s1">: </span><span class="s2">\&quot;\\\\</span><span class="s1">u003c</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;\\</span><span class="s1">u2028</span><span class="s2">\&quot;</span><span class="s1">: </span><span class="s2">\&quot;\\\\</span><span class="s1">u2028</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;\\</span><span class="s1">u2029</span><span class="s2">\&quot;</span><span class="s1">: </span><span class="s2">\&quot;\\\\</span><span class="s1">u2029</span><span class="s2">\&quot;\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">var ESCAPE_REGEX = /[&amp;&gt;&lt;</span><span class="s2">\\</span><span class="s1">u2028</span><span class="s2">\\</span><span class="s1">u2029]/g;</span><span class="s2">\n</span><span class="s1">function escapeHtml(html) {</span><span class="s2">\n  </span><span class="s1">return html.replace(ESCAPE_REGEX, (match) =&gt; ESCAPE_LOOKUP[match]);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createHtml(html) {</span><span class="s2">\n  </span><span class="s1">return { __html: html };</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/dom/ssr/single-fetch.tsx</span><span class="s2">\n</span><span class="s1">import * as React4 from </span><span class="s2">\&quot;</span><span class="s1">react</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n</span><span class="s1">// vendor/turbo-stream-v2/utils.ts</span><span class="s2">\n</span><span class="s1">var HOLE = -1;</span><span class="s2">\n</span><span class="s1">var NAN = -2;</span><span class="s2">\n</span><span class="s1">var NEGATIVE_INFINITY = -3;</span><span class="s2">\n</span><span class="s1">var NEGATIVE_ZERO = -4;</span><span class="s2">\n</span><span class="s1">var NULL = -5;</span><span class="s2">\n</span><span class="s1">var POSITIVE_INFINITY = -6;</span><span class="s2">\n</span><span class="s1">var UNDEFINED = -7;</span><span class="s2">\n</span><span class="s1">var TYPE_BIGINT = </span><span class="s2">\&quot;</span><span class="s1">B</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">var TYPE_DATE = </span><span class="s2">\&quot;</span><span class="s1">D</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">var TYPE_ERROR = </span><span class="s2">\&quot;</span><span class="s1">E</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">var TYPE_MAP = </span><span class="s2">\&quot;</span><span class="s1">M</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">var TYPE_NULL_OBJECT = </span><span class="s2">\&quot;</span><span class="s1">N</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">var TYPE_PROMISE = </span><span class="s2">\&quot;</span><span class="s1">P</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">var TYPE_REGEXP = </span><span class="s2">\&quot;</span><span class="s1">R</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">var TYPE_SET = </span><span class="s2">\&quot;</span><span class="s1">S</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">var TYPE_SYMBOL = </span><span class="s2">\&quot;</span><span class="s1">Y</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">var TYPE_URL = </span><span class="s2">\&quot;</span><span class="s1">U</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">var TYPE_PREVIOUS_RESOLVED = </span><span class="s2">\&quot;</span><span class="s1">Z</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">var Deferred2 = class {</span><span class="s2">\n  </span><span class="s1">constructor() {</span><span class="s2">\n    </span><span class="s1">this.promise = new Promise((resolve, reject) =&gt; {</span><span class="s2">\n      </span><span class="s1">this.resolve = resolve;</span><span class="s2">\n      </span><span class="s1">this.reject = reject;</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">function createLineSplittingTransform() {</span><span class="s2">\n  </span><span class="s1">const decoder = new TextDecoder();</span><span class="s2">\n  </span><span class="s1">let leftover = </span><span class="s2">\&quot;\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">return new TransformStream({</span><span class="s2">\n    </span><span class="s1">transform(chunk, controller) {</span><span class="s2">\n      </span><span class="s1">const str = decoder.decode(chunk, { stream: true });</span><span class="s2">\n      </span><span class="s1">const parts = (leftover + str).split(</span><span class="s2">\&quot;\\</span><span class="s1">n</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">leftover = parts.pop() || </span><span class="s2">\&quot;\&quot;</span><span class="s1">;</span><span class="s2">\n      </span><span class="s1">for (const part of parts) {</span><span class="s2">\n        </span><span class="s1">controller.enqueue(part);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">flush(controller) {</span><span class="s2">\n      </span><span class="s1">if (leftover) {</span><span class="s2">\n        </span><span class="s1">controller.enqueue(leftover);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// vendor/turbo-stream-v2/flatten.ts</span><span class="s2">\n</span><span class="s1">function flatten(input) {</span><span class="s2">\n  </span><span class="s1">const { indices } = this;</span><span class="s2">\n  </span><span class="s1">const existing = indices.get(input);</span><span class="s2">\n  </span><span class="s1">if (existing) return [existing];</span><span class="s2">\n  </span><span class="s1">if (input === void 0) return UNDEFINED;</span><span class="s2">\n  </span><span class="s1">if (input === null) return NULL;</span><span class="s2">\n  </span><span class="s1">if (Number.isNaN(input)) return NAN;</span><span class="s2">\n  </span><span class="s1">if (input === Number.POSITIVE_INFINITY) return POSITIVE_INFINITY;</span><span class="s2">\n  </span><span class="s1">if (input === Number.NEGATIVE_INFINITY) return NEGATIVE_INFINITY;</span><span class="s2">\n  </span><span class="s1">if (input === 0 &amp;&amp; 1 / input &lt; 0) return NEGATIVE_ZERO;</span><span class="s2">\n  </span><span class="s1">const index = this.index++;</span><span class="s2">\n  </span><span class="s1">indices.set(input, index);</span><span class="s2">\n  </span><span class="s1">stringify.call(this, input, index);</span><span class="s2">\n  </span><span class="s1">return index;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function stringify(input, index) {</span><span class="s2">\n  </span><span class="s1">const { deferred, plugins, postPlugins } = this;</span><span class="s2">\n  </span><span class="s1">const str = this.stringified;</span><span class="s2">\n  </span><span class="s1">const stack = [[input, index]];</span><span class="s2">\n  </span><span class="s1">while (stack.length &gt; 0) {</span><span class="s2">\n    </span><span class="s1">const [input2, index2] = stack.pop();</span><span class="s2">\n    </span><span class="s1">const partsForObj = (obj) =&gt; Object.keys(obj).map((k) =&gt; `</span><span class="s2">\&quot;</span><span class="s1">_${flatten.call(this, k)}</span><span class="s2">\&quot;</span><span class="s1">:${flatten.call(this, obj[k])}`).join(</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">let error = null;</span><span class="s2">\n    </span><span class="s1">switch (typeof input2) {</span><span class="s2">\n      </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">boolean</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n      </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">number</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n      </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n        </span><span class="s1">str[index2] = JSON.stringify(input2);</span><span class="s2">\n        </span><span class="s1">break;</span><span class="s2">\n      </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">bigint</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n        </span><span class="s1">str[index2] = `[</span><span class="s2">\&quot;</span><span class="s1">${TYPE_BIGINT}</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\&quot;</span><span class="s1">${input2}</span><span class="s2">\&quot;</span><span class="s1">]`;</span><span class="s2">\n        </span><span class="s1">break;</span><span class="s2">\n      </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">symbol</span><span class="s2">\&quot;</span><span class="s1">: {</span><span class="s2">\n        </span><span class="s1">const keyFor = Symbol.keyFor(input2);</span><span class="s2">\n        </span><span class="s1">if (!keyFor) {</span><span class="s2">\n          </span><span class="s1">error = new Error(</span><span class="s2">\n            \&quot;</span><span class="s1">Cannot encode symbol unless created with Symbol.for()</span><span class="s2">\&quot;\n          </span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">str[index2] = `[</span><span class="s2">\&quot;</span><span class="s1">${TYPE_SYMBOL}</span><span class="s2">\&quot;</span><span class="s1">,${JSON.stringify(keyFor)}]`;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">break;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">object</span><span class="s2">\&quot;</span><span class="s1">: {</span><span class="s2">\n        </span><span class="s1">if (!input2) {</span><span class="s2">\n          </span><span class="s1">str[index2] = `${NULL}`;</span><span class="s2">\n          </span><span class="s1">break;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">const isArray = Array.isArray(input2);</span><span class="s2">\n        </span><span class="s1">let pluginHandled = false;</span><span class="s2">\n        </span><span class="s1">if (!isArray &amp;&amp; plugins) {</span><span class="s2">\n          </span><span class="s1">for (const plugin of plugins) {</span><span class="s2">\n            </span><span class="s1">const pluginResult = plugin(input2);</span><span class="s2">\n            </span><span class="s1">if (Array.isArray(pluginResult)) {</span><span class="s2">\n              </span><span class="s1">pluginHandled = true;</span><span class="s2">\n              </span><span class="s1">const [pluginIdentifier, ...rest] = pluginResult;</span><span class="s2">\n              </span><span class="s1">str[index2] = `[${JSON.stringify(pluginIdentifier)}`;</span><span class="s2">\n              </span><span class="s1">if (rest.length &gt; 0) {</span><span class="s2">\n                </span><span class="s1">str[index2] += `,${rest.map((v) =&gt; flatten.call(this, v)).join(</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\&quot;</span><span class="s1">)}`;</span><span class="s2">\n              </span><span class="s1">}</span><span class="s2">\n              </span><span class="s1">str[index2] += </span><span class="s2">\&quot;</span><span class="s1">]</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n              </span><span class="s1">break;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (!pluginHandled) {</span><span class="s2">\n          </span><span class="s1">let result = isArray ? </span><span class="s2">\&quot;</span><span class="s1">[</span><span class="s2">\&quot; </span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">{</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n          </span><span class="s1">if (isArray) {</span><span class="s2">\n            </span><span class="s1">for (let i = 0; i &lt; input2.length; i++)</span><span class="s2">\n              </span><span class="s1">result += (i ? </span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\&quot; </span><span class="s1">: </span><span class="s2">\&quot;\&quot;</span><span class="s1">) + (i in input2 ? flatten.call(this, input2[i]) : HOLE);</span><span class="s2">\n            </span><span class="s1">str[index2] = `${result}]`;</span><span class="s2">\n          </span><span class="s1">} else if (input2 instanceof Date) {</span><span class="s2">\n            </span><span class="s1">str[index2] = `[</span><span class="s2">\&quot;</span><span class="s1">${TYPE_DATE}</span><span class="s2">\&quot;</span><span class="s1">,${input2.getTime()}]`;</span><span class="s2">\n          </span><span class="s1">} else if (input2 instanceof URL) {</span><span class="s2">\n            </span><span class="s1">str[index2] = `[</span><span class="s2">\&quot;</span><span class="s1">${TYPE_URL}</span><span class="s2">\&quot;</span><span class="s1">,${JSON.stringify(input2.href)}]`;</span><span class="s2">\n          </span><span class="s1">} else if (input2 instanceof RegExp) {</span><span class="s2">\n            </span><span class="s1">str[index2] = `[</span><span class="s2">\&quot;</span><span class="s1">${TYPE_REGEXP}</span><span class="s2">\&quot;</span><span class="s1">,${JSON.stringify(</span><span class="s2">\n              </span><span class="s1">input2.source</span><span class="s2">\n            </span><span class="s1">)},${JSON.stringify(input2.flags)}]`;</span><span class="s2">\n          </span><span class="s1">} else if (input2 instanceof Set) {</span><span class="s2">\n            </span><span class="s1">if (input2.size &gt; 0) {</span><span class="s2">\n              </span><span class="s1">str[index2] = `[</span><span class="s2">\&quot;</span><span class="s1">${TYPE_SET}</span><span class="s2">\&quot;</span><span class="s1">,${[...input2].map((val) =&gt; flatten.call(this, val)).join(</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\&quot;</span><span class="s1">)}]`;</span><span class="s2">\n            </span><span class="s1">} else {</span><span class="s2">\n              </span><span class="s1">str[index2] = `[</span><span class="s2">\&quot;</span><span class="s1">${TYPE_SET}</span><span class="s2">\&quot;</span><span class="s1">]`;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">} else if (input2 instanceof Map) {</span><span class="s2">\n            </span><span class="s1">if (input2.size &gt; 0) {</span><span class="s2">\n              </span><span class="s1">str[index2] = `[</span><span class="s2">\&quot;</span><span class="s1">${TYPE_MAP}</span><span class="s2">\&quot;</span><span class="s1">,${[...input2].flatMap(([k, v]) =&gt; [</span><span class="s2">\n                </span><span class="s1">flatten.call(this, k),</span><span class="s2">\n                </span><span class="s1">flatten.call(this, v)</span><span class="s2">\n              </span><span class="s1">]).join(</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\&quot;</span><span class="s1">)}]`;</span><span class="s2">\n            </span><span class="s1">} else {</span><span class="s2">\n              </span><span class="s1">str[index2] = `[</span><span class="s2">\&quot;</span><span class="s1">${TYPE_MAP}</span><span class="s2">\&quot;</span><span class="s1">]`;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">} else if (input2 instanceof Promise) {</span><span class="s2">\n            </span><span class="s1">str[index2] = `[</span><span class="s2">\&quot;</span><span class="s1">${TYPE_PROMISE}</span><span class="s2">\&quot;</span><span class="s1">,${index2}]`;</span><span class="s2">\n            </span><span class="s1">deferred[index2] = input2;</span><span class="s2">\n          </span><span class="s1">} else if (input2 instanceof Error) {</span><span class="s2">\n            </span><span class="s1">str[index2] = `[</span><span class="s2">\&quot;</span><span class="s1">${TYPE_ERROR}</span><span class="s2">\&quot;</span><span class="s1">,${JSON.stringify(input2.message)}`;</span><span class="s2">\n            </span><span class="s1">if (input2.name !== </span><span class="s2">\&quot;</span><span class="s1">Error</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n              </span><span class="s1">str[index2] += `,${JSON.stringify(input2.name)}`;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">str[index2] += </span><span class="s2">\&quot;</span><span class="s1">]</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n          </span><span class="s1">} else if (Object.getPrototypeOf(input2) === null) {</span><span class="s2">\n            </span><span class="s1">str[index2] = `[</span><span class="s2">\&quot;</span><span class="s1">${TYPE_NULL_OBJECT}</span><span class="s2">\&quot;</span><span class="s1">,{${partsForObj(input2)}}]`;</span><span class="s2">\n          </span><span class="s1">} else if (isPlainObject(input2)) {</span><span class="s2">\n            </span><span class="s1">str[index2] = `{${partsForObj(input2)}}`;</span><span class="s2">\n          </span><span class="s1">} else {</span><span class="s2">\n            </span><span class="s1">error = new Error(</span><span class="s2">\&quot;</span><span class="s1">Cannot encode object with prototype</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">break;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">default: {</span><span class="s2">\n        </span><span class="s1">const isArray = Array.isArray(input2);</span><span class="s2">\n        </span><span class="s1">let pluginHandled = false;</span><span class="s2">\n        </span><span class="s1">if (!isArray &amp;&amp; plugins) {</span><span class="s2">\n          </span><span class="s1">for (const plugin of plugins) {</span><span class="s2">\n            </span><span class="s1">const pluginResult = plugin(input2);</span><span class="s2">\n            </span><span class="s1">if (Array.isArray(pluginResult)) {</span><span class="s2">\n              </span><span class="s1">pluginHandled = true;</span><span class="s2">\n              </span><span class="s1">const [pluginIdentifier, ...rest] = pluginResult;</span><span class="s2">\n              </span><span class="s1">str[index2] = `[${JSON.stringify(pluginIdentifier)}`;</span><span class="s2">\n              </span><span class="s1">if (rest.length &gt; 0) {</span><span class="s2">\n                </span><span class="s1">str[index2] += `,${rest.map((v) =&gt; flatten.call(this, v)).join(</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\&quot;</span><span class="s1">)}`;</span><span class="s2">\n              </span><span class="s1">}</span><span class="s2">\n              </span><span class="s1">str[index2] += </span><span class="s2">\&quot;</span><span class="s1">]</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n              </span><span class="s1">break;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (!pluginHandled) {</span><span class="s2">\n          </span><span class="s1">error = new Error(</span><span class="s2">\&quot;</span><span class="s1">Cannot encode function or unexpected type</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (error) {</span><span class="s2">\n      </span><span class="s1">let pluginHandled = false;</span><span class="s2">\n      </span><span class="s1">if (postPlugins) {</span><span class="s2">\n        </span><span class="s1">for (const plugin of postPlugins) {</span><span class="s2">\n          </span><span class="s1">const pluginResult = plugin(input2);</span><span class="s2">\n          </span><span class="s1">if (Array.isArray(pluginResult)) {</span><span class="s2">\n            </span><span class="s1">pluginHandled = true;</span><span class="s2">\n            </span><span class="s1">const [pluginIdentifier, ...rest] = pluginResult;</span><span class="s2">\n            </span><span class="s1">str[index2] = `[${JSON.stringify(pluginIdentifier)}`;</span><span class="s2">\n            </span><span class="s1">if (rest.length &gt; 0) {</span><span class="s2">\n              </span><span class="s1">str[index2] += `,${rest.map((v) =&gt; flatten.call(this, v)).join(</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\&quot;</span><span class="s1">)}`;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">str[index2] += </span><span class="s2">\&quot;</span><span class="s1">]</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n            </span><span class="s1">break;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (!pluginHandled) {</span><span class="s2">\n        </span><span class="s1">throw error;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var objectProtoNames = Object.getOwnPropertyNames(Object.prototype).sort().join(</span><span class="s2">\&quot;\\</span><span class="s1">0</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n</span><span class="s1">function isPlainObject(thing) {</span><span class="s2">\n  </span><span class="s1">const proto = Object.getPrototypeOf(thing);</span><span class="s2">\n  </span><span class="s1">return proto === Object.prototype || proto === null || Object.getOwnPropertyNames(proto).sort().join(</span><span class="s2">\&quot;\\</span><span class="s1">0</span><span class="s2">\&quot;</span><span class="s1">) === objectProtoNames;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// vendor/turbo-stream-v2/unflatten.ts</span><span class="s2">\n</span><span class="s1">var globalObj = typeof window !== </span><span class="s2">\&quot;</span><span class="s1">undefined</span><span class="s2">\&quot; </span><span class="s1">? window : typeof globalThis !== </span><span class="s2">\&quot;</span><span class="s1">undefined</span><span class="s2">\&quot; </span><span class="s1">? globalThis : void 0;</span><span class="s2">\n</span><span class="s1">function unflatten(parsed) {</span><span class="s2">\n  </span><span class="s1">const { hydrated, values } = this;</span><span class="s2">\n  </span><span class="s1">if (typeof parsed === </span><span class="s2">\&quot;</span><span class="s1">number</span><span class="s2">\&quot;</span><span class="s1">) return hydrate.call(this, parsed);</span><span class="s2">\n  </span><span class="s1">if (!Array.isArray(parsed) || !parsed.length) throw new SyntaxError();</span><span class="s2">\n  </span><span class="s1">const startIndex = values.length;</span><span class="s2">\n  </span><span class="s1">for (const value of parsed) {</span><span class="s2">\n    </span><span class="s1">values.push(value);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">hydrated.length = values.length;</span><span class="s2">\n  </span><span class="s1">return hydrate.call(this, startIndex);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function hydrate(index) {</span><span class="s2">\n  </span><span class="s1">const { hydrated, values, deferred, plugins } = this;</span><span class="s2">\n  </span><span class="s1">let result;</span><span class="s2">\n  </span><span class="s1">const stack = [</span><span class="s2">\n    </span><span class="s1">[</span><span class="s2">\n      </span><span class="s1">index,</span><span class="s2">\n      </span><span class="s1">(v) =&gt; {</span><span class="s2">\n        </span><span class="s1">result = v;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">]</span><span class="s2">\n  </span><span class="s1">];</span><span class="s2">\n  </span><span class="s1">let postRun = [];</span><span class="s2">\n  </span><span class="s1">while (stack.length &gt; 0) {</span><span class="s2">\n    </span><span class="s1">const [index2, set] = stack.pop();</span><span class="s2">\n    </span><span class="s1">switch (index2) {</span><span class="s2">\n      </span><span class="s1">case UNDEFINED:</span><span class="s2">\n        </span><span class="s1">set(void 0);</span><span class="s2">\n        </span><span class="s1">continue;</span><span class="s2">\n      </span><span class="s1">case NULL:</span><span class="s2">\n        </span><span class="s1">set(null);</span><span class="s2">\n        </span><span class="s1">continue;</span><span class="s2">\n      </span><span class="s1">case NAN:</span><span class="s2">\n        </span><span class="s1">set(NaN);</span><span class="s2">\n        </span><span class="s1">continue;</span><span class="s2">\n      </span><span class="s1">case POSITIVE_INFINITY:</span><span class="s2">\n        </span><span class="s1">set(Infinity);</span><span class="s2">\n        </span><span class="s1">continue;</span><span class="s2">\n      </span><span class="s1">case NEGATIVE_INFINITY:</span><span class="s2">\n        </span><span class="s1">set(-Infinity);</span><span class="s2">\n        </span><span class="s1">continue;</span><span class="s2">\n      </span><span class="s1">case NEGATIVE_ZERO:</span><span class="s2">\n        </span><span class="s1">set(-0);</span><span class="s2">\n        </span><span class="s1">continue;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (hydrated[index2]) {</span><span class="s2">\n      </span><span class="s1">set(hydrated[index2]);</span><span class="s2">\n      </span><span class="s1">continue;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">const value = values[index2];</span><span class="s2">\n    </span><span class="s1">if (!value || typeof value !== </span><span class="s2">\&quot;</span><span class="s1">object</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">hydrated[index2] = value;</span><span class="s2">\n      </span><span class="s1">set(value);</span><span class="s2">\n      </span><span class="s1">continue;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (Array.isArray(value)) {</span><span class="s2">\n      </span><span class="s1">if (typeof value[0] === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">const [type, b, c] = value;</span><span class="s2">\n        </span><span class="s1">switch (type) {</span><span class="s2">\n          </span><span class="s1">case TYPE_DATE:</span><span class="s2">\n            </span><span class="s1">set(hydrated[index2] = new Date(b));</span><span class="s2">\n            </span><span class="s1">continue;</span><span class="s2">\n          </span><span class="s1">case TYPE_URL:</span><span class="s2">\n            </span><span class="s1">set(hydrated[index2] = new URL(b));</span><span class="s2">\n            </span><span class="s1">continue;</span><span class="s2">\n          </span><span class="s1">case TYPE_BIGINT:</span><span class="s2">\n            </span><span class="s1">set(hydrated[index2] = BigInt(b));</span><span class="s2">\n            </span><span class="s1">continue;</span><span class="s2">\n          </span><span class="s1">case TYPE_REGEXP:</span><span class="s2">\n            </span><span class="s1">set(hydrated[index2] = new RegExp(b, c));</span><span class="s2">\n            </span><span class="s1">continue;</span><span class="s2">\n          </span><span class="s1">case TYPE_SYMBOL:</span><span class="s2">\n            </span><span class="s1">set(hydrated[index2] = Symbol.for(b));</span><span class="s2">\n            </span><span class="s1">continue;</span><span class="s2">\n          </span><span class="s1">case TYPE_SET:</span><span class="s2">\n            </span><span class="s1">const newSet = /* @__PURE__ */ new Set();</span><span class="s2">\n            </span><span class="s1">hydrated[index2] = newSet;</span><span class="s2">\n            </span><span class="s1">for (let i = value.length - 1; i &gt; 0; i--)</span><span class="s2">\n              </span><span class="s1">stack.push([</span><span class="s2">\n                </span><span class="s1">value[i],</span><span class="s2">\n                </span><span class="s1">(v) =&gt; {</span><span class="s2">\n                  </span><span class="s1">newSet.add(v);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n              </span><span class="s1">]);</span><span class="s2">\n            </span><span class="s1">set(newSet);</span><span class="s2">\n            </span><span class="s1">continue;</span><span class="s2">\n          </span><span class="s1">case TYPE_MAP:</span><span class="s2">\n            </span><span class="s1">const map = /* @__PURE__ */ new Map();</span><span class="s2">\n            </span><span class="s1">hydrated[index2] = map;</span><span class="s2">\n            </span><span class="s1">for (let i = value.length - 2; i &gt; 0; i -= 2) {</span><span class="s2">\n              </span><span class="s1">const r = [];</span><span class="s2">\n              </span><span class="s1">stack.push([</span><span class="s2">\n                </span><span class="s1">value[i + 1],</span><span class="s2">\n                </span><span class="s1">(v) =&gt; {</span><span class="s2">\n                  </span><span class="s1">r[1] = v;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n              </span><span class="s1">]);</span><span class="s2">\n              </span><span class="s1">stack.push([</span><span class="s2">\n                </span><span class="s1">value[i],</span><span class="s2">\n                </span><span class="s1">(k) =&gt; {</span><span class="s2">\n                  </span><span class="s1">r[0] = k;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n              </span><span class="s1">]);</span><span class="s2">\n              </span><span class="s1">postRun.push(() =&gt; {</span><span class="s2">\n                </span><span class="s1">map.set(r[0], r[1]);</span><span class="s2">\n              </span><span class="s1">});</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">set(map);</span><span class="s2">\n            </span><span class="s1">continue;</span><span class="s2">\n          </span><span class="s1">case TYPE_NULL_OBJECT:</span><span class="s2">\n            </span><span class="s1">const obj = /* @__PURE__ */ Object.create(null);</span><span class="s2">\n            </span><span class="s1">hydrated[index2] = obj;</span><span class="s2">\n            </span><span class="s1">for (const key of Object.keys(b).reverse()) {</span><span class="s2">\n              </span><span class="s1">const r = [];</span><span class="s2">\n              </span><span class="s1">stack.push([</span><span class="s2">\n                </span><span class="s1">b[key],</span><span class="s2">\n                </span><span class="s1">(v) =&gt; {</span><span class="s2">\n                  </span><span class="s1">r[1] = v;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n              </span><span class="s1">]);</span><span class="s2">\n              </span><span class="s1">stack.push([</span><span class="s2">\n                </span><span class="s1">Number(key.slice(1)),</span><span class="s2">\n                </span><span class="s1">(k) =&gt; {</span><span class="s2">\n                  </span><span class="s1">r[0] = k;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n              </span><span class="s1">]);</span><span class="s2">\n              </span><span class="s1">postRun.push(() =&gt; {</span><span class="s2">\n                </span><span class="s1">obj[r[0]] = r[1];</span><span class="s2">\n              </span><span class="s1">});</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">set(obj);</span><span class="s2">\n            </span><span class="s1">continue;</span><span class="s2">\n          </span><span class="s1">case TYPE_PROMISE:</span><span class="s2">\n            </span><span class="s1">if (hydrated[b]) {</span><span class="s2">\n              </span><span class="s1">set(hydrated[index2] = hydrated[b]);</span><span class="s2">\n            </span><span class="s1">} else {</span><span class="s2">\n              </span><span class="s1">const d = new Deferred2();</span><span class="s2">\n              </span><span class="s1">deferred[b] = d;</span><span class="s2">\n              </span><span class="s1">set(hydrated[index2] = d.promise);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">continue;</span><span class="s2">\n          </span><span class="s1">case TYPE_ERROR:</span><span class="s2">\n            </span><span class="s1">const [, message, errorType] = value;</span><span class="s2">\n            </span><span class="s1">let error = errorType &amp;&amp; globalObj &amp;&amp; globalObj[errorType] ? new globalObj[errorType](message) : new Error(message);</span><span class="s2">\n            </span><span class="s1">hydrated[index2] = error;</span><span class="s2">\n            </span><span class="s1">set(error);</span><span class="s2">\n            </span><span class="s1">continue;</span><span class="s2">\n          </span><span class="s1">case TYPE_PREVIOUS_RESOLVED:</span><span class="s2">\n            </span><span class="s1">set(hydrated[index2] = hydrated[b]);</span><span class="s2">\n            </span><span class="s1">continue;</span><span class="s2">\n          </span><span class="s1">default:</span><span class="s2">\n            </span><span class="s1">if (Array.isArray(plugins)) {</span><span class="s2">\n              </span><span class="s1">const r = [];</span><span class="s2">\n              </span><span class="s1">const vals = value.slice(1);</span><span class="s2">\n              </span><span class="s1">for (let i = 0; i &lt; vals.length; i++) {</span><span class="s2">\n                </span><span class="s1">const v = vals[i];</span><span class="s2">\n                </span><span class="s1">stack.push([</span><span class="s2">\n                  </span><span class="s1">v,</span><span class="s2">\n                  </span><span class="s1">(v2) =&gt; {</span><span class="s2">\n                    </span><span class="s1">r[i] = v2;</span><span class="s2">\n                  </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">]);</span><span class="s2">\n              </span><span class="s1">}</span><span class="s2">\n              </span><span class="s1">postRun.push(() =&gt; {</span><span class="s2">\n                </span><span class="s1">for (const plugin of plugins) {</span><span class="s2">\n                  </span><span class="s1">const result2 = plugin(value[0], ...r);</span><span class="s2">\n                  </span><span class="s1">if (result2) {</span><span class="s2">\n                    </span><span class="s1">set(hydrated[index2] = result2.value);</span><span class="s2">\n                    </span><span class="s1">return;</span><span class="s2">\n                  </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">throw new SyntaxError();</span><span class="s2">\n              </span><span class="s1">});</span><span class="s2">\n              </span><span class="s1">continue;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">throw new SyntaxError();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">const array = [];</span><span class="s2">\n        </span><span class="s1">hydrated[index2] = array;</span><span class="s2">\n        </span><span class="s1">for (let i = 0; i &lt; value.length; i++) {</span><span class="s2">\n          </span><span class="s1">const n = value[i];</span><span class="s2">\n          </span><span class="s1">if (n !== HOLE) {</span><span class="s2">\n            </span><span class="s1">stack.push([</span><span class="s2">\n              </span><span class="s1">n,</span><span class="s2">\n              </span><span class="s1">(v) =&gt; {</span><span class="s2">\n                </span><span class="s1">array[i] = v;</span><span class="s2">\n              </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">]);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">set(array);</span><span class="s2">\n        </span><span class="s1">continue;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">const object = {};</span><span class="s2">\n      </span><span class="s1">hydrated[index2] = object;</span><span class="s2">\n      </span><span class="s1">for (const key of Object.keys(value).reverse()) {</span><span class="s2">\n        </span><span class="s1">const r = [];</span><span class="s2">\n        </span><span class="s1">stack.push([</span><span class="s2">\n          </span><span class="s1">value[key],</span><span class="s2">\n          </span><span class="s1">(v) =&gt; {</span><span class="s2">\n            </span><span class="s1">r[1] = v;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">]);</span><span class="s2">\n        </span><span class="s1">stack.push([</span><span class="s2">\n          </span><span class="s1">Number(key.slice(1)),</span><span class="s2">\n          </span><span class="s1">(k) =&gt; {</span><span class="s2">\n            </span><span class="s1">r[0] = k;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">]);</span><span class="s2">\n        </span><span class="s1">postRun.push(() =&gt; {</span><span class="s2">\n          </span><span class="s1">object[r[0]] = r[1];</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">set(object);</span><span class="s2">\n      </span><span class="s1">continue;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">while (postRun.length &gt; 0) {</span><span class="s2">\n    </span><span class="s1">postRun.pop()();</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return result;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// vendor/turbo-stream-v2/turbo-stream.ts</span><span class="s2">\n</span><span class="s1">async function decode(readable, options) {</span><span class="s2">\n  </span><span class="s1">const { plugins } = options ?? {};</span><span class="s2">\n  </span><span class="s1">const done = new Deferred2();</span><span class="s2">\n  </span><span class="s1">const reader = readable.pipeThrough(createLineSplittingTransform()).getReader();</span><span class="s2">\n  </span><span class="s1">const decoder = {</span><span class="s2">\n    </span><span class="s1">values: [],</span><span class="s2">\n    </span><span class="s1">hydrated: [],</span><span class="s2">\n    </span><span class="s1">deferred: {},</span><span class="s2">\n    </span><span class="s1">plugins</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">const decoded = await decodeInitial.call(decoder, reader);</span><span class="s2">\n  </span><span class="s1">let donePromise = done.promise;</span><span class="s2">\n  </span><span class="s1">if (decoded.done) {</span><span class="s2">\n    </span><span class="s1">done.resolve();</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">donePromise = decodeDeferred.call(decoder, reader).then(done.resolve).catch((reason) =&gt; {</span><span class="s2">\n      </span><span class="s1">for (const deferred of Object.values(decoder.deferred)) {</span><span class="s2">\n        </span><span class="s1">deferred.reject(reason);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">done.reject(reason);</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">done: donePromise.then(() =&gt; reader.closed),</span><span class="s2">\n    </span><span class="s1">value: decoded.value</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">async function decodeInitial(reader) {</span><span class="s2">\n  </span><span class="s1">const read = await reader.read();</span><span class="s2">\n  </span><span class="s1">if (!read.value) {</span><span class="s2">\n    </span><span class="s1">throw new SyntaxError();</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let line;</span><span class="s2">\n  </span><span class="s1">try {</span><span class="s2">\n    </span><span class="s1">line = JSON.parse(read.value);</span><span class="s2">\n  </span><span class="s1">} catch (reason) {</span><span class="s2">\n    </span><span class="s1">throw new SyntaxError();</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">done: read.done,</span><span class="s2">\n    </span><span class="s1">value: unflatten.call(this, line)</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">async function decodeDeferred(reader) {</span><span class="s2">\n  </span><span class="s1">let read = await reader.read();</span><span class="s2">\n  </span><span class="s1">while (!read.done) {</span><span class="s2">\n    </span><span class="s1">if (!read.value) continue;</span><span class="s2">\n    </span><span class="s1">const line = read.value;</span><span class="s2">\n    </span><span class="s1">switch (line[0]) {</span><span class="s2">\n      </span><span class="s1">case TYPE_PROMISE: {</span><span class="s2">\n        </span><span class="s1">const colonIndex = line.indexOf(</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">const deferredId = Number(line.slice(1, colonIndex));</span><span class="s2">\n        </span><span class="s1">const deferred = this.deferred[deferredId];</span><span class="s2">\n        </span><span class="s1">if (!deferred) {</span><span class="s2">\n          </span><span class="s1">throw new Error(`Deferred ID ${deferredId} not found in stream`);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">const lineData = line.slice(colonIndex + 1);</span><span class="s2">\n        </span><span class="s1">let jsonLine;</span><span class="s2">\n        </span><span class="s1">try {</span><span class="s2">\n          </span><span class="s1">jsonLine = JSON.parse(lineData);</span><span class="s2">\n        </span><span class="s1">} catch (reason) {</span><span class="s2">\n          </span><span class="s1">throw new SyntaxError();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">const value = unflatten.call(this, jsonLine);</span><span class="s2">\n        </span><span class="s1">deferred.resolve(value);</span><span class="s2">\n        </span><span class="s1">break;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">case TYPE_ERROR: {</span><span class="s2">\n        </span><span class="s1">const colonIndex = line.indexOf(</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">const deferredId = Number(line.slice(1, colonIndex));</span><span class="s2">\n        </span><span class="s1">const deferred = this.deferred[deferredId];</span><span class="s2">\n        </span><span class="s1">if (!deferred) {</span><span class="s2">\n          </span><span class="s1">throw new Error(`Deferred ID ${deferredId} not found in stream`);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">const lineData = line.slice(colonIndex + 1);</span><span class="s2">\n        </span><span class="s1">let jsonLine;</span><span class="s2">\n        </span><span class="s1">try {</span><span class="s2">\n          </span><span class="s1">jsonLine = JSON.parse(lineData);</span><span class="s2">\n        </span><span class="s1">} catch (reason) {</span><span class="s2">\n          </span><span class="s1">throw new SyntaxError();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">const value = unflatten.call(this, jsonLine);</span><span class="s2">\n        </span><span class="s1">deferred.reject(value);</span><span class="s2">\n        </span><span class="s1">break;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">default:</span><span class="s2">\n        </span><span class="s1">throw new SyntaxError();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">read = await reader.read();</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function encode(input, options) {</span><span class="s2">\n  </span><span class="s1">const { plugins, postPlugins, signal } = options ?? {};</span><span class="s2">\n  </span><span class="s1">const encoder2 = {</span><span class="s2">\n    </span><span class="s1">deferred: {},</span><span class="s2">\n    </span><span class="s1">index: 0,</span><span class="s2">\n    </span><span class="s1">indices: /* @__PURE__ */ new Map(),</span><span class="s2">\n    </span><span class="s1">stringified: [],</span><span class="s2">\n    </span><span class="s1">plugins,</span><span class="s2">\n    </span><span class="s1">postPlugins,</span><span class="s2">\n    </span><span class="s1">signal</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">const textEncoder = new TextEncoder();</span><span class="s2">\n  </span><span class="s1">let lastSentIndex = 0;</span><span class="s2">\n  </span><span class="s1">const readable = new ReadableStream({</span><span class="s2">\n    </span><span class="s1">async start(controller) {</span><span class="s2">\n      </span><span class="s1">const id = flatten.call(encoder2, input);</span><span class="s2">\n      </span><span class="s1">if (Array.isArray(id)) {</span><span class="s2">\n        </span><span class="s1">throw new Error(</span><span class="s2">\&quot;</span><span class="s1">This should never happen</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (id &lt; 0) {</span><span class="s2">\n        </span><span class="s1">controller.enqueue(textEncoder.encode(`${id}</span><span class="s2">\n</span><span class="s1">`));</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">controller.enqueue(</span><span class="s2">\n          </span><span class="s1">textEncoder.encode(`[${encoder2.stringified.join(</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\&quot;</span><span class="s1">)}]</span><span class="s2">\n</span><span class="s1">`)</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">lastSentIndex = encoder2.stringified.length - 1;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">const seenPromises = /* @__PURE__ */ new WeakSet();</span><span class="s2">\n      </span><span class="s1">if (Object.keys(encoder2.deferred).length) {</span><span class="s2">\n        </span><span class="s1">let raceDone;</span><span class="s2">\n        </span><span class="s1">const racePromise = new Promise((resolve, reject) =&gt; {</span><span class="s2">\n          </span><span class="s1">raceDone = resolve;</span><span class="s2">\n          </span><span class="s1">if (signal) {</span><span class="s2">\n            </span><span class="s1">const rejectPromise = () =&gt; reject(signal.reason || new Error(</span><span class="s2">\&quot;</span><span class="s1">Signal was aborted.</span><span class="s2">\&quot;</span><span class="s1">));</span><span class="s2">\n            </span><span class="s1">if (signal.aborted) {</span><span class="s2">\n              </span><span class="s1">rejectPromise();</span><span class="s2">\n            </span><span class="s1">} else {</span><span class="s2">\n              </span><span class="s1">signal.addEventListener(</span><span class="s2">\&quot;</span><span class="s1">abort</span><span class="s2">\&quot;</span><span class="s1">, (event) =&gt; {</span><span class="s2">\n                </span><span class="s1">rejectPromise();</span><span class="s2">\n              </span><span class="s1">});</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">while (Object.keys(encoder2.deferred).length &gt; 0) {</span><span class="s2">\n          </span><span class="s1">for (const [deferredId, deferred] of Object.entries(</span><span class="s2">\n            </span><span class="s1">encoder2.deferred</span><span class="s2">\n          </span><span class="s1">)) {</span><span class="s2">\n            </span><span class="s1">if (seenPromises.has(deferred)) continue;</span><span class="s2">\n            </span><span class="s1">seenPromises.add(</span><span class="s2">\n              </span><span class="s1">// biome-ignore lint/suspicious/noAssignInExpressions: &lt;explanation&gt;</span><span class="s2">\n              </span><span class="s1">encoder2.deferred[Number(deferredId)] = Promise.race([</span><span class="s2">\n                </span><span class="s1">racePromise,</span><span class="s2">\n                </span><span class="s1">deferred</span><span class="s2">\n              </span><span class="s1">]).then(</span><span class="s2">\n                </span><span class="s1">(resolved) =&gt; {</span><span class="s2">\n                  </span><span class="s1">const id2 = flatten.call(encoder2, resolved);</span><span class="s2">\n                  </span><span class="s1">if (Array.isArray(id2)) {</span><span class="s2">\n                    </span><span class="s1">controller.enqueue(</span><span class="s2">\n                      </span><span class="s1">textEncoder.encode(</span><span class="s2">\n                        </span><span class="s1">`${TYPE_PROMISE}${deferredId}:[[</span><span class="s2">\&quot;</span><span class="s1">${TYPE_PREVIOUS_RESOLVED}</span><span class="s2">\&quot;</span><span class="s1">,${id2[0]}]]</span><span class="s2">\n</span><span class="s1">`</span><span class="s2">\n                      </span><span class="s1">)</span><span class="s2">\n                    </span><span class="s1">);</span><span class="s2">\n                    </span><span class="s1">encoder2.index++;</span><span class="s2">\n                    </span><span class="s1">lastSentIndex++;</span><span class="s2">\n                  </span><span class="s1">} else if (id2 &lt; 0) {</span><span class="s2">\n                    </span><span class="s1">controller.enqueue(</span><span class="s2">\n                      </span><span class="s1">textEncoder.encode(</span><span class="s2">\n                        </span><span class="s1">`${TYPE_PROMISE}${deferredId}:${id2}</span><span class="s2">\n</span><span class="s1">`</span><span class="s2">\n                      </span><span class="s1">)</span><span class="s2">\n                    </span><span class="s1">);</span><span class="s2">\n                  </span><span class="s1">} else {</span><span class="s2">\n                    </span><span class="s1">const values = encoder2.stringified.slice(lastSentIndex + 1).join(</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n                    </span><span class="s1">controller.enqueue(</span><span class="s2">\n                      </span><span class="s1">textEncoder.encode(</span><span class="s2">\n                        </span><span class="s1">`${TYPE_PROMISE}${deferredId}:[${values}]</span><span class="s2">\n</span><span class="s1">`</span><span class="s2">\n                      </span><span class="s1">)</span><span class="s2">\n                    </span><span class="s1">);</span><span class="s2">\n                    </span><span class="s1">lastSentIndex = encoder2.stringified.length - 1;</span><span class="s2">\n                  </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">},</span><span class="s2">\n                </span><span class="s1">(reason) =&gt; {</span><span class="s2">\n                  </span><span class="s1">if (!reason || typeof reason !== </span><span class="s2">\&quot;</span><span class="s1">object</span><span class="s2">\&quot; </span><span class="s1">|| !(reason instanceof Error)) {</span><span class="s2">\n                    </span><span class="s1">reason = new Error(</span><span class="s2">\&quot;</span><span class="s1">An unknown error occurred</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n                  </span><span class="s1">}</span><span class="s2">\n                  </span><span class="s1">const id2 = flatten.call(encoder2, reason);</span><span class="s2">\n                  </span><span class="s1">if (Array.isArray(id2)) {</span><span class="s2">\n                    </span><span class="s1">controller.enqueue(</span><span class="s2">\n                      </span><span class="s1">textEncoder.encode(</span><span class="s2">\n                        </span><span class="s1">`${TYPE_ERROR}${deferredId}:[[</span><span class="s2">\&quot;</span><span class="s1">${TYPE_PREVIOUS_RESOLVED}</span><span class="s2">\&quot;</span><span class="s1">,${id2[0]}]]</span><span class="s2">\n</span><span class="s1">`</span><span class="s2">\n                      </span><span class="s1">)</span><span class="s2">\n                    </span><span class="s1">);</span><span class="s2">\n                    </span><span class="s1">encoder2.index++;</span><span class="s2">\n                    </span><span class="s1">lastSentIndex++;</span><span class="s2">\n                  </span><span class="s1">} else if (id2 &lt; 0) {</span><span class="s2">\n                    </span><span class="s1">controller.enqueue(</span><span class="s2">\n                      </span><span class="s1">textEncoder.encode(`${TYPE_ERROR}${deferredId}:${id2}</span><span class="s2">\n</span><span class="s1">`)</span><span class="s2">\n                    </span><span class="s1">);</span><span class="s2">\n                  </span><span class="s1">} else {</span><span class="s2">\n                    </span><span class="s1">const values = encoder2.stringified.slice(lastSentIndex + 1).join(</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n                    </span><span class="s1">controller.enqueue(</span><span class="s2">\n                      </span><span class="s1">textEncoder.encode(</span><span class="s2">\n                        </span><span class="s1">`${TYPE_ERROR}${deferredId}:[${values}]</span><span class="s2">\n</span><span class="s1">`</span><span class="s2">\n                      </span><span class="s1">)</span><span class="s2">\n                    </span><span class="s1">);</span><span class="s2">\n                    </span><span class="s1">lastSentIndex = encoder2.stringified.length - 1;</span><span class="s2">\n                  </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n              </span><span class="s1">).finally(() =&gt; {</span><span class="s2">\n                </span><span class="s1">delete encoder2.deferred[Number(deferredId)];</span><span class="s2">\n              </span><span class="s1">})</span><span class="s2">\n            </span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">await Promise.race(Object.values(encoder2.deferred));</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">raceDone();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">await Promise.all(Object.values(encoder2.deferred));</span><span class="s2">\n      </span><span class="s1">controller.close();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">return readable;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/dom/ssr/data.ts</span><span class="s2">\n</span><span class="s1">async function createRequestInit(request) {</span><span class="s2">\n  </span><span class="s1">let init = { signal: request.signal };</span><span class="s2">\n  </span><span class="s1">if (request.method !== </span><span class="s2">\&quot;</span><span class="s1">GET</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">init.method = request.method;</span><span class="s2">\n    </span><span class="s1">let contentType = request.headers.get(</span><span class="s2">\&quot;</span><span class="s1">Content-Type</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">if (contentType &amp;&amp; /</span><span class="s2">\\</span><span class="s1">bapplication</span><span class="s2">\\</span><span class="s1">/json</span><span class="s2">\\</span><span class="s1">b/.test(contentType)) {</span><span class="s2">\n      </span><span class="s1">init.headers = { </span><span class="s2">\&quot;</span><span class="s1">Content-Type</span><span class="s2">\&quot;</span><span class="s1">: contentType };</span><span class="s2">\n      </span><span class="s1">init.body = JSON.stringify(await request.json());</span><span class="s2">\n    </span><span class="s1">} else if (contentType &amp;&amp; /</span><span class="s2">\\</span><span class="s1">btext</span><span class="s2">\\</span><span class="s1">/plain</span><span class="s2">\\</span><span class="s1">b/.test(contentType)) {</span><span class="s2">\n      </span><span class="s1">init.headers = { </span><span class="s2">\&quot;</span><span class="s1">Content-Type</span><span class="s2">\&quot;</span><span class="s1">: contentType };</span><span class="s2">\n      </span><span class="s1">init.body = await request.text();</span><span class="s2">\n    </span><span class="s1">} else if (contentType &amp;&amp; /</span><span class="s2">\\</span><span class="s1">bapplication</span><span class="s2">\\</span><span class="s1">/x-www-form-urlencoded</span><span class="s2">\\</span><span class="s1">b/.test(contentType)) {</span><span class="s2">\n      </span><span class="s1">init.body = new URLSearchParams(await request.text());</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">init.body = await request.formData();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return init;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/dom/ssr/single-fetch.tsx</span><span class="s2">\n</span><span class="s1">var SingleFetchRedirectSymbol = Symbol(</span><span class="s2">\&quot;</span><span class="s1">SingleFetchRedirect</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n</span><span class="s1">var SingleFetchNoResultError = class extends Error {</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">var SINGLE_FETCH_REDIRECT_STATUS = 202;</span><span class="s2">\n</span><span class="s1">var NO_BODY_STATUS_CODES = /* @__PURE__ */ new Set([100, 101, 204, 205]);</span><span class="s2">\n</span><span class="s1">function StreamTransfer({</span><span class="s2">\n  </span><span class="s1">context,</span><span class="s2">\n  </span><span class="s1">identifier,</span><span class="s2">\n  </span><span class="s1">reader,</span><span class="s2">\n  </span><span class="s1">textDecoder,</span><span class="s2">\n  </span><span class="s1">nonce</span><span class="s2">\n</span><span class="s1">}) {</span><span class="s2">\n  </span><span class="s1">if (!context.renderMeta || !context.renderMeta.didRenderScripts) {</span><span class="s2">\n    </span><span class="s1">return null;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (!context.renderMeta.streamCache) {</span><span class="s2">\n    </span><span class="s1">context.renderMeta.streamCache = {};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let { streamCache } = context.renderMeta;</span><span class="s2">\n  </span><span class="s1">let promise = streamCache[identifier];</span><span class="s2">\n  </span><span class="s1">if (!promise) {</span><span class="s2">\n    </span><span class="s1">promise = streamCache[identifier] = reader.read().then((result) =&gt; {</span><span class="s2">\n      </span><span class="s1">streamCache[identifier].result = {</span><span class="s2">\n        </span><span class="s1">done: result.done,</span><span class="s2">\n        </span><span class="s1">value: textDecoder.decode(result.value, { stream: true })</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}).catch((e) =&gt; {</span><span class="s2">\n      </span><span class="s1">streamCache[identifier].error = e;</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (promise.error) {</span><span class="s2">\n    </span><span class="s1">throw promise.error;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (promise.result === void 0) {</span><span class="s2">\n    </span><span class="s1">throw promise;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let { done, value } = promise.result;</span><span class="s2">\n  </span><span class="s1">let scriptTag = value ? /* @__PURE__ */ React4.createElement(</span><span class="s2">\n    \&quot;</span><span class="s1">script</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">{</span><span class="s2">\n      </span><span class="s1">nonce,</span><span class="s2">\n      </span><span class="s1">dangerouslySetInnerHTML: {</span><span class="s2">\n        </span><span class="s1">__html: `window.__reactRouterContext.streamController.enqueue(${escapeHtml(</span><span class="s2">\n          </span><span class="s1">JSON.stringify(value)</span><span class="s2">\n        </span><span class="s1">)});`</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">) : null;</span><span class="s2">\n  </span><span class="s1">if (done) {</span><span class="s2">\n    </span><span class="s1">return /* @__PURE__ */ React4.createElement(React4.Fragment, null, scriptTag, /* @__PURE__ */ React4.createElement(</span><span class="s2">\n      \&quot;</span><span class="s1">script</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">{</span><span class="s2">\n        </span><span class="s1">nonce,</span><span class="s2">\n        </span><span class="s1">dangerouslySetInnerHTML: {</span><span class="s2">\n          </span><span class="s1">__html: `window.__reactRouterContext.streamController.close();`</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">));</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">return /* @__PURE__ */ React4.createElement(React4.Fragment, null, scriptTag, /* @__PURE__ */ React4.createElement(React4.Suspense, null, /* @__PURE__ */ React4.createElement(</span><span class="s2">\n      </span><span class="s1">StreamTransfer,</span><span class="s2">\n      </span><span class="s1">{</span><span class="s2">\n        </span><span class="s1">context,</span><span class="s2">\n        </span><span class="s1">identifier: identifier + 1,</span><span class="s2">\n        </span><span class="s1">reader,</span><span class="s2">\n        </span><span class="s1">textDecoder,</span><span class="s2">\n        </span><span class="s1">nonce</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">)));</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getTurboStreamSingleFetchDataStrategy(getRouter, manifest, routeModules, ssr, basename) {</span><span class="s2">\n  </span><span class="s1">let dataStrategy = getSingleFetchDataStrategyImpl(</span><span class="s2">\n    </span><span class="s1">getRouter,</span><span class="s2">\n    </span><span class="s1">(match) =&gt; {</span><span class="s2">\n      </span><span class="s1">let manifestRoute = manifest.routes[match.route.id];</span><span class="s2">\n      </span><span class="s1">invariant2(manifestRoute, </span><span class="s2">\&quot;</span><span class="s1">Route not found in manifest</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">let routeModule = routeModules[match.route.id];</span><span class="s2">\n      </span><span class="s1">return {</span><span class="s2">\n        </span><span class="s1">hasLoader: manifestRoute.hasLoader,</span><span class="s2">\n        </span><span class="s1">hasClientLoader: manifestRoute.hasClientLoader,</span><span class="s2">\n        </span><span class="s1">hasShouldRevalidate: Boolean(routeModule?.shouldRevalidate)</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">fetchAndDecodeViaTurboStream,</span><span class="s2">\n    </span><span class="s1">ssr,</span><span class="s2">\n    </span><span class="s1">basename</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">return async (args) =&gt; args.unstable_runClientMiddleware(dataStrategy);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getSingleFetchDataStrategyImpl(getRouter, getRouteInfo, fetchAndDecode, ssr, basename) {</span><span class="s2">\n  </span><span class="s1">return async (args) =&gt; {</span><span class="s2">\n    </span><span class="s1">let { request, matches, fetcherKey } = args;</span><span class="s2">\n    </span><span class="s1">let router = getRouter();</span><span class="s2">\n    </span><span class="s1">if (request.method !== </span><span class="s2">\&quot;</span><span class="s1">GET</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">return singleFetchActionStrategy(args, fetchAndDecode, basename);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let foundRevalidatingServerLoader = matches.some((m) =&gt; {</span><span class="s2">\n      </span><span class="s1">let { hasLoader, hasClientLoader } = getRouteInfo(m);</span><span class="s2">\n      </span><span class="s1">return m.unstable_shouldCallHandler() &amp;&amp; hasLoader &amp;&amp; !hasClientLoader;</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">if (!ssr &amp;&amp; !foundRevalidatingServerLoader) {</span><span class="s2">\n      </span><span class="s1">return nonSsrStrategy(args, getRouteInfo, fetchAndDecode, basename);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (fetcherKey) {</span><span class="s2">\n      </span><span class="s1">return singleFetchLoaderFetcherStrategy(args, fetchAndDecode, basename);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return singleFetchLoaderNavigationStrategy(</span><span class="s2">\n      </span><span class="s1">args,</span><span class="s2">\n      </span><span class="s1">router,</span><span class="s2">\n      </span><span class="s1">getRouteInfo,</span><span class="s2">\n      </span><span class="s1">fetchAndDecode,</span><span class="s2">\n      </span><span class="s1">ssr,</span><span class="s2">\n      </span><span class="s1">basename</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">async function singleFetchActionStrategy(args, fetchAndDecode, basename) {</span><span class="s2">\n  </span><span class="s1">let actionMatch = args.matches.find((m) =&gt; m.unstable_shouldCallHandler());</span><span class="s2">\n  </span><span class="s1">invariant2(actionMatch, </span><span class="s2">\&quot;</span><span class="s1">No action match found</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let actionStatus = void 0;</span><span class="s2">\n  </span><span class="s1">let result = await actionMatch.resolve(async (handler) =&gt; {</span><span class="s2">\n    </span><span class="s1">let result2 = await handler(async () =&gt; {</span><span class="s2">\n      </span><span class="s1">let { data: data2, status } = await fetchAndDecode(args, basename, [</span><span class="s2">\n        </span><span class="s1">actionMatch.route.id</span><span class="s2">\n      </span><span class="s1">]);</span><span class="s2">\n      </span><span class="s1">actionStatus = status;</span><span class="s2">\n      </span><span class="s1">return unwrapSingleFetchResult(data2, actionMatch.route.id);</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">return result2;</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">if (isResponse(result.result) || isRouteErrorResponse(result.result) || isDataWithResponseInit(result.result)) {</span><span class="s2">\n    </span><span class="s1">return { [actionMatch.route.id]: result };</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">[actionMatch.route.id]: {</span><span class="s2">\n      </span><span class="s1">type: result.type,</span><span class="s2">\n      </span><span class="s1">result: data(result.result, actionStatus)</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">async function nonSsrStrategy(args, getRouteInfo, fetchAndDecode, basename) {</span><span class="s2">\n  </span><span class="s1">let matchesToLoad = args.matches.filter(</span><span class="s2">\n    </span><span class="s1">(m) =&gt; m.unstable_shouldCallHandler()</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let results = {};</span><span class="s2">\n  </span><span class="s1">await Promise.all(</span><span class="s2">\n    </span><span class="s1">matchesToLoad.map(</span><span class="s2">\n      </span><span class="s1">(m) =&gt; m.resolve(async (handler) =&gt; {</span><span class="s2">\n        </span><span class="s1">try {</span><span class="s2">\n          </span><span class="s1">let { hasClientLoader } = getRouteInfo(m);</span><span class="s2">\n          </span><span class="s1">let routeId = m.route.id;</span><span class="s2">\n          </span><span class="s1">let result = hasClientLoader ? await handler(async () =&gt; {</span><span class="s2">\n            </span><span class="s1">let { data: data2 } = await fetchAndDecode(args, basename, [routeId]);</span><span class="s2">\n            </span><span class="s1">return unwrapSingleFetchResult(data2, routeId);</span><span class="s2">\n          </span><span class="s1">}) : await handler();</span><span class="s2">\n          </span><span class="s1">results[m.route.id] = { type: </span><span class="s2">\&quot;</span><span class="s1">data</span><span class="s2">\&quot;</span><span class="s1">, result };</span><span class="s2">\n        </span><span class="s1">} catch (e) {</span><span class="s2">\n          </span><span class="s1">results[m.route.id] = { type: </span><span class="s2">\&quot;</span><span class="s1">error</span><span class="s2">\&quot;</span><span class="s1">, result: e };</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">})</span><span class="s2">\n    </span><span class="s1">)</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">return results;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">async function singleFetchLoaderNavigationStrategy(args, router, getRouteInfo, fetchAndDecode, ssr, basename) {</span><span class="s2">\n  </span><span class="s1">let routesParams = /* @__PURE__ */ new Set();</span><span class="s2">\n  </span><span class="s1">let foundOptOutRoute = false;</span><span class="s2">\n  </span><span class="s1">let routeDfds = args.matches.map(() =&gt; createDeferred2());</span><span class="s2">\n  </span><span class="s1">let singleFetchDfd = createDeferred2();</span><span class="s2">\n  </span><span class="s1">let results = {};</span><span class="s2">\n  </span><span class="s1">let resolvePromise = Promise.all(</span><span class="s2">\n    </span><span class="s1">args.matches.map(</span><span class="s2">\n      </span><span class="s1">async (m, i) =&gt; m.resolve(async (handler) =&gt; {</span><span class="s2">\n        </span><span class="s1">routeDfds[i].resolve();</span><span class="s2">\n        </span><span class="s1">let routeId = m.route.id;</span><span class="s2">\n        </span><span class="s1">let { hasLoader, hasClientLoader, hasShouldRevalidate } = getRouteInfo(m);</span><span class="s2">\n        </span><span class="s1">let defaultShouldRevalidate = !m.unstable_shouldRevalidateArgs || m.unstable_shouldRevalidateArgs.actionStatus == null || m.unstable_shouldRevalidateArgs.actionStatus &lt; 400;</span><span class="s2">\n        </span><span class="s1">let shouldCall = m.unstable_shouldCallHandler(defaultShouldRevalidate);</span><span class="s2">\n        </span><span class="s1">if (!shouldCall) {</span><span class="s2">\n          </span><span class="s1">foundOptOutRoute || (foundOptOutRoute = m.unstable_shouldRevalidateArgs != null &amp;&amp; // This is a revalidation,</span><span class="s2">\n          </span><span class="s1">hasLoader &amp;&amp; // for a route with a server loader,</span><span class="s2">\n          </span><span class="s1">hasShouldRevalidate === true);</span><span class="s2">\n          </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (hasClientLoader) {</span><span class="s2">\n          </span><span class="s1">if (hasLoader) {</span><span class="s2">\n            </span><span class="s1">foundOptOutRoute = true;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">try {</span><span class="s2">\n            </span><span class="s1">let result = await handler(async () =&gt; {</span><span class="s2">\n              </span><span class="s1">let { data: data2 } = await fetchAndDecode(args, basename, [routeId]);</span><span class="s2">\n              </span><span class="s1">return unwrapSingleFetchResult(data2, routeId);</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n            </span><span class="s1">results[routeId] = { type: </span><span class="s2">\&quot;</span><span class="s1">data</span><span class="s2">\&quot;</span><span class="s1">, result };</span><span class="s2">\n          </span><span class="s1">} catch (e) {</span><span class="s2">\n            </span><span class="s1">results[routeId] = { type: </span><span class="s2">\&quot;</span><span class="s1">error</span><span class="s2">\&quot;</span><span class="s1">, result: e };</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (hasLoader) {</span><span class="s2">\n          </span><span class="s1">routesParams.add(routeId);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">try {</span><span class="s2">\n          </span><span class="s1">let result = await handler(async () =&gt; {</span><span class="s2">\n            </span><span class="s1">let data2 = await singleFetchDfd.promise;</span><span class="s2">\n            </span><span class="s1">return unwrapSingleFetchResult(data2, routeId);</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n          </span><span class="s1">results[routeId] = { type: </span><span class="s2">\&quot;</span><span class="s1">data</span><span class="s2">\&quot;</span><span class="s1">, result };</span><span class="s2">\n        </span><span class="s1">} catch (e) {</span><span class="s2">\n          </span><span class="s1">results[routeId] = { type: </span><span class="s2">\&quot;</span><span class="s1">error</span><span class="s2">\&quot;</span><span class="s1">, result: e };</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">})</span><span class="s2">\n    </span><span class="s1">)</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">await Promise.all(routeDfds.map((d) =&gt; d.promise));</span><span class="s2">\n  </span><span class="s1">let isInitialLoad = !router.state.initialized &amp;&amp; router.state.navigation.state === </span><span class="s2">\&quot;</span><span class="s1">idle</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">if ((isInitialLoad || routesParams.size === 0) &amp;&amp; !window.__reactRouterHdrActive) {</span><span class="s2">\n    </span><span class="s1">singleFetchDfd.resolve({ routes: {} });</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">let targetRoutes = ssr &amp;&amp; foundOptOutRoute &amp;&amp; routesParams.size &gt; 0 ? [...routesParams.keys()] : void 0;</span><span class="s2">\n    </span><span class="s1">try {</span><span class="s2">\n      </span><span class="s1">let data2 = await fetchAndDecode(args, basename, targetRoutes);</span><span class="s2">\n      </span><span class="s1">singleFetchDfd.resolve(data2.data);</span><span class="s2">\n    </span><span class="s1">} catch (e) {</span><span class="s2">\n      </span><span class="s1">singleFetchDfd.reject(e);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">await resolvePromise;</span><span class="s2">\n  </span><span class="s1">await bubbleMiddlewareErrors(</span><span class="s2">\n    </span><span class="s1">singleFetchDfd.promise,</span><span class="s2">\n    </span><span class="s1">args.matches,</span><span class="s2">\n    </span><span class="s1">routesParams,</span><span class="s2">\n    </span><span class="s1">results</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">return results;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">async function bubbleMiddlewareErrors(singleFetchPromise, matches, routesParams, results) {</span><span class="s2">\n  </span><span class="s1">try {</span><span class="s2">\n    </span><span class="s1">let middlewareError;</span><span class="s2">\n    </span><span class="s1">let fetchedData = await singleFetchPromise;</span><span class="s2">\n    </span><span class="s1">if (</span><span class="s2">\&quot;</span><span class="s1">routes</span><span class="s2">\&quot; </span><span class="s1">in fetchedData) {</span><span class="s2">\n      </span><span class="s1">for (let match of matches) {</span><span class="s2">\n        </span><span class="s1">if (match.route.id in fetchedData.routes) {</span><span class="s2">\n          </span><span class="s1">let routeResult = fetchedData.routes[match.route.id];</span><span class="s2">\n          </span><span class="s1">if (</span><span class="s2">\&quot;</span><span class="s1">error</span><span class="s2">\&quot; </span><span class="s1">in routeResult) {</span><span class="s2">\n            </span><span class="s1">middlewareError = routeResult.error;</span><span class="s2">\n            </span><span class="s1">break;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (middlewareError !== void 0) {</span><span class="s2">\n      </span><span class="s1">Array.from(routesParams.values()).forEach((routeId) =&gt; {</span><span class="s2">\n        </span><span class="s1">if (results[routeId].result instanceof SingleFetchNoResultError) {</span><span class="s2">\n          </span><span class="s1">results[routeId].result = middlewareError;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">} catch (e) {</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">async function singleFetchLoaderFetcherStrategy(args, fetchAndDecode, basename) {</span><span class="s2">\n  </span><span class="s1">let fetcherMatch = args.matches.find((m) =&gt; m.unstable_shouldCallHandler());</span><span class="s2">\n  </span><span class="s1">invariant2(fetcherMatch, </span><span class="s2">\&quot;</span><span class="s1">No fetcher match found</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let routeId = fetcherMatch.route.id;</span><span class="s2">\n  </span><span class="s1">let result = await fetcherMatch.resolve(</span><span class="s2">\n    </span><span class="s1">async (handler) =&gt; handler(async () =&gt; {</span><span class="s2">\n      </span><span class="s1">let { data: data2 } = await fetchAndDecode(args, basename, [routeId]);</span><span class="s2">\n      </span><span class="s1">return unwrapSingleFetchResult(data2, routeId);</span><span class="s2">\n    </span><span class="s1">})</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">return { [fetcherMatch.route.id]: result };</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function stripIndexParam(url) {</span><span class="s2">\n  </span><span class="s1">let indexValues = url.searchParams.getAll(</span><span class="s2">\&quot;</span><span class="s1">index</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">url.searchParams.delete(</span><span class="s2">\&quot;</span><span class="s1">index</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let indexValuesToKeep = [];</span><span class="s2">\n  </span><span class="s1">for (let indexValue of indexValues) {</span><span class="s2">\n    </span><span class="s1">if (indexValue) {</span><span class="s2">\n      </span><span class="s1">indexValuesToKeep.push(indexValue);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">for (let toKeep of indexValuesToKeep) {</span><span class="s2">\n    </span><span class="s1">url.searchParams.append(</span><span class="s2">\&quot;</span><span class="s1">index</span><span class="s2">\&quot;</span><span class="s1">, toKeep);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return url;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function singleFetchUrl(reqUrl, basename) {</span><span class="s2">\n  </span><span class="s1">let url = typeof reqUrl === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">? new URL(</span><span class="s2">\n    </span><span class="s1">reqUrl,</span><span class="s2">\n    </span><span class="s1">// This can be called during the SSR flow via PrefetchPageLinksImpl so</span><span class="s2">\n    </span><span class="s1">// don't assume window is available</span><span class="s2">\n    </span><span class="s1">typeof window === </span><span class="s2">\&quot;</span><span class="s1">undefined</span><span class="s2">\&quot; </span><span class="s1">? </span><span class="s2">\&quot;</span><span class="s1">server://singlefetch/</span><span class="s2">\&quot; </span><span class="s1">: window.location.origin</span><span class="s2">\n  </span><span class="s1">) : reqUrl;</span><span class="s2">\n  </span><span class="s1">if (url.pathname === </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">url.pathname = </span><span class="s2">\&quot;</span><span class="s1">_root.data</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">} else if (basename &amp;&amp; stripBasename(url.pathname, basename) === </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">url.pathname = `${basename.replace(/</span><span class="s2">\\</span><span class="s1">/$/, </span><span class="s2">\&quot;\&quot;</span><span class="s1">)}/_root.data`;</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">url.pathname = `${url.pathname.replace(/</span><span class="s2">\\</span><span class="s1">/$/, </span><span class="s2">\&quot;\&quot;</span><span class="s1">)}.data`;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return url;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">async function fetchAndDecodeViaTurboStream(args, basename, targetRoutes) {</span><span class="s2">\n  </span><span class="s1">let { request } = args;</span><span class="s2">\n  </span><span class="s1">let url = singleFetchUrl(request.url, basename);</span><span class="s2">\n  </span><span class="s1">if (request.method === </span><span class="s2">\&quot;</span><span class="s1">GET</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">url = stripIndexParam(url);</span><span class="s2">\n    </span><span class="s1">if (targetRoutes) {</span><span class="s2">\n      </span><span class="s1">url.searchParams.set(</span><span class="s2">\&quot;</span><span class="s1">_routes</span><span class="s2">\&quot;</span><span class="s1">, targetRoutes.join(</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\&quot;</span><span class="s1">));</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let res = await fetch(url, await createRequestInit(request));</span><span class="s2">\n  </span><span class="s1">if (res.status === 404 &amp;&amp; !res.headers.has(</span><span class="s2">\&quot;</span><span class="s1">X-Remix-Response</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n    </span><span class="s1">throw new ErrorResponseImpl(404, </span><span class="s2">\&quot;</span><span class="s1">Not Found</span><span class="s2">\&quot;</span><span class="s1">, true);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (res.status === 204 &amp;&amp; res.headers.has(</span><span class="s2">\&quot;</span><span class="s1">X-Remix-Redirect</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n    </span><span class="s1">return {</span><span class="s2">\n      </span><span class="s1">status: SINGLE_FETCH_REDIRECT_STATUS,</span><span class="s2">\n      </span><span class="s1">data: {</span><span class="s2">\n        </span><span class="s1">redirect: {</span><span class="s2">\n          </span><span class="s1">redirect: res.headers.get(</span><span class="s2">\&quot;</span><span class="s1">X-Remix-Redirect</span><span class="s2">\&quot;</span><span class="s1">),</span><span class="s2">\n          </span><span class="s1">status: Number(res.headers.get(</span><span class="s2">\&quot;</span><span class="s1">X-Remix-Status</span><span class="s2">\&quot;</span><span class="s1">) || </span><span class="s2">\&quot;</span><span class="s1">302</span><span class="s2">\&quot;</span><span class="s1">),</span><span class="s2">\n          </span><span class="s1">revalidate: res.headers.get(</span><span class="s2">\&quot;</span><span class="s1">X-Remix-Revalidate</span><span class="s2">\&quot;</span><span class="s1">) === </span><span class="s2">\&quot;</span><span class="s1">true</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n          </span><span class="s1">reload: res.headers.get(</span><span class="s2">\&quot;</span><span class="s1">X-Remix-Reload-Document</span><span class="s2">\&quot;</span><span class="s1">) === </span><span class="s2">\&quot;</span><span class="s1">true</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n          </span><span class="s1">replace: res.headers.get(</span><span class="s2">\&quot;</span><span class="s1">X-Remix-Replace</span><span class="s2">\&quot;</span><span class="s1">) === </span><span class="s2">\&quot;</span><span class="s1">true</span><span class="s2">\&quot;\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (NO_BODY_STATUS_CODES.has(res.status)) {</span><span class="s2">\n    </span><span class="s1">let routes = {};</span><span class="s2">\n    </span><span class="s1">if (targetRoutes &amp;&amp; request.method !== </span><span class="s2">\&quot;</span><span class="s1">GET</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">routes[targetRoutes[0]] = { data: void 0 };</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return {</span><span class="s2">\n      </span><span class="s1">status: res.status,</span><span class="s2">\n      </span><span class="s1">data: { routes }</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">invariant2(res.body, </span><span class="s2">\&quot;</span><span class="s1">No response body to decode</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">try {</span><span class="s2">\n    </span><span class="s1">let decoded = await decodeViaTurboStream(res.body, window);</span><span class="s2">\n    </span><span class="s1">let data2;</span><span class="s2">\n    </span><span class="s1">if (request.method === </span><span class="s2">\&quot;</span><span class="s1">GET</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">let typed = decoded.value;</span><span class="s2">\n      </span><span class="s1">if (SingleFetchRedirectSymbol in typed) {</span><span class="s2">\n        </span><span class="s1">data2 = { redirect: typed[SingleFetchRedirectSymbol] };</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">data2 = { routes: typed };</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">let typed = decoded.value;</span><span class="s2">\n      </span><span class="s1">let routeId = targetRoutes?.[0];</span><span class="s2">\n      </span><span class="s1">invariant2(routeId, </span><span class="s2">\&quot;</span><span class="s1">No routeId found for single fetch call decoding</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">if (</span><span class="s2">\&quot;</span><span class="s1">redirect</span><span class="s2">\&quot; </span><span class="s1">in typed) {</span><span class="s2">\n        </span><span class="s1">data2 = { redirect: typed };</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">data2 = { routes: { [routeId]: typed } };</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return { status: res.status, data: data2 };</span><span class="s2">\n  </span><span class="s1">} catch (e) {</span><span class="s2">\n    </span><span class="s1">throw new Error(</span><span class="s2">\&quot;</span><span class="s1">Unable to decode turbo-stream response</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function decodeViaTurboStream(body, global2) {</span><span class="s2">\n  </span><span class="s1">return decode(body, {</span><span class="s2">\n    </span><span class="s1">plugins: [</span><span class="s2">\n      </span><span class="s1">(type, ...rest) =&gt; {</span><span class="s2">\n        </span><span class="s1">if (type === </span><span class="s2">\&quot;</span><span class="s1">SanitizedError</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">let [name, message, stack] = rest;</span><span class="s2">\n          </span><span class="s1">let Constructor = Error;</span><span class="s2">\n          </span><span class="s1">if (name &amp;&amp; name in global2 &amp;&amp; typeof global2[name] === </span><span class="s2">\&quot;</span><span class="s1">function</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n            </span><span class="s1">Constructor = global2[name];</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">let error = new Constructor(message);</span><span class="s2">\n          </span><span class="s1">error.stack = stack;</span><span class="s2">\n          </span><span class="s1">return { value: error };</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (type === </span><span class="s2">\&quot;</span><span class="s1">ErrorResponse</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">let [data2, status, statusText] = rest;</span><span class="s2">\n          </span><span class="s1">return {</span><span class="s2">\n            </span><span class="s1">value: new ErrorResponseImpl(status, statusText, data2)</span><span class="s2">\n          </span><span class="s1">};</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (type === </span><span class="s2">\&quot;</span><span class="s1">SingleFetchRedirect</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">return { value: { [SingleFetchRedirectSymbol]: rest[0] } };</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (type === </span><span class="s2">\&quot;</span><span class="s1">SingleFetchClassInstance</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">return { value: rest[0] };</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (type === </span><span class="s2">\&quot;</span><span class="s1">SingleFetchFallback</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">return { value: void 0 };</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">]</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function unwrapSingleFetchResult(result, routeId) {</span><span class="s2">\n  </span><span class="s1">if (</span><span class="s2">\&quot;</span><span class="s1">redirect</span><span class="s2">\&quot; </span><span class="s1">in result) {</span><span class="s2">\n    </span><span class="s1">let {</span><span class="s2">\n      </span><span class="s1">redirect: location,</span><span class="s2">\n      </span><span class="s1">revalidate,</span><span class="s2">\n      </span><span class="s1">reload,</span><span class="s2">\n      </span><span class="s1">replace: replace2,</span><span class="s2">\n      </span><span class="s1">status</span><span class="s2">\n    </span><span class="s1">} = result.redirect;</span><span class="s2">\n    </span><span class="s1">throw redirect(location, {</span><span class="s2">\n      </span><span class="s1">status,</span><span class="s2">\n      </span><span class="s1">headers: {</span><span class="s2">\n        </span><span class="s1">// Three R's of redirecting (lol Veep)</span><span class="s2">\n        </span><span class="s1">...revalidate ? { </span><span class="s2">\&quot;</span><span class="s1">X-Remix-Revalidate</span><span class="s2">\&quot;</span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">yes</span><span class="s2">\&quot; </span><span class="s1">} : null,</span><span class="s2">\n        </span><span class="s1">...reload ? { </span><span class="s2">\&quot;</span><span class="s1">X-Remix-Reload-Document</span><span class="s2">\&quot;</span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">yes</span><span class="s2">\&quot; </span><span class="s1">} : null,</span><span class="s2">\n        </span><span class="s1">...replace2 ? { </span><span class="s2">\&quot;</span><span class="s1">X-Remix-Replace</span><span class="s2">\&quot;</span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">yes</span><span class="s2">\&quot; </span><span class="s1">} : null</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let routeResult = result.routes[routeId];</span><span class="s2">\n  </span><span class="s1">if (routeResult == null) {</span><span class="s2">\n    </span><span class="s1">throw new SingleFetchNoResultError(</span><span class="s2">\n      </span><span class="s1">`No result found for routeId </span><span class="s2">\&quot;</span><span class="s1">${routeId}</span><span class="s2">\&quot;</span><span class="s1">`</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">} else if (</span><span class="s2">\&quot;</span><span class="s1">error</span><span class="s2">\&quot; </span><span class="s1">in routeResult) {</span><span class="s2">\n    </span><span class="s1">throw routeResult.error;</span><span class="s2">\n  </span><span class="s1">} else if (</span><span class="s2">\&quot;</span><span class="s1">data</span><span class="s2">\&quot; </span><span class="s1">in routeResult) {</span><span class="s2">\n    </span><span class="s1">return routeResult.data;</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">throw new Error(`Invalid response found for routeId </span><span class="s2">\&quot;</span><span class="s1">${routeId}</span><span class="s2">\&quot;</span><span class="s1">`);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createDeferred2() {</span><span class="s2">\n  </span><span class="s1">let resolve;</span><span class="s2">\n  </span><span class="s1">let reject;</span><span class="s2">\n  </span><span class="s1">let promise = new Promise((res, rej) =&gt; {</span><span class="s2">\n    </span><span class="s1">resolve = async (val) =&gt; {</span><span class="s2">\n      </span><span class="s1">res(val);</span><span class="s2">\n      </span><span class="s1">try {</span><span class="s2">\n        </span><span class="s1">await promise;</span><span class="s2">\n      </span><span class="s1">} catch (e) {</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">reject = async (error) =&gt; {</span><span class="s2">\n      </span><span class="s1">rej(error);</span><span class="s2">\n      </span><span class="s1">try {</span><span class="s2">\n        </span><span class="s1">await promise;</span><span class="s2">\n      </span><span class="s1">} catch (e) {</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">promise,</span><span class="s2">\n    </span><span class="s1">//@ts-ignore</span><span class="s2">\n    </span><span class="s1">resolve,</span><span class="s2">\n    </span><span class="s1">//@ts-ignore</span><span class="s2">\n    </span><span class="s1">reject</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/dom/ssr/fog-of-war.ts</span><span class="s2">\n</span><span class="s1">import * as React8 from </span><span class="s2">\&quot;</span><span class="s1">react</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n</span><span class="s1">// lib/dom/ssr/routes.tsx</span><span class="s2">\n</span><span class="s1">import * as React7 from </span><span class="s2">\&quot;</span><span class="s1">react</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n</span><span class="s1">// lib/dom/ssr/errorBoundaries.tsx</span><span class="s2">\n</span><span class="s1">import * as React5 from </span><span class="s2">\&quot;</span><span class="s1">react</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">var RemixErrorBoundary = class extends React5.Component {</span><span class="s2">\n  </span><span class="s1">constructor(props) {</span><span class="s2">\n    </span><span class="s1">super(props);</span><span class="s2">\n    </span><span class="s1">this.state = { error: props.error || null, location: props.location };</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">static getDerivedStateFromError(error) {</span><span class="s2">\n    </span><span class="s1">return { error };</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">static getDerivedStateFromProps(props, state) {</span><span class="s2">\n    </span><span class="s1">if (state.location !== props.location) {</span><span class="s2">\n      </span><span class="s1">return { error: props.error || null, location: props.location };</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return { error: props.error || state.error, location: state.location };</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">render() {</span><span class="s2">\n    </span><span class="s1">if (this.state.error) {</span><span class="s2">\n      </span><span class="s1">return /* @__PURE__ */ React5.createElement(</span><span class="s2">\n        </span><span class="s1">RemixRootDefaultErrorBoundary,</span><span class="s2">\n        </span><span class="s1">{</span><span class="s2">\n          </span><span class="s1">error: this.state.error,</span><span class="s2">\n          </span><span class="s1">isOutsideRemixApp: true</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">return this.props.children;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">function RemixRootDefaultErrorBoundary({</span><span class="s2">\n  </span><span class="s1">error,</span><span class="s2">\n  </span><span class="s1">isOutsideRemixApp</span><span class="s2">\n</span><span class="s1">}) {</span><span class="s2">\n  </span><span class="s1">console.error(error);</span><span class="s2">\n  </span><span class="s1">let heyDeveloper = /* @__PURE__ */ React5.createElement(</span><span class="s2">\n    \&quot;</span><span class="s1">script</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">{</span><span class="s2">\n      </span><span class="s1">dangerouslySetInnerHTML: {</span><span class="s2">\n        </span><span class="s1">__html: `</span><span class="s2">\n        </span><span class="s1">console.log(</span><span class="s2">\n          \&quot;\\</span><span class="s1">u{1F4BF} Hey developer </span><span class="s2">\\</span><span class="s1">u{1F44B}. You can provide a way better UX than this when your app throws errors. Check out https://reactrouter.com/how-to/error-boundary for more information.</span><span class="s2">\&quot;\n        </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">`</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">if (isRouteErrorResponse(error)) {</span><span class="s2">\n    </span><span class="s1">return /* @__PURE__ */ React5.createElement(BoundaryShell, { title: </span><span class="s2">\&quot;</span><span class="s1">Unhandled Thrown Response!</span><span class="s2">\&quot; </span><span class="s1">}, /* @__PURE__ */ React5.createElement(</span><span class="s2">\&quot;</span><span class="s1">h1</span><span class="s2">\&quot;</span><span class="s1">, { style: { fontSize: </span><span class="s2">\&quot;</span><span class="s1">24px</span><span class="s2">\&quot; </span><span class="s1">} }, error.status, </span><span class="s2">\&quot; \&quot;</span><span class="s1">, error.statusText), ENABLE_DEV_WARNINGS ? heyDeveloper : null);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let errorInstance;</span><span class="s2">\n  </span><span class="s1">if (error instanceof Error) {</span><span class="s2">\n    </span><span class="s1">errorInstance = error;</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">let errorString = error == null ? </span><span class="s2">\&quot;</span><span class="s1">Unknown Error</span><span class="s2">\&quot; </span><span class="s1">: typeof error === </span><span class="s2">\&quot;</span><span class="s1">object</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; </span><span class="s2">\&quot;</span><span class="s1">toString</span><span class="s2">\&quot; </span><span class="s1">in error ? error.toString() : JSON.stringify(error);</span><span class="s2">\n    </span><span class="s1">errorInstance = new Error(errorString);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return /* @__PURE__ */ React5.createElement(</span><span class="s2">\n    </span><span class="s1">BoundaryShell,</span><span class="s2">\n    </span><span class="s1">{</span><span class="s2">\n      </span><span class="s1">title: </span><span class="s2">\&quot;</span><span class="s1">Application Error!</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">isOutsideRemixApp</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">/* @__PURE__ */ React5.createElement(</span><span class="s2">\&quot;</span><span class="s1">h1</span><span class="s2">\&quot;</span><span class="s1">, { style: { fontSize: </span><span class="s2">\&quot;</span><span class="s1">24px</span><span class="s2">\&quot; </span><span class="s1">} }, </span><span class="s2">\&quot;</span><span class="s1">Application Error</span><span class="s2">\&quot;</span><span class="s1">),</span><span class="s2">\n    </span><span class="s1">/* @__PURE__ */ React5.createElement(</span><span class="s2">\n      \&quot;</span><span class="s1">pre</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">{</span><span class="s2">\n        </span><span class="s1">style: {</span><span class="s2">\n          </span><span class="s1">padding: </span><span class="s2">\&quot;</span><span class="s1">2rem</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n          </span><span class="s1">background: </span><span class="s2">\&quot;</span><span class="s1">hsla(10, 50%, 50%, 0.1)</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n          </span><span class="s1">color: </span><span class="s2">\&quot;</span><span class="s1">red</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n          </span><span class="s1">overflow: </span><span class="s2">\&quot;</span><span class="s1">auto</span><span class="s2">\&quot;\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">},</span><span class="s2">\n      </span><span class="s1">errorInstance.stack</span><span class="s2">\n    </span><span class="s1">),</span><span class="s2">\n    </span><span class="s1">heyDeveloper</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function BoundaryShell({</span><span class="s2">\n  </span><span class="s1">title,</span><span class="s2">\n  </span><span class="s1">renderScripts,</span><span class="s2">\n  </span><span class="s1">isOutsideRemixApp,</span><span class="s2">\n  </span><span class="s1">children</span><span class="s2">\n</span><span class="s1">}) {</span><span class="s2">\n  </span><span class="s1">let { routeModules } = useFrameworkContext();</span><span class="s2">\n  </span><span class="s1">if (routeModules.root?.Layout &amp;&amp; !isOutsideRemixApp) {</span><span class="s2">\n    </span><span class="s1">return children;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return /* @__PURE__ */ React5.createElement(</span><span class="s2">\&quot;</span><span class="s1">html</span><span class="s2">\&quot;</span><span class="s1">, { lang: </span><span class="s2">\&quot;</span><span class="s1">en</span><span class="s2">\&quot; </span><span class="s1">}, /* @__PURE__ */ React5.createElement(</span><span class="s2">\&quot;</span><span class="s1">head</span><span class="s2">\&quot;</span><span class="s1">, null, /* @__PURE__ */ React5.createElement(</span><span class="s2">\&quot;</span><span class="s1">meta</span><span class="s2">\&quot;</span><span class="s1">, { charSet: </span><span class="s2">\&quot;</span><span class="s1">utf-8</span><span class="s2">\&quot; </span><span class="s1">}), /* @__PURE__ */ React5.createElement(</span><span class="s2">\n    \&quot;</span><span class="s1">meta</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">{</span><span class="s2">\n      </span><span class="s1">name: </span><span class="s2">\&quot;</span><span class="s1">viewport</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">content: </span><span class="s2">\&quot;</span><span class="s1">width=device-width,initial-scale=1,viewport-fit=cover</span><span class="s2">\&quot;\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">), /* @__PURE__ */ React5.createElement(</span><span class="s2">\&quot;</span><span class="s1">title</span><span class="s2">\&quot;</span><span class="s1">, null, title)), /* @__PURE__ */ React5.createElement(</span><span class="s2">\&quot;</span><span class="s1">body</span><span class="s2">\&quot;</span><span class="s1">, null, /* @__PURE__ */ React5.createElement(</span><span class="s2">\&quot;</span><span class="s1">main</span><span class="s2">\&quot;</span><span class="s1">, { style: { fontFamily: </span><span class="s2">\&quot;</span><span class="s1">system-ui, sans-serif</span><span class="s2">\&quot;</span><span class="s1">, padding: </span><span class="s2">\&quot;</span><span class="s1">2rem</span><span class="s2">\&quot; </span><span class="s1">} }, children, renderScripts ? /* @__PURE__ */ React5.createElement(Scripts, null) : null)));</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/dom/ssr/fallback.tsx</span><span class="s2">\n</span><span class="s1">import * as React6 from </span><span class="s2">\&quot;</span><span class="s1">react</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">function RemixRootDefaultHydrateFallback() {</span><span class="s2">\n  </span><span class="s1">return /* @__PURE__ */ React6.createElement(BoundaryShell, { title: </span><span class="s2">\&quot;</span><span class="s1">Loading...</span><span class="s2">\&quot;</span><span class="s1">, renderScripts: true }, ENABLE_DEV_WARNINGS ? /* @__PURE__ */ React6.createElement(</span><span class="s2">\n    \&quot;</span><span class="s1">script</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">{</span><span class="s2">\n      </span><span class="s1">dangerouslySetInnerHTML: {</span><span class="s2">\n        </span><span class="s1">__html: `</span><span class="s2">\n              </span><span class="s1">console.log(</span><span class="s2">\n                \&quot;\\</span><span class="s1">u{1F4BF} Hey developer </span><span class="s2">\\</span><span class="s1">u{1F44B}. You can provide a way better UX than this </span><span class="s2">\&quot; </span><span class="s1">+</span><span class="s2">\n                \&quot;</span><span class="s1">when your app is loading JS modules and/or running </span><span class="s2">\\</span><span class="s1">`clientLoader</span><span class="s2">\\</span><span class="s1">` </span><span class="s2">\&quot; </span><span class="s1">+</span><span class="s2">\n                \&quot;</span><span class="s1">functions. Check out https://reactrouter.com/start/framework/route-module#hydratefallback </span><span class="s2">\&quot; </span><span class="s1">+</span><span class="s2">\n                \&quot;</span><span class="s1">for more information.</span><span class="s2">\&quot;\n              </span><span class="s1">);</span><span class="s2">\n            </span><span class="s1">`</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">) : null);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/dom/ssr/routes.tsx</span><span class="s2">\n</span><span class="s1">function groupRoutesByParentId(manifest) {</span><span class="s2">\n  </span><span class="s1">let routes = {};</span><span class="s2">\n  </span><span class="s1">Object.values(manifest).forEach((route) =&gt; {</span><span class="s2">\n    </span><span class="s1">if (route) {</span><span class="s2">\n      </span><span class="s1">let parentId = route.parentId || </span><span class="s2">\&quot;\&quot;</span><span class="s1">;</span><span class="s2">\n      </span><span class="s1">if (!routes[parentId]) {</span><span class="s2">\n        </span><span class="s1">routes[parentId] = [];</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">routes[parentId].push(route);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">return routes;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getRouteComponents(route, routeModule, isSpaMode) {</span><span class="s2">\n  </span><span class="s1">let Component4 = getRouteModuleComponent(routeModule);</span><span class="s2">\n  </span><span class="s1">let HydrateFallback = routeModule.HydrateFallback &amp;&amp; (!isSpaMode || route.id === </span><span class="s2">\&quot;</span><span class="s1">root</span><span class="s2">\&quot;</span><span class="s1">) ? routeModule.HydrateFallback : route.id === </span><span class="s2">\&quot;</span><span class="s1">root</span><span class="s2">\&quot; </span><span class="s1">? RemixRootDefaultHydrateFallback : void 0;</span><span class="s2">\n  </span><span class="s1">let ErrorBoundary = routeModule.ErrorBoundary ? routeModule.ErrorBoundary : route.id === </span><span class="s2">\&quot;</span><span class="s1">root</span><span class="s2">\&quot; </span><span class="s1">? () =&gt; /* @__PURE__ */ React7.createElement(RemixRootDefaultErrorBoundary, { error: useRouteError() }) : void 0;</span><span class="s2">\n  </span><span class="s1">if (route.id === </span><span class="s2">\&quot;</span><span class="s1">root</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; routeModule.Layout) {</span><span class="s2">\n    </span><span class="s1">return {</span><span class="s2">\n      </span><span class="s1">...Component4 ? {</span><span class="s2">\n        </span><span class="s1">element: /* @__PURE__ */ React7.createElement(routeModule.Layout, null, /* @__PURE__ */ React7.createElement(Component4, null))</span><span class="s2">\n      </span><span class="s1">} : { Component: Component4 },</span><span class="s2">\n      </span><span class="s1">...ErrorBoundary ? {</span><span class="s2">\n        </span><span class="s1">errorElement: /* @__PURE__ */ React7.createElement(routeModule.Layout, null, /* @__PURE__ */ React7.createElement(ErrorBoundary, null))</span><span class="s2">\n      </span><span class="s1">} : { ErrorBoundary },</span><span class="s2">\n      </span><span class="s1">...HydrateFallback ? {</span><span class="s2">\n        </span><span class="s1">hydrateFallbackElement: /* @__PURE__ */ React7.createElement(routeModule.Layout, null, /* @__PURE__ */ React7.createElement(HydrateFallback, null))</span><span class="s2">\n      </span><span class="s1">} : { HydrateFallback }</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return { Component: Component4, ErrorBoundary, HydrateFallback };</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createServerRoutes(manifest, routeModules, future, isSpaMode, parentId = </span><span class="s2">\&quot;\&quot;</span><span class="s1">, routesByParentId = groupRoutesByParentId(manifest), spaModeLazyPromise = Promise.resolve({ Component: () =&gt; null })) {</span><span class="s2">\n  </span><span class="s1">return (routesByParentId[parentId] || []).map((route) =&gt; {</span><span class="s2">\n    </span><span class="s1">let routeModule = routeModules[route.id];</span><span class="s2">\n    </span><span class="s1">invariant2(</span><span class="s2">\n      </span><span class="s1">routeModule,</span><span class="s2">\n      \&quot;</span><span class="s1">No `routeModule` available to create server routes</span><span class="s2">\&quot;\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">let dataRoute = {</span><span class="s2">\n      </span><span class="s1">...getRouteComponents(route, routeModule, isSpaMode),</span><span class="s2">\n      </span><span class="s1">caseSensitive: route.caseSensitive,</span><span class="s2">\n      </span><span class="s1">id: route.id,</span><span class="s2">\n      </span><span class="s1">index: route.index,</span><span class="s2">\n      </span><span class="s1">path: route.path,</span><span class="s2">\n      </span><span class="s1">handle: routeModule.handle,</span><span class="s2">\n      </span><span class="s1">// For SPA Mode, all routes are lazy except root.  However we tell the</span><span class="s2">\n      </span><span class="s1">// router root is also lazy here too since we don't need a full</span><span class="s2">\n      </span><span class="s1">// implementation - we just need a `lazy` prop to tell the RR rendering</span><span class="s2">\n      </span><span class="s1">// where to stop which is always at the root route in SPA mode</span><span class="s2">\n      </span><span class="s1">lazy: isSpaMode ? () =&gt; spaModeLazyPromise : void 0,</span><span class="s2">\n      </span><span class="s1">// For partial hydration rendering, we need to indicate when the route</span><span class="s2">\n      </span><span class="s1">// has a loader/clientLoader, but it won't ever be called during the static</span><span class="s2">\n      </span><span class="s1">// render, so just give it a no-op function so we can render down to the</span><span class="s2">\n      </span><span class="s1">// proper fallback</span><span class="s2">\n      </span><span class="s1">loader: route.hasLoader || route.hasClientLoader ? () =&gt; null : void 0</span><span class="s2">\n      </span><span class="s1">// We don't need middleware/action/shouldRevalidate on these routes since</span><span class="s2">\n      </span><span class="s1">// they're for a static render</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">let children = createServerRoutes(</span><span class="s2">\n      </span><span class="s1">manifest,</span><span class="s2">\n      </span><span class="s1">routeModules,</span><span class="s2">\n      </span><span class="s1">future,</span><span class="s2">\n      </span><span class="s1">isSpaMode,</span><span class="s2">\n      </span><span class="s1">route.id,</span><span class="s2">\n      </span><span class="s1">routesByParentId,</span><span class="s2">\n      </span><span class="s1">spaModeLazyPromise</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">if (children.length &gt; 0) dataRoute.children = children;</span><span class="s2">\n    </span><span class="s1">return dataRoute;</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createClientRoutesWithHMRRevalidationOptOut(needsRevalidation, manifest, routeModulesCache, initialState, ssr, isSpaMode) {</span><span class="s2">\n  </span><span class="s1">return createClientRoutes(</span><span class="s2">\n    </span><span class="s1">manifest,</span><span class="s2">\n    </span><span class="s1">routeModulesCache,</span><span class="s2">\n    </span><span class="s1">initialState,</span><span class="s2">\n    </span><span class="s1">ssr,</span><span class="s2">\n    </span><span class="s1">isSpaMode,</span><span class="s2">\n    \&quot;\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">groupRoutesByParentId(manifest),</span><span class="s2">\n    </span><span class="s1">needsRevalidation</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function preventInvalidServerHandlerCall(type, route) {</span><span class="s2">\n  </span><span class="s1">if (type === </span><span class="s2">\&quot;</span><span class="s1">loader</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; !route.hasLoader || type === </span><span class="s2">\&quot;</span><span class="s1">action</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; !route.hasAction) {</span><span class="s2">\n    </span><span class="s1">let fn = type === </span><span class="s2">\&quot;</span><span class="s1">action</span><span class="s2">\&quot; </span><span class="s1">? </span><span class="s2">\&quot;</span><span class="s1">serverAction()</span><span class="s2">\&quot; </span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">serverLoader()</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">let msg = `You are trying to call ${fn} on a route that does not have a server ${type} (routeId: </span><span class="s2">\&quot;</span><span class="s1">${route.id}</span><span class="s2">\&quot;</span><span class="s1">)`;</span><span class="s2">\n    </span><span class="s1">console.error(msg);</span><span class="s2">\n    </span><span class="s1">throw new ErrorResponseImpl(400, </span><span class="s2">\&quot;</span><span class="s1">Bad Request</span><span class="s2">\&quot;</span><span class="s1">, new Error(msg), true);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function noActionDefinedError(type, routeId) {</span><span class="s2">\n  </span><span class="s1">let article = type === </span><span class="s2">\&quot;</span><span class="s1">clientAction</span><span class="s2">\&quot; </span><span class="s1">? </span><span class="s2">\&quot;</span><span class="s1">a</span><span class="s2">\&quot; </span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">an</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">let msg = `Route </span><span class="s2">\&quot;</span><span class="s1">${routeId}</span><span class="s2">\&quot; </span><span class="s1">does not have ${article} ${type}, but you are trying to submit to it. To fix this, please add ${article} </span><span class="s2">\\</span><span class="s1">`${type}</span><span class="s2">\\</span><span class="s1">` function to the route`;</span><span class="s2">\n  </span><span class="s1">console.error(msg);</span><span class="s2">\n  </span><span class="s1">throw new ErrorResponseImpl(405, </span><span class="s2">\&quot;</span><span class="s1">Method Not Allowed</span><span class="s2">\&quot;</span><span class="s1">, new Error(msg), true);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createClientRoutes(manifest, routeModulesCache, initialState, ssr, isSpaMode, parentId = </span><span class="s2">\&quot;\&quot;</span><span class="s1">, routesByParentId = groupRoutesByParentId(manifest), needsRevalidation) {</span><span class="s2">\n  </span><span class="s1">return (routesByParentId[parentId] || []).map((route) =&gt; {</span><span class="s2">\n    </span><span class="s1">let routeModule = routeModulesCache[route.id];</span><span class="s2">\n    </span><span class="s1">function fetchServerHandler(singleFetch) {</span><span class="s2">\n      </span><span class="s1">invariant2(</span><span class="s2">\n        </span><span class="s1">typeof singleFetch === </span><span class="s2">\&quot;</span><span class="s1">function</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        \&quot;</span><span class="s1">No single fetch function available for route handler</span><span class="s2">\&quot;\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">return singleFetch();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">function fetchServerLoader(singleFetch) {</span><span class="s2">\n      </span><span class="s1">if (!route.hasLoader) return Promise.resolve(null);</span><span class="s2">\n      </span><span class="s1">return fetchServerHandler(singleFetch);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">function fetchServerAction(singleFetch) {</span><span class="s2">\n      </span><span class="s1">if (!route.hasAction) {</span><span class="s2">\n        </span><span class="s1">throw noActionDefinedError(</span><span class="s2">\&quot;</span><span class="s1">action</span><span class="s2">\&quot;</span><span class="s1">, route.id);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return fetchServerHandler(singleFetch);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">function prefetchModule(modulePath) {</span><span class="s2">\n      </span><span class="s1">import(</span><span class="s2">\n        </span><span class="s1">/* @vite-ignore */</span><span class="s2">\n        </span><span class="s1">/* webpackIgnore: true */</span><span class="s2">\n        </span><span class="s1">modulePath</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">function prefetchRouteModuleChunks(route2) {</span><span class="s2">\n      </span><span class="s1">if (route2.clientActionModule) {</span><span class="s2">\n        </span><span class="s1">prefetchModule(route2.clientActionModule);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (route2.clientLoaderModule) {</span><span class="s2">\n        </span><span class="s1">prefetchModule(route2.clientLoaderModule);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">async function prefetchStylesAndCallHandler(handler) {</span><span class="s2">\n      </span><span class="s1">let cachedModule = routeModulesCache[route.id];</span><span class="s2">\n      </span><span class="s1">let linkPrefetchPromise = cachedModule ? prefetchStyleLinks(route, cachedModule) : Promise.resolve();</span><span class="s2">\n      </span><span class="s1">try {</span><span class="s2">\n        </span><span class="s1">return handler();</span><span class="s2">\n      </span><span class="s1">} finally {</span><span class="s2">\n        </span><span class="s1">await linkPrefetchPromise;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let dataRoute = {</span><span class="s2">\n      </span><span class="s1">id: route.id,</span><span class="s2">\n      </span><span class="s1">index: route.index,</span><span class="s2">\n      </span><span class="s1">path: route.path</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">if (routeModule) {</span><span class="s2">\n      </span><span class="s1">Object.assign(dataRoute, {</span><span class="s2">\n        </span><span class="s1">...dataRoute,</span><span class="s2">\n        </span><span class="s1">...getRouteComponents(route, routeModule, isSpaMode),</span><span class="s2">\n        </span><span class="s1">unstable_middleware: routeModule.unstable_clientMiddleware,</span><span class="s2">\n        </span><span class="s1">handle: routeModule.handle,</span><span class="s2">\n        </span><span class="s1">shouldRevalidate: getShouldRevalidateFunction(</span><span class="s2">\n          </span><span class="s1">dataRoute.path,</span><span class="s2">\n          </span><span class="s1">routeModule,</span><span class="s2">\n          </span><span class="s1">route,</span><span class="s2">\n          </span><span class="s1">ssr,</span><span class="s2">\n          </span><span class="s1">needsRevalidation</span><span class="s2">\n        </span><span class="s1">)</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">let hasInitialData = initialState &amp;&amp; initialState.loaderData &amp;&amp; route.id in initialState.loaderData;</span><span class="s2">\n      </span><span class="s1">let initialData = hasInitialData ? initialState?.loaderData?.[route.id] : void 0;</span><span class="s2">\n      </span><span class="s1">let hasInitialError = initialState &amp;&amp; initialState.errors &amp;&amp; route.id in initialState.errors;</span><span class="s2">\n      </span><span class="s1">let initialError = hasInitialError ? initialState?.errors?.[route.id] : void 0;</span><span class="s2">\n      </span><span class="s1">let isHydrationRequest = needsRevalidation == null &amp;&amp; (routeModule.clientLoader?.hydrate === true || !route.hasLoader);</span><span class="s2">\n      </span><span class="s1">dataRoute.loader = async ({ request, params, context }, singleFetch) =&gt; {</span><span class="s2">\n        </span><span class="s1">try {</span><span class="s2">\n          </span><span class="s1">let result = await prefetchStylesAndCallHandler(async () =&gt; {</span><span class="s2">\n            </span><span class="s1">invariant2(</span><span class="s2">\n              </span><span class="s1">routeModule,</span><span class="s2">\n              \&quot;</span><span class="s1">No `routeModule` available for critical-route loader</span><span class="s2">\&quot;\n            </span><span class="s1">);</span><span class="s2">\n            </span><span class="s1">if (!routeModule.clientLoader) {</span><span class="s2">\n              </span><span class="s1">return fetchServerLoader(singleFetch);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">return routeModule.clientLoader({</span><span class="s2">\n              </span><span class="s1">request,</span><span class="s2">\n              </span><span class="s1">params,</span><span class="s2">\n              </span><span class="s1">context,</span><span class="s2">\n              </span><span class="s1">async serverLoader() {</span><span class="s2">\n                </span><span class="s1">preventInvalidServerHandlerCall(</span><span class="s2">\&quot;</span><span class="s1">loader</span><span class="s2">\&quot;</span><span class="s1">, route);</span><span class="s2">\n                </span><span class="s1">if (isHydrationRequest) {</span><span class="s2">\n                  </span><span class="s1">if (hasInitialData) {</span><span class="s2">\n                    </span><span class="s1">return initialData;</span><span class="s2">\n                  </span><span class="s1">}</span><span class="s2">\n                  </span><span class="s1">if (hasInitialError) {</span><span class="s2">\n                    </span><span class="s1">throw initialError;</span><span class="s2">\n                  </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">return fetchServerLoader(singleFetch);</span><span class="s2">\n              </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n          </span><span class="s1">return result;</span><span class="s2">\n        </span><span class="s1">} finally {</span><span class="s2">\n          </span><span class="s1">isHydrationRequest = false;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">dataRoute.loader.hydrate = shouldHydrateRouteLoader(</span><span class="s2">\n        </span><span class="s1">route.id,</span><span class="s2">\n        </span><span class="s1">routeModule.clientLoader,</span><span class="s2">\n        </span><span class="s1">route.hasLoader,</span><span class="s2">\n        </span><span class="s1">isSpaMode</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">dataRoute.action = ({ request, params, context }, singleFetch) =&gt; {</span><span class="s2">\n        </span><span class="s1">return prefetchStylesAndCallHandler(async () =&gt; {</span><span class="s2">\n          </span><span class="s1">invariant2(</span><span class="s2">\n            </span><span class="s1">routeModule,</span><span class="s2">\n            \&quot;</span><span class="s1">No `routeModule` available for critical-route action</span><span class="s2">\&quot;\n          </span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">if (!routeModule.clientAction) {</span><span class="s2">\n            </span><span class="s1">if (isSpaMode) {</span><span class="s2">\n              </span><span class="s1">throw noActionDefinedError(</span><span class="s2">\&quot;</span><span class="s1">clientAction</span><span class="s2">\&quot;</span><span class="s1">, route.id);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">return fetchServerAction(singleFetch);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">return routeModule.clientAction({</span><span class="s2">\n            </span><span class="s1">request,</span><span class="s2">\n            </span><span class="s1">params,</span><span class="s2">\n            </span><span class="s1">context,</span><span class="s2">\n            </span><span class="s1">async serverAction() {</span><span class="s2">\n              </span><span class="s1">preventInvalidServerHandlerCall(</span><span class="s2">\&quot;</span><span class="s1">action</span><span class="s2">\&quot;</span><span class="s1">, route);</span><span class="s2">\n              </span><span class="s1">return fetchServerAction(singleFetch);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">if (!route.hasClientLoader) {</span><span class="s2">\n        </span><span class="s1">dataRoute.loader = (_, singleFetch) =&gt; prefetchStylesAndCallHandler(() =&gt; {</span><span class="s2">\n          </span><span class="s1">return fetchServerLoader(singleFetch);</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (!route.hasClientAction) {</span><span class="s2">\n        </span><span class="s1">dataRoute.action = (_, singleFetch) =&gt; prefetchStylesAndCallHandler(() =&gt; {</span><span class="s2">\n          </span><span class="s1">if (isSpaMode) {</span><span class="s2">\n            </span><span class="s1">throw noActionDefinedError(</span><span class="s2">\&quot;</span><span class="s1">clientAction</span><span class="s2">\&quot;</span><span class="s1">, route.id);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">return fetchServerAction(singleFetch);</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">let lazyRoutePromise;</span><span class="s2">\n      </span><span class="s1">async function getLazyRoute() {</span><span class="s2">\n        </span><span class="s1">if (lazyRoutePromise) {</span><span class="s2">\n          </span><span class="s1">return await lazyRoutePromise;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">lazyRoutePromise = (async () =&gt; {</span><span class="s2">\n          </span><span class="s1">if (route.clientLoaderModule || route.clientActionModule) {</span><span class="s2">\n            </span><span class="s1">await new Promise((resolve) =&gt; setTimeout(resolve, 0));</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">let routeModulePromise = loadRouteModuleWithBlockingLinks(</span><span class="s2">\n            </span><span class="s1">route,</span><span class="s2">\n            </span><span class="s1">routeModulesCache</span><span class="s2">\n          </span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">prefetchRouteModuleChunks(route);</span><span class="s2">\n          </span><span class="s1">return await routeModulePromise;</span><span class="s2">\n        </span><span class="s1">})();</span><span class="s2">\n        </span><span class="s1">return await lazyRoutePromise;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">dataRoute.lazy = {</span><span class="s2">\n        </span><span class="s1">loader: route.hasClientLoader ? async () =&gt; {</span><span class="s2">\n          </span><span class="s1">let { clientLoader } = route.clientLoaderModule ? await import(</span><span class="s2">\n            </span><span class="s1">/* @vite-ignore */</span><span class="s2">\n            </span><span class="s1">/* webpackIgnore: true */</span><span class="s2">\n            </span><span class="s1">route.clientLoaderModule</span><span class="s2">\n          </span><span class="s1">) : await getLazyRoute();</span><span class="s2">\n          </span><span class="s1">invariant2(clientLoader, </span><span class="s2">\&quot;</span><span class="s1">No `clientLoader` export found</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">return (args, singleFetch) =&gt; clientLoader({</span><span class="s2">\n            </span><span class="s1">...args,</span><span class="s2">\n            </span><span class="s1">async serverLoader() {</span><span class="s2">\n              </span><span class="s1">preventInvalidServerHandlerCall(</span><span class="s2">\&quot;</span><span class="s1">loader</span><span class="s2">\&quot;</span><span class="s1">, route);</span><span class="s2">\n              </span><span class="s1">return fetchServerLoader(singleFetch);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">} : void 0,</span><span class="s2">\n        </span><span class="s1">action: route.hasClientAction ? async () =&gt; {</span><span class="s2">\n          </span><span class="s1">let clientActionPromise = route.clientActionModule ? import(</span><span class="s2">\n            </span><span class="s1">/* @vite-ignore */</span><span class="s2">\n            </span><span class="s1">/* webpackIgnore: true */</span><span class="s2">\n            </span><span class="s1">route.clientActionModule</span><span class="s2">\n          </span><span class="s1">) : getLazyRoute();</span><span class="s2">\n          </span><span class="s1">prefetchRouteModuleChunks(route);</span><span class="s2">\n          </span><span class="s1">let { clientAction } = await clientActionPromise;</span><span class="s2">\n          </span><span class="s1">invariant2(clientAction, </span><span class="s2">\&quot;</span><span class="s1">No `clientAction` export found</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">return (args, singleFetch) =&gt; clientAction({</span><span class="s2">\n            </span><span class="s1">...args,</span><span class="s2">\n            </span><span class="s1">async serverAction() {</span><span class="s2">\n              </span><span class="s1">preventInvalidServerHandlerCall(</span><span class="s2">\&quot;</span><span class="s1">action</span><span class="s2">\&quot;</span><span class="s1">, route);</span><span class="s2">\n              </span><span class="s1">return fetchServerAction(singleFetch);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">} : void 0,</span><span class="s2">\n        </span><span class="s1">unstable_middleware: route.hasClientMiddleware ? async () =&gt; {</span><span class="s2">\n          </span><span class="s1">let { unstable_clientMiddleware } = route.clientMiddlewareModule ? await import(</span><span class="s2">\n            </span><span class="s1">/* @vite-ignore */</span><span class="s2">\n            </span><span class="s1">/* webpackIgnore: true */</span><span class="s2">\n            </span><span class="s1">route.clientMiddlewareModule</span><span class="s2">\n          </span><span class="s1">) : await getLazyRoute();</span><span class="s2">\n          </span><span class="s1">invariant2(</span><span class="s2">\n            </span><span class="s1">unstable_clientMiddleware,</span><span class="s2">\n            \&quot;</span><span class="s1">No `unstable_clientMiddleware` export found</span><span class="s2">\&quot;\n          </span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">return unstable_clientMiddleware;</span><span class="s2">\n        </span><span class="s1">} : void 0,</span><span class="s2">\n        </span><span class="s1">shouldRevalidate: async () =&gt; {</span><span class="s2">\n          </span><span class="s1">let lazyRoute = await getLazyRoute();</span><span class="s2">\n          </span><span class="s1">return getShouldRevalidateFunction(</span><span class="s2">\n            </span><span class="s1">dataRoute.path,</span><span class="s2">\n            </span><span class="s1">lazyRoute,</span><span class="s2">\n            </span><span class="s1">route,</span><span class="s2">\n            </span><span class="s1">ssr,</span><span class="s2">\n            </span><span class="s1">needsRevalidation</span><span class="s2">\n          </span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">handle: async () =&gt; (await getLazyRoute()).handle,</span><span class="s2">\n        </span><span class="s1">// No need to wrap these in layout since the root route is never</span><span class="s2">\n        </span><span class="s1">// loaded via route.lazy()</span><span class="s2">\n        </span><span class="s1">Component: async () =&gt; (await getLazyRoute()).Component,</span><span class="s2">\n        </span><span class="s1">ErrorBoundary: route.hasErrorBoundary ? async () =&gt; (await getLazyRoute()).ErrorBoundary : void 0</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let children = createClientRoutes(</span><span class="s2">\n      </span><span class="s1">manifest,</span><span class="s2">\n      </span><span class="s1">routeModulesCache,</span><span class="s2">\n      </span><span class="s1">initialState,</span><span class="s2">\n      </span><span class="s1">ssr,</span><span class="s2">\n      </span><span class="s1">isSpaMode,</span><span class="s2">\n      </span><span class="s1">route.id,</span><span class="s2">\n      </span><span class="s1">routesByParentId,</span><span class="s2">\n      </span><span class="s1">needsRevalidation</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">if (children.length &gt; 0) dataRoute.children = children;</span><span class="s2">\n    </span><span class="s1">return dataRoute;</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getShouldRevalidateFunction(path, route, manifestRoute, ssr, needsRevalidation) {</span><span class="s2">\n  </span><span class="s1">if (needsRevalidation) {</span><span class="s2">\n    </span><span class="s1">return wrapShouldRevalidateForHdr(</span><span class="s2">\n      </span><span class="s1">manifestRoute.id,</span><span class="s2">\n      </span><span class="s1">route.shouldRevalidate,</span><span class="s2">\n      </span><span class="s1">needsRevalidation</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (!ssr &amp;&amp; manifestRoute.hasLoader &amp;&amp; !manifestRoute.hasClientLoader) {</span><span class="s2">\n    </span><span class="s1">let myParams = path ? compilePath(path)[1].map((p) =&gt; p.paramName) : [];</span><span class="s2">\n    </span><span class="s1">const didParamsChange = (opts) =&gt; myParams.some((p) =&gt; opts.currentParams[p] !== opts.nextParams[p]);</span><span class="s2">\n    </span><span class="s1">if (route.shouldRevalidate) {</span><span class="s2">\n      </span><span class="s1">let fn = route.shouldRevalidate;</span><span class="s2">\n      </span><span class="s1">return (opts) =&gt; fn({</span><span class="s2">\n        </span><span class="s1">...opts,</span><span class="s2">\n        </span><span class="s1">defaultShouldRevalidate: didParamsChange(opts)</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">return (opts) =&gt; didParamsChange(opts);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (ssr &amp;&amp; route.shouldRevalidate) {</span><span class="s2">\n    </span><span class="s1">let fn = route.shouldRevalidate;</span><span class="s2">\n    </span><span class="s1">return (opts) =&gt; fn({ ...opts, defaultShouldRevalidate: true });</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return route.shouldRevalidate;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function wrapShouldRevalidateForHdr(routeId, routeShouldRevalidate, needsRevalidation) {</span><span class="s2">\n  </span><span class="s1">let handledRevalidation = false;</span><span class="s2">\n  </span><span class="s1">return (arg) =&gt; {</span><span class="s2">\n    </span><span class="s1">if (!handledRevalidation) {</span><span class="s2">\n      </span><span class="s1">handledRevalidation = true;</span><span class="s2">\n      </span><span class="s1">return needsRevalidation.has(routeId);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return routeShouldRevalidate ? routeShouldRevalidate(arg) : arg.defaultShouldRevalidate;</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">async function loadRouteModuleWithBlockingLinks(route, routeModules) {</span><span class="s2">\n  </span><span class="s1">let routeModulePromise = loadRouteModule(route, routeModules);</span><span class="s2">\n  </span><span class="s1">let prefetchRouteCssPromise = prefetchRouteCss(route);</span><span class="s2">\n  </span><span class="s1">let routeModule = await routeModulePromise;</span><span class="s2">\n  </span><span class="s1">await Promise.all([</span><span class="s2">\n    </span><span class="s1">prefetchRouteCssPromise,</span><span class="s2">\n    </span><span class="s1">prefetchStyleLinks(route, routeModule)</span><span class="s2">\n  </span><span class="s1">]);</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">Component: getRouteModuleComponent(routeModule),</span><span class="s2">\n    </span><span class="s1">ErrorBoundary: routeModule.ErrorBoundary,</span><span class="s2">\n    </span><span class="s1">unstable_clientMiddleware: routeModule.unstable_clientMiddleware,</span><span class="s2">\n    </span><span class="s1">clientAction: routeModule.clientAction,</span><span class="s2">\n    </span><span class="s1">clientLoader: routeModule.clientLoader,</span><span class="s2">\n    </span><span class="s1">handle: routeModule.handle,</span><span class="s2">\n    </span><span class="s1">links: routeModule.links,</span><span class="s2">\n    </span><span class="s1">meta: routeModule.meta,</span><span class="s2">\n    </span><span class="s1">shouldRevalidate: routeModule.shouldRevalidate</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getRouteModuleComponent(routeModule) {</span><span class="s2">\n  </span><span class="s1">if (routeModule.default == null) return void 0;</span><span class="s2">\n  </span><span class="s1">let isEmptyObject = typeof routeModule.default === </span><span class="s2">\&quot;</span><span class="s1">object</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; Object.keys(routeModule.default).length === 0;</span><span class="s2">\n  </span><span class="s1">if (!isEmptyObject) {</span><span class="s2">\n    </span><span class="s1">return routeModule.default;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function shouldHydrateRouteLoader(routeId, clientLoader, hasLoader, isSpaMode) {</span><span class="s2">\n  </span><span class="s1">return isSpaMode &amp;&amp; routeId !== </span><span class="s2">\&quot;</span><span class="s1">root</span><span class="s2">\&quot; </span><span class="s1">|| clientLoader != null &amp;&amp; (clientLoader.hydrate === true || hasLoader !== true);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/dom/ssr/fog-of-war.ts</span><span class="s2">\n</span><span class="s1">var nextPaths = /* @__PURE__ */ new Set();</span><span class="s2">\n</span><span class="s1">var discoveredPathsMaxSize = 1e3;</span><span class="s2">\n</span><span class="s1">var discoveredPaths = /* @__PURE__ */ new Set();</span><span class="s2">\n</span><span class="s1">var URL_LIMIT = 7680;</span><span class="s2">\n</span><span class="s1">function isFogOfWarEnabled(routeDiscovery, ssr) {</span><span class="s2">\n  </span><span class="s1">return routeDiscovery.mode === </span><span class="s2">\&quot;</span><span class="s1">lazy</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; ssr === true;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getPartialManifest({ sri, ...manifest }, router) {</span><span class="s2">\n  </span><span class="s1">let routeIds = new Set(router.state.matches.map((m) =&gt; m.route.id));</span><span class="s2">\n  </span><span class="s1">let segments = router.state.location.pathname.split(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">).filter(Boolean);</span><span class="s2">\n  </span><span class="s1">let paths = [</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">];</span><span class="s2">\n  </span><span class="s1">segments.pop();</span><span class="s2">\n  </span><span class="s1">while (segments.length &gt; 0) {</span><span class="s2">\n    </span><span class="s1">paths.push(`/${segments.join(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">)}`);</span><span class="s2">\n    </span><span class="s1">segments.pop();</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">paths.forEach((path) =&gt; {</span><span class="s2">\n    </span><span class="s1">let matches = matchRoutes(router.routes, path, router.basename);</span><span class="s2">\n    </span><span class="s1">if (matches) {</span><span class="s2">\n      </span><span class="s1">matches.forEach((m) =&gt; routeIds.add(m.route.id));</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">let initialRoutes = [...routeIds].reduce(</span><span class="s2">\n    </span><span class="s1">(acc, id) =&gt; Object.assign(acc, { [id]: manifest.routes[id] }),</span><span class="s2">\n    </span><span class="s1">{}</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">...manifest,</span><span class="s2">\n    </span><span class="s1">routes: initialRoutes,</span><span class="s2">\n    </span><span class="s1">sri: sri ? true : void 0</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getPatchRoutesOnNavigationFunction(manifest, routeModules, ssr, routeDiscovery, isSpaMode, basename) {</span><span class="s2">\n  </span><span class="s1">if (!isFogOfWarEnabled(routeDiscovery, ssr)) {</span><span class="s2">\n    </span><span class="s1">return void 0;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return async ({ path, patch, signal, fetcherKey }) =&gt; {</span><span class="s2">\n    </span><span class="s1">if (discoveredPaths.has(path)) {</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">await fetchAndApplyManifestPatches(</span><span class="s2">\n      </span><span class="s1">[path],</span><span class="s2">\n      </span><span class="s1">fetcherKey ? window.location.href : path,</span><span class="s2">\n      </span><span class="s1">manifest,</span><span class="s2">\n      </span><span class="s1">routeModules,</span><span class="s2">\n      </span><span class="s1">ssr,</span><span class="s2">\n      </span><span class="s1">isSpaMode,</span><span class="s2">\n      </span><span class="s1">basename,</span><span class="s2">\n      </span><span class="s1">routeDiscovery.manifestPath,</span><span class="s2">\n      </span><span class="s1">patch,</span><span class="s2">\n      </span><span class="s1">signal</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useFogOFWarDiscovery(router, manifest, routeModules, ssr, routeDiscovery, isSpaMode) {</span><span class="s2">\n  </span><span class="s1">React8.useEffect(() =&gt; {</span><span class="s2">\n    </span><span class="s1">if (!isFogOfWarEnabled(routeDiscovery, ssr) || // @ts-expect-error - TS doesn't know about this yet</span><span class="s2">\n    </span><span class="s1">window.navigator?.connection?.saveData === true) {</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">function registerElement(el) {</span><span class="s2">\n      </span><span class="s1">let path = el.tagName === </span><span class="s2">\&quot;</span><span class="s1">FORM</span><span class="s2">\&quot; </span><span class="s1">? el.getAttribute(</span><span class="s2">\&quot;</span><span class="s1">action</span><span class="s2">\&quot;</span><span class="s1">) : el.getAttribute(</span><span class="s2">\&quot;</span><span class="s1">href</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">if (!path) {</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">let pathname = el.tagName === </span><span class="s2">\&quot;</span><span class="s1">A</span><span class="s2">\&quot; </span><span class="s1">? el.pathname : new URL(path, window.location.origin).pathname;</span><span class="s2">\n      </span><span class="s1">if (!discoveredPaths.has(pathname)) {</span><span class="s2">\n        </span><span class="s1">nextPaths.add(pathname);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">async function fetchPatches() {</span><span class="s2">\n      </span><span class="s1">document.querySelectorAll(</span><span class="s2">\&quot;</span><span class="s1">a[data-discover], form[data-discover]</span><span class="s2">\&quot;</span><span class="s1">).forEach(registerElement);</span><span class="s2">\n      </span><span class="s1">let lazyPaths = Array.from(nextPaths.keys()).filter((path) =&gt; {</span><span class="s2">\n        </span><span class="s1">if (discoveredPaths.has(path)) {</span><span class="s2">\n          </span><span class="s1">nextPaths.delete(path);</span><span class="s2">\n          </span><span class="s1">return false;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return true;</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">if (lazyPaths.length === 0) {</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">try {</span><span class="s2">\n        </span><span class="s1">await fetchAndApplyManifestPatches(</span><span class="s2">\n          </span><span class="s1">lazyPaths,</span><span class="s2">\n          </span><span class="s1">null,</span><span class="s2">\n          </span><span class="s1">manifest,</span><span class="s2">\n          </span><span class="s1">routeModules,</span><span class="s2">\n          </span><span class="s1">ssr,</span><span class="s2">\n          </span><span class="s1">isSpaMode,</span><span class="s2">\n          </span><span class="s1">router.basename,</span><span class="s2">\n          </span><span class="s1">routeDiscovery.manifestPath,</span><span class="s2">\n          </span><span class="s1">router.patchRoutes</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">} catch (e) {</span><span class="s2">\n        </span><span class="s1">console.error(</span><span class="s2">\&quot;</span><span class="s1">Failed to fetch manifest patches</span><span class="s2">\&quot;</span><span class="s1">, e);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let debouncedFetchPatches = debounce(fetchPatches, 100);</span><span class="s2">\n    </span><span class="s1">fetchPatches();</span><span class="s2">\n    </span><span class="s1">let observer = new MutationObserver(() =&gt; debouncedFetchPatches());</span><span class="s2">\n    </span><span class="s1">observer.observe(document.documentElement, {</span><span class="s2">\n      </span><span class="s1">subtree: true,</span><span class="s2">\n      </span><span class="s1">childList: true,</span><span class="s2">\n      </span><span class="s1">attributes: true,</span><span class="s2">\n      </span><span class="s1">attributeFilter: [</span><span class="s2">\&quot;</span><span class="s1">data-discover</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">href</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">action</span><span class="s2">\&quot;</span><span class="s1">]</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">return () =&gt; observer.disconnect();</span><span class="s2">\n  </span><span class="s1">}, [ssr, isSpaMode, manifest, routeModules, router, routeDiscovery]);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getManifestPath(_manifestPath, basename) {</span><span class="s2">\n  </span><span class="s1">let manifestPath = _manifestPath || </span><span class="s2">\&quot;</span><span class="s1">/__manifest</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">if (basename == null) {</span><span class="s2">\n    </span><span class="s1">return manifestPath;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return `${basename}${manifestPath}`.replace(/</span><span class="s2">\\</span><span class="s1">/+/g, </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var MANIFEST_VERSION_STORAGE_KEY = </span><span class="s2">\&quot;</span><span class="s1">react-router-manifest-version</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">async function fetchAndApplyManifestPatches(paths, errorReloadPath, manifest, routeModules, ssr, isSpaMode, basename, manifestPath, patchRoutes, signal) {</span><span class="s2">\n  </span><span class="s1">let url = new URL(</span><span class="s2">\n    </span><span class="s1">getManifestPath(manifestPath, basename),</span><span class="s2">\n    </span><span class="s1">window.location.origin</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">paths.sort().forEach((path) =&gt; url.searchParams.append(</span><span class="s2">\&quot;</span><span class="s1">p</span><span class="s2">\&quot;</span><span class="s1">, path));</span><span class="s2">\n  </span><span class="s1">url.searchParams.set(</span><span class="s2">\&quot;</span><span class="s1">version</span><span class="s2">\&quot;</span><span class="s1">, manifest.version);</span><span class="s2">\n  </span><span class="s1">if (url.toString().length &gt; URL_LIMIT) {</span><span class="s2">\n    </span><span class="s1">nextPaths.clear();</span><span class="s2">\n    </span><span class="s1">return;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let serverPatches;</span><span class="s2">\n  </span><span class="s1">try {</span><span class="s2">\n    </span><span class="s1">let res = await fetch(url, { signal });</span><span class="s2">\n    </span><span class="s1">if (!res.ok) {</span><span class="s2">\n      </span><span class="s1">throw new Error(`${res.status} ${res.statusText}`);</span><span class="s2">\n    </span><span class="s1">} else if (res.status === 204 &amp;&amp; res.headers.has(</span><span class="s2">\&quot;</span><span class="s1">X-Remix-Reload-Document</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n      </span><span class="s1">if (!errorReloadPath) {</span><span class="s2">\n        </span><span class="s1">console.warn(</span><span class="s2">\n          \&quot;</span><span class="s1">Detected a manifest version mismatch during eager route discovery. The next navigation/fetch to an undiscovered route will result in a new document navigation to sync up with the latest manifest.</span><span class="s2">\&quot;\n        </span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (sessionStorage.getItem(MANIFEST_VERSION_STORAGE_KEY) === manifest.version) {</span><span class="s2">\n        </span><span class="s1">console.error(</span><span class="s2">\n          \&quot;</span><span class="s1">Unable to discover routes due to manifest version mismatch.</span><span class="s2">\&quot;\n        </span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">sessionStorage.setItem(MANIFEST_VERSION_STORAGE_KEY, manifest.version);</span><span class="s2">\n      </span><span class="s1">window.location.href = errorReloadPath;</span><span class="s2">\n      </span><span class="s1">console.warn(</span><span class="s2">\&quot;</span><span class="s1">Detected manifest version mismatch, reloading...</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">await new Promise(() =&gt; {</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">} else if (res.status &gt;= 400) {</span><span class="s2">\n      </span><span class="s1">throw new Error(await res.text());</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">sessionStorage.removeItem(MANIFEST_VERSION_STORAGE_KEY);</span><span class="s2">\n    </span><span class="s1">serverPatches = await res.json();</span><span class="s2">\n  </span><span class="s1">} catch (e) {</span><span class="s2">\n    </span><span class="s1">if (signal?.aborted) return;</span><span class="s2">\n    </span><span class="s1">throw e;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let knownRoutes = new Set(Object.keys(manifest.routes));</span><span class="s2">\n  </span><span class="s1">let patches = Object.values(serverPatches).reduce((acc, route) =&gt; {</span><span class="s2">\n    </span><span class="s1">if (route &amp;&amp; !knownRoutes.has(route.id)) {</span><span class="s2">\n      </span><span class="s1">acc[route.id] = route;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return acc;</span><span class="s2">\n  </span><span class="s1">}, {});</span><span class="s2">\n  </span><span class="s1">Object.assign(manifest.routes, patches);</span><span class="s2">\n  </span><span class="s1">paths.forEach((p) =&gt; addToFifoQueue(p, discoveredPaths));</span><span class="s2">\n  </span><span class="s1">let parentIds = /* @__PURE__ */ new Set();</span><span class="s2">\n  </span><span class="s1">Object.values(patches).forEach((patch) =&gt; {</span><span class="s2">\n    </span><span class="s1">if (patch &amp;&amp; (!patch.parentId || !patches[patch.parentId])) {</span><span class="s2">\n      </span><span class="s1">parentIds.add(patch.parentId);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">parentIds.forEach(</span><span class="s2">\n    </span><span class="s1">(parentId) =&gt; patchRoutes(</span><span class="s2">\n      </span><span class="s1">parentId || null,</span><span class="s2">\n      </span><span class="s1">createClientRoutes(patches, routeModules, null, ssr, isSpaMode, parentId)</span><span class="s2">\n    </span><span class="s1">)</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function addToFifoQueue(path, queue) {</span><span class="s2">\n  </span><span class="s1">if (queue.size &gt;= discoveredPathsMaxSize) {</span><span class="s2">\n    </span><span class="s1">let first = queue.values().next().value;</span><span class="s2">\n    </span><span class="s1">queue.delete(first);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">queue.add(path);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function debounce(callback, wait) {</span><span class="s2">\n  </span><span class="s1">let timeoutId;</span><span class="s2">\n  </span><span class="s1">return (...args) =&gt; {</span><span class="s2">\n    </span><span class="s1">window.clearTimeout(timeoutId);</span><span class="s2">\n    </span><span class="s1">timeoutId = window.setTimeout(() =&gt; callback(...args), wait);</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/dom/ssr/components.tsx</span><span class="s2">\n</span><span class="s1">function useDataRouterContext2() {</span><span class="s2">\n  </span><span class="s1">let context = React9.useContext(DataRouterContext);</span><span class="s2">\n  </span><span class="s1">invariant2(</span><span class="s2">\n    </span><span class="s1">context,</span><span class="s2">\n    \&quot;</span><span class="s1">You must render this element inside a &lt;DataRouterContext.Provider&gt; element</span><span class="s2">\&quot;\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">return context;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useDataRouterStateContext() {</span><span class="s2">\n  </span><span class="s1">let context = React9.useContext(DataRouterStateContext);</span><span class="s2">\n  </span><span class="s1">invariant2(</span><span class="s2">\n    </span><span class="s1">context,</span><span class="s2">\n    \&quot;</span><span class="s1">You must render this element inside a &lt;DataRouterStateContext.Provider&gt; element</span><span class="s2">\&quot;\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">return context;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var FrameworkContext = React9.createContext(void 0);</span><span class="s2">\n</span><span class="s1">FrameworkContext.displayName = </span><span class="s2">\&quot;</span><span class="s1">FrameworkContext</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">function useFrameworkContext() {</span><span class="s2">\n  </span><span class="s1">let context = React9.useContext(FrameworkContext);</span><span class="s2">\n  </span><span class="s1">invariant2(</span><span class="s2">\n    </span><span class="s1">context,</span><span class="s2">\n    \&quot;</span><span class="s1">You must render this element inside a &lt;HydratedRouter&gt; element</span><span class="s2">\&quot;\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">return context;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function usePrefetchBehavior(prefetch, theirElementProps) {</span><span class="s2">\n  </span><span class="s1">let frameworkContext = React9.useContext(FrameworkContext);</span><span class="s2">\n  </span><span class="s1">let [maybePrefetch, setMaybePrefetch] = React9.useState(false);</span><span class="s2">\n  </span><span class="s1">let [shouldPrefetch, setShouldPrefetch] = React9.useState(false);</span><span class="s2">\n  </span><span class="s1">let { onFocus, onBlur, onMouseEnter, onMouseLeave, onTouchStart } = theirElementProps;</span><span class="s2">\n  </span><span class="s1">let ref = React9.useRef(null);</span><span class="s2">\n  </span><span class="s1">React9.useEffect(() =&gt; {</span><span class="s2">\n    </span><span class="s1">if (prefetch === </span><span class="s2">\&quot;</span><span class="s1">render</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">setShouldPrefetch(true);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (prefetch === </span><span class="s2">\&quot;</span><span class="s1">viewport</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">let callback = (entries) =&gt; {</span><span class="s2">\n        </span><span class="s1">entries.forEach((entry) =&gt; {</span><span class="s2">\n          </span><span class="s1">setShouldPrefetch(entry.isIntersecting);</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">let observer = new IntersectionObserver(callback, { threshold: 0.5 });</span><span class="s2">\n      </span><span class="s1">if (ref.current) observer.observe(ref.current);</span><span class="s2">\n      </span><span class="s1">return () =&gt; {</span><span class="s2">\n        </span><span class="s1">observer.disconnect();</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}, [prefetch]);</span><span class="s2">\n  </span><span class="s1">React9.useEffect(() =&gt; {</span><span class="s2">\n    </span><span class="s1">if (maybePrefetch) {</span><span class="s2">\n      </span><span class="s1">let id = setTimeout(() =&gt; {</span><span class="s2">\n        </span><span class="s1">setShouldPrefetch(true);</span><span class="s2">\n      </span><span class="s1">}, 100);</span><span class="s2">\n      </span><span class="s1">return () =&gt; {</span><span class="s2">\n        </span><span class="s1">clearTimeout(id);</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}, [maybePrefetch]);</span><span class="s2">\n  </span><span class="s1">let setIntent = () =&gt; {</span><span class="s2">\n    </span><span class="s1">setMaybePrefetch(true);</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">let cancelIntent = () =&gt; {</span><span class="s2">\n    </span><span class="s1">setMaybePrefetch(false);</span><span class="s2">\n    </span><span class="s1">setShouldPrefetch(false);</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">if (!frameworkContext) {</span><span class="s2">\n    </span><span class="s1">return [false, ref, {}];</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (prefetch !== </span><span class="s2">\&quot;</span><span class="s1">intent</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">return [shouldPrefetch, ref, {}];</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return [</span><span class="s2">\n    </span><span class="s1">shouldPrefetch,</span><span class="s2">\n    </span><span class="s1">ref,</span><span class="s2">\n    </span><span class="s1">{</span><span class="s2">\n      </span><span class="s1">onFocus: composeEventHandlers(onFocus, setIntent),</span><span class="s2">\n      </span><span class="s1">onBlur: composeEventHandlers(onBlur, cancelIntent),</span><span class="s2">\n      </span><span class="s1">onMouseEnter: composeEventHandlers(onMouseEnter, setIntent),</span><span class="s2">\n      </span><span class="s1">onMouseLeave: composeEventHandlers(onMouseLeave, cancelIntent),</span><span class="s2">\n      </span><span class="s1">onTouchStart: composeEventHandlers(onTouchStart, setIntent)</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">];</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function composeEventHandlers(theirHandler, ourHandler) {</span><span class="s2">\n  </span><span class="s1">return (event) =&gt; {</span><span class="s2">\n    </span><span class="s1">theirHandler &amp;&amp; theirHandler(event);</span><span class="s2">\n    </span><span class="s1">if (!event.defaultPrevented) {</span><span class="s2">\n      </span><span class="s1">ourHandler(event);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getActiveMatches(matches, errors, isSpaMode) {</span><span class="s2">\n  </span><span class="s1">if (isSpaMode &amp;&amp; !isHydrated) {</span><span class="s2">\n    </span><span class="s1">return [matches[0]];</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (errors) {</span><span class="s2">\n    </span><span class="s1">let errorIdx = matches.findIndex((m) =&gt; errors[m.route.id] !== void 0);</span><span class="s2">\n    </span><span class="s1">return matches.slice(0, errorIdx + 1);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return matches;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function Links() {</span><span class="s2">\n  </span><span class="s1">let { isSpaMode, manifest, routeModules, criticalCss } = useFrameworkContext();</span><span class="s2">\n  </span><span class="s1">let { errors, matches: routerMatches } = useDataRouterStateContext();</span><span class="s2">\n  </span><span class="s1">let matches = getActiveMatches(routerMatches, errors, isSpaMode);</span><span class="s2">\n  </span><span class="s1">let keyedLinks = React9.useMemo(</span><span class="s2">\n    </span><span class="s1">() =&gt; getKeyedLinksForMatches(matches, routeModules, manifest),</span><span class="s2">\n    </span><span class="s1">[matches, routeModules, manifest]</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">return /* @__PURE__ */ React9.createElement(React9.Fragment, null, typeof criticalCss === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">? /* @__PURE__ */ React9.createElement(</span><span class="s2">\&quot;</span><span class="s1">style</span><span class="s2">\&quot;</span><span class="s1">, { dangerouslySetInnerHTML: { __html: criticalCss } }) : null, typeof criticalCss === </span><span class="s2">\&quot;</span><span class="s1">object</span><span class="s2">\&quot; </span><span class="s1">? /* @__PURE__ */ React9.createElement(</span><span class="s2">\&quot;</span><span class="s1">link</span><span class="s2">\&quot;</span><span class="s1">, { rel: </span><span class="s2">\&quot;</span><span class="s1">stylesheet</span><span class="s2">\&quot;</span><span class="s1">, href: criticalCss.href }) : null, keyedLinks.map(</span><span class="s2">\n    </span><span class="s1">({ key, link }) =&gt; isPageLinkDescriptor(link) ? /* @__PURE__ */ React9.createElement(PrefetchPageLinks, { key, ...link }) : /* @__PURE__ */ React9.createElement(</span><span class="s2">\&quot;</span><span class="s1">link</span><span class="s2">\&quot;</span><span class="s1">, { key, ...link })</span><span class="s2">\n  </span><span class="s1">));</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function PrefetchPageLinks({</span><span class="s2">\n  </span><span class="s1">page,</span><span class="s2">\n  </span><span class="s1">...dataLinkProps</span><span class="s2">\n</span><span class="s1">}) {</span><span class="s2">\n  </span><span class="s1">let { router } = useDataRouterContext2();</span><span class="s2">\n  </span><span class="s1">let matches = React9.useMemo(</span><span class="s2">\n    </span><span class="s1">() =&gt; matchRoutes(router.routes, page, router.basename),</span><span class="s2">\n    </span><span class="s1">[router.routes, page, router.basename]</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">if (!matches) {</span><span class="s2">\n    </span><span class="s1">return null;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return /* @__PURE__ */ React9.createElement(PrefetchPageLinksImpl, { page, matches, ...dataLinkProps });</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useKeyedPrefetchLinks(matches) {</span><span class="s2">\n  </span><span class="s1">let { manifest, routeModules } = useFrameworkContext();</span><span class="s2">\n  </span><span class="s1">let [keyedPrefetchLinks, setKeyedPrefetchLinks] = React9.useState([]);</span><span class="s2">\n  </span><span class="s1">React9.useEffect(() =&gt; {</span><span class="s2">\n    </span><span class="s1">let interrupted = false;</span><span class="s2">\n    </span><span class="s1">void getKeyedPrefetchLinks(matches, manifest, routeModules).then(</span><span class="s2">\n      </span><span class="s1">(links) =&gt; {</span><span class="s2">\n        </span><span class="s1">if (!interrupted) {</span><span class="s2">\n          </span><span class="s1">setKeyedPrefetchLinks(links);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">return () =&gt; {</span><span class="s2">\n      </span><span class="s1">interrupted = true;</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}, [matches, manifest, routeModules]);</span><span class="s2">\n  </span><span class="s1">return keyedPrefetchLinks;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function PrefetchPageLinksImpl({</span><span class="s2">\n  </span><span class="s1">page,</span><span class="s2">\n  </span><span class="s1">matches: nextMatches,</span><span class="s2">\n  </span><span class="s1">...linkProps</span><span class="s2">\n</span><span class="s1">}) {</span><span class="s2">\n  </span><span class="s1">let location = useLocation();</span><span class="s2">\n  </span><span class="s1">let { manifest, routeModules } = useFrameworkContext();</span><span class="s2">\n  </span><span class="s1">let { basename } = useDataRouterContext2();</span><span class="s2">\n  </span><span class="s1">let { loaderData, matches } = useDataRouterStateContext();</span><span class="s2">\n  </span><span class="s1">let newMatchesForData = React9.useMemo(</span><span class="s2">\n    </span><span class="s1">() =&gt; getNewMatchesForLinks(</span><span class="s2">\n      </span><span class="s1">page,</span><span class="s2">\n      </span><span class="s1">nextMatches,</span><span class="s2">\n      </span><span class="s1">matches,</span><span class="s2">\n      </span><span class="s1">manifest,</span><span class="s2">\n      </span><span class="s1">location,</span><span class="s2">\n      \&quot;</span><span class="s1">data</span><span class="s2">\&quot;\n    </span><span class="s1">),</span><span class="s2">\n    </span><span class="s1">[page, nextMatches, matches, manifest, location]</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let newMatchesForAssets = React9.useMemo(</span><span class="s2">\n    </span><span class="s1">() =&gt; getNewMatchesForLinks(</span><span class="s2">\n      </span><span class="s1">page,</span><span class="s2">\n      </span><span class="s1">nextMatches,</span><span class="s2">\n      </span><span class="s1">matches,</span><span class="s2">\n      </span><span class="s1">manifest,</span><span class="s2">\n      </span><span class="s1">location,</span><span class="s2">\n      \&quot;</span><span class="s1">assets</span><span class="s2">\&quot;\n    </span><span class="s1">),</span><span class="s2">\n    </span><span class="s1">[page, nextMatches, matches, manifest, location]</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let dataHrefs = React9.useMemo(() =&gt; {</span><span class="s2">\n    </span><span class="s1">if (page === location.pathname + location.search + location.hash) {</span><span class="s2">\n      </span><span class="s1">return [];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let routesParams = /* @__PURE__ */ new Set();</span><span class="s2">\n    </span><span class="s1">let foundOptOutRoute = false;</span><span class="s2">\n    </span><span class="s1">nextMatches.forEach((m) =&gt; {</span><span class="s2">\n      </span><span class="s1">let manifestRoute = manifest.routes[m.route.id];</span><span class="s2">\n      </span><span class="s1">if (!manifestRoute || !manifestRoute.hasLoader) {</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (!newMatchesForData.some((m2) =&gt; m2.route.id === m.route.id) &amp;&amp; m.route.id in loaderData &amp;&amp; routeModules[m.route.id]?.shouldRevalidate) {</span><span class="s2">\n        </span><span class="s1">foundOptOutRoute = true;</span><span class="s2">\n      </span><span class="s1">} else if (manifestRoute.hasClientLoader) {</span><span class="s2">\n        </span><span class="s1">foundOptOutRoute = true;</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">routesParams.add(m.route.id);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">if (routesParams.size === 0) {</span><span class="s2">\n      </span><span class="s1">return [];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let url = singleFetchUrl(page, basename);</span><span class="s2">\n    </span><span class="s1">if (foundOptOutRoute &amp;&amp; routesParams.size &gt; 0) {</span><span class="s2">\n      </span><span class="s1">url.searchParams.set(</span><span class="s2">\n        \&quot;</span><span class="s1">_routes</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        </span><span class="s1">nextMatches.filter((m) =&gt; routesParams.has(m.route.id)).map((m) =&gt; m.route.id).join(</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\&quot;</span><span class="s1">)</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return [url.pathname + url.search];</span><span class="s2">\n  </span><span class="s1">}, [</span><span class="s2">\n    </span><span class="s1">basename,</span><span class="s2">\n    </span><span class="s1">loaderData,</span><span class="s2">\n    </span><span class="s1">location,</span><span class="s2">\n    </span><span class="s1">manifest,</span><span class="s2">\n    </span><span class="s1">newMatchesForData,</span><span class="s2">\n    </span><span class="s1">nextMatches,</span><span class="s2">\n    </span><span class="s1">page,</span><span class="s2">\n    </span><span class="s1">routeModules</span><span class="s2">\n  </span><span class="s1">]);</span><span class="s2">\n  </span><span class="s1">let moduleHrefs = React9.useMemo(</span><span class="s2">\n    </span><span class="s1">() =&gt; getModuleLinkHrefs(newMatchesForAssets, manifest),</span><span class="s2">\n    </span><span class="s1">[newMatchesForAssets, manifest]</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let keyedPrefetchLinks = useKeyedPrefetchLinks(newMatchesForAssets);</span><span class="s2">\n  </span><span class="s1">return /* @__PURE__ */ React9.createElement(React9.Fragment, null, dataHrefs.map((href2) =&gt; /* @__PURE__ */ React9.createElement(</span><span class="s2">\&quot;</span><span class="s1">link</span><span class="s2">\&quot;</span><span class="s1">, { key: href2, rel: </span><span class="s2">\&quot;</span><span class="s1">prefetch</span><span class="s2">\&quot;</span><span class="s1">, as: </span><span class="s2">\&quot;</span><span class="s1">fetch</span><span class="s2">\&quot;</span><span class="s1">, href: href2, ...linkProps })), moduleHrefs.map((href2) =&gt; /* @__PURE__ */ React9.createElement(</span><span class="s2">\&quot;</span><span class="s1">link</span><span class="s2">\&quot;</span><span class="s1">, { key: href2, rel: </span><span class="s2">\&quot;</span><span class="s1">modulepreload</span><span class="s2">\&quot;</span><span class="s1">, href: href2, ...linkProps })), keyedPrefetchLinks.map(({ key, link }) =&gt; (</span><span class="s2">\n    </span><span class="s1">// these don't spread `linkProps` because they are full link descriptors</span><span class="s2">\n    </span><span class="s1">// already with their own props</span><span class="s2">\n    </span><span class="s1">/* @__PURE__ */ React9.createElement(</span><span class="s2">\&quot;</span><span class="s1">link</span><span class="s2">\&quot;</span><span class="s1">, { key, ...link })</span><span class="s2">\n  </span><span class="s1">)));</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function Meta() {</span><span class="s2">\n  </span><span class="s1">let { isSpaMode, routeModules } = useFrameworkContext();</span><span class="s2">\n  </span><span class="s1">let {</span><span class="s2">\n    </span><span class="s1">errors,</span><span class="s2">\n    </span><span class="s1">matches: routerMatches,</span><span class="s2">\n    </span><span class="s1">loaderData</span><span class="s2">\n  </span><span class="s1">} = useDataRouterStateContext();</span><span class="s2">\n  </span><span class="s1">let location = useLocation();</span><span class="s2">\n  </span><span class="s1">let _matches = getActiveMatches(routerMatches, errors, isSpaMode);</span><span class="s2">\n  </span><span class="s1">let error = null;</span><span class="s2">\n  </span><span class="s1">if (errors) {</span><span class="s2">\n    </span><span class="s1">error = errors[_matches[_matches.length - 1].route.id];</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let meta = [];</span><span class="s2">\n  </span><span class="s1">let leafMeta = null;</span><span class="s2">\n  </span><span class="s1">let matches = [];</span><span class="s2">\n  </span><span class="s1">for (let i = 0; i &lt; _matches.length; i++) {</span><span class="s2">\n    </span><span class="s1">let _match = _matches[i];</span><span class="s2">\n    </span><span class="s1">let routeId = _match.route.id;</span><span class="s2">\n    </span><span class="s1">let data2 = loaderData[routeId];</span><span class="s2">\n    </span><span class="s1">let params = _match.params;</span><span class="s2">\n    </span><span class="s1">let routeModule = routeModules[routeId];</span><span class="s2">\n    </span><span class="s1">let routeMeta = [];</span><span class="s2">\n    </span><span class="s1">let match = {</span><span class="s2">\n      </span><span class="s1">id: routeId,</span><span class="s2">\n      </span><span class="s1">data: data2,</span><span class="s2">\n      </span><span class="s1">meta: [],</span><span class="s2">\n      </span><span class="s1">params: _match.params,</span><span class="s2">\n      </span><span class="s1">pathname: _match.pathname,</span><span class="s2">\n      </span><span class="s1">handle: _match.route.handle,</span><span class="s2">\n      </span><span class="s1">error</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">matches[i] = match;</span><span class="s2">\n    </span><span class="s1">if (routeModule?.meta) {</span><span class="s2">\n      </span><span class="s1">routeMeta = typeof routeModule.meta === </span><span class="s2">\&quot;</span><span class="s1">function</span><span class="s2">\&quot; </span><span class="s1">? routeModule.meta({</span><span class="s2">\n        </span><span class="s1">data: data2,</span><span class="s2">\n        </span><span class="s1">params,</span><span class="s2">\n        </span><span class="s1">location,</span><span class="s2">\n        </span><span class="s1">matches,</span><span class="s2">\n        </span><span class="s1">error</span><span class="s2">\n      </span><span class="s1">}) : Array.isArray(routeModule.meta) ? [...routeModule.meta] : routeModule.meta;</span><span class="s2">\n    </span><span class="s1">} else if (leafMeta) {</span><span class="s2">\n      </span><span class="s1">routeMeta = [...leafMeta];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">routeMeta = routeMeta || [];</span><span class="s2">\n    </span><span class="s1">if (!Array.isArray(routeMeta)) {</span><span class="s2">\n      </span><span class="s1">throw new Error(</span><span class="s2">\n        \&quot;</span><span class="s1">The route at </span><span class="s2">\&quot; </span><span class="s1">+ _match.route.path + </span><span class="s2">\&quot; </span><span class="s1">returns an invalid value. All route meta functions must return an array of meta objects.</span><span class="s2">\\</span><span class="s1">n</span><span class="s2">\\</span><span class="s1">nTo reference the meta function API, see https://remix.run/route/meta</span><span class="s2">\&quot;\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">match.meta = routeMeta;</span><span class="s2">\n    </span><span class="s1">matches[i] = match;</span><span class="s2">\n    </span><span class="s1">meta = [...routeMeta];</span><span class="s2">\n    </span><span class="s1">leafMeta = meta;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return /* @__PURE__ */ React9.createElement(React9.Fragment, null, meta.flat().map((metaProps) =&gt; {</span><span class="s2">\n    </span><span class="s1">if (!metaProps) {</span><span class="s2">\n      </span><span class="s1">return null;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (</span><span class="s2">\&quot;</span><span class="s1">tagName</span><span class="s2">\&quot; </span><span class="s1">in metaProps) {</span><span class="s2">\n      </span><span class="s1">let { tagName, ...rest } = metaProps;</span><span class="s2">\n      </span><span class="s1">if (!isValidMetaTag(tagName)) {</span><span class="s2">\n        </span><span class="s1">console.warn(</span><span class="s2">\n          </span><span class="s1">`A meta object uses an invalid tagName: ${tagName}. Expected either 'link' or 'meta'`</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">return null;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">let Comp = tagName;</span><span class="s2">\n      </span><span class="s1">return /* @__PURE__ */ React9.createElement(Comp, { key: JSON.stringify(rest), ...rest });</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (</span><span class="s2">\&quot;</span><span class="s1">title</span><span class="s2">\&quot; </span><span class="s1">in metaProps) {</span><span class="s2">\n      </span><span class="s1">return /* @__PURE__ */ React9.createElement(</span><span class="s2">\&quot;</span><span class="s1">title</span><span class="s2">\&quot;</span><span class="s1">, { key: </span><span class="s2">\&quot;</span><span class="s1">title</span><span class="s2">\&quot; </span><span class="s1">}, String(metaProps.title));</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (</span><span class="s2">\&quot;</span><span class="s1">charset</span><span class="s2">\&quot; </span><span class="s1">in metaProps) {</span><span class="s2">\n      </span><span class="s1">metaProps.charSet ?? (metaProps.charSet = metaProps.charset);</span><span class="s2">\n      </span><span class="s1">delete metaProps.charset;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (</span><span class="s2">\&quot;</span><span class="s1">charSet</span><span class="s2">\&quot; </span><span class="s1">in metaProps &amp;&amp; metaProps.charSet != null) {</span><span class="s2">\n      </span><span class="s1">return typeof metaProps.charSet === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">? /* @__PURE__ */ React9.createElement(</span><span class="s2">\&quot;</span><span class="s1">meta</span><span class="s2">\&quot;</span><span class="s1">, { key: </span><span class="s2">\&quot;</span><span class="s1">charSet</span><span class="s2">\&quot;</span><span class="s1">, charSet: metaProps.charSet }) : null;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (</span><span class="s2">\&quot;</span><span class="s1">script:ld+json</span><span class="s2">\&quot; </span><span class="s1">in metaProps) {</span><span class="s2">\n      </span><span class="s1">try {</span><span class="s2">\n        </span><span class="s1">let json = JSON.stringify(metaProps[</span><span class="s2">\&quot;</span><span class="s1">script:ld+json</span><span class="s2">\&quot;</span><span class="s1">]);</span><span class="s2">\n        </span><span class="s1">return /* @__PURE__ */ React9.createElement(</span><span class="s2">\n          \&quot;</span><span class="s1">script</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n          </span><span class="s1">{</span><span class="s2">\n            </span><span class="s1">key: `script:ld+json:${json}`,</span><span class="s2">\n            </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">application/ld+json</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n            </span><span class="s1">dangerouslySetInnerHTML: { __html: json }</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">} catch (err) {</span><span class="s2">\n        </span><span class="s1">return null;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return /* @__PURE__ */ React9.createElement(</span><span class="s2">\&quot;</span><span class="s1">meta</span><span class="s2">\&quot;</span><span class="s1">, { key: JSON.stringify(metaProps), ...metaProps });</span><span class="s2">\n  </span><span class="s1">}));</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isValidMetaTag(tagName) {</span><span class="s2">\n  </span><span class="s1">return typeof tagName === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; /^(meta|link)$/.test(tagName);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var isHydrated = false;</span><span class="s2">\n</span><span class="s1">function Scripts(props) {</span><span class="s2">\n  </span><span class="s1">let {</span><span class="s2">\n    </span><span class="s1">manifest,</span><span class="s2">\n    </span><span class="s1">serverHandoffString,</span><span class="s2">\n    </span><span class="s1">isSpaMode,</span><span class="s2">\n    </span><span class="s1">renderMeta,</span><span class="s2">\n    </span><span class="s1">routeDiscovery,</span><span class="s2">\n    </span><span class="s1">ssr</span><span class="s2">\n  </span><span class="s1">} = useFrameworkContext();</span><span class="s2">\n  </span><span class="s1">let { router, static: isStatic, staticContext } = useDataRouterContext2();</span><span class="s2">\n  </span><span class="s1">let { matches: routerMatches } = useDataRouterStateContext();</span><span class="s2">\n  </span><span class="s1">let enableFogOfWar = isFogOfWarEnabled(routeDiscovery, ssr);</span><span class="s2">\n  </span><span class="s1">if (renderMeta) {</span><span class="s2">\n    </span><span class="s1">renderMeta.didRenderScripts = true;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let matches = getActiveMatches(routerMatches, null, isSpaMode);</span><span class="s2">\n  </span><span class="s1">React9.useEffect(() =&gt; {</span><span class="s2">\n    </span><span class="s1">isHydrated = true;</span><span class="s2">\n  </span><span class="s1">}, []);</span><span class="s2">\n  </span><span class="s1">let initialScripts = React9.useMemo(() =&gt; {</span><span class="s2">\n    </span><span class="s1">let streamScript = </span><span class="s2">\&quot;</span><span class="s1">window.__reactRouterContext.stream = new ReadableStream({start(controller){window.__reactRouterContext.streamController = controller;}}).pipeThrough(new TextEncoderStream());</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">let contextScript = staticContext ? `window.__reactRouterContext = ${serverHandoffString};${streamScript}` : </span><span class="s2">\&quot; \&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">let routeModulesScript = !isStatic ? </span><span class="s2">\&quot; \&quot; </span><span class="s1">: `${manifest.hmr?.runtime ? `import ${JSON.stringify(manifest.hmr.runtime)};` : </span><span class="s2">\&quot;\&quot;</span><span class="s1">}${!enableFogOfWar ? `import ${JSON.stringify(manifest.url)}` : </span><span class="s2">\&quot;\&quot;</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">${matches.map((match, routeIndex) =&gt; {</span><span class="s2">\n      </span><span class="s1">let routeVarName = `route${routeIndex}`;</span><span class="s2">\n      </span><span class="s1">let manifestEntry = manifest.routes[match.route.id];</span><span class="s2">\n      </span><span class="s1">invariant2(manifestEntry, `Route ${match.route.id} not found in manifest`);</span><span class="s2">\n      </span><span class="s1">let {</span><span class="s2">\n        </span><span class="s1">clientActionModule,</span><span class="s2">\n        </span><span class="s1">clientLoaderModule,</span><span class="s2">\n        </span><span class="s1">clientMiddlewareModule,</span><span class="s2">\n        </span><span class="s1">hydrateFallbackModule,</span><span class="s2">\n        </span><span class="s1">module</span><span class="s2">\n      </span><span class="s1">} = manifestEntry;</span><span class="s2">\n      </span><span class="s1">let chunks = [</span><span class="s2">\n        </span><span class="s1">...clientActionModule ? [</span><span class="s2">\n          </span><span class="s1">{</span><span class="s2">\n            </span><span class="s1">module: clientActionModule,</span><span class="s2">\n            </span><span class="s1">varName: `${routeVarName}_clientAction`</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">] : [],</span><span class="s2">\n        </span><span class="s1">...clientLoaderModule ? [</span><span class="s2">\n          </span><span class="s1">{</span><span class="s2">\n            </span><span class="s1">module: clientLoaderModule,</span><span class="s2">\n            </span><span class="s1">varName: `${routeVarName}_clientLoader`</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">] : [],</span><span class="s2">\n        </span><span class="s1">...clientMiddlewareModule ? [</span><span class="s2">\n          </span><span class="s1">{</span><span class="s2">\n            </span><span class="s1">module: clientMiddlewareModule,</span><span class="s2">\n            </span><span class="s1">varName: `${routeVarName}_clientMiddleware`</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">] : [],</span><span class="s2">\n        </span><span class="s1">...hydrateFallbackModule ? [</span><span class="s2">\n          </span><span class="s1">{</span><span class="s2">\n            </span><span class="s1">module: hydrateFallbackModule,</span><span class="s2">\n            </span><span class="s1">varName: `${routeVarName}_HydrateFallback`</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">] : [],</span><span class="s2">\n        </span><span class="s1">{ module, varName: `${routeVarName}_main` }</span><span class="s2">\n      </span><span class="s1">];</span><span class="s2">\n      </span><span class="s1">if (chunks.length === 1) {</span><span class="s2">\n        </span><span class="s1">return `import * as ${routeVarName} from ${JSON.stringify(module)};`;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">let chunkImportsSnippet = chunks.map((chunk) =&gt; `import * as ${chunk.varName} from </span><span class="s2">\&quot;</span><span class="s1">${chunk.module}</span><span class="s2">\&quot;</span><span class="s1">;`).join(</span><span class="s2">\&quot;\\</span><span class="s1">n</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">let mergedChunksSnippet = `const ${routeVarName} = {${chunks.map((chunk) =&gt; `...${chunk.varName}`).join(</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\&quot;</span><span class="s1">)}};`;</span><span class="s2">\n      </span><span class="s1">return [chunkImportsSnippet, mergedChunksSnippet].join(</span><span class="s2">\&quot;\\</span><span class="s1">n</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}).join(</span><span class="s2">\&quot;\\</span><span class="s1">n</span><span class="s2">\&quot;</span><span class="s1">)}</span><span class="s2">\n  </span><span class="s1">${enableFogOfWar ? (</span><span class="s2">\n      </span><span class="s1">// Inline a minimal manifest with the SSR matches</span><span class="s2">\n      </span><span class="s1">`window.__reactRouterManifest = ${JSON.stringify(</span><span class="s2">\n        </span><span class="s1">getPartialManifest(manifest, router),</span><span class="s2">\n        </span><span class="s1">null,</span><span class="s2">\n        </span><span class="s1">2</span><span class="s2">\n      </span><span class="s1">)};`</span><span class="s2">\n    </span><span class="s1">) : </span><span class="s2">\&quot;\&quot;</span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">window.__reactRouterRouteModules = {${matches.map((match, index) =&gt; `${JSON.stringify(match.route.id)}:route${index}`).join(</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\&quot;</span><span class="s1">)}};</span><span class="s2">\n\n</span><span class="s1">import(${JSON.stringify(manifest.entry.module)});`;</span><span class="s2">\n    </span><span class="s1">return /* @__PURE__ */ React9.createElement(React9.Fragment, null, /* @__PURE__ */ React9.createElement(</span><span class="s2">\n      \&quot;</span><span class="s1">script</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">{</span><span class="s2">\n        </span><span class="s1">...props,</span><span class="s2">\n        </span><span class="s1">suppressHydrationWarning: true,</span><span class="s2">\n        </span><span class="s1">dangerouslySetInnerHTML: createHtml(contextScript),</span><span class="s2">\n        </span><span class="s1">type: void 0</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">), /* @__PURE__ */ React9.createElement(</span><span class="s2">\n      \&quot;</span><span class="s1">script</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">{</span><span class="s2">\n        </span><span class="s1">...props,</span><span class="s2">\n        </span><span class="s1">suppressHydrationWarning: true,</span><span class="s2">\n        </span><span class="s1">dangerouslySetInnerHTML: createHtml(routeModulesScript),</span><span class="s2">\n        </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">module</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        </span><span class="s1">async: true</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">));</span><span class="s2">\n  </span><span class="s1">}, []);</span><span class="s2">\n  </span><span class="s1">let preloads = isHydrated ? [] : dedupe(</span><span class="s2">\n    </span><span class="s1">manifest.entry.imports.concat(</span><span class="s2">\n      </span><span class="s1">getModuleLinkHrefs(matches, manifest, {</span><span class="s2">\n        </span><span class="s1">includeHydrateFallback: true</span><span class="s2">\n      </span><span class="s1">})</span><span class="s2">\n    </span><span class="s1">)</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let sri = typeof manifest.sri === </span><span class="s2">\&quot;</span><span class="s1">object</span><span class="s2">\&quot; </span><span class="s1">? manifest.sri : {};</span><span class="s2">\n  </span><span class="s1">return isHydrated ? null : /* @__PURE__ */ React9.createElement(React9.Fragment, null, typeof manifest.sri === </span><span class="s2">\&quot;</span><span class="s1">object</span><span class="s2">\&quot; </span><span class="s1">? /* @__PURE__ */ React9.createElement(</span><span class="s2">\n    \&quot;</span><span class="s1">script</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">{</span><span class="s2">\n      \&quot;</span><span class="s1">rr-importmap</span><span class="s2">\&quot;</span><span class="s1">: </span><span class="s2">\&quot;\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">importmap</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">suppressHydrationWarning: true,</span><span class="s2">\n      </span><span class="s1">dangerouslySetInnerHTML: {</span><span class="s2">\n        </span><span class="s1">__html: JSON.stringify({</span><span class="s2">\n          </span><span class="s1">integrity: sri</span><span class="s2">\n        </span><span class="s1">})</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">) : null, !enableFogOfWar ? /* @__PURE__ */ React9.createElement(</span><span class="s2">\n    \&quot;</span><span class="s1">link</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">{</span><span class="s2">\n      </span><span class="s1">rel: </span><span class="s2">\&quot;</span><span class="s1">modulepreload</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">href: manifest.url,</span><span class="s2">\n      </span><span class="s1">crossOrigin: props.crossOrigin,</span><span class="s2">\n      </span><span class="s1">integrity: sri[manifest.url],</span><span class="s2">\n      </span><span class="s1">suppressHydrationWarning: true</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">) : null, /* @__PURE__ */ React9.createElement(</span><span class="s2">\n    \&quot;</span><span class="s1">link</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">{</span><span class="s2">\n      </span><span class="s1">rel: </span><span class="s2">\&quot;</span><span class="s1">modulepreload</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">href: manifest.entry.module,</span><span class="s2">\n      </span><span class="s1">crossOrigin: props.crossOrigin,</span><span class="s2">\n      </span><span class="s1">integrity: sri[manifest.entry.module],</span><span class="s2">\n      </span><span class="s1">suppressHydrationWarning: true</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">), preloads.map((path) =&gt; /* @__PURE__ */ React9.createElement(</span><span class="s2">\n    \&quot;</span><span class="s1">link</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">{</span><span class="s2">\n      </span><span class="s1">key: path,</span><span class="s2">\n      </span><span class="s1">rel: </span><span class="s2">\&quot;</span><span class="s1">modulepreload</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">href: path,</span><span class="s2">\n      </span><span class="s1">crossOrigin: props.crossOrigin,</span><span class="s2">\n      </span><span class="s1">integrity: sri[path],</span><span class="s2">\n      </span><span class="s1">suppressHydrationWarning: true</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">)), initialScripts);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function dedupe(array) {</span><span class="s2">\n  </span><span class="s1">return [...new Set(array)];</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function mergeRefs(...refs) {</span><span class="s2">\n  </span><span class="s1">return (value) =&gt; {</span><span class="s2">\n    </span><span class="s1">refs.forEach((ref) =&gt; {</span><span class="s2">\n      </span><span class="s1">if (typeof ref === </span><span class="s2">\&quot;</span><span class="s1">function</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">ref(value);</span><span class="s2">\n      </span><span class="s1">} else if (ref != null) {</span><span class="s2">\n        </span><span class="s1">ref.current = value;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/dom/lib.tsx</span><span class="s2">\n</span><span class="s1">var isBrowser = typeof window !== </span><span class="s2">\&quot;</span><span class="s1">undefined</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; typeof window.document !== </span><span class="s2">\&quot;</span><span class="s1">undefined</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; typeof window.document.createElement !== </span><span class="s2">\&quot;</span><span class="s1">undefined</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">try {</span><span class="s2">\n  </span><span class="s1">if (isBrowser) {</span><span class="s2">\n    </span><span class="s1">window.__reactRouterVersion = </span><span class="s2">\&quot;</span><span class="s1">7.6.0</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">} catch (e) {</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createBrowserRouter(routes, opts) {</span><span class="s2">\n  </span><span class="s1">return createRouter({</span><span class="s2">\n    </span><span class="s1">basename: opts?.basename,</span><span class="s2">\n    </span><span class="s1">unstable_getContext: opts?.unstable_getContext,</span><span class="s2">\n    </span><span class="s1">future: opts?.future,</span><span class="s2">\n    </span><span class="s1">history: createBrowserHistory({ window: opts?.window }),</span><span class="s2">\n    </span><span class="s1">hydrationData: opts?.hydrationData || parseHydrationData(),</span><span class="s2">\n    </span><span class="s1">routes,</span><span class="s2">\n    </span><span class="s1">mapRouteProperties,</span><span class="s2">\n    </span><span class="s1">hydrationRouteProperties,</span><span class="s2">\n    </span><span class="s1">dataStrategy: opts?.dataStrategy,</span><span class="s2">\n    </span><span class="s1">patchRoutesOnNavigation: opts?.patchRoutesOnNavigation,</span><span class="s2">\n    </span><span class="s1">window: opts?.window</span><span class="s2">\n  </span><span class="s1">}).initialize();</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createHashRouter(routes, opts) {</span><span class="s2">\n  </span><span class="s1">return createRouter({</span><span class="s2">\n    </span><span class="s1">basename: opts?.basename,</span><span class="s2">\n    </span><span class="s1">unstable_getContext: opts?.unstable_getContext,</span><span class="s2">\n    </span><span class="s1">future: opts?.future,</span><span class="s2">\n    </span><span class="s1">history: createHashHistory({ window: opts?.window }),</span><span class="s2">\n    </span><span class="s1">hydrationData: opts?.hydrationData || parseHydrationData(),</span><span class="s2">\n    </span><span class="s1">routes,</span><span class="s2">\n    </span><span class="s1">mapRouteProperties,</span><span class="s2">\n    </span><span class="s1">hydrationRouteProperties,</span><span class="s2">\n    </span><span class="s1">dataStrategy: opts?.dataStrategy,</span><span class="s2">\n    </span><span class="s1">patchRoutesOnNavigation: opts?.patchRoutesOnNavigation,</span><span class="s2">\n    </span><span class="s1">window: opts?.window</span><span class="s2">\n  </span><span class="s1">}).initialize();</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function parseHydrationData() {</span><span class="s2">\n  </span><span class="s1">let state = window?.__staticRouterHydrationData;</span><span class="s2">\n  </span><span class="s1">if (state &amp;&amp; state.errors) {</span><span class="s2">\n    </span><span class="s1">state = {</span><span class="s2">\n      </span><span class="s1">...state,</span><span class="s2">\n      </span><span class="s1">errors: deserializeErrors(state.errors)</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return state;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function deserializeErrors(errors) {</span><span class="s2">\n  </span><span class="s1">if (!errors) return null;</span><span class="s2">\n  </span><span class="s1">let entries = Object.entries(errors);</span><span class="s2">\n  </span><span class="s1">let serialized = {};</span><span class="s2">\n  </span><span class="s1">for (let [key, val] of entries) {</span><span class="s2">\n    </span><span class="s1">if (val &amp;&amp; val.__type === </span><span class="s2">\&quot;</span><span class="s1">RouteErrorResponse</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">serialized[key] = new ErrorResponseImpl(</span><span class="s2">\n        </span><span class="s1">val.status,</span><span class="s2">\n        </span><span class="s1">val.statusText,</span><span class="s2">\n        </span><span class="s1">val.data,</span><span class="s2">\n        </span><span class="s1">val.internal === true</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">} else if (val &amp;&amp; val.__type === </span><span class="s2">\&quot;</span><span class="s1">Error</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">if (val.__subType) {</span><span class="s2">\n        </span><span class="s1">let ErrorConstructor = window[val.__subType];</span><span class="s2">\n        </span><span class="s1">if (typeof ErrorConstructor === </span><span class="s2">\&quot;</span><span class="s1">function</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">try {</span><span class="s2">\n            </span><span class="s1">let error = new ErrorConstructor(val.message);</span><span class="s2">\n            </span><span class="s1">error.stack = </span><span class="s2">\&quot;\&quot;</span><span class="s1">;</span><span class="s2">\n            </span><span class="s1">serialized[key] = error;</span><span class="s2">\n          </span><span class="s1">} catch (e) {</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (serialized[key] == null) {</span><span class="s2">\n        </span><span class="s1">let error = new Error(val.message);</span><span class="s2">\n        </span><span class="s1">error.stack = </span><span class="s2">\&quot;\&quot;</span><span class="s1">;</span><span class="s2">\n        </span><span class="s1">serialized[key] = error;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">serialized[key] = val;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return serialized;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function BrowserRouter({</span><span class="s2">\n  </span><span class="s1">basename,</span><span class="s2">\n  </span><span class="s1">children,</span><span class="s2">\n  </span><span class="s1">window: window2</span><span class="s2">\n</span><span class="s1">}) {</span><span class="s2">\n  </span><span class="s1">let historyRef = React10.useRef();</span><span class="s2">\n  </span><span class="s1">if (historyRef.current == null) {</span><span class="s2">\n    </span><span class="s1">historyRef.current = createBrowserHistory({ window: window2, v5Compat: true });</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let history = historyRef.current;</span><span class="s2">\n  </span><span class="s1">let [state, setStateImpl] = React10.useState({</span><span class="s2">\n    </span><span class="s1">action: history.action,</span><span class="s2">\n    </span><span class="s1">location: history.location</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">let setState = React10.useCallback(</span><span class="s2">\n    </span><span class="s1">(newState) =&gt; {</span><span class="s2">\n      </span><span class="s1">React10.startTransition(() =&gt; setStateImpl(newState));</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">[setStateImpl]</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">React10.useLayoutEffect(() =&gt; history.listen(setState), [history, setState]);</span><span class="s2">\n  </span><span class="s1">return /* @__PURE__ */ React10.createElement(</span><span class="s2">\n    </span><span class="s1">Router,</span><span class="s2">\n    </span><span class="s1">{</span><span class="s2">\n      </span><span class="s1">basename,</span><span class="s2">\n      </span><span class="s1">children,</span><span class="s2">\n      </span><span class="s1">location: state.location,</span><span class="s2">\n      </span><span class="s1">navigationType: state.action,</span><span class="s2">\n      </span><span class="s1">navigator: history</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function HashRouter({ basename, children, window: window2 }) {</span><span class="s2">\n  </span><span class="s1">let historyRef = React10.useRef();</span><span class="s2">\n  </span><span class="s1">if (historyRef.current == null) {</span><span class="s2">\n    </span><span class="s1">historyRef.current = createHashHistory({ window: window2, v5Compat: true });</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let history = historyRef.current;</span><span class="s2">\n  </span><span class="s1">let [state, setStateImpl] = React10.useState({</span><span class="s2">\n    </span><span class="s1">action: history.action,</span><span class="s2">\n    </span><span class="s1">location: history.location</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">let setState = React10.useCallback(</span><span class="s2">\n    </span><span class="s1">(newState) =&gt; {</span><span class="s2">\n      </span><span class="s1">React10.startTransition(() =&gt; setStateImpl(newState));</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">[setStateImpl]</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">React10.useLayoutEffect(() =&gt; history.listen(setState), [history, setState]);</span><span class="s2">\n  </span><span class="s1">return /* @__PURE__ */ React10.createElement(</span><span class="s2">\n    </span><span class="s1">Router,</span><span class="s2">\n    </span><span class="s1">{</span><span class="s2">\n      </span><span class="s1">basename,</span><span class="s2">\n      </span><span class="s1">children,</span><span class="s2">\n      </span><span class="s1">location: state.location,</span><span class="s2">\n      </span><span class="s1">navigationType: state.action,</span><span class="s2">\n      </span><span class="s1">navigator: history</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function HistoryRouter({</span><span class="s2">\n  </span><span class="s1">basename,</span><span class="s2">\n  </span><span class="s1">children,</span><span class="s2">\n  </span><span class="s1">history</span><span class="s2">\n</span><span class="s1">}) {</span><span class="s2">\n  </span><span class="s1">let [state, setStateImpl] = React10.useState({</span><span class="s2">\n    </span><span class="s1">action: history.action,</span><span class="s2">\n    </span><span class="s1">location: history.location</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">let setState = React10.useCallback(</span><span class="s2">\n    </span><span class="s1">(newState) =&gt; {</span><span class="s2">\n      </span><span class="s1">React10.startTransition(() =&gt; setStateImpl(newState));</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">[setStateImpl]</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">React10.useLayoutEffect(() =&gt; history.listen(setState), [history, setState]);</span><span class="s2">\n  </span><span class="s1">return /* @__PURE__ */ React10.createElement(</span><span class="s2">\n    </span><span class="s1">Router,</span><span class="s2">\n    </span><span class="s1">{</span><span class="s2">\n      </span><span class="s1">basename,</span><span class="s2">\n      </span><span class="s1">children,</span><span class="s2">\n      </span><span class="s1">location: state.location,</span><span class="s2">\n      </span><span class="s1">navigationType: state.action,</span><span class="s2">\n      </span><span class="s1">navigator: history</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">HistoryRouter.displayName = </span><span class="s2">\&quot;</span><span class="s1">unstable_HistoryRouter</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">var ABSOLUTE_URL_REGEX2 = /^(?:[a-z][a-z0-9+.-]*:|</span><span class="s2">\\</span><span class="s1">/</span><span class="s2">\\</span><span class="s1">/)/i;</span><span class="s2">\n</span><span class="s1">var Link = React10.forwardRef(</span><span class="s2">\n  </span><span class="s1">function LinkWithRef({</span><span class="s2">\n    </span><span class="s1">onClick,</span><span class="s2">\n    </span><span class="s1">discover = </span><span class="s2">\&quot;</span><span class="s1">render</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">prefetch = </span><span class="s2">\&quot;</span><span class="s1">none</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">relative,</span><span class="s2">\n    </span><span class="s1">reloadDocument,</span><span class="s2">\n    </span><span class="s1">replace: replace2,</span><span class="s2">\n    </span><span class="s1">state,</span><span class="s2">\n    </span><span class="s1">target,</span><span class="s2">\n    </span><span class="s1">to,</span><span class="s2">\n    </span><span class="s1">preventScrollReset,</span><span class="s2">\n    </span><span class="s1">viewTransition,</span><span class="s2">\n    </span><span class="s1">...rest</span><span class="s2">\n  </span><span class="s1">}, forwardedRef) {</span><span class="s2">\n    </span><span class="s1">let { basename } = React10.useContext(NavigationContext);</span><span class="s2">\n    </span><span class="s1">let isAbsolute = typeof to === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; ABSOLUTE_URL_REGEX2.test(to);</span><span class="s2">\n    </span><span class="s1">let absoluteHref;</span><span class="s2">\n    </span><span class="s1">let isExternal = false;</span><span class="s2">\n    </span><span class="s1">if (typeof to === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; isAbsolute) {</span><span class="s2">\n      </span><span class="s1">absoluteHref = to;</span><span class="s2">\n      </span><span class="s1">if (isBrowser) {</span><span class="s2">\n        </span><span class="s1">try {</span><span class="s2">\n          </span><span class="s1">let currentUrl = new URL(window.location.href);</span><span class="s2">\n          </span><span class="s1">let targetUrl = to.startsWith(</span><span class="s2">\&quot;</span><span class="s1">//</span><span class="s2">\&quot;</span><span class="s1">) ? new URL(currentUrl.protocol + to) : new URL(to);</span><span class="s2">\n          </span><span class="s1">let path = stripBasename(targetUrl.pathname, basename);</span><span class="s2">\n          </span><span class="s1">if (targetUrl.origin === currentUrl.origin &amp;&amp; path != null) {</span><span class="s2">\n            </span><span class="s1">to = path + targetUrl.search + targetUrl.hash;</span><span class="s2">\n          </span><span class="s1">} else {</span><span class="s2">\n            </span><span class="s1">isExternal = true;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">} catch (e) {</span><span class="s2">\n          </span><span class="s1">warning(</span><span class="s2">\n            </span><span class="s1">false,</span><span class="s2">\n            </span><span class="s1">`&lt;Link to=</span><span class="s2">\&quot;</span><span class="s1">${to}</span><span class="s2">\&quot;</span><span class="s1">&gt; contains an invalid URL which will probably break when clicked - please update to a valid URL path.`</span><span class="s2">\n          </span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let href2 = useHref(to, { relative });</span><span class="s2">\n    </span><span class="s1">let [shouldPrefetch, prefetchRef, prefetchHandlers] = usePrefetchBehavior(</span><span class="s2">\n      </span><span class="s1">prefetch,</span><span class="s2">\n      </span><span class="s1">rest</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">let internalOnClick = useLinkClickHandler(to, {</span><span class="s2">\n      </span><span class="s1">replace: replace2,</span><span class="s2">\n      </span><span class="s1">state,</span><span class="s2">\n      </span><span class="s1">target,</span><span class="s2">\n      </span><span class="s1">preventScrollReset,</span><span class="s2">\n      </span><span class="s1">relative,</span><span class="s2">\n      </span><span class="s1">viewTransition</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">function handleClick(event) {</span><span class="s2">\n      </span><span class="s1">if (onClick) onClick(event);</span><span class="s2">\n      </span><span class="s1">if (!event.defaultPrevented) {</span><span class="s2">\n        </span><span class="s1">internalOnClick(event);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let link = (</span><span class="s2">\n      </span><span class="s1">// eslint-disable-next-line jsx-a11y/anchor-has-content</span><span class="s2">\n      </span><span class="s1">/* @__PURE__ */ React10.createElement(</span><span class="s2">\n        \&quot;</span><span class="s1">a</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        </span><span class="s1">{</span><span class="s2">\n          </span><span class="s1">...rest,</span><span class="s2">\n          </span><span class="s1">...prefetchHandlers,</span><span class="s2">\n          </span><span class="s1">href: absoluteHref || href2,</span><span class="s2">\n          </span><span class="s1">onClick: isExternal || reloadDocument ? onClick : handleClick,</span><span class="s2">\n          </span><span class="s1">ref: mergeRefs(forwardedRef, prefetchRef),</span><span class="s2">\n          </span><span class="s1">target,</span><span class="s2">\n          \&quot;</span><span class="s1">data-discover</span><span class="s2">\&quot;</span><span class="s1">: !isAbsolute &amp;&amp; discover === </span><span class="s2">\&quot;</span><span class="s1">render</span><span class="s2">\&quot; </span><span class="s1">? </span><span class="s2">\&quot;</span><span class="s1">true</span><span class="s2">\&quot; </span><span class="s1">: void 0</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">)</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">return shouldPrefetch &amp;&amp; !isAbsolute ? /* @__PURE__ */ React10.createElement(React10.Fragment, null, link, /* @__PURE__ */ React10.createElement(PrefetchPageLinks, { page: href2 })) : link;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">);</span><span class="s2">\n</span><span class="s1">Link.displayName = </span><span class="s2">\&quot;</span><span class="s1">Link</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">var NavLink = React10.forwardRef(</span><span class="s2">\n  </span><span class="s1">function NavLinkWithRef({</span><span class="s2">\n    \&quot;</span><span class="s1">aria-current</span><span class="s2">\&quot;</span><span class="s1">: ariaCurrentProp = </span><span class="s2">\&quot;</span><span class="s1">page</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">caseSensitive = false,</span><span class="s2">\n    </span><span class="s1">className: classNameProp = </span><span class="s2">\&quot;\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">end = false,</span><span class="s2">\n    </span><span class="s1">style: styleProp,</span><span class="s2">\n    </span><span class="s1">to,</span><span class="s2">\n    </span><span class="s1">viewTransition,</span><span class="s2">\n    </span><span class="s1">children,</span><span class="s2">\n    </span><span class="s1">...rest</span><span class="s2">\n  </span><span class="s1">}, ref) {</span><span class="s2">\n    </span><span class="s1">let path = useResolvedPath(to, { relative: rest.relative });</span><span class="s2">\n    </span><span class="s1">let location = useLocation();</span><span class="s2">\n    </span><span class="s1">let routerState = React10.useContext(DataRouterStateContext);</span><span class="s2">\n    </span><span class="s1">let { navigator, basename } = React10.useContext(NavigationContext);</span><span class="s2">\n    </span><span class="s1">let isTransitioning = routerState != null &amp;&amp; // Conditional usage is OK here because the usage of a data router is static</span><span class="s2">\n    </span><span class="s1">// eslint-disable-next-line react-hooks/rules-of-hooks</span><span class="s2">\n    </span><span class="s1">useViewTransitionState(path) &amp;&amp; viewTransition === true;</span><span class="s2">\n    </span><span class="s1">let toPathname = navigator.encodeLocation ? navigator.encodeLocation(path).pathname : path.pathname;</span><span class="s2">\n    </span><span class="s1">let locationPathname = location.pathname;</span><span class="s2">\n    </span><span class="s1">let nextLocationPathname = routerState &amp;&amp; routerState.navigation &amp;&amp; routerState.navigation.location ? routerState.navigation.location.pathname : null;</span><span class="s2">\n    </span><span class="s1">if (!caseSensitive) {</span><span class="s2">\n      </span><span class="s1">locationPathname = locationPathname.toLowerCase();</span><span class="s2">\n      </span><span class="s1">nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;</span><span class="s2">\n      </span><span class="s1">toPathname = toPathname.toLowerCase();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (nextLocationPathname &amp;&amp; basename) {</span><span class="s2">\n      </span><span class="s1">nextLocationPathname = stripBasename(nextLocationPathname, basename) || nextLocationPathname;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">const endSlashPosition = toPathname !== </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; toPathname.endsWith(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">) ? toPathname.length - 1 : toPathname.length;</span><span class="s2">\n    </span><span class="s1">let isActive = locationPathname === toPathname || !end &amp;&amp; locationPathname.startsWith(toPathname) &amp;&amp; locationPathname.charAt(endSlashPosition) === </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">let isPending = nextLocationPathname != null &amp;&amp; (nextLocationPathname === toPathname || !end &amp;&amp; nextLocationPathname.startsWith(toPathname) &amp;&amp; nextLocationPathname.charAt(toPathname.length) === </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">let renderProps = {</span><span class="s2">\n      </span><span class="s1">isActive,</span><span class="s2">\n      </span><span class="s1">isPending,</span><span class="s2">\n      </span><span class="s1">isTransitioning</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">let ariaCurrent = isActive ? ariaCurrentProp : void 0;</span><span class="s2">\n    </span><span class="s1">let className;</span><span class="s2">\n    </span><span class="s1">if (typeof classNameProp === </span><span class="s2">\&quot;</span><span class="s1">function</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">className = classNameProp(renderProps);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">className = [</span><span class="s2">\n        </span><span class="s1">classNameProp,</span><span class="s2">\n        </span><span class="s1">isActive ? </span><span class="s2">\&quot;</span><span class="s1">active</span><span class="s2">\&quot; </span><span class="s1">: null,</span><span class="s2">\n        </span><span class="s1">isPending ? </span><span class="s2">\&quot;</span><span class="s1">pending</span><span class="s2">\&quot; </span><span class="s1">: null,</span><span class="s2">\n        </span><span class="s1">isTransitioning ? </span><span class="s2">\&quot;</span><span class="s1">transitioning</span><span class="s2">\&quot; </span><span class="s1">: null</span><span class="s2">\n      </span><span class="s1">].filter(Boolean).join(</span><span class="s2">\&quot; \&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let style = typeof styleProp === </span><span class="s2">\&quot;</span><span class="s1">function</span><span class="s2">\&quot; </span><span class="s1">? styleProp(renderProps) : styleProp;</span><span class="s2">\n    </span><span class="s1">return /* @__PURE__ */ React10.createElement(</span><span class="s2">\n      </span><span class="s1">Link,</span><span class="s2">\n      </span><span class="s1">{</span><span class="s2">\n        </span><span class="s1">...rest,</span><span class="s2">\n        \&quot;</span><span class="s1">aria-current</span><span class="s2">\&quot;</span><span class="s1">: ariaCurrent,</span><span class="s2">\n        </span><span class="s1">className,</span><span class="s2">\n        </span><span class="s1">ref,</span><span class="s2">\n        </span><span class="s1">style,</span><span class="s2">\n        </span><span class="s1">to,</span><span class="s2">\n        </span><span class="s1">viewTransition</span><span class="s2">\n      </span><span class="s1">},</span><span class="s2">\n      </span><span class="s1">typeof children === </span><span class="s2">\&quot;</span><span class="s1">function</span><span class="s2">\&quot; </span><span class="s1">? children(renderProps) : children</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">);</span><span class="s2">\n</span><span class="s1">NavLink.displayName = </span><span class="s2">\&quot;</span><span class="s1">NavLink</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">var Form = React10.forwardRef(</span><span class="s2">\n  </span><span class="s1">({</span><span class="s2">\n    </span><span class="s1">discover = </span><span class="s2">\&quot;</span><span class="s1">render</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">fetcherKey,</span><span class="s2">\n    </span><span class="s1">navigate,</span><span class="s2">\n    </span><span class="s1">reloadDocument,</span><span class="s2">\n    </span><span class="s1">replace: replace2,</span><span class="s2">\n    </span><span class="s1">state,</span><span class="s2">\n    </span><span class="s1">method = defaultMethod,</span><span class="s2">\n    </span><span class="s1">action,</span><span class="s2">\n    </span><span class="s1">onSubmit,</span><span class="s2">\n    </span><span class="s1">relative,</span><span class="s2">\n    </span><span class="s1">preventScrollReset,</span><span class="s2">\n    </span><span class="s1">viewTransition,</span><span class="s2">\n    </span><span class="s1">...props</span><span class="s2">\n  </span><span class="s1">}, forwardedRef) =&gt; {</span><span class="s2">\n    </span><span class="s1">let submit = useSubmit();</span><span class="s2">\n    </span><span class="s1">let formAction = useFormAction(action, { relative });</span><span class="s2">\n    </span><span class="s1">let formMethod = method.toLowerCase() === </span><span class="s2">\&quot;</span><span class="s1">get</span><span class="s2">\&quot; </span><span class="s1">? </span><span class="s2">\&quot;</span><span class="s1">get</span><span class="s2">\&quot; </span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">post</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">let isAbsolute = typeof action === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; ABSOLUTE_URL_REGEX2.test(action);</span><span class="s2">\n    </span><span class="s1">let submitHandler = (event) =&gt; {</span><span class="s2">\n      </span><span class="s1">onSubmit &amp;&amp; onSubmit(event);</span><span class="s2">\n      </span><span class="s1">if (event.defaultPrevented) return;</span><span class="s2">\n      </span><span class="s1">event.preventDefault();</span><span class="s2">\n      </span><span class="s1">let submitter = event.nativeEvent.submitter;</span><span class="s2">\n      </span><span class="s1">let submitMethod = submitter?.getAttribute(</span><span class="s2">\&quot;</span><span class="s1">formmethod</span><span class="s2">\&quot;</span><span class="s1">) || method;</span><span class="s2">\n      </span><span class="s1">submit(submitter || event.currentTarget, {</span><span class="s2">\n        </span><span class="s1">fetcherKey,</span><span class="s2">\n        </span><span class="s1">method: submitMethod,</span><span class="s2">\n        </span><span class="s1">navigate,</span><span class="s2">\n        </span><span class="s1">replace: replace2,</span><span class="s2">\n        </span><span class="s1">state,</span><span class="s2">\n        </span><span class="s1">relative,</span><span class="s2">\n        </span><span class="s1">preventScrollReset,</span><span class="s2">\n        </span><span class="s1">viewTransition</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">return /* @__PURE__ */ React10.createElement(</span><span class="s2">\n      \&quot;</span><span class="s1">form</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">{</span><span class="s2">\n        </span><span class="s1">ref: forwardedRef,</span><span class="s2">\n        </span><span class="s1">method: formMethod,</span><span class="s2">\n        </span><span class="s1">action: formAction,</span><span class="s2">\n        </span><span class="s1">onSubmit: reloadDocument ? onSubmit : submitHandler,</span><span class="s2">\n        </span><span class="s1">...props,</span><span class="s2">\n        \&quot;</span><span class="s1">data-discover</span><span class="s2">\&quot;</span><span class="s1">: !isAbsolute &amp;&amp; discover === </span><span class="s2">\&quot;</span><span class="s1">render</span><span class="s2">\&quot; </span><span class="s1">? </span><span class="s2">\&quot;</span><span class="s1">true</span><span class="s2">\&quot; </span><span class="s1">: void 0</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">);</span><span class="s2">\n</span><span class="s1">Form.displayName = </span><span class="s2">\&quot;</span><span class="s1">Form</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">function ScrollRestoration({</span><span class="s2">\n  </span><span class="s1">getKey,</span><span class="s2">\n  </span><span class="s1">storageKey,</span><span class="s2">\n  </span><span class="s1">...props</span><span class="s2">\n</span><span class="s1">}) {</span><span class="s2">\n  </span><span class="s1">let remixContext = React10.useContext(FrameworkContext);</span><span class="s2">\n  </span><span class="s1">let { basename } = React10.useContext(NavigationContext);</span><span class="s2">\n  </span><span class="s1">let location = useLocation();</span><span class="s2">\n  </span><span class="s1">let matches = useMatches();</span><span class="s2">\n  </span><span class="s1">useScrollRestoration({ getKey, storageKey });</span><span class="s2">\n  </span><span class="s1">let ssrKey = React10.useMemo(</span><span class="s2">\n    </span><span class="s1">() =&gt; {</span><span class="s2">\n      </span><span class="s1">if (!remixContext || !getKey) return null;</span><span class="s2">\n      </span><span class="s1">let userKey = getScrollRestorationKey(</span><span class="s2">\n        </span><span class="s1">location,</span><span class="s2">\n        </span><span class="s1">matches,</span><span class="s2">\n        </span><span class="s1">basename,</span><span class="s2">\n        </span><span class="s1">getKey</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">return userKey !== location.key ? userKey : null;</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">// Nah, we only need this the first time for the SSR render</span><span class="s2">\n    </span><span class="s1">// eslint-disable-next-line react-hooks/exhaustive-deps</span><span class="s2">\n    </span><span class="s1">[]</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">if (!remixContext || remixContext.isSpaMode) {</span><span class="s2">\n    </span><span class="s1">return null;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let restoreScroll = ((storageKey2, restoreKey) =&gt; {</span><span class="s2">\n    </span><span class="s1">if (!window.history.state || !window.history.state.key) {</span><span class="s2">\n      </span><span class="s1">let key = Math.random().toString(32).slice(2);</span><span class="s2">\n      </span><span class="s1">window.history.replaceState({ key }, </span><span class="s2">\&quot;\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">try {</span><span class="s2">\n      </span><span class="s1">let positions = JSON.parse(sessionStorage.getItem(storageKey2) || </span><span class="s2">\&quot;</span><span class="s1">{}</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">let storedY = positions[restoreKey || window.history.state.key];</span><span class="s2">\n      </span><span class="s1">if (typeof storedY === </span><span class="s2">\&quot;</span><span class="s1">number</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">window.scrollTo(0, storedY);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} catch (error) {</span><span class="s2">\n      </span><span class="s1">console.error(error);</span><span class="s2">\n      </span><span class="s1">sessionStorage.removeItem(storageKey2);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}).toString();</span><span class="s2">\n  </span><span class="s1">return /* @__PURE__ */ React10.createElement(</span><span class="s2">\n    \&quot;</span><span class="s1">script</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">{</span><span class="s2">\n      </span><span class="s1">...props,</span><span class="s2">\n      </span><span class="s1">suppressHydrationWarning: true,</span><span class="s2">\n      </span><span class="s1">dangerouslySetInnerHTML: {</span><span class="s2">\n        </span><span class="s1">__html: `(${restoreScroll})(${JSON.stringify(</span><span class="s2">\n          </span><span class="s1">storageKey || SCROLL_RESTORATION_STORAGE_KEY</span><span class="s2">\n        </span><span class="s1">)}, ${JSON.stringify(ssrKey)})`</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">ScrollRestoration.displayName = </span><span class="s2">\&quot;</span><span class="s1">ScrollRestoration</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">function getDataRouterConsoleError2(hookName) {</span><span class="s2">\n  </span><span class="s1">return `${hookName} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useDataRouterContext3(hookName) {</span><span class="s2">\n  </span><span class="s1">let ctx = React10.useContext(DataRouterContext);</span><span class="s2">\n  </span><span class="s1">invariant(ctx, getDataRouterConsoleError2(hookName));</span><span class="s2">\n  </span><span class="s1">return ctx;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useDataRouterState2(hookName) {</span><span class="s2">\n  </span><span class="s1">let state = React10.useContext(DataRouterStateContext);</span><span class="s2">\n  </span><span class="s1">invariant(state, getDataRouterConsoleError2(hookName));</span><span class="s2">\n  </span><span class="s1">return state;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useLinkClickHandler(to, {</span><span class="s2">\n  </span><span class="s1">target,</span><span class="s2">\n  </span><span class="s1">replace: replaceProp,</span><span class="s2">\n  </span><span class="s1">state,</span><span class="s2">\n  </span><span class="s1">preventScrollReset,</span><span class="s2">\n  </span><span class="s1">relative,</span><span class="s2">\n  </span><span class="s1">viewTransition</span><span class="s2">\n</span><span class="s1">} = {}) {</span><span class="s2">\n  </span><span class="s1">let navigate = useNavigate();</span><span class="s2">\n  </span><span class="s1">let location = useLocation();</span><span class="s2">\n  </span><span class="s1">let path = useResolvedPath(to, { relative });</span><span class="s2">\n  </span><span class="s1">return React10.useCallback(</span><span class="s2">\n    </span><span class="s1">(event) =&gt; {</span><span class="s2">\n      </span><span class="s1">if (shouldProcessLinkClick(event, target)) {</span><span class="s2">\n        </span><span class="s1">event.preventDefault();</span><span class="s2">\n        </span><span class="s1">let replace2 = replaceProp !== void 0 ? replaceProp : createPath(location) === createPath(path);</span><span class="s2">\n        </span><span class="s1">navigate(to, {</span><span class="s2">\n          </span><span class="s1">replace: replace2,</span><span class="s2">\n          </span><span class="s1">state,</span><span class="s2">\n          </span><span class="s1">preventScrollReset,</span><span class="s2">\n          </span><span class="s1">relative,</span><span class="s2">\n          </span><span class="s1">viewTransition</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">[</span><span class="s2">\n      </span><span class="s1">location,</span><span class="s2">\n      </span><span class="s1">navigate,</span><span class="s2">\n      </span><span class="s1">path,</span><span class="s2">\n      </span><span class="s1">replaceProp,</span><span class="s2">\n      </span><span class="s1">state,</span><span class="s2">\n      </span><span class="s1">target,</span><span class="s2">\n      </span><span class="s1">to,</span><span class="s2">\n      </span><span class="s1">preventScrollReset,</span><span class="s2">\n      </span><span class="s1">relative,</span><span class="s2">\n      </span><span class="s1">viewTransition</span><span class="s2">\n    </span><span class="s1">]</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useSearchParams(defaultInit) {</span><span class="s2">\n  </span><span class="s1">warning(</span><span class="s2">\n    </span><span class="s1">typeof URLSearchParams !== </span><span class="s2">\&quot;</span><span class="s1">undefined</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">`You cannot use the </span><span class="s2">\\</span><span class="s1">`useSearchParams</span><span class="s2">\\</span><span class="s1">` hook in a browser that does not support the URLSearchParams API. If you need to support Internet Explorer 11, we recommend you load a polyfill such as https://github.com/ungap/url-search-params.`</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let defaultSearchParamsRef = React10.useRef(createSearchParams(defaultInit));</span><span class="s2">\n  </span><span class="s1">let hasSetSearchParamsRef = React10.useRef(false);</span><span class="s2">\n  </span><span class="s1">let location = useLocation();</span><span class="s2">\n  </span><span class="s1">let searchParams = React10.useMemo(</span><span class="s2">\n    </span><span class="s1">() =&gt; (</span><span class="s2">\n      </span><span class="s1">// Only merge in the defaults if we haven't yet called setSearchParams.</span><span class="s2">\n      </span><span class="s1">// Once we call that we want those to take precedence, otherwise you can't</span><span class="s2">\n      </span><span class="s1">// remove a param with setSearchParams({}) if it has an initial value</span><span class="s2">\n      </span><span class="s1">getSearchParamsForLocation(</span><span class="s2">\n        </span><span class="s1">location.search,</span><span class="s2">\n        </span><span class="s1">hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current</span><span class="s2">\n      </span><span class="s1">)</span><span class="s2">\n    </span><span class="s1">),</span><span class="s2">\n    </span><span class="s1">[location.search]</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let navigate = useNavigate();</span><span class="s2">\n  </span><span class="s1">let setSearchParams = React10.useCallback(</span><span class="s2">\n    </span><span class="s1">(nextInit, navigateOptions) =&gt; {</span><span class="s2">\n      </span><span class="s1">const newSearchParams = createSearchParams(</span><span class="s2">\n        </span><span class="s1">typeof nextInit === </span><span class="s2">\&quot;</span><span class="s1">function</span><span class="s2">\&quot; </span><span class="s1">? nextInit(searchParams) : nextInit</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">hasSetSearchParamsRef.current = true;</span><span class="s2">\n      </span><span class="s1">navigate(</span><span class="s2">\&quot;</span><span class="s1">?</span><span class="s2">\&quot; </span><span class="s1">+ newSearchParams, navigateOptions);</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">[navigate, searchParams]</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">return [searchParams, setSearchParams];</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var fetcherId = 0;</span><span class="s2">\n</span><span class="s1">var getUniqueFetcherId = () =&gt; `__${String(++fetcherId)}__`;</span><span class="s2">\n</span><span class="s1">function useSubmit() {</span><span class="s2">\n  </span><span class="s1">let { router } = useDataRouterContext3(</span><span class="s2">\&quot;</span><span class="s1">useSubmit</span><span class="s2">\&quot; </span><span class="s1">/* UseSubmit */);</span><span class="s2">\n  </span><span class="s1">let { basename } = React10.useContext(NavigationContext);</span><span class="s2">\n  </span><span class="s1">let currentRouteId = useRouteId();</span><span class="s2">\n  </span><span class="s1">return React10.useCallback(</span><span class="s2">\n    </span><span class="s1">async (target, options = {}) =&gt; {</span><span class="s2">\n      </span><span class="s1">let { action, method, encType, formData, body } = getFormSubmissionInfo(</span><span class="s2">\n        </span><span class="s1">target,</span><span class="s2">\n        </span><span class="s1">basename</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">if (options.navigate === false) {</span><span class="s2">\n        </span><span class="s1">let key = options.fetcherKey || getUniqueFetcherId();</span><span class="s2">\n        </span><span class="s1">await router.fetch(key, currentRouteId, options.action || action, {</span><span class="s2">\n          </span><span class="s1">preventScrollReset: options.preventScrollReset,</span><span class="s2">\n          </span><span class="s1">formData,</span><span class="s2">\n          </span><span class="s1">body,</span><span class="s2">\n          </span><span class="s1">formMethod: options.method || method,</span><span class="s2">\n          </span><span class="s1">formEncType: options.encType || encType,</span><span class="s2">\n          </span><span class="s1">flushSync: options.flushSync</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">await router.navigate(options.action || action, {</span><span class="s2">\n          </span><span class="s1">preventScrollReset: options.preventScrollReset,</span><span class="s2">\n          </span><span class="s1">formData,</span><span class="s2">\n          </span><span class="s1">body,</span><span class="s2">\n          </span><span class="s1">formMethod: options.method || method,</span><span class="s2">\n          </span><span class="s1">formEncType: options.encType || encType,</span><span class="s2">\n          </span><span class="s1">replace: options.replace,</span><span class="s2">\n          </span><span class="s1">state: options.state,</span><span class="s2">\n          </span><span class="s1">fromRouteId: currentRouteId,</span><span class="s2">\n          </span><span class="s1">flushSync: options.flushSync,</span><span class="s2">\n          </span><span class="s1">viewTransition: options.viewTransition</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">[router, basename, currentRouteId]</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useFormAction(action, { relative } = {}) {</span><span class="s2">\n  </span><span class="s1">let { basename } = React10.useContext(NavigationContext);</span><span class="s2">\n  </span><span class="s1">let routeContext = React10.useContext(RouteContext);</span><span class="s2">\n  </span><span class="s1">invariant(routeContext, </span><span class="s2">\&quot;</span><span class="s1">useFormAction must be used inside a RouteContext</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let [match] = routeContext.matches.slice(-1);</span><span class="s2">\n  </span><span class="s1">let path = { ...useResolvedPath(action ? action : </span><span class="s2">\&quot;</span><span class="s1">.</span><span class="s2">\&quot;</span><span class="s1">, { relative }) };</span><span class="s2">\n  </span><span class="s1">let location = useLocation();</span><span class="s2">\n  </span><span class="s1">if (action == null) {</span><span class="s2">\n    </span><span class="s1">path.search = location.search;</span><span class="s2">\n    </span><span class="s1">let params = new URLSearchParams(path.search);</span><span class="s2">\n    </span><span class="s1">let indexValues = params.getAll(</span><span class="s2">\&quot;</span><span class="s1">index</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">let hasNakedIndexParam = indexValues.some((v) =&gt; v === </span><span class="s2">\&quot;\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">if (hasNakedIndexParam) {</span><span class="s2">\n      </span><span class="s1">params.delete(</span><span class="s2">\&quot;</span><span class="s1">index</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">indexValues.filter((v) =&gt; v).forEach((v) =&gt; params.append(</span><span class="s2">\&quot;</span><span class="s1">index</span><span class="s2">\&quot;</span><span class="s1">, v));</span><span class="s2">\n      </span><span class="s1">let qs = params.toString();</span><span class="s2">\n      </span><span class="s1">path.search = qs ? `?${qs}` : </span><span class="s2">\&quot;\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if ((!action || action === </span><span class="s2">\&quot;</span><span class="s1">.</span><span class="s2">\&quot;</span><span class="s1">) &amp;&amp; match.route.index) {</span><span class="s2">\n    </span><span class="s1">path.search = path.search ? path.search.replace(/^</span><span class="s2">\\</span><span class="s1">?/, </span><span class="s2">\&quot;</span><span class="s1">?index&amp;</span><span class="s2">\&quot;</span><span class="s1">) : </span><span class="s2">\&quot;</span><span class="s1">?index</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (basename !== </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">path.pathname = path.pathname === </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot; </span><span class="s1">? basename : joinPaths([basename, path.pathname]);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return createPath(path);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useFetcher({</span><span class="s2">\n  </span><span class="s1">key</span><span class="s2">\n</span><span class="s1">} = {}) {</span><span class="s2">\n  </span><span class="s1">let { router } = useDataRouterContext3(</span><span class="s2">\&quot;</span><span class="s1">useFetcher</span><span class="s2">\&quot; </span><span class="s1">/* UseFetcher */);</span><span class="s2">\n  </span><span class="s1">let state = useDataRouterState2(</span><span class="s2">\&quot;</span><span class="s1">useFetcher</span><span class="s2">\&quot; </span><span class="s1">/* UseFetcher */);</span><span class="s2">\n  </span><span class="s1">let fetcherData = React10.useContext(FetchersContext);</span><span class="s2">\n  </span><span class="s1">let route = React10.useContext(RouteContext);</span><span class="s2">\n  </span><span class="s1">let routeId = route.matches[route.matches.length - 1]?.route.id;</span><span class="s2">\n  </span><span class="s1">invariant(fetcherData, `useFetcher must be used inside a FetchersContext`);</span><span class="s2">\n  </span><span class="s1">invariant(route, `useFetcher must be used inside a RouteContext`);</span><span class="s2">\n  </span><span class="s1">invariant(</span><span class="s2">\n    </span><span class="s1">routeId != null,</span><span class="s2">\n    </span><span class="s1">`useFetcher can only be used on routes that contain a unique </span><span class="s2">\&quot;</span><span class="s1">id</span><span class="s2">\&quot;</span><span class="s1">`</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let defaultKey = React10.useId();</span><span class="s2">\n  </span><span class="s1">let [fetcherKey, setFetcherKey] = React10.useState(key || defaultKey);</span><span class="s2">\n  </span><span class="s1">if (key &amp;&amp; key !== fetcherKey) {</span><span class="s2">\n    </span><span class="s1">setFetcherKey(key);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">React10.useEffect(() =&gt; {</span><span class="s2">\n    </span><span class="s1">router.getFetcher(fetcherKey);</span><span class="s2">\n    </span><span class="s1">return () =&gt; router.deleteFetcher(fetcherKey);</span><span class="s2">\n  </span><span class="s1">}, [router, fetcherKey]);</span><span class="s2">\n  </span><span class="s1">let load = React10.useCallback(</span><span class="s2">\n    </span><span class="s1">async (href2, opts) =&gt; {</span><span class="s2">\n      </span><span class="s1">invariant(routeId, </span><span class="s2">\&quot;</span><span class="s1">No routeId available for fetcher.load()</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">await router.fetch(fetcherKey, routeId, href2, opts);</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">[fetcherKey, routeId, router]</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let submitImpl = useSubmit();</span><span class="s2">\n  </span><span class="s1">let submit = React10.useCallback(</span><span class="s2">\n    </span><span class="s1">async (target, opts) =&gt; {</span><span class="s2">\n      </span><span class="s1">await submitImpl(target, {</span><span class="s2">\n        </span><span class="s1">...opts,</span><span class="s2">\n        </span><span class="s1">navigate: false,</span><span class="s2">\n        </span><span class="s1">fetcherKey</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">[fetcherKey, submitImpl]</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let FetcherForm = React10.useMemo(() =&gt; {</span><span class="s2">\n    </span><span class="s1">let FetcherForm2 = React10.forwardRef(</span><span class="s2">\n      </span><span class="s1">(props, ref) =&gt; {</span><span class="s2">\n        </span><span class="s1">return /* @__PURE__ */ React10.createElement(Form, { ...props, navigate: false, fetcherKey, ref });</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">FetcherForm2.displayName = </span><span class="s2">\&quot;</span><span class="s1">fetcher.Form</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">return FetcherForm2;</span><span class="s2">\n  </span><span class="s1">}, [fetcherKey]);</span><span class="s2">\n  </span><span class="s1">let fetcher = state.fetchers.get(fetcherKey) || IDLE_FETCHER;</span><span class="s2">\n  </span><span class="s1">let data2 = fetcherData.get(fetcherKey);</span><span class="s2">\n  </span><span class="s1">let fetcherWithComponents = React10.useMemo(</span><span class="s2">\n    </span><span class="s1">() =&gt; ({</span><span class="s2">\n      </span><span class="s1">Form: FetcherForm,</span><span class="s2">\n      </span><span class="s1">submit,</span><span class="s2">\n      </span><span class="s1">load,</span><span class="s2">\n      </span><span class="s1">...fetcher,</span><span class="s2">\n      </span><span class="s1">data: data2</span><span class="s2">\n    </span><span class="s1">}),</span><span class="s2">\n    </span><span class="s1">[FetcherForm, submit, load, fetcher, data2]</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">return fetcherWithComponents;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useFetchers() {</span><span class="s2">\n  </span><span class="s1">let state = useDataRouterState2(</span><span class="s2">\&quot;</span><span class="s1">useFetchers</span><span class="s2">\&quot; </span><span class="s1">/* UseFetchers */);</span><span class="s2">\n  </span><span class="s1">return Array.from(state.fetchers.entries()).map(([key, fetcher]) =&gt; ({</span><span class="s2">\n    </span><span class="s1">...fetcher,</span><span class="s2">\n    </span><span class="s1">key</span><span class="s2">\n  </span><span class="s1">}));</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var SCROLL_RESTORATION_STORAGE_KEY = </span><span class="s2">\&quot;</span><span class="s1">react-router-scroll-positions</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">var savedScrollPositions = {};</span><span class="s2">\n</span><span class="s1">function getScrollRestorationKey(location, matches, basename, getKey) {</span><span class="s2">\n  </span><span class="s1">let key = null;</span><span class="s2">\n  </span><span class="s1">if (getKey) {</span><span class="s2">\n    </span><span class="s1">if (basename !== </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">key = getKey(</span><span class="s2">\n        </span><span class="s1">{</span><span class="s2">\n          </span><span class="s1">...location,</span><span class="s2">\n          </span><span class="s1">pathname: stripBasename(location.pathname, basename) || location.pathname</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">matches</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">key = getKey(location, matches);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (key == null) {</span><span class="s2">\n    </span><span class="s1">key = location.key;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return key;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useScrollRestoration({</span><span class="s2">\n  </span><span class="s1">getKey,</span><span class="s2">\n  </span><span class="s1">storageKey</span><span class="s2">\n</span><span class="s1">} = {}) {</span><span class="s2">\n  </span><span class="s1">let { router } = useDataRouterContext3(</span><span class="s2">\&quot;</span><span class="s1">useScrollRestoration</span><span class="s2">\&quot; </span><span class="s1">/* UseScrollRestoration */);</span><span class="s2">\n  </span><span class="s1">let { restoreScrollPosition, preventScrollReset } = useDataRouterState2(</span><span class="s2">\n    \&quot;</span><span class="s1">useScrollRestoration</span><span class="s2">\&quot; </span><span class="s1">/* UseScrollRestoration */</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let { basename } = React10.useContext(NavigationContext);</span><span class="s2">\n  </span><span class="s1">let location = useLocation();</span><span class="s2">\n  </span><span class="s1">let matches = useMatches();</span><span class="s2">\n  </span><span class="s1">let navigation = useNavigation();</span><span class="s2">\n  </span><span class="s1">React10.useEffect(() =&gt; {</span><span class="s2">\n    </span><span class="s1">window.history.scrollRestoration = </span><span class="s2">\&quot;</span><span class="s1">manual</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">return () =&gt; {</span><span class="s2">\n      </span><span class="s1">window.history.scrollRestoration = </span><span class="s2">\&quot;</span><span class="s1">auto</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}, []);</span><span class="s2">\n  </span><span class="s1">usePageHide(</span><span class="s2">\n    </span><span class="s1">React10.useCallback(() =&gt; {</span><span class="s2">\n      </span><span class="s1">if (navigation.state === </span><span class="s2">\&quot;</span><span class="s1">idle</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">let key = getScrollRestorationKey(location, matches, basename, getKey);</span><span class="s2">\n        </span><span class="s1">savedScrollPositions[key] = window.scrollY;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">try {</span><span class="s2">\n        </span><span class="s1">sessionStorage.setItem(</span><span class="s2">\n          </span><span class="s1">storageKey || SCROLL_RESTORATION_STORAGE_KEY,</span><span class="s2">\n          </span><span class="s1">JSON.stringify(savedScrollPositions)</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">} catch (error) {</span><span class="s2">\n        </span><span class="s1">warning(</span><span class="s2">\n          </span><span class="s1">false,</span><span class="s2">\n          </span><span class="s1">`Failed to save scroll positions in sessionStorage, &lt;ScrollRestoration /&gt; will not work properly (${error}).`</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">window.history.scrollRestoration = </span><span class="s2">\&quot;</span><span class="s1">auto</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">}, [navigation.state, getKey, basename, location, matches, storageKey])</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">if (typeof document !== </span><span class="s2">\&quot;</span><span class="s1">undefined</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">React10.useLayoutEffect(() =&gt; {</span><span class="s2">\n      </span><span class="s1">try {</span><span class="s2">\n        </span><span class="s1">let sessionPositions = sessionStorage.getItem(</span><span class="s2">\n          </span><span class="s1">storageKey || SCROLL_RESTORATION_STORAGE_KEY</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">if (sessionPositions) {</span><span class="s2">\n          </span><span class="s1">savedScrollPositions = JSON.parse(sessionPositions);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">} catch (e) {</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}, [storageKey]);</span><span class="s2">\n    </span><span class="s1">React10.useLayoutEffect(() =&gt; {</span><span class="s2">\n      </span><span class="s1">let disableScrollRestoration = router?.enableScrollRestoration(</span><span class="s2">\n        </span><span class="s1">savedScrollPositions,</span><span class="s2">\n        </span><span class="s1">() =&gt; window.scrollY,</span><span class="s2">\n        </span><span class="s1">getKey ? (location2, matches2) =&gt; getScrollRestorationKey(location2, matches2, basename, getKey) : void 0</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">return () =&gt; disableScrollRestoration &amp;&amp; disableScrollRestoration();</span><span class="s2">\n    </span><span class="s1">}, [router, basename, getKey]);</span><span class="s2">\n    </span><span class="s1">React10.useLayoutEffect(() =&gt; {</span><span class="s2">\n      </span><span class="s1">if (restoreScrollPosition === false) {</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (typeof restoreScrollPosition === </span><span class="s2">\&quot;</span><span class="s1">number</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">window.scrollTo(0, restoreScrollPosition);</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (location.hash) {</span><span class="s2">\n        </span><span class="s1">let el = document.getElementById(</span><span class="s2">\n          </span><span class="s1">decodeURIComponent(location.hash.slice(1))</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">if (el) {</span><span class="s2">\n          </span><span class="s1">el.scrollIntoView();</span><span class="s2">\n          </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (preventScrollReset === true) {</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">window.scrollTo(0, 0);</span><span class="s2">\n    </span><span class="s1">}, [location, restoreScrollPosition, preventScrollReset]);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useBeforeUnload(callback, options) {</span><span class="s2">\n  </span><span class="s1">let { capture } = options || {};</span><span class="s2">\n  </span><span class="s1">React10.useEffect(() =&gt; {</span><span class="s2">\n    </span><span class="s1">let opts = capture != null ? { capture } : void 0;</span><span class="s2">\n    </span><span class="s1">window.addEventListener(</span><span class="s2">\&quot;</span><span class="s1">beforeunload</span><span class="s2">\&quot;</span><span class="s1">, callback, opts);</span><span class="s2">\n    </span><span class="s1">return () =&gt; {</span><span class="s2">\n      </span><span class="s1">window.removeEventListener(</span><span class="s2">\&quot;</span><span class="s1">beforeunload</span><span class="s2">\&quot;</span><span class="s1">, callback, opts);</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}, [callback, capture]);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function usePageHide(callback, options) {</span><span class="s2">\n  </span><span class="s1">let { capture } = options || {};</span><span class="s2">\n  </span><span class="s1">React10.useEffect(() =&gt; {</span><span class="s2">\n    </span><span class="s1">let opts = capture != null ? { capture } : void 0;</span><span class="s2">\n    </span><span class="s1">window.addEventListener(</span><span class="s2">\&quot;</span><span class="s1">pagehide</span><span class="s2">\&quot;</span><span class="s1">, callback, opts);</span><span class="s2">\n    </span><span class="s1">return () =&gt; {</span><span class="s2">\n      </span><span class="s1">window.removeEventListener(</span><span class="s2">\&quot;</span><span class="s1">pagehide</span><span class="s2">\&quot;</span><span class="s1">, callback, opts);</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}, [callback, capture]);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function usePrompt({</span><span class="s2">\n  </span><span class="s1">when,</span><span class="s2">\n  </span><span class="s1">message</span><span class="s2">\n</span><span class="s1">}) {</span><span class="s2">\n  </span><span class="s1">let blocker = useBlocker(when);</span><span class="s2">\n  </span><span class="s1">React10.useEffect(() =&gt; {</span><span class="s2">\n    </span><span class="s1">if (blocker.state === </span><span class="s2">\&quot;</span><span class="s1">blocked</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">let proceed = window.confirm(message);</span><span class="s2">\n      </span><span class="s1">if (proceed) {</span><span class="s2">\n        </span><span class="s1">setTimeout(blocker.proceed, 0);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">blocker.reset();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}, [blocker, message]);</span><span class="s2">\n  </span><span class="s1">React10.useEffect(() =&gt; {</span><span class="s2">\n    </span><span class="s1">if (blocker.state === </span><span class="s2">\&quot;</span><span class="s1">blocked</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; !when) {</span><span class="s2">\n      </span><span class="s1">blocker.reset();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}, [blocker, when]);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useViewTransitionState(to, opts = {}) {</span><span class="s2">\n  </span><span class="s1">let vtContext = React10.useContext(ViewTransitionContext);</span><span class="s2">\n  </span><span class="s1">invariant(</span><span class="s2">\n    </span><span class="s1">vtContext != null,</span><span class="s2">\n    \&quot;</span><span class="s1">`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?</span><span class="s2">\&quot;\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let { basename } = useDataRouterContext3(</span><span class="s2">\n    \&quot;</span><span class="s1">useViewTransitionState</span><span class="s2">\&quot; </span><span class="s1">/* useViewTransitionState */</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let path = useResolvedPath(to, { relative: opts.relative });</span><span class="s2">\n  </span><span class="s1">if (!vtContext.isTransitioning) {</span><span class="s2">\n    </span><span class="s1">return false;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let currentPath = stripBasename(vtContext.currentLocation.pathname, basename) || vtContext.currentLocation.pathname;</span><span class="s2">\n  </span><span class="s1">let nextPath = stripBasename(vtContext.nextLocation.pathname, basename) || vtContext.nextLocation.pathname;</span><span class="s2">\n  </span><span class="s1">return matchPath(path.pathname, nextPath) != null || matchPath(path.pathname, currentPath) != null;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/dom/server.tsx</span><span class="s2">\n</span><span class="s1">import * as React11 from </span><span class="s2">\&quot;</span><span class="s1">react</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">function StaticRouter({</span><span class="s2">\n  </span><span class="s1">basename,</span><span class="s2">\n  </span><span class="s1">children,</span><span class="s2">\n  </span><span class="s1">location: locationProp = </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;\n</span><span class="s1">}) {</span><span class="s2">\n  </span><span class="s1">if (typeof locationProp === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">locationProp = parsePath(locationProp);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let action = </span><span class="s2">\&quot;</span><span class="s1">POP</span><span class="s2">\&quot; </span><span class="s1">/* Pop */;</span><span class="s2">\n  </span><span class="s1">let location = {</span><span class="s2">\n    </span><span class="s1">pathname: locationProp.pathname || </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">search: locationProp.search || </span><span class="s2">\&quot;\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">hash: locationProp.hash || </span><span class="s2">\&quot;\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">state: locationProp.state != null ? locationProp.state : null,</span><span class="s2">\n    </span><span class="s1">key: locationProp.key || </span><span class="s2">\&quot;</span><span class="s1">default</span><span class="s2">\&quot;\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">let staticNavigator = getStatelessNavigator();</span><span class="s2">\n  </span><span class="s1">return /* @__PURE__ */ React11.createElement(</span><span class="s2">\n    </span><span class="s1">Router,</span><span class="s2">\n    </span><span class="s1">{</span><span class="s2">\n      </span><span class="s1">basename,</span><span class="s2">\n      </span><span class="s1">children,</span><span class="s2">\n      </span><span class="s1">location,</span><span class="s2">\n      </span><span class="s1">navigationType: action,</span><span class="s2">\n      </span><span class="s1">navigator: staticNavigator,</span><span class="s2">\n      </span><span class="s1">static: true</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function StaticRouterProvider({</span><span class="s2">\n  </span><span class="s1">context,</span><span class="s2">\n  </span><span class="s1">router,</span><span class="s2">\n  </span><span class="s1">hydrate: hydrate2 = true,</span><span class="s2">\n  </span><span class="s1">nonce</span><span class="s2">\n</span><span class="s1">}) {</span><span class="s2">\n  </span><span class="s1">invariant(</span><span class="s2">\n    </span><span class="s1">router &amp;&amp; context,</span><span class="s2">\n    \&quot;</span><span class="s1">You must provide `router` and `context` to &lt;StaticRouterProvider&gt;</span><span class="s2">\&quot;\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let dataRouterContext = {</span><span class="s2">\n    </span><span class="s1">router,</span><span class="s2">\n    </span><span class="s1">navigator: getStatelessNavigator(),</span><span class="s2">\n    </span><span class="s1">static: true,</span><span class="s2">\n    </span><span class="s1">staticContext: context,</span><span class="s2">\n    </span><span class="s1">basename: context.basename || </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">let fetchersContext = /* @__PURE__ */ new Map();</span><span class="s2">\n  </span><span class="s1">let hydrateScript = </span><span class="s2">\&quot;\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">if (hydrate2 !== false) {</span><span class="s2">\n    </span><span class="s1">let data2 = {</span><span class="s2">\n      </span><span class="s1">loaderData: context.loaderData,</span><span class="s2">\n      </span><span class="s1">actionData: context.actionData,</span><span class="s2">\n      </span><span class="s1">errors: serializeErrors(context.errors)</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">let json = htmlEscape(JSON.stringify(JSON.stringify(data2)));</span><span class="s2">\n    </span><span class="s1">hydrateScript = `window.__staticRouterHydrationData = JSON.parse(${json});`;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let { state } = dataRouterContext.router;</span><span class="s2">\n  </span><span class="s1">return /* @__PURE__ */ React11.createElement(React11.Fragment, null, /* @__PURE__ */ React11.createElement(DataRouterContext.Provider, { value: dataRouterContext }, /* @__PURE__ */ React11.createElement(DataRouterStateContext.Provider, { value: state }, /* @__PURE__ */ React11.createElement(FetchersContext.Provider, { value: fetchersContext }, /* @__PURE__ */ React11.createElement(ViewTransitionContext.Provider, { value: { isTransitioning: false } }, /* @__PURE__ */ React11.createElement(</span><span class="s2">\n    </span><span class="s1">Router,</span><span class="s2">\n    </span><span class="s1">{</span><span class="s2">\n      </span><span class="s1">basename: dataRouterContext.basename,</span><span class="s2">\n      </span><span class="s1">location: state.location,</span><span class="s2">\n      </span><span class="s1">navigationType: state.historyAction,</span><span class="s2">\n      </span><span class="s1">navigator: dataRouterContext.navigator,</span><span class="s2">\n      </span><span class="s1">static: dataRouterContext.static</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">/* @__PURE__ */ React11.createElement(</span><span class="s2">\n      </span><span class="s1">DataRoutes2,</span><span class="s2">\n      </span><span class="s1">{</span><span class="s2">\n        </span><span class="s1">routes: router.routes,</span><span class="s2">\n        </span><span class="s1">future: router.future,</span><span class="s2">\n        </span><span class="s1">state</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">)</span><span class="s2">\n  </span><span class="s1">))))), hydrateScript ? /* @__PURE__ */ React11.createElement(</span><span class="s2">\n    \&quot;</span><span class="s1">script</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">{</span><span class="s2">\n      </span><span class="s1">suppressHydrationWarning: true,</span><span class="s2">\n      </span><span class="s1">nonce,</span><span class="s2">\n      </span><span class="s1">dangerouslySetInnerHTML: { __html: hydrateScript }</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">) : null);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function DataRoutes2({</span><span class="s2">\n  </span><span class="s1">routes,</span><span class="s2">\n  </span><span class="s1">future,</span><span class="s2">\n  </span><span class="s1">state</span><span class="s2">\n</span><span class="s1">}) {</span><span class="s2">\n  </span><span class="s1">return useRoutesImpl(routes, void 0, state, future);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function serializeErrors(errors) {</span><span class="s2">\n  </span><span class="s1">if (!errors) return null;</span><span class="s2">\n  </span><span class="s1">let entries = Object.entries(errors);</span><span class="s2">\n  </span><span class="s1">let serialized = {};</span><span class="s2">\n  </span><span class="s1">for (let [key, val] of entries) {</span><span class="s2">\n    </span><span class="s1">if (isRouteErrorResponse(val)) {</span><span class="s2">\n      </span><span class="s1">serialized[key] = { ...val, __type: </span><span class="s2">\&quot;</span><span class="s1">RouteErrorResponse</span><span class="s2">\&quot; </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">} else if (val instanceof Error) {</span><span class="s2">\n      </span><span class="s1">serialized[key] = {</span><span class="s2">\n        </span><span class="s1">message: val.message,</span><span class="s2">\n        </span><span class="s1">__type: </span><span class="s2">\&quot;</span><span class="s1">Error</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        </span><span class="s1">// If this is a subclass (i.e., ReferenceError), send up the type so we</span><span class="s2">\n        </span><span class="s1">// can re-create the same type during hydration.</span><span class="s2">\n        </span><span class="s1">...val.name !== </span><span class="s2">\&quot;</span><span class="s1">Error</span><span class="s2">\&quot; </span><span class="s1">? {</span><span class="s2">\n          </span><span class="s1">__subType: val.name</span><span class="s2">\n        </span><span class="s1">} : {}</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">serialized[key] = val;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return serialized;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getStatelessNavigator() {</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">createHref,</span><span class="s2">\n    </span><span class="s1">encodeLocation,</span><span class="s2">\n    </span><span class="s1">push(to) {</span><span class="s2">\n      </span><span class="s1">throw new Error(</span><span class="s2">\n        </span><span class="s1">`You cannot use navigator.push() on the server because it is a stateless environment. This error was probably triggered when you did a </span><span class="s2">\\</span><span class="s1">`navigate(${JSON.stringify(to)})</span><span class="s2">\\</span><span class="s1">` somewhere in your app.`</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">replace(to) {</span><span class="s2">\n      </span><span class="s1">throw new Error(</span><span class="s2">\n        </span><span class="s1">`You cannot use navigator.replace() on the server because it is a stateless environment. This error was probably triggered when you did a </span><span class="s2">\\</span><span class="s1">`navigate(${JSON.stringify(to)}, { replace: true })</span><span class="s2">\\</span><span class="s1">` somewhere in your app.`</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">go(delta) {</span><span class="s2">\n      </span><span class="s1">throw new Error(</span><span class="s2">\n        </span><span class="s1">`You cannot use navigator.go() on the server because it is a stateless environment. This error was probably triggered when you did a </span><span class="s2">\\</span><span class="s1">`navigate(${delta})</span><span class="s2">\\</span><span class="s1">` somewhere in your app.`</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">back() {</span><span class="s2">\n      </span><span class="s1">throw new Error(</span><span class="s2">\n        </span><span class="s1">`You cannot use navigator.back() on the server because it is a stateless environment.`</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">forward() {</span><span class="s2">\n      </span><span class="s1">throw new Error(</span><span class="s2">\n        </span><span class="s1">`You cannot use navigator.forward() on the server because it is a stateless environment.`</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createStaticHandler2(routes, opts) {</span><span class="s2">\n  </span><span class="s1">return createStaticHandler(routes, {</span><span class="s2">\n    </span><span class="s1">...opts,</span><span class="s2">\n    </span><span class="s1">mapRouteProperties</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createStaticRouter(routes, context, opts = {}) {</span><span class="s2">\n  </span><span class="s1">let manifest = {};</span><span class="s2">\n  </span><span class="s1">let dataRoutes = convertRoutesToDataRoutes(</span><span class="s2">\n    </span><span class="s1">routes,</span><span class="s2">\n    </span><span class="s1">mapRouteProperties,</span><span class="s2">\n    </span><span class="s1">void 0,</span><span class="s2">\n    </span><span class="s1">manifest</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let matches = context.matches.map((match) =&gt; {</span><span class="s2">\n    </span><span class="s1">let route = manifest[match.route.id] || match.route;</span><span class="s2">\n    </span><span class="s1">return {</span><span class="s2">\n      </span><span class="s1">...match,</span><span class="s2">\n      </span><span class="s1">route</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">let msg = (method) =&gt; `You cannot use router.${method}() on the server because it is a stateless environment`;</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">get basename() {</span><span class="s2">\n      </span><span class="s1">return context.basename;</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">get future() {</span><span class="s2">\n      </span><span class="s1">return {</span><span class="s2">\n        </span><span class="s1">unstable_middleware: false,</span><span class="s2">\n        </span><span class="s1">...opts?.future</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">get state() {</span><span class="s2">\n      </span><span class="s1">return {</span><span class="s2">\n        </span><span class="s1">historyAction: </span><span class="s2">\&quot;</span><span class="s1">POP</span><span class="s2">\&quot; </span><span class="s1">/* Pop */,</span><span class="s2">\n        </span><span class="s1">location: context.location,</span><span class="s2">\n        </span><span class="s1">matches,</span><span class="s2">\n        </span><span class="s1">loaderData: context.loaderData,</span><span class="s2">\n        </span><span class="s1">actionData: context.actionData,</span><span class="s2">\n        </span><span class="s1">errors: context.errors,</span><span class="s2">\n        </span><span class="s1">initialized: true,</span><span class="s2">\n        </span><span class="s1">navigation: IDLE_NAVIGATION,</span><span class="s2">\n        </span><span class="s1">restoreScrollPosition: null,</span><span class="s2">\n        </span><span class="s1">preventScrollReset: false,</span><span class="s2">\n        </span><span class="s1">revalidation: </span><span class="s2">\&quot;</span><span class="s1">idle</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        </span><span class="s1">fetchers: /* @__PURE__ */ new Map(),</span><span class="s2">\n        </span><span class="s1">blockers: /* @__PURE__ */ new Map()</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">get routes() {</span><span class="s2">\n      </span><span class="s1">return dataRoutes;</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">get window() {</span><span class="s2">\n      </span><span class="s1">return void 0;</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">initialize() {</span><span class="s2">\n      </span><span class="s1">throw msg(</span><span class="s2">\&quot;</span><span class="s1">initialize</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">subscribe() {</span><span class="s2">\n      </span><span class="s1">throw msg(</span><span class="s2">\&quot;</span><span class="s1">subscribe</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">enableScrollRestoration() {</span><span class="s2">\n      </span><span class="s1">throw msg(</span><span class="s2">\&quot;</span><span class="s1">enableScrollRestoration</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">navigate() {</span><span class="s2">\n      </span><span class="s1">throw msg(</span><span class="s2">\&quot;</span><span class="s1">navigate</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">fetch() {</span><span class="s2">\n      </span><span class="s1">throw msg(</span><span class="s2">\&quot;</span><span class="s1">fetch</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">revalidate() {</span><span class="s2">\n      </span><span class="s1">throw msg(</span><span class="s2">\&quot;</span><span class="s1">revalidate</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">createHref,</span><span class="s2">\n    </span><span class="s1">encodeLocation,</span><span class="s2">\n    </span><span class="s1">getFetcher() {</span><span class="s2">\n      </span><span class="s1">return IDLE_FETCHER;</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">deleteFetcher() {</span><span class="s2">\n      </span><span class="s1">throw msg(</span><span class="s2">\&quot;</span><span class="s1">deleteFetcher</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">dispose() {</span><span class="s2">\n      </span><span class="s1">throw msg(</span><span class="s2">\&quot;</span><span class="s1">dispose</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">getBlocker() {</span><span class="s2">\n      </span><span class="s1">return IDLE_BLOCKER;</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">deleteBlocker() {</span><span class="s2">\n      </span><span class="s1">throw msg(</span><span class="s2">\&quot;</span><span class="s1">deleteBlocker</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">patchRoutes() {</span><span class="s2">\n      </span><span class="s1">throw msg(</span><span class="s2">\&quot;</span><span class="s1">patchRoutes</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">_internalFetchControllers: /* @__PURE__ */ new Map(),</span><span class="s2">\n    </span><span class="s1">_internalSetRoutes() {</span><span class="s2">\n      </span><span class="s1">throw msg(</span><span class="s2">\&quot;</span><span class="s1">_internalSetRoutes</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createHref(to) {</span><span class="s2">\n  </span><span class="s1">return typeof to === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">? to : createPath(to);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function encodeLocation(to) {</span><span class="s2">\n  </span><span class="s1">let href2 = typeof to === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">? to : createPath(to);</span><span class="s2">\n  </span><span class="s1">href2 = href2.replace(/ $/, </span><span class="s2">\&quot;</span><span class="s1">%20</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let encoded = ABSOLUTE_URL_REGEX3.test(href2) ? new URL(href2) : new URL(href2, </span><span class="s2">\&quot;</span><span class="s1">http://localhost</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">pathname: encoded.pathname,</span><span class="s2">\n    </span><span class="s1">search: encoded.search,</span><span class="s2">\n    </span><span class="s1">hash: encoded.hash</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var ABSOLUTE_URL_REGEX3 = /^(?:[a-z][a-z0-9+.-]*:|</span><span class="s2">\\</span><span class="s1">/</span><span class="s2">\\</span><span class="s1">/)/i;</span><span class="s2">\n</span><span class="s1">var ESCAPE_LOOKUP2 = {</span><span class="s2">\n  \&quot;</span><span class="s1">&amp;</span><span class="s2">\&quot;</span><span class="s1">: </span><span class="s2">\&quot;\\\\</span><span class="s1">u0026</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">&gt;</span><span class="s2">\&quot;</span><span class="s1">: </span><span class="s2">\&quot;\\\\</span><span class="s1">u003e</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">&lt;</span><span class="s2">\&quot;</span><span class="s1">: </span><span class="s2">\&quot;\\\\</span><span class="s1">u003c</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;\\</span><span class="s1">u2028</span><span class="s2">\&quot;</span><span class="s1">: </span><span class="s2">\&quot;\\\\</span><span class="s1">u2028</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;\\</span><span class="s1">u2029</span><span class="s2">\&quot;</span><span class="s1">: </span><span class="s2">\&quot;\\\\</span><span class="s1">u2029</span><span class="s2">\&quot;\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">var ESCAPE_REGEX2 = /[&amp;&gt;&lt;</span><span class="s2">\\</span><span class="s1">u2028</span><span class="s2">\\</span><span class="s1">u2029]/g;</span><span class="s2">\n</span><span class="s1">function htmlEscape(str) {</span><span class="s2">\n  </span><span class="s1">return str.replace(ESCAPE_REGEX2, (match) =&gt; ESCAPE_LOOKUP2[match]);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/dom/ssr/server.tsx</span><span class="s2">\n</span><span class="s1">import * as React12 from </span><span class="s2">\&quot;</span><span class="s1">react</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">function ServerRouter({</span><span class="s2">\n  </span><span class="s1">context,</span><span class="s2">\n  </span><span class="s1">url,</span><span class="s2">\n  </span><span class="s1">nonce</span><span class="s2">\n</span><span class="s1">}) {</span><span class="s2">\n  </span><span class="s1">if (typeof url === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">url = new URL(url);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let { manifest, routeModules, criticalCss, serverHandoffString } = context;</span><span class="s2">\n  </span><span class="s1">let routes = createServerRoutes(</span><span class="s2">\n    </span><span class="s1">manifest.routes,</span><span class="s2">\n    </span><span class="s1">routeModules,</span><span class="s2">\n    </span><span class="s1">context.future,</span><span class="s2">\n    </span><span class="s1">context.isSpaMode</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">context.staticHandlerContext.loaderData = {</span><span class="s2">\n    </span><span class="s1">...context.staticHandlerContext.loaderData</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">for (let match of context.staticHandlerContext.matches) {</span><span class="s2">\n    </span><span class="s1">let routeId = match.route.id;</span><span class="s2">\n    </span><span class="s1">let route = routeModules[routeId];</span><span class="s2">\n    </span><span class="s1">let manifestRoute = context.manifest.routes[routeId];</span><span class="s2">\n    </span><span class="s1">if (route &amp;&amp; manifestRoute &amp;&amp; shouldHydrateRouteLoader(</span><span class="s2">\n      </span><span class="s1">routeId,</span><span class="s2">\n      </span><span class="s1">route.clientLoader,</span><span class="s2">\n      </span><span class="s1">manifestRoute.hasLoader,</span><span class="s2">\n      </span><span class="s1">context.isSpaMode</span><span class="s2">\n    </span><span class="s1">) &amp;&amp; (route.HydrateFallback || !manifestRoute.hasLoader)) {</span><span class="s2">\n      </span><span class="s1">delete context.staticHandlerContext.loaderData[routeId];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let router = createStaticRouter(routes, context.staticHandlerContext);</span><span class="s2">\n  </span><span class="s1">return /* @__PURE__ */ React12.createElement(React12.Fragment, null, /* @__PURE__ */ React12.createElement(</span><span class="s2">\n    </span><span class="s1">FrameworkContext.Provider,</span><span class="s2">\n    </span><span class="s1">{</span><span class="s2">\n      </span><span class="s1">value: {</span><span class="s2">\n        </span><span class="s1">manifest,</span><span class="s2">\n        </span><span class="s1">routeModules,</span><span class="s2">\n        </span><span class="s1">criticalCss,</span><span class="s2">\n        </span><span class="s1">serverHandoffString,</span><span class="s2">\n        </span><span class="s1">future: context.future,</span><span class="s2">\n        </span><span class="s1">ssr: context.ssr,</span><span class="s2">\n        </span><span class="s1">isSpaMode: context.isSpaMode,</span><span class="s2">\n        </span><span class="s1">routeDiscovery: context.routeDiscovery,</span><span class="s2">\n        </span><span class="s1">serializeError: context.serializeError,</span><span class="s2">\n        </span><span class="s1">renderMeta: context.renderMeta</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">/* @__PURE__ */ React12.createElement(RemixErrorBoundary, { location: router.state.location }, /* @__PURE__ */ React12.createElement(</span><span class="s2">\n      </span><span class="s1">StaticRouterProvider,</span><span class="s2">\n      </span><span class="s1">{</span><span class="s2">\n        </span><span class="s1">router,</span><span class="s2">\n        </span><span class="s1">context: context.staticHandlerContext,</span><span class="s2">\n        </span><span class="s1">hydrate: false</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">))</span><span class="s2">\n  </span><span class="s1">), context.serverHandoffStream ? /* @__PURE__ */ React12.createElement(React12.Suspense, null, /* @__PURE__ */ React12.createElement(</span><span class="s2">\n    </span><span class="s1">StreamTransfer,</span><span class="s2">\n    </span><span class="s1">{</span><span class="s2">\n      </span><span class="s1">context,</span><span class="s2">\n      </span><span class="s1">identifier: 0,</span><span class="s2">\n      </span><span class="s1">reader: context.serverHandoffStream.getReader(),</span><span class="s2">\n      </span><span class="s1">textDecoder: new TextDecoder(),</span><span class="s2">\n      </span><span class="s1">nonce</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">)) : null);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/dom/ssr/routes-test-stub.tsx</span><span class="s2">\n</span><span class="s1">import * as React13 from </span><span class="s2">\&quot;</span><span class="s1">react</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">function createRoutesStub(routes, unstable_getContext) {</span><span class="s2">\n  </span><span class="s1">return function RoutesTestStub({</span><span class="s2">\n    </span><span class="s1">initialEntries,</span><span class="s2">\n    </span><span class="s1">initialIndex,</span><span class="s2">\n    </span><span class="s1">hydrationData,</span><span class="s2">\n    </span><span class="s1">future</span><span class="s2">\n  </span><span class="s1">}) {</span><span class="s2">\n    </span><span class="s1">let routerRef = React13.useRef();</span><span class="s2">\n    </span><span class="s1">let remixContextRef = React13.useRef();</span><span class="s2">\n    </span><span class="s1">if (routerRef.current == null) {</span><span class="s2">\n      </span><span class="s1">remixContextRef.current = {</span><span class="s2">\n        </span><span class="s1">future: {</span><span class="s2">\n          </span><span class="s1">unstable_subResourceIntegrity: future?.unstable_subResourceIntegrity === true,</span><span class="s2">\n          </span><span class="s1">unstable_middleware: future?.unstable_middleware === true</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">manifest: {</span><span class="s2">\n          </span><span class="s1">routes: {},</span><span class="s2">\n          </span><span class="s1">entry: { imports: [], module: </span><span class="s2">\&quot;\&quot; </span><span class="s1">},</span><span class="s2">\n          </span><span class="s1">url: </span><span class="s2">\&quot;\&quot;</span><span class="s1">,</span><span class="s2">\n          </span><span class="s1">version: </span><span class="s2">\&quot;\&quot;\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">routeModules: {},</span><span class="s2">\n        </span><span class="s1">ssr: false,</span><span class="s2">\n        </span><span class="s1">isSpaMode: false,</span><span class="s2">\n        </span><span class="s1">routeDiscovery: { mode: </span><span class="s2">\&quot;</span><span class="s1">lazy</span><span class="s2">\&quot;</span><span class="s1">, manifestPath: </span><span class="s2">\&quot;</span><span class="s1">/__manifest</span><span class="s2">\&quot; </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">let patched = processRoutes(</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error `StubRouteObject` is stricter about `loader`/`action`</span><span class="s2">\n        </span><span class="s1">// types compared to `AgnosticRouteObject`</span><span class="s2">\n        </span><span class="s1">convertRoutesToDataRoutes(routes, (r) =&gt; r),</span><span class="s2">\n        </span><span class="s1">remixContextRef.current.manifest,</span><span class="s2">\n        </span><span class="s1">remixContextRef.current.routeModules</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">routerRef.current = createMemoryRouter(patched, {</span><span class="s2">\n        </span><span class="s1">unstable_getContext,</span><span class="s2">\n        </span><span class="s1">initialEntries,</span><span class="s2">\n        </span><span class="s1">initialIndex,</span><span class="s2">\n        </span><span class="s1">hydrationData</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return /* @__PURE__ */ React13.createElement(FrameworkContext.Provider, { value: remixContextRef.current }, /* @__PURE__ */ React13.createElement(RouterProvider, { router: routerRef.current }));</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function withComponentProps(Component4) {</span><span class="s2">\n  </span><span class="s1">return function Wrapped() {</span><span class="s2">\n    </span><span class="s1">return React13.createElement(Component4, {</span><span class="s2">\n      </span><span class="s1">params: useParams(),</span><span class="s2">\n      </span><span class="s1">loaderData: useLoaderData(),</span><span class="s2">\n      </span><span class="s1">actionData: useActionData(),</span><span class="s2">\n      </span><span class="s1">matches: useMatches()</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function withHydrateFallbackProps(HydrateFallback) {</span><span class="s2">\n  </span><span class="s1">return function Wrapped() {</span><span class="s2">\n    </span><span class="s1">const props = {</span><span class="s2">\n      </span><span class="s1">params: useParams(),</span><span class="s2">\n      </span><span class="s1">loaderData: useLoaderData(),</span><span class="s2">\n      </span><span class="s1">actionData: useActionData()</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">return React13.createElement(HydrateFallback, props);</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function withErrorBoundaryProps(ErrorBoundary) {</span><span class="s2">\n  </span><span class="s1">return function Wrapped() {</span><span class="s2">\n    </span><span class="s1">const props = {</span><span class="s2">\n      </span><span class="s1">params: useParams(),</span><span class="s2">\n      </span><span class="s1">loaderData: useLoaderData(),</span><span class="s2">\n      </span><span class="s1">actionData: useActionData(),</span><span class="s2">\n      </span><span class="s1">error: useRouteError()</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">return React13.createElement(ErrorBoundary, props);</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function processRoutes(routes, manifest, routeModules, parentId) {</span><span class="s2">\n  </span><span class="s1">return routes.map((route) =&gt; {</span><span class="s2">\n    </span><span class="s1">if (!route.id) {</span><span class="s2">\n      </span><span class="s1">throw new Error(</span><span class="s2">\n        \&quot;</span><span class="s1">Expected a route.id in @remix-run/testing processRoutes() function</span><span class="s2">\&quot;\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let newRoute = {</span><span class="s2">\n      </span><span class="s1">id: route.id,</span><span class="s2">\n      </span><span class="s1">path: route.path,</span><span class="s2">\n      </span><span class="s1">index: route.index,</span><span class="s2">\n      </span><span class="s1">Component: route.Component ? withComponentProps(route.Component) : void 0,</span><span class="s2">\n      </span><span class="s1">HydrateFallback: route.HydrateFallback ? withHydrateFallbackProps(route.HydrateFallback) : void 0,</span><span class="s2">\n      </span><span class="s1">ErrorBoundary: route.ErrorBoundary ? withErrorBoundaryProps(route.ErrorBoundary) : void 0,</span><span class="s2">\n      </span><span class="s1">action: route.action,</span><span class="s2">\n      </span><span class="s1">loader: route.loader,</span><span class="s2">\n      </span><span class="s1">handle: route.handle,</span><span class="s2">\n      </span><span class="s1">shouldRevalidate: route.shouldRevalidate</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">let entryRoute = {</span><span class="s2">\n      </span><span class="s1">id: route.id,</span><span class="s2">\n      </span><span class="s1">path: route.path,</span><span class="s2">\n      </span><span class="s1">index: route.index,</span><span class="s2">\n      </span><span class="s1">parentId,</span><span class="s2">\n      </span><span class="s1">hasAction: route.action != null,</span><span class="s2">\n      </span><span class="s1">hasLoader: route.loader != null,</span><span class="s2">\n      </span><span class="s1">// When testing routes, you should be stubbing loader/action/middleware,</span><span class="s2">\n      </span><span class="s1">// not trying to re-implement the full loader/clientLoader/SSR/hydration</span><span class="s2">\n      </span><span class="s1">// flow. That is better tested via E2E tests.</span><span class="s2">\n      </span><span class="s1">hasClientAction: false,</span><span class="s2">\n      </span><span class="s1">hasClientLoader: false,</span><span class="s2">\n      </span><span class="s1">hasClientMiddleware: false,</span><span class="s2">\n      </span><span class="s1">hasErrorBoundary: route.ErrorBoundary != null,</span><span class="s2">\n      </span><span class="s1">// any need for these?</span><span class="s2">\n      </span><span class="s1">module: </span><span class="s2">\&quot;</span><span class="s1">build/stub-path-to-module.js</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">clientActionModule: void 0,</span><span class="s2">\n      </span><span class="s1">clientLoaderModule: void 0,</span><span class="s2">\n      </span><span class="s1">clientMiddlewareModule: void 0,</span><span class="s2">\n      </span><span class="s1">hydrateFallbackModule: void 0</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">manifest.routes[newRoute.id] = entryRoute;</span><span class="s2">\n    </span><span class="s1">routeModules[route.id] = {</span><span class="s2">\n      </span><span class="s1">default: newRoute.Component || Outlet,</span><span class="s2">\n      </span><span class="s1">ErrorBoundary: newRoute.ErrorBoundary || void 0,</span><span class="s2">\n      </span><span class="s1">handle: route.handle,</span><span class="s2">\n      </span><span class="s1">links: route.links,</span><span class="s2">\n      </span><span class="s1">meta: route.meta,</span><span class="s2">\n      </span><span class="s1">shouldRevalidate: route.shouldRevalidate</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">if (route.children) {</span><span class="s2">\n      </span><span class="s1">newRoute.children = processRoutes(</span><span class="s2">\n        </span><span class="s1">route.children,</span><span class="s2">\n        </span><span class="s1">manifest,</span><span class="s2">\n        </span><span class="s1">routeModules,</span><span class="s2">\n        </span><span class="s1">newRoute.id</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return newRoute;</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/server-runtime/cookies.ts</span><span class="s2">\n</span><span class="s1">import { parse, serialize } from </span><span class="s2">\&quot;</span><span class="s1">cookie</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n</span><span class="s1">// lib/server-runtime/crypto.ts</span><span class="s2">\n</span><span class="s1">var encoder = /* @__PURE__ */ new TextEncoder();</span><span class="s2">\n</span><span class="s1">var sign = async (value, secret) =&gt; {</span><span class="s2">\n  </span><span class="s1">let data2 = encoder.encode(value);</span><span class="s2">\n  </span><span class="s1">let key = await createKey2(secret, [</span><span class="s2">\&quot;</span><span class="s1">sign</span><span class="s2">\&quot;</span><span class="s1">]);</span><span class="s2">\n  </span><span class="s1">let signature = await crypto.subtle.sign(</span><span class="s2">\&quot;</span><span class="s1">HMAC</span><span class="s2">\&quot;</span><span class="s1">, key, data2);</span><span class="s2">\n  </span><span class="s1">let hash = btoa(String.fromCharCode(...new Uint8Array(signature))).replace(</span><span class="s2">\n    </span><span class="s1">/=+$/,</span><span class="s2">\n    \&quot;\&quot;\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">return value + </span><span class="s2">\&quot;</span><span class="s1">.</span><span class="s2">\&quot; </span><span class="s1">+ hash;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">var unsign = async (cookie, secret) =&gt; {</span><span class="s2">\n  </span><span class="s1">let index = cookie.lastIndexOf(</span><span class="s2">\&quot;</span><span class="s1">.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let value = cookie.slice(0, index);</span><span class="s2">\n  </span><span class="s1">let hash = cookie.slice(index + 1);</span><span class="s2">\n  </span><span class="s1">let data2 = encoder.encode(value);</span><span class="s2">\n  </span><span class="s1">let key = await createKey2(secret, [</span><span class="s2">\&quot;</span><span class="s1">verify</span><span class="s2">\&quot;</span><span class="s1">]);</span><span class="s2">\n  </span><span class="s1">let signature = byteStringToUint8Array(atob(hash));</span><span class="s2">\n  </span><span class="s1">let valid = await crypto.subtle.verify(</span><span class="s2">\&quot;</span><span class="s1">HMAC</span><span class="s2">\&quot;</span><span class="s1">, key, signature, data2);</span><span class="s2">\n  </span><span class="s1">return valid ? value : false;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">var createKey2 = async (secret, usages) =&gt; crypto.subtle.importKey(</span><span class="s2">\n  \&quot;</span><span class="s1">raw</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">encoder.encode(secret),</span><span class="s2">\n  </span><span class="s1">{ name: </span><span class="s2">\&quot;</span><span class="s1">HMAC</span><span class="s2">\&quot;</span><span class="s1">, hash: </span><span class="s2">\&quot;</span><span class="s1">SHA-256</span><span class="s2">\&quot; </span><span class="s1">},</span><span class="s2">\n  </span><span class="s1">false,</span><span class="s2">\n  </span><span class="s1">usages</span><span class="s2">\n</span><span class="s1">);</span><span class="s2">\n</span><span class="s1">function byteStringToUint8Array(byteString) {</span><span class="s2">\n  </span><span class="s1">let array = new Uint8Array(byteString.length);</span><span class="s2">\n  </span><span class="s1">for (let i = 0; i &lt; byteString.length; i++) {</span><span class="s2">\n    </span><span class="s1">array[i] = byteString.charCodeAt(i);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return array;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/server-runtime/cookies.ts</span><span class="s2">\n</span><span class="s1">var createCookie = (name, cookieOptions = {}) =&gt; {</span><span class="s2">\n  </span><span class="s1">let { secrets = [], ...options } = {</span><span class="s2">\n    </span><span class="s1">path: </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">sameSite: </span><span class="s2">\&quot;</span><span class="s1">lax</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">...cookieOptions</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">warnOnceAboutExpiresCookie(name, options.expires);</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">get name() {</span><span class="s2">\n      </span><span class="s1">return name;</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">get isSigned() {</span><span class="s2">\n      </span><span class="s1">return secrets.length &gt; 0;</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">get expires() {</span><span class="s2">\n      </span><span class="s1">return typeof options.maxAge !== </span><span class="s2">\&quot;</span><span class="s1">undefined</span><span class="s2">\&quot; </span><span class="s1">? new Date(Date.now() + options.maxAge * 1e3) : options.expires;</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">async parse(cookieHeader, parseOptions) {</span><span class="s2">\n      </span><span class="s1">if (!cookieHeader) return null;</span><span class="s2">\n      </span><span class="s1">let cookies = parse(cookieHeader, { ...options, ...parseOptions });</span><span class="s2">\n      </span><span class="s1">if (name in cookies) {</span><span class="s2">\n        </span><span class="s1">let value = cookies[name];</span><span class="s2">\n        </span><span class="s1">if (typeof value === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; value !== </span><span class="s2">\&quot;\&quot;</span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">let decoded = await decodeCookieValue(value, secrets);</span><span class="s2">\n          </span><span class="s1">return decoded;</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">return </span><span class="s2">\&quot;\&quot;</span><span class="s1">;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">return null;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">async serialize(value, serializeOptions) {</span><span class="s2">\n      </span><span class="s1">return serialize(</span><span class="s2">\n        </span><span class="s1">name,</span><span class="s2">\n        </span><span class="s1">value === </span><span class="s2">\&quot;\&quot; </span><span class="s1">? </span><span class="s2">\&quot;\&quot; </span><span class="s1">: await encodeCookieValue(value, secrets),</span><span class="s2">\n        </span><span class="s1">{</span><span class="s2">\n          </span><span class="s1">...options,</span><span class="s2">\n          </span><span class="s1">...serializeOptions</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">var isCookie = (object) =&gt; {</span><span class="s2">\n  </span><span class="s1">return object != null &amp;&amp; typeof object.name === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; typeof object.isSigned === </span><span class="s2">\&quot;</span><span class="s1">boolean</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; typeof object.parse === </span><span class="s2">\&quot;</span><span class="s1">function</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; typeof object.serialize === </span><span class="s2">\&quot;</span><span class="s1">function</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">async function encodeCookieValue(value, secrets) {</span><span class="s2">\n  </span><span class="s1">let encoded = encodeData(value);</span><span class="s2">\n  </span><span class="s1">if (secrets.length &gt; 0) {</span><span class="s2">\n    </span><span class="s1">encoded = await sign(encoded, secrets[0]);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return encoded;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">async function decodeCookieValue(value, secrets) {</span><span class="s2">\n  </span><span class="s1">if (secrets.length &gt; 0) {</span><span class="s2">\n    </span><span class="s1">for (let secret of secrets) {</span><span class="s2">\n      </span><span class="s1">let unsignedValue = await unsign(value, secret);</span><span class="s2">\n      </span><span class="s1">if (unsignedValue !== false) {</span><span class="s2">\n        </span><span class="s1">return decodeData(unsignedValue);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return null;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return decodeData(value);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function encodeData(value) {</span><span class="s2">\n  </span><span class="s1">return btoa(myUnescape(encodeURIComponent(JSON.stringify(value))));</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function decodeData(value) {</span><span class="s2">\n  </span><span class="s1">try {</span><span class="s2">\n    </span><span class="s1">return JSON.parse(decodeURIComponent(myEscape(atob(value))));</span><span class="s2">\n  </span><span class="s1">} catch (error) {</span><span class="s2">\n    </span><span class="s1">return {};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function myEscape(value) {</span><span class="s2">\n  </span><span class="s1">let str = value.toString();</span><span class="s2">\n  </span><span class="s1">let result = </span><span class="s2">\&quot;\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">let index = 0;</span><span class="s2">\n  </span><span class="s1">let chr, code;</span><span class="s2">\n  </span><span class="s1">while (index &lt; str.length) {</span><span class="s2">\n    </span><span class="s1">chr = str.charAt(index++);</span><span class="s2">\n    </span><span class="s1">if (/[</span><span class="s2">\\</span><span class="s1">w*+</span><span class="s2">\\</span><span class="s1">-./@]/.exec(chr)) {</span><span class="s2">\n      </span><span class="s1">result += chr;</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">code = chr.charCodeAt(0);</span><span class="s2">\n      </span><span class="s1">if (code &lt; 256) {</span><span class="s2">\n        </span><span class="s1">result += </span><span class="s2">\&quot;</span><span class="s1">%</span><span class="s2">\&quot; </span><span class="s1">+ hex(code, 2);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">result += </span><span class="s2">\&quot;</span><span class="s1">%u</span><span class="s2">\&quot; </span><span class="s1">+ hex(code, 4).toUpperCase();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return result;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function hex(code, length) {</span><span class="s2">\n  </span><span class="s1">let result = code.toString(16);</span><span class="s2">\n  </span><span class="s1">while (result.length &lt; length) result = </span><span class="s2">\&quot;</span><span class="s1">0</span><span class="s2">\&quot; </span><span class="s1">+ result;</span><span class="s2">\n  </span><span class="s1">return result;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function myUnescape(value) {</span><span class="s2">\n  </span><span class="s1">let str = value.toString();</span><span class="s2">\n  </span><span class="s1">let result = </span><span class="s2">\&quot;\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">let index = 0;</span><span class="s2">\n  </span><span class="s1">let chr, part;</span><span class="s2">\n  </span><span class="s1">while (index &lt; str.length) {</span><span class="s2">\n    </span><span class="s1">chr = str.charAt(index++);</span><span class="s2">\n    </span><span class="s1">if (chr === </span><span class="s2">\&quot;</span><span class="s1">%</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">if (str.charAt(index) === </span><span class="s2">\&quot;</span><span class="s1">u</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">part = str.slice(index + 1, index + 5);</span><span class="s2">\n        </span><span class="s1">if (/^[</span><span class="s2">\\</span><span class="s1">da-f]{4}$/i.exec(part)) {</span><span class="s2">\n          </span><span class="s1">result += String.fromCharCode(parseInt(part, 16));</span><span class="s2">\n          </span><span class="s1">index += 5;</span><span class="s2">\n          </span><span class="s1">continue;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">part = str.slice(index, index + 2);</span><span class="s2">\n        </span><span class="s1">if (/^[</span><span class="s2">\\</span><span class="s1">da-f]{2}$/i.exec(part)) {</span><span class="s2">\n          </span><span class="s1">result += String.fromCharCode(parseInt(part, 16));</span><span class="s2">\n          </span><span class="s1">index += 2;</span><span class="s2">\n          </span><span class="s1">continue;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">result += chr;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return result;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function warnOnceAboutExpiresCookie(name, expires) {</span><span class="s2">\n  </span><span class="s1">warnOnce(</span><span class="s2">\n    </span><span class="s1">!expires,</span><span class="s2">\n    </span><span class="s1">`The </span><span class="s2">\&quot;</span><span class="s1">${name}</span><span class="s2">\&quot; </span><span class="s1">cookie has an </span><span class="s2">\&quot;</span><span class="s1">expires</span><span class="s2">\&quot; </span><span class="s1">property set. This will cause the expires value to not be updated when the session is committed. Instead, you should set the expires value when serializing the cookie. You can use </span><span class="s2">\\</span><span class="s1">`commitSession(session, { expires })</span><span class="s2">\\</span><span class="s1">` if using a session storage object, or </span><span class="s2">\\</span><span class="s1">`cookie.serialize(</span><span class="s2">\&quot;</span><span class="s1">value</span><span class="s2">\&quot;</span><span class="s1">, { expires })</span><span class="s2">\\</span><span class="s1">` if you're using the cookie directly.`</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/server-runtime/entry.ts</span><span class="s2">\n</span><span class="s1">function createEntryRouteModules(manifest) {</span><span class="s2">\n  </span><span class="s1">return Object.keys(manifest).reduce((memo2, routeId) =&gt; {</span><span class="s2">\n    </span><span class="s1">let route = manifest[routeId];</span><span class="s2">\n    </span><span class="s1">if (route) {</span><span class="s2">\n      </span><span class="s1">memo2[routeId] = route.module;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return memo2;</span><span class="s2">\n  </span><span class="s1">}, {});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/server-runtime/mode.ts</span><span class="s2">\n</span><span class="s1">var ServerMode = /* @__PURE__ */ ((ServerMode2) =&gt; {</span><span class="s2">\n  </span><span class="s1">ServerMode2[</span><span class="s2">\&quot;</span><span class="s1">Development</span><span class="s2">\&quot;</span><span class="s1">] = </span><span class="s2">\&quot;</span><span class="s1">development</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">ServerMode2[</span><span class="s2">\&quot;</span><span class="s1">Production</span><span class="s2">\&quot;</span><span class="s1">] = </span><span class="s2">\&quot;</span><span class="s1">production</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">ServerMode2[</span><span class="s2">\&quot;</span><span class="s1">Test</span><span class="s2">\&quot;</span><span class="s1">] = </span><span class="s2">\&quot;</span><span class="s1">test</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">return ServerMode2;</span><span class="s2">\n</span><span class="s1">})(ServerMode || {});</span><span class="s2">\n</span><span class="s1">function isServerMode(value) {</span><span class="s2">\n  </span><span class="s1">return value === </span><span class="s2">\&quot;</span><span class="s1">development</span><span class="s2">\&quot; </span><span class="s1">/* Development */ || value === </span><span class="s2">\&quot;</span><span class="s1">production</span><span class="s2">\&quot; </span><span class="s1">/* Production */ || value === </span><span class="s2">\&quot;</span><span class="s1">test</span><span class="s2">\&quot; </span><span class="s1">/* Test */;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/server-runtime/errors.ts</span><span class="s2">\n</span><span class="s1">function sanitizeError(error, serverMode) {</span><span class="s2">\n  </span><span class="s1">if (error instanceof Error &amp;&amp; serverMode !== </span><span class="s2">\&quot;</span><span class="s1">development</span><span class="s2">\&quot; </span><span class="s1">/* Development */) {</span><span class="s2">\n    </span><span class="s1">let sanitized = new Error(</span><span class="s2">\&quot;</span><span class="s1">Unexpected Server Error</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">sanitized.stack = void 0;</span><span class="s2">\n    </span><span class="s1">return sanitized;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return error;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function sanitizeErrors(errors, serverMode) {</span><span class="s2">\n  </span><span class="s1">return Object.entries(errors).reduce((acc, [routeId, error]) =&gt; {</span><span class="s2">\n    </span><span class="s1">return Object.assign(acc, { [routeId]: sanitizeError(error, serverMode) });</span><span class="s2">\n  </span><span class="s1">}, {});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function serializeError(error, serverMode) {</span><span class="s2">\n  </span><span class="s1">let sanitized = sanitizeError(error, serverMode);</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">message: sanitized.message,</span><span class="s2">\n    </span><span class="s1">stack: sanitized.stack</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function serializeErrors2(errors, serverMode) {</span><span class="s2">\n  </span><span class="s1">if (!errors) return null;</span><span class="s2">\n  </span><span class="s1">let entries = Object.entries(errors);</span><span class="s2">\n  </span><span class="s1">let serialized = {};</span><span class="s2">\n  </span><span class="s1">for (let [key, val] of entries) {</span><span class="s2">\n    </span><span class="s1">if (isRouteErrorResponse(val)) {</span><span class="s2">\n      </span><span class="s1">serialized[key] = { ...val, __type: </span><span class="s2">\&quot;</span><span class="s1">RouteErrorResponse</span><span class="s2">\&quot; </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">} else if (val instanceof Error) {</span><span class="s2">\n      </span><span class="s1">let sanitized = sanitizeError(val, serverMode);</span><span class="s2">\n      </span><span class="s1">serialized[key] = {</span><span class="s2">\n        </span><span class="s1">message: sanitized.message,</span><span class="s2">\n        </span><span class="s1">stack: sanitized.stack,</span><span class="s2">\n        </span><span class="s1">__type: </span><span class="s2">\&quot;</span><span class="s1">Error</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        </span><span class="s1">// If this is a subclass (i.e., ReferenceError), send up the type so we</span><span class="s2">\n        </span><span class="s1">// can re-create the same type during hydration.  This will only apply</span><span class="s2">\n        </span><span class="s1">// in dev mode since all production errors are sanitized to normal</span><span class="s2">\n        </span><span class="s1">// Error instances</span><span class="s2">\n        </span><span class="s1">...sanitized.name !== </span><span class="s2">\&quot;</span><span class="s1">Error</span><span class="s2">\&quot; </span><span class="s1">? {</span><span class="s2">\n          </span><span class="s1">__subType: sanitized.name</span><span class="s2">\n        </span><span class="s1">} : {}</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">serialized[key] = val;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return serialized;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/server-runtime/routeMatching.ts</span><span class="s2">\n</span><span class="s1">function matchServerRoutes(routes, pathname, basename) {</span><span class="s2">\n  </span><span class="s1">let matches = matchRoutes(</span><span class="s2">\n    </span><span class="s1">routes,</span><span class="s2">\n    </span><span class="s1">pathname,</span><span class="s2">\n    </span><span class="s1">basename</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">if (!matches) return null;</span><span class="s2">\n  </span><span class="s1">return matches.map((match) =&gt; ({</span><span class="s2">\n    </span><span class="s1">params: match.params,</span><span class="s2">\n    </span><span class="s1">pathname: match.pathname,</span><span class="s2">\n    </span><span class="s1">route: match.route</span><span class="s2">\n  </span><span class="s1">}));</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/server-runtime/data.ts</span><span class="s2">\n</span><span class="s1">async function callRouteHandler(handler, args) {</span><span class="s2">\n  </span><span class="s1">let result = await handler({</span><span class="s2">\n    </span><span class="s1">request: stripRoutesParam(stripIndexParam2(args.request)),</span><span class="s2">\n    </span><span class="s1">params: args.params,</span><span class="s2">\n    </span><span class="s1">context: args.context</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">if (isDataWithResponseInit(result) &amp;&amp; result.init &amp;&amp; result.init.status &amp;&amp; isRedirectStatusCode(result.init.status)) {</span><span class="s2">\n    </span><span class="s1">throw new Response(null, result.init);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return result;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function stripIndexParam2(request) {</span><span class="s2">\n  </span><span class="s1">let url = new URL(request.url);</span><span class="s2">\n  </span><span class="s1">let indexValues = url.searchParams.getAll(</span><span class="s2">\&quot;</span><span class="s1">index</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">url.searchParams.delete(</span><span class="s2">\&quot;</span><span class="s1">index</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let indexValuesToKeep = [];</span><span class="s2">\n  </span><span class="s1">for (let indexValue of indexValues) {</span><span class="s2">\n    </span><span class="s1">if (indexValue) {</span><span class="s2">\n      </span><span class="s1">indexValuesToKeep.push(indexValue);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">for (let toKeep of indexValuesToKeep) {</span><span class="s2">\n    </span><span class="s1">url.searchParams.append(</span><span class="s2">\&quot;</span><span class="s1">index</span><span class="s2">\&quot;</span><span class="s1">, toKeep);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let init = {</span><span class="s2">\n    </span><span class="s1">method: request.method,</span><span class="s2">\n    </span><span class="s1">body: request.body,</span><span class="s2">\n    </span><span class="s1">headers: request.headers,</span><span class="s2">\n    </span><span class="s1">signal: request.signal</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">if (init.body) {</span><span class="s2">\n    </span><span class="s1">init.duplex = </span><span class="s2">\&quot;</span><span class="s1">half</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return new Request(url.href, init);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function stripRoutesParam(request) {</span><span class="s2">\n  </span><span class="s1">let url = new URL(request.url);</span><span class="s2">\n  </span><span class="s1">url.searchParams.delete(</span><span class="s2">\&quot;</span><span class="s1">_routes</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let init = {</span><span class="s2">\n    </span><span class="s1">method: request.method,</span><span class="s2">\n    </span><span class="s1">body: request.body,</span><span class="s2">\n    </span><span class="s1">headers: request.headers,</span><span class="s2">\n    </span><span class="s1">signal: request.signal</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">if (init.body) {</span><span class="s2">\n    </span><span class="s1">init.duplex = </span><span class="s2">\&quot;</span><span class="s1">half</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return new Request(url.href, init);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/server-runtime/invariant.ts</span><span class="s2">\n</span><span class="s1">function invariant3(value, message) {</span><span class="s2">\n  </span><span class="s1">if (value === false || value === null || typeof value === </span><span class="s2">\&quot;</span><span class="s1">undefined</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">console.error(</span><span class="s2">\n      \&quot;</span><span class="s1">The following error is a bug in React Router; please open an issue! https://github.com/remix-run/react-router/issues/new/choose</span><span class="s2">\&quot;\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">throw new Error(message);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/server-runtime/dev.ts</span><span class="s2">\n</span><span class="s1">var globalDevServerHooksKey = </span><span class="s2">\&quot;</span><span class="s1">__reactRouterDevServerHooks</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">function setDevServerHooks(devServerHooks) {</span><span class="s2">\n  </span><span class="s1">globalThis[globalDevServerHooksKey] = devServerHooks;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getDevServerHooks() {</span><span class="s2">\n  </span><span class="s1">return globalThis[globalDevServerHooksKey];</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getBuildTimeHeader(request, headerName) {</span><span class="s2">\n  </span><span class="s1">if (typeof process !== </span><span class="s2">\&quot;</span><span class="s1">undefined</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">try {</span><span class="s2">\n      </span><span class="s1">if (process.env?.IS_RR_BUILD_REQUEST === </span><span class="s2">\&quot;</span><span class="s1">yes</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">return request.headers.get(headerName);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} catch (e) {</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return null;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/server-runtime/routes.ts</span><span class="s2">\n</span><span class="s1">function groupRoutesByParentId2(manifest) {</span><span class="s2">\n  </span><span class="s1">let routes = {};</span><span class="s2">\n  </span><span class="s1">Object.values(manifest).forEach((route) =&gt; {</span><span class="s2">\n    </span><span class="s1">if (route) {</span><span class="s2">\n      </span><span class="s1">let parentId = route.parentId || </span><span class="s2">\&quot;\&quot;</span><span class="s1">;</span><span class="s2">\n      </span><span class="s1">if (!routes[parentId]) {</span><span class="s2">\n        </span><span class="s1">routes[parentId] = [];</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">routes[parentId].push(route);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">return routes;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createRoutes(manifest, parentId = </span><span class="s2">\&quot;\&quot;</span><span class="s1">, routesByParentId = groupRoutesByParentId2(manifest)) {</span><span class="s2">\n  </span><span class="s1">return (routesByParentId[parentId] || []).map((route) =&gt; ({</span><span class="s2">\n    </span><span class="s1">...route,</span><span class="s2">\n    </span><span class="s1">children: createRoutes(manifest, route.id, routesByParentId)</span><span class="s2">\n  </span><span class="s1">}));</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createStaticHandlerDataRoutes(manifest, future, parentId = </span><span class="s2">\&quot;\&quot;</span><span class="s1">, routesByParentId = groupRoutesByParentId2(manifest)) {</span><span class="s2">\n  </span><span class="s1">return (routesByParentId[parentId] || []).map((route) =&gt; {</span><span class="s2">\n    </span><span class="s1">let commonRoute = {</span><span class="s2">\n      </span><span class="s1">// Always include root due to default boundaries</span><span class="s2">\n      </span><span class="s1">hasErrorBoundary: route.id === </span><span class="s2">\&quot;</span><span class="s1">root</span><span class="s2">\&quot; </span><span class="s1">|| route.module.ErrorBoundary != null,</span><span class="s2">\n      </span><span class="s1">id: route.id,</span><span class="s2">\n      </span><span class="s1">path: route.path,</span><span class="s2">\n      </span><span class="s1">unstable_middleware: route.module.unstable_middleware,</span><span class="s2">\n      </span><span class="s1">// Need to use RR's version in the param typed here to permit the optional</span><span class="s2">\n      </span><span class="s1">// context even though we know it'll always be provided in remix</span><span class="s2">\n      </span><span class="s1">loader: route.module.loader ? async (args) =&gt; {</span><span class="s2">\n        </span><span class="s1">let preRenderedData = getBuildTimeHeader(</span><span class="s2">\n          </span><span class="s1">args.request,</span><span class="s2">\n          \&quot;</span><span class="s1">X-React-Router-Prerender-Data</span><span class="s2">\&quot;\n        </span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">if (preRenderedData != null) {</span><span class="s2">\n          </span><span class="s1">let encoded = preRenderedData ? decodeURI(preRenderedData) : preRenderedData;</span><span class="s2">\n          </span><span class="s1">invariant3(encoded, </span><span class="s2">\&quot;</span><span class="s1">Missing prerendered data for route</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">let uint8array = new TextEncoder().encode(encoded);</span><span class="s2">\n          </span><span class="s1">let stream = new ReadableStream({</span><span class="s2">\n            </span><span class="s1">start(controller) {</span><span class="s2">\n              </span><span class="s1">controller.enqueue(uint8array);</span><span class="s2">\n              </span><span class="s1">controller.close();</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n          </span><span class="s1">let decoded = await decodeViaTurboStream(stream, global);</span><span class="s2">\n          </span><span class="s1">let data2 = decoded.value;</span><span class="s2">\n          </span><span class="s1">if (data2 &amp;&amp; SingleFetchRedirectSymbol in data2) {</span><span class="s2">\n            </span><span class="s1">let result = data2[SingleFetchRedirectSymbol];</span><span class="s2">\n            </span><span class="s1">let init = { status: result.status };</span><span class="s2">\n            </span><span class="s1">if (result.reload) {</span><span class="s2">\n              </span><span class="s1">throw redirectDocument(result.redirect, init);</span><span class="s2">\n            </span><span class="s1">} else if (result.replace) {</span><span class="s2">\n              </span><span class="s1">throw replace(result.redirect, init);</span><span class="s2">\n            </span><span class="s1">} else {</span><span class="s2">\n              </span><span class="s1">throw redirect(result.redirect, init);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">} else {</span><span class="s2">\n            </span><span class="s1">invariant3(</span><span class="s2">\n              </span><span class="s1">data2 &amp;&amp; route.id in data2,</span><span class="s2">\n              \&quot;</span><span class="s1">Unable to decode prerendered data</span><span class="s2">\&quot;\n            </span><span class="s1">);</span><span class="s2">\n            </span><span class="s1">let result = data2[route.id];</span><span class="s2">\n            </span><span class="s1">invariant3(</span><span class="s2">\n              \&quot;</span><span class="s1">data</span><span class="s2">\&quot; </span><span class="s1">in result,</span><span class="s2">\n              \&quot;</span><span class="s1">Unable to process prerendered data</span><span class="s2">\&quot;\n            </span><span class="s1">);</span><span class="s2">\n            </span><span class="s1">return result.data;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">let val = await callRouteHandler(route.module.loader, args);</span><span class="s2">\n        </span><span class="s1">return val;</span><span class="s2">\n      </span><span class="s1">} : void 0,</span><span class="s2">\n      </span><span class="s1">action: route.module.action ? (args) =&gt; callRouteHandler(route.module.action, args) : void 0,</span><span class="s2">\n      </span><span class="s1">handle: route.module.handle</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">return route.index ? {</span><span class="s2">\n      </span><span class="s1">index: true,</span><span class="s2">\n      </span><span class="s1">...commonRoute</span><span class="s2">\n    </span><span class="s1">} : {</span><span class="s2">\n      </span><span class="s1">caseSensitive: route.caseSensitive,</span><span class="s2">\n      </span><span class="s1">children: createStaticHandlerDataRoutes(</span><span class="s2">\n        </span><span class="s1">manifest,</span><span class="s2">\n        </span><span class="s1">future,</span><span class="s2">\n        </span><span class="s1">route.id,</span><span class="s2">\n        </span><span class="s1">routesByParentId</span><span class="s2">\n      </span><span class="s1">),</span><span class="s2">\n      </span><span class="s1">...commonRoute</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/server-runtime/markup.ts</span><span class="s2">\n</span><span class="s1">var ESCAPE_LOOKUP3 = {</span><span class="s2">\n  \&quot;</span><span class="s1">&amp;</span><span class="s2">\&quot;</span><span class="s1">: </span><span class="s2">\&quot;\\\\</span><span class="s1">u0026</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">&gt;</span><span class="s2">\&quot;</span><span class="s1">: </span><span class="s2">\&quot;\\\\</span><span class="s1">u003e</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">&lt;</span><span class="s2">\&quot;</span><span class="s1">: </span><span class="s2">\&quot;\\\\</span><span class="s1">u003c</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;\\</span><span class="s1">u2028</span><span class="s2">\&quot;</span><span class="s1">: </span><span class="s2">\&quot;\\\\</span><span class="s1">u2028</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;\\</span><span class="s1">u2029</span><span class="s2">\&quot;</span><span class="s1">: </span><span class="s2">\&quot;\\\\</span><span class="s1">u2029</span><span class="s2">\&quot;\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">var ESCAPE_REGEX3 = /[&amp;&gt;&lt;</span><span class="s2">\\</span><span class="s1">u2028</span><span class="s2">\\</span><span class="s1">u2029]/g;</span><span class="s2">\n</span><span class="s1">function escapeHtml2(html) {</span><span class="s2">\n  </span><span class="s1">return html.replace(ESCAPE_REGEX3, (match) =&gt; ESCAPE_LOOKUP3[match]);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/server-runtime/serverHandoff.ts</span><span class="s2">\n</span><span class="s1">function createServerHandoffString(serverHandoff) {</span><span class="s2">\n  </span><span class="s1">return escapeHtml2(JSON.stringify(serverHandoff));</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/server-runtime/headers.ts</span><span class="s2">\n</span><span class="s1">import { splitCookiesString } from </span><span class="s2">\&quot;</span><span class="s1">set-cookie-parser</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">function getDocumentHeaders(build, context) {</span><span class="s2">\n  </span><span class="s1">let boundaryIdx = context.errors ? context.matches.findIndex((m) =&gt; context.errors[m.route.id]) : -1;</span><span class="s2">\n  </span><span class="s1">let matches = boundaryIdx &gt;= 0 ? context.matches.slice(0, boundaryIdx + 1) : context.matches;</span><span class="s2">\n  </span><span class="s1">let errorHeaders;</span><span class="s2">\n  </span><span class="s1">if (boundaryIdx &gt;= 0) {</span><span class="s2">\n    </span><span class="s1">let { actionHeaders, actionData, loaderHeaders, loaderData } = context;</span><span class="s2">\n    </span><span class="s1">context.matches.slice(boundaryIdx).some((match) =&gt; {</span><span class="s2">\n      </span><span class="s1">let id = match.route.id;</span><span class="s2">\n      </span><span class="s1">if (actionHeaders[id] &amp;&amp; (!actionData || !actionData.hasOwnProperty(id))) {</span><span class="s2">\n        </span><span class="s1">errorHeaders = actionHeaders[id];</span><span class="s2">\n      </span><span class="s1">} else if (loaderHeaders[id] &amp;&amp; !loaderData.hasOwnProperty(id)) {</span><span class="s2">\n        </span><span class="s1">errorHeaders = loaderHeaders[id];</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return errorHeaders != null;</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return matches.reduce((parentHeaders, match, idx) =&gt; {</span><span class="s2">\n    </span><span class="s1">let { id } = match.route;</span><span class="s2">\n    </span><span class="s1">let route = build.routes[id];</span><span class="s2">\n    </span><span class="s1">invariant3(route, `Route with id </span><span class="s2">\&quot;</span><span class="s1">${id}</span><span class="s2">\&quot; </span><span class="s1">not found in build`);</span><span class="s2">\n    </span><span class="s1">let routeModule = route.module;</span><span class="s2">\n    </span><span class="s1">let loaderHeaders = context.loaderHeaders[id] || new Headers();</span><span class="s2">\n    </span><span class="s1">let actionHeaders = context.actionHeaders[id] || new Headers();</span><span class="s2">\n    </span><span class="s1">let includeErrorHeaders = errorHeaders != null &amp;&amp; idx === matches.length - 1;</span><span class="s2">\n    </span><span class="s1">let includeErrorCookies = includeErrorHeaders &amp;&amp; errorHeaders !== loaderHeaders &amp;&amp; errorHeaders !== actionHeaders;</span><span class="s2">\n    </span><span class="s1">if (routeModule.headers == null) {</span><span class="s2">\n      </span><span class="s1">let headers2 = new Headers(parentHeaders);</span><span class="s2">\n      </span><span class="s1">if (includeErrorCookies) {</span><span class="s2">\n        </span><span class="s1">prependCookies(errorHeaders, headers2);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">prependCookies(actionHeaders, headers2);</span><span class="s2">\n      </span><span class="s1">prependCookies(loaderHeaders, headers2);</span><span class="s2">\n      </span><span class="s1">return headers2;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let headers = new Headers(</span><span class="s2">\n      </span><span class="s1">routeModule.headers ? typeof routeModule.headers === </span><span class="s2">\&quot;</span><span class="s1">function</span><span class="s2">\&quot; </span><span class="s1">? routeModule.headers({</span><span class="s2">\n        </span><span class="s1">loaderHeaders,</span><span class="s2">\n        </span><span class="s1">parentHeaders,</span><span class="s2">\n        </span><span class="s1">actionHeaders,</span><span class="s2">\n        </span><span class="s1">errorHeaders: includeErrorHeaders ? errorHeaders : void 0</span><span class="s2">\n      </span><span class="s1">}) : routeModule.headers : void 0</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">if (includeErrorCookies) {</span><span class="s2">\n      </span><span class="s1">prependCookies(errorHeaders, headers);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">prependCookies(actionHeaders, headers);</span><span class="s2">\n    </span><span class="s1">prependCookies(loaderHeaders, headers);</span><span class="s2">\n    </span><span class="s1">prependCookies(parentHeaders, headers);</span><span class="s2">\n    </span><span class="s1">return headers;</span><span class="s2">\n  </span><span class="s1">}, new Headers());</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function prependCookies(parentHeaders, childHeaders) {</span><span class="s2">\n  </span><span class="s1">let parentSetCookieString = parentHeaders.get(</span><span class="s2">\&quot;</span><span class="s1">Set-Cookie</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">if (parentSetCookieString) {</span><span class="s2">\n    </span><span class="s1">let cookies = splitCookiesString(parentSetCookieString);</span><span class="s2">\n    </span><span class="s1">let childCookies = new Set(childHeaders.getSetCookie());</span><span class="s2">\n    </span><span class="s1">cookies.forEach((cookie) =&gt; {</span><span class="s2">\n      </span><span class="s1">if (!childCookies.has(cookie)) {</span><span class="s2">\n        </span><span class="s1">childHeaders.append(</span><span class="s2">\&quot;</span><span class="s1">Set-Cookie</span><span class="s2">\&quot;</span><span class="s1">, cookie);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/server-runtime/single-fetch.ts</span><span class="s2">\n</span><span class="s1">var SERVER_NO_BODY_STATUS_CODES = /* @__PURE__ */ new Set([</span><span class="s2">\n  </span><span class="s1">...NO_BODY_STATUS_CODES,</span><span class="s2">\n  </span><span class="s1">304</span><span class="s2">\n</span><span class="s1">]);</span><span class="s2">\n</span><span class="s1">async function singleFetchAction(build, serverMode, staticHandler, request, handlerUrl, loadContext, handleError) {</span><span class="s2">\n  </span><span class="s1">try {</span><span class="s2">\n    </span><span class="s1">let respond2 = function(context) {</span><span class="s2">\n      </span><span class="s1">let headers = getDocumentHeaders(build, context);</span><span class="s2">\n      </span><span class="s1">if (isRedirectStatusCode(context.statusCode) &amp;&amp; headers.has(</span><span class="s2">\&quot;</span><span class="s1">Location</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n        </span><span class="s1">return generateSingleFetchResponse(request, build, serverMode, {</span><span class="s2">\n          </span><span class="s1">result: getSingleFetchRedirect(</span><span class="s2">\n            </span><span class="s1">context.statusCode,</span><span class="s2">\n            </span><span class="s1">headers,</span><span class="s2">\n            </span><span class="s1">build.basename</span><span class="s2">\n          </span><span class="s1">),</span><span class="s2">\n          </span><span class="s1">headers,</span><span class="s2">\n          </span><span class="s1">status: SINGLE_FETCH_REDIRECT_STATUS</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (context.errors) {</span><span class="s2">\n        </span><span class="s1">Object.values(context.errors).forEach((err) =&gt; {</span><span class="s2">\n          </span><span class="s1">if (!isRouteErrorResponse(err) || err.error) {</span><span class="s2">\n            </span><span class="s1">handleError(err);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">context.errors = sanitizeErrors(context.errors, serverMode);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">let singleFetchResult;</span><span class="s2">\n      </span><span class="s1">if (context.errors) {</span><span class="s2">\n        </span><span class="s1">singleFetchResult = { error: Object.values(context.errors)[0] };</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">singleFetchResult = {</span><span class="s2">\n          </span><span class="s1">data: Object.values(context.actionData || {})[0]</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return generateSingleFetchResponse(request, build, serverMode, {</span><span class="s2">\n        </span><span class="s1">result: singleFetchResult,</span><span class="s2">\n        </span><span class="s1">headers,</span><span class="s2">\n        </span><span class="s1">status: context.statusCode</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">var respond = respond2;</span><span class="s2">\n    </span><span class="s1">let handlerRequest = new Request(handlerUrl, {</span><span class="s2">\n      </span><span class="s1">method: request.method,</span><span class="s2">\n      </span><span class="s1">body: request.body,</span><span class="s2">\n      </span><span class="s1">headers: request.headers,</span><span class="s2">\n      </span><span class="s1">signal: request.signal,</span><span class="s2">\n      </span><span class="s1">...request.body ? { duplex: </span><span class="s2">\&quot;</span><span class="s1">half</span><span class="s2">\&quot; </span><span class="s1">} : void 0</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">let result = await staticHandler.query(handlerRequest, {</span><span class="s2">\n      </span><span class="s1">requestContext: loadContext,</span><span class="s2">\n      </span><span class="s1">skipLoaderErrorBubbling: true,</span><span class="s2">\n      </span><span class="s1">skipRevalidation: true,</span><span class="s2">\n      </span><span class="s1">unstable_respond: respond2</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">if (!isResponse(result)) {</span><span class="s2">\n      </span><span class="s1">result = respond2(result);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (isRedirectResponse(result)) {</span><span class="s2">\n      </span><span class="s1">return generateSingleFetchResponse(request, build, serverMode, {</span><span class="s2">\n        </span><span class="s1">result: getSingleFetchRedirect(</span><span class="s2">\n          </span><span class="s1">result.status,</span><span class="s2">\n          </span><span class="s1">result.headers,</span><span class="s2">\n          </span><span class="s1">build.basename</span><span class="s2">\n        </span><span class="s1">),</span><span class="s2">\n        </span><span class="s1">headers: result.headers,</span><span class="s2">\n        </span><span class="s1">status: SINGLE_FETCH_REDIRECT_STATUS</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return result;</span><span class="s2">\n  </span><span class="s1">} catch (error) {</span><span class="s2">\n    </span><span class="s1">handleError(error);</span><span class="s2">\n    </span><span class="s1">return generateSingleFetchResponse(request, build, serverMode, {</span><span class="s2">\n      </span><span class="s1">result: { error },</span><span class="s2">\n      </span><span class="s1">headers: new Headers(),</span><span class="s2">\n      </span><span class="s1">status: 500</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">async function singleFetchLoaders(build, serverMode, staticHandler, request, handlerUrl, loadContext, handleError) {</span><span class="s2">\n  </span><span class="s1">try {</span><span class="s2">\n    </span><span class="s1">let respond2 = function(context) {</span><span class="s2">\n      </span><span class="s1">let headers = getDocumentHeaders(build, context);</span><span class="s2">\n      </span><span class="s1">if (isRedirectStatusCode(context.statusCode) &amp;&amp; headers.has(</span><span class="s2">\&quot;</span><span class="s1">Location</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n        </span><span class="s1">return generateSingleFetchResponse(request, build, serverMode, {</span><span class="s2">\n          </span><span class="s1">result: {</span><span class="s2">\n            </span><span class="s1">[SingleFetchRedirectSymbol]: getSingleFetchRedirect(</span><span class="s2">\n              </span><span class="s1">context.statusCode,</span><span class="s2">\n              </span><span class="s1">headers,</span><span class="s2">\n              </span><span class="s1">build.basename</span><span class="s2">\n            </span><span class="s1">)</span><span class="s2">\n          </span><span class="s1">},</span><span class="s2">\n          </span><span class="s1">headers,</span><span class="s2">\n          </span><span class="s1">status: SINGLE_FETCH_REDIRECT_STATUS</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (context.errors) {</span><span class="s2">\n        </span><span class="s1">Object.values(context.errors).forEach((err) =&gt; {</span><span class="s2">\n          </span><span class="s1">if (!isRouteErrorResponse(err) || err.error) {</span><span class="s2">\n            </span><span class="s1">handleError(err);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">context.errors = sanitizeErrors(context.errors, serverMode);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">let results = {};</span><span class="s2">\n      </span><span class="s1">let loadedMatches = new Set(</span><span class="s2">\n        </span><span class="s1">context.matches.filter(</span><span class="s2">\n          </span><span class="s1">(m) =&gt; loadRouteIds ? loadRouteIds.has(m.route.id) : m.route.loader != null</span><span class="s2">\n        </span><span class="s1">).map((m) =&gt; m.route.id)</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">if (context.errors) {</span><span class="s2">\n        </span><span class="s1">for (let [id, error] of Object.entries(context.errors)) {</span><span class="s2">\n          </span><span class="s1">results[id] = { error };</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">for (let [id, data2] of Object.entries(context.loaderData)) {</span><span class="s2">\n        </span><span class="s1">if (!(id in results) &amp;&amp; loadedMatches.has(id)) {</span><span class="s2">\n          </span><span class="s1">results[id] = { data: data2 };</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return generateSingleFetchResponse(request, build, serverMode, {</span><span class="s2">\n        </span><span class="s1">result: results,</span><span class="s2">\n        </span><span class="s1">headers,</span><span class="s2">\n        </span><span class="s1">status: context.statusCode</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">var respond = respond2;</span><span class="s2">\n    </span><span class="s1">let handlerRequest = new Request(handlerUrl, {</span><span class="s2">\n      </span><span class="s1">headers: request.headers,</span><span class="s2">\n      </span><span class="s1">signal: request.signal</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">let routesParam = new URL(request.url).searchParams.get(</span><span class="s2">\&quot;</span><span class="s1">_routes</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">let loadRouteIds = routesParam ? new Set(routesParam.split(</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\&quot;</span><span class="s1">)) : null;</span><span class="s2">\n    </span><span class="s1">let result = await staticHandler.query(handlerRequest, {</span><span class="s2">\n      </span><span class="s1">requestContext: loadContext,</span><span class="s2">\n      </span><span class="s1">filterMatchesToLoad: (m) =&gt; !loadRouteIds || loadRouteIds.has(m.route.id),</span><span class="s2">\n      </span><span class="s1">skipLoaderErrorBubbling: true,</span><span class="s2">\n      </span><span class="s1">unstable_respond: respond2</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">if (!isResponse(result)) {</span><span class="s2">\n      </span><span class="s1">result = respond2(result);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (isRedirectResponse(result)) {</span><span class="s2">\n      </span><span class="s1">return generateSingleFetchResponse(request, build, serverMode, {</span><span class="s2">\n        </span><span class="s1">result: {</span><span class="s2">\n          </span><span class="s1">[SingleFetchRedirectSymbol]: getSingleFetchRedirect(</span><span class="s2">\n            </span><span class="s1">result.status,</span><span class="s2">\n            </span><span class="s1">result.headers,</span><span class="s2">\n            </span><span class="s1">build.basename</span><span class="s2">\n          </span><span class="s1">)</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">headers: result.headers,</span><span class="s2">\n        </span><span class="s1">status: SINGLE_FETCH_REDIRECT_STATUS</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return result;</span><span class="s2">\n  </span><span class="s1">} catch (error) {</span><span class="s2">\n    </span><span class="s1">handleError(error);</span><span class="s2">\n    </span><span class="s1">return generateSingleFetchResponse(request, build, serverMode, {</span><span class="s2">\n      </span><span class="s1">result: { root: { error } },</span><span class="s2">\n      </span><span class="s1">headers: new Headers(),</span><span class="s2">\n      </span><span class="s1">status: 500</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function generateSingleFetchResponse(request, build, serverMode, {</span><span class="s2">\n  </span><span class="s1">result,</span><span class="s2">\n  </span><span class="s1">headers,</span><span class="s2">\n  </span><span class="s1">status</span><span class="s2">\n</span><span class="s1">}) {</span><span class="s2">\n  </span><span class="s1">let resultHeaders = new Headers(headers);</span><span class="s2">\n  </span><span class="s1">resultHeaders.set(</span><span class="s2">\&quot;</span><span class="s1">X-Remix-Response</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">yes</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">if (SERVER_NO_BODY_STATUS_CODES.has(status)) {</span><span class="s2">\n    </span><span class="s1">return new Response(null, { status, headers: resultHeaders });</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">resultHeaders.set(</span><span class="s2">\&quot;</span><span class="s1">Content-Type</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">text/x-script</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">return new Response(</span><span class="s2">\n    </span><span class="s1">encodeViaTurboStream(</span><span class="s2">\n      </span><span class="s1">result,</span><span class="s2">\n      </span><span class="s1">request.signal,</span><span class="s2">\n      </span><span class="s1">build.entry.module.streamTimeout,</span><span class="s2">\n      </span><span class="s1">serverMode</span><span class="s2">\n    </span><span class="s1">),</span><span class="s2">\n    </span><span class="s1">{</span><span class="s2">\n      </span><span class="s1">status: status || 200,</span><span class="s2">\n      </span><span class="s1">headers: resultHeaders</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getSingleFetchRedirect(status, headers, basename) {</span><span class="s2">\n  </span><span class="s1">let redirect2 = headers.get(</span><span class="s2">\&quot;</span><span class="s1">Location</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">if (basename) {</span><span class="s2">\n    </span><span class="s1">redirect2 = stripBasename(redirect2, basename) || redirect2;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">redirect: redirect2,</span><span class="s2">\n    </span><span class="s1">status,</span><span class="s2">\n    </span><span class="s1">revalidate: (</span><span class="s2">\n      </span><span class="s1">// Technically X-Remix-Revalidate isn't needed here - that was an implementation</span><span class="s2">\n      </span><span class="s1">// detail of ?_data requests as our way to tell the front end to revalidate when</span><span class="s2">\n      </span><span class="s1">// we didn't have a response body to include that information in.</span><span class="s2">\n      </span><span class="s1">// With single fetch, we tell the front end via this revalidate boolean field.</span><span class="s2">\n      </span><span class="s1">// However, we're respecting it for now because it may be something folks have</span><span class="s2">\n      </span><span class="s1">// used in their own responses</span><span class="s2">\n      </span><span class="s1">// TODO(v3): Consider removing or making this official public API</span><span class="s2">\n      </span><span class="s1">headers.has(</span><span class="s2">\&quot;</span><span class="s1">X-Remix-Revalidate</span><span class="s2">\&quot;</span><span class="s1">) || headers.has(</span><span class="s2">\&quot;</span><span class="s1">Set-Cookie</span><span class="s2">\&quot;</span><span class="s1">)</span><span class="s2">\n    </span><span class="s1">),</span><span class="s2">\n    </span><span class="s1">reload: headers.has(</span><span class="s2">\&quot;</span><span class="s1">X-Remix-Reload-Document</span><span class="s2">\&quot;</span><span class="s1">),</span><span class="s2">\n    </span><span class="s1">replace: headers.has(</span><span class="s2">\&quot;</span><span class="s1">X-Remix-Replace</span><span class="s2">\&quot;</span><span class="s1">)</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function encodeViaTurboStream(data2, requestSignal, streamTimeout, serverMode) {</span><span class="s2">\n  </span><span class="s1">let controller = new AbortController();</span><span class="s2">\n  </span><span class="s1">let timeoutId = setTimeout(</span><span class="s2">\n    </span><span class="s1">() =&gt; controller.abort(new Error(</span><span class="s2">\&quot;</span><span class="s1">Server Timeout</span><span class="s2">\&quot;</span><span class="s1">)),</span><span class="s2">\n    </span><span class="s1">typeof streamTimeout === </span><span class="s2">\&quot;</span><span class="s1">number</span><span class="s2">\&quot; </span><span class="s1">? streamTimeout : 4950</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">requestSignal.addEventListener(</span><span class="s2">\&quot;</span><span class="s1">abort</span><span class="s2">\&quot;</span><span class="s1">, () =&gt; clearTimeout(timeoutId));</span><span class="s2">\n  </span><span class="s1">return encode(data2, {</span><span class="s2">\n    </span><span class="s1">signal: controller.signal,</span><span class="s2">\n    </span><span class="s1">plugins: [</span><span class="s2">\n      </span><span class="s1">(value) =&gt; {</span><span class="s2">\n        </span><span class="s1">if (value instanceof Error) {</span><span class="s2">\n          </span><span class="s1">let { name, message, stack } = serverMode === </span><span class="s2">\&quot;</span><span class="s1">production</span><span class="s2">\&quot; </span><span class="s1">/* Production */ ? sanitizeError(value, serverMode) : value;</span><span class="s2">\n          </span><span class="s1">return [</span><span class="s2">\&quot;</span><span class="s1">SanitizedError</span><span class="s2">\&quot;</span><span class="s1">, name, message, stack];</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (value instanceof ErrorResponseImpl) {</span><span class="s2">\n          </span><span class="s1">let { data: data3, status, statusText } = value;</span><span class="s2">\n          </span><span class="s1">return [</span><span class="s2">\&quot;</span><span class="s1">ErrorResponse</span><span class="s2">\&quot;</span><span class="s1">, data3, status, statusText];</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (value &amp;&amp; typeof value === </span><span class="s2">\&quot;</span><span class="s1">object</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; SingleFetchRedirectSymbol in value) {</span><span class="s2">\n          </span><span class="s1">return [</span><span class="s2">\&quot;</span><span class="s1">SingleFetchRedirect</span><span class="s2">\&quot;</span><span class="s1">, value[SingleFetchRedirectSymbol]];</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">],</span><span class="s2">\n    </span><span class="s1">postPlugins: [</span><span class="s2">\n      </span><span class="s1">(value) =&gt; {</span><span class="s2">\n        </span><span class="s1">if (!value) return;</span><span class="s2">\n        </span><span class="s1">if (typeof value !== </span><span class="s2">\&quot;</span><span class="s1">object</span><span class="s2">\&quot;</span><span class="s1">) return;</span><span class="s2">\n        </span><span class="s1">return [</span><span class="s2">\n          \&quot;</span><span class="s1">SingleFetchClassInstance</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n          </span><span class="s1">Object.fromEntries(Object.entries(value))</span><span class="s2">\n        </span><span class="s1">];</span><span class="s2">\n      </span><span class="s1">},</span><span class="s2">\n      </span><span class="s1">() =&gt; [</span><span class="s2">\&quot;</span><span class="s1">SingleFetchFallback</span><span class="s2">\&quot;</span><span class="s1">]</span><span class="s2">\n    </span><span class="s1">]</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/server-runtime/server.ts</span><span class="s2">\n</span><span class="s1">function derive(build, mode) {</span><span class="s2">\n  </span><span class="s1">let routes = createRoutes(build.routes);</span><span class="s2">\n  </span><span class="s1">let dataRoutes = createStaticHandlerDataRoutes(build.routes, build.future);</span><span class="s2">\n  </span><span class="s1">let serverMode = isServerMode(mode) ? mode : </span><span class="s2">\&quot;</span><span class="s1">production</span><span class="s2">\&quot; </span><span class="s1">/* Production */;</span><span class="s2">\n  </span><span class="s1">let staticHandler = createStaticHandler(dataRoutes, {</span><span class="s2">\n    </span><span class="s1">basename: build.basename</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">let errorHandler = build.entry.module.handleError || ((error, { request }) =&gt; {</span><span class="s2">\n    </span><span class="s1">if (serverMode !== </span><span class="s2">\&quot;</span><span class="s1">test</span><span class="s2">\&quot; </span><span class="s1">/* Test */ &amp;&amp; !request.signal.aborted) {</span><span class="s2">\n      </span><span class="s1">console.error(</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error This is </span><span class="s2">\&quot;</span><span class="s1">private</span><span class="s2">\&quot; </span><span class="s1">from users but intended for internal use</span><span class="s2">\n        </span><span class="s1">isRouteErrorResponse(error) &amp;&amp; error.error ? error.error : error</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">routes,</span><span class="s2">\n    </span><span class="s1">dataRoutes,</span><span class="s2">\n    </span><span class="s1">serverMode,</span><span class="s2">\n    </span><span class="s1">staticHandler,</span><span class="s2">\n    </span><span class="s1">errorHandler</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var createRequestHandler = (build, mode) =&gt; {</span><span class="s2">\n  </span><span class="s1">let _build;</span><span class="s2">\n  </span><span class="s1">let routes;</span><span class="s2">\n  </span><span class="s1">let serverMode;</span><span class="s2">\n  </span><span class="s1">let staticHandler;</span><span class="s2">\n  </span><span class="s1">let errorHandler;</span><span class="s2">\n  </span><span class="s1">return async function requestHandler(request, initialContext) {</span><span class="s2">\n    </span><span class="s1">_build = typeof build === </span><span class="s2">\&quot;</span><span class="s1">function</span><span class="s2">\&quot; </span><span class="s1">? await build() : build;</span><span class="s2">\n    </span><span class="s1">if (typeof build === </span><span class="s2">\&quot;</span><span class="s1">function</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">let derived = derive(_build, mode);</span><span class="s2">\n      </span><span class="s1">routes = derived.routes;</span><span class="s2">\n      </span><span class="s1">serverMode = derived.serverMode;</span><span class="s2">\n      </span><span class="s1">staticHandler = derived.staticHandler;</span><span class="s2">\n      </span><span class="s1">errorHandler = derived.errorHandler;</span><span class="s2">\n    </span><span class="s1">} else if (!routes || !serverMode || !staticHandler || !errorHandler) {</span><span class="s2">\n      </span><span class="s1">let derived = derive(_build, mode);</span><span class="s2">\n      </span><span class="s1">routes = derived.routes;</span><span class="s2">\n      </span><span class="s1">serverMode = derived.serverMode;</span><span class="s2">\n      </span><span class="s1">staticHandler = derived.staticHandler;</span><span class="s2">\n      </span><span class="s1">errorHandler = derived.errorHandler;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let params = {};</span><span class="s2">\n    </span><span class="s1">let loadContext;</span><span class="s2">\n    </span><span class="s1">let handleError = (error) =&gt; {</span><span class="s2">\n      </span><span class="s1">if (mode === </span><span class="s2">\&quot;</span><span class="s1">development</span><span class="s2">\&quot; </span><span class="s1">/* Development */) {</span><span class="s2">\n        </span><span class="s1">getDevServerHooks()?.processRequestError?.(error);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">errorHandler(error, {</span><span class="s2">\n        </span><span class="s1">context: loadContext,</span><span class="s2">\n        </span><span class="s1">params,</span><span class="s2">\n        </span><span class="s1">request</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">if (_build.future.unstable_middleware) {</span><span class="s2">\n      </span><span class="s1">if (initialContext == null) {</span><span class="s2">\n        </span><span class="s1">loadContext = new unstable_RouterContextProvider();</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">try {</span><span class="s2">\n          </span><span class="s1">loadContext = new unstable_RouterContextProvider(</span><span class="s2">\n            </span><span class="s1">initialContext</span><span class="s2">\n          </span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">} catch (e) {</span><span class="s2">\n          </span><span class="s1">let error = new Error(</span><span class="s2">\n            </span><span class="s1">`Unable to create initial </span><span class="s2">\\</span><span class="s1">`unstable_RouterContextProvider</span><span class="s2">\\</span><span class="s1">` instance. Please confirm you are returning an instance of </span><span class="s2">\\</span><span class="s1">`Map&lt;unstable_routerContext, unknown&gt;</span><span class="s2">\\</span><span class="s1">` from your </span><span class="s2">\\</span><span class="s1">`getLoadContext</span><span class="s2">\\</span><span class="s1">` function.</span><span class="s2">\n\n</span><span class="s1">Error: ${e instanceof Error ? e.toString() : e}`</span><span class="s2">\n          </span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">handleError(error);</span><span class="s2">\n          </span><span class="s1">return returnLastResortErrorResponse(error, serverMode);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">loadContext = initialContext || {};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let url = new URL(request.url);</span><span class="s2">\n    </span><span class="s1">let normalizedBasename = _build.basename || </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">let normalizedPath = url.pathname;</span><span class="s2">\n    </span><span class="s1">if (stripBasename(normalizedPath, normalizedBasename) === </span><span class="s2">\&quot;</span><span class="s1">/_root.data</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">normalizedPath = normalizedBasename;</span><span class="s2">\n    </span><span class="s1">} else if (normalizedPath.endsWith(</span><span class="s2">\&quot;</span><span class="s1">.data</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n      </span><span class="s1">normalizedPath = normalizedPath.replace(/</span><span class="s2">\\</span><span class="s1">.data$/, </span><span class="s2">\&quot;\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (stripBasename(normalizedPath, normalizedBasename) !== </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; normalizedPath.endsWith(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n      </span><span class="s1">normalizedPath = normalizedPath.slice(0, -1);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let isSpaMode = getBuildTimeHeader(request, </span><span class="s2">\&quot;</span><span class="s1">X-React-Router-SPA-Mode</span><span class="s2">\&quot;</span><span class="s1">) === </span><span class="s2">\&quot;</span><span class="s1">yes</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">if (!_build.ssr) {</span><span class="s2">\n      </span><span class="s1">if (_build.prerender.length === 0) {</span><span class="s2">\n        </span><span class="s1">isSpaMode = true;</span><span class="s2">\n      </span><span class="s1">} else if (!_build.prerender.includes(normalizedPath) &amp;&amp; !_build.prerender.includes(normalizedPath + </span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n        </span><span class="s1">if (url.pathname.endsWith(</span><span class="s2">\&quot;</span><span class="s1">.data</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n          </span><span class="s1">errorHandler(</span><span class="s2">\n            </span><span class="s1">new ErrorResponseImpl(</span><span class="s2">\n              </span><span class="s1">404,</span><span class="s2">\n              \&quot;</span><span class="s1">Not Found</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n              </span><span class="s1">`Refusing to SSR the path </span><span class="s2">\\</span><span class="s1">`${normalizedPath}</span><span class="s2">\\</span><span class="s1">` because </span><span class="s2">\\</span><span class="s1">`ssr:false</span><span class="s2">\\</span><span class="s1">` is set and the path is not included in the </span><span class="s2">\\</span><span class="s1">`prerender</span><span class="s2">\\</span><span class="s1">` config, so in production the path will be a 404.`</span><span class="s2">\n            </span><span class="s1">),</span><span class="s2">\n            </span><span class="s1">{</span><span class="s2">\n              </span><span class="s1">context: loadContext,</span><span class="s2">\n              </span><span class="s1">params,</span><span class="s2">\n              </span><span class="s1">request</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">return new Response(</span><span class="s2">\&quot;</span><span class="s1">Not Found</span><span class="s2">\&quot;</span><span class="s1">, {</span><span class="s2">\n            </span><span class="s1">status: 404,</span><span class="s2">\n            </span><span class="s1">statusText: </span><span class="s2">\&quot;</span><span class="s1">Not Found</span><span class="s2">\&quot;\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">isSpaMode = true;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let manifestUrl = getManifestPath(</span><span class="s2">\n      </span><span class="s1">_build.routeDiscovery.manifestPath,</span><span class="s2">\n      </span><span class="s1">normalizedBasename</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">if (url.pathname === manifestUrl) {</span><span class="s2">\n      </span><span class="s1">try {</span><span class="s2">\n        </span><span class="s1">let res = await handleManifestRequest(_build, routes, url);</span><span class="s2">\n        </span><span class="s1">return res;</span><span class="s2">\n      </span><span class="s1">} catch (e) {</span><span class="s2">\n        </span><span class="s1">handleError(e);</span><span class="s2">\n        </span><span class="s1">return new Response(</span><span class="s2">\&quot;</span><span class="s1">Unknown Server Error</span><span class="s2">\&quot;</span><span class="s1">, { status: 500 });</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let matches = matchServerRoutes(routes, normalizedPath, _build.basename);</span><span class="s2">\n    </span><span class="s1">if (matches &amp;&amp; matches.length &gt; 0) {</span><span class="s2">\n      </span><span class="s1">Object.assign(params, matches[0].params);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let response;</span><span class="s2">\n    </span><span class="s1">if (url.pathname.endsWith(</span><span class="s2">\&quot;</span><span class="s1">.data</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n      </span><span class="s1">let handlerUrl = new URL(request.url);</span><span class="s2">\n      </span><span class="s1">handlerUrl.pathname = normalizedPath;</span><span class="s2">\n      </span><span class="s1">let singleFetchMatches = matchServerRoutes(</span><span class="s2">\n        </span><span class="s1">routes,</span><span class="s2">\n        </span><span class="s1">handlerUrl.pathname,</span><span class="s2">\n        </span><span class="s1">_build.basename</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">response = await handleSingleFetchRequest(</span><span class="s2">\n        </span><span class="s1">serverMode,</span><span class="s2">\n        </span><span class="s1">_build,</span><span class="s2">\n        </span><span class="s1">staticHandler,</span><span class="s2">\n        </span><span class="s1">request,</span><span class="s2">\n        </span><span class="s1">handlerUrl,</span><span class="s2">\n        </span><span class="s1">loadContext,</span><span class="s2">\n        </span><span class="s1">handleError</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">if (_build.entry.module.handleDataRequest) {</span><span class="s2">\n        </span><span class="s1">response = await _build.entry.module.handleDataRequest(response, {</span><span class="s2">\n          </span><span class="s1">context: loadContext,</span><span class="s2">\n          </span><span class="s1">params: singleFetchMatches ? singleFetchMatches[0].params : {},</span><span class="s2">\n          </span><span class="s1">request</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">if (isRedirectResponse(response)) {</span><span class="s2">\n          </span><span class="s1">let result = getSingleFetchRedirect(</span><span class="s2">\n            </span><span class="s1">response.status,</span><span class="s2">\n            </span><span class="s1">response.headers,</span><span class="s2">\n            </span><span class="s1">_build.basename</span><span class="s2">\n          </span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">if (request.method === </span><span class="s2">\&quot;</span><span class="s1">GET</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n            </span><span class="s1">result = {</span><span class="s2">\n              </span><span class="s1">[SingleFetchRedirectSymbol]: result</span><span class="s2">\n            </span><span class="s1">};</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">let headers = new Headers(response.headers);</span><span class="s2">\n          </span><span class="s1">headers.set(</span><span class="s2">\&quot;</span><span class="s1">Content-Type</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">text/x-script</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">return new Response(</span><span class="s2">\n            </span><span class="s1">encodeViaTurboStream(</span><span class="s2">\n              </span><span class="s1">result,</span><span class="s2">\n              </span><span class="s1">request.signal,</span><span class="s2">\n              </span><span class="s1">_build.entry.module.streamTimeout,</span><span class="s2">\n              </span><span class="s1">serverMode</span><span class="s2">\n            </span><span class="s1">),</span><span class="s2">\n            </span><span class="s1">{</span><span class="s2">\n              </span><span class="s1">status: SINGLE_FETCH_REDIRECT_STATUS,</span><span class="s2">\n              </span><span class="s1">headers</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else if (!isSpaMode &amp;&amp; matches &amp;&amp; matches[matches.length - 1].route.module.default == null &amp;&amp; matches[matches.length - 1].route.module.ErrorBoundary == null) {</span><span class="s2">\n      </span><span class="s1">response = await handleResourceRequest(</span><span class="s2">\n        </span><span class="s1">serverMode,</span><span class="s2">\n        </span><span class="s1">_build,</span><span class="s2">\n        </span><span class="s1">staticHandler,</span><span class="s2">\n        </span><span class="s1">matches.slice(-1)[0].route.id,</span><span class="s2">\n        </span><span class="s1">request,</span><span class="s2">\n        </span><span class="s1">loadContext,</span><span class="s2">\n        </span><span class="s1">handleError</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">let { pathname } = url;</span><span class="s2">\n      </span><span class="s1">let criticalCss = void 0;</span><span class="s2">\n      </span><span class="s1">if (_build.unstable_getCriticalCss) {</span><span class="s2">\n        </span><span class="s1">criticalCss = await _build.unstable_getCriticalCss({ pathname });</span><span class="s2">\n      </span><span class="s1">} else if (mode === </span><span class="s2">\&quot;</span><span class="s1">development</span><span class="s2">\&quot; </span><span class="s1">/* Development */ &amp;&amp; getDevServerHooks()?.getCriticalCss) {</span><span class="s2">\n        </span><span class="s1">criticalCss = await getDevServerHooks()?.getCriticalCss?.(pathname);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">response = await handleDocumentRequest(</span><span class="s2">\n        </span><span class="s1">serverMode,</span><span class="s2">\n        </span><span class="s1">_build,</span><span class="s2">\n        </span><span class="s1">staticHandler,</span><span class="s2">\n        </span><span class="s1">request,</span><span class="s2">\n        </span><span class="s1">loadContext,</span><span class="s2">\n        </span><span class="s1">handleError,</span><span class="s2">\n        </span><span class="s1">isSpaMode,</span><span class="s2">\n        </span><span class="s1">criticalCss</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (request.method === </span><span class="s2">\&quot;</span><span class="s1">HEAD</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">return new Response(null, {</span><span class="s2">\n        </span><span class="s1">headers: response.headers,</span><span class="s2">\n        </span><span class="s1">status: response.status,</span><span class="s2">\n        </span><span class="s1">statusText: response.statusText</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return response;</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">async function handleManifestRequest(build, routes, url) {</span><span class="s2">\n  </span><span class="s1">if (build.assets.version !== url.searchParams.get(</span><span class="s2">\&quot;</span><span class="s1">version</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n    </span><span class="s1">return new Response(null, {</span><span class="s2">\n      </span><span class="s1">status: 204,</span><span class="s2">\n      </span><span class="s1">headers: {</span><span class="s2">\n        \&quot;</span><span class="s1">X-Remix-Reload-Document</span><span class="s2">\&quot;</span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">true</span><span class="s2">\&quot;\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">let patches = {};</span><span class="s2">\n  </span><span class="s1">if (url.searchParams.has(</span><span class="s2">\&quot;</span><span class="s1">p</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n    </span><span class="s1">let paths = /* @__PURE__ */ new Set();</span><span class="s2">\n    </span><span class="s1">url.searchParams.getAll(</span><span class="s2">\&quot;</span><span class="s1">p</span><span class="s2">\&quot;</span><span class="s1">).forEach((path) =&gt; {</span><span class="s2">\n      </span><span class="s1">if (!path.startsWith(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n        </span><span class="s1">path = `/${path}`;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">let segments = path.split(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">).slice(1);</span><span class="s2">\n      </span><span class="s1">segments.forEach((_, i) =&gt; {</span><span class="s2">\n        </span><span class="s1">let partialPath = segments.slice(0, i + 1).join(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">paths.add(`/${partialPath}`);</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">for (let path of paths) {</span><span class="s2">\n      </span><span class="s1">let matches = matchServerRoutes(routes, path, build.basename);</span><span class="s2">\n      </span><span class="s1">if (matches) {</span><span class="s2">\n        </span><span class="s1">for (let match of matches) {</span><span class="s2">\n          </span><span class="s1">let routeId = match.route.id;</span><span class="s2">\n          </span><span class="s1">let route = build.assets.routes[routeId];</span><span class="s2">\n          </span><span class="s1">if (route) {</span><span class="s2">\n            </span><span class="s1">patches[routeId] = route;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return Response.json(patches, {</span><span class="s2">\n      </span><span class="s1">headers: {</span><span class="s2">\n        \&quot;</span><span class="s1">Cache-Control</span><span class="s2">\&quot;</span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">public, max-age=31536000, immutable</span><span class="s2">\&quot;\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return new Response(</span><span class="s2">\&quot;</span><span class="s1">Invalid Request</span><span class="s2">\&quot;</span><span class="s1">, { status: 400 });</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">async function handleSingleFetchRequest(serverMode, build, staticHandler, request, handlerUrl, loadContext, handleError) {</span><span class="s2">\n  </span><span class="s1">let response = request.method !== </span><span class="s2">\&quot;</span><span class="s1">GET</span><span class="s2">\&quot; </span><span class="s1">? await singleFetchAction(</span><span class="s2">\n    </span><span class="s1">build,</span><span class="s2">\n    </span><span class="s1">serverMode,</span><span class="s2">\n    </span><span class="s1">staticHandler,</span><span class="s2">\n    </span><span class="s1">request,</span><span class="s2">\n    </span><span class="s1">handlerUrl,</span><span class="s2">\n    </span><span class="s1">loadContext,</span><span class="s2">\n    </span><span class="s1">handleError</span><span class="s2">\n  </span><span class="s1">) : await singleFetchLoaders(</span><span class="s2">\n    </span><span class="s1">build,</span><span class="s2">\n    </span><span class="s1">serverMode,</span><span class="s2">\n    </span><span class="s1">staticHandler,</span><span class="s2">\n    </span><span class="s1">request,</span><span class="s2">\n    </span><span class="s1">handlerUrl,</span><span class="s2">\n    </span><span class="s1">loadContext,</span><span class="s2">\n    </span><span class="s1">handleError</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">return response;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">async function handleDocumentRequest(serverMode, build, staticHandler, request, loadContext, handleError, isSpaMode, criticalCss) {</span><span class="s2">\n  </span><span class="s1">try {</span><span class="s2">\n    </span><span class="s1">let response = await staticHandler.query(request, {</span><span class="s2">\n      </span><span class="s1">requestContext: loadContext,</span><span class="s2">\n      </span><span class="s1">unstable_respond: build.future.unstable_middleware ? (ctx) =&gt; renderHtml(ctx, isSpaMode) : void 0</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">return isResponse(response) ? response : renderHtml(response, isSpaMode);</span><span class="s2">\n  </span><span class="s1">} catch (error) {</span><span class="s2">\n    </span><span class="s1">handleError(error);</span><span class="s2">\n    </span><span class="s1">return new Response(null, { status: 500 });</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">async function renderHtml(context, isSpaMode2) {</span><span class="s2">\n    </span><span class="s1">if (isResponse(context)) {</span><span class="s2">\n      </span><span class="s1">return context;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let headers = getDocumentHeaders(build, context);</span><span class="s2">\n    </span><span class="s1">if (SERVER_NO_BODY_STATUS_CODES.has(context.statusCode)) {</span><span class="s2">\n      </span><span class="s1">return new Response(null, { status: context.statusCode, headers });</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (context.errors) {</span><span class="s2">\n      </span><span class="s1">Object.values(context.errors).forEach((err) =&gt; {</span><span class="s2">\n        </span><span class="s1">if (!isRouteErrorResponse(err) || err.error) {</span><span class="s2">\n          </span><span class="s1">handleError(err);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">context.errors = sanitizeErrors(context.errors, serverMode);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let state = {</span><span class="s2">\n      </span><span class="s1">loaderData: context.loaderData,</span><span class="s2">\n      </span><span class="s1">actionData: context.actionData,</span><span class="s2">\n      </span><span class="s1">errors: serializeErrors2(context.errors, serverMode)</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">let baseServerHandoff = {</span><span class="s2">\n      </span><span class="s1">basename: build.basename,</span><span class="s2">\n      </span><span class="s1">future: build.future,</span><span class="s2">\n      </span><span class="s1">routeDiscovery: build.routeDiscovery,</span><span class="s2">\n      </span><span class="s1">ssr: build.ssr,</span><span class="s2">\n      </span><span class="s1">isSpaMode: isSpaMode2</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">let entryContext = {</span><span class="s2">\n      </span><span class="s1">manifest: build.assets,</span><span class="s2">\n      </span><span class="s1">routeModules: createEntryRouteModules(build.routes),</span><span class="s2">\n      </span><span class="s1">staticHandlerContext: context,</span><span class="s2">\n      </span><span class="s1">criticalCss,</span><span class="s2">\n      </span><span class="s1">serverHandoffString: createServerHandoffString({</span><span class="s2">\n        </span><span class="s1">...baseServerHandoff,</span><span class="s2">\n        </span><span class="s1">criticalCss</span><span class="s2">\n      </span><span class="s1">}),</span><span class="s2">\n      </span><span class="s1">serverHandoffStream: encodeViaTurboStream(</span><span class="s2">\n        </span><span class="s1">state,</span><span class="s2">\n        </span><span class="s1">request.signal,</span><span class="s2">\n        </span><span class="s1">build.entry.module.streamTimeout,</span><span class="s2">\n        </span><span class="s1">serverMode</span><span class="s2">\n      </span><span class="s1">),</span><span class="s2">\n      </span><span class="s1">renderMeta: {},</span><span class="s2">\n      </span><span class="s1">future: build.future,</span><span class="s2">\n      </span><span class="s1">ssr: build.ssr,</span><span class="s2">\n      </span><span class="s1">routeDiscovery: build.routeDiscovery,</span><span class="s2">\n      </span><span class="s1">isSpaMode: isSpaMode2,</span><span class="s2">\n      </span><span class="s1">serializeError: (err) =&gt; serializeError(err, serverMode)</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">let handleDocumentRequestFunction = build.entry.module.default;</span><span class="s2">\n    </span><span class="s1">try {</span><span class="s2">\n      </span><span class="s1">return await handleDocumentRequestFunction(</span><span class="s2">\n        </span><span class="s1">request,</span><span class="s2">\n        </span><span class="s1">context.statusCode,</span><span class="s2">\n        </span><span class="s1">headers,</span><span class="s2">\n        </span><span class="s1">entryContext,</span><span class="s2">\n        </span><span class="s1">loadContext</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">} catch (error) {</span><span class="s2">\n      </span><span class="s1">handleError(error);</span><span class="s2">\n      </span><span class="s1">let errorForSecondRender = error;</span><span class="s2">\n      </span><span class="s1">if (isResponse(error)) {</span><span class="s2">\n        </span><span class="s1">try {</span><span class="s2">\n          </span><span class="s1">let data2 = await unwrapResponse(error);</span><span class="s2">\n          </span><span class="s1">errorForSecondRender = new ErrorResponseImpl(</span><span class="s2">\n            </span><span class="s1">error.status,</span><span class="s2">\n            </span><span class="s1">error.statusText,</span><span class="s2">\n            </span><span class="s1">data2</span><span class="s2">\n          </span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">} catch (e) {</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">context = getStaticContextFromError(</span><span class="s2">\n        </span><span class="s1">staticHandler.dataRoutes,</span><span class="s2">\n        </span><span class="s1">context,</span><span class="s2">\n        </span><span class="s1">errorForSecondRender</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">if (context.errors) {</span><span class="s2">\n        </span><span class="s1">context.errors = sanitizeErrors(context.errors, serverMode);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">let state2 = {</span><span class="s2">\n        </span><span class="s1">loaderData: context.loaderData,</span><span class="s2">\n        </span><span class="s1">actionData: context.actionData,</span><span class="s2">\n        </span><span class="s1">errors: serializeErrors2(context.errors, serverMode)</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">entryContext = {</span><span class="s2">\n        </span><span class="s1">...entryContext,</span><span class="s2">\n        </span><span class="s1">staticHandlerContext: context,</span><span class="s2">\n        </span><span class="s1">serverHandoffString: createServerHandoffString(baseServerHandoff),</span><span class="s2">\n        </span><span class="s1">serverHandoffStream: encodeViaTurboStream(</span><span class="s2">\n          </span><span class="s1">state2,</span><span class="s2">\n          </span><span class="s1">request.signal,</span><span class="s2">\n          </span><span class="s1">build.entry.module.streamTimeout,</span><span class="s2">\n          </span><span class="s1">serverMode</span><span class="s2">\n        </span><span class="s1">),</span><span class="s2">\n        </span><span class="s1">renderMeta: {}</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">try {</span><span class="s2">\n        </span><span class="s1">return await handleDocumentRequestFunction(</span><span class="s2">\n          </span><span class="s1">request,</span><span class="s2">\n          </span><span class="s1">context.statusCode,</span><span class="s2">\n          </span><span class="s1">headers,</span><span class="s2">\n          </span><span class="s1">entryContext,</span><span class="s2">\n          </span><span class="s1">loadContext</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">} catch (error2) {</span><span class="s2">\n        </span><span class="s1">handleError(error2);</span><span class="s2">\n        </span><span class="s1">return returnLastResortErrorResponse(error2, serverMode);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">async function handleResourceRequest(serverMode, build, staticHandler, routeId, request, loadContext, handleError) {</span><span class="s2">\n  </span><span class="s1">try {</span><span class="s2">\n    </span><span class="s1">let response = await staticHandler.queryRoute(request, {</span><span class="s2">\n      </span><span class="s1">routeId,</span><span class="s2">\n      </span><span class="s1">requestContext: loadContext,</span><span class="s2">\n      </span><span class="s1">unstable_respond: build.future.unstable_middleware ? (ctx) =&gt; ctx : void 0</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">if (isResponse(response)) {</span><span class="s2">\n      </span><span class="s1">return response;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (typeof response === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">return new Response(response);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return Response.json(response);</span><span class="s2">\n  </span><span class="s1">} catch (error) {</span><span class="s2">\n    </span><span class="s1">if (isResponse(error)) {</span><span class="s2">\n      </span><span class="s1">error.headers.set(</span><span class="s2">\&quot;</span><span class="s1">X-Remix-Catch</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">yes</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">return error;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (isRouteErrorResponse(error)) {</span><span class="s2">\n      </span><span class="s1">if (error) {</span><span class="s2">\n        </span><span class="s1">handleError(error);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return errorResponseToJson(error, serverMode);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (error instanceof Error &amp;&amp; error.message === </span><span class="s2">\&quot;</span><span class="s1">Expected a response from queryRoute</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">let newError = new Error(</span><span class="s2">\n        \&quot;</span><span class="s1">Expected a Response to be returned from resource route handler</span><span class="s2">\&quot;\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">handleError(newError);</span><span class="s2">\n      </span><span class="s1">return returnLastResortErrorResponse(newError, serverMode);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">handleError(error);</span><span class="s2">\n    </span><span class="s1">return returnLastResortErrorResponse(error, serverMode);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function errorResponseToJson(errorResponse, serverMode) {</span><span class="s2">\n  </span><span class="s1">return Response.json(</span><span class="s2">\n    </span><span class="s1">serializeError(</span><span class="s2">\n      </span><span class="s1">// @ts-expect-error This is </span><span class="s2">\&quot;</span><span class="s1">private</span><span class="s2">\&quot; </span><span class="s1">from users but intended for internal use</span><span class="s2">\n      </span><span class="s1">errorResponse.error || new Error(</span><span class="s2">\&quot;</span><span class="s1">Unexpected Server Error</span><span class="s2">\&quot;</span><span class="s1">),</span><span class="s2">\n      </span><span class="s1">serverMode</span><span class="s2">\n    </span><span class="s1">),</span><span class="s2">\n    </span><span class="s1">{</span><span class="s2">\n      </span><span class="s1">status: errorResponse.status,</span><span class="s2">\n      </span><span class="s1">statusText: errorResponse.statusText,</span><span class="s2">\n      </span><span class="s1">headers: {</span><span class="s2">\n        \&quot;</span><span class="s1">X-Remix-Error</span><span class="s2">\&quot;</span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">yes</span><span class="s2">\&quot;\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function returnLastResortErrorResponse(error, serverMode) {</span><span class="s2">\n  </span><span class="s1">let message = </span><span class="s2">\&quot;</span><span class="s1">Unexpected Server Error</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">if (serverMode !== </span><span class="s2">\&quot;</span><span class="s1">production</span><span class="s2">\&quot; </span><span class="s1">/* Production */) {</span><span class="s2">\n    </span><span class="s1">message += `</span><span class="s2">\n\n</span><span class="s1">${String(error)}`;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return new Response(message, {</span><span class="s2">\n    </span><span class="s1">status: 500,</span><span class="s2">\n    </span><span class="s1">headers: {</span><span class="s2">\n      \&quot;</span><span class="s1">Content-Type</span><span class="s2">\&quot;</span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">text/plain</span><span class="s2">\&quot;\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function unwrapResponse(response) {</span><span class="s2">\n  </span><span class="s1">let contentType = response.headers.get(</span><span class="s2">\&quot;</span><span class="s1">Content-Type</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">return contentType &amp;&amp; /</span><span class="s2">\\</span><span class="s1">bapplication</span><span class="s2">\\</span><span class="s1">/json</span><span class="s2">\\</span><span class="s1">b/.test(contentType) ? response.body == null ? null : response.json() : response.text();</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/server-runtime/sessions.ts</span><span class="s2">\n</span><span class="s1">function flash(name) {</span><span class="s2">\n  </span><span class="s1">return `__flash_${name}__`;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">var createSession = (initialData = {}, id = </span><span class="s2">\&quot;\&quot;</span><span class="s1">) =&gt; {</span><span class="s2">\n  </span><span class="s1">let map = new Map(Object.entries(initialData));</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">get id() {</span><span class="s2">\n      </span><span class="s1">return id;</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">get data() {</span><span class="s2">\n      </span><span class="s1">return Object.fromEntries(map);</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">has(name) {</span><span class="s2">\n      </span><span class="s1">return map.has(name) || map.has(flash(name));</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">get(name) {</span><span class="s2">\n      </span><span class="s1">if (map.has(name)) return map.get(name);</span><span class="s2">\n      </span><span class="s1">let flashName = flash(name);</span><span class="s2">\n      </span><span class="s1">if (map.has(flashName)) {</span><span class="s2">\n        </span><span class="s1">let value = map.get(flashName);</span><span class="s2">\n        </span><span class="s1">map.delete(flashName);</span><span class="s2">\n        </span><span class="s1">return value;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return void 0;</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">set(name, value) {</span><span class="s2">\n      </span><span class="s1">map.set(name, value);</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">flash(name, value) {</span><span class="s2">\n      </span><span class="s1">map.set(flash(name), value);</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">unset(name) {</span><span class="s2">\n      </span><span class="s1">map.delete(name);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">var isSession = (object) =&gt; {</span><span class="s2">\n  </span><span class="s1">return object != null &amp;&amp; typeof object.id === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; typeof object.data !== </span><span class="s2">\&quot;</span><span class="s1">undefined</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; typeof object.has === </span><span class="s2">\&quot;</span><span class="s1">function</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; typeof object.get === </span><span class="s2">\&quot;</span><span class="s1">function</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; typeof object.set === </span><span class="s2">\&quot;</span><span class="s1">function</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; typeof object.flash === </span><span class="s2">\&quot;</span><span class="s1">function</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; typeof object.unset === </span><span class="s2">\&quot;</span><span class="s1">function</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">function createSessionStorage({</span><span class="s2">\n  </span><span class="s1">cookie: cookieArg,</span><span class="s2">\n  </span><span class="s1">createData,</span><span class="s2">\n  </span><span class="s1">readData,</span><span class="s2">\n  </span><span class="s1">updateData,</span><span class="s2">\n  </span><span class="s1">deleteData</span><span class="s2">\n</span><span class="s1">}) {</span><span class="s2">\n  </span><span class="s1">let cookie = isCookie(cookieArg) ? cookieArg : createCookie(cookieArg?.name || </span><span class="s2">\&quot;</span><span class="s1">__session</span><span class="s2">\&quot;</span><span class="s1">, cookieArg);</span><span class="s2">\n  </span><span class="s1">warnOnceAboutSigningSessionCookie(cookie);</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">async getSession(cookieHeader, options) {</span><span class="s2">\n      </span><span class="s1">let id = cookieHeader &amp;&amp; await cookie.parse(cookieHeader, options);</span><span class="s2">\n      </span><span class="s1">let data2 = id &amp;&amp; await readData(id);</span><span class="s2">\n      </span><span class="s1">return createSession(data2 || {}, id || </span><span class="s2">\&quot;\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">async commitSession(session, options) {</span><span class="s2">\n      </span><span class="s1">let { id, data: data2 } = session;</span><span class="s2">\n      </span><span class="s1">let expires = options?.maxAge != null ? new Date(Date.now() + options.maxAge * 1e3) : options?.expires != null ? options.expires : cookie.expires;</span><span class="s2">\n      </span><span class="s1">if (id) {</span><span class="s2">\n        </span><span class="s1">await updateData(id, data2, expires);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">id = await createData(data2, expires);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return cookie.serialize(id, options);</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">async destroySession(session, options) {</span><span class="s2">\n      </span><span class="s1">await deleteData(session.id);</span><span class="s2">\n      </span><span class="s1">return cookie.serialize(</span><span class="s2">\&quot;\&quot;</span><span class="s1">, {</span><span class="s2">\n        </span><span class="s1">...options,</span><span class="s2">\n        </span><span class="s1">maxAge: void 0,</span><span class="s2">\n        </span><span class="s1">expires: /* @__PURE__ */ new Date(0)</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function warnOnceAboutSigningSessionCookie(cookie) {</span><span class="s2">\n  </span><span class="s1">warnOnce(</span><span class="s2">\n    </span><span class="s1">cookie.isSigned,</span><span class="s2">\n    </span><span class="s1">`The </span><span class="s2">\&quot;</span><span class="s1">${cookie.name}</span><span class="s2">\&quot; </span><span class="s1">cookie is not signed, but session cookies should be signed to prevent tampering on the client before they are sent back to the server. See https://reactrouter.com/explanation/sessions-and-cookies#signing-cookies for more information.`</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/server-runtime/sessions/cookieStorage.ts</span><span class="s2">\n</span><span class="s1">function createCookieSessionStorage({ cookie: cookieArg } = {}) {</span><span class="s2">\n  </span><span class="s1">let cookie = isCookie(cookieArg) ? cookieArg : createCookie(cookieArg?.name || </span><span class="s2">\&quot;</span><span class="s1">__session</span><span class="s2">\&quot;</span><span class="s1">, cookieArg);</span><span class="s2">\n  </span><span class="s1">warnOnceAboutSigningSessionCookie(cookie);</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">async getSession(cookieHeader, options) {</span><span class="s2">\n      </span><span class="s1">return createSession(</span><span class="s2">\n        </span><span class="s1">cookieHeader &amp;&amp; await cookie.parse(cookieHeader, options) || {}</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">async commitSession(session, options) {</span><span class="s2">\n      </span><span class="s1">let serializedCookie = await cookie.serialize(session.data, options);</span><span class="s2">\n      </span><span class="s1">if (serializedCookie.length &gt; 4096) {</span><span class="s2">\n        </span><span class="s1">throw new Error(</span><span class="s2">\n          \&quot;</span><span class="s1">Cookie length will exceed browser maximum. Length: </span><span class="s2">\&quot; </span><span class="s1">+ serializedCookie.length</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return serializedCookie;</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">async destroySession(_session, options) {</span><span class="s2">\n      </span><span class="s1">return cookie.serialize(</span><span class="s2">\&quot;\&quot;</span><span class="s1">, {</span><span class="s2">\n        </span><span class="s1">...options,</span><span class="s2">\n        </span><span class="s1">maxAge: void 0,</span><span class="s2">\n        </span><span class="s1">expires: /* @__PURE__ */ new Date(0)</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/server-runtime/sessions/memoryStorage.ts</span><span class="s2">\n</span><span class="s1">function createMemorySessionStorage({ cookie } = {}) {</span><span class="s2">\n  </span><span class="s1">let map = /* @__PURE__ */ new Map();</span><span class="s2">\n  </span><span class="s1">return createSessionStorage({</span><span class="s2">\n    </span><span class="s1">cookie,</span><span class="s2">\n    </span><span class="s1">async createData(data2, expires) {</span><span class="s2">\n      </span><span class="s1">let id = Math.random().toString(36).substring(2, 10);</span><span class="s2">\n      </span><span class="s1">map.set(id, { data: data2, expires });</span><span class="s2">\n      </span><span class="s1">return id;</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">async readData(id) {</span><span class="s2">\n      </span><span class="s1">if (map.has(id)) {</span><span class="s2">\n        </span><span class="s1">let { data: data2, expires } = map.get(id);</span><span class="s2">\n        </span><span class="s1">if (!expires || expires &gt; /* @__PURE__ */ new Date()) {</span><span class="s2">\n          </span><span class="s1">return data2;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (expires) map.delete(id);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return null;</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">async updateData(id, data2, expires) {</span><span class="s2">\n      </span><span class="s1">map.set(id, { data: data2, expires });</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">async deleteData(id) {</span><span class="s2">\n      </span><span class="s1">map.delete(id);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/href.ts</span><span class="s2">\n</span><span class="s1">function href(path, ...args) {</span><span class="s2">\n  </span><span class="s1">let params = args[0];</span><span class="s2">\n  </span><span class="s1">return path.split(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">).map((segment) =&gt; {</span><span class="s2">\n    </span><span class="s1">const match = segment.match(/^:([</span><span class="s2">\\</span><span class="s1">w-]+)(</span><span class="s2">\\</span><span class="s1">?)?/);</span><span class="s2">\n    </span><span class="s1">if (!match) return segment;</span><span class="s2">\n    </span><span class="s1">const param = match[1];</span><span class="s2">\n    </span><span class="s1">const value = params ? params[param] : void 0;</span><span class="s2">\n    </span><span class="s1">const isRequired = match[2] === void 0;</span><span class="s2">\n    </span><span class="s1">if (isRequired &amp;&amp; value === void 0) {</span><span class="s2">\n      </span><span class="s1">throw Error(</span><span class="s2">\n        </span><span class="s1">`Path '${path}' requires param '${param}' but it was not provided`</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return value;</span><span class="s2">\n  </span><span class="s1">}).filter((segment) =&gt; segment !== void 0).join(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/dom/ssr/errors.ts</span><span class="s2">\n</span><span class="s1">function deserializeErrors2(errors) {</span><span class="s2">\n  </span><span class="s1">if (!errors) return null;</span><span class="s2">\n  </span><span class="s1">let entries = Object.entries(errors);</span><span class="s2">\n  </span><span class="s1">let serialized = {};</span><span class="s2">\n  </span><span class="s1">for (let [key, val] of entries) {</span><span class="s2">\n    </span><span class="s1">if (val &amp;&amp; val.__type === </span><span class="s2">\&quot;</span><span class="s1">RouteErrorResponse</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">serialized[key] = new ErrorResponseImpl(</span><span class="s2">\n        </span><span class="s1">val.status,</span><span class="s2">\n        </span><span class="s1">val.statusText,</span><span class="s2">\n        </span><span class="s1">val.data,</span><span class="s2">\n        </span><span class="s1">val.internal === true</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">} else if (val &amp;&amp; val.__type === </span><span class="s2">\&quot;</span><span class="s1">Error</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">if (val.__subType) {</span><span class="s2">\n        </span><span class="s1">let ErrorConstructor = window[val.__subType];</span><span class="s2">\n        </span><span class="s1">if (typeof ErrorConstructor === </span><span class="s2">\&quot;</span><span class="s1">function</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">try {</span><span class="s2">\n            </span><span class="s1">let error = new ErrorConstructor(val.message);</span><span class="s2">\n            </span><span class="s1">error.stack = val.stack;</span><span class="s2">\n            </span><span class="s1">serialized[key] = error;</span><span class="s2">\n          </span><span class="s1">} catch (e) {</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (serialized[key] == null) {</span><span class="s2">\n        </span><span class="s1">let error = new Error(val.message);</span><span class="s2">\n        </span><span class="s1">error.stack = val.stack;</span><span class="s2">\n        </span><span class="s1">serialized[key] = error;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">serialized[key] = val;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return serialized;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// lib/dom/ssr/hydration.tsx</span><span class="s2">\n</span><span class="s1">function getHydrationData(state, routes, getRouteInfo, location, basename, isSpaMode) {</span><span class="s2">\n  </span><span class="s1">let hydrationData = {</span><span class="s2">\n    </span><span class="s1">...state,</span><span class="s2">\n    </span><span class="s1">loaderData: { ...state.loaderData }</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">let initialMatches = matchRoutes(routes, location, basename);</span><span class="s2">\n  </span><span class="s1">if (initialMatches) {</span><span class="s2">\n    </span><span class="s1">for (let match of initialMatches) {</span><span class="s2">\n      </span><span class="s1">let routeId = match.route.id;</span><span class="s2">\n      </span><span class="s1">let routeInfo = getRouteInfo(routeId);</span><span class="s2">\n      </span><span class="s1">if (shouldHydrateRouteLoader(</span><span class="s2">\n        </span><span class="s1">routeId,</span><span class="s2">\n        </span><span class="s1">routeInfo.clientLoader,</span><span class="s2">\n        </span><span class="s1">routeInfo.hasLoader,</span><span class="s2">\n        </span><span class="s1">isSpaMode</span><span class="s2">\n      </span><span class="s1">) &amp;&amp; (routeInfo.hasHydrateFallback || !routeInfo.hasLoader)) {</span><span class="s2">\n        </span><span class="s1">delete hydrationData.loaderData[routeId];</span><span class="s2">\n      </span><span class="s1">} else if (!routeInfo.hasLoader) {</span><span class="s2">\n        </span><span class="s1">hydrationData.loaderData[routeId] = null;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return hydrationData;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">export {</span><span class="s2">\n  </span><span class="s1">Action,</span><span class="s2">\n  </span><span class="s1">createBrowserHistory,</span><span class="s2">\n  </span><span class="s1">invariant,</span><span class="s2">\n  </span><span class="s1">createPath,</span><span class="s2">\n  </span><span class="s1">parsePath,</span><span class="s2">\n  </span><span class="s1">unstable_createContext,</span><span class="s2">\n  </span><span class="s1">unstable_RouterContextProvider,</span><span class="s2">\n  </span><span class="s1">matchRoutes,</span><span class="s2">\n  </span><span class="s1">generatePath,</span><span class="s2">\n  </span><span class="s1">matchPath,</span><span class="s2">\n  </span><span class="s1">resolvePath,</span><span class="s2">\n  </span><span class="s1">data,</span><span class="s2">\n  </span><span class="s1">redirect,</span><span class="s2">\n  </span><span class="s1">redirectDocument,</span><span class="s2">\n  </span><span class="s1">replace,</span><span class="s2">\n  </span><span class="s1">ErrorResponseImpl,</span><span class="s2">\n  </span><span class="s1">isRouteErrorResponse,</span><span class="s2">\n  </span><span class="s1">IDLE_NAVIGATION,</span><span class="s2">\n  </span><span class="s1">IDLE_FETCHER,</span><span class="s2">\n  </span><span class="s1">IDLE_BLOCKER,</span><span class="s2">\n  </span><span class="s1">createRouter,</span><span class="s2">\n  </span><span class="s1">DataRouterContext,</span><span class="s2">\n  </span><span class="s1">DataRouterStateContext,</span><span class="s2">\n  </span><span class="s1">ViewTransitionContext,</span><span class="s2">\n  </span><span class="s1">FetchersContext,</span><span class="s2">\n  </span><span class="s1">NavigationContext,</span><span class="s2">\n  </span><span class="s1">LocationContext,</span><span class="s2">\n  </span><span class="s1">RouteContext,</span><span class="s2">\n  </span><span class="s1">useHref,</span><span class="s2">\n  </span><span class="s1">useInRouterContext,</span><span class="s2">\n  </span><span class="s1">useLocation,</span><span class="s2">\n  </span><span class="s1">useNavigationType,</span><span class="s2">\n  </span><span class="s1">useMatch,</span><span class="s2">\n  </span><span class="s1">useNavigate,</span><span class="s2">\n  </span><span class="s1">useOutletContext,</span><span class="s2">\n  </span><span class="s1">useOutlet,</span><span class="s2">\n  </span><span class="s1">useParams,</span><span class="s2">\n  </span><span class="s1">useResolvedPath,</span><span class="s2">\n  </span><span class="s1">useRoutes,</span><span class="s2">\n  </span><span class="s1">useNavigation,</span><span class="s2">\n  </span><span class="s1">useRevalidator,</span><span class="s2">\n  </span><span class="s1">useMatches,</span><span class="s2">\n  </span><span class="s1">useLoaderData,</span><span class="s2">\n  </span><span class="s1">useRouteLoaderData,</span><span class="s2">\n  </span><span class="s1">useActionData,</span><span class="s2">\n  </span><span class="s1">useRouteError,</span><span class="s2">\n  </span><span class="s1">useAsyncValue,</span><span class="s2">\n  </span><span class="s1">useAsyncError,</span><span class="s2">\n  </span><span class="s1">useBlocker,</span><span class="s2">\n  </span><span class="s1">mapRouteProperties,</span><span class="s2">\n  </span><span class="s1">hydrationRouteProperties,</span><span class="s2">\n  </span><span class="s1">createMemoryRouter,</span><span class="s2">\n  </span><span class="s1">RouterProvider,</span><span class="s2">\n  </span><span class="s1">MemoryRouter,</span><span class="s2">\n  </span><span class="s1">Navigate,</span><span class="s2">\n  </span><span class="s1">Outlet,</span><span class="s2">\n  </span><span class="s1">Route,</span><span class="s2">\n  </span><span class="s1">Router,</span><span class="s2">\n  </span><span class="s1">Routes,</span><span class="s2">\n  </span><span class="s1">Await,</span><span class="s2">\n  </span><span class="s1">createRoutesFromChildren,</span><span class="s2">\n  </span><span class="s1">createRoutesFromElements,</span><span class="s2">\n  </span><span class="s1">renderMatches,</span><span class="s2">\n  </span><span class="s1">createSearchParams,</span><span class="s2">\n  </span><span class="s1">SingleFetchRedirectSymbol,</span><span class="s2">\n  </span><span class="s1">getTurboStreamSingleFetchDataStrategy,</span><span class="s2">\n  </span><span class="s1">decodeViaTurboStream,</span><span class="s2">\n  </span><span class="s1">RemixErrorBoundary,</span><span class="s2">\n  </span><span class="s1">createClientRoutesWithHMRRevalidationOptOut,</span><span class="s2">\n  </span><span class="s1">createClientRoutes,</span><span class="s2">\n  </span><span class="s1">shouldHydrateRouteLoader,</span><span class="s2">\n  </span><span class="s1">getPatchRoutesOnNavigationFunction,</span><span class="s2">\n  </span><span class="s1">useFogOFWarDiscovery,</span><span class="s2">\n  </span><span class="s1">FrameworkContext,</span><span class="s2">\n  </span><span class="s1">Links,</span><span class="s2">\n  </span><span class="s1">PrefetchPageLinks,</span><span class="s2">\n  </span><span class="s1">Meta,</span><span class="s2">\n  </span><span class="s1">Scripts,</span><span class="s2">\n  </span><span class="s1">createBrowserRouter,</span><span class="s2">\n  </span><span class="s1">createHashRouter,</span><span class="s2">\n  </span><span class="s1">BrowserRouter,</span><span class="s2">\n  </span><span class="s1">HashRouter,</span><span class="s2">\n  </span><span class="s1">HistoryRouter,</span><span class="s2">\n  </span><span class="s1">Link,</span><span class="s2">\n  </span><span class="s1">NavLink,</span><span class="s2">\n  </span><span class="s1">Form,</span><span class="s2">\n  </span><span class="s1">ScrollRestoration,</span><span class="s2">\n  </span><span class="s1">useLinkClickHandler,</span><span class="s2">\n  </span><span class="s1">useSearchParams,</span><span class="s2">\n  </span><span class="s1">useSubmit,</span><span class="s2">\n  </span><span class="s1">useFormAction,</span><span class="s2">\n  </span><span class="s1">useFetcher,</span><span class="s2">\n  </span><span class="s1">useFetchers,</span><span class="s2">\n  </span><span class="s1">useScrollRestoration,</span><span class="s2">\n  </span><span class="s1">useBeforeUnload,</span><span class="s2">\n  </span><span class="s1">usePrompt,</span><span class="s2">\n  </span><span class="s1">useViewTransitionState,</span><span class="s2">\n  </span><span class="s1">StaticRouter,</span><span class="s2">\n  </span><span class="s1">StaticRouterProvider,</span><span class="s2">\n  </span><span class="s1">createStaticHandler2 as createStaticHandler,</span><span class="s2">\n  </span><span class="s1">createStaticRouter,</span><span class="s2">\n  </span><span class="s1">ServerRouter,</span><span class="s2">\n  </span><span class="s1">createRoutesStub,</span><span class="s2">\n  </span><span class="s1">createCookie,</span><span class="s2">\n  </span><span class="s1">isCookie,</span><span class="s2">\n  </span><span class="s1">ServerMode,</span><span class="s2">\n  </span><span class="s1">setDevServerHooks,</span><span class="s2">\n  </span><span class="s1">createRequestHandler,</span><span class="s2">\n  </span><span class="s1">createSession,</span><span class="s2">\n  </span><span class="s1">isSession,</span><span class="s2">\n  </span><span class="s1">createSessionStorage,</span><span class="s2">\n  </span><span class="s1">createCookieSessionStorage,</span><span class="s2">\n  </span><span class="s1">createMemorySessionStorage,</span><span class="s2">\n  </span><span class="s1">href,</span><span class="s2">\n  </span><span class="s1">deserializeErrors2 as deserializeErrors,</span><span class="s2">\n  </span><span class="s1">getHydrationData</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[]},</span><span class="s1">&quot;metadata&quot;</span><span class="s0">:{},</span><span class="s1">&quot;sourceType&quot;</span><span class="s0">:</span><span class="s1">&quot;module&quot;</span><span class="s0">,</span><span class="s1">&quot;externalDependencies&quot;</span><span class="s0">:[]}</span></pre>
</body>
</html>