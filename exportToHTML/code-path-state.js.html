<html>
<head>
<title>code-path-state.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #67a37c; font-style: italic;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #bcbec4;}
.s5 { color: #7a7e85;}
.s6 { color: #cf8e6d;}
.s7 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
code-path-state.js</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* </span><span class="s1">@fileoverview </span><span class="s0">A class to manage state of generating a code path.</span>
 <span class="s0">* </span><span class="s1">@author </span><span class="s0">Toru Nagashima</span>
 <span class="s0">*/</span>

<span class="s3">&quot;use strict&quot;</span><span class="s4">;</span>

<span class="s5">//------------------------------------------------------------------------------</span>
<span class="s5">// Requirements</span>
<span class="s5">//------------------------------------------------------------------------------</span>

<span class="s6">const </span><span class="s2">CodePathSegment </span><span class="s4">= </span><span class="s2">require</span><span class="s4">(</span><span class="s3">&quot;./code-path-segment&quot;</span><span class="s4">),</span>
    <span class="s2">ForkContext </span><span class="s4">= </span><span class="s2">require</span><span class="s4">(</span><span class="s3">&quot;./fork-context&quot;</span><span class="s4">);</span>

<span class="s5">//-----------------------------------------------------------------------------</span>
<span class="s5">// Contexts</span>
<span class="s5">//-----------------------------------------------------------------------------</span>

<span class="s0">/**</span>
 <span class="s0">* Represents the context in which a `break` statement can be used.</span>
 <span class="s0">*</span>
 <span class="s0">* A `break` statement without a label is only valid in a few places in</span>
 <span class="s0">* JavaScript: any type of loop or a `switch` statement. Otherwise, `break`</span>
 <span class="s0">* without a label causes a syntax error. For these contexts, `breakable` is</span>
 <span class="s0">* set to `true` to indicate that a `break` without a label is valid.</span>
 <span class="s0">*</span>
 <span class="s0">* However, a `break` statement with a label is also valid inside of a labeled</span>
 <span class="s0">* statement. For example, this is valid:</span>
 <span class="s0">*</span>
 <span class="s0">*     a : {</span>
 <span class="s0">*         break a;</span>
 <span class="s0">*     }</span>
 <span class="s0">*</span>
 <span class="s0">* The `breakable` property is set false for labeled statements to indicate</span>
 <span class="s0">* that `break` without a label is invalid.</span>
 <span class="s0">*/</span>
<span class="s6">class </span><span class="s2">BreakContext </span><span class="s4">{</span>

    <span class="s0">/**</span>
     <span class="s0">* Creates a new instance.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{BreakContext} upperContext The previous `BreakContext`.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{boolean} breakable Indicates if we are inside a statement where</span>
     <span class="s0">*      `break` without a label will exit the statement.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|null} label The label for the statement.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ForkContext} forkContext The current fork context.</span>
     <span class="s0">*/</span>
    <span class="s2">constructor</span><span class="s4">(</span><span class="s2">upperContext</span><span class="s4">, </span><span class="s2">breakable</span><span class="s4">, </span><span class="s2">label</span><span class="s4">, </span><span class="s2">forkContext</span><span class="s4">) {</span>

        <span class="s0">/**</span>
         <span class="s0">* The previous `BreakContext`</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{BreakContext}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">upper </span><span class="s4">= </span><span class="s2">upperContext</span><span class="s4">;</span>

        <span class="s0">/**</span>
         <span class="s0">* Indicates if we are inside a statement where `break` without a label</span>
         <span class="s0">* will exit the statement.</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{boolean}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">breakable </span><span class="s4">= </span><span class="s2">breakable</span><span class="s4">;</span>

        <span class="s0">/**</span>
         <span class="s0">* The label associated with the statement.</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{string|null}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">label </span><span class="s4">= </span><span class="s2">label</span><span class="s4">;</span>

        <span class="s0">/**</span>
         <span class="s0">* The fork context for the `break`.</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{ForkContext}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">brokenForkContext </span><span class="s4">= </span><span class="s2">ForkContext</span><span class="s4">.</span><span class="s2">newEmpty</span><span class="s4">(</span><span class="s2">forkContext</span><span class="s4">);</span>
    <span class="s4">}</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Represents the context for `ChainExpression` nodes.</span>
 <span class="s0">*/</span>
<span class="s6">class </span><span class="s2">ChainContext </span><span class="s4">{</span>

    <span class="s0">/**</span>
     <span class="s0">* Creates a new instance.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ChainContext} upperContext The previous `ChainContext`.</span>
     <span class="s0">*/</span>
    <span class="s2">constructor</span><span class="s4">(</span><span class="s2">upperContext</span><span class="s4">) {</span>

        <span class="s0">/**</span>
         <span class="s0">* The previous `ChainContext`</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{ChainContext}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">upper </span><span class="s4">= </span><span class="s2">upperContext</span><span class="s4">;</span>

        <span class="s0">/**</span>
         <span class="s0">* The number of choice contexts inside of the `ChainContext`.</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{number}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">choiceContextCount </span><span class="s4">= </span><span class="s7">0</span><span class="s4">;</span>

    <span class="s4">}</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Represents a choice in the code path.</span>
 <span class="s0">*</span>
 <span class="s0">* Choices are created by logical operators such as `&amp;&amp;`, loops, conditionals,</span>
 <span class="s0">* and `if` statements. This is the point at which the code path has a choice of</span>
 <span class="s0">* which direction to go.</span>
 <span class="s0">*</span>
 <span class="s0">* The result of a choice might be in the left (test) expression of another choice,</span>
 <span class="s0">* and in that case, may create a new fork. For example, `a || b` is a choice</span>
 <span class="s0">* but does not create a new fork because the result of the expression is</span>
 <span class="s0">* not used as the test expression in another expression. In this case,</span>
 <span class="s0">* `isForkingAsResult` is false. In the expression `a || b || c`, the `a || b`</span>
 <span class="s0">* expression appears as the test expression for `|| c`, so the</span>
 <span class="s0">* result of `a || b` creates a fork because execution may or may not</span>
 <span class="s0">* continue to `|| c`. `isForkingAsResult` for `a || b` in this case is true</span>
 <span class="s0">* while `isForkingAsResult` for `|| c` is false. (`isForkingAsResult` is always</span>
 <span class="s0">* false for `if` statements, conditional expressions, and loops.)</span>
 <span class="s0">*</span>
 <span class="s0">* All of the choices except one (`??`) operate on a true/false fork, meaning if</span>
 <span class="s0">* true go one way and if false go the other (tracked by `trueForkContext` and</span>
 <span class="s0">* `falseForkContext`). The `??` operator doesn't operate on true/false because</span>
 <span class="s0">* the left expression is evaluated to be nullish or not, so only if nullish do</span>
 <span class="s0">* we fork to the right expression (tracked by `nullishForkContext`).</span>
 <span class="s0">*/</span>
<span class="s6">class </span><span class="s2">ChoiceContext </span><span class="s4">{</span>

    <span class="s0">/**</span>
     <span class="s0">* Creates a new instance.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ChoiceContext} upperContext The previous `ChoiceContext`.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} kind The kind of choice. If it's a logical or assignment expression, this</span>
     <span class="s0">*      is `&quot;&amp;&amp;&quot;` or `&quot;||&quot;` or `&quot;??&quot;`; if it's an `if` statement or</span>
     <span class="s0">*      conditional expression, this is `&quot;test&quot;`; otherwise, this is `&quot;loop&quot;`.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{boolean} isForkingAsResult Indicates if the result of the choice</span>
     <span class="s0">*      creates a fork.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ForkContext} forkContext The containing `ForkContext`.</span>
     <span class="s0">*/</span>
    <span class="s2">constructor</span><span class="s4">(</span><span class="s2">upperContext</span><span class="s4">, </span><span class="s2">kind</span><span class="s4">, </span><span class="s2">isForkingAsResult</span><span class="s4">, </span><span class="s2">forkContext</span><span class="s4">) {</span>

        <span class="s0">/**</span>
         <span class="s0">* The previous `ChoiceContext`</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{ChoiceContext}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">upper </span><span class="s4">= </span><span class="s2">upperContext</span><span class="s4">;</span>

        <span class="s0">/**</span>
         <span class="s0">* The kind of choice. If it's a logical or assignment expression, this</span>
         <span class="s0">* is `&quot;&amp;&amp;&quot;` or `&quot;||&quot;` or `&quot;??&quot;`; if it's an `if` statement or</span>
         <span class="s0">* conditional expression, this is `&quot;test&quot;`; otherwise, this is `&quot;loop&quot;`.</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{string}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">kind </span><span class="s4">= </span><span class="s2">kind</span><span class="s4">;</span>

        <span class="s0">/**</span>
         <span class="s0">* Indicates if the result of the choice forks the code path.</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{boolean}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">isForkingAsResult </span><span class="s4">= </span><span class="s2">isForkingAsResult</span><span class="s4">;</span>

        <span class="s0">/**</span>
         <span class="s0">* The fork context for the `true` path of the choice.</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{ForkContext}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">trueForkContext </span><span class="s4">= </span><span class="s2">ForkContext</span><span class="s4">.</span><span class="s2">newEmpty</span><span class="s4">(</span><span class="s2">forkContext</span><span class="s4">);</span>

        <span class="s0">/**</span>
         <span class="s0">* The fork context for the `false` path of the choice.</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{ForkContext}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">falseForkContext </span><span class="s4">= </span><span class="s2">ForkContext</span><span class="s4">.</span><span class="s2">newEmpty</span><span class="s4">(</span><span class="s2">forkContext</span><span class="s4">);</span>

        <span class="s0">/**</span>
         <span class="s0">* The fork context for when the choice result is `null` or `undefined`.</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{ForkContext}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">nullishForkContext </span><span class="s4">= </span><span class="s2">ForkContext</span><span class="s4">.</span><span class="s2">newEmpty</span><span class="s4">(</span><span class="s2">forkContext</span><span class="s4">);</span>

        <span class="s0">/**</span>
         <span class="s0">* Indicates if any of `trueForkContext`, `falseForkContext`, or</span>
         <span class="s0">* `nullishForkContext` have been updated with segments from a child context.</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{boolean}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">processed </span><span class="s4">= </span><span class="s6">false</span><span class="s4">;</span>
    <span class="s4">}</span>

<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Base class for all loop contexts.</span>
 <span class="s0">*/</span>
<span class="s6">class </span><span class="s2">LoopContextBase </span><span class="s4">{</span>

    <span class="s0">/**</span>
     <span class="s0">* Creates a new instance.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{LoopContext|null} upperContext The previous `LoopContext`.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} type The AST node's `type` for the loop.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|null} label The label for the loop from an enclosing `LabeledStatement`.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{BreakContext} breakContext The context for breaking the loop.</span>
     <span class="s0">*/</span>
    <span class="s2">constructor</span><span class="s4">(</span><span class="s2">upperContext</span><span class="s4">, </span><span class="s2">type</span><span class="s4">, </span><span class="s2">label</span><span class="s4">, </span><span class="s2">breakContext</span><span class="s4">) {</span>

        <span class="s0">/**</span>
         <span class="s0">* The previous `LoopContext`.</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{LoopContext}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">upper </span><span class="s4">= </span><span class="s2">upperContext</span><span class="s4">;</span>

        <span class="s0">/**</span>
         <span class="s0">* The AST node's `type` for the loop.</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{string}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">type </span><span class="s4">= </span><span class="s2">type</span><span class="s4">;</span>

        <span class="s0">/**</span>
         <span class="s0">* The label for the loop from an enclosing `LabeledStatement`.</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{string|null}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">label </span><span class="s4">= </span><span class="s2">label</span><span class="s4">;</span>

        <span class="s0">/**</span>
         <span class="s0">* The fork context for when `break` is encountered.</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{ForkContext}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">brokenForkContext </span><span class="s4">= </span><span class="s2">breakContext</span><span class="s4">.</span><span class="s2">brokenForkContext</span><span class="s4">;</span>
    <span class="s4">}</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Represents the context for a `while` loop.</span>
 <span class="s0">*/</span>
<span class="s6">class </span><span class="s2">WhileLoopContext </span><span class="s6">extends </span><span class="s2">LoopContextBase </span><span class="s4">{</span>

    <span class="s0">/**</span>
     <span class="s0">* Creates a new instance.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{LoopContext|null} upperContext The previous `LoopContext`.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|null} label The label for the loop from an enclosing `LabeledStatement`.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{BreakContext} breakContext The context for breaking the loop.</span>
     <span class="s0">*/</span>
    <span class="s2">constructor</span><span class="s4">(</span><span class="s2">upperContext</span><span class="s4">, </span><span class="s2">label</span><span class="s4">, </span><span class="s2">breakContext</span><span class="s4">) {</span>
        <span class="s6">super</span><span class="s4">(</span><span class="s2">upperContext</span><span class="s4">, </span><span class="s3">&quot;WhileStatement&quot;</span><span class="s4">, </span><span class="s2">label</span><span class="s4">, </span><span class="s2">breakContext</span><span class="s4">);</span>

        <span class="s0">/**</span>
         <span class="s0">* The hardcoded literal boolean test condition for</span>
         <span class="s0">* the loop. Used to catch infinite or skipped loops.</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{boolean|undefined}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">test </span><span class="s4">= </span><span class="s6">void </span><span class="s7">0</span><span class="s4">;</span>

        <span class="s0">/**</span>
         <span class="s0">* The segments representing the test condition where `continue` will</span>
         <span class="s0">* jump to. The test condition will typically have just one segment but</span>
         <span class="s0">* it's possible for there to be more than one.</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{Array&lt;CodePathSegment&gt;|null}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">continueDestSegments </span><span class="s4">= </span><span class="s6">null</span><span class="s4">;</span>
    <span class="s4">}</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Represents the context for a `do-while` loop.</span>
 <span class="s0">*/</span>
<span class="s6">class </span><span class="s2">DoWhileLoopContext </span><span class="s6">extends </span><span class="s2">LoopContextBase </span><span class="s4">{</span>

    <span class="s0">/**</span>
     <span class="s0">* Creates a new instance.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{LoopContext|null} upperContext The previous `LoopContext`.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|null} label The label for the loop from an enclosing `LabeledStatement`.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{BreakContext} breakContext The context for breaking the loop.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ForkContext} forkContext The enclosing fork context.</span>
     <span class="s0">*/</span>
    <span class="s2">constructor</span><span class="s4">(</span><span class="s2">upperContext</span><span class="s4">, </span><span class="s2">label</span><span class="s4">, </span><span class="s2">breakContext</span><span class="s4">, </span><span class="s2">forkContext</span><span class="s4">) {</span>
        <span class="s6">super</span><span class="s4">(</span><span class="s2">upperContext</span><span class="s4">, </span><span class="s3">&quot;DoWhileStatement&quot;</span><span class="s4">, </span><span class="s2">label</span><span class="s4">, </span><span class="s2">breakContext</span><span class="s4">);</span>

        <span class="s0">/**</span>
         <span class="s0">* The hardcoded literal boolean test condition for</span>
         <span class="s0">* the loop. Used to catch infinite or skipped loops.</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{boolean|undefined}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">test </span><span class="s4">= </span><span class="s6">void </span><span class="s7">0</span><span class="s4">;</span>

        <span class="s0">/**</span>
         <span class="s0">* The segments at the start of the loop body. This is the only loop</span>
         <span class="s0">* where the test comes at the end, so the first iteration always</span>
         <span class="s0">* happens and we need a reference to the first statements.</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{Array&lt;CodePathSegment&gt;|null}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">entrySegments </span><span class="s4">= </span><span class="s6">null</span><span class="s4">;</span>

        <span class="s0">/**</span>
         <span class="s0">* The fork context to follow when a `continue` is found.</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{ForkContext}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">continueForkContext </span><span class="s4">= </span><span class="s2">ForkContext</span><span class="s4">.</span><span class="s2">newEmpty</span><span class="s4">(</span><span class="s2">forkContext</span><span class="s4">);</span>
    <span class="s4">}</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Represents the context for a `for` loop.</span>
 <span class="s0">*/</span>
<span class="s6">class </span><span class="s2">ForLoopContext </span><span class="s6">extends </span><span class="s2">LoopContextBase </span><span class="s4">{</span>

    <span class="s0">/**</span>
     <span class="s0">* Creates a new instance.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{LoopContext|null} upperContext The previous `LoopContext`.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|null} label The label for the loop from an enclosing `LabeledStatement`.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{BreakContext} breakContext The context for breaking the loop.</span>
     <span class="s0">*/</span>
    <span class="s2">constructor</span><span class="s4">(</span><span class="s2">upperContext</span><span class="s4">, </span><span class="s2">label</span><span class="s4">, </span><span class="s2">breakContext</span><span class="s4">) {</span>
        <span class="s6">super</span><span class="s4">(</span><span class="s2">upperContext</span><span class="s4">, </span><span class="s3">&quot;ForStatement&quot;</span><span class="s4">, </span><span class="s2">label</span><span class="s4">, </span><span class="s2">breakContext</span><span class="s4">);</span>

        <span class="s0">/**</span>
         <span class="s0">* The hardcoded literal boolean test condition for</span>
         <span class="s0">* the loop. Used to catch infinite or skipped loops.</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{boolean|undefined}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">test </span><span class="s4">= </span><span class="s6">void </span><span class="s7">0</span><span class="s4">;</span>

        <span class="s0">/**</span>
         <span class="s0">* The end of the init expression. This may change during the lifetime</span>
         <span class="s0">* of the instance as we traverse the loop because some loops don't have</span>
         <span class="s0">* an init expression.</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{Array&lt;CodePathSegment&gt;|null}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">endOfInitSegments </span><span class="s4">= </span><span class="s6">null</span><span class="s4">;</span>

        <span class="s0">/**</span>
         <span class="s0">* The start of the test expression. This may change during the lifetime</span>
         <span class="s0">* of the instance as we traverse the loop because some loops don't have</span>
         <span class="s0">* a test expression.</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{Array&lt;CodePathSegment&gt;|null}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">testSegments </span><span class="s4">= </span><span class="s6">null</span><span class="s4">;</span>

        <span class="s0">/**</span>
         <span class="s0">* The end of the test expression. This may change during the lifetime</span>
         <span class="s0">* of the instance as we traverse the loop because some loops don't have</span>
         <span class="s0">* a test expression.</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{Array&lt;CodePathSegment&gt;|null}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">endOfTestSegments </span><span class="s4">= </span><span class="s6">null</span><span class="s4">;</span>

        <span class="s0">/**</span>
         <span class="s0">* The start of the update expression. This may change during the lifetime</span>
         <span class="s0">* of the instance as we traverse the loop because some loops don't have</span>
         <span class="s0">* an update expression.</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{Array&lt;CodePathSegment&gt;|null}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">updateSegments </span><span class="s4">= </span><span class="s6">null</span><span class="s4">;</span>

        <span class="s0">/**</span>
         <span class="s0">* The end of the update expresion. This may change during the lifetime</span>
         <span class="s0">* of the instance as we traverse the loop because some loops don't have</span>
         <span class="s0">* an update expression.</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{Array&lt;CodePathSegment&gt;|null}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">endOfUpdateSegments </span><span class="s4">= </span><span class="s6">null</span><span class="s4">;</span>

        <span class="s0">/**</span>
         <span class="s0">* The segments representing the test condition where `continue` will</span>
         <span class="s0">* jump to. The test condition will typically have just one segment but</span>
         <span class="s0">* it's possible for there to be more than one. This may change during the</span>
         <span class="s0">* lifetime of the instance as we traverse the loop because some loops</span>
         <span class="s0">* don't have an update expression. When there is an update expression, this</span>
         <span class="s0">* will end up pointing to that expression; otherwise it will end up pointing</span>
         <span class="s0">* to the test expression.</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{Array&lt;CodePathSegment&gt;|null}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">continueDestSegments </span><span class="s4">= </span><span class="s6">null</span><span class="s4">;</span>
    <span class="s4">}</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Represents the context for a `for-in` loop.</span>
 <span class="s0">*</span>
 <span class="s0">* Terminology:</span>
 <span class="s0">* - &quot;left&quot; means the part of the loop to the left of the `in` keyword. For</span>
 <span class="s0">*   example, in `for (var x in y)`, the left is `var x`.</span>
 <span class="s0">* - &quot;right&quot; means the part of the loop to the right of the `in` keyword. For</span>
 <span class="s0">*   example, in `for (var x in y)`, the right is `y`.</span>
 <span class="s0">*/</span>
<span class="s6">class </span><span class="s2">ForInLoopContext </span><span class="s6">extends </span><span class="s2">LoopContextBase </span><span class="s4">{</span>

    <span class="s0">/**</span>
     <span class="s0">* Creates a new instance.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{LoopContext|null} upperContext The previous `LoopContext`.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|null} label The label for the loop from an enclosing `LabeledStatement`.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{BreakContext} breakContext The context for breaking the loop.</span>
     <span class="s0">*/</span>
    <span class="s2">constructor</span><span class="s4">(</span><span class="s2">upperContext</span><span class="s4">, </span><span class="s2">label</span><span class="s4">, </span><span class="s2">breakContext</span><span class="s4">) {</span>
        <span class="s6">super</span><span class="s4">(</span><span class="s2">upperContext</span><span class="s4">, </span><span class="s3">&quot;ForInStatement&quot;</span><span class="s4">, </span><span class="s2">label</span><span class="s4">, </span><span class="s2">breakContext</span><span class="s4">);</span>

        <span class="s0">/**</span>
         <span class="s0">* The segments that came immediately before the start of the loop.</span>
         <span class="s0">* This allows you to traverse backwards out of the loop into the</span>
         <span class="s0">* surrounding code. This is necessary to evaluate the right expression</span>
         <span class="s0">* correctly, as it must be evaluated in the same way as the left</span>
         <span class="s0">* expression, but the pointer to these segments would otherwise be</span>
         <span class="s0">* lost if not stored on the instance. Once the right expression has</span>
         <span class="s0">* been evaluated, this property is no longer used.</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{Array&lt;CodePathSegment&gt;|null}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">prevSegments </span><span class="s4">= </span><span class="s6">null</span><span class="s4">;</span>

        <span class="s0">/**</span>
         <span class="s0">* Segments representing the start of everything to the left of the</span>
         <span class="s0">* `in` keyword. This can be used to move forward towards</span>
         <span class="s0">* `endOfLeftSegments`. `leftSegments` and `endOfLeftSegments` are</span>
         <span class="s0">* effectively the head and tail of a doubly-linked list.</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{Array&lt;CodePathSegment&gt;|null}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">leftSegments </span><span class="s4">= </span><span class="s6">null</span><span class="s4">;</span>

        <span class="s0">/**</span>
         <span class="s0">* Segments representing the end of everything to the left of the</span>
         <span class="s0">* `in` keyword. This can be used to move backward towards `leftSegments`.</span>
         <span class="s0">* `leftSegments` and `endOfLeftSegments` are effectively the head</span>
         <span class="s0">* and tail of a doubly-linked list.</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{Array&lt;CodePathSegment&gt;|null}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">endOfLeftSegments </span><span class="s4">= </span><span class="s6">null</span><span class="s4">;</span>

        <span class="s0">/**</span>
         <span class="s0">* The segments representing the left expression where `continue` will</span>
         <span class="s0">* jump to. In `for-in` loops, `continue` must always re-execute the</span>
         <span class="s0">* left expression each time through the loop. This contains the same</span>
         <span class="s0">* segments as `leftSegments`, but is duplicated here so each loop</span>
         <span class="s0">* context has the same property pointing to where `continue` should</span>
         <span class="s0">* end up.</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{Array&lt;CodePathSegment&gt;|null}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">continueDestSegments </span><span class="s4">= </span><span class="s6">null</span><span class="s4">;</span>
    <span class="s4">}</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Represents the context for a `for-of` loop.</span>
 <span class="s0">*/</span>
<span class="s6">class </span><span class="s2">ForOfLoopContext </span><span class="s6">extends </span><span class="s2">LoopContextBase </span><span class="s4">{</span>

    <span class="s0">/**</span>
     <span class="s0">* Creates a new instance.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{LoopContext|null} upperContext The previous `LoopContext`.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|null} label The label for the loop from an enclosing `LabeledStatement`.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{BreakContext} breakContext The context for breaking the loop.</span>
     <span class="s0">*/</span>
    <span class="s2">constructor</span><span class="s4">(</span><span class="s2">upperContext</span><span class="s4">, </span><span class="s2">label</span><span class="s4">, </span><span class="s2">breakContext</span><span class="s4">) {</span>
        <span class="s6">super</span><span class="s4">(</span><span class="s2">upperContext</span><span class="s4">, </span><span class="s3">&quot;ForOfStatement&quot;</span><span class="s4">, </span><span class="s2">label</span><span class="s4">, </span><span class="s2">breakContext</span><span class="s4">);</span>

        <span class="s0">/**</span>
         <span class="s0">* The segments that came immediately before the start of the loop.</span>
         <span class="s0">* This allows you to traverse backwards out of the loop into the</span>
         <span class="s0">* surrounding code. This is necessary to evaluate the right expression</span>
         <span class="s0">* correctly, as it must be evaluated in the same way as the left</span>
         <span class="s0">* expression, but the pointer to these segments would otherwise be</span>
         <span class="s0">* lost if not stored on the instance. Once the right expression has</span>
         <span class="s0">* been evaluated, this property is no longer used.</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{Array&lt;CodePathSegment&gt;|null}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">prevSegments </span><span class="s4">= </span><span class="s6">null</span><span class="s4">;</span>

        <span class="s0">/**</span>
         <span class="s0">* Segments representing the start of everything to the left of the</span>
         <span class="s0">* `of` keyword. This can be used to move forward towards</span>
         <span class="s0">* `endOfLeftSegments`. `leftSegments` and `endOfLeftSegments` are</span>
         <span class="s0">* effectively the head and tail of a doubly-linked list.</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{Array&lt;CodePathSegment&gt;|null}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">leftSegments </span><span class="s4">= </span><span class="s6">null</span><span class="s4">;</span>

        <span class="s0">/**</span>
         <span class="s0">* Segments representing the end of everything to the left of the</span>
         <span class="s0">* `of` keyword. This can be used to move backward towards `leftSegments`.</span>
         <span class="s0">* `leftSegments` and `endOfLeftSegments` are effectively the head</span>
         <span class="s0">* and tail of a doubly-linked list.</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{Array&lt;CodePathSegment&gt;|null}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">endOfLeftSegments </span><span class="s4">= </span><span class="s6">null</span><span class="s4">;</span>

        <span class="s0">/**</span>
         <span class="s0">* The segments representing the left expression where `continue` will</span>
         <span class="s0">* jump to. In `for-in` loops, `continue` must always re-execute the</span>
         <span class="s0">* left expression each time through the loop. This contains the same</span>
         <span class="s0">* segments as `leftSegments`, but is duplicated here so each loop</span>
         <span class="s0">* context has the same property pointing to where `continue` should</span>
         <span class="s0">* end up.</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{Array&lt;CodePathSegment&gt;|null}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">continueDestSegments </span><span class="s4">= </span><span class="s6">null</span><span class="s4">;</span>
    <span class="s4">}</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Represents the context for any loop.</span>
 <span class="s0">* </span><span class="s1">@typedef </span><span class="s0">{WhileLoopContext|DoWhileLoopContext|ForLoopContext|ForInLoopContext|ForOfLoopContext} LoopContext</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Represents the context for a `switch` statement.</span>
 <span class="s0">*/</span>
<span class="s6">class </span><span class="s2">SwitchContext </span><span class="s4">{</span>

    <span class="s0">/**</span>
     <span class="s0">* Creates a new instance.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{SwitchContext} upperContext The previous context.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{boolean} hasCase Indicates if there is at least one `case` statement.</span>
     <span class="s0">*      `default` doesn't count.</span>
     <span class="s0">*/</span>
    <span class="s2">constructor</span><span class="s4">(</span><span class="s2">upperContext</span><span class="s4">, </span><span class="s2">hasCase</span><span class="s4">) {</span>

        <span class="s0">/**</span>
         <span class="s0">* The previous context.</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{SwitchContext}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">upper </span><span class="s4">= </span><span class="s2">upperContext</span><span class="s4">;</span>

        <span class="s0">/**</span>
         <span class="s0">* Indicates if there is at least one `case` statement. `default` doesn't count.</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{boolean}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">hasCase </span><span class="s4">= </span><span class="s2">hasCase</span><span class="s4">;</span>

        <span class="s0">/**</span>
         <span class="s0">* The `default` keyword.</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{Array&lt;CodePathSegment&gt;|null}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">defaultSegments </span><span class="s4">= </span><span class="s6">null</span><span class="s4">;</span>

        <span class="s0">/**</span>
         <span class="s0">* The default case body starting segments.</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{Array&lt;CodePathSegment&gt;|null}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">defaultBodySegments </span><span class="s4">= </span><span class="s6">null</span><span class="s4">;</span>

        <span class="s0">/**</span>
         <span class="s0">* Indicates if a `default` case and is empty exists.</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{boolean}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">foundEmptyDefault </span><span class="s4">= </span><span class="s6">false</span><span class="s4">;</span>

        <span class="s0">/**</span>
         <span class="s0">* Indicates that a `default` exists and is the last case.</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{boolean}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">lastIsDefault </span><span class="s4">= </span><span class="s6">false</span><span class="s4">;</span>

        <span class="s0">/**</span>
         <span class="s0">* The number of fork contexts created. This is equivalent to the</span>
         <span class="s0">* number of `case` statements plus a `default` statement (if present).</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{number}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">forkCount </span><span class="s4">= </span><span class="s7">0</span><span class="s4">;</span>
    <span class="s4">}</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Represents the context for a `try` statement.</span>
 <span class="s0">*/</span>
<span class="s6">class </span><span class="s2">TryContext </span><span class="s4">{</span>

    <span class="s0">/**</span>
     <span class="s0">* Creates a new instance.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{TryContext} upperContext The previous context.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{boolean} hasFinalizer Indicates if the `try` statement has a</span>
     <span class="s0">*      `finally` block.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ForkContext} forkContext The enclosing fork context.</span>
     <span class="s0">*/</span>
    <span class="s2">constructor</span><span class="s4">(</span><span class="s2">upperContext</span><span class="s4">, </span><span class="s2">hasFinalizer</span><span class="s4">, </span><span class="s2">forkContext</span><span class="s4">) {</span>

        <span class="s0">/**</span>
         <span class="s0">* The previous context.</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{TryContext}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">upper </span><span class="s4">= </span><span class="s2">upperContext</span><span class="s4">;</span>

        <span class="s0">/**</span>
         <span class="s0">* Indicates if the `try` statement has a `finally` block.</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{boolean}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">hasFinalizer </span><span class="s4">= </span><span class="s2">hasFinalizer</span><span class="s4">;</span>

        <span class="s0">/**</span>
         <span class="s0">* Tracks the traversal position inside of the `try` statement. This is</span>
         <span class="s0">* used to help determine the context necessary to create paths because</span>
         <span class="s0">* a `try` statement may or may not have `catch` or `finally` blocks,</span>
         <span class="s0">* and code paths behave differently in those blocks.</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{&quot;try&quot;|&quot;catch&quot;|&quot;finally&quot;}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">position </span><span class="s4">= </span><span class="s3">&quot;try&quot;</span><span class="s4">;</span>

        <span class="s0">/**</span>
         <span class="s0">* If the `try` statement has a `finally` block, this affects how a</span>
         <span class="s0">* `return` statement behaves in the `try` block. Without `finally`,</span>
         <span class="s0">* `return` behaves as usual and doesn't require a fork; with `finally`,</span>
         <span class="s0">* `return` forks into the `finally` block, so we need a fork context</span>
         <span class="s0">* to track it.</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{ForkContext|null}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">returnedForkContext </span><span class="s4">= </span><span class="s2">hasFinalizer</span>
            <span class="s4">? </span><span class="s2">ForkContext</span><span class="s4">.</span><span class="s2">newEmpty</span><span class="s4">(</span><span class="s2">forkContext</span><span class="s4">)</span>
            <span class="s4">: </span><span class="s6">null</span><span class="s4">;</span>

        <span class="s0">/**</span>
         <span class="s0">* When a `throw` occurs inside of a `try` block, the code path forks</span>
         <span class="s0">* into the `catch` or `finally` blocks, and this fork context tracks</span>
         <span class="s0">* that path.</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{ForkContext}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">thrownForkContext </span><span class="s4">= </span><span class="s2">ForkContext</span><span class="s4">.</span><span class="s2">newEmpty</span><span class="s4">(</span><span class="s2">forkContext</span><span class="s4">);</span>

        <span class="s0">/**</span>
         <span class="s0">* Indicates if the last segment in the `try` block is reachable.</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{boolean}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">lastOfTryIsReachable </span><span class="s4">= </span><span class="s6">false</span><span class="s4">;</span>

        <span class="s0">/**</span>
         <span class="s0">* Indicates if the last segment in the `catch` block is reachable.</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{boolean}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">lastOfCatchIsReachable </span><span class="s4">= </span><span class="s6">false</span><span class="s4">;</span>
    <span class="s4">}</span>
<span class="s4">}</span>

<span class="s5">//------------------------------------------------------------------------------</span>
<span class="s5">// Helpers</span>
<span class="s5">//------------------------------------------------------------------------------</span>

<span class="s0">/**</span>
 <span class="s0">* Adds given segments into the `dest` array.</span>
 <span class="s0">* If the `others` array does not include the given segments, adds to the `all`</span>
 <span class="s0">* array as well.</span>
 <span class="s0">*</span>
 <span class="s0">* This adds only reachable and used segments.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{CodePathSegment[]} dest A destination array (`returnedSegments` or `thrownSegments`).</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{CodePathSegment[]} others Another destination array (`returnedSegments` or `thrownSegments`).</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{CodePathSegment[]} all The unified destination array (`finalSegments`).</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{CodePathSegment[]} segments Segments to add.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
 <span class="s0">*/</span>
<span class="s6">function </span><span class="s2">addToReturnedOrThrown</span><span class="s4">(</span><span class="s2">dest</span><span class="s4">, </span><span class="s2">others</span><span class="s4">, </span><span class="s2">all</span><span class="s4">, </span><span class="s2">segments</span><span class="s4">) {</span>
    <span class="s6">for </span><span class="s4">(</span><span class="s6">let </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s2">segments</span><span class="s4">.</span><span class="s2">length</span><span class="s4">; ++</span><span class="s2">i</span><span class="s4">) {</span>
        <span class="s6">const </span><span class="s2">segment </span><span class="s4">= </span><span class="s2">segments</span><span class="s4">[</span><span class="s2">i</span><span class="s4">];</span>

        <span class="s2">dest</span><span class="s4">.</span><span class="s2">push</span><span class="s4">(</span><span class="s2">segment</span><span class="s4">);</span>
        <span class="s6">if </span><span class="s4">(!</span><span class="s2">others</span><span class="s4">.</span><span class="s2">includes</span><span class="s4">(</span><span class="s2">segment</span><span class="s4">)) {</span>
            <span class="s2">all</span><span class="s4">.</span><span class="s2">push</span><span class="s4">(</span><span class="s2">segment</span><span class="s4">);</span>
        <span class="s4">}</span>
    <span class="s4">}</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Gets a loop context for a `continue` statement based on a given label.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{CodePathState} state The state to search within.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|null} label The label of a `continue` statement.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{LoopContext} A loop-context for a `continue` statement.</span>
 <span class="s0">*/</span>
<span class="s6">function </span><span class="s2">getContinueContext</span><span class="s4">(</span><span class="s2">state</span><span class="s4">, </span><span class="s2">label</span><span class="s4">) {</span>
    <span class="s6">if </span><span class="s4">(!</span><span class="s2">label</span><span class="s4">) {</span>
        <span class="s6">return </span><span class="s2">state</span><span class="s4">.</span><span class="s2">loopContext</span><span class="s4">;</span>
    <span class="s4">}</span>

    <span class="s6">let </span><span class="s2">context </span><span class="s4">= </span><span class="s2">state</span><span class="s4">.</span><span class="s2">loopContext</span><span class="s4">;</span>

    <span class="s6">while </span><span class="s4">(</span><span class="s2">context</span><span class="s4">) {</span>
        <span class="s6">if </span><span class="s4">(</span><span class="s2">context</span><span class="s4">.</span><span class="s2">label </span><span class="s4">=== </span><span class="s2">label</span><span class="s4">) {</span>
            <span class="s6">return </span><span class="s2">context</span><span class="s4">;</span>
        <span class="s4">}</span>
        <span class="s2">context </span><span class="s4">= </span><span class="s2">context</span><span class="s4">.</span><span class="s2">upper</span><span class="s4">;</span>
    <span class="s4">}</span>

    <span class="s5">/* c8 ignore next */</span>
    <span class="s6">return null</span><span class="s4">;</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Gets a context for a `break` statement.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{CodePathState} state The state to search within.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|null} label The label of a `break` statement.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{BreakContext} A context for a `break` statement.</span>
 <span class="s0">*/</span>
<span class="s6">function </span><span class="s2">getBreakContext</span><span class="s4">(</span><span class="s2">state</span><span class="s4">, </span><span class="s2">label</span><span class="s4">) {</span>
    <span class="s6">let </span><span class="s2">context </span><span class="s4">= </span><span class="s2">state</span><span class="s4">.</span><span class="s2">breakContext</span><span class="s4">;</span>

    <span class="s6">while </span><span class="s4">(</span><span class="s2">context</span><span class="s4">) {</span>
        <span class="s6">if </span><span class="s4">(</span><span class="s2">label </span><span class="s4">? </span><span class="s2">context</span><span class="s4">.</span><span class="s2">label </span><span class="s4">=== </span><span class="s2">label </span><span class="s4">: </span><span class="s2">context</span><span class="s4">.</span><span class="s2">breakable</span><span class="s4">) {</span>
            <span class="s6">return </span><span class="s2">context</span><span class="s4">;</span>
        <span class="s4">}</span>
        <span class="s2">context </span><span class="s4">= </span><span class="s2">context</span><span class="s4">.</span><span class="s2">upper</span><span class="s4">;</span>
    <span class="s4">}</span>

    <span class="s5">/* c8 ignore next */</span>
    <span class="s6">return null</span><span class="s4">;</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Gets a context for a `return` statement. There is just one special case:</span>
 <span class="s0">* if there is a `try` statement with a `finally` block, because that alters</span>
 <span class="s0">* how `return` behaves; otherwise, this just passes through the given state.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{CodePathState} state The state to search within</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{TryContext|CodePathState} A context for a `return` statement.</span>
 <span class="s0">*/</span>
<span class="s6">function </span><span class="s2">getReturnContext</span><span class="s4">(</span><span class="s2">state</span><span class="s4">) {</span>
    <span class="s6">let </span><span class="s2">context </span><span class="s4">= </span><span class="s2">state</span><span class="s4">.</span><span class="s2">tryContext</span><span class="s4">;</span>

    <span class="s6">while </span><span class="s4">(</span><span class="s2">context</span><span class="s4">) {</span>
        <span class="s6">if </span><span class="s4">(</span><span class="s2">context</span><span class="s4">.</span><span class="s2">hasFinalizer </span><span class="s4">&amp;&amp; </span><span class="s2">context</span><span class="s4">.</span><span class="s2">position </span><span class="s4">!== </span><span class="s3">&quot;finally&quot;</span><span class="s4">) {</span>
            <span class="s6">return </span><span class="s2">context</span><span class="s4">;</span>
        <span class="s4">}</span>
        <span class="s2">context </span><span class="s4">= </span><span class="s2">context</span><span class="s4">.</span><span class="s2">upper</span><span class="s4">;</span>
    <span class="s4">}</span>

    <span class="s6">return </span><span class="s2">state</span><span class="s4">;</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Gets a context for a `throw` statement. There is just one special case:</span>
 <span class="s0">* if there is a `try` statement with a `finally` block and we are inside of</span>
 <span class="s0">* a `catch` because that changes how `throw` behaves; otherwise, this just</span>
 <span class="s0">* passes through the given state.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{CodePathState} state The state to search within.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{TryContext|CodePathState} A context for a `throw` statement.</span>
 <span class="s0">*/</span>
<span class="s6">function </span><span class="s2">getThrowContext</span><span class="s4">(</span><span class="s2">state</span><span class="s4">) {</span>
    <span class="s6">let </span><span class="s2">context </span><span class="s4">= </span><span class="s2">state</span><span class="s4">.</span><span class="s2">tryContext</span><span class="s4">;</span>

    <span class="s6">while </span><span class="s4">(</span><span class="s2">context</span><span class="s4">) {</span>
        <span class="s6">if </span><span class="s4">(</span><span class="s2">context</span><span class="s4">.</span><span class="s2">position </span><span class="s4">=== </span><span class="s3">&quot;try&quot; </span><span class="s4">||</span>
            <span class="s4">(</span><span class="s2">context</span><span class="s4">.</span><span class="s2">hasFinalizer </span><span class="s4">&amp;&amp; </span><span class="s2">context</span><span class="s4">.</span><span class="s2">position </span><span class="s4">=== </span><span class="s3">&quot;catch&quot;</span><span class="s4">)</span>
        <span class="s4">) {</span>
            <span class="s6">return </span><span class="s2">context</span><span class="s4">;</span>
        <span class="s4">}</span>
        <span class="s2">context </span><span class="s4">= </span><span class="s2">context</span><span class="s4">.</span><span class="s2">upper</span><span class="s4">;</span>
    <span class="s4">}</span>

    <span class="s6">return </span><span class="s2">state</span><span class="s4">;</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Removes a given value from a given array.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{any[]} elements An array to remove the specific element.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{any} value The value to be removed.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
 <span class="s0">*/</span>
<span class="s6">function </span><span class="s2">removeFromArray</span><span class="s4">(</span><span class="s2">elements</span><span class="s4">, </span><span class="s2">value</span><span class="s4">) {</span>
    <span class="s2">elements</span><span class="s4">.</span><span class="s2">splice</span><span class="s4">(</span><span class="s2">elements</span><span class="s4">.</span><span class="s2">indexOf</span><span class="s4">(</span><span class="s2">value</span><span class="s4">), </span><span class="s7">1</span><span class="s4">);</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Disconnect given segments.</span>
 <span class="s0">*</span>
 <span class="s0">* This is used in a process for switch statements.</span>
 <span class="s0">* If there is the &quot;default&quot; chunk before other cases, the order is different</span>
 <span class="s0">* between node's and running's.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{CodePathSegment[]} prevSegments Forward segments to disconnect.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{CodePathSegment[]} nextSegments Backward segments to disconnect.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
 <span class="s0">*/</span>
<span class="s6">function </span><span class="s2">disconnectSegments</span><span class="s4">(</span><span class="s2">prevSegments</span><span class="s4">, </span><span class="s2">nextSegments</span><span class="s4">) {</span>
    <span class="s6">for </span><span class="s4">(</span><span class="s6">let </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s2">prevSegments</span><span class="s4">.</span><span class="s2">length</span><span class="s4">; ++</span><span class="s2">i</span><span class="s4">) {</span>
        <span class="s6">const </span><span class="s2">prevSegment </span><span class="s4">= </span><span class="s2">prevSegments</span><span class="s4">[</span><span class="s2">i</span><span class="s4">];</span>
        <span class="s6">const </span><span class="s2">nextSegment </span><span class="s4">= </span><span class="s2">nextSegments</span><span class="s4">[</span><span class="s2">i</span><span class="s4">];</span>

        <span class="s2">removeFromArray</span><span class="s4">(</span><span class="s2">prevSegment</span><span class="s4">.</span><span class="s2">nextSegments</span><span class="s4">, </span><span class="s2">nextSegment</span><span class="s4">);</span>
        <span class="s2">removeFromArray</span><span class="s4">(</span><span class="s2">prevSegment</span><span class="s4">.</span><span class="s2">allNextSegments</span><span class="s4">, </span><span class="s2">nextSegment</span><span class="s4">);</span>
        <span class="s2">removeFromArray</span><span class="s4">(</span><span class="s2">nextSegment</span><span class="s4">.</span><span class="s2">prevSegments</span><span class="s4">, </span><span class="s2">prevSegment</span><span class="s4">);</span>
        <span class="s2">removeFromArray</span><span class="s4">(</span><span class="s2">nextSegment</span><span class="s4">.</span><span class="s2">allPrevSegments</span><span class="s4">, </span><span class="s2">prevSegment</span><span class="s4">);</span>
    <span class="s4">}</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Creates looping path between two arrays of segments, ensuring that there are</span>
 <span class="s0">* paths going between matching segments in the arrays.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{CodePathState} state The state to operate on.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{CodePathSegment[]} unflattenedFromSegments Segments which are source.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{CodePathSegment[]} unflattenedToSegments Segments which are destination.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
 <span class="s0">*/</span>
<span class="s6">function </span><span class="s2">makeLooped</span><span class="s4">(</span><span class="s2">state</span><span class="s4">, </span><span class="s2">unflattenedFromSegments</span><span class="s4">, </span><span class="s2">unflattenedToSegments</span><span class="s4">) {</span>

    <span class="s6">const </span><span class="s2">fromSegments </span><span class="s4">= </span><span class="s2">CodePathSegment</span><span class="s4">.</span><span class="s2">flattenUnusedSegments</span><span class="s4">(</span><span class="s2">unflattenedFromSegments</span><span class="s4">);</span>
    <span class="s6">const </span><span class="s2">toSegments </span><span class="s4">= </span><span class="s2">CodePathSegment</span><span class="s4">.</span><span class="s2">flattenUnusedSegments</span><span class="s4">(</span><span class="s2">unflattenedToSegments</span><span class="s4">);</span>
    <span class="s6">const </span><span class="s2">end </span><span class="s4">= </span><span class="s2">Math</span><span class="s4">.</span><span class="s2">min</span><span class="s4">(</span><span class="s2">fromSegments</span><span class="s4">.</span><span class="s2">length</span><span class="s4">, </span><span class="s2">toSegments</span><span class="s4">.</span><span class="s2">length</span><span class="s4">);</span>

    <span class="s5">/* 
     * This loop effectively updates a doubly-linked list between two collections 
     * of segments making sure that segments in the same array indices are 
     * combined to create a path. 
     */</span>
    <span class="s6">for </span><span class="s4">(</span><span class="s6">let </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s2">end</span><span class="s4">; ++</span><span class="s2">i</span><span class="s4">) {</span>

        <span class="s5">// get the segments in matching array indices</span>
        <span class="s6">const </span><span class="s2">fromSegment </span><span class="s4">= </span><span class="s2">fromSegments</span><span class="s4">[</span><span class="s2">i</span><span class="s4">];</span>
        <span class="s6">const </span><span class="s2">toSegment </span><span class="s4">= </span><span class="s2">toSegments</span><span class="s4">[</span><span class="s2">i</span><span class="s4">];</span>

        <span class="s5">/* 
         * If the destination segment is reachable, then create a path from the 
         * source segment to the destination segment. 
         */</span>
        <span class="s6">if </span><span class="s4">(</span><span class="s2">toSegment</span><span class="s4">.</span><span class="s2">reachable</span><span class="s4">) {</span>
            <span class="s2">fromSegment</span><span class="s4">.</span><span class="s2">nextSegments</span><span class="s4">.</span><span class="s2">push</span><span class="s4">(</span><span class="s2">toSegment</span><span class="s4">);</span>
        <span class="s4">}</span>

        <span class="s5">/* 
         * If the source segment is reachable, then create a path from the 
         * destination segment back to the source segment. 
         */</span>
        <span class="s6">if </span><span class="s4">(</span><span class="s2">fromSegment</span><span class="s4">.</span><span class="s2">reachable</span><span class="s4">) {</span>
            <span class="s2">toSegment</span><span class="s4">.</span><span class="s2">prevSegments</span><span class="s4">.</span><span class="s2">push</span><span class="s4">(</span><span class="s2">fromSegment</span><span class="s4">);</span>
        <span class="s4">}</span>

        <span class="s5">/* 
         * Also update the arrays that don't care if the segments are reachable 
         * or not. This should always happen regardless of anything else. 
         */</span>
        <span class="s2">fromSegment</span><span class="s4">.</span><span class="s2">allNextSegments</span><span class="s4">.</span><span class="s2">push</span><span class="s4">(</span><span class="s2">toSegment</span><span class="s4">);</span>
        <span class="s2">toSegment</span><span class="s4">.</span><span class="s2">allPrevSegments</span><span class="s4">.</span><span class="s2">push</span><span class="s4">(</span><span class="s2">fromSegment</span><span class="s4">);</span>

        <span class="s5">/* 
         * If the destination segment has at least two previous segments in its 
         * path then that means there was one previous segment before this iteration 
         * of the loop was executed. So, we need to mark the source segment as 
         * looped. 
         */</span>
        <span class="s6">if </span><span class="s4">(</span><span class="s2">toSegment</span><span class="s4">.</span><span class="s2">allPrevSegments</span><span class="s4">.</span><span class="s2">length </span><span class="s4">&gt;= </span><span class="s7">2</span><span class="s4">) {</span>
            <span class="s2">CodePathSegment</span><span class="s4">.</span><span class="s2">markPrevSegmentAsLooped</span><span class="s4">(</span><span class="s2">toSegment</span><span class="s4">, </span><span class="s2">fromSegment</span><span class="s4">);</span>
        <span class="s4">}</span>

        <span class="s5">// let the code path analyzer know that there's been a loop created</span>
        <span class="s2">state</span><span class="s4">.</span><span class="s2">notifyLooped</span><span class="s4">(</span><span class="s2">fromSegment</span><span class="s4">, </span><span class="s2">toSegment</span><span class="s4">);</span>
    <span class="s4">}</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Finalizes segments of `test` chunk of a ForStatement.</span>
 <span class="s0">*</span>
 <span class="s0">* - Adds `false` paths to paths which are leaving from the loop.</span>
 <span class="s0">* - Sets `true` paths to paths which go to the body.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{LoopContext} context A loop context to modify.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ChoiceContext} choiceContext A choice context of this loop.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{CodePathSegment[]} head The current head paths.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
 <span class="s0">*/</span>
<span class="s6">function </span><span class="s2">finalizeTestSegmentsOfFor</span><span class="s4">(</span><span class="s2">context</span><span class="s4">, </span><span class="s2">choiceContext</span><span class="s4">, </span><span class="s2">head</span><span class="s4">) {</span>

    <span class="s5">/* 
     * If this choice context doesn't already contain paths from a 
     * child context, then add the current head to each potential path. 
     */</span>
    <span class="s6">if </span><span class="s4">(!</span><span class="s2">choiceContext</span><span class="s4">.</span><span class="s2">processed</span><span class="s4">) {</span>
        <span class="s2">choiceContext</span><span class="s4">.</span><span class="s2">trueForkContext</span><span class="s4">.</span><span class="s2">add</span><span class="s4">(</span><span class="s2">head</span><span class="s4">);</span>
        <span class="s2">choiceContext</span><span class="s4">.</span><span class="s2">falseForkContext</span><span class="s4">.</span><span class="s2">add</span><span class="s4">(</span><span class="s2">head</span><span class="s4">);</span>
        <span class="s2">choiceContext</span><span class="s4">.</span><span class="s2">nullishForkContext</span><span class="s4">.</span><span class="s2">add</span><span class="s4">(</span><span class="s2">head</span><span class="s4">);</span>
    <span class="s4">}</span>

    <span class="s5">/* 
     * If the test condition isn't a hardcoded truthy value, then `break` 
     * must follow the same path as if the test condition is false. To represent 
     * that, we append the path for when the loop test is false (represented by 
     * `falseForkContext`) to the `brokenForkContext`. 
     */</span>
    <span class="s6">if </span><span class="s4">(</span><span class="s2">context</span><span class="s4">.</span><span class="s2">test </span><span class="s4">!== </span><span class="s6">true</span><span class="s4">) {</span>
        <span class="s2">context</span><span class="s4">.</span><span class="s2">brokenForkContext</span><span class="s4">.</span><span class="s2">addAll</span><span class="s4">(</span><span class="s2">choiceContext</span><span class="s4">.</span><span class="s2">falseForkContext</span><span class="s4">);</span>
    <span class="s4">}</span>

    <span class="s2">context</span><span class="s4">.</span><span class="s2">endOfTestSegments </span><span class="s4">= </span><span class="s2">choiceContext</span><span class="s4">.</span><span class="s2">trueForkContext</span><span class="s4">.</span><span class="s2">makeNext</span><span class="s4">(</span><span class="s7">0</span><span class="s4">, -</span><span class="s7">1</span><span class="s4">);</span>
<span class="s4">}</span>

<span class="s5">//------------------------------------------------------------------------------</span>
<span class="s5">// Public Interface</span>
<span class="s5">//------------------------------------------------------------------------------</span>

<span class="s0">/**</span>
 <span class="s0">* A class which manages state to analyze code paths.</span>
 <span class="s0">*/</span>
<span class="s6">class </span><span class="s2">CodePathState </span><span class="s4">{</span>

    <span class="s0">/**</span>
     <span class="s0">* Creates a new instance.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{IdGenerator} idGenerator An id generator to generate id for code</span>
     <span class="s0">*   path segments.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} onLooped A callback function to notify looping.</span>
     <span class="s0">*/</span>
    <span class="s2">constructor</span><span class="s4">(</span><span class="s2">idGenerator</span><span class="s4">, </span><span class="s2">onLooped</span><span class="s4">) {</span>

        <span class="s0">/**</span>
         <span class="s0">* The ID generator to use when creating new segments.</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{IdGenerator}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">idGenerator </span><span class="s4">= </span><span class="s2">idGenerator</span><span class="s4">;</span>

        <span class="s0">/**</span>
         <span class="s0">* A callback function to call when there is a loop.</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{Function}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">notifyLooped </span><span class="s4">= </span><span class="s2">onLooped</span><span class="s4">;</span>

        <span class="s0">/**</span>
         <span class="s0">* The root fork context for this state.</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{ForkContext}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">forkContext </span><span class="s4">= </span><span class="s2">ForkContext</span><span class="s4">.</span><span class="s2">newRoot</span><span class="s4">(</span><span class="s2">idGenerator</span><span class="s4">);</span>

        <span class="s0">/**</span>
         <span class="s0">* Context for logical expressions, conditional expressions, `if` statements,</span>
         <span class="s0">* and loops.</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{ChoiceContext}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">choiceContext </span><span class="s4">= </span><span class="s6">null</span><span class="s4">;</span>

        <span class="s0">/**</span>
         <span class="s0">* Context for `switch` statements.</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{SwitchContext}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">switchContext </span><span class="s4">= </span><span class="s6">null</span><span class="s4">;</span>

        <span class="s0">/**</span>
         <span class="s0">* Context for `try` statements.</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{TryContext}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">tryContext </span><span class="s4">= </span><span class="s6">null</span><span class="s4">;</span>

        <span class="s0">/**</span>
         <span class="s0">* Context for loop statements.</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{LoopContext}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">loopContext </span><span class="s4">= </span><span class="s6">null</span><span class="s4">;</span>

        <span class="s0">/**</span>
         <span class="s0">* Context for `break` statements.</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{BreakContext}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">breakContext </span><span class="s4">= </span><span class="s6">null</span><span class="s4">;</span>

        <span class="s0">/**</span>
         <span class="s0">* Context for `ChainExpression` nodes.</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{ChainContext}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">chainContext </span><span class="s4">= </span><span class="s6">null</span><span class="s4">;</span>

        <span class="s0">/**</span>
         <span class="s0">* An array that tracks the current segments in the state. The array</span>
         <span class="s0">* starts empty and segments are added with each `onCodePathSegmentStart`</span>
         <span class="s0">* event and removed with each `onCodePathSegmentEnd` event. Effectively,</span>
         <span class="s0">* this is tracking the code path segment traversal as the state is</span>
         <span class="s0">* modified.</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{Array&lt;CodePathSegment&gt;}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">currentSegments </span><span class="s4">= [];</span>

        <span class="s0">/**</span>
         <span class="s0">* Tracks the starting segment for this path. This value never changes.</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{CodePathSegment}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">initialSegment </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">head</span><span class="s4">[</span><span class="s7">0</span><span class="s4">];</span>

        <span class="s0">/**</span>
         <span class="s0">* The final segments of the code path which are either `return` or `throw`.</span>
         <span class="s0">* This is a union of the segments in `returnedForkContext` and `thrownForkContext`.</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{Array&lt;CodePathSegment&gt;}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">finalSegments </span><span class="s4">= [];</span>

        <span class="s0">/**</span>
         <span class="s0">* The final segments of the code path which are `return`. These</span>
         <span class="s0">* segments are also contained in `finalSegments`.</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{Array&lt;CodePathSegment&gt;}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">returnedForkContext </span><span class="s4">= [];</span>

        <span class="s0">/**</span>
         <span class="s0">* The final segments of the code path which are `throw`. These</span>
         <span class="s0">* segments are also contained in `finalSegments`.</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{Array&lt;CodePathSegment&gt;}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">thrownForkContext </span><span class="s4">= [];</span>

        <span class="s5">/* 
         * We add an `add` method so that these look more like fork contexts and 
         * can be used interchangeably when a fork context is needed to add more 
         * segments to a path. 
         * 
         * Ultimately, we want anything added to `returned` or `thrown` to also 
         * be added to `final`. We only add reachable and used segments to these 
         * arrays. 
         */</span>
        <span class="s6">const </span><span class="s2">final </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">finalSegments</span><span class="s4">;</span>
        <span class="s6">const </span><span class="s2">returned </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">returnedForkContext</span><span class="s4">;</span>
        <span class="s6">const </span><span class="s2">thrown </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">thrownForkContext</span><span class="s4">;</span>

        <span class="s2">returned</span><span class="s4">.</span><span class="s2">add </span><span class="s4">= </span><span class="s2">addToReturnedOrThrown</span><span class="s4">.</span><span class="s2">bind</span><span class="s4">(</span><span class="s6">null</span><span class="s4">, </span><span class="s2">returned</span><span class="s4">, </span><span class="s2">thrown</span><span class="s4">, </span><span class="s2">final</span><span class="s4">);</span>
        <span class="s2">thrown</span><span class="s4">.</span><span class="s2">add </span><span class="s4">= </span><span class="s2">addToReturnedOrThrown</span><span class="s4">.</span><span class="s2">bind</span><span class="s4">(</span><span class="s6">null</span><span class="s4">, </span><span class="s2">thrown</span><span class="s4">, </span><span class="s2">returned</span><span class="s4">, </span><span class="s2">final</span><span class="s4">);</span>
    <span class="s4">}</span>

    <span class="s0">/**</span>
     <span class="s0">* A passthrough property exposing the current pointer as part of the API.</span>
     <span class="s0">* </span><span class="s1">@type </span><span class="s0">{CodePathSegment[]}</span>
     <span class="s0">*/</span>
    <span class="s2">get headSegments</span><span class="s4">() {</span>
        <span class="s6">return this</span><span class="s4">.</span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">head</span><span class="s4">;</span>
    <span class="s4">}</span>

    <span class="s0">/**</span>
     <span class="s0">* The parent forking context.</span>
     <span class="s0">* This is used for the root of new forks.</span>
     <span class="s0">* </span><span class="s1">@type </span><span class="s0">{ForkContext}</span>
     <span class="s0">*/</span>
    <span class="s2">get parentForkContext</span><span class="s4">() {</span>
        <span class="s6">const </span><span class="s2">current </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">forkContext</span><span class="s4">;</span>

        <span class="s6">return </span><span class="s2">current </span><span class="s4">&amp;&amp; </span><span class="s2">current</span><span class="s4">.</span><span class="s2">upper</span><span class="s4">;</span>
    <span class="s4">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Creates and stacks new forking context.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{boolean} forkLeavingPath A flag which shows being in a</span>
     <span class="s0">*   &quot;finally&quot; block.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{ForkContext} The created context.</span>
     <span class="s0">*/</span>
    <span class="s2">pushForkContext</span><span class="s4">(</span><span class="s2">forkLeavingPath</span><span class="s4">) {</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">forkContext </span><span class="s4">= </span><span class="s2">ForkContext</span><span class="s4">.</span><span class="s2">newEmpty</span><span class="s4">(</span>
            <span class="s6">this</span><span class="s4">.</span><span class="s2">forkContext</span><span class="s4">,</span>
            <span class="s2">forkLeavingPath</span>
        <span class="s4">);</span>

        <span class="s6">return this</span><span class="s4">.</span><span class="s2">forkContext</span><span class="s4">;</span>
    <span class="s4">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Pops and merges the last forking context.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{ForkContext} The last context.</span>
     <span class="s0">*/</span>
    <span class="s2">popForkContext</span><span class="s4">() {</span>
        <span class="s6">const </span><span class="s2">lastContext </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">forkContext</span><span class="s4">;</span>

        <span class="s6">this</span><span class="s4">.</span><span class="s2">forkContext </span><span class="s4">= </span><span class="s2">lastContext</span><span class="s4">.</span><span class="s2">upper</span><span class="s4">;</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">replaceHead</span><span class="s4">(</span><span class="s2">lastContext</span><span class="s4">.</span><span class="s2">makeNext</span><span class="s4">(</span><span class="s7">0</span><span class="s4">, -</span><span class="s7">1</span><span class="s4">));</span>

        <span class="s6">return </span><span class="s2">lastContext</span><span class="s4">;</span>
    <span class="s4">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Creates a new path.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
     <span class="s0">*/</span>
    <span class="s2">forkPath</span><span class="s4">() {</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">add</span><span class="s4">(</span><span class="s6">this</span><span class="s4">.</span><span class="s2">parentForkContext</span><span class="s4">.</span><span class="s2">makeNext</span><span class="s4">(-</span><span class="s7">1</span><span class="s4">, -</span><span class="s7">1</span><span class="s4">));</span>
    <span class="s4">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Creates a bypass path.</span>
     <span class="s0">* This is used for such as IfStatement which does not have &quot;else&quot; chunk.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
     <span class="s0">*/</span>
    <span class="s2">forkBypassPath</span><span class="s4">() {</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">add</span><span class="s4">(</span><span class="s6">this</span><span class="s4">.</span><span class="s2">parentForkContext</span><span class="s4">.</span><span class="s2">head</span><span class="s4">);</span>
    <span class="s4">}</span>

    <span class="s5">//--------------------------------------------------------------------------</span>
    <span class="s5">// ConditionalExpression, LogicalExpression, IfStatement</span>
    <span class="s5">//--------------------------------------------------------------------------</span>

    <span class="s0">/**</span>
     <span class="s0">* Creates a context for ConditionalExpression, LogicalExpression, AssignmentExpression (logical assignments only),</span>
     <span class="s0">* IfStatement, WhileStatement, DoWhileStatement, or ForStatement.</span>
     <span class="s0">*</span>
     <span class="s0">* LogicalExpressions have cases that it goes different paths between the</span>
     <span class="s0">* `true` case and the `false` case.</span>
     <span class="s0">*</span>
     <span class="s0">* For Example:</span>
     <span class="s0">*</span>
     <span class="s0">*     if (a || b) {</span>
     <span class="s0">*         foo();</span>
     <span class="s0">*     } else {</span>
     <span class="s0">*         bar();</span>
     <span class="s0">*     }</span>
     <span class="s0">*</span>
     <span class="s0">* In this case, `b` is evaluated always in the code path of the `else`</span>
     <span class="s0">* block, but it's not so in the code path of the `if` block.</span>
     <span class="s0">* So there are 3 paths.</span>
     <span class="s0">*</span>
     <span class="s0">*     a -&gt; foo();</span>
     <span class="s0">*     a -&gt; b -&gt; foo();</span>
     <span class="s0">*     a -&gt; b -&gt; bar();</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} kind A kind string.</span>
     <span class="s0">*   If the new context is LogicalExpression's or AssignmentExpression's, this is `&quot;&amp;&amp;&quot;` or `&quot;||&quot;` or `&quot;??&quot;`.</span>
     <span class="s0">*   If it's IfStatement's or ConditionalExpression's, this is `&quot;test&quot;`.</span>
     <span class="s0">*   Otherwise, this is `&quot;loop&quot;`.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{boolean} isForkingAsResult Indicates if the result of the choice</span>
     <span class="s0">*      creates a fork.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
     <span class="s0">*/</span>
    <span class="s2">pushChoiceContext</span><span class="s4">(</span><span class="s2">kind</span><span class="s4">, </span><span class="s2">isForkingAsResult</span><span class="s4">) {</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">choiceContext </span><span class="s4">= </span><span class="s6">new </span><span class="s2">ChoiceContext</span><span class="s4">(</span><span class="s6">this</span><span class="s4">.</span><span class="s2">choiceContext</span><span class="s4">, </span><span class="s2">kind</span><span class="s4">, </span><span class="s2">isForkingAsResult</span><span class="s4">, </span><span class="s6">this</span><span class="s4">.</span><span class="s2">forkContext</span><span class="s4">);</span>
    <span class="s4">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Pops the last choice context and finalizes it.</span>
     <span class="s0">* This is called upon leaving a node that represents a choice.</span>
     <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{Error} (Unreachable.)</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{ChoiceContext} The popped context.</span>
     <span class="s0">*/</span>
    <span class="s2">popChoiceContext</span><span class="s4">() {</span>
        <span class="s6">const </span><span class="s2">poppedChoiceContext </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">choiceContext</span><span class="s4">;</span>
        <span class="s6">const </span><span class="s2">forkContext </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">forkContext</span><span class="s4">;</span>
        <span class="s6">const </span><span class="s2">head </span><span class="s4">= </span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">head</span><span class="s4">;</span>

        <span class="s6">this</span><span class="s4">.</span><span class="s2">choiceContext </span><span class="s4">= </span><span class="s2">poppedChoiceContext</span><span class="s4">.</span><span class="s2">upper</span><span class="s4">;</span>

        <span class="s6">switch </span><span class="s4">(</span><span class="s2">poppedChoiceContext</span><span class="s4">.</span><span class="s2">kind</span><span class="s4">) {</span>
            <span class="s6">case </span><span class="s3">&quot;&amp;&amp;&quot;</span><span class="s4">:</span>
            <span class="s6">case </span><span class="s3">&quot;||&quot;</span><span class="s4">:</span>
            <span class="s6">case </span><span class="s3">&quot;??&quot;</span><span class="s4">:</span>

                <span class="s5">/* 
                 * The `head` are the path of the right-hand operand. 
                 * If we haven't previously added segments from child contexts, 
                 * then we add these segments to all possible forks. 
                 */</span>
                <span class="s6">if </span><span class="s4">(!</span><span class="s2">poppedChoiceContext</span><span class="s4">.</span><span class="s2">processed</span><span class="s4">) {</span>
                    <span class="s2">poppedChoiceContext</span><span class="s4">.</span><span class="s2">trueForkContext</span><span class="s4">.</span><span class="s2">add</span><span class="s4">(</span><span class="s2">head</span><span class="s4">);</span>
                    <span class="s2">poppedChoiceContext</span><span class="s4">.</span><span class="s2">falseForkContext</span><span class="s4">.</span><span class="s2">add</span><span class="s4">(</span><span class="s2">head</span><span class="s4">);</span>
                    <span class="s2">poppedChoiceContext</span><span class="s4">.</span><span class="s2">nullishForkContext</span><span class="s4">.</span><span class="s2">add</span><span class="s4">(</span><span class="s2">head</span><span class="s4">);</span>
                <span class="s4">}</span>

                <span class="s5">/* 
                 * If this context is the left (test) expression for another choice 
                 * context, such as `a || b` in the expression `a || b || c`, 
                 * then we take the segments for this context and move them up 
                 * to the parent context. 
                 */</span>
                <span class="s6">if </span><span class="s4">(</span><span class="s2">poppedChoiceContext</span><span class="s4">.</span><span class="s2">isForkingAsResult</span><span class="s4">) {</span>
                    <span class="s6">const </span><span class="s2">parentContext </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">choiceContext</span><span class="s4">;</span>

                    <span class="s2">parentContext</span><span class="s4">.</span><span class="s2">trueForkContext</span><span class="s4">.</span><span class="s2">addAll</span><span class="s4">(</span><span class="s2">poppedChoiceContext</span><span class="s4">.</span><span class="s2">trueForkContext</span><span class="s4">);</span>
                    <span class="s2">parentContext</span><span class="s4">.</span><span class="s2">falseForkContext</span><span class="s4">.</span><span class="s2">addAll</span><span class="s4">(</span><span class="s2">poppedChoiceContext</span><span class="s4">.</span><span class="s2">falseForkContext</span><span class="s4">);</span>
                    <span class="s2">parentContext</span><span class="s4">.</span><span class="s2">nullishForkContext</span><span class="s4">.</span><span class="s2">addAll</span><span class="s4">(</span><span class="s2">poppedChoiceContext</span><span class="s4">.</span><span class="s2">nullishForkContext</span><span class="s4">);</span>
                    <span class="s2">parentContext</span><span class="s4">.</span><span class="s2">processed </span><span class="s4">= </span><span class="s6">true</span><span class="s4">;</span>

                    <span class="s5">// Exit early so we don't collapse all paths into one.</span>
                    <span class="s6">return </span><span class="s2">poppedChoiceContext</span><span class="s4">;</span>
                <span class="s4">}</span>

                <span class="s6">break</span><span class="s4">;</span>

            <span class="s6">case </span><span class="s3">&quot;test&quot;</span><span class="s4">:</span>
                <span class="s6">if </span><span class="s4">(!</span><span class="s2">poppedChoiceContext</span><span class="s4">.</span><span class="s2">processed</span><span class="s4">) {</span>

                    <span class="s5">/* 
                     * The head segments are the path of the `if` block here. 
                     * Updates the `true` path with the end of the `if` block. 
                     */</span>
                    <span class="s2">poppedChoiceContext</span><span class="s4">.</span><span class="s2">trueForkContext</span><span class="s4">.</span><span class="s2">clear</span><span class="s4">();</span>
                    <span class="s2">poppedChoiceContext</span><span class="s4">.</span><span class="s2">trueForkContext</span><span class="s4">.</span><span class="s2">add</span><span class="s4">(</span><span class="s2">head</span><span class="s4">);</span>
                <span class="s4">} </span><span class="s6">else </span><span class="s4">{</span>

                    <span class="s5">/* 
                     * The head segments are the path of the `else` block here. 
                     * Updates the `false` path with the end of the `else` 
                     * block. 
                     */</span>
                    <span class="s2">poppedChoiceContext</span><span class="s4">.</span><span class="s2">falseForkContext</span><span class="s4">.</span><span class="s2">clear</span><span class="s4">();</span>
                    <span class="s2">poppedChoiceContext</span><span class="s4">.</span><span class="s2">falseForkContext</span><span class="s4">.</span><span class="s2">add</span><span class="s4">(</span><span class="s2">head</span><span class="s4">);</span>
                <span class="s4">}</span>

                <span class="s6">break</span><span class="s4">;</span>

            <span class="s6">case </span><span class="s3">&quot;loop&quot;</span><span class="s4">:</span>

                <span class="s5">/* 
                 * Loops are addressed in `popLoopContext()` so just return 
                 * the context without modification. 
                 */</span>
                <span class="s6">return </span><span class="s2">poppedChoiceContext</span><span class="s4">;</span>

            <span class="s5">/* c8 ignore next */</span>
            <span class="s6">default</span><span class="s4">:</span>
                <span class="s6">throw new </span><span class="s2">Error</span><span class="s4">(</span><span class="s3">&quot;unreachable&quot;</span><span class="s4">);</span>
        <span class="s4">}</span>

        <span class="s5">/* 
         * Merge the true path with the false path to create a single path. 
         */</span>
        <span class="s6">const </span><span class="s2">combinedForkContext </span><span class="s4">= </span><span class="s2">poppedChoiceContext</span><span class="s4">.</span><span class="s2">trueForkContext</span><span class="s4">;</span>

        <span class="s2">combinedForkContext</span><span class="s4">.</span><span class="s2">addAll</span><span class="s4">(</span><span class="s2">poppedChoiceContext</span><span class="s4">.</span><span class="s2">falseForkContext</span><span class="s4">);</span>
        <span class="s2">forkContext</span><span class="s4">.</span><span class="s2">replaceHead</span><span class="s4">(</span><span class="s2">combinedForkContext</span><span class="s4">.</span><span class="s2">makeNext</span><span class="s4">(</span><span class="s7">0</span><span class="s4">, -</span><span class="s7">1</span><span class="s4">));</span>

        <span class="s6">return </span><span class="s2">poppedChoiceContext</span><span class="s4">;</span>
    <span class="s4">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Creates a code path segment to represent right-hand operand of a logical</span>
     <span class="s0">* expression.</span>
     <span class="s0">* This is called in the preprocessing phase when entering a node.</span>
     <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{Error} (Unreachable.)</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
     <span class="s0">*/</span>
    <span class="s2">makeLogicalRight</span><span class="s4">() {</span>
        <span class="s6">const </span><span class="s2">currentChoiceContext </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">choiceContext</span><span class="s4">;</span>
        <span class="s6">const </span><span class="s2">forkContext </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">forkContext</span><span class="s4">;</span>

        <span class="s6">if </span><span class="s4">(</span><span class="s2">currentChoiceContext</span><span class="s4">.</span><span class="s2">processed</span><span class="s4">) {</span>

            <span class="s5">/* 
             * This context was already assigned segments from a child 
             * choice context. In this case, we are concerned only about 
             * the path that does not short-circuit and so ends up on the 
             * right-hand operand of the logical expression. 
             */</span>
            <span class="s6">let </span><span class="s2">prevForkContext</span><span class="s4">;</span>

            <span class="s6">switch </span><span class="s4">(</span><span class="s2">currentChoiceContext</span><span class="s4">.</span><span class="s2">kind</span><span class="s4">) {</span>
                <span class="s6">case </span><span class="s3">&quot;&amp;&amp;&quot;</span><span class="s4">: </span><span class="s5">// if true then go to the right-hand side.</span>
                    <span class="s2">prevForkContext </span><span class="s4">= </span><span class="s2">currentChoiceContext</span><span class="s4">.</span><span class="s2">trueForkContext</span><span class="s4">;</span>
                    <span class="s6">break</span><span class="s4">;</span>
                <span class="s6">case </span><span class="s3">&quot;||&quot;</span><span class="s4">: </span><span class="s5">// if false then go to the right-hand side.</span>
                    <span class="s2">prevForkContext </span><span class="s4">= </span><span class="s2">currentChoiceContext</span><span class="s4">.</span><span class="s2">falseForkContext</span><span class="s4">;</span>
                    <span class="s6">break</span><span class="s4">;</span>
                <span class="s6">case </span><span class="s3">&quot;??&quot;</span><span class="s4">: </span><span class="s5">// Both true/false can short-circuit, so needs the third path to go to the right-hand side. That's nullishForkContext.</span>
                    <span class="s2">prevForkContext </span><span class="s4">= </span><span class="s2">currentChoiceContext</span><span class="s4">.</span><span class="s2">nullishForkContext</span><span class="s4">;</span>
                    <span class="s6">break</span><span class="s4">;</span>
                <span class="s6">default</span><span class="s4">:</span>
                    <span class="s6">throw new </span><span class="s2">Error</span><span class="s4">(</span><span class="s3">&quot;unreachable&quot;</span><span class="s4">);</span>
            <span class="s4">}</span>

            <span class="s5">/* 
             * Create the segment for the right-hand operand of the logical expression 
             * and adjust the fork context pointer to point there. The right-hand segment 
             * is added at the end of all segments in `prevForkContext`. 
             */</span>
            <span class="s2">forkContext</span><span class="s4">.</span><span class="s2">replaceHead</span><span class="s4">(</span><span class="s2">prevForkContext</span><span class="s4">.</span><span class="s2">makeNext</span><span class="s4">(</span><span class="s7">0</span><span class="s4">, -</span><span class="s7">1</span><span class="s4">));</span>

            <span class="s5">/* 
             * We no longer need this list of segments. 
             * 
             * Reset `processed` because we've removed the segments from the child 
             * choice context. This allows `popChoiceContext()` to continue adding 
             * segments later. 
             */</span>
            <span class="s2">prevForkContext</span><span class="s4">.</span><span class="s2">clear</span><span class="s4">();</span>
            <span class="s2">currentChoiceContext</span><span class="s4">.</span><span class="s2">processed </span><span class="s4">= </span><span class="s6">false</span><span class="s4">;</span>

        <span class="s4">} </span><span class="s6">else </span><span class="s4">{</span>

            <span class="s5">/* 
             * This choice context was not assigned segments from a child 
             * choice context, which means that it's a terminal logical 
             * expression. 
             * 
             * `head` is the segments for the left-hand operand of the 
             * logical expression. 
             * 
             * Each of the fork contexts below are empty at this point. We choose 
             * the path(s) that will short-circuit and add the segment for the 
             * left-hand operand to it. Ultimately, this will be the only segment 
             * in that path due to the short-circuting, so we are just seeding 
             * these paths to start. 
             */</span>
            <span class="s6">switch </span><span class="s4">(</span><span class="s2">currentChoiceContext</span><span class="s4">.</span><span class="s2">kind</span><span class="s4">) {</span>
                <span class="s6">case </span><span class="s3">&quot;&amp;&amp;&quot;</span><span class="s4">:</span>

                    <span class="s5">/* 
                     * In most contexts, when a &amp;&amp; expression evaluates to false, 
                     * it short circuits, so we need to account for that by setting 
                     * the `falseForkContext` to the left operand. 
                     * 
                     * When a &amp;&amp; expression is the left-hand operand for a ?? 
                     * expression, such as `(a &amp;&amp; b) ?? c`, a nullish value will 
                     * also short-circuit in a different way than a false value, 
                     * so we also set the `nullishForkContext` to the left operand. 
                     * This path is only used with a ?? expression and is thrown 
                     * away for any other type of logical expression, so it's safe 
                     * to always add. 
                     */</span>
                    <span class="s2">currentChoiceContext</span><span class="s4">.</span><span class="s2">falseForkContext</span><span class="s4">.</span><span class="s2">add</span><span class="s4">(</span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">head</span><span class="s4">);</span>
                    <span class="s2">currentChoiceContext</span><span class="s4">.</span><span class="s2">nullishForkContext</span><span class="s4">.</span><span class="s2">add</span><span class="s4">(</span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">head</span><span class="s4">);</span>
                    <span class="s6">break</span><span class="s4">;</span>
                <span class="s6">case </span><span class="s3">&quot;||&quot;</span><span class="s4">: </span><span class="s5">// the true path can short-circuit.</span>
                    <span class="s2">currentChoiceContext</span><span class="s4">.</span><span class="s2">trueForkContext</span><span class="s4">.</span><span class="s2">add</span><span class="s4">(</span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">head</span><span class="s4">);</span>
                    <span class="s6">break</span><span class="s4">;</span>
                <span class="s6">case </span><span class="s3">&quot;??&quot;</span><span class="s4">: </span><span class="s5">// both can short-circuit.</span>
                    <span class="s2">currentChoiceContext</span><span class="s4">.</span><span class="s2">trueForkContext</span><span class="s4">.</span><span class="s2">add</span><span class="s4">(</span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">head</span><span class="s4">);</span>
                    <span class="s2">currentChoiceContext</span><span class="s4">.</span><span class="s2">falseForkContext</span><span class="s4">.</span><span class="s2">add</span><span class="s4">(</span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">head</span><span class="s4">);</span>
                    <span class="s6">break</span><span class="s4">;</span>
                <span class="s6">default</span><span class="s4">:</span>
                    <span class="s6">throw new </span><span class="s2">Error</span><span class="s4">(</span><span class="s3">&quot;unreachable&quot;</span><span class="s4">);</span>
            <span class="s4">}</span>

            <span class="s5">/* 
             * Create the segment for the right-hand operand of the logical expression 
             * and adjust the fork context pointer to point there. 
             */</span>
            <span class="s2">forkContext</span><span class="s4">.</span><span class="s2">replaceHead</span><span class="s4">(</span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">makeNext</span><span class="s4">(-</span><span class="s7">1</span><span class="s4">, -</span><span class="s7">1</span><span class="s4">));</span>
        <span class="s4">}</span>
    <span class="s4">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Makes a code path segment of the `if` block.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
     <span class="s0">*/</span>
    <span class="s2">makeIfConsequent</span><span class="s4">() {</span>
        <span class="s6">const </span><span class="s2">context </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">choiceContext</span><span class="s4">;</span>
        <span class="s6">const </span><span class="s2">forkContext </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">forkContext</span><span class="s4">;</span>

        <span class="s5">/* 
         * If any result were not transferred from child contexts, 
         * this sets the head segments to both cases. 
         * The head segments are the path of the test expression. 
         */</span>
        <span class="s6">if </span><span class="s4">(!</span><span class="s2">context</span><span class="s4">.</span><span class="s2">processed</span><span class="s4">) {</span>
            <span class="s2">context</span><span class="s4">.</span><span class="s2">trueForkContext</span><span class="s4">.</span><span class="s2">add</span><span class="s4">(</span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">head</span><span class="s4">);</span>
            <span class="s2">context</span><span class="s4">.</span><span class="s2">falseForkContext</span><span class="s4">.</span><span class="s2">add</span><span class="s4">(</span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">head</span><span class="s4">);</span>
            <span class="s2">context</span><span class="s4">.</span><span class="s2">nullishForkContext</span><span class="s4">.</span><span class="s2">add</span><span class="s4">(</span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">head</span><span class="s4">);</span>
        <span class="s4">}</span>

        <span class="s2">context</span><span class="s4">.</span><span class="s2">processed </span><span class="s4">= </span><span class="s6">false</span><span class="s4">;</span>

        <span class="s5">// Creates new path from the `true` case.</span>
        <span class="s2">forkContext</span><span class="s4">.</span><span class="s2">replaceHead</span><span class="s4">(</span>
            <span class="s2">context</span><span class="s4">.</span><span class="s2">trueForkContext</span><span class="s4">.</span><span class="s2">makeNext</span><span class="s4">(</span><span class="s7">0</span><span class="s4">, -</span><span class="s7">1</span><span class="s4">)</span>
        <span class="s4">);</span>
    <span class="s4">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Makes a code path segment of the `else` block.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
     <span class="s0">*/</span>
    <span class="s2">makeIfAlternate</span><span class="s4">() {</span>
        <span class="s6">const </span><span class="s2">context </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">choiceContext</span><span class="s4">;</span>
        <span class="s6">const </span><span class="s2">forkContext </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">forkContext</span><span class="s4">;</span>

        <span class="s5">/* 
         * The head segments are the path of the `if` block. 
         * Updates the `true` path with the end of the `if` block. 
         */</span>
        <span class="s2">context</span><span class="s4">.</span><span class="s2">trueForkContext</span><span class="s4">.</span><span class="s2">clear</span><span class="s4">();</span>
        <span class="s2">context</span><span class="s4">.</span><span class="s2">trueForkContext</span><span class="s4">.</span><span class="s2">add</span><span class="s4">(</span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">head</span><span class="s4">);</span>
        <span class="s2">context</span><span class="s4">.</span><span class="s2">processed </span><span class="s4">= </span><span class="s6">true</span><span class="s4">;</span>

        <span class="s5">// Creates new path from the `false` case.</span>
        <span class="s2">forkContext</span><span class="s4">.</span><span class="s2">replaceHead</span><span class="s4">(</span>
            <span class="s2">context</span><span class="s4">.</span><span class="s2">falseForkContext</span><span class="s4">.</span><span class="s2">makeNext</span><span class="s4">(</span><span class="s7">0</span><span class="s4">, -</span><span class="s7">1</span><span class="s4">)</span>
        <span class="s4">);</span>
    <span class="s4">}</span>

    <span class="s5">//--------------------------------------------------------------------------</span>
    <span class="s5">// ChainExpression</span>
    <span class="s5">//--------------------------------------------------------------------------</span>

    <span class="s0">/**</span>
     <span class="s0">* Pushes a new `ChainExpression` context to the stack. This method is</span>
     <span class="s0">* called when entering a `ChainExpression` node. A chain context is used to</span>
     <span class="s0">* count forking in the optional chain then merge them on the exiting from the</span>
     <span class="s0">* `ChainExpression` node.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
     <span class="s0">*/</span>
    <span class="s2">pushChainContext</span><span class="s4">() {</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">chainContext </span><span class="s4">= </span><span class="s6">new </span><span class="s2">ChainContext</span><span class="s4">(</span><span class="s6">this</span><span class="s4">.</span><span class="s2">chainContext</span><span class="s4">);</span>
    <span class="s4">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Pop a `ChainExpression` context from the stack. This method is called on</span>
     <span class="s0">* exiting from each `ChainExpression` node. This merges all forks of the</span>
     <span class="s0">* last optional chaining.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
     <span class="s0">*/</span>
    <span class="s2">popChainContext</span><span class="s4">() {</span>
        <span class="s6">const </span><span class="s2">context </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">chainContext</span><span class="s4">;</span>

        <span class="s6">this</span><span class="s4">.</span><span class="s2">chainContext </span><span class="s4">= </span><span class="s2">context</span><span class="s4">.</span><span class="s2">upper</span><span class="s4">;</span>

        <span class="s5">// pop all choice contexts of this.</span>
        <span class="s6">for </span><span class="s4">(</span><span class="s6">let </span><span class="s2">i </span><span class="s4">= </span><span class="s2">context</span><span class="s4">.</span><span class="s2">choiceContextCount</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&gt; </span><span class="s7">0</span><span class="s4">; --</span><span class="s2">i</span><span class="s4">) {</span>
            <span class="s6">this</span><span class="s4">.</span><span class="s2">popChoiceContext</span><span class="s4">();</span>
        <span class="s4">}</span>
    <span class="s4">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Create a choice context for optional access.</span>
     <span class="s0">* This method is called on entering to each `(Call|Member)Expression[optional=true]` node.</span>
     <span class="s0">* This creates a choice context as similar to `LogicalExpression[operator=&quot;??&quot;]` node.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
     <span class="s0">*/</span>
    <span class="s2">makeOptionalNode</span><span class="s4">() {</span>
        <span class="s6">if </span><span class="s4">(</span><span class="s6">this</span><span class="s4">.</span><span class="s2">chainContext</span><span class="s4">) {</span>
            <span class="s6">this</span><span class="s4">.</span><span class="s2">chainContext</span><span class="s4">.</span><span class="s2">choiceContextCount </span><span class="s4">+= </span><span class="s7">1</span><span class="s4">;</span>
            <span class="s6">this</span><span class="s4">.</span><span class="s2">pushChoiceContext</span><span class="s4">(</span><span class="s3">&quot;??&quot;</span><span class="s4">, </span><span class="s6">false</span><span class="s4">);</span>
        <span class="s4">}</span>
    <span class="s4">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Create a fork.</span>
     <span class="s0">* This method is called on entering to the `arguments|property` property of each `(Call|Member)Expression` node.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
     <span class="s0">*/</span>
    <span class="s2">makeOptionalRight</span><span class="s4">() {</span>
        <span class="s6">if </span><span class="s4">(</span><span class="s6">this</span><span class="s4">.</span><span class="s2">chainContext</span><span class="s4">) {</span>
            <span class="s6">this</span><span class="s4">.</span><span class="s2">makeLogicalRight</span><span class="s4">();</span>
        <span class="s4">}</span>
    <span class="s4">}</span>

    <span class="s5">//--------------------------------------------------------------------------</span>
    <span class="s5">// SwitchStatement</span>
    <span class="s5">//--------------------------------------------------------------------------</span>

    <span class="s0">/**</span>
     <span class="s0">* Creates a context object of SwitchStatement and stacks it.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{boolean} hasCase `true` if the switch statement has one or more</span>
     <span class="s0">*   case parts.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|null} label The label text.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
     <span class="s0">*/</span>
    <span class="s2">pushSwitchContext</span><span class="s4">(</span><span class="s2">hasCase</span><span class="s4">, </span><span class="s2">label</span><span class="s4">) {</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">switchContext </span><span class="s4">= </span><span class="s6">new </span><span class="s2">SwitchContext</span><span class="s4">(</span><span class="s6">this</span><span class="s4">.</span><span class="s2">switchContext</span><span class="s4">, </span><span class="s2">hasCase</span><span class="s4">);</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">pushBreakContext</span><span class="s4">(</span><span class="s6">true</span><span class="s4">, </span><span class="s2">label</span><span class="s4">);</span>
    <span class="s4">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Pops the last context of SwitchStatement and finalizes it.</span>
     <span class="s0">*</span>
     <span class="s0">* - Disposes all forking stack for `case` and `default`.</span>
     <span class="s0">* - Creates the next code path segment from `context.brokenForkContext`.</span>
     <span class="s0">* - If the last `SwitchCase` node is not a `default` part, creates a path</span>
     <span class="s0">*   to the `default` body.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
     <span class="s0">*/</span>
    <span class="s2">popSwitchContext</span><span class="s4">() {</span>
        <span class="s6">const </span><span class="s2">context </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">switchContext</span><span class="s4">;</span>

        <span class="s6">this</span><span class="s4">.</span><span class="s2">switchContext </span><span class="s4">= </span><span class="s2">context</span><span class="s4">.</span><span class="s2">upper</span><span class="s4">;</span>

        <span class="s6">const </span><span class="s2">forkContext </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">forkContext</span><span class="s4">;</span>
        <span class="s6">const </span><span class="s2">brokenForkContext </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">popBreakContext</span><span class="s4">().</span><span class="s2">brokenForkContext</span><span class="s4">;</span>

        <span class="s6">if </span><span class="s4">(</span><span class="s2">context</span><span class="s4">.</span><span class="s2">forkCount </span><span class="s4">=== </span><span class="s7">0</span><span class="s4">) {</span>

            <span class="s5">/* 
             * When there is only one `default` chunk and there is one or more 
             * `break` statements, even if forks are nothing, it needs to merge 
             * those. 
             */</span>
            <span class="s6">if </span><span class="s4">(!</span><span class="s2">brokenForkContext</span><span class="s4">.</span><span class="s2">empty</span><span class="s4">) {</span>
                <span class="s2">brokenForkContext</span><span class="s4">.</span><span class="s2">add</span><span class="s4">(</span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">makeNext</span><span class="s4">(-</span><span class="s7">1</span><span class="s4">, -</span><span class="s7">1</span><span class="s4">));</span>
                <span class="s2">forkContext</span><span class="s4">.</span><span class="s2">replaceHead</span><span class="s4">(</span><span class="s2">brokenForkContext</span><span class="s4">.</span><span class="s2">makeNext</span><span class="s4">(</span><span class="s7">0</span><span class="s4">, -</span><span class="s7">1</span><span class="s4">));</span>
            <span class="s4">}</span>

            <span class="s6">return</span><span class="s4">;</span>
        <span class="s4">}</span>

        <span class="s6">const </span><span class="s2">lastSegments </span><span class="s4">= </span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">head</span><span class="s4">;</span>

        <span class="s6">this</span><span class="s4">.</span><span class="s2">forkBypassPath</span><span class="s4">();</span>
        <span class="s6">const </span><span class="s2">lastCaseSegments </span><span class="s4">= </span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">head</span><span class="s4">;</span>

        <span class="s5">/* 
         * `brokenForkContext` is used to make the next segment. 
         * It must add the last segment into `brokenForkContext`. 
         */</span>
        <span class="s2">brokenForkContext</span><span class="s4">.</span><span class="s2">add</span><span class="s4">(</span><span class="s2">lastSegments</span><span class="s4">);</span>

        <span class="s5">/* 
         * Any value that doesn't match a `case` test should flow to the default 
         * case. That happens normally when the default case is last in the `switch`, 
         * but if it's not, we need to rewire some of the paths to be correct. 
         */</span>
        <span class="s6">if </span><span class="s4">(!</span><span class="s2">context</span><span class="s4">.</span><span class="s2">lastIsDefault</span><span class="s4">) {</span>
            <span class="s6">if </span><span class="s4">(</span><span class="s2">context</span><span class="s4">.</span><span class="s2">defaultBodySegments</span><span class="s4">) {</span>

                <span class="s5">/* 
                 * There is a non-empty default case, so remove the path from the `default` 
                 * label to its body for an accurate representation. 
                 */</span>
                <span class="s2">disconnectSegments</span><span class="s4">(</span><span class="s2">context</span><span class="s4">.</span><span class="s2">defaultSegments</span><span class="s4">, </span><span class="s2">context</span><span class="s4">.</span><span class="s2">defaultBodySegments</span><span class="s4">);</span>

                <span class="s5">/* 
                 * Connect the path from the last non-default case to the body of the 
                 * default case. 
                 */</span>
                <span class="s2">makeLooped</span><span class="s4">(</span><span class="s6">this</span><span class="s4">, </span><span class="s2">lastCaseSegments</span><span class="s4">, </span><span class="s2">context</span><span class="s4">.</span><span class="s2">defaultBodySegments</span><span class="s4">);</span>

            <span class="s4">} </span><span class="s6">else </span><span class="s4">{</span>

                <span class="s5">/* 
                 * There is no default case, so we treat this as if the last case 
                 * had a `break` in it. 
                 */</span>
                <span class="s2">brokenForkContext</span><span class="s4">.</span><span class="s2">add</span><span class="s4">(</span><span class="s2">lastCaseSegments</span><span class="s4">);</span>
            <span class="s4">}</span>
        <span class="s4">}</span>

        <span class="s5">// Traverse up to the original fork context for the `switch` statement</span>
        <span class="s6">for </span><span class="s4">(</span><span class="s6">let </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s2">context</span><span class="s4">.</span><span class="s2">forkCount</span><span class="s4">; ++</span><span class="s2">i</span><span class="s4">) {</span>
            <span class="s6">this</span><span class="s4">.</span><span class="s2">forkContext </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">upper</span><span class="s4">;</span>
        <span class="s4">}</span>

        <span class="s5">/* 
         * Creates a path from all `brokenForkContext` paths. 
         * This is a path after `switch` statement. 
         */</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">replaceHead</span><span class="s4">(</span><span class="s2">brokenForkContext</span><span class="s4">.</span><span class="s2">makeNext</span><span class="s4">(</span><span class="s7">0</span><span class="s4">, -</span><span class="s7">1</span><span class="s4">));</span>
    <span class="s4">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Makes a code path segment for a `SwitchCase` node.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{boolean} isCaseBodyEmpty `true` if the body is empty.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{boolean} isDefaultCase `true` if the body is the default case.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
     <span class="s0">*/</span>
    <span class="s2">makeSwitchCaseBody</span><span class="s4">(</span><span class="s2">isCaseBodyEmpty</span><span class="s4">, </span><span class="s2">isDefaultCase</span><span class="s4">) {</span>
        <span class="s6">const </span><span class="s2">context </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">switchContext</span><span class="s4">;</span>

        <span class="s6">if </span><span class="s4">(!</span><span class="s2">context</span><span class="s4">.</span><span class="s2">hasCase</span><span class="s4">) {</span>
            <span class="s6">return</span><span class="s4">;</span>
        <span class="s4">}</span>

        <span class="s5">/* 
         * Merge forks. 
         * The parent fork context has two segments. 
         * Those are from the current `case` and the body of the previous case. 
         */</span>
        <span class="s6">const </span><span class="s2">parentForkContext </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">forkContext</span><span class="s4">;</span>
        <span class="s6">const </span><span class="s2">forkContext </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">pushForkContext</span><span class="s4">();</span>

        <span class="s2">forkContext</span><span class="s4">.</span><span class="s2">add</span><span class="s4">(</span><span class="s2">parentForkContext</span><span class="s4">.</span><span class="s2">makeNext</span><span class="s4">(</span><span class="s7">0</span><span class="s4">, -</span><span class="s7">1</span><span class="s4">));</span>

        <span class="s5">/* 
         * Add information about the default case. 
         * 
         * The purpose of this is to identify the starting segments for the 
         * default case to make sure there is a path there. 
         */</span>
        <span class="s6">if </span><span class="s4">(</span><span class="s2">isDefaultCase</span><span class="s4">) {</span>

            <span class="s5">/* 
             * This is the default case in the `switch`. 
             * 
             * We first save the current pointer as `defaultSegments` to point 
             * to the `default` keyword. 
             */</span>
            <span class="s2">context</span><span class="s4">.</span><span class="s2">defaultSegments </span><span class="s4">= </span><span class="s2">parentForkContext</span><span class="s4">.</span><span class="s2">head</span><span class="s4">;</span>

            <span class="s5">/* 
             * If the body of the case is empty then we just set 
             * `foundEmptyDefault` to true; otherwise, we save a reference 
             * to the current pointer as `defaultBodySegments`. 
             */</span>
            <span class="s6">if </span><span class="s4">(</span><span class="s2">isCaseBodyEmpty</span><span class="s4">) {</span>
                <span class="s2">context</span><span class="s4">.</span><span class="s2">foundEmptyDefault </span><span class="s4">= </span><span class="s6">true</span><span class="s4">;</span>
            <span class="s4">} </span><span class="s6">else </span><span class="s4">{</span>
                <span class="s2">context</span><span class="s4">.</span><span class="s2">defaultBodySegments </span><span class="s4">= </span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">head</span><span class="s4">;</span>
            <span class="s4">}</span>

        <span class="s4">} </span><span class="s6">else </span><span class="s4">{</span>

            <span class="s5">/* 
             * This is not the default case in the `switch`. 
             * 
             * If it's not empty and there is already an empty default case found, 
             * that means the default case actually comes before this case, 
             * and that it will fall through to this case. So, we can now 
             * ignore the previous default case (reset `foundEmptyDefault` to false) 
             * and set `defaultBodySegments` to the current segments because this is 
             * effectively the new default case. 
             */</span>
            <span class="s6">if </span><span class="s4">(!</span><span class="s2">isCaseBodyEmpty </span><span class="s4">&amp;&amp; </span><span class="s2">context</span><span class="s4">.</span><span class="s2">foundEmptyDefault</span><span class="s4">) {</span>
                <span class="s2">context</span><span class="s4">.</span><span class="s2">foundEmptyDefault </span><span class="s4">= </span><span class="s6">false</span><span class="s4">;</span>
                <span class="s2">context</span><span class="s4">.</span><span class="s2">defaultBodySegments </span><span class="s4">= </span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">head</span><span class="s4">;</span>
            <span class="s4">}</span>
        <span class="s4">}</span>

        <span class="s5">// keep track if the default case ends up last</span>
        <span class="s2">context</span><span class="s4">.</span><span class="s2">lastIsDefault </span><span class="s4">= </span><span class="s2">isDefaultCase</span><span class="s4">;</span>
        <span class="s2">context</span><span class="s4">.</span><span class="s2">forkCount </span><span class="s4">+= </span><span class="s7">1</span><span class="s4">;</span>
    <span class="s4">}</span>

    <span class="s5">//--------------------------------------------------------------------------</span>
    <span class="s5">// TryStatement</span>
    <span class="s5">//--------------------------------------------------------------------------</span>

    <span class="s0">/**</span>
     <span class="s0">* Creates a context object of TryStatement and stacks it.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{boolean} hasFinalizer `true` if the try statement has a</span>
     <span class="s0">*   `finally` block.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
     <span class="s0">*/</span>
    <span class="s2">pushTryContext</span><span class="s4">(</span><span class="s2">hasFinalizer</span><span class="s4">) {</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">tryContext </span><span class="s4">= </span><span class="s6">new </span><span class="s2">TryContext</span><span class="s4">(</span><span class="s6">this</span><span class="s4">.</span><span class="s2">tryContext</span><span class="s4">, </span><span class="s2">hasFinalizer</span><span class="s4">, </span><span class="s6">this</span><span class="s4">.</span><span class="s2">forkContext</span><span class="s4">);</span>
    <span class="s4">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Pops the last context of TryStatement and finalizes it.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
     <span class="s0">*/</span>
    <span class="s2">popTryContext</span><span class="s4">() {</span>
        <span class="s6">const </span><span class="s2">context </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">tryContext</span><span class="s4">;</span>

        <span class="s6">this</span><span class="s4">.</span><span class="s2">tryContext </span><span class="s4">= </span><span class="s2">context</span><span class="s4">.</span><span class="s2">upper</span><span class="s4">;</span>

        <span class="s5">/* 
         * If we're inside the `catch` block, that means there is no `finally`, 
         * so we can process the `try` and `catch` blocks the simple way and 
         * merge their two paths. 
         */</span>
        <span class="s6">if </span><span class="s4">(</span><span class="s2">context</span><span class="s4">.</span><span class="s2">position </span><span class="s4">=== </span><span class="s3">&quot;catch&quot;</span><span class="s4">) {</span>
            <span class="s6">this</span><span class="s4">.</span><span class="s2">popForkContext</span><span class="s4">();</span>
            <span class="s6">return</span><span class="s4">;</span>
        <span class="s4">}</span>

        <span class="s5">/* 
         * The following process is executed only when there is a `finally` 
         * block. 
         */</span>

        <span class="s6">const </span><span class="s2">originalReturnedForkContext </span><span class="s4">= </span><span class="s2">context</span><span class="s4">.</span><span class="s2">returnedForkContext</span><span class="s4">;</span>
        <span class="s6">const </span><span class="s2">originalThrownForkContext </span><span class="s4">= </span><span class="s2">context</span><span class="s4">.</span><span class="s2">thrownForkContext</span><span class="s4">;</span>

        <span class="s5">// no `return` or `throw` in `try` or `catch` so there's nothing left to do</span>
        <span class="s6">if </span><span class="s4">(</span><span class="s2">originalReturnedForkContext</span><span class="s4">.</span><span class="s2">empty </span><span class="s4">&amp;&amp; </span><span class="s2">originalThrownForkContext</span><span class="s4">.</span><span class="s2">empty</span><span class="s4">) {</span>
            <span class="s6">return</span><span class="s4">;</span>
        <span class="s4">}</span>

        <span class="s5">/* 
         * The following process is executed only when there is a `finally` 
         * block and there was a `return` or `throw` in the `try` or `catch` 
         * blocks. 
         */</span>

        <span class="s5">// Separate head to normal paths and leaving paths.</span>
        <span class="s6">const </span><span class="s2">headSegments </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">head</span><span class="s4">;</span>

        <span class="s6">this</span><span class="s4">.</span><span class="s2">forkContext </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">upper</span><span class="s4">;</span>
        <span class="s6">const </span><span class="s2">normalSegments </span><span class="s4">= </span><span class="s2">headSegments</span><span class="s4">.</span><span class="s2">slice</span><span class="s4">(</span><span class="s7">0</span><span class="s4">, </span><span class="s2">headSegments</span><span class="s4">.</span><span class="s2">length </span><span class="s4">/ </span><span class="s7">2 </span><span class="s4">| </span><span class="s7">0</span><span class="s4">);</span>
        <span class="s6">const </span><span class="s2">leavingSegments </span><span class="s4">= </span><span class="s2">headSegments</span><span class="s4">.</span><span class="s2">slice</span><span class="s4">(</span><span class="s2">headSegments</span><span class="s4">.</span><span class="s2">length </span><span class="s4">/ </span><span class="s7">2 </span><span class="s4">| </span><span class="s7">0</span><span class="s4">);</span>

        <span class="s5">// Forwards the leaving path to upper contexts.</span>
        <span class="s6">if </span><span class="s4">(!</span><span class="s2">originalReturnedForkContext</span><span class="s4">.</span><span class="s2">empty</span><span class="s4">) {</span>
            <span class="s2">getReturnContext</span><span class="s4">(</span><span class="s6">this</span><span class="s4">).</span><span class="s2">returnedForkContext</span><span class="s4">.</span><span class="s2">add</span><span class="s4">(</span><span class="s2">leavingSegments</span><span class="s4">);</span>
        <span class="s4">}</span>
        <span class="s6">if </span><span class="s4">(!</span><span class="s2">originalThrownForkContext</span><span class="s4">.</span><span class="s2">empty</span><span class="s4">) {</span>
            <span class="s2">getThrowContext</span><span class="s4">(</span><span class="s6">this</span><span class="s4">).</span><span class="s2">thrownForkContext</span><span class="s4">.</span><span class="s2">add</span><span class="s4">(</span><span class="s2">leavingSegments</span><span class="s4">);</span>
        <span class="s4">}</span>

        <span class="s5">// Sets the normal path as the next.</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">replaceHead</span><span class="s4">(</span><span class="s2">normalSegments</span><span class="s4">);</span>

        <span class="s5">/* 
         * If both paths of the `try` block and the `catch` block are 
         * unreachable, the next path becomes unreachable as well. 
         */</span>
        <span class="s6">if </span><span class="s4">(!</span><span class="s2">context</span><span class="s4">.</span><span class="s2">lastOfTryIsReachable </span><span class="s4">&amp;&amp; !</span><span class="s2">context</span><span class="s4">.</span><span class="s2">lastOfCatchIsReachable</span><span class="s4">) {</span>
            <span class="s6">this</span><span class="s4">.</span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">makeUnreachable</span><span class="s4">();</span>
        <span class="s4">}</span>
    <span class="s4">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Makes a code path segment for a `catch` block.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
     <span class="s0">*/</span>
    <span class="s2">makeCatchBlock</span><span class="s4">() {</span>
        <span class="s6">const </span><span class="s2">context </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">tryContext</span><span class="s4">;</span>
        <span class="s6">const </span><span class="s2">forkContext </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">forkContext</span><span class="s4">;</span>
        <span class="s6">const </span><span class="s2">originalThrownForkContext </span><span class="s4">= </span><span class="s2">context</span><span class="s4">.</span><span class="s2">thrownForkContext</span><span class="s4">;</span>

        <span class="s5">/* 
         * We are now in a catch block so we need to update the context 
         * with that information. This includes creating a new fork 
         * context in case we encounter any `throw` statements here. 
         */</span>
        <span class="s2">context</span><span class="s4">.</span><span class="s2">position </span><span class="s4">= </span><span class="s3">&quot;catch&quot;</span><span class="s4">;</span>
        <span class="s2">context</span><span class="s4">.</span><span class="s2">thrownForkContext </span><span class="s4">= </span><span class="s2">ForkContext</span><span class="s4">.</span><span class="s2">newEmpty</span><span class="s4">(</span><span class="s2">forkContext</span><span class="s4">);</span>
        <span class="s2">context</span><span class="s4">.</span><span class="s2">lastOfTryIsReachable </span><span class="s4">= </span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">reachable</span><span class="s4">;</span>

        <span class="s5">// Merge the thrown paths from the `try` and `catch` blocks</span>
        <span class="s2">originalThrownForkContext</span><span class="s4">.</span><span class="s2">add</span><span class="s4">(</span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">head</span><span class="s4">);</span>
        <span class="s6">const </span><span class="s2">thrownSegments </span><span class="s4">= </span><span class="s2">originalThrownForkContext</span><span class="s4">.</span><span class="s2">makeNext</span><span class="s4">(</span><span class="s7">0</span><span class="s4">, -</span><span class="s7">1</span><span class="s4">);</span>

        <span class="s5">// Fork to a bypass and the merged thrown path.</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">pushForkContext</span><span class="s4">();</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">forkBypassPath</span><span class="s4">();</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">add</span><span class="s4">(</span><span class="s2">thrownSegments</span><span class="s4">);</span>
    <span class="s4">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Makes a code path segment for a `finally` block.</span>
     <span class="s0">*</span>
     <span class="s0">* In the `finally` block, parallel paths are created. The parallel paths</span>
     <span class="s0">* are used as leaving-paths. The leaving-paths are paths from `return`</span>
     <span class="s0">* statements and `throw` statements in a `try` block or a `catch` block.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
     <span class="s0">*/</span>
    <span class="s2">makeFinallyBlock</span><span class="s4">() {</span>
        <span class="s6">const </span><span class="s2">context </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">tryContext</span><span class="s4">;</span>
        <span class="s6">let </span><span class="s2">forkContext </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">forkContext</span><span class="s4">;</span>
        <span class="s6">const </span><span class="s2">originalReturnedForkContext </span><span class="s4">= </span><span class="s2">context</span><span class="s4">.</span><span class="s2">returnedForkContext</span><span class="s4">;</span>
        <span class="s6">const </span><span class="s2">originalThrownForContext </span><span class="s4">= </span><span class="s2">context</span><span class="s4">.</span><span class="s2">thrownForkContext</span><span class="s4">;</span>
        <span class="s6">const </span><span class="s2">headOfLeavingSegments </span><span class="s4">= </span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">head</span><span class="s4">;</span>

        <span class="s5">// Update state.</span>
        <span class="s6">if </span><span class="s4">(</span><span class="s2">context</span><span class="s4">.</span><span class="s2">position </span><span class="s4">=== </span><span class="s3">&quot;catch&quot;</span><span class="s4">) {</span>

            <span class="s5">// Merges two paths from the `try` block and `catch` block.</span>
            <span class="s6">this</span><span class="s4">.</span><span class="s2">popForkContext</span><span class="s4">();</span>
            <span class="s2">forkContext </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">forkContext</span><span class="s4">;</span>

            <span class="s2">context</span><span class="s4">.</span><span class="s2">lastOfCatchIsReachable </span><span class="s4">= </span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">reachable</span><span class="s4">;</span>
        <span class="s4">} </span><span class="s6">else </span><span class="s4">{</span>
            <span class="s2">context</span><span class="s4">.</span><span class="s2">lastOfTryIsReachable </span><span class="s4">= </span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">reachable</span><span class="s4">;</span>
        <span class="s4">}</span>


        <span class="s2">context</span><span class="s4">.</span><span class="s2">position </span><span class="s4">= </span><span class="s3">&quot;finally&quot;</span><span class="s4">;</span>

        <span class="s5">/* 
         * If there was no `return` or `throw` in either the `try` or `catch` 
         * blocks, then there's no further code paths to create for `finally`. 
         */</span>
        <span class="s6">if </span><span class="s4">(</span><span class="s2">originalReturnedForkContext</span><span class="s4">.</span><span class="s2">empty </span><span class="s4">&amp;&amp; </span><span class="s2">originalThrownForContext</span><span class="s4">.</span><span class="s2">empty</span><span class="s4">) {</span>

            <span class="s5">// This path does not leave.</span>
            <span class="s6">return</span><span class="s4">;</span>
        <span class="s4">}</span>

        <span class="s5">/* 
         * Create a parallel segment from merging returned and thrown. 
         * This segment will leave at the end of this `finally` block. 
         */</span>
        <span class="s6">const </span><span class="s2">segments </span><span class="s4">= </span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">makeNext</span><span class="s4">(-</span><span class="s7">1</span><span class="s4">, -</span><span class="s7">1</span><span class="s4">);</span>

        <span class="s6">for </span><span class="s4">(</span><span class="s6">let </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">count</span><span class="s4">; ++</span><span class="s2">i</span><span class="s4">) {</span>
            <span class="s6">const </span><span class="s2">prevSegsOfLeavingSegment </span><span class="s4">= [</span><span class="s2">headOfLeavingSegments</span><span class="s4">[</span><span class="s2">i</span><span class="s4">]];</span>

            <span class="s6">for </span><span class="s4">(</span><span class="s6">let </span><span class="s2">j </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">j </span><span class="s4">&lt; </span><span class="s2">originalReturnedForkContext</span><span class="s4">.</span><span class="s2">segmentsList</span><span class="s4">.</span><span class="s2">length</span><span class="s4">; ++</span><span class="s2">j</span><span class="s4">) {</span>
                <span class="s2">prevSegsOfLeavingSegment</span><span class="s4">.</span><span class="s2">push</span><span class="s4">(</span><span class="s2">originalReturnedForkContext</span><span class="s4">.</span><span class="s2">segmentsList</span><span class="s4">[</span><span class="s2">j</span><span class="s4">][</span><span class="s2">i</span><span class="s4">]);</span>
            <span class="s4">}</span>
            <span class="s6">for </span><span class="s4">(</span><span class="s6">let </span><span class="s2">j </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">j </span><span class="s4">&lt; </span><span class="s2">originalThrownForContext</span><span class="s4">.</span><span class="s2">segmentsList</span><span class="s4">.</span><span class="s2">length</span><span class="s4">; ++</span><span class="s2">j</span><span class="s4">) {</span>
                <span class="s2">prevSegsOfLeavingSegment</span><span class="s4">.</span><span class="s2">push</span><span class="s4">(</span><span class="s2">originalThrownForContext</span><span class="s4">.</span><span class="s2">segmentsList</span><span class="s4">[</span><span class="s2">j</span><span class="s4">][</span><span class="s2">i</span><span class="s4">]);</span>
            <span class="s4">}</span>

            <span class="s2">segments</span><span class="s4">.</span><span class="s2">push</span><span class="s4">(</span>
                <span class="s2">CodePathSegment</span><span class="s4">.</span><span class="s2">newNext</span><span class="s4">(</span>
                    <span class="s6">this</span><span class="s4">.</span><span class="s2">idGenerator</span><span class="s4">.</span><span class="s2">next</span><span class="s4">(),</span>
                    <span class="s2">prevSegsOfLeavingSegment</span>
                <span class="s4">)</span>
            <span class="s4">);</span>
        <span class="s4">}</span>

        <span class="s6">this</span><span class="s4">.</span><span class="s2">pushForkContext</span><span class="s4">(</span><span class="s6">true</span><span class="s4">);</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">add</span><span class="s4">(</span><span class="s2">segments</span><span class="s4">);</span>
    <span class="s4">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Makes a code path segment from the first throwable node to the `catch`</span>
     <span class="s0">* block or the `finally` block.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
     <span class="s0">*/</span>
    <span class="s2">makeFirstThrowablePathInTryBlock</span><span class="s4">() {</span>
        <span class="s6">const </span><span class="s2">forkContext </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">forkContext</span><span class="s4">;</span>

        <span class="s6">if </span><span class="s4">(!</span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">reachable</span><span class="s4">) {</span>
            <span class="s6">return</span><span class="s4">;</span>
        <span class="s4">}</span>

        <span class="s6">const </span><span class="s2">context </span><span class="s4">= </span><span class="s2">getThrowContext</span><span class="s4">(</span><span class="s6">this</span><span class="s4">);</span>

        <span class="s6">if </span><span class="s4">(</span><span class="s2">context </span><span class="s4">=== </span><span class="s6">this </span><span class="s4">||</span>
            <span class="s2">context</span><span class="s4">.</span><span class="s2">position </span><span class="s4">!== </span><span class="s3">&quot;try&quot; </span><span class="s4">||</span>
            <span class="s4">!</span><span class="s2">context</span><span class="s4">.</span><span class="s2">thrownForkContext</span><span class="s4">.</span><span class="s2">empty</span>
        <span class="s4">) {</span>
            <span class="s6">return</span><span class="s4">;</span>
        <span class="s4">}</span>

        <span class="s2">context</span><span class="s4">.</span><span class="s2">thrownForkContext</span><span class="s4">.</span><span class="s2">add</span><span class="s4">(</span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">head</span><span class="s4">);</span>
        <span class="s2">forkContext</span><span class="s4">.</span><span class="s2">replaceHead</span><span class="s4">(</span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">makeNext</span><span class="s4">(-</span><span class="s7">1</span><span class="s4">, -</span><span class="s7">1</span><span class="s4">));</span>
    <span class="s4">}</span>

    <span class="s5">//--------------------------------------------------------------------------</span>
    <span class="s5">// Loop Statements</span>
    <span class="s5">//--------------------------------------------------------------------------</span>

    <span class="s0">/**</span>
     <span class="s0">* Creates a context object of a loop statement and stacks it.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} type The type of the node which was triggered. One of</span>
     <span class="s0">*   `WhileStatement`, `DoWhileStatement`, `ForStatement`, `ForInStatement`,</span>
     <span class="s0">*   and `ForStatement`.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|null} label A label of the node which was triggered.</span>
     <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{Error} (Unreachable - unknown type.)</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
     <span class="s0">*/</span>
    <span class="s2">pushLoopContext</span><span class="s4">(</span><span class="s2">type</span><span class="s4">, </span><span class="s2">label</span><span class="s4">) {</span>
        <span class="s6">const </span><span class="s2">forkContext </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">forkContext</span><span class="s4">;</span>

        <span class="s5">// All loops need a path to account for `break` statements</span>
        <span class="s6">const </span><span class="s2">breakContext </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">pushBreakContext</span><span class="s4">(</span><span class="s6">true</span><span class="s4">, </span><span class="s2">label</span><span class="s4">);</span>

        <span class="s6">switch </span><span class="s4">(</span><span class="s2">type</span><span class="s4">) {</span>
            <span class="s6">case </span><span class="s3">&quot;WhileStatement&quot;</span><span class="s4">:</span>
                <span class="s6">this</span><span class="s4">.</span><span class="s2">pushChoiceContext</span><span class="s4">(</span><span class="s3">&quot;loop&quot;</span><span class="s4">, </span><span class="s6">false</span><span class="s4">);</span>
                <span class="s6">this</span><span class="s4">.</span><span class="s2">loopContext </span><span class="s4">= </span><span class="s6">new </span><span class="s2">WhileLoopContext</span><span class="s4">(</span><span class="s6">this</span><span class="s4">.</span><span class="s2">loopContext</span><span class="s4">, </span><span class="s2">label</span><span class="s4">, </span><span class="s2">breakContext</span><span class="s4">);</span>
                <span class="s6">break</span><span class="s4">;</span>

            <span class="s6">case </span><span class="s3">&quot;DoWhileStatement&quot;</span><span class="s4">:</span>
                <span class="s6">this</span><span class="s4">.</span><span class="s2">pushChoiceContext</span><span class="s4">(</span><span class="s3">&quot;loop&quot;</span><span class="s4">, </span><span class="s6">false</span><span class="s4">);</span>
                <span class="s6">this</span><span class="s4">.</span><span class="s2">loopContext </span><span class="s4">= </span><span class="s6">new </span><span class="s2">DoWhileLoopContext</span><span class="s4">(</span><span class="s6">this</span><span class="s4">.</span><span class="s2">loopContext</span><span class="s4">, </span><span class="s2">label</span><span class="s4">, </span><span class="s2">breakContext</span><span class="s4">, </span><span class="s2">forkContext</span><span class="s4">);</span>
                <span class="s6">break</span><span class="s4">;</span>

            <span class="s6">case </span><span class="s3">&quot;ForStatement&quot;</span><span class="s4">:</span>
                <span class="s6">this</span><span class="s4">.</span><span class="s2">pushChoiceContext</span><span class="s4">(</span><span class="s3">&quot;loop&quot;</span><span class="s4">, </span><span class="s6">false</span><span class="s4">);</span>
                <span class="s6">this</span><span class="s4">.</span><span class="s2">loopContext </span><span class="s4">= </span><span class="s6">new </span><span class="s2">ForLoopContext</span><span class="s4">(</span><span class="s6">this</span><span class="s4">.</span><span class="s2">loopContext</span><span class="s4">, </span><span class="s2">label</span><span class="s4">, </span><span class="s2">breakContext</span><span class="s4">);</span>
                <span class="s6">break</span><span class="s4">;</span>

            <span class="s6">case </span><span class="s3">&quot;ForInStatement&quot;</span><span class="s4">:</span>
                <span class="s6">this</span><span class="s4">.</span><span class="s2">loopContext </span><span class="s4">= </span><span class="s6">new </span><span class="s2">ForInLoopContext</span><span class="s4">(</span><span class="s6">this</span><span class="s4">.</span><span class="s2">loopContext</span><span class="s4">, </span><span class="s2">label</span><span class="s4">, </span><span class="s2">breakContext</span><span class="s4">);</span>
                <span class="s6">break</span><span class="s4">;</span>

            <span class="s6">case </span><span class="s3">&quot;ForOfStatement&quot;</span><span class="s4">:</span>
                <span class="s6">this</span><span class="s4">.</span><span class="s2">loopContext </span><span class="s4">= </span><span class="s6">new </span><span class="s2">ForOfLoopContext</span><span class="s4">(</span><span class="s6">this</span><span class="s4">.</span><span class="s2">loopContext</span><span class="s4">, </span><span class="s2">label</span><span class="s4">, </span><span class="s2">breakContext</span><span class="s4">);</span>
                <span class="s6">break</span><span class="s4">;</span>

            <span class="s5">/* c8 ignore next */</span>
            <span class="s6">default</span><span class="s4">:</span>
                <span class="s6">throw new </span><span class="s2">Error</span><span class="s4">(</span><span class="s3">`unknown type: &quot;</span><span class="s2">$</span><span class="s4">{</span><span class="s2">type</span><span class="s4">}</span><span class="s3">&quot;`</span><span class="s4">);</span>
        <span class="s4">}</span>
    <span class="s4">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Pops the last context of a loop statement and finalizes it.</span>
     <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{Error} (Unreachable - unknown type.)</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
     <span class="s0">*/</span>
    <span class="s2">popLoopContext</span><span class="s4">() {</span>
        <span class="s6">const </span><span class="s2">context </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">loopContext</span><span class="s4">;</span>

        <span class="s6">this</span><span class="s4">.</span><span class="s2">loopContext </span><span class="s4">= </span><span class="s2">context</span><span class="s4">.</span><span class="s2">upper</span><span class="s4">;</span>

        <span class="s6">const </span><span class="s2">forkContext </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">forkContext</span><span class="s4">;</span>
        <span class="s6">const </span><span class="s2">brokenForkContext </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">popBreakContext</span><span class="s4">().</span><span class="s2">brokenForkContext</span><span class="s4">;</span>

        <span class="s5">// Creates a looped path.</span>
        <span class="s6">switch </span><span class="s4">(</span><span class="s2">context</span><span class="s4">.</span><span class="s2">type</span><span class="s4">) {</span>
            <span class="s6">case </span><span class="s3">&quot;WhileStatement&quot;</span><span class="s4">:</span>
            <span class="s6">case </span><span class="s3">&quot;ForStatement&quot;</span><span class="s4">:</span>
                <span class="s6">this</span><span class="s4">.</span><span class="s2">popChoiceContext</span><span class="s4">();</span>

                <span class="s5">/* 
                 * Creates the path from the end of the loop body up to the 
                 * location where `continue` would jump to. 
                 */</span>
                <span class="s2">makeLooped</span><span class="s4">(</span>
                    <span class="s6">this</span><span class="s4">,</span>
                    <span class="s2">forkContext</span><span class="s4">.</span><span class="s2">head</span><span class="s4">,</span>
                    <span class="s2">context</span><span class="s4">.</span><span class="s2">continueDestSegments</span>
                <span class="s4">);</span>
                <span class="s6">break</span><span class="s4">;</span>

            <span class="s6">case </span><span class="s3">&quot;DoWhileStatement&quot;</span><span class="s4">: {</span>
                <span class="s6">const </span><span class="s2">choiceContext </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">popChoiceContext</span><span class="s4">();</span>

                <span class="s6">if </span><span class="s4">(!</span><span class="s2">choiceContext</span><span class="s4">.</span><span class="s2">processed</span><span class="s4">) {</span>
                    <span class="s2">choiceContext</span><span class="s4">.</span><span class="s2">trueForkContext</span><span class="s4">.</span><span class="s2">add</span><span class="s4">(</span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">head</span><span class="s4">);</span>
                    <span class="s2">choiceContext</span><span class="s4">.</span><span class="s2">falseForkContext</span><span class="s4">.</span><span class="s2">add</span><span class="s4">(</span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">head</span><span class="s4">);</span>
                <span class="s4">}</span>

                <span class="s5">/* 
                 * If this isn't a hardcoded `true` condition, then `break` 
                 * should continue down the path as if the condition evaluated 
                 * to false. 
                 */</span>
                <span class="s6">if </span><span class="s4">(</span><span class="s2">context</span><span class="s4">.</span><span class="s2">test </span><span class="s4">!== </span><span class="s6">true</span><span class="s4">) {</span>
                    <span class="s2">brokenForkContext</span><span class="s4">.</span><span class="s2">addAll</span><span class="s4">(</span><span class="s2">choiceContext</span><span class="s4">.</span><span class="s2">falseForkContext</span><span class="s4">);</span>
                <span class="s4">}</span>

                <span class="s5">/* 
                 * When the condition is true, the loop continues back to the top, 
                 * so create a path from each possible true condition back to the 
                 * top of the loop. 
                 */</span>
                <span class="s6">const </span><span class="s2">segmentsList </span><span class="s4">= </span><span class="s2">choiceContext</span><span class="s4">.</span><span class="s2">trueForkContext</span><span class="s4">.</span><span class="s2">segmentsList</span><span class="s4">;</span>

                <span class="s6">for </span><span class="s4">(</span><span class="s6">let </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s2">segmentsList</span><span class="s4">.</span><span class="s2">length</span><span class="s4">; ++</span><span class="s2">i</span><span class="s4">) {</span>
                    <span class="s2">makeLooped</span><span class="s4">(</span>
                        <span class="s6">this</span><span class="s4">,</span>
                        <span class="s2">segmentsList</span><span class="s4">[</span><span class="s2">i</span><span class="s4">],</span>
                        <span class="s2">context</span><span class="s4">.</span><span class="s2">entrySegments</span>
                    <span class="s4">);</span>
                <span class="s4">}</span>
                <span class="s6">break</span><span class="s4">;</span>
            <span class="s4">}</span>

            <span class="s6">case </span><span class="s3">&quot;ForInStatement&quot;</span><span class="s4">:</span>
            <span class="s6">case </span><span class="s3">&quot;ForOfStatement&quot;</span><span class="s4">:</span>
                <span class="s2">brokenForkContext</span><span class="s4">.</span><span class="s2">add</span><span class="s4">(</span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">head</span><span class="s4">);</span>

                <span class="s5">/* 
                 * Creates the path from the end of the loop body up to the 
                 * left expression (left of `in` or `of`) of the loop. 
                 */</span>
                <span class="s2">makeLooped</span><span class="s4">(</span>
                    <span class="s6">this</span><span class="s4">,</span>
                    <span class="s2">forkContext</span><span class="s4">.</span><span class="s2">head</span><span class="s4">,</span>
                    <span class="s2">context</span><span class="s4">.</span><span class="s2">leftSegments</span>
                <span class="s4">);</span>
                <span class="s6">break</span><span class="s4">;</span>

            <span class="s5">/* c8 ignore next */</span>
            <span class="s6">default</span><span class="s4">:</span>
                <span class="s6">throw new </span><span class="s2">Error</span><span class="s4">(</span><span class="s3">&quot;unreachable&quot;</span><span class="s4">);</span>
        <span class="s4">}</span>

        <span class="s5">/* 
         * If there wasn't a `break` statement in the loop, then we're at 
         * the end of the loop's path, so we make an unreachable segment 
         * to mark that. 
         * 
         * If there was a `break` statement, then we continue on into the 
         * `brokenForkContext`. 
         */</span>
        <span class="s6">if </span><span class="s4">(</span><span class="s2">brokenForkContext</span><span class="s4">.</span><span class="s2">empty</span><span class="s4">) {</span>
            <span class="s2">forkContext</span><span class="s4">.</span><span class="s2">replaceHead</span><span class="s4">(</span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">makeUnreachable</span><span class="s4">(-</span><span class="s7">1</span><span class="s4">, -</span><span class="s7">1</span><span class="s4">));</span>
        <span class="s4">} </span><span class="s6">else </span><span class="s4">{</span>
            <span class="s2">forkContext</span><span class="s4">.</span><span class="s2">replaceHead</span><span class="s4">(</span><span class="s2">brokenForkContext</span><span class="s4">.</span><span class="s2">makeNext</span><span class="s4">(</span><span class="s7">0</span><span class="s4">, -</span><span class="s7">1</span><span class="s4">));</span>
        <span class="s4">}</span>
    <span class="s4">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Makes a code path segment for the test part of a WhileStatement.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{boolean|undefined} test The test value (only when constant).</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
     <span class="s0">*/</span>
    <span class="s2">makeWhileTest</span><span class="s4">(</span><span class="s2">test</span><span class="s4">) {</span>
        <span class="s6">const </span><span class="s2">context </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">loopContext</span><span class="s4">;</span>
        <span class="s6">const </span><span class="s2">forkContext </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">forkContext</span><span class="s4">;</span>
        <span class="s6">const </span><span class="s2">testSegments </span><span class="s4">= </span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">makeNext</span><span class="s4">(</span><span class="s7">0</span><span class="s4">, -</span><span class="s7">1</span><span class="s4">);</span>

        <span class="s5">// Update state.</span>
        <span class="s2">context</span><span class="s4">.</span><span class="s2">test </span><span class="s4">= </span><span class="s2">test</span><span class="s4">;</span>
        <span class="s2">context</span><span class="s4">.</span><span class="s2">continueDestSegments </span><span class="s4">= </span><span class="s2">testSegments</span><span class="s4">;</span>
        <span class="s2">forkContext</span><span class="s4">.</span><span class="s2">replaceHead</span><span class="s4">(</span><span class="s2">testSegments</span><span class="s4">);</span>
    <span class="s4">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Makes a code path segment for the body part of a WhileStatement.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
     <span class="s0">*/</span>
    <span class="s2">makeWhileBody</span><span class="s4">() {</span>
        <span class="s6">const </span><span class="s2">context </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">loopContext</span><span class="s4">;</span>
        <span class="s6">const </span><span class="s2">choiceContext </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">choiceContext</span><span class="s4">;</span>
        <span class="s6">const </span><span class="s2">forkContext </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">forkContext</span><span class="s4">;</span>

        <span class="s6">if </span><span class="s4">(!</span><span class="s2">choiceContext</span><span class="s4">.</span><span class="s2">processed</span><span class="s4">) {</span>
            <span class="s2">choiceContext</span><span class="s4">.</span><span class="s2">trueForkContext</span><span class="s4">.</span><span class="s2">add</span><span class="s4">(</span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">head</span><span class="s4">);</span>
            <span class="s2">choiceContext</span><span class="s4">.</span><span class="s2">falseForkContext</span><span class="s4">.</span><span class="s2">add</span><span class="s4">(</span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">head</span><span class="s4">);</span>
        <span class="s4">}</span>

        <span class="s5">/* 
         * If this isn't a hardcoded `true` condition, then `break` 
         * should continue down the path as if the condition evaluated 
         * to false. 
         */</span>
        <span class="s6">if </span><span class="s4">(</span><span class="s2">context</span><span class="s4">.</span><span class="s2">test </span><span class="s4">!== </span><span class="s6">true</span><span class="s4">) {</span>
            <span class="s2">context</span><span class="s4">.</span><span class="s2">brokenForkContext</span><span class="s4">.</span><span class="s2">addAll</span><span class="s4">(</span><span class="s2">choiceContext</span><span class="s4">.</span><span class="s2">falseForkContext</span><span class="s4">);</span>
        <span class="s4">}</span>
        <span class="s2">forkContext</span><span class="s4">.</span><span class="s2">replaceHead</span><span class="s4">(</span><span class="s2">choiceContext</span><span class="s4">.</span><span class="s2">trueForkContext</span><span class="s4">.</span><span class="s2">makeNext</span><span class="s4">(</span><span class="s7">0</span><span class="s4">, -</span><span class="s7">1</span><span class="s4">));</span>
    <span class="s4">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Makes a code path segment for the body part of a DoWhileStatement.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
     <span class="s0">*/</span>
    <span class="s2">makeDoWhileBody</span><span class="s4">() {</span>
        <span class="s6">const </span><span class="s2">context </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">loopContext</span><span class="s4">;</span>
        <span class="s6">const </span><span class="s2">forkContext </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">forkContext</span><span class="s4">;</span>
        <span class="s6">const </span><span class="s2">bodySegments </span><span class="s4">= </span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">makeNext</span><span class="s4">(-</span><span class="s7">1</span><span class="s4">, -</span><span class="s7">1</span><span class="s4">);</span>

        <span class="s5">// Update state.</span>
        <span class="s2">context</span><span class="s4">.</span><span class="s2">entrySegments </span><span class="s4">= </span><span class="s2">bodySegments</span><span class="s4">;</span>
        <span class="s2">forkContext</span><span class="s4">.</span><span class="s2">replaceHead</span><span class="s4">(</span><span class="s2">bodySegments</span><span class="s4">);</span>
    <span class="s4">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Makes a code path segment for the test part of a DoWhileStatement.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{boolean|undefined} test The test value (only when constant).</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
     <span class="s0">*/</span>
    <span class="s2">makeDoWhileTest</span><span class="s4">(</span><span class="s2">test</span><span class="s4">) {</span>
        <span class="s6">const </span><span class="s2">context </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">loopContext</span><span class="s4">;</span>
        <span class="s6">const </span><span class="s2">forkContext </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">forkContext</span><span class="s4">;</span>

        <span class="s2">context</span><span class="s4">.</span><span class="s2">test </span><span class="s4">= </span><span class="s2">test</span><span class="s4">;</span>

        <span class="s5">/* 
         * If there is a `continue` statement in the loop then `continueForkContext` 
         * won't be empty. We wire up the path from `continue` to the loop 
         * test condition and then continue the traversal in the root fork context. 
         */</span>
        <span class="s6">if </span><span class="s4">(!</span><span class="s2">context</span><span class="s4">.</span><span class="s2">continueForkContext</span><span class="s4">.</span><span class="s2">empty</span><span class="s4">) {</span>
            <span class="s2">context</span><span class="s4">.</span><span class="s2">continueForkContext</span><span class="s4">.</span><span class="s2">add</span><span class="s4">(</span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">head</span><span class="s4">);</span>
            <span class="s6">const </span><span class="s2">testSegments </span><span class="s4">= </span><span class="s2">context</span><span class="s4">.</span><span class="s2">continueForkContext</span><span class="s4">.</span><span class="s2">makeNext</span><span class="s4">(</span><span class="s7">0</span><span class="s4">, -</span><span class="s7">1</span><span class="s4">);</span>

            <span class="s2">forkContext</span><span class="s4">.</span><span class="s2">replaceHead</span><span class="s4">(</span><span class="s2">testSegments</span><span class="s4">);</span>
        <span class="s4">}</span>
    <span class="s4">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Makes a code path segment for the test part of a ForStatement.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{boolean|undefined} test The test value (only when constant).</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
     <span class="s0">*/</span>
    <span class="s2">makeForTest</span><span class="s4">(</span><span class="s2">test</span><span class="s4">) {</span>
        <span class="s6">const </span><span class="s2">context </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">loopContext</span><span class="s4">;</span>
        <span class="s6">const </span><span class="s2">forkContext </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">forkContext</span><span class="s4">;</span>
        <span class="s6">const </span><span class="s2">endOfInitSegments </span><span class="s4">= </span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">head</span><span class="s4">;</span>
        <span class="s6">const </span><span class="s2">testSegments </span><span class="s4">= </span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">makeNext</span><span class="s4">(-</span><span class="s7">1</span><span class="s4">, -</span><span class="s7">1</span><span class="s4">);</span>

        <span class="s5">/* 
         * Update the state. 
         * 
         * The `continueDestSegments` are set to `testSegments` because we 
         * don't yet know if there is an update expression in this loop. So, 
         * from what we already know at this point, a `continue` statement 
         * will jump back to the test expression. 
         */</span>
        <span class="s2">context</span><span class="s4">.</span><span class="s2">test </span><span class="s4">= </span><span class="s2">test</span><span class="s4">;</span>
        <span class="s2">context</span><span class="s4">.</span><span class="s2">endOfInitSegments </span><span class="s4">= </span><span class="s2">endOfInitSegments</span><span class="s4">;</span>
        <span class="s2">context</span><span class="s4">.</span><span class="s2">continueDestSegments </span><span class="s4">= </span><span class="s2">context</span><span class="s4">.</span><span class="s2">testSegments </span><span class="s4">= </span><span class="s2">testSegments</span><span class="s4">;</span>
        <span class="s2">forkContext</span><span class="s4">.</span><span class="s2">replaceHead</span><span class="s4">(</span><span class="s2">testSegments</span><span class="s4">);</span>
    <span class="s4">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Makes a code path segment for the update part of a ForStatement.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
     <span class="s0">*/</span>
    <span class="s2">makeForUpdate</span><span class="s4">() {</span>
        <span class="s6">const </span><span class="s2">context </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">loopContext</span><span class="s4">;</span>
        <span class="s6">const </span><span class="s2">choiceContext </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">choiceContext</span><span class="s4">;</span>
        <span class="s6">const </span><span class="s2">forkContext </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">forkContext</span><span class="s4">;</span>

        <span class="s5">// Make the next paths of the test.</span>
        <span class="s6">if </span><span class="s4">(</span><span class="s2">context</span><span class="s4">.</span><span class="s2">testSegments</span><span class="s4">) {</span>
            <span class="s2">finalizeTestSegmentsOfFor</span><span class="s4">(</span>
                <span class="s2">context</span><span class="s4">,</span>
                <span class="s2">choiceContext</span><span class="s4">,</span>
                <span class="s2">forkContext</span><span class="s4">.</span><span class="s2">head</span>
            <span class="s4">);</span>
        <span class="s4">} </span><span class="s6">else </span><span class="s4">{</span>
            <span class="s2">context</span><span class="s4">.</span><span class="s2">endOfInitSegments </span><span class="s4">= </span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">head</span><span class="s4">;</span>
        <span class="s4">}</span>

        <span class="s5">/* 
         * Update the state. 
         * 
         * The `continueDestSegments` are now set to `updateSegments` because we 
         * know there is an update expression in this loop. So, a `continue` statement 
         * in the loop will jump to the update expression first, and then to any 
         * test expression the loop might have. 
         */</span>
        <span class="s6">const </span><span class="s2">updateSegments </span><span class="s4">= </span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">makeDisconnected</span><span class="s4">(-</span><span class="s7">1</span><span class="s4">, -</span><span class="s7">1</span><span class="s4">);</span>

        <span class="s2">context</span><span class="s4">.</span><span class="s2">continueDestSegments </span><span class="s4">= </span><span class="s2">context</span><span class="s4">.</span><span class="s2">updateSegments </span><span class="s4">= </span><span class="s2">updateSegments</span><span class="s4">;</span>
        <span class="s2">forkContext</span><span class="s4">.</span><span class="s2">replaceHead</span><span class="s4">(</span><span class="s2">updateSegments</span><span class="s4">);</span>
    <span class="s4">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Makes a code path segment for the body part of a ForStatement.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
     <span class="s0">*/</span>
    <span class="s2">makeForBody</span><span class="s4">() {</span>
        <span class="s6">const </span><span class="s2">context </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">loopContext</span><span class="s4">;</span>
        <span class="s6">const </span><span class="s2">choiceContext </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">choiceContext</span><span class="s4">;</span>
        <span class="s6">const </span><span class="s2">forkContext </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">forkContext</span><span class="s4">;</span>

        <span class="s5">/* 
         * Determine what to do based on which part of the `for` loop are present. 
         * 1. If there is an update expression, then `updateSegments` is not null and 
         *    we need to assign `endOfUpdateSegments`, and if there is a test 
         *    expression, we then need to create the looped path to get back to 
         *    the test condition. 
         * 2. If there is no update expression but there is a test expression, 
         *    then we only need to update the test segment information. 
         * 3. If there is no update expression and no test expression, then we 
         *    just save `endOfInitSegments`. 
         */</span>
        <span class="s6">if </span><span class="s4">(</span><span class="s2">context</span><span class="s4">.</span><span class="s2">updateSegments</span><span class="s4">) {</span>
            <span class="s2">context</span><span class="s4">.</span><span class="s2">endOfUpdateSegments </span><span class="s4">= </span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">head</span><span class="s4">;</span>

            <span class="s5">/* 
             * In a `for` loop that has both an update expression and a test 
             * condition, execution flows from the test expression into the 
             * loop body, to the update expression, and then back to the test 
             * expression to determine if the loop should continue. 
             * 
             * To account for that, we need to make a path from the end of the 
             * update expression to the start of the test expression. This is 
             * effectively what creates the loop in the code path. 
             */</span>
            <span class="s6">if </span><span class="s4">(</span><span class="s2">context</span><span class="s4">.</span><span class="s2">testSegments</span><span class="s4">) {</span>
                <span class="s2">makeLooped</span><span class="s4">(</span>
                    <span class="s6">this</span><span class="s4">,</span>
                    <span class="s2">context</span><span class="s4">.</span><span class="s2">endOfUpdateSegments</span><span class="s4">,</span>
                    <span class="s2">context</span><span class="s4">.</span><span class="s2">testSegments</span>
                <span class="s4">);</span>
            <span class="s4">}</span>
        <span class="s4">} </span><span class="s6">else if </span><span class="s4">(</span><span class="s2">context</span><span class="s4">.</span><span class="s2">testSegments</span><span class="s4">) {</span>
            <span class="s2">finalizeTestSegmentsOfFor</span><span class="s4">(</span>
                <span class="s2">context</span><span class="s4">,</span>
                <span class="s2">choiceContext</span><span class="s4">,</span>
                <span class="s2">forkContext</span><span class="s4">.</span><span class="s2">head</span>
            <span class="s4">);</span>
        <span class="s4">} </span><span class="s6">else </span><span class="s4">{</span>
            <span class="s2">context</span><span class="s4">.</span><span class="s2">endOfInitSegments </span><span class="s4">= </span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">head</span><span class="s4">;</span>
        <span class="s4">}</span>

        <span class="s6">let </span><span class="s2">bodySegments </span><span class="s4">= </span><span class="s2">context</span><span class="s4">.</span><span class="s2">endOfTestSegments</span><span class="s4">;</span>

        <span class="s5">/* 
         * If there is a test condition, then there `endOfTestSegments` is also 
         * the start of the loop body. If there isn't a test condition then 
         * `bodySegments` will be null and we need to look elsewhere to find 
         * the start of the body. 
         * 
         * The body starts at the end of the init expression and ends at the end 
         * of the update expression, so we use those locations to determine the 
         * body segments. 
         */</span>
        <span class="s6">if </span><span class="s4">(!</span><span class="s2">bodySegments</span><span class="s4">) {</span>

            <span class="s6">const </span><span class="s2">prevForkContext </span><span class="s4">= </span><span class="s2">ForkContext</span><span class="s4">.</span><span class="s2">newEmpty</span><span class="s4">(</span><span class="s2">forkContext</span><span class="s4">);</span>

            <span class="s2">prevForkContext</span><span class="s4">.</span><span class="s2">add</span><span class="s4">(</span><span class="s2">context</span><span class="s4">.</span><span class="s2">endOfInitSegments</span><span class="s4">);</span>
            <span class="s6">if </span><span class="s4">(</span><span class="s2">context</span><span class="s4">.</span><span class="s2">endOfUpdateSegments</span><span class="s4">) {</span>
                <span class="s2">prevForkContext</span><span class="s4">.</span><span class="s2">add</span><span class="s4">(</span><span class="s2">context</span><span class="s4">.</span><span class="s2">endOfUpdateSegments</span><span class="s4">);</span>
            <span class="s4">}</span>

            <span class="s2">bodySegments </span><span class="s4">= </span><span class="s2">prevForkContext</span><span class="s4">.</span><span class="s2">makeNext</span><span class="s4">(</span><span class="s7">0</span><span class="s4">, -</span><span class="s7">1</span><span class="s4">);</span>
        <span class="s4">}</span>

        <span class="s5">/* 
         * If there was no test condition and no update expression, then 
         * `continueDestSegments` will be null. In that case, a 
         * `continue` should skip directly to the body of the loop. 
         * Otherwise, we want to keep the current `continueDestSegments`. 
         */</span>
        <span class="s2">context</span><span class="s4">.</span><span class="s2">continueDestSegments </span><span class="s4">= </span><span class="s2">context</span><span class="s4">.</span><span class="s2">continueDestSegments </span><span class="s4">|| </span><span class="s2">bodySegments</span><span class="s4">;</span>

        <span class="s5">// move pointer to the body</span>
        <span class="s2">forkContext</span><span class="s4">.</span><span class="s2">replaceHead</span><span class="s4">(</span><span class="s2">bodySegments</span><span class="s4">);</span>
    <span class="s4">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Makes a code path segment for the left part of a ForInStatement and a</span>
     <span class="s0">* ForOfStatement.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
     <span class="s0">*/</span>
    <span class="s2">makeForInOfLeft</span><span class="s4">() {</span>
        <span class="s6">const </span><span class="s2">context </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">loopContext</span><span class="s4">;</span>
        <span class="s6">const </span><span class="s2">forkContext </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">forkContext</span><span class="s4">;</span>
        <span class="s6">const </span><span class="s2">leftSegments </span><span class="s4">= </span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">makeDisconnected</span><span class="s4">(-</span><span class="s7">1</span><span class="s4">, -</span><span class="s7">1</span><span class="s4">);</span>

        <span class="s5">// Update state.</span>
        <span class="s2">context</span><span class="s4">.</span><span class="s2">prevSegments </span><span class="s4">= </span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">head</span><span class="s4">;</span>
        <span class="s2">context</span><span class="s4">.</span><span class="s2">leftSegments </span><span class="s4">= </span><span class="s2">context</span><span class="s4">.</span><span class="s2">continueDestSegments </span><span class="s4">= </span><span class="s2">leftSegments</span><span class="s4">;</span>
        <span class="s2">forkContext</span><span class="s4">.</span><span class="s2">replaceHead</span><span class="s4">(</span><span class="s2">leftSegments</span><span class="s4">);</span>
    <span class="s4">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Makes a code path segment for the right part of a ForInStatement and a</span>
     <span class="s0">* ForOfStatement.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
     <span class="s0">*/</span>
    <span class="s2">makeForInOfRight</span><span class="s4">() {</span>
        <span class="s6">const </span><span class="s2">context </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">loopContext</span><span class="s4">;</span>
        <span class="s6">const </span><span class="s2">forkContext </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">forkContext</span><span class="s4">;</span>
        <span class="s6">const </span><span class="s2">temp </span><span class="s4">= </span><span class="s2">ForkContext</span><span class="s4">.</span><span class="s2">newEmpty</span><span class="s4">(</span><span class="s2">forkContext</span><span class="s4">);</span>

        <span class="s2">temp</span><span class="s4">.</span><span class="s2">add</span><span class="s4">(</span><span class="s2">context</span><span class="s4">.</span><span class="s2">prevSegments</span><span class="s4">);</span>
        <span class="s6">const </span><span class="s2">rightSegments </span><span class="s4">= </span><span class="s2">temp</span><span class="s4">.</span><span class="s2">makeNext</span><span class="s4">(-</span><span class="s7">1</span><span class="s4">, -</span><span class="s7">1</span><span class="s4">);</span>

        <span class="s5">// Update state.</span>
        <span class="s2">context</span><span class="s4">.</span><span class="s2">endOfLeftSegments </span><span class="s4">= </span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">head</span><span class="s4">;</span>
        <span class="s2">forkContext</span><span class="s4">.</span><span class="s2">replaceHead</span><span class="s4">(</span><span class="s2">rightSegments</span><span class="s4">);</span>
    <span class="s4">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Makes a code path segment for the body part of a ForInStatement and a</span>
     <span class="s0">* ForOfStatement.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
     <span class="s0">*/</span>
    <span class="s2">makeForInOfBody</span><span class="s4">() {</span>
        <span class="s6">const </span><span class="s2">context </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">loopContext</span><span class="s4">;</span>
        <span class="s6">const </span><span class="s2">forkContext </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">forkContext</span><span class="s4">;</span>
        <span class="s6">const </span><span class="s2">temp </span><span class="s4">= </span><span class="s2">ForkContext</span><span class="s4">.</span><span class="s2">newEmpty</span><span class="s4">(</span><span class="s2">forkContext</span><span class="s4">);</span>

        <span class="s2">temp</span><span class="s4">.</span><span class="s2">add</span><span class="s4">(</span><span class="s2">context</span><span class="s4">.</span><span class="s2">endOfLeftSegments</span><span class="s4">);</span>
        <span class="s6">const </span><span class="s2">bodySegments </span><span class="s4">= </span><span class="s2">temp</span><span class="s4">.</span><span class="s2">makeNext</span><span class="s4">(-</span><span class="s7">1</span><span class="s4">, -</span><span class="s7">1</span><span class="s4">);</span>

        <span class="s5">// Make a path: `right` -&gt; `left`.</span>
        <span class="s2">makeLooped</span><span class="s4">(</span><span class="s6">this</span><span class="s4">, </span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">head</span><span class="s4">, </span><span class="s2">context</span><span class="s4">.</span><span class="s2">leftSegments</span><span class="s4">);</span>

        <span class="s5">// Update state.</span>
        <span class="s2">context</span><span class="s4">.</span><span class="s2">brokenForkContext</span><span class="s4">.</span><span class="s2">add</span><span class="s4">(</span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">head</span><span class="s4">);</span>
        <span class="s2">forkContext</span><span class="s4">.</span><span class="s2">replaceHead</span><span class="s4">(</span><span class="s2">bodySegments</span><span class="s4">);</span>
    <span class="s4">}</span>

    <span class="s5">//--------------------------------------------------------------------------</span>
    <span class="s5">// Control Statements</span>
    <span class="s5">//--------------------------------------------------------------------------</span>

    <span class="s0">/**</span>
     <span class="s0">* Creates new context in which a `break` statement can be used. This occurs inside of a loop,</span>
     <span class="s0">* labeled statement, or switch statement.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{boolean} breakable Indicates if we are inside a statement where</span>
     <span class="s0">*      `break` without a label will exit the statement.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|null} label The label associated with the statement.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{BreakContext} The new context.</span>
     <span class="s0">*/</span>
    <span class="s2">pushBreakContext</span><span class="s4">(</span><span class="s2">breakable</span><span class="s4">, </span><span class="s2">label</span><span class="s4">) {</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">breakContext </span><span class="s4">= </span><span class="s6">new </span><span class="s2">BreakContext</span><span class="s4">(</span><span class="s6">this</span><span class="s4">.</span><span class="s2">breakContext</span><span class="s4">, </span><span class="s2">breakable</span><span class="s4">, </span><span class="s2">label</span><span class="s4">, </span><span class="s6">this</span><span class="s4">.</span><span class="s2">forkContext</span><span class="s4">);</span>
        <span class="s6">return this</span><span class="s4">.</span><span class="s2">breakContext</span><span class="s4">;</span>
    <span class="s4">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Removes the top item of the break context stack.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Object} The removed context.</span>
     <span class="s0">*/</span>
    <span class="s2">popBreakContext</span><span class="s4">() {</span>
        <span class="s6">const </span><span class="s2">context </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">breakContext</span><span class="s4">;</span>
        <span class="s6">const </span><span class="s2">forkContext </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">forkContext</span><span class="s4">;</span>

        <span class="s6">this</span><span class="s4">.</span><span class="s2">breakContext </span><span class="s4">= </span><span class="s2">context</span><span class="s4">.</span><span class="s2">upper</span><span class="s4">;</span>

        <span class="s5">// Process this context here for other than switches and loops.</span>
        <span class="s6">if </span><span class="s4">(!</span><span class="s2">context</span><span class="s4">.</span><span class="s2">breakable</span><span class="s4">) {</span>
            <span class="s6">const </span><span class="s2">brokenForkContext </span><span class="s4">= </span><span class="s2">context</span><span class="s4">.</span><span class="s2">brokenForkContext</span><span class="s4">;</span>

            <span class="s6">if </span><span class="s4">(!</span><span class="s2">brokenForkContext</span><span class="s4">.</span><span class="s2">empty</span><span class="s4">) {</span>
                <span class="s2">brokenForkContext</span><span class="s4">.</span><span class="s2">add</span><span class="s4">(</span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">head</span><span class="s4">);</span>
                <span class="s2">forkContext</span><span class="s4">.</span><span class="s2">replaceHead</span><span class="s4">(</span><span class="s2">brokenForkContext</span><span class="s4">.</span><span class="s2">makeNext</span><span class="s4">(</span><span class="s7">0</span><span class="s4">, -</span><span class="s7">1</span><span class="s4">));</span>
            <span class="s4">}</span>
        <span class="s4">}</span>

        <span class="s6">return </span><span class="s2">context</span><span class="s4">;</span>
    <span class="s4">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Makes a path for a `break` statement.</span>
     <span class="s0">*</span>
     <span class="s0">* It registers the head segment to a context of `break`.</span>
     <span class="s0">* It makes new unreachable segment, then it set the head with the segment.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|null} label A label of the break statement.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
     <span class="s0">*/</span>
    <span class="s2">makeBreak</span><span class="s4">(</span><span class="s2">label</span><span class="s4">) {</span>
        <span class="s6">const </span><span class="s2">forkContext </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">forkContext</span><span class="s4">;</span>

        <span class="s6">if </span><span class="s4">(!</span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">reachable</span><span class="s4">) {</span>
            <span class="s6">return</span><span class="s4">;</span>
        <span class="s4">}</span>

        <span class="s6">const </span><span class="s2">context </span><span class="s4">= </span><span class="s2">getBreakContext</span><span class="s4">(</span><span class="s6">this</span><span class="s4">, </span><span class="s2">label</span><span class="s4">);</span>


        <span class="s6">if </span><span class="s4">(</span><span class="s2">context</span><span class="s4">) {</span>
            <span class="s2">context</span><span class="s4">.</span><span class="s2">brokenForkContext</span><span class="s4">.</span><span class="s2">add</span><span class="s4">(</span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">head</span><span class="s4">);</span>
        <span class="s4">}</span>

        <span class="s5">/* c8 ignore next */</span>
        <span class="s2">forkContext</span><span class="s4">.</span><span class="s2">replaceHead</span><span class="s4">(</span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">makeUnreachable</span><span class="s4">(-</span><span class="s7">1</span><span class="s4">, -</span><span class="s7">1</span><span class="s4">));</span>
    <span class="s4">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Makes a path for a `continue` statement.</span>
     <span class="s0">*</span>
     <span class="s0">* It makes a looping path.</span>
     <span class="s0">* It makes new unreachable segment, then it set the head with the segment.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|null} label A label of the continue statement.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
     <span class="s0">*/</span>
    <span class="s2">makeContinue</span><span class="s4">(</span><span class="s2">label</span><span class="s4">) {</span>
        <span class="s6">const </span><span class="s2">forkContext </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">forkContext</span><span class="s4">;</span>

        <span class="s6">if </span><span class="s4">(!</span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">reachable</span><span class="s4">) {</span>
            <span class="s6">return</span><span class="s4">;</span>
        <span class="s4">}</span>

        <span class="s6">const </span><span class="s2">context </span><span class="s4">= </span><span class="s2">getContinueContext</span><span class="s4">(</span><span class="s6">this</span><span class="s4">, </span><span class="s2">label</span><span class="s4">);</span>

        <span class="s6">if </span><span class="s4">(</span><span class="s2">context</span><span class="s4">) {</span>
            <span class="s6">if </span><span class="s4">(</span><span class="s2">context</span><span class="s4">.</span><span class="s2">continueDestSegments</span><span class="s4">) {</span>
                <span class="s2">makeLooped</span><span class="s4">(</span><span class="s6">this</span><span class="s4">, </span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">head</span><span class="s4">, </span><span class="s2">context</span><span class="s4">.</span><span class="s2">continueDestSegments</span><span class="s4">);</span>

                <span class="s5">// If the context is a for-in/of loop, this affects a break also.</span>
                <span class="s6">if </span><span class="s4">(</span><span class="s2">context</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;ForInStatement&quot; </span><span class="s4">||</span>
                    <span class="s2">context</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;ForOfStatement&quot;</span>
                <span class="s4">) {</span>
                    <span class="s2">context</span><span class="s4">.</span><span class="s2">brokenForkContext</span><span class="s4">.</span><span class="s2">add</span><span class="s4">(</span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">head</span><span class="s4">);</span>
                <span class="s4">}</span>
            <span class="s4">} </span><span class="s6">else </span><span class="s4">{</span>
                <span class="s2">context</span><span class="s4">.</span><span class="s2">continueForkContext</span><span class="s4">.</span><span class="s2">add</span><span class="s4">(</span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">head</span><span class="s4">);</span>
            <span class="s4">}</span>
        <span class="s4">}</span>
        <span class="s2">forkContext</span><span class="s4">.</span><span class="s2">replaceHead</span><span class="s4">(</span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">makeUnreachable</span><span class="s4">(-</span><span class="s7">1</span><span class="s4">, -</span><span class="s7">1</span><span class="s4">));</span>
    <span class="s4">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Makes a path for a `return` statement.</span>
     <span class="s0">*</span>
     <span class="s0">* It registers the head segment to a context of `return`.</span>
     <span class="s0">* It makes new unreachable segment, then it set the head with the segment.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
     <span class="s0">*/</span>
    <span class="s2">makeReturn</span><span class="s4">() {</span>
        <span class="s6">const </span><span class="s2">forkContext </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">forkContext</span><span class="s4">;</span>

        <span class="s6">if </span><span class="s4">(</span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">reachable</span><span class="s4">) {</span>
            <span class="s2">getReturnContext</span><span class="s4">(</span><span class="s6">this</span><span class="s4">).</span><span class="s2">returnedForkContext</span><span class="s4">.</span><span class="s2">add</span><span class="s4">(</span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">head</span><span class="s4">);</span>
            <span class="s2">forkContext</span><span class="s4">.</span><span class="s2">replaceHead</span><span class="s4">(</span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">makeUnreachable</span><span class="s4">(-</span><span class="s7">1</span><span class="s4">, -</span><span class="s7">1</span><span class="s4">));</span>
        <span class="s4">}</span>
    <span class="s4">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Makes a path for a `throw` statement.</span>
     <span class="s0">*</span>
     <span class="s0">* It registers the head segment to a context of `throw`.</span>
     <span class="s0">* It makes new unreachable segment, then it set the head with the segment.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
     <span class="s0">*/</span>
    <span class="s2">makeThrow</span><span class="s4">() {</span>
        <span class="s6">const </span><span class="s2">forkContext </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">forkContext</span><span class="s4">;</span>

        <span class="s6">if </span><span class="s4">(</span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">reachable</span><span class="s4">) {</span>
            <span class="s2">getThrowContext</span><span class="s4">(</span><span class="s6">this</span><span class="s4">).</span><span class="s2">thrownForkContext</span><span class="s4">.</span><span class="s2">add</span><span class="s4">(</span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">head</span><span class="s4">);</span>
            <span class="s2">forkContext</span><span class="s4">.</span><span class="s2">replaceHead</span><span class="s4">(</span><span class="s2">forkContext</span><span class="s4">.</span><span class="s2">makeUnreachable</span><span class="s4">(-</span><span class="s7">1</span><span class="s4">, -</span><span class="s7">1</span><span class="s4">));</span>
        <span class="s4">}</span>
    <span class="s4">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Makes the final path.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
     <span class="s0">*/</span>
    <span class="s2">makeFinal</span><span class="s4">() {</span>
        <span class="s6">const </span><span class="s2">segments </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">currentSegments</span><span class="s4">;</span>

        <span class="s6">if </span><span class="s4">(</span><span class="s2">segments</span><span class="s4">.</span><span class="s2">length </span><span class="s4">&gt; </span><span class="s7">0 </span><span class="s4">&amp;&amp; </span><span class="s2">segments</span><span class="s4">[</span><span class="s7">0</span><span class="s4">].</span><span class="s2">reachable</span><span class="s4">) {</span>
            <span class="s6">this</span><span class="s4">.</span><span class="s2">returnedForkContext</span><span class="s4">.</span><span class="s2">add</span><span class="s4">(</span><span class="s2">segments</span><span class="s4">);</span>
        <span class="s4">}</span>
    <span class="s4">}</span>
<span class="s4">}</span>

<span class="s2">module</span><span class="s4">.</span><span class="s2">exports </span><span class="s4">= </span><span class="s2">CodePathState</span><span class="s4">;</span>
</pre>
</body>
</html>