<html>
<head>
<title>const-enum.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
const-enum.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_enum&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;EXPORTED_CONST_ENUMS_IN_NAMESPACE&quot;</span><span class="s0">,</span><span class="s1">&quot;exports&quot;</span><span class="s0">,</span><span class="s1">&quot;WeakSet&quot;</span><span class="s0">,</span><span class="s1">&quot;transpileConstEnum&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;t&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;id&quot;</span><span class="s0">,</span><span class="s1">&quot;parentIsExport&quot;</span><span class="s0">,</span><span class="s1">&quot;parentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;isExportNamedDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;isExported&quot;</span><span class="s0">,</span><span class="s1">&quot;isProgram&quot;</span><span class="s0">,</span><span class="s1">&quot;parent&quot;</span><span class="s0">,</span><span class="s1">&quot;body&quot;</span><span class="s0">,</span><span class="s1">&quot;some&quot;</span><span class="s0">,</span><span class="s1">&quot;stmt&quot;</span><span class="s0">,</span><span class="s1">&quot;exportKind&quot;</span><span class="s0">,</span><span class="s1">&quot;source&quot;</span><span class="s0">,</span><span class="s1">&quot;specifiers&quot;</span><span class="s0">,</span><span class="s1">&quot;spec&quot;</span><span class="s0">,</span><span class="s1">&quot;isExportSpecifier&quot;</span><span class="s0">,</span><span class="s1">&quot;local&quot;</span><span class="s0">,</span><span class="s1">&quot;enumValues&quot;</span><span class="s0">,</span><span class="s1">&quot;entries&quot;</span><span class="s0">,</span><span class="s1">&quot;translateEnumValues&quot;</span><span class="s0">,</span><span class="s1">&quot;has&quot;</span><span class="s0">,</span><span class="s1">&quot;obj&quot;</span><span class="s0">,</span><span class="s1">&quot;objectExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;objectProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;isValidIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;identifier&quot;</span><span class="s0">,</span><span class="s1">&quot;stringLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;scope&quot;</span><span class="s0">,</span><span class="s1">&quot;hasOwnBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceWith&quot;</span><span class="s0">,</span><span class="s1">&quot;expressionStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;callExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;memberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;variableDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;variableDeclarator&quot;</span><span class="s0">,</span><span class="s1">&quot;registerDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;entriesMap&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;traverse&quot;</span><span class="s0">,</span><span class="s1">&quot;Scope&quot;</span><span class="s0">,</span><span class="s1">&quot;skip&quot;</span><span class="s0">,</span><span class="s1">&quot;MemberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;object&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;computed&quot;</span><span class="s0">,</span><span class="s1">&quot;isStringLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;property&quot;</span><span class="s0">,</span><span class="s1">&quot;cloneNode&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;remove&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../src/const-enum.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { NodePath, types as t } from </span><span class="s3">\&quot;</span><span class="s1">@babel/core</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">import { translateEnumValues } from </span><span class="s3">\&quot;</span><span class="s1">./enum.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">export const EXPORTED_CONST_ENUMS_IN_NAMESPACE =</span><span class="s3">\n  </span><span class="s1">new WeakSet&lt;t.TSEnumDeclaration&gt;();</span><span class="s3">\n\n</span><span class="s1">export type NodePathConstEnum = NodePath&lt;t.TSEnumDeclaration &amp; { const: true }&gt;;</span><span class="s3">\n</span><span class="s1">export default function transpileConstEnum(</span><span class="s3">\n  </span><span class="s1">path: NodePathConstEnum,</span><span class="s3">\n  </span><span class="s1">t: typeof import(</span><span class="s3">\&quot;</span><span class="s1">@babel/types</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const { name } = path.node.id;</span><span class="s3">\n\n  </span><span class="s1">const parentIsExport = path.parentPath.isExportNamedDeclaration();</span><span class="s3">\n  </span><span class="s1">let isExported = parentIsExport;</span><span class="s3">\n  </span><span class="s1">if (!isExported &amp;&amp; t.isProgram(path.parent)) {</span><span class="s3">\n    </span><span class="s1">isExported = path.parent.body.some(</span><span class="s3">\n      </span><span class="s1">stmt =&gt;</span><span class="s3">\n        </span><span class="s1">t.isExportNamedDeclaration(stmt) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">stmt.exportKind !== </span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n        </span><span class="s1">!stmt.source &amp;&amp;</span><span class="s3">\n        </span><span class="s1">stmt.specifiers.some(</span><span class="s3">\n          </span><span class="s1">spec =&gt;</span><span class="s3">\n            </span><span class="s1">t.isExportSpecifier(spec) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">spec.exportKind !== </span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n            </span><span class="s1">spec.local.name === name,</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const { enumValues: entries } = translateEnumValues(path, t);</span><span class="s3">\n\n  </span><span class="s1">if (isExported || EXPORTED_CONST_ENUMS_IN_NAMESPACE.has(path.node)) {</span><span class="s3">\n    </span><span class="s1">const obj = t.objectExpression(</span><span class="s3">\n      </span><span class="s1">entries.map(([name, value]) =&gt;</span><span class="s3">\n        </span><span class="s1">t.objectProperty(</span><span class="s3">\n          </span><span class="s1">t.isValidIdentifier(name)</span><span class="s3">\n            </span><span class="s1">? t.identifier(name)</span><span class="s3">\n            </span><span class="s1">: t.stringLiteral(name),</span><span class="s3">\n          </span><span class="s1">value,</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n\n    </span><span class="s1">if (path.scope.hasOwnBinding(name)) {</span><span class="s3">\n      </span><span class="s1">(parentIsExport ? path.parentPath : path).replaceWith(</span><span class="s3">\n        </span><span class="s1">t.expressionStatement(</span><span class="s3">\n          </span><span class="s1">t.callExpression(</span><span class="s3">\n            </span><span class="s1">t.memberExpression(t.identifier(</span><span class="s3">\&quot;</span><span class="s1">Object</span><span class="s3">\&quot;</span><span class="s1">), t.identifier(</span><span class="s3">\&quot;</span><span class="s1">assign</span><span class="s3">\&quot;</span><span class="s1">)),</span><span class="s3">\n            </span><span class="s1">[path.node.id, obj],</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">path.replaceWith(</span><span class="s3">\n        </span><span class="s1">t.variableDeclaration(process.env.BABEL_8_BREAKING ? </span><span class="s3">\&quot;</span><span class="s1">const</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">var</span><span class="s3">\&quot;</span><span class="s1">, [</span><span class="s3">\n          </span><span class="s1">t.variableDeclarator(path.node.id, obj),</span><span class="s3">\n        </span><span class="s1">]),</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">path.scope.registerDeclaration(path);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const entriesMap = new Map(entries);</span><span class="s3">\n\n  </span><span class="s1">// TODO: After fixing https://github.com/babel/babel/pull/11065, we can</span><span class="s3">\n  </span><span class="s1">// use path.scope.getBinding(name).referencePaths rather than doing</span><span class="s3">\n  </span><span class="s1">// a full traversal.</span><span class="s3">\n  </span><span class="s1">path.scope.path.traverse({</span><span class="s3">\n    </span><span class="s1">Scope(path) {</span><span class="s3">\n      </span><span class="s1">if (path.scope.hasOwnBinding(name)) path.skip();</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">MemberExpression(path) {</span><span class="s3">\n      </span><span class="s1">if (!t.isIdentifier(path.node.object, { name })) return;</span><span class="s3">\n\n      </span><span class="s1">let key: string;</span><span class="s3">\n      </span><span class="s1">if (path.node.computed) {</span><span class="s3">\n        </span><span class="s1">if (t.isStringLiteral(path.node.property)) {</span><span class="s3">\n          </span><span class="s1">key = path.node.property.value;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else if (t.isIdentifier(path.node.property)) {</span><span class="s3">\n        </span><span class="s1">key = path.node.property.name;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (!entriesMap.has(key)) return;</span><span class="s3">\n\n      </span><span class="s1">path.replaceWith(t.cloneNode(entriesMap.get(key)));</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">path.remove();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[]}</span></pre>
</body>
</html>