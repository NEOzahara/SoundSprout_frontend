<html>
<head>
<title>control-flow.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #6aab73;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #cf8e6d;}
.s4 { color: #2aacb8;}
.s5 { color: #7a7e85;}
.s6 { color: #5f826b; font-style: italic;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
control-flow.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s2">Object</span><span class="s1">.</span><span class="s2">defineProperty</span><span class="s1">(</span><span class="s2">exports</span><span class="s1">, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, { </span><span class="s2">value</span><span class="s1">: </span><span class="s3">true </span><span class="s1">});</span>
<span class="s2">exports</span><span class="s1">.</span><span class="s2">callExpressionAffectsControlFlow </span><span class="s1">= </span><span class="s2">exports</span><span class="s1">.</span><span class="s2">SignatureEffect </span><span class="s1">= </span><span class="s2">exports</span><span class="s1">.</span><span class="s2">getControlFlowEnd </span><span class="s1">= </span><span class="s2">exports</span><span class="s1">.</span><span class="s2">endsControlFlow </span><span class="s1">= </span><span class="s3">void </span><span class="s4">0</span><span class="s1">;</span>
<span class="s3">const </span><span class="s2">ts </span><span class="s1">= </span><span class="s2">require</span><span class="s1">(</span><span class="s0">&quot;typescript&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s2">node_1 </span><span class="s1">= </span><span class="s2">require</span><span class="s1">(</span><span class="s0">&quot;../typeguard/node&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s2">util_1 </span><span class="s1">= </span><span class="s2">require</span><span class="s1">(</span><span class="s0">&quot;./util&quot;</span><span class="s1">);</span>
<span class="s3">function </span><span class="s2">endsControlFlow</span><span class="s1">(</span><span class="s2">statement</span><span class="s1">, </span><span class="s2">checker</span><span class="s1">) {</span>
    <span class="s3">return </span><span class="s2">getControlFlowEnd</span><span class="s1">(</span><span class="s2">statement</span><span class="s1">, </span><span class="s2">checker</span><span class="s1">).</span><span class="s2">end</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">exports</span><span class="s1">.</span><span class="s2">endsControlFlow </span><span class="s1">= </span><span class="s2">endsControlFlow</span><span class="s1">;</span>
<span class="s3">const </span><span class="s2">defaultControlFlowEnd </span><span class="s1">= { </span><span class="s2">statements</span><span class="s1">: [], </span><span class="s2">end</span><span class="s1">: </span><span class="s3">false </span><span class="s1">};</span>
<span class="s3">function </span><span class="s2">getControlFlowEnd</span><span class="s1">(</span><span class="s2">statement</span><span class="s1">, </span><span class="s2">checker</span><span class="s1">) {</span>
    <span class="s3">return </span><span class="s2">node_1</span><span class="s1">.</span><span class="s2">isBlockLike</span><span class="s1">(</span><span class="s2">statement</span><span class="s1">) ? </span><span class="s2">handleBlock</span><span class="s1">(</span><span class="s2">statement</span><span class="s1">, </span><span class="s2">checker</span><span class="s1">) : </span><span class="s2">getControlFlowEndWorker</span><span class="s1">(</span><span class="s2">statement</span><span class="s1">, </span><span class="s2">checker</span><span class="s1">);</span>
<span class="s1">}</span>
<span class="s2">exports</span><span class="s1">.</span><span class="s2">getControlFlowEnd </span><span class="s1">= </span><span class="s2">getControlFlowEnd</span><span class="s1">;</span>
<span class="s3">function </span><span class="s2">getControlFlowEndWorker</span><span class="s1">(</span><span class="s2">statement</span><span class="s1">, </span><span class="s2">checker</span><span class="s1">) {</span>
    <span class="s3">switch </span><span class="s1">(</span><span class="s2">statement</span><span class="s1">.</span><span class="s2">kind</span><span class="s1">) {</span>
        <span class="s3">case </span><span class="s2">ts</span><span class="s1">.</span><span class="s2">SyntaxKind</span><span class="s1">.</span><span class="s2">ReturnStatement</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">ts</span><span class="s1">.</span><span class="s2">SyntaxKind</span><span class="s1">.</span><span class="s2">ThrowStatement</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">ts</span><span class="s1">.</span><span class="s2">SyntaxKind</span><span class="s1">.</span><span class="s2">ContinueStatement</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">ts</span><span class="s1">.</span><span class="s2">SyntaxKind</span><span class="s1">.</span><span class="s2">BreakStatement</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">{ </span><span class="s2">statements</span><span class="s1">: [</span><span class="s2">statement</span><span class="s1">], </span><span class="s2">end</span><span class="s1">: </span><span class="s3">true </span><span class="s1">};</span>
        <span class="s3">case </span><span class="s2">ts</span><span class="s1">.</span><span class="s2">SyntaxKind</span><span class="s1">.</span><span class="s2">Block</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s2">handleBlock</span><span class="s1">(</span><span class="s2">statement</span><span class="s1">, </span><span class="s2">checker</span><span class="s1">);</span>
        <span class="s3">case </span><span class="s2">ts</span><span class="s1">.</span><span class="s2">SyntaxKind</span><span class="s1">.</span><span class="s2">ForStatement</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">ts</span><span class="s1">.</span><span class="s2">SyntaxKind</span><span class="s1">.</span><span class="s2">WhileStatement</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s2">handleForAndWhileStatement</span><span class="s1">(</span><span class="s2">statement</span><span class="s1">, </span><span class="s2">checker</span><span class="s1">);</span>
        <span class="s3">case </span><span class="s2">ts</span><span class="s1">.</span><span class="s2">SyntaxKind</span><span class="s1">.</span><span class="s2">ForOfStatement</span><span class="s1">:</span>
        <span class="s3">case </span><span class="s2">ts</span><span class="s1">.</span><span class="s2">SyntaxKind</span><span class="s1">.</span><span class="s2">ForInStatement</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s2">handleForInOrOfStatement</span><span class="s1">(</span><span class="s2">statement</span><span class="s1">, </span><span class="s2">checker</span><span class="s1">);</span>
        <span class="s3">case </span><span class="s2">ts</span><span class="s1">.</span><span class="s2">SyntaxKind</span><span class="s1">.</span><span class="s2">DoStatement</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s2">matchBreakOrContinue</span><span class="s1">(</span><span class="s2">getControlFlowEndWorker</span><span class="s1">(</span><span class="s2">statement</span><span class="s1">.</span><span class="s2">statement</span><span class="s1">, </span><span class="s2">checker</span><span class="s1">), </span><span class="s2">node_1</span><span class="s1">.</span><span class="s2">isBreakOrContinueStatement</span><span class="s1">);</span>
        <span class="s3">case </span><span class="s2">ts</span><span class="s1">.</span><span class="s2">SyntaxKind</span><span class="s1">.</span><span class="s2">IfStatement</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s2">handleIfStatement</span><span class="s1">(</span><span class="s2">statement</span><span class="s1">, </span><span class="s2">checker</span><span class="s1">);</span>
        <span class="s3">case </span><span class="s2">ts</span><span class="s1">.</span><span class="s2">SyntaxKind</span><span class="s1">.</span><span class="s2">SwitchStatement</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s2">matchBreakOrContinue</span><span class="s1">(</span><span class="s2">handleSwitchStatement</span><span class="s1">(</span><span class="s2">statement</span><span class="s1">, </span><span class="s2">checker</span><span class="s1">), </span><span class="s2">node_1</span><span class="s1">.</span><span class="s2">isBreakStatement</span><span class="s1">);</span>
        <span class="s3">case </span><span class="s2">ts</span><span class="s1">.</span><span class="s2">SyntaxKind</span><span class="s1">.</span><span class="s2">TryStatement</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s2">handleTryStatement</span><span class="s1">(</span><span class="s2">statement</span><span class="s1">, </span><span class="s2">checker</span><span class="s1">);</span>
        <span class="s3">case </span><span class="s2">ts</span><span class="s1">.</span><span class="s2">SyntaxKind</span><span class="s1">.</span><span class="s2">LabeledStatement</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s2">matchLabel</span><span class="s1">(</span><span class="s2">getControlFlowEndWorker</span><span class="s1">(</span><span class="s2">statement</span><span class="s1">.</span><span class="s2">statement</span><span class="s1">, </span><span class="s2">checker</span><span class="s1">), </span><span class="s2">statement</span><span class="s1">.</span><span class="s2">label</span><span class="s1">);</span>
        <span class="s3">case </span><span class="s2">ts</span><span class="s1">.</span><span class="s2">SyntaxKind</span><span class="s1">.</span><span class="s2">WithStatement</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s2">getControlFlowEndWorker</span><span class="s1">(</span><span class="s2">statement</span><span class="s1">.</span><span class="s2">statement</span><span class="s1">, </span><span class="s2">checker</span><span class="s1">);</span>
        <span class="s3">case </span><span class="s2">ts</span><span class="s1">.</span><span class="s2">SyntaxKind</span><span class="s1">.</span><span class="s2">ExpressionStatement</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s2">checker </span><span class="s1">=== </span><span class="s2">undefined</span><span class="s1">)</span>
                <span class="s3">return </span><span class="s2">defaultControlFlowEnd</span><span class="s1">;</span>
            <span class="s3">return </span><span class="s2">handleExpressionStatement</span><span class="s1">(</span><span class="s2">statement</span><span class="s1">, </span><span class="s2">checker</span><span class="s1">);</span>
        <span class="s3">default</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s2">defaultControlFlowEnd</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s2">handleBlock</span><span class="s1">(</span><span class="s2">statement</span><span class="s1">, </span><span class="s2">checker</span><span class="s1">) {</span>
    <span class="s3">const </span><span class="s2">result </span><span class="s1">= { </span><span class="s2">statements</span><span class="s1">: [], </span><span class="s2">end</span><span class="s1">: </span><span class="s3">false </span><span class="s1">};</span>
    <span class="s3">for </span><span class="s1">(</span><span class="s3">const </span><span class="s2">s of statement</span><span class="s1">.</span><span class="s2">statements</span><span class="s1">) {</span>
        <span class="s3">const </span><span class="s2">current </span><span class="s1">= </span><span class="s2">getControlFlowEndWorker</span><span class="s1">(</span><span class="s2">s</span><span class="s1">, </span><span class="s2">checker</span><span class="s1">);</span>
        <span class="s2">result</span><span class="s1">.</span><span class="s2">statements</span><span class="s1">.</span><span class="s2">push</span><span class="s1">(</span><span class="s2">...current</span><span class="s1">.</span><span class="s2">statements</span><span class="s1">);</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s2">current</span><span class="s1">.</span><span class="s2">end</span><span class="s1">) {</span>
            <span class="s2">result</span><span class="s1">.</span><span class="s2">end </span><span class="s1">= </span><span class="s3">true</span><span class="s1">;</span>
            <span class="s3">break</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">return </span><span class="s2">result</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s2">handleForInOrOfStatement</span><span class="s1">(</span><span class="s2">statement</span><span class="s1">, </span><span class="s2">checker</span><span class="s1">) {</span>
    <span class="s3">const </span><span class="s2">end </span><span class="s1">= </span><span class="s2">matchBreakOrContinue</span><span class="s1">(</span><span class="s2">getControlFlowEndWorker</span><span class="s1">(</span><span class="s2">statement</span><span class="s1">.</span><span class="s2">statement</span><span class="s1">, </span><span class="s2">checker</span><span class="s1">), </span><span class="s2">node_1</span><span class="s1">.</span><span class="s2">isBreakOrContinueStatement</span><span class="s1">);</span>
    <span class="s2">end</span><span class="s1">.</span><span class="s2">end </span><span class="s1">= </span><span class="s3">false</span><span class="s1">; </span><span class="s5">// loop body is guaranteed to be executed</span>
    <span class="s3">return </span><span class="s2">end</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s2">handleForAndWhileStatement</span><span class="s1">(</span><span class="s2">statement</span><span class="s1">, </span><span class="s2">checker</span><span class="s1">) {</span>
    <span class="s3">const </span><span class="s2">constantCondition </span><span class="s1">= </span><span class="s2">statement</span><span class="s1">.</span><span class="s2">kind </span><span class="s1">=== </span><span class="s2">ts</span><span class="s1">.</span><span class="s2">SyntaxKind</span><span class="s1">.</span><span class="s2">WhileStatement</span>
        <span class="s1">? </span><span class="s2">getConstantCondition</span><span class="s1">(</span><span class="s2">statement</span><span class="s1">.</span><span class="s2">expression</span><span class="s1">)</span>
        <span class="s1">: </span><span class="s2">statement</span><span class="s1">.</span><span class="s2">condition </span><span class="s1">=== </span><span class="s2">undefined </span><span class="s1">|| </span><span class="s2">getConstantCondition</span><span class="s1">(</span><span class="s2">statement</span><span class="s1">.</span><span class="s2">condition</span><span class="s1">);</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s2">constantCondition </span><span class="s1">=== </span><span class="s3">false</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s2">defaultControlFlowEnd</span><span class="s1">; </span><span class="s5">// loop body is never executed</span>
    <span class="s3">const </span><span class="s2">end </span><span class="s1">= </span><span class="s2">matchBreakOrContinue</span><span class="s1">(</span><span class="s2">getControlFlowEndWorker</span><span class="s1">(</span><span class="s2">statement</span><span class="s1">.</span><span class="s2">statement</span><span class="s1">, </span><span class="s2">checker</span><span class="s1">), </span><span class="s2">node_1</span><span class="s1">.</span><span class="s2">isBreakOrContinueStatement</span><span class="s1">);</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s2">constantCondition </span><span class="s1">=== </span><span class="s2">undefined</span><span class="s1">)</span>
        <span class="s2">end</span><span class="s1">.</span><span class="s2">end </span><span class="s1">= </span><span class="s3">false</span><span class="s1">; </span><span class="s5">// can't be sure that loop body is executed at all</span>
    <span class="s3">return </span><span class="s2">end</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s6">/** Simply detects `true` and `false` in conditions. That matches TypeScript's behavior. */</span>
<span class="s3">function </span><span class="s2">getConstantCondition</span><span class="s1">(</span><span class="s2">node</span><span class="s1">) {</span>
    <span class="s3">switch </span><span class="s1">(</span><span class="s2">node</span><span class="s1">.</span><span class="s2">kind</span><span class="s1">) {</span>
        <span class="s3">case </span><span class="s2">ts</span><span class="s1">.</span><span class="s2">SyntaxKind</span><span class="s1">.</span><span class="s2">TrueKeyword</span><span class="s1">:</span>
            <span class="s3">return true</span><span class="s1">;</span>
        <span class="s3">case </span><span class="s2">ts</span><span class="s1">.</span><span class="s2">SyntaxKind</span><span class="s1">.</span><span class="s2">FalseKeyword</span><span class="s1">:</span>
            <span class="s3">return false</span><span class="s1">;</span>
        <span class="s3">default</span><span class="s1">:</span>
            <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s2">handleIfStatement</span><span class="s1">(</span><span class="s2">node</span><span class="s1">, </span><span class="s2">checker</span><span class="s1">) {</span>
    <span class="s3">switch </span><span class="s1">(</span><span class="s2">getConstantCondition</span><span class="s1">(</span><span class="s2">node</span><span class="s1">.</span><span class="s2">expression</span><span class="s1">)) {</span>
        <span class="s3">case true</span><span class="s1">:</span>
            <span class="s5">// else branch is never executed</span>
            <span class="s3">return </span><span class="s2">getControlFlowEndWorker</span><span class="s1">(</span><span class="s2">node</span><span class="s1">.</span><span class="s2">thenStatement</span><span class="s1">, </span><span class="s2">checker</span><span class="s1">);</span>
        <span class="s3">case false</span><span class="s1">:</span>
            <span class="s5">// then branch is never executed</span>
            <span class="s3">return </span><span class="s2">node</span><span class="s1">.</span><span class="s2">elseStatement </span><span class="s1">=== </span><span class="s2">undefined</span>
                <span class="s1">? </span><span class="s2">defaultControlFlowEnd</span>
                <span class="s1">: </span><span class="s2">getControlFlowEndWorker</span><span class="s1">(</span><span class="s2">node</span><span class="s1">.</span><span class="s2">elseStatement</span><span class="s1">, </span><span class="s2">checker</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s3">const </span><span class="s2">then </span><span class="s1">= </span><span class="s2">getControlFlowEndWorker</span><span class="s1">(</span><span class="s2">node</span><span class="s1">.</span><span class="s2">thenStatement</span><span class="s1">, </span><span class="s2">checker</span><span class="s1">);</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s2">node</span><span class="s1">.</span><span class="s2">elseStatement </span><span class="s1">=== </span><span class="s2">undefined</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">{</span>
            <span class="s2">statements</span><span class="s1">: </span><span class="s2">then</span><span class="s1">.</span><span class="s2">statements</span><span class="s1">,</span>
            <span class="s2">end</span><span class="s1">: </span><span class="s3">false</span><span class="s1">,</span>
        <span class="s1">};</span>
    <span class="s3">const </span><span class="s2">elze </span><span class="s1">= </span><span class="s2">getControlFlowEndWorker</span><span class="s1">(</span><span class="s2">node</span><span class="s1">.</span><span class="s2">elseStatement</span><span class="s1">, </span><span class="s2">checker</span><span class="s1">);</span>
    <span class="s3">return </span><span class="s1">{</span>
        <span class="s2">statements</span><span class="s1">: [</span><span class="s2">...then</span><span class="s1">.</span><span class="s2">statements</span><span class="s1">, </span><span class="s2">...elze</span><span class="s1">.</span><span class="s2">statements</span><span class="s1">],</span>
        <span class="s2">end</span><span class="s1">: </span><span class="s2">then</span><span class="s1">.</span><span class="s2">end </span><span class="s1">&amp;&amp; </span><span class="s2">elze</span><span class="s1">.</span><span class="s2">end</span><span class="s1">,</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s2">handleSwitchStatement</span><span class="s1">(</span><span class="s2">node</span><span class="s1">, </span><span class="s2">checker</span><span class="s1">) {</span>
    <span class="s3">let </span><span class="s2">hasDefault </span><span class="s1">= </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s3">const </span><span class="s2">result </span><span class="s1">= {</span>
        <span class="s2">statements</span><span class="s1">: [],</span>
        <span class="s2">end</span><span class="s1">: </span><span class="s3">false</span><span class="s1">,</span>
    <span class="s1">};</span>
    <span class="s3">for </span><span class="s1">(</span><span class="s3">const </span><span class="s2">clause of node</span><span class="s1">.</span><span class="s2">caseBlock</span><span class="s1">.</span><span class="s2">clauses</span><span class="s1">) {</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s2">clause</span><span class="s1">.</span><span class="s2">kind </span><span class="s1">=== </span><span class="s2">ts</span><span class="s1">.</span><span class="s2">SyntaxKind</span><span class="s1">.</span><span class="s2">DefaultClause</span><span class="s1">)</span>
            <span class="s2">hasDefault </span><span class="s1">= </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s3">const </span><span class="s2">current </span><span class="s1">= </span><span class="s2">handleBlock</span><span class="s1">(</span><span class="s2">clause</span><span class="s1">, </span><span class="s2">checker</span><span class="s1">);</span>
        <span class="s2">result</span><span class="s1">.</span><span class="s2">end </span><span class="s1">= </span><span class="s2">current</span><span class="s1">.</span><span class="s2">end</span><span class="s1">;</span>
        <span class="s2">result</span><span class="s1">.</span><span class="s2">statements</span><span class="s1">.</span><span class="s2">push</span><span class="s1">(</span><span class="s2">...current</span><span class="s1">.</span><span class="s2">statements</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">result</span><span class="s1">.</span><span class="s2">end </span><span class="s1">&amp;&amp; (</span><span class="s2">result</span><span class="s1">.</span><span class="s2">end </span><span class="s1">= </span><span class="s2">hasDefault </span><span class="s1">|| </span><span class="s2">checker </span><span class="s1">!== </span><span class="s2">undefined </span><span class="s1">&amp;&amp; </span><span class="s2">util_1</span><span class="s1">.</span><span class="s2">hasExhaustiveCaseClauses</span><span class="s1">(</span><span class="s2">node</span><span class="s1">, </span><span class="s2">checker</span><span class="s1">));</span>
    <span class="s3">return </span><span class="s2">result</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s2">handleTryStatement</span><span class="s1">(</span><span class="s2">node</span><span class="s1">, </span><span class="s2">checker</span><span class="s1">) {</span>
    <span class="s3">let </span><span class="s2">finallyResult</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s2">node</span><span class="s1">.</span><span class="s2">finallyBlock </span><span class="s1">!== </span><span class="s2">undefined</span><span class="s1">) {</span>
        <span class="s2">finallyResult </span><span class="s1">= </span><span class="s2">handleBlock</span><span class="s1">(</span><span class="s2">node</span><span class="s1">.</span><span class="s2">finallyBlock</span><span class="s1">, </span><span class="s2">checker</span><span class="s1">);</span>
        <span class="s5">// if 'finally' always ends control flow, we are not interested in any jump statements from 'try' or 'catch'</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s2">finallyResult</span><span class="s1">.</span><span class="s2">end</span><span class="s1">)</span>
            <span class="s3">return </span><span class="s2">finallyResult</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">const </span><span class="s2">tryResult </span><span class="s1">= </span><span class="s2">handleBlock</span><span class="s1">(</span><span class="s2">node</span><span class="s1">.</span><span class="s2">tryBlock</span><span class="s1">, </span><span class="s2">checker</span><span class="s1">);</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s2">node</span><span class="s1">.</span><span class="s2">catchClause </span><span class="s1">=== </span><span class="s2">undefined</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">{ </span><span class="s2">statements</span><span class="s1">: </span><span class="s2">finallyResult</span><span class="s1">.</span><span class="s2">statements</span><span class="s1">.</span><span class="s2">concat</span><span class="s1">(</span><span class="s2">tryResult</span><span class="s1">.</span><span class="s2">statements</span><span class="s1">), </span><span class="s2">end</span><span class="s1">: </span><span class="s2">tryResult</span><span class="s1">.</span><span class="s2">end </span><span class="s1">};</span>
    <span class="s3">const </span><span class="s2">catchResult </span><span class="s1">= </span><span class="s2">handleBlock</span><span class="s1">(</span><span class="s2">node</span><span class="s1">.</span><span class="s2">catchClause</span><span class="s1">.</span><span class="s2">block</span><span class="s1">, </span><span class="s2">checker</span><span class="s1">);</span>
    <span class="s3">return </span><span class="s1">{</span>
        <span class="s2">statements</span><span class="s1">: </span><span class="s2">tryResult</span><span class="s1">.</span><span class="s2">statements</span>
            <span class="s5">// remove all throw statements and throwing function calls from the list of control flow statements inside tryBlock</span>
            <span class="s1">.</span><span class="s2">filter</span><span class="s1">((</span><span class="s2">s</span><span class="s1">) =&gt; </span><span class="s2">s</span><span class="s1">.</span><span class="s2">kind </span><span class="s1">!== </span><span class="s2">ts</span><span class="s1">.</span><span class="s2">SyntaxKind</span><span class="s1">.</span><span class="s2">ThrowStatement </span><span class="s1">&amp;&amp; </span><span class="s2">s</span><span class="s1">.</span><span class="s2">kind </span><span class="s1">!== </span><span class="s2">ts</span><span class="s1">.</span><span class="s2">SyntaxKind</span><span class="s1">.</span><span class="s2">ExpressionStatement</span><span class="s1">)</span>
            <span class="s1">.</span><span class="s2">concat</span><span class="s1">(</span><span class="s2">catchResult</span><span class="s1">.</span><span class="s2">statements</span><span class="s1">, </span><span class="s2">finallyResult </span><span class="s1">=== </span><span class="s2">undefined </span><span class="s1">? [] : </span><span class="s2">finallyResult</span><span class="s1">.</span><span class="s2">statements</span><span class="s1">),</span>
        <span class="s2">end</span><span class="s1">: </span><span class="s2">tryResult</span><span class="s1">.</span><span class="s2">end </span><span class="s1">&amp;&amp; </span><span class="s2">catchResult</span><span class="s1">.</span><span class="s2">end</span><span class="s1">, </span><span class="s5">// only ends control flow if try AND catch definitely end control flow</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s6">/** Dotted name as TypeScript requires it for assertion signatures to affect control flow. */</span>
<span class="s3">function </span><span class="s2">isDottedNameWithExplicitTypeAnnotation</span><span class="s1">(</span><span class="s2">node</span><span class="s1">, </span><span class="s2">checker</span><span class="s1">) {</span>
    <span class="s3">while </span><span class="s1">(</span><span class="s3">true</span><span class="s1">) {</span>
        <span class="s3">switch </span><span class="s1">(</span><span class="s2">node</span><span class="s1">.</span><span class="s2">kind</span><span class="s1">) {</span>
            <span class="s3">case </span><span class="s2">ts</span><span class="s1">.</span><span class="s2">SyntaxKind</span><span class="s1">.</span><span class="s2">Identifier</span><span class="s1">: {</span>
                <span class="s3">const </span><span class="s2">symbol </span><span class="s1">= </span><span class="s2">checker</span><span class="s1">.</span><span class="s2">getExportSymbolOfSymbol</span><span class="s1">(</span><span class="s2">checker</span><span class="s1">.</span><span class="s2">getSymbolAtLocation</span><span class="s1">(</span><span class="s2">node</span><span class="s1">));</span>
                <span class="s3">return </span><span class="s2">isExplicitlyTypedSymbol</span><span class="s1">(</span><span class="s2">util_1</span><span class="s1">.</span><span class="s2">isSymbolFlagSet</span><span class="s1">(</span><span class="s2">symbol</span><span class="s1">, </span><span class="s2">ts</span><span class="s1">.</span><span class="s2">SymbolFlags</span><span class="s1">.</span><span class="s2">Alias</span><span class="s1">) ? </span><span class="s2">checker</span><span class="s1">.</span><span class="s2">getAliasedSymbol</span><span class="s1">(</span><span class="s2">symbol</span><span class="s1">) : </span><span class="s2">symbol</span><span class="s1">, </span><span class="s2">checker</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s3">case </span><span class="s2">ts</span><span class="s1">.</span><span class="s2">SyntaxKind</span><span class="s1">.</span><span class="s2">ThisKeyword</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s2">isExplicitlyTypedThis</span><span class="s1">(</span><span class="s2">node</span><span class="s1">);</span>
            <span class="s3">case </span><span class="s2">ts</span><span class="s1">.</span><span class="s2">SyntaxKind</span><span class="s1">.</span><span class="s2">SuperKeyword</span><span class="s1">:</span>
                <span class="s3">return true</span><span class="s1">;</span>
            <span class="s3">case </span><span class="s2">ts</span><span class="s1">.</span><span class="s2">SyntaxKind</span><span class="s1">.</span><span class="s2">PropertyAccessExpression</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">(!</span><span class="s2">isExplicitlyTypedSymbol</span><span class="s1">(</span><span class="s2">checker</span><span class="s1">.</span><span class="s2">getSymbolAtLocation</span><span class="s1">(</span><span class="s2">node</span><span class="s1">), </span><span class="s2">checker</span><span class="s1">))</span>
                    <span class="s3">return false</span><span class="s1">;</span>
            <span class="s5">// falls through</span>
            <span class="s3">case </span><span class="s2">ts</span><span class="s1">.</span><span class="s2">SyntaxKind</span><span class="s1">.</span><span class="s2">ParenthesizedExpression</span><span class="s1">:</span>
                <span class="s2">node </span><span class="s1">= </span><span class="s2">node</span><span class="s1">.</span><span class="s2">expression</span><span class="s1">;</span>
                <span class="s3">continue</span><span class="s1">;</span>
            <span class="s3">default</span><span class="s1">:</span>
                <span class="s3">return false</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s2">isExplicitlyTypedSymbol</span><span class="s1">(</span><span class="s2">symbol</span><span class="s1">, </span><span class="s2">checker</span><span class="s1">) {</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s2">symbol </span><span class="s1">=== </span><span class="s2">undefined</span><span class="s1">)</span>
        <span class="s3">return false</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s2">util_1</span><span class="s1">.</span><span class="s2">isSymbolFlagSet</span><span class="s1">(</span><span class="s2">symbol</span><span class="s1">, </span><span class="s2">ts</span><span class="s1">.</span><span class="s2">SymbolFlags</span><span class="s1">.</span><span class="s2">Function </span><span class="s1">| </span><span class="s2">ts</span><span class="s1">.</span><span class="s2">SymbolFlags</span><span class="s1">.</span><span class="s2">Method </span><span class="s1">| </span><span class="s2">ts</span><span class="s1">.</span><span class="s2">SymbolFlags</span><span class="s1">.</span><span class="s2">Class </span><span class="s1">| </span><span class="s2">ts</span><span class="s1">.</span><span class="s2">SymbolFlags</span><span class="s1">.</span><span class="s2">ValueModule</span><span class="s1">))</span>
        <span class="s3">return true</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s1">(!</span><span class="s2">util_1</span><span class="s1">.</span><span class="s2">isSymbolFlagSet</span><span class="s1">(</span><span class="s2">symbol</span><span class="s1">, </span><span class="s2">ts</span><span class="s1">.</span><span class="s2">SymbolFlags</span><span class="s1">.</span><span class="s2">Variable </span><span class="s1">| </span><span class="s2">ts</span><span class="s1">.</span><span class="s2">SymbolFlags</span><span class="s1">.</span><span class="s2">Property</span><span class="s1">))</span>
        <span class="s3">return false</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s2">symbol</span><span class="s1">.</span><span class="s2">valueDeclaration </span><span class="s1">=== </span><span class="s2">undefined</span><span class="s1">)</span>
        <span class="s3">return false</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s2">declarationHasExplicitTypeAnnotation</span><span class="s1">(</span><span class="s2">symbol</span><span class="s1">.</span><span class="s2">valueDeclaration</span><span class="s1">))</span>
        <span class="s3">return true</span><span class="s1">;</span>
    <span class="s3">return </span><span class="s2">node_1</span><span class="s1">.</span><span class="s2">isVariableDeclaration</span><span class="s1">(</span><span class="s2">symbol</span><span class="s1">.</span><span class="s2">valueDeclaration</span><span class="s1">) &amp;&amp;</span>
        <span class="s2">symbol</span><span class="s1">.</span><span class="s2">valueDeclaration</span><span class="s1">.</span><span class="s2">parent</span><span class="s1">.</span><span class="s2">parent</span><span class="s1">.</span><span class="s2">kind </span><span class="s1">=== </span><span class="s2">ts</span><span class="s1">.</span><span class="s2">SyntaxKind</span><span class="s1">.</span><span class="s2">ForOfStatement </span><span class="s1">&amp;&amp;</span>
        <span class="s2">isDottedNameWithExplicitTypeAnnotation</span><span class="s1">(</span><span class="s2">symbol</span><span class="s1">.</span><span class="s2">valueDeclaration</span><span class="s1">.</span><span class="s2">parent</span><span class="s1">.</span><span class="s2">parent</span><span class="s1">.</span><span class="s2">expression</span><span class="s1">, </span><span class="s2">checker</span><span class="s1">);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s2">declarationHasExplicitTypeAnnotation</span><span class="s1">(</span><span class="s2">node</span><span class="s1">) {</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s2">ts</span><span class="s1">.</span><span class="s2">isJSDocPropertyLikeTag</span><span class="s1">(</span><span class="s2">node</span><span class="s1">))</span>
        <span class="s3">return </span><span class="s2">node</span><span class="s1">.</span><span class="s2">typeExpression </span><span class="s1">!== </span><span class="s2">undefined</span><span class="s1">;</span>
    <span class="s3">return </span><span class="s1">(</span><span class="s2">node_1</span><span class="s1">.</span><span class="s2">isVariableDeclaration</span><span class="s1">(</span><span class="s2">node</span><span class="s1">) ||</span>
        <span class="s2">node_1</span><span class="s1">.</span><span class="s2">isParameterDeclaration</span><span class="s1">(</span><span class="s2">node</span><span class="s1">) ||</span>
        <span class="s2">node_1</span><span class="s1">.</span><span class="s2">isPropertyDeclaration</span><span class="s1">(</span><span class="s2">node</span><span class="s1">) ||</span>
        <span class="s2">node_1</span><span class="s1">.</span><span class="s2">isPropertySignature</span><span class="s1">(</span><span class="s2">node</span><span class="s1">)) &amp;&amp; (</span><span class="s2">util_1</span><span class="s1">.</span><span class="s2">isNodeFlagSet</span><span class="s1">(</span><span class="s2">node</span><span class="s1">, </span><span class="s2">ts</span><span class="s1">.</span><span class="s2">NodeFlags</span><span class="s1">.</span><span class="s2">JavaScriptFile</span><span class="s1">)</span>
        <span class="s1">? </span><span class="s2">ts</span><span class="s1">.</span><span class="s2">getJSDocType</span><span class="s1">(</span><span class="s2">node</span><span class="s1">)</span>
        <span class="s1">: </span><span class="s2">node</span><span class="s1">.</span><span class="s2">type</span><span class="s1">) !== </span><span class="s2">undefined</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s2">isExplicitlyTypedThis</span><span class="s1">(</span><span class="s2">node</span><span class="s1">) {</span>
    <span class="s3">var </span><span class="s2">_a</span><span class="s1">;</span>
    <span class="s3">do </span><span class="s1">{</span>
        <span class="s2">node </span><span class="s1">= </span><span class="s2">node</span><span class="s1">.</span><span class="s2">parent</span><span class="s1">;</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s2">node_1</span><span class="s1">.</span><span class="s2">isDecorator</span><span class="s1">(</span><span class="s2">node</span><span class="s1">)) {</span>
            <span class="s5">// `this` in decorators always resolves outside of the containing class</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s2">node</span><span class="s1">.</span><span class="s2">parent</span><span class="s1">.</span><span class="s2">kind </span><span class="s1">=== </span><span class="s2">ts</span><span class="s1">.</span><span class="s2">SyntaxKind</span><span class="s1">.</span><span class="s2">Parameter </span><span class="s1">&amp;&amp; </span><span class="s2">node_1</span><span class="s1">.</span><span class="s2">isClassLikeDeclaration</span><span class="s1">(</span><span class="s2">node</span><span class="s1">.</span><span class="s2">parent</span><span class="s1">.</span><span class="s2">parent</span><span class="s1">.</span><span class="s2">parent</span><span class="s1">)) {</span>
                <span class="s2">node </span><span class="s1">= </span><span class="s2">node</span><span class="s1">.</span><span class="s2">parent</span><span class="s1">.</span><span class="s2">parent</span><span class="s1">.</span><span class="s2">parent</span><span class="s1">.</span><span class="s2">parent</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">else if </span><span class="s1">(</span><span class="s2">node_1</span><span class="s1">.</span><span class="s2">isClassLikeDeclaration</span><span class="s1">(</span><span class="s2">node</span><span class="s1">.</span><span class="s2">parent</span><span class="s1">.</span><span class="s2">parent</span><span class="s1">)) {</span>
                <span class="s2">node </span><span class="s1">= </span><span class="s2">node</span><span class="s1">.</span><span class="s2">parent</span><span class="s1">.</span><span class="s2">parent</span><span class="s1">.</span><span class="s2">parent</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">else if </span><span class="s1">(</span><span class="s2">node_1</span><span class="s1">.</span><span class="s2">isClassLikeDeclaration</span><span class="s1">(</span><span class="s2">node</span><span class="s1">.</span><span class="s2">parent</span><span class="s1">)) {</span>
                <span class="s2">node </span><span class="s1">= </span><span class="s2">node</span><span class="s1">.</span><span class="s2">parent</span><span class="s1">.</span><span class="s2">parent</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">while </span><span class="s1">(</span><span class="s2">util_1</span><span class="s1">.</span><span class="s2">isFunctionScopeBoundary</span><span class="s1">(</span><span class="s2">node</span><span class="s1">) !== </span><span class="s4">1 </span><span class="s5">/* Function */ </span><span class="s1">|| </span><span class="s2">node</span><span class="s1">.</span><span class="s2">kind </span><span class="s1">=== </span><span class="s2">ts</span><span class="s1">.</span><span class="s2">SyntaxKind</span><span class="s1">.</span><span class="s2">ArrowFunction</span><span class="s1">);</span>
    <span class="s3">return </span><span class="s2">util_1</span><span class="s1">.</span><span class="s2">isFunctionWithBody</span><span class="s1">(</span><span class="s2">node</span><span class="s1">) &amp;&amp;</span>
        <span class="s1">(</span><span class="s2">util_1</span><span class="s1">.</span><span class="s2">isNodeFlagSet</span><span class="s1">(</span><span class="s2">node</span><span class="s1">, </span><span class="s2">ts</span><span class="s1">.</span><span class="s2">NodeFlags</span><span class="s1">.</span><span class="s2">JavaScriptFile</span><span class="s1">)</span>
            <span class="s1">? ((</span><span class="s2">_a </span><span class="s1">= </span><span class="s2">ts</span><span class="s1">.</span><span class="s2">getJSDocThisTag</span><span class="s1">(</span><span class="s2">node</span><span class="s1">)) === </span><span class="s3">null </span><span class="s1">|| </span><span class="s2">_a </span><span class="s1">=== </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">? </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">: </span><span class="s2">_a</span><span class="s1">.</span><span class="s2">typeExpression</span><span class="s1">) !== </span><span class="s2">undefined</span>
            <span class="s1">: </span><span class="s2">node</span><span class="s1">.</span><span class="s2">parameters</span><span class="s1">.</span><span class="s2">length </span><span class="s1">!== </span><span class="s4">0 </span><span class="s1">&amp;&amp; </span><span class="s2">util_1</span><span class="s1">.</span><span class="s2">isThisParameter</span><span class="s1">(</span><span class="s2">node</span><span class="s1">.</span><span class="s2">parameters</span><span class="s1">[</span><span class="s4">0</span><span class="s1">]) &amp;&amp; </span><span class="s2">node</span><span class="s1">.</span><span class="s2">parameters</span><span class="s1">[</span><span class="s4">0</span><span class="s1">].</span><span class="s2">type </span><span class="s1">!== </span><span class="s2">undefined</span><span class="s1">) ||</span>
        <span class="s2">node_1</span><span class="s1">.</span><span class="s2">isClassLikeDeclaration</span><span class="s1">(</span><span class="s2">node</span><span class="s1">.</span><span class="s2">parent</span><span class="s1">);</span>
<span class="s1">}</span>
<span class="s3">var </span><span class="s2">SignatureEffect</span><span class="s1">;</span>
<span class="s1">(</span><span class="s3">function </span><span class="s1">(</span><span class="s2">SignatureEffect</span><span class="s1">) {</span>
    <span class="s2">SignatureEffect</span><span class="s1">[</span><span class="s2">SignatureEffect</span><span class="s1">[</span><span class="s0">&quot;Never&quot;</span><span class="s1">] = </span><span class="s4">1</span><span class="s1">] = </span><span class="s0">&quot;Never&quot;</span><span class="s1">;</span>
    <span class="s2">SignatureEffect</span><span class="s1">[</span><span class="s2">SignatureEffect</span><span class="s1">[</span><span class="s0">&quot;Asserts&quot;</span><span class="s1">] = </span><span class="s4">2</span><span class="s1">] = </span><span class="s0">&quot;Asserts&quot;</span><span class="s1">;</span>
<span class="s1">})(</span><span class="s2">SignatureEffect </span><span class="s1">= </span><span class="s2">exports</span><span class="s1">.</span><span class="s2">SignatureEffect </span><span class="s1">|| (</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">SignatureEffect </span><span class="s1">= {}));</span>
<span class="s6">/**</span>
 <span class="s6">* Dermines whether a top level CallExpression has a control flow effect according to TypeScript's rules.</span>
 <span class="s6">* This handles functions returning `never` and `asserts`.</span>
 <span class="s6">*/</span>
<span class="s3">function </span><span class="s2">callExpressionAffectsControlFlow</span><span class="s1">(</span><span class="s2">node</span><span class="s1">, </span><span class="s2">checker</span><span class="s1">) {</span>
    <span class="s3">var </span><span class="s2">_a</span><span class="s1">, </span><span class="s2">_b</span><span class="s1">, </span><span class="s2">_c</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s1">(!</span><span class="s2">node_1</span><span class="s1">.</span><span class="s2">isExpressionStatement</span><span class="s1">(</span><span class="s2">node</span><span class="s1">.</span><span class="s2">parent</span><span class="s1">) ||</span>
        <span class="s2">ts</span><span class="s1">.</span><span class="s2">isOptionalChain</span><span class="s1">(</span><span class="s2">node</span><span class="s1">) ||</span>
        <span class="s1">!</span><span class="s2">isDottedNameWithExplicitTypeAnnotation</span><span class="s1">(</span><span class="s2">node</span><span class="s1">.</span><span class="s2">expression</span><span class="s1">, </span><span class="s2">checker</span><span class="s1">))</span>
        <span class="s3">return</span><span class="s1">;</span>
    <span class="s3">const </span><span class="s2">signature </span><span class="s1">= </span><span class="s2">checker</span><span class="s1">.</span><span class="s2">getResolvedSignature</span><span class="s1">(</span><span class="s2">node</span><span class="s1">);</span>
    <span class="s3">if </span><span class="s1">((</span><span class="s2">signature </span><span class="s1">=== </span><span class="s3">null </span><span class="s1">|| </span><span class="s2">signature </span><span class="s1">=== </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">? </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">: </span><span class="s2">signature</span><span class="s1">.</span><span class="s2">declaration</span><span class="s1">) === </span><span class="s2">undefined</span><span class="s1">)</span>
        <span class="s3">return</span><span class="s1">;</span>
    <span class="s3">const </span><span class="s2">typeNode </span><span class="s1">= </span><span class="s2">ts</span><span class="s1">.</span><span class="s2">isJSDocSignature</span><span class="s1">(</span><span class="s2">signature</span><span class="s1">.</span><span class="s2">declaration</span><span class="s1">)</span>
        <span class="s1">? (</span><span class="s2">_b </span><span class="s1">= (</span><span class="s2">_a </span><span class="s1">= </span><span class="s2">signature</span><span class="s1">.</span><span class="s2">declaration</span><span class="s1">.</span><span class="s2">type</span><span class="s1">) === </span><span class="s3">null </span><span class="s1">|| </span><span class="s2">_a </span><span class="s1">=== </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">? </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">: </span><span class="s2">_a</span><span class="s1">.</span><span class="s2">typeExpression</span><span class="s1">) === </span><span class="s3">null </span><span class="s1">|| </span><span class="s2">_b </span><span class="s1">=== </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">? </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">: </span><span class="s2">_b</span><span class="s1">.</span><span class="s2">type</span>
        <span class="s1">: (</span><span class="s2">_c </span><span class="s1">= </span><span class="s2">signature</span><span class="s1">.</span><span class="s2">declaration</span><span class="s1">.</span><span class="s2">type</span><span class="s1">) !== </span><span class="s3">null </span><span class="s1">&amp;&amp; </span><span class="s2">_c </span><span class="s1">!== </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">? </span><span class="s2">_c </span><span class="s1">: (</span><span class="s2">util_1</span><span class="s1">.</span><span class="s2">isNodeFlagSet</span><span class="s1">(</span><span class="s2">signature</span><span class="s1">.</span><span class="s2">declaration</span><span class="s1">, </span><span class="s2">ts</span><span class="s1">.</span><span class="s2">NodeFlags</span><span class="s1">.</span><span class="s2">JavaScriptFile</span><span class="s1">)</span>
            <span class="s1">? </span><span class="s2">ts</span><span class="s1">.</span><span class="s2">getJSDocReturnType</span><span class="s1">(</span><span class="s2">signature</span><span class="s1">.</span><span class="s2">declaration</span><span class="s1">)</span>
            <span class="s1">: </span><span class="s2">undefined</span><span class="s1">);</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s2">typeNode </span><span class="s1">=== </span><span class="s2">undefined</span><span class="s1">)</span>
        <span class="s3">return</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s2">node_1</span><span class="s1">.</span><span class="s2">isTypePredicateNode</span><span class="s1">(</span><span class="s2">typeNode</span><span class="s1">) &amp;&amp; </span><span class="s2">typeNode</span><span class="s1">.</span><span class="s2">assertsModifier </span><span class="s1">!== </span><span class="s2">undefined</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s4">2 </span><span class="s5">/* Asserts */</span><span class="s1">;</span>
    <span class="s3">return </span><span class="s2">util_1</span><span class="s1">.</span><span class="s2">isTypeFlagSet</span><span class="s1">(</span><span class="s2">checker</span><span class="s1">.</span><span class="s2">getTypeFromTypeNode</span><span class="s1">(</span><span class="s2">typeNode</span><span class="s1">), </span><span class="s2">ts</span><span class="s1">.</span><span class="s2">TypeFlags</span><span class="s1">.</span><span class="s2">Never</span><span class="s1">) ? </span><span class="s4">1 </span><span class="s5">/* Never */ </span><span class="s1">: </span><span class="s2">undefined</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">exports</span><span class="s1">.</span><span class="s2">callExpressionAffectsControlFlow </span><span class="s1">= </span><span class="s2">callExpressionAffectsControlFlow</span><span class="s1">;</span>
<span class="s3">function </span><span class="s2">handleExpressionStatement</span><span class="s1">(</span><span class="s2">node</span><span class="s1">, </span><span class="s2">checker</span><span class="s1">) {</span>
    <span class="s3">if </span><span class="s1">(!</span><span class="s2">node_1</span><span class="s1">.</span><span class="s2">isCallExpression</span><span class="s1">(</span><span class="s2">node</span><span class="s1">.</span><span class="s2">expression</span><span class="s1">))</span>
        <span class="s3">return </span><span class="s2">defaultControlFlowEnd</span><span class="s1">;</span>
    <span class="s3">switch </span><span class="s1">(</span><span class="s2">callExpressionAffectsControlFlow</span><span class="s1">(</span><span class="s2">node</span><span class="s1">.</span><span class="s2">expression</span><span class="s1">, </span><span class="s2">checker</span><span class="s1">)) {</span>
        <span class="s3">case </span><span class="s4">2 </span><span class="s5">/* Asserts */</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">{ </span><span class="s2">statements</span><span class="s1">: [</span><span class="s2">node</span><span class="s1">], </span><span class="s2">end</span><span class="s1">: </span><span class="s3">false </span><span class="s1">};</span>
        <span class="s3">case </span><span class="s4">1 </span><span class="s5">/* Never */</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">{ </span><span class="s2">statements</span><span class="s1">: [</span><span class="s2">node</span><span class="s1">], </span><span class="s2">end</span><span class="s1">: </span><span class="s3">true </span><span class="s1">};</span>
        <span class="s3">case </span><span class="s2">undefined</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s2">defaultControlFlowEnd</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s2">matchBreakOrContinue</span><span class="s1">(</span><span class="s2">current</span><span class="s1">, </span><span class="s2">pred</span><span class="s1">) {</span>
    <span class="s3">const </span><span class="s2">result </span><span class="s1">= {</span>
        <span class="s2">statements</span><span class="s1">: [],</span>
        <span class="s2">end</span><span class="s1">: </span><span class="s2">current</span><span class="s1">.</span><span class="s2">end</span><span class="s1">,</span>
    <span class="s1">};</span>
    <span class="s3">for </span><span class="s1">(</span><span class="s3">const </span><span class="s2">statement of current</span><span class="s1">.</span><span class="s2">statements</span><span class="s1">) {</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s2">pred</span><span class="s1">(</span><span class="s2">statement</span><span class="s1">) &amp;&amp; </span><span class="s2">statement</span><span class="s1">.</span><span class="s2">label </span><span class="s1">=== </span><span class="s2">undefined</span><span class="s1">) {</span>
            <span class="s2">result</span><span class="s1">.</span><span class="s2">end </span><span class="s1">= </span><span class="s3">false</span><span class="s1">;</span>
            <span class="s3">continue</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">result</span><span class="s1">.</span><span class="s2">statements</span><span class="s1">.</span><span class="s2">push</span><span class="s1">(</span><span class="s2">statement</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s3">return </span><span class="s2">result</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s2">matchLabel</span><span class="s1">(</span><span class="s2">current</span><span class="s1">, </span><span class="s2">label</span><span class="s1">) {</span>
    <span class="s3">const </span><span class="s2">result </span><span class="s1">= {</span>
        <span class="s2">statements</span><span class="s1">: [],</span>
        <span class="s2">end</span><span class="s1">: </span><span class="s2">current</span><span class="s1">.</span><span class="s2">end</span><span class="s1">,</span>
    <span class="s1">};</span>
    <span class="s3">const </span><span class="s2">labelText </span><span class="s1">= </span><span class="s2">label</span><span class="s1">.</span><span class="s2">text</span><span class="s1">;</span>
    <span class="s3">for </span><span class="s1">(</span><span class="s3">const </span><span class="s2">statement of current</span><span class="s1">.</span><span class="s2">statements</span><span class="s1">) {</span>
        <span class="s3">switch </span><span class="s1">(</span><span class="s2">statement</span><span class="s1">.</span><span class="s2">kind</span><span class="s1">) {</span>
            <span class="s3">case </span><span class="s2">ts</span><span class="s1">.</span><span class="s2">SyntaxKind</span><span class="s1">.</span><span class="s2">BreakStatement</span><span class="s1">:</span>
            <span class="s3">case </span><span class="s2">ts</span><span class="s1">.</span><span class="s2">SyntaxKind</span><span class="s1">.</span><span class="s2">ContinueStatement</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">(</span><span class="s2">statement</span><span class="s1">.</span><span class="s2">label </span><span class="s1">!== </span><span class="s2">undefined </span><span class="s1">&amp;&amp; </span><span class="s2">statement</span><span class="s1">.</span><span class="s2">label</span><span class="s1">.</span><span class="s2">text </span><span class="s1">=== </span><span class="s2">labelText</span><span class="s1">) {</span>
                    <span class="s2">result</span><span class="s1">.</span><span class="s2">end </span><span class="s1">= </span><span class="s3">false</span><span class="s1">;</span>
                    <span class="s3">continue</span><span class="s1">;</span>
                <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">result</span><span class="s1">.</span><span class="s2">statements</span><span class="s1">.</span><span class="s2">push</span><span class="s1">(</span><span class="s2">statement</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s3">return </span><span class="s2">result</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s5">//# sourceMappingURL=control-flow.js.map</span></pre>
</body>
</html>