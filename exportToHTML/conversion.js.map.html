<html>
<head>
<title>conversion.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
conversion.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_t&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;_template&quot;</span><span class="s0">,</span><span class="s1">&quot;_visitors&quot;</span><span class="s0">,</span><span class="s1">&quot;_context&quot;</span><span class="s0">,</span><span class="s1">&quot;arrowFunctionExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;assignmentExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;binaryExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;blockStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;callExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;conditionalExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;expressionStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;identifier&quot;</span><span class="s0">,</span><span class="s1">&quot;isIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;jsxIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;logicalExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;LOGICAL_OPERATORS&quot;</span><span class="s0">,</span><span class="s1">&quot;memberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;metaProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;numericLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;objectExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;restElement&quot;</span><span class="s0">,</span><span class="s1">&quot;returnStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;sequenceExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;spreadElement&quot;</span><span class="s0">,</span><span class="s1">&quot;stringLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;super&quot;</span><span class="s0">,</span><span class="s1">&quot;_super&quot;</span><span class="s0">,</span><span class="s1">&quot;thisExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;toExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;unaryExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;toBindingIdentifierName&quot;</span><span class="s0">,</span><span class="s1">&quot;isFunction&quot;</span><span class="s0">,</span><span class="s1">&quot;isAssignmentPattern&quot;</span><span class="s0">,</span><span class="s1">&quot;isRestElement&quot;</span><span class="s0">,</span><span class="s1">&quot;getFunctionName&quot;</span><span class="s0">,</span><span class="s1">&quot;cloneNode&quot;</span><span class="s0">,</span><span class="s1">&quot;variableDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;variableDeclarator&quot;</span><span class="s0">,</span><span class="s1">&quot;exportNamedDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;exportSpecifier&quot;</span><span class="s0">,</span><span class="s1">&quot;inherits&quot;</span><span class="s0">,</span><span class="s1">&quot;toComputedKey&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;isMemberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;property&quot;</span><span class="s0">,</span><span class="s1">&quot;isProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;isMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;ReferenceError&quot;</span><span class="s0">,</span><span class="s1">&quot;computed&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;ensureBlock&quot;</span><span class="s0">,</span><span class="s1">&quot;body&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;bodyNode&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;isArray&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;isBlockStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;statements&quot;</span><span class="s0">,</span><span class="s1">&quot;stringPath&quot;</span><span class="s0">,</span><span class="s1">&quot;listKey&quot;</span><span class="s0">,</span><span class="s1">&quot;isStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;parentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;setup&quot;</span><span class="s0">,</span><span class="s1">&quot;call&quot;</span><span class="s0">,</span><span class="s1">&quot;exports&quot;</span><span class="s0">,</span><span class="s1">&quot;arrowFunctionToShadowed&quot;</span><span class="s0">,</span><span class="s1">&quot;isArrowFunctionExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;arrowFunctionToExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;unwrapFunctionEnvironment&quot;</span><span class="s0">,</span><span class="s1">&quot;isFunctionExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isFunctionDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;buildCodeFrameError&quot;</span><span class="s0">,</span><span class="s1">&quot;hoistFunctionEnvironment&quot;</span><span class="s0">,</span><span class="s1">&quot;setType&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;allowInsertArrow&quot;</span><span class="s0">,</span><span class="s1">&quot;allowInsertArrowWithRest&quot;</span><span class="s0">,</span><span class="s1">&quot;noNewArrows&quot;</span><span class="s0">,</span><span class="s1">&quot;_arguments$&quot;</span><span class="s0">,</span><span class="s1">&quot;arguments&quot;</span><span class="s0">,</span><span class="s1">&quot;specCompliant&quot;</span><span class="s0">,</span><span class="s1">&quot;self&quot;</span><span class="s0">,</span><span class="s1">&quot;_self$ensureFunctionN&quot;</span><span class="s0">,</span><span class="s1">&quot;ensureFunctionName&quot;</span><span class="s0">,</span><span class="s1">&quot;thisBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;fnPath&quot;</span><span class="s0">,</span><span class="s1">&quot;fn&quot;</span><span class="s0">,</span><span class="s1">&quot;checkBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;scope&quot;</span><span class="s0">,</span><span class="s1">&quot;generateUidIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;id&quot;</span><span class="s0">,</span><span class="s1">&quot;init&quot;</span><span class="s0">,</span><span class="s1">&quot;unshiftContainer&quot;</span><span class="s0">,</span><span class="s1">&quot;hub&quot;</span><span class="s0">,</span><span class="s1">&quot;addHelper&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceWith&quot;</span><span class="s0">,</span><span class="s1">&quot;getSuperCallsVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;environmentVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;CallExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;child&quot;</span><span class="s0">,</span><span class="s1">&quot;allSuperCalls&quot;</span><span class="s0">,</span><span class="s1">&quot;isSuper&quot;</span><span class="s0">,</span><span class="s1">&quot;arrowParent&quot;</span><span class="s0">,</span><span class="s1">&quot;thisEnvFn&quot;</span><span class="s0">,</span><span class="s1">&quot;findParent&quot;</span><span class="s0">,</span><span class="s1">&quot;p&quot;</span><span class="s0">,</span><span class="s1">&quot;isProgram&quot;</span><span class="s0">,</span><span class="s1">&quot;isClassProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;static&quot;</span><span class="s0">,</span><span class="s1">&quot;isClassPrivateProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;inConstructor&quot;</span><span class="s0">,</span><span class="s1">&quot;isClassMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;kind&quot;</span><span class="s0">,</span><span class="s1">&quot;thisPaths&quot;</span><span class="s0">,</span><span class="s1">&quot;argumentsPaths&quot;</span><span class="s0">,</span><span class="s1">&quot;newTargetPaths&quot;</span><span class="s0">,</span><span class="s1">&quot;superProps&quot;</span><span class="s0">,</span><span class="s1">&quot;superCalls&quot;</span><span class="s0">,</span><span class="s1">&quot;getScopeInformation&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;traverse&quot;</span><span class="s0">,</span><span class="s1">&quot;superBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;getSuperBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;forEach&quot;</span><span class="s0">,</span><span class="s1">&quot;superCall&quot;</span><span class="s0">,</span><span class="s1">&quot;callee&quot;</span><span class="s0">,</span><span class="s1">&quot;loc&quot;</span><span class="s0">,</span><span class="s1">&quot;argumentsBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;getBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;args&quot;</span><span class="s0">,</span><span class="s1">&quot;buildUndefinedNode&quot;</span><span class="s0">,</span><span class="s1">&quot;argumentsChild&quot;</span><span class="s0">,</span><span class="s1">&quot;argsRef&quot;</span><span class="s0">,</span><span class="s1">&quot;newTargetBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;targetChild&quot;</span><span class="s0">,</span><span class="s1">&quot;targetRef&quot;</span><span class="s0">,</span><span class="s1">&quot;flatSuperProps&quot;</span><span class="s0">,</span><span class="s1">&quot;reduce&quot;</span><span class="s0">,</span><span class="s1">&quot;acc&quot;</span><span class="s0">,</span><span class="s1">&quot;superProp&quot;</span><span class="s0">,</span><span class="s1">&quot;concat&quot;</span><span class="s0">,</span><span class="s1">&quot;standardizeSuperProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;superParentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;isAssignment&quot;</span><span class="s0">,</span><span class="s1">&quot;isAssignmentExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;left&quot;</span><span class="s0">,</span><span class="s1">&quot;isCall&quot;</span><span class="s0">,</span><span class="s1">&quot;isCallExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isTaggedTemplate&quot;</span><span class="s0">,</span><span class="s1">&quot;isTaggedTemplateExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;tag&quot;</span><span class="s0">,</span><span class="s1">&quot;getSuperPropBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;right&quot;</span><span class="s0">,</span><span class="s1">&quot;getThisBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;hasSuperClass&quot;</span><span class="s0">,</span><span class="s1">&quot;thisChild&quot;</span><span class="s0">,</span><span class="s1">&quot;thisRef&quot;</span><span class="s0">,</span><span class="s1">&quot;isJSX&quot;</span><span class="s0">,</span><span class="s1">&quot;isLogicalOp&quot;</span><span class="s0">,</span><span class="s1">&quot;op&quot;</span><span class="s0">,</span><span class="s1">&quot;includes&quot;</span><span class="s0">,</span><span class="s1">&quot;operator&quot;</span><span class="s0">,</span><span class="s1">&quot;assignmentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;isLogicalAssignment&quot;</span><span class="s0">,</span><span class="s1">&quot;tmp&quot;</span><span class="s0">,</span><span class="s1">&quot;generateDeclaredUidIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;object&quot;</span><span class="s0">,</span><span class="s1">&quot;rightExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isUpdateExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;updateExpr&quot;</span><span class="s0">,</span><span class="s1">&quot;computedKey&quot;</span><span class="s0">,</span><span class="s1">&quot;parts&quot;</span><span class="s0">,</span><span class="s1">&quot;prefix&quot;</span><span class="s0">,</span><span class="s1">&quot;superClass&quot;</span><span class="s0">,</span><span class="s1">&quot;assignSuperThisVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;supers&quot;</span><span class="s0">,</span><span class="s1">&quot;has&quot;</span><span class="s0">,</span><span class="s1">&quot;add&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceWithMultiple&quot;</span><span class="s0">,</span><span class="s1">&quot;WeakSet&quot;</span><span class="s0">,</span><span class="s1">&quot;argsBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;propName&quot;</span><span class="s0">,</span><span class="s1">&quot;argsList&quot;</span><span class="s0">,</span><span class="s1">&quot;fnBody&quot;</span><span class="s0">,</span><span class="s1">&quot;method&quot;</span><span class="s0">,</span><span class="s1">&quot;unshift&quot;</span><span class="s0">,</span><span class="s1">&quot;valueIdent&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheKey&quot;</span><span class="s0">,</span><span class="s1">&quot;data&quot;</span><span class="s0">,</span><span class="s1">&quot;getData&quot;</span><span class="s0">,</span><span class="s1">&quot;setData&quot;</span><span class="s0">,</span><span class="s1">&quot;getScopeInformationVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;ThisExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;JSXIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;isJSXMemberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isJSXOpeningElement&quot;</span><span class="s0">,</span><span class="s1">&quot;MemberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;Identifier&quot;</span><span class="s0">,</span><span class="s1">&quot;isReferencedIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;curr&quot;</span><span class="s0">,</span><span class="s1">&quot;hasOwnBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;rename&quot;</span><span class="s0">,</span><span class="s1">&quot;parent&quot;</span><span class="s0">,</span><span class="s1">&quot;MetaProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;splitExportDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;isExportDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;isExportAllDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;isExportNamedDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;declaration&quot;</span><span class="s0">,</span><span class="s1">&quot;isExportDefaultDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;standaloneDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;isClassDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;exportExpr&quot;</span><span class="s0">,</span><span class="s1">&quot;isClassExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isScope&quot;</span><span class="s0">,</span><span class="s1">&quot;needBindingRegistration&quot;</span><span class="s0">,</span><span class="s1">&quot;hasBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;updatedDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;updatedExportDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;insertAfter&quot;</span><span class="s0">,</span><span class="s1">&quot;registerDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;bindingIdentifiers&quot;</span><span class="s0">,</span><span class="s1">&quot;getOuterBindingIdentifiers&quot;</span><span class="s0">,</span><span class="s1">&quot;specifiers&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;keys&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;aliasDeclar&quot;</span><span class="s0">,</span><span class="s1">&quot;refersOuterBindingVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;ReferencedIdentifier|BindingIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;state&quot;</span><span class="s0">,</span><span class="s1">&quot;needsRename&quot;</span><span class="s0">,</span><span class="s1">&quot;stop&quot;</span><span class="s0">,</span><span class="s1">&quot;Scope&quot;</span><span class="s0">,</span><span class="s1">&quot;skip&quot;</span><span class="s0">,</span><span class="s1">&quot;supportUnicodeId&quot;</span><span class="s0">,</span><span class="s1">&quot;res&quot;</span><span class="s0">,</span><span class="s1">&quot;test&quot;</span><span class="s0">,</span><span class="s1">&quot;startsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;replace&quot;</span><span class="s0">,</span><span class="s1">&quot;originalNode&quot;</span><span class="s0">,</span><span class="s1">&quot;binding&quot;</span><span class="s0">,</span><span class="s1">&quot;getOwnBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;hasGlobal&quot;</span><span class="s0">,</span><span class="s1">&quot;getProgramParent&quot;</span><span class="s0">,</span><span class="s1">&quot;references&quot;</span><span class="s0">,</span><span class="s1">&quot;params&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;len&quot;</span><span class="s0">,</span><span class="s1">&quot;getFunctionArity&quot;</span><span class="s0">,</span><span class="s1">&quot;template&quot;</span><span class="s0">,</span><span class="s1">&quot;expression&quot;</span><span class="s0">,</span><span class="s1">&quot;ast&quot;</span><span class="s0">,</span><span class="s1">&quot;count&quot;</span><span class="s0">,</span><span class="s1">&quot;findIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;param&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../src/path/conversion.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;// This file contains methods that convert the path node into another node or some other type of data.</span><span class="s3">\n\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">arrowFunctionExpression,</span><span class="s3">\n  </span><span class="s1">assignmentExpression,</span><span class="s3">\n  </span><span class="s1">binaryExpression,</span><span class="s3">\n  </span><span class="s1">blockStatement,</span><span class="s3">\n  </span><span class="s1">callExpression,</span><span class="s3">\n  </span><span class="s1">conditionalExpression,</span><span class="s3">\n  </span><span class="s1">expressionStatement,</span><span class="s3">\n  </span><span class="s1">identifier,</span><span class="s3">\n  </span><span class="s1">isIdentifier,</span><span class="s3">\n  </span><span class="s1">jsxIdentifier,</span><span class="s3">\n  </span><span class="s1">logicalExpression,</span><span class="s3">\n  </span><span class="s1">LOGICAL_OPERATORS,</span><span class="s3">\n  </span><span class="s1">memberExpression,</span><span class="s3">\n  </span><span class="s1">metaProperty,</span><span class="s3">\n  </span><span class="s1">numericLiteral,</span><span class="s3">\n  </span><span class="s1">objectExpression,</span><span class="s3">\n  </span><span class="s1">restElement,</span><span class="s3">\n  </span><span class="s1">returnStatement,</span><span class="s3">\n  </span><span class="s1">sequenceExpression,</span><span class="s3">\n  </span><span class="s1">spreadElement,</span><span class="s3">\n  </span><span class="s1">stringLiteral,</span><span class="s3">\n  </span><span class="s1">super as _super,</span><span class="s3">\n  </span><span class="s1">thisExpression,</span><span class="s3">\n  </span><span class="s1">toExpression,</span><span class="s3">\n  </span><span class="s1">unaryExpression,</span><span class="s3">\n  </span><span class="s1">toBindingIdentifierName,</span><span class="s3">\n  </span><span class="s1">isFunction,</span><span class="s3">\n  </span><span class="s1">isAssignmentPattern,</span><span class="s3">\n  </span><span class="s1">isRestElement,</span><span class="s3">\n  </span><span class="s1">getFunctionName,</span><span class="s3">\n  </span><span class="s1">cloneNode,</span><span class="s3">\n  </span><span class="s1">variableDeclaration,</span><span class="s3">\n  </span><span class="s1">variableDeclarator,</span><span class="s3">\n  </span><span class="s1">exportNamedDeclaration,</span><span class="s3">\n  </span><span class="s1">exportSpecifier,</span><span class="s3">\n  </span><span class="s1">inherits,</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">@babel/types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type * as t from </span><span class="s3">\&quot;</span><span class="s1">@babel/types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import template from </span><span class="s3">\&quot;</span><span class="s1">@babel/template</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { environmentVisitor } from </span><span class="s3">\&quot;</span><span class="s1">../visitors.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type NodePath from </span><span class="s3">\&quot;</span><span class="s1">./index.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { Visitor } from </span><span class="s3">\&quot;</span><span class="s1">../types.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { setup } from </span><span class="s3">\&quot;</span><span class="s1">./context.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">export function toComputedKey(this: NodePath) {</span><span class="s3">\n  </span><span class="s1">let key;</span><span class="s3">\n  </span><span class="s1">if (this.isMemberExpression()) {</span><span class="s3">\n    </span><span class="s1">key = this.node.property;</span><span class="s3">\n  </span><span class="s1">} else if (this.isProperty() || this.isMethod()) {</span><span class="s3">\n    </span><span class="s1">key = this.node.key;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">throw new ReferenceError(</span><span class="s3">\&quot;</span><span class="s1">todo</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts) computed does not exist in ClassPrivateProperty</span><span class="s3">\n  </span><span class="s1">if (!this.node.computed) {</span><span class="s3">\n    </span><span class="s1">if (isIdentifier(key)) key = stringLiteral(key.name);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return key;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function ensureBlock(</span><span class="s3">\n  </span><span class="s1">this: NodePath&lt;</span><span class="s3">\n    </span><span class="s1">t.Loop | t.WithStatement | t.Function | t.LabeledStatement | t.CatchClause</span><span class="s3">\n  </span><span class="s1">&gt;,</span><span class="s3">\n</span><span class="s1">): void {</span><span class="s3">\n  </span><span class="s1">const body = this.get(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">const bodyNode = body.node;</span><span class="s3">\n\n  </span><span class="s1">if (Array.isArray(body)) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">Can't convert array path to a block statement</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (!bodyNode) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">Can't convert node without a body</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (body.isBlockStatement()) {</span><span class="s3">\n    </span><span class="s1">// @ts-expect-error TS throws because ensureBlock returns the body node path</span><span class="s3">\n    </span><span class="s1">// however, we don't use the return value and treat it as a transform and</span><span class="s3">\n    </span><span class="s1">// assertion utilities. For better type inference we annotate it as an</span><span class="s3">\n    </span><span class="s1">// assertion method</span><span class="s3">\n    </span><span class="s1">// TODO: Unify the implementation with the type definition</span><span class="s3">\n    </span><span class="s1">return bodyNode;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const statements: Array&lt;t.Statement&gt; = [];</span><span class="s3">\n\n  </span><span class="s1">let stringPath = </span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">let key;</span><span class="s3">\n  </span><span class="s1">let listKey;</span><span class="s3">\n  </span><span class="s1">if (body.isStatement()) {</span><span class="s3">\n    </span><span class="s1">listKey = </span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">key = 0;</span><span class="s3">\n    </span><span class="s1">statements.push(body.node);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">stringPath += </span><span class="s3">\&quot;</span><span class="s1">.body.0</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">if (this.isFunction()) {</span><span class="s3">\n      </span><span class="s1">key = </span><span class="s3">\&quot;</span><span class="s1">argument</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">statements.push(returnStatement(body.node as t.Expression));</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">key = </span><span class="s3">\&quot;</span><span class="s1">expression</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">statements.push(expressionStatement(body.node as t.Expression));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">this.node.body = blockStatement(statements);</span><span class="s3">\n  </span><span class="s1">const parentPath = this.get(stringPath) as NodePath;</span><span class="s3">\n  </span><span class="s1">setup.call(</span><span class="s3">\n    </span><span class="s1">body,</span><span class="s3">\n    </span><span class="s1">parentPath,</span><span class="s3">\n    </span><span class="s1">listKey</span><span class="s3">\n      </span><span class="s1">? // @ts-expect-error listKey must present in parent path</span><span class="s3">\n        </span><span class="s1">parentPath.node[listKey]</span><span class="s3">\n      </span><span class="s1">: parentPath.node,</span><span class="s3">\n    </span><span class="s1">listKey,</span><span class="s3">\n    </span><span class="s1">key,</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n\n  </span><span class="s1">// @ts-expect-error TS throws because ensureBlock returns the body node path</span><span class="s3">\n  </span><span class="s1">// however, we don't use the return value and treat it as a transform and</span><span class="s3">\n  </span><span class="s1">// assertion utilities. For better type inference we annotate it as an</span><span class="s3">\n  </span><span class="s1">// assertion method</span><span class="s3">\n  </span><span class="s1">// TODO: Unify the implementation with the type definition</span><span class="s3">\n  </span><span class="s1">return this.node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">if (!process.env.BABEL_8_BREAKING &amp;&amp; !USE_ESM) {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Keeping this for backward-compatibility. You should use arrowFunctionToExpression() for &gt;=7.x.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">// eslint-disable-next-line no-restricted-globals</span><span class="s3">\n  </span><span class="s1">exports.arrowFunctionToShadowed = function (this: NodePath) {</span><span class="s3">\n    </span><span class="s1">if (!this.isArrowFunctionExpression()) return;</span><span class="s3">\n\n    </span><span class="s1">this.arrowFunctionToExpression();</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Given an arbitrary function, process its content as if it were an arrow function, moving references</span><span class="s3">\n </span><span class="s1">* to </span><span class="s3">\&quot;</span><span class="s1">this</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">super</span><span class="s3">\&quot;</span><span class="s1">, and such into the function's parent scope. This method is useful if</span><span class="s3">\n </span><span class="s1">* you have wrapped some set of items in an IIFE or other function, but want </span><span class="s3">\&quot;</span><span class="s1">this</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">, and super</span><span class="s3">\&quot;\n </span><span class="s1">* to continue behaving as expected.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function unwrapFunctionEnvironment(this: NodePath) {</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">!this.isArrowFunctionExpression() &amp;&amp;</span><span class="s3">\n    </span><span class="s1">!this.isFunctionExpression() &amp;&amp;</span><span class="s3">\n    </span><span class="s1">!this.isFunctionDeclaration()</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">throw this.buildCodeFrameError(</span><span class="s3">\n      \&quot;</span><span class="s1">Can only unwrap the environment of a function.</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">hoistFunctionEnvironment(this);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function setType&lt;N extends t.Node, T extends N[</span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">]&gt;(</span><span class="s3">\n  </span><span class="s1">path: NodePath&lt;N&gt;,</span><span class="s3">\n  </span><span class="s1">type: T,</span><span class="s3">\n</span><span class="s1">): asserts path is NodePath&lt;Extract&lt;N, { type: T }&gt;&gt; {</span><span class="s3">\n  </span><span class="s1">path.node.type = type;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Convert a given arrow function into a normal ES5 function expression.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function arrowFunctionToExpression(</span><span class="s3">\n  </span><span class="s1">this: NodePath&lt;t.ArrowFunctionExpression&gt;,</span><span class="s3">\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">allowInsertArrow = true,</span><span class="s3">\n    </span><span class="s1">allowInsertArrowWithRest = allowInsertArrow,</span><span class="s3">\n    </span><span class="s1">noNewArrows = process.env.BABEL_8_BREAKING</span><span class="s3">\n      </span><span class="s1">? // TODO(Babel 8): Consider defaulting to `false` for spec compliance</span><span class="s3">\n        </span><span class="s1">true</span><span class="s3">\n      </span><span class="s1">: !arguments[0]?.specCompliant,</span><span class="s3">\n  </span><span class="s1">}: {</span><span class="s3">\n    </span><span class="s1">allowInsertArrow?: boolean | void;</span><span class="s3">\n    </span><span class="s1">allowInsertArrowWithRest?: boolean | void;</span><span class="s3">\n    </span><span class="s1">noNewArrows?: boolean;</span><span class="s3">\n  </span><span class="s1">} = {},</span><span class="s3">\n</span><span class="s1">): NodePath&lt;</span><span class="s3">\n  </span><span class="s1">Exclude&lt;t.Function, t.Method | t.ArrowFunctionExpression&gt; | t.CallExpression</span><span class="s3">\n</span><span class="s1">&gt; {</span><span class="s3">\n  </span><span class="s1">if (!this.isArrowFunctionExpression()) {</span><span class="s3">\n    </span><span class="s1">throw (this as NodePath).buildCodeFrameError(</span><span class="s3">\n      \&quot;</span><span class="s1">Cannot convert non-arrow function to a function expression.</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let self = this;</span><span class="s3">\n  </span><span class="s1">if (!noNewArrows) {</span><span class="s3">\n    </span><span class="s1">// @ts-expect-error This is technicallynot valid on arrow functions</span><span class="s3">\n    </span><span class="s1">// because it adds an .id property, but we are going to convert it</span><span class="s3">\n    </span><span class="s1">// to a function expression anyway</span><span class="s3">\n    </span><span class="s1">self = self.ensureFunctionName(false) ?? self;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const { thisBinding, fnPath: fn } = hoistFunctionEnvironment(</span><span class="s3">\n    </span><span class="s1">self,</span><span class="s3">\n    </span><span class="s1">noNewArrows,</span><span class="s3">\n    </span><span class="s1">allowInsertArrow,</span><span class="s3">\n    </span><span class="s1">allowInsertArrowWithRest,</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n\n  </span><span class="s1">fn.ensureBlock();</span><span class="s3">\n  </span><span class="s1">setType(fn, </span><span class="s3">\&quot;</span><span class="s1">FunctionExpression</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n  </span><span class="s1">if (!noNewArrows) {</span><span class="s3">\n    </span><span class="s1">const checkBinding = thisBinding</span><span class="s3">\n      </span><span class="s1">? null</span><span class="s3">\n      </span><span class="s1">: fn.scope.generateUidIdentifier(</span><span class="s3">\&quot;</span><span class="s1">arrowCheckId</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">if (checkBinding) {</span><span class="s3">\n      </span><span class="s1">fn.parentPath.scope.push({</span><span class="s3">\n        </span><span class="s1">id: checkBinding,</span><span class="s3">\n        </span><span class="s1">init: objectExpression([]),</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">fn.get(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">).unshiftContainer(</span><span class="s3">\n      \&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">expressionStatement(</span><span class="s3">\n        </span><span class="s1">callExpression(this.hub.addHelper(</span><span class="s3">\&quot;</span><span class="s1">newArrowCheck</span><span class="s3">\&quot;</span><span class="s1">), [</span><span class="s3">\n          </span><span class="s1">thisExpression(),</span><span class="s3">\n          </span><span class="s1">checkBinding</span><span class="s3">\n            </span><span class="s1">? identifier(checkBinding.name)</span><span class="s3">\n            </span><span class="s1">: identifier(thisBinding),</span><span class="s3">\n        </span><span class="s1">]),</span><span class="s3">\n      </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n\n    </span><span class="s1">fn.replaceWith(</span><span class="s3">\n      </span><span class="s1">callExpression(memberExpression(fn.node, identifier(</span><span class="s3">\&quot;</span><span class="s1">bind</span><span class="s3">\&quot;</span><span class="s1">)), [</span><span class="s3">\n        </span><span class="s1">checkBinding ? identifier(checkBinding.name) : thisExpression(),</span><span class="s3">\n      </span><span class="s1">]),</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n\n    </span><span class="s1">return fn.get(</span><span class="s3">\&quot;</span><span class="s1">callee.object</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return fn;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const getSuperCallsVisitor = environmentVisitor&lt;{</span><span class="s3">\n  </span><span class="s1">allSuperCalls: NodePath&lt;t.CallExpression&gt;[];</span><span class="s3">\n</span><span class="s1">}&gt;({</span><span class="s3">\n  </span><span class="s1">CallExpression(child, { allSuperCalls }) {</span><span class="s3">\n    </span><span class="s1">if (!child.get(</span><span class="s3">\&quot;</span><span class="s1">callee</span><span class="s3">\&quot;</span><span class="s1">).isSuper()) return;</span><span class="s3">\n    </span><span class="s1">allSuperCalls.push(child);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Given a function, traverse its contents, and if there are references to </span><span class="s3">\&quot;</span><span class="s1">this</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">super</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n </span><span class="s1">* or </span><span class="s3">\&quot;</span><span class="s1">new.target</span><span class="s3">\&quot;</span><span class="s1">, ensure that these references reference the parent environment around this function.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @returns `thisBinding`: the name of the injected reference to `this`; for example </span><span class="s3">\&quot;</span><span class="s1">_this</span><span class="s3">\&quot;\n </span><span class="s1">* @returns `fnPath`: the new path to the function node. This is different from the fnPath</span><span class="s3">\n </span><span class="s1">*                    parameter when the function node is wrapped in another node.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function hoistFunctionEnvironment(</span><span class="s3">\n  </span><span class="s1">fnPath: NodePath&lt;t.Function&gt;,</span><span class="s3">\n  </span><span class="s1">// TODO(Babel 8): Consider defaulting to `false` for spec compliance</span><span class="s3">\n  </span><span class="s1">noNewArrows: boolean | void = true,</span><span class="s3">\n  </span><span class="s1">allowInsertArrow: boolean | void = true,</span><span class="s3">\n  </span><span class="s1">allowInsertArrowWithRest: boolean | void = true,</span><span class="s3">\n</span><span class="s1">): { thisBinding: string; fnPath: NodePath&lt;t.Function&gt; } {</span><span class="s3">\n  </span><span class="s1">let arrowParent;</span><span class="s3">\n  </span><span class="s1">let thisEnvFn: NodePath&lt;t.Function&gt; = fnPath.findParent(p =&gt; {</span><span class="s3">\n    </span><span class="s1">if (p.isArrowFunctionExpression()) {</span><span class="s3">\n      </span><span class="s1">arrowParent ??= p;</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return (</span><span class="s3">\n      </span><span class="s1">p.isFunction() ||</span><span class="s3">\n      </span><span class="s1">p.isProgram() ||</span><span class="s3">\n      </span><span class="s1">p.isClassProperty({ static: false }) ||</span><span class="s3">\n      </span><span class="s1">p.isClassPrivateProperty({ static: false })</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}) as NodePath&lt;t.Function&gt;;</span><span class="s3">\n  </span><span class="s1">const inConstructor = thisEnvFn.isClassMethod({ kind: </span><span class="s3">\&quot;</span><span class="s1">constructor</span><span class="s3">\&quot; </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">if (thisEnvFn.isClassProperty() || thisEnvFn.isClassPrivateProperty()) {</span><span class="s3">\n    </span><span class="s1">if (arrowParent) {</span><span class="s3">\n      </span><span class="s1">thisEnvFn = arrowParent;</span><span class="s3">\n    </span><span class="s1">} else if (allowInsertArrow) {</span><span class="s3">\n      </span><span class="s1">// It's safe to wrap this function in another and not hoist to the</span><span class="s3">\n      </span><span class="s1">// top level because the 'this' binding is constant in class</span><span class="s3">\n      </span><span class="s1">// properties (since 'super()' has already been called), so we don't</span><span class="s3">\n      </span><span class="s1">// need to capture/reassign it at the top level.</span><span class="s3">\n      </span><span class="s1">fnPath.replaceWith(</span><span class="s3">\n        </span><span class="s1">callExpression(</span><span class="s3">\n          </span><span class="s1">arrowFunctionExpression([], toExpression(fnPath.node)),</span><span class="s3">\n          </span><span class="s1">[],</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">thisEnvFn = fnPath.get(</span><span class="s3">\&quot;</span><span class="s1">callee</span><span class="s3">\&quot;</span><span class="s1">) as NodePath&lt;t.ArrowFunctionExpression&gt;;</span><span class="s3">\n      </span><span class="s1">fnPath = thisEnvFn.get(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">) as NodePath&lt;t.FunctionExpression&gt;;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">throw fnPath.buildCodeFrameError(</span><span class="s3">\n        \&quot;</span><span class="s1">Unable to transform arrow inside class property</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const { thisPaths, argumentsPaths, newTargetPaths, superProps, superCalls } =</span><span class="s3">\n    </span><span class="s1">getScopeInformation(fnPath);</span><span class="s3">\n\n  </span><span class="s1">// Convert all super() calls in the constructor, if super is used in an arrow.</span><span class="s3">\n  </span><span class="s1">if (inConstructor &amp;&amp; superCalls.length &gt; 0) {</span><span class="s3">\n    </span><span class="s1">if (!allowInsertArrow) {</span><span class="s3">\n      </span><span class="s1">throw superCalls[0].buildCodeFrameError(</span><span class="s3">\n        \&quot;</span><span class="s1">When using '@babel/plugin-transform-arrow-functions', </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n          \&quot;</span><span class="s1">it's not possible to compile `super()` in an arrow function without compiling classes.</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n          \&quot;</span><span class="s1">Please add '@babel/plugin-transform-classes' to your Babel configuration.</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!allowInsertArrowWithRest) {</span><span class="s3">\n      </span><span class="s1">// preset-env with target `since 2017` enables `transform-parameters` without `transform-classes`.</span><span class="s3">\n      </span><span class="s1">throw superCalls[0].buildCodeFrameError(</span><span class="s3">\n        \&quot;</span><span class="s1">When using '@babel/plugin-transform-parameters', </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n          \&quot;</span><span class="s1">it's not possible to compile `super()` in an arrow function with default or rest parameters without compiling classes.</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n          \&quot;</span><span class="s1">Please add '@babel/plugin-transform-classes' to your Babel configuration.</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const allSuperCalls: NodePath&lt;t.CallExpression&gt;[] = [];</span><span class="s3">\n    </span><span class="s1">thisEnvFn.traverse(getSuperCallsVisitor, { allSuperCalls });</span><span class="s3">\n    </span><span class="s1">const superBinding = getSuperBinding(thisEnvFn);</span><span class="s3">\n    </span><span class="s1">allSuperCalls.forEach(superCall =&gt; {</span><span class="s3">\n      </span><span class="s1">const callee = identifier(superBinding);</span><span class="s3">\n      </span><span class="s1">callee.loc = superCall.node.callee.loc;</span><span class="s3">\n\n      </span><span class="s1">superCall.get(</span><span class="s3">\&quot;</span><span class="s1">callee</span><span class="s3">\&quot;</span><span class="s1">).replaceWith(callee);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Convert all </span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot; </span><span class="s1">references in the arrow to point at the alias.</span><span class="s3">\n  </span><span class="s1">if (argumentsPaths.length &gt; 0) {</span><span class="s3">\n    </span><span class="s1">const argumentsBinding = getBinding(thisEnvFn, </span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">, () =&gt; {</span><span class="s3">\n      </span><span class="s1">const args = () =&gt; identifier(</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">if (thisEnvFn.scope.path.isProgram()) {</span><span class="s3">\n        </span><span class="s1">return conditionalExpression(</span><span class="s3">\n          </span><span class="s1">binaryExpression(</span><span class="s3">\n            \&quot;</span><span class="s1">===</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">unaryExpression(</span><span class="s3">\&quot;</span><span class="s1">typeof</span><span class="s3">\&quot;</span><span class="s1">, args()),</span><span class="s3">\n            </span><span class="s1">stringLiteral(</span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">thisEnvFn.scope.buildUndefinedNode(),</span><span class="s3">\n          </span><span class="s1">args(),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">return args();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n\n    </span><span class="s1">argumentsPaths.forEach(argumentsChild =&gt; {</span><span class="s3">\n      </span><span class="s1">const argsRef = identifier(argumentsBinding);</span><span class="s3">\n      </span><span class="s1">argsRef.loc = argumentsChild.node.loc;</span><span class="s3">\n\n      </span><span class="s1">argumentsChild.replaceWith(argsRef);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Convert all </span><span class="s3">\&quot;</span><span class="s1">new.target</span><span class="s3">\&quot; </span><span class="s1">references in the arrow to point at the alias.</span><span class="s3">\n  </span><span class="s1">if (newTargetPaths.length &gt; 0) {</span><span class="s3">\n    </span><span class="s1">const newTargetBinding = getBinding(thisEnvFn, </span><span class="s3">\&quot;</span><span class="s1">newtarget</span><span class="s3">\&quot;</span><span class="s1">, () =&gt;</span><span class="s3">\n      </span><span class="s1">metaProperty(identifier(</span><span class="s3">\&quot;</span><span class="s1">new</span><span class="s3">\&quot;</span><span class="s1">), identifier(</span><span class="s3">\&quot;</span><span class="s1">target</span><span class="s3">\&quot;</span><span class="s1">)),</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n\n    </span><span class="s1">newTargetPaths.forEach(targetChild =&gt; {</span><span class="s3">\n      </span><span class="s1">const targetRef = identifier(newTargetBinding);</span><span class="s3">\n      </span><span class="s1">targetRef.loc = targetChild.node.loc;</span><span class="s3">\n\n      </span><span class="s1">targetChild.replaceWith(targetRef);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Convert all </span><span class="s3">\&quot;</span><span class="s1">super.prop</span><span class="s3">\&quot; </span><span class="s1">references to point at aliases.</span><span class="s3">\n  </span><span class="s1">if (superProps.length &gt; 0) {</span><span class="s3">\n    </span><span class="s1">if (!allowInsertArrow) {</span><span class="s3">\n      </span><span class="s1">throw superProps[0].buildCodeFrameError(</span><span class="s3">\n        \&quot;</span><span class="s1">When using '@babel/plugin-transform-arrow-functions', </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n          \&quot;</span><span class="s1">it's not possible to compile `super.prop` in an arrow function without compiling classes.</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n          \&quot;</span><span class="s1">Please add '@babel/plugin-transform-classes' to your Babel configuration.</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const flatSuperProps: NodePath&lt;t.MemberExpression&gt;[] = superProps.reduce(</span><span class="s3">\n      </span><span class="s1">(acc, superProp) =&gt; acc.concat(standardizeSuperProperty(superProp)),</span><span class="s3">\n      </span><span class="s1">[],</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n\n    </span><span class="s1">flatSuperProps.forEach(superProp =&gt; {</span><span class="s3">\n      </span><span class="s1">const key = superProp.node.computed</span><span class="s3">\n        </span><span class="s1">? </span><span class="s3">\&quot;\&quot;\n        </span><span class="s1">: // @ts-expect-error super property must not contain private name</span><span class="s3">\n          </span><span class="s1">superProp.get(</span><span class="s3">\&quot;</span><span class="s1">property</span><span class="s3">\&quot;</span><span class="s1">).node.name;</span><span class="s3">\n\n      </span><span class="s1">const superParentPath = superProp.parentPath;</span><span class="s3">\n\n      </span><span class="s1">const isAssignment = superParentPath.isAssignmentExpression({</span><span class="s3">\n        </span><span class="s1">left: superProp.node,</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">const isCall = superParentPath.isCallExpression({</span><span class="s3">\n        </span><span class="s1">callee: superProp.node,</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">const isTaggedTemplate = superParentPath.isTaggedTemplateExpression({</span><span class="s3">\n        </span><span class="s1">tag: superProp.node,</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">const superBinding = getSuperPropBinding(thisEnvFn, isAssignment, key);</span><span class="s3">\n\n      </span><span class="s1">const args: t.Expression[] = [];</span><span class="s3">\n      </span><span class="s1">if (superProp.node.computed) {</span><span class="s3">\n        </span><span class="s1">// SuperProperty must not be a private name</span><span class="s3">\n        </span><span class="s1">args.push(superProp.get(</span><span class="s3">\&quot;</span><span class="s1">property</span><span class="s3">\&quot;</span><span class="s1">).node as t.Expression);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (isAssignment) {</span><span class="s3">\n        </span><span class="s1">const value = superParentPath.node.right;</span><span class="s3">\n        </span><span class="s1">args.push(value);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const call = callExpression(identifier(superBinding), args);</span><span class="s3">\n\n      </span><span class="s1">if (isCall) {</span><span class="s3">\n        </span><span class="s1">superParentPath.unshiftContainer(</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">, thisExpression());</span><span class="s3">\n        </span><span class="s1">superProp.replaceWith(memberExpression(call, identifier(</span><span class="s3">\&quot;</span><span class="s1">call</span><span class="s3">\&quot;</span><span class="s1">)));</span><span class="s3">\n\n        </span><span class="s1">thisPaths.push(</span><span class="s3">\n          </span><span class="s1">superParentPath.get(</span><span class="s3">\&quot;</span><span class="s1">arguments.0</span><span class="s3">\&quot;</span><span class="s1">) as NodePath&lt;t.ThisExpression&gt;,</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">} else if (isAssignment) {</span><span class="s3">\n        </span><span class="s1">// Replace not only the super.prop, but the whole assignment</span><span class="s3">\n        </span><span class="s1">superParentPath.replaceWith(call);</span><span class="s3">\n      </span><span class="s1">} else if (isTaggedTemplate) {</span><span class="s3">\n        </span><span class="s1">superProp.replaceWith(</span><span class="s3">\n          </span><span class="s1">callExpression(memberExpression(call, identifier(</span><span class="s3">\&quot;</span><span class="s1">bind</span><span class="s3">\&quot;</span><span class="s1">), false), [</span><span class="s3">\n            </span><span class="s1">thisExpression(),</span><span class="s3">\n          </span><span class="s1">]),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n\n        </span><span class="s1">thisPaths.push(</span><span class="s3">\n          </span><span class="s1">superProp.get(</span><span class="s3">\&quot;</span><span class="s1">arguments.0</span><span class="s3">\&quot;</span><span class="s1">) as NodePath&lt;t.ThisExpression&gt;,</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">superProp.replaceWith(call);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Convert all </span><span class="s3">\&quot;</span><span class="s1">this</span><span class="s3">\&quot; </span><span class="s1">references in the arrow to point at the alias.</span><span class="s3">\n  </span><span class="s1">let thisBinding: string | null;</span><span class="s3">\n  </span><span class="s1">if (thisPaths.length &gt; 0 || !noNewArrows) {</span><span class="s3">\n    </span><span class="s1">thisBinding = getThisBinding(thisEnvFn, inConstructor);</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">noNewArrows ||</span><span class="s3">\n      </span><span class="s1">// In subclass constructors, still need to rewrite because </span><span class="s3">\&quot;</span><span class="s1">this</span><span class="s3">\&quot; </span><span class="s1">can't be bound in spec mode</span><span class="s3">\n      </span><span class="s1">// because it might not have been initialized yet.</span><span class="s3">\n      </span><span class="s1">(inConstructor &amp;&amp; hasSuperClass(thisEnvFn))</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">thisPaths.forEach(thisChild =&gt; {</span><span class="s3">\n        </span><span class="s1">const thisRef = thisChild.isJSX()</span><span class="s3">\n          </span><span class="s1">? jsxIdentifier(thisBinding)</span><span class="s3">\n          </span><span class="s1">: identifier(thisBinding);</span><span class="s3">\n\n        </span><span class="s1">thisRef.loc = thisChild.node.loc;</span><span class="s3">\n        </span><span class="s1">thisChild.replaceWith(thisRef);</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n\n      </span><span class="s1">if (!noNewArrows) thisBinding = null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return { thisBinding, fnPath };</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type LogicalOp = Parameters&lt;typeof logicalExpression&gt;[0];</span><span class="s3">\n</span><span class="s1">type BinaryOp = Parameters&lt;typeof binaryExpression&gt;[0];</span><span class="s3">\n\n</span><span class="s1">function isLogicalOp(op: string): op is LogicalOp {</span><span class="s3">\n  </span><span class="s1">return LOGICAL_OPERATORS.includes(op);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function standardizeSuperProperty(</span><span class="s3">\n  </span><span class="s1">superProp: NodePath&lt;t.MemberExpression&gt;,</span><span class="s3">\n</span><span class="s1">):</span><span class="s3">\n  </span><span class="s1">| [NodePath&lt;t.MemberExpression&gt;]</span><span class="s3">\n  </span><span class="s1">| [NodePath&lt;t.MemberExpression&gt;, NodePath&lt;t.MemberExpression&gt;] {</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">superProp.parentPath.isAssignmentExpression() &amp;&amp;</span><span class="s3">\n    </span><span class="s1">superProp.parentPath.node.operator !== </span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">const assignmentPath = superProp.parentPath;</span><span class="s3">\n\n    </span><span class="s1">const op = assignmentPath.node.operator.slice(0, -1) as</span><span class="s3">\n      </span><span class="s1">| LogicalOp</span><span class="s3">\n      </span><span class="s1">| BinaryOp;</span><span class="s3">\n\n    </span><span class="s1">const value = assignmentPath.node.right;</span><span class="s3">\n\n    </span><span class="s1">const isLogicalAssignment = isLogicalOp(op);</span><span class="s3">\n\n    </span><span class="s1">if (superProp.node.computed) {</span><span class="s3">\n      </span><span class="s1">// from: super[foo] **= 4;</span><span class="s3">\n      </span><span class="s1">// to:   super[tmp = foo] = super[tmp] ** 4;</span><span class="s3">\n\n      </span><span class="s1">// from: super[foo] ??= 4;</span><span class="s3">\n      </span><span class="s1">// to:   super[tmp = foo] ?? super[tmp] = 4;</span><span class="s3">\n\n      </span><span class="s1">const tmp = superProp.scope.generateDeclaredUidIdentifier(</span><span class="s3">\&quot;</span><span class="s1">tmp</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n      </span><span class="s1">const object = superProp.node.object;</span><span class="s3">\n      </span><span class="s1">const property = superProp.node.property as t.Expression;</span><span class="s3">\n\n      </span><span class="s1">assignmentPath</span><span class="s3">\n        </span><span class="s1">.get(</span><span class="s3">\&quot;</span><span class="s1">left</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">.replaceWith(</span><span class="s3">\n          </span><span class="s1">memberExpression(</span><span class="s3">\n            </span><span class="s1">object,</span><span class="s3">\n            </span><span class="s1">assignmentExpression(</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">, tmp, property),</span><span class="s3">\n            </span><span class="s1">true /* computed */,</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n\n      </span><span class="s1">assignmentPath</span><span class="s3">\n        </span><span class="s1">.get(</span><span class="s3">\&quot;</span><span class="s1">right</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">.replaceWith(</span><span class="s3">\n          </span><span class="s1">rightExpression(</span><span class="s3">\n            </span><span class="s1">isLogicalAssignment ? </span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot; </span><span class="s1">: op,</span><span class="s3">\n            </span><span class="s1">memberExpression(object, identifier(tmp.name), true /* computed */),</span><span class="s3">\n            </span><span class="s1">value,</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// from: super.foo **= 4;</span><span class="s3">\n      </span><span class="s1">// to:   super.foo = super.foo ** 4;</span><span class="s3">\n\n      </span><span class="s1">// from: super.foo ??= 4;</span><span class="s3">\n      </span><span class="s1">// to:   super.foo ?? super.foo = 4;</span><span class="s3">\n\n      </span><span class="s1">const object = superProp.node.object;</span><span class="s3">\n      </span><span class="s1">const property = superProp.node.property as t.Identifier;</span><span class="s3">\n\n      </span><span class="s1">assignmentPath</span><span class="s3">\n        </span><span class="s1">.get(</span><span class="s3">\&quot;</span><span class="s1">left</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">.replaceWith(memberExpression(object, property));</span><span class="s3">\n\n      </span><span class="s1">assignmentPath</span><span class="s3">\n        </span><span class="s1">.get(</span><span class="s3">\&quot;</span><span class="s1">right</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">.replaceWith(</span><span class="s3">\n          </span><span class="s1">rightExpression(</span><span class="s3">\n            </span><span class="s1">isLogicalAssignment ? </span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot; </span><span class="s1">: op,</span><span class="s3">\n            </span><span class="s1">memberExpression(object, identifier(property.name)),</span><span class="s3">\n            </span><span class="s1">value,</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (isLogicalAssignment) {</span><span class="s3">\n      </span><span class="s1">assignmentPath.replaceWith(</span><span class="s3">\n        </span><span class="s1">logicalExpression(</span><span class="s3">\n          </span><span class="s1">op,</span><span class="s3">\n          </span><span class="s1">assignmentPath.node.left as t.MemberExpression,</span><span class="s3">\n          </span><span class="s1">assignmentPath.node.right,</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">assignmentPath.node.operator = </span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return [</span><span class="s3">\n      </span><span class="s1">assignmentPath.get(</span><span class="s3">\&quot;</span><span class="s1">left</span><span class="s3">\&quot;</span><span class="s1">) as NodePath&lt;t.MemberExpression&gt;,</span><span class="s3">\n      </span><span class="s1">assignmentPath.get(</span><span class="s3">\&quot;</span><span class="s1">right</span><span class="s3">\&quot;</span><span class="s1">).get(</span><span class="s3">\&quot;</span><span class="s1">left</span><span class="s3">\&quot;</span><span class="s1">) as NodePath&lt;t.MemberExpression&gt;,</span><span class="s3">\n    </span><span class="s1">];</span><span class="s3">\n  </span><span class="s1">} else if (superProp.parentPath.isUpdateExpression()) {</span><span class="s3">\n    </span><span class="s1">const updateExpr = superProp.parentPath;</span><span class="s3">\n\n    </span><span class="s1">const tmp = superProp.scope.generateDeclaredUidIdentifier(</span><span class="s3">\&quot;</span><span class="s1">tmp</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">const computedKey = superProp.node.computed</span><span class="s3">\n      </span><span class="s1">? superProp.scope.generateDeclaredUidIdentifier(</span><span class="s3">\&quot;</span><span class="s1">prop</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">: null;</span><span class="s3">\n\n    </span><span class="s1">const parts: t.Expression[] = [</span><span class="s3">\n      </span><span class="s1">assignmentExpression(</span><span class="s3">\n        \&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">tmp,</span><span class="s3">\n        </span><span class="s1">memberExpression(</span><span class="s3">\n          </span><span class="s1">superProp.node.object,</span><span class="s3">\n          </span><span class="s1">computedKey</span><span class="s3">\n            </span><span class="s1">? assignmentExpression(</span><span class="s3">\n                \&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                </span><span class="s1">computedKey,</span><span class="s3">\n                </span><span class="s1">superProp.node.property as t.Expression,</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">: superProp.node.property,</span><span class="s3">\n          </span><span class="s1">superProp.node.computed,</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">assignmentExpression(</span><span class="s3">\n        \&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">memberExpression(</span><span class="s3">\n          </span><span class="s1">superProp.node.object,</span><span class="s3">\n          </span><span class="s1">computedKey ? identifier(computedKey.name) : superProp.node.property,</span><span class="s3">\n          </span><span class="s1">superProp.node.computed,</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">binaryExpression(</span><span class="s3">\n          </span><span class="s1">// map `++` to `+`, and `--` to `-`</span><span class="s3">\n          </span><span class="s1">superProp.parentPath.node.operator[0] as </span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">-</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n          </span><span class="s1">identifier(tmp.name),</span><span class="s3">\n          </span><span class="s1">numericLiteral(1),</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">];</span><span class="s3">\n\n    </span><span class="s1">if (!superProp.parentPath.node.prefix) {</span><span class="s3">\n      </span><span class="s1">parts.push(identifier(tmp.name));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">updateExpr.replaceWith(sequenceExpression(parts));</span><span class="s3">\n\n    </span><span class="s1">const left = updateExpr.get(</span><span class="s3">\n      \&quot;</span><span class="s1">expressions.0.right</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">) as NodePath&lt;t.MemberExpression&gt;;</span><span class="s3">\n    </span><span class="s1">const right = updateExpr.get(</span><span class="s3">\n      \&quot;</span><span class="s1">expressions.1.left</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">) as NodePath&lt;t.MemberExpression&gt;;</span><span class="s3">\n    </span><span class="s1">return [left, right];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return [superProp];</span><span class="s3">\n\n  </span><span class="s1">function rightExpression(</span><span class="s3">\n    </span><span class="s1">op: BinaryOp | </span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">left: t.MemberExpression,</span><span class="s3">\n    </span><span class="s1">right: t.Expression,</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">if (op === </span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return assignmentExpression(</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">, left, right);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">return binaryExpression(op, left, right);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function hasSuperClass(thisEnvFn: NodePath&lt;t.Function&gt;) {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">thisEnvFn.isClassMethod() &amp;&amp;</span><span class="s3">\n    </span><span class="s1">!!(thisEnvFn.parentPath.parentPath.node as t.Class).superClass</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const assignSuperThisVisitor = environmentVisitor&lt;{</span><span class="s3">\n  </span><span class="s1">supers: WeakSet&lt;t.CallExpression&gt;;</span><span class="s3">\n  </span><span class="s1">thisBinding: string;</span><span class="s3">\n</span><span class="s1">}&gt;({</span><span class="s3">\n  </span><span class="s1">CallExpression(child, { supers, thisBinding }) {</span><span class="s3">\n    </span><span class="s1">if (!child.get(</span><span class="s3">\&quot;</span><span class="s1">callee</span><span class="s3">\&quot;</span><span class="s1">).isSuper()) return;</span><span class="s3">\n    </span><span class="s1">if (supers.has(child.node)) return;</span><span class="s3">\n    </span><span class="s1">supers.add(child.node);</span><span class="s3">\n\n    </span><span class="s1">child.replaceWithMultiple([</span><span class="s3">\n      </span><span class="s1">child.node,</span><span class="s3">\n      </span><span class="s1">assignmentExpression(</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">, identifier(thisBinding), identifier(</span><span class="s3">\&quot;</span><span class="s1">this</span><span class="s3">\&quot;</span><span class="s1">)),</span><span class="s3">\n    </span><span class="s1">]);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">// Create a binding that evaluates to the </span><span class="s3">\&quot;</span><span class="s1">this</span><span class="s3">\&quot; </span><span class="s1">of the given function.</span><span class="s3">\n</span><span class="s1">function getThisBinding(</span><span class="s3">\n  </span><span class="s1">thisEnvFn: NodePath&lt;t.Function&gt;,</span><span class="s3">\n  </span><span class="s1">inConstructor: boolean,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">return getBinding(thisEnvFn, </span><span class="s3">\&quot;</span><span class="s1">this</span><span class="s3">\&quot;</span><span class="s1">, thisBinding =&gt; {</span><span class="s3">\n    </span><span class="s1">if (!inConstructor || !hasSuperClass(thisEnvFn)) return thisExpression();</span><span class="s3">\n\n    </span><span class="s1">thisEnvFn.traverse(assignSuperThisVisitor, {</span><span class="s3">\n      </span><span class="s1">supers: new WeakSet(),</span><span class="s3">\n      </span><span class="s1">thisBinding,</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Create a binding for a function that will call </span><span class="s3">\&quot;</span><span class="s1">super()</span><span class="s3">\&quot; </span><span class="s1">with arguments passed through.</span><span class="s3">\n</span><span class="s1">function getSuperBinding(thisEnvFn: NodePath&lt;t.Function&gt;) {</span><span class="s3">\n  </span><span class="s1">return getBinding(thisEnvFn, </span><span class="s3">\&quot;</span><span class="s1">supercall</span><span class="s3">\&quot;</span><span class="s1">, () =&gt; {</span><span class="s3">\n    </span><span class="s1">const argsBinding = thisEnvFn.scope.generateUidIdentifier(</span><span class="s3">\&quot;</span><span class="s1">args</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">return arrowFunctionExpression(</span><span class="s3">\n      </span><span class="s1">[restElement(argsBinding)],</span><span class="s3">\n      </span><span class="s1">callExpression(_super(), [spreadElement(identifier(argsBinding.name))]),</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Create a binding for a function that will call </span><span class="s3">\&quot;</span><span class="s1">super.foo</span><span class="s3">\&quot; </span><span class="s1">or </span><span class="s3">\&quot;</span><span class="s1">super[foo]</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\n</span><span class="s1">function getSuperPropBinding(</span><span class="s3">\n  </span><span class="s1">thisEnvFn: NodePath&lt;t.Function&gt;,</span><span class="s3">\n  </span><span class="s1">isAssignment: boolean,</span><span class="s3">\n  </span><span class="s1">propName: string,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const op = isAssignment ? </span><span class="s3">\&quot;</span><span class="s1">set</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">get</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n  </span><span class="s1">return getBinding(thisEnvFn, `superprop_${op}:${propName || </span><span class="s3">\&quot;\&quot;</span><span class="s1">}`, () =&gt; {</span><span class="s3">\n    </span><span class="s1">const argsList = [];</span><span class="s3">\n\n    </span><span class="s1">let fnBody;</span><span class="s3">\n    </span><span class="s1">if (propName) {</span><span class="s3">\n      </span><span class="s1">// () =&gt; super.foo</span><span class="s3">\n      </span><span class="s1">fnBody = memberExpression(_super(), identifier(propName));</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">const method = thisEnvFn.scope.generateUidIdentifier(</span><span class="s3">\&quot;</span><span class="s1">prop</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">// (method) =&gt; super[method]</span><span class="s3">\n      </span><span class="s1">argsList.unshift(method);</span><span class="s3">\n      </span><span class="s1">fnBody = memberExpression(</span><span class="s3">\n        </span><span class="s1">_super(),</span><span class="s3">\n        </span><span class="s1">identifier(method.name),</span><span class="s3">\n        </span><span class="s1">true /* computed */,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (isAssignment) {</span><span class="s3">\n      </span><span class="s1">const valueIdent = thisEnvFn.scope.generateUidIdentifier(</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">argsList.push(valueIdent);</span><span class="s3">\n\n      </span><span class="s1">fnBody = assignmentExpression(</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">, fnBody, identifier(valueIdent.name));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return arrowFunctionExpression(argsList, fnBody);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function getBinding(</span><span class="s3">\n  </span><span class="s1">thisEnvFn: NodePath,</span><span class="s3">\n  </span><span class="s1">key: string,</span><span class="s3">\n  </span><span class="s1">init: (name: string) =&gt; t.Expression,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const cacheKey = </span><span class="s3">\&quot;</span><span class="s1">binding:</span><span class="s3">\&quot; </span><span class="s1">+ key;</span><span class="s3">\n  </span><span class="s1">let data: string | undefined = thisEnvFn.getData(cacheKey);</span><span class="s3">\n  </span><span class="s1">if (!data) {</span><span class="s3">\n    </span><span class="s1">const id = thisEnvFn.scope.generateUidIdentifier(key);</span><span class="s3">\n    </span><span class="s1">data = id.name;</span><span class="s3">\n    </span><span class="s1">thisEnvFn.setData(cacheKey, data);</span><span class="s3">\n\n    </span><span class="s1">thisEnvFn.scope.push({</span><span class="s3">\n      </span><span class="s1">id: id,</span><span class="s3">\n      </span><span class="s1">init: init(data),</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return data;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type ScopeInfo = {</span><span class="s3">\n  </span><span class="s1">thisPaths: NodePath&lt;t.ThisExpression | t.JSXIdentifier&gt;[];</span><span class="s3">\n  </span><span class="s1">superCalls: NodePath&lt;t.CallExpression&gt;[];</span><span class="s3">\n  </span><span class="s1">superProps: NodePath&lt;t.MemberExpression&gt;[];</span><span class="s3">\n  </span><span class="s1">argumentsPaths: NodePath&lt;t.Identifier | t.JSXIdentifier&gt;[];</span><span class="s3">\n  </span><span class="s1">newTargetPaths: NodePath&lt;t.MetaProperty&gt;[];</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">const getScopeInformationVisitor = environmentVisitor&lt;ScopeInfo&gt;({</span><span class="s3">\n  </span><span class="s1">ThisExpression(child, { thisPaths }) {</span><span class="s3">\n    </span><span class="s1">thisPaths.push(child);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">JSXIdentifier(child, { thisPaths }) {</span><span class="s3">\n    </span><span class="s1">if (child.node.name !== </span><span class="s3">\&quot;</span><span class="s1">this</span><span class="s3">\&quot;</span><span class="s1">) return;</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">!child.parentPath.isJSXMemberExpression({ object: child.node }) &amp;&amp;</span><span class="s3">\n      </span><span class="s1">!child.parentPath.isJSXOpeningElement({ name: child.node })</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">thisPaths.push(child);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">CallExpression(child, { superCalls }) {</span><span class="s3">\n    </span><span class="s1">if (child.get(</span><span class="s3">\&quot;</span><span class="s1">callee</span><span class="s3">\&quot;</span><span class="s1">).isSuper()) superCalls.push(child);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">MemberExpression(child, { superProps }) {</span><span class="s3">\n    </span><span class="s1">if (child.get(</span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">).isSuper()) superProps.push(child);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">Identifier(child, { argumentsPaths }) {</span><span class="s3">\n    </span><span class="s1">if (!child.isReferencedIdentifier({ name: </span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot; </span><span class="s1">})) return;</span><span class="s3">\n\n    </span><span class="s1">let curr = child.scope;</span><span class="s3">\n    </span><span class="s1">do {</span><span class="s3">\n      </span><span class="s1">if (curr.hasOwnBinding(</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n        </span><span class="s1">curr.rename(</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (curr.path.isFunction() &amp;&amp; !curr.path.isArrowFunctionExpression()) {</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} while ((curr = curr.parent));</span><span class="s3">\n\n    </span><span class="s1">argumentsPaths.push(child);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">MetaProperty(child, { newTargetPaths }) {</span><span class="s3">\n    </span><span class="s1">if (!child.get(</span><span class="s3">\&quot;</span><span class="s1">meta</span><span class="s3">\&quot;</span><span class="s1">).isIdentifier({ name: </span><span class="s3">\&quot;</span><span class="s1">new</span><span class="s3">\&quot; </span><span class="s1">})) return;</span><span class="s3">\n    </span><span class="s1">if (!child.get(</span><span class="s3">\&quot;</span><span class="s1">property</span><span class="s3">\&quot;</span><span class="s1">).isIdentifier({ name: </span><span class="s3">\&quot;</span><span class="s1">target</span><span class="s3">\&quot; </span><span class="s1">})) return;</span><span class="s3">\n\n    </span><span class="s1">newTargetPaths.push(child);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">function getScopeInformation(fnPath: NodePath) {</span><span class="s3">\n  </span><span class="s1">const thisPaths: ScopeInfo[</span><span class="s3">\&quot;</span><span class="s1">thisPaths</span><span class="s3">\&quot;</span><span class="s1">] = [];</span><span class="s3">\n  </span><span class="s1">const argumentsPaths: ScopeInfo[</span><span class="s3">\&quot;</span><span class="s1">argumentsPaths</span><span class="s3">\&quot;</span><span class="s1">] = [];</span><span class="s3">\n  </span><span class="s1">const newTargetPaths: ScopeInfo[</span><span class="s3">\&quot;</span><span class="s1">newTargetPaths</span><span class="s3">\&quot;</span><span class="s1">] = [];</span><span class="s3">\n  </span><span class="s1">const superProps: ScopeInfo[</span><span class="s3">\&quot;</span><span class="s1">superProps</span><span class="s3">\&quot;</span><span class="s1">] = [];</span><span class="s3">\n  </span><span class="s1">const superCalls: ScopeInfo[</span><span class="s3">\&quot;</span><span class="s1">superCalls</span><span class="s3">\&quot;</span><span class="s1">] = [];</span><span class="s3">\n\n  </span><span class="s1">fnPath.traverse(getScopeInformationVisitor, {</span><span class="s3">\n    </span><span class="s1">thisPaths,</span><span class="s3">\n    </span><span class="s1">argumentsPaths,</span><span class="s3">\n    </span><span class="s1">newTargetPaths,</span><span class="s3">\n    </span><span class="s1">superProps,</span><span class="s3">\n    </span><span class="s1">superCalls,</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">thisPaths,</span><span class="s3">\n    </span><span class="s1">argumentsPaths,</span><span class="s3">\n    </span><span class="s1">newTargetPaths,</span><span class="s3">\n    </span><span class="s1">superProps,</span><span class="s3">\n    </span><span class="s1">superCalls,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function splitExportDeclaration(</span><span class="s3">\n  </span><span class="s1">this: NodePath&lt;t.ExportDefaultDeclaration | t.ExportNamedDeclaration&gt;,</span><span class="s3">\n</span><span class="s1">): NodePath&lt;t.Declaration&gt; {</span><span class="s3">\n  </span><span class="s1">if (!this.isExportDeclaration() || this.isExportAllDeclaration()) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">Only default and named export declarations can be split.</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (this.isExportNamedDeclaration() &amp;&amp; this.get(</span><span class="s3">\&quot;</span><span class="s1">specifiers</span><span class="s3">\&quot;</span><span class="s1">).length &gt; 0) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">It doesn't make sense to split exported specifiers.</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const declaration = this.get(</span><span class="s3">\&quot;</span><span class="s1">declaration</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n  </span><span class="s1">if (this.isExportDefaultDeclaration()) {</span><span class="s3">\n    </span><span class="s1">const standaloneDeclaration =</span><span class="s3">\n      </span><span class="s1">declaration.isFunctionDeclaration() || declaration.isClassDeclaration();</span><span class="s3">\n    </span><span class="s1">const exportExpr =</span><span class="s3">\n      </span><span class="s1">declaration.isFunctionExpression() || declaration.isClassExpression();</span><span class="s3">\n\n    </span><span class="s1">const scope = declaration.isScope()</span><span class="s3">\n      </span><span class="s1">? declaration.scope.parent</span><span class="s3">\n      </span><span class="s1">: declaration.scope;</span><span class="s3">\n\n    </span><span class="s1">// @ts-expect-error id is not defined in expressions other than function/class</span><span class="s3">\n    </span><span class="s1">let id = declaration.node.id;</span><span class="s3">\n    </span><span class="s1">let needBindingRegistration = false;</span><span class="s3">\n\n    </span><span class="s1">if (!id) {</span><span class="s3">\n      </span><span class="s1">needBindingRegistration = true;</span><span class="s3">\n\n      </span><span class="s1">id = scope.generateUidIdentifier(</span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n      </span><span class="s1">if (standaloneDeclaration || exportExpr) {</span><span class="s3">\n        </span><span class="s1">declaration.node.id = cloneNode(id);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (exportExpr &amp;&amp; scope.hasBinding(id.name)) {</span><span class="s3">\n      </span><span class="s1">needBindingRegistration = true;</span><span class="s3">\n\n      </span><span class="s1">id = scope.generateUidIdentifier(id.name);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const updatedDeclaration = standaloneDeclaration</span><span class="s3">\n      </span><span class="s1">? declaration.node</span><span class="s3">\n      </span><span class="s1">: variableDeclaration(</span><span class="s3">\&quot;</span><span class="s1">var</span><span class="s3">\&quot;</span><span class="s1">, [</span><span class="s3">\n          </span><span class="s1">variableDeclarator(</span><span class="s3">\n            </span><span class="s1">cloneNode(id),</span><span class="s3">\n            </span><span class="s1">// @ts-expect-error When `standaloneDeclaration` is false, declaration must not be a Function/ClassDeclaration</span><span class="s3">\n            </span><span class="s1">declaration.node,</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">]);</span><span class="s3">\n\n    </span><span class="s1">const updatedExportDeclaration = exportNamedDeclaration(null, [</span><span class="s3">\n      </span><span class="s1">exportSpecifier(cloneNode(id), identifier(</span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot;</span><span class="s1">)),</span><span class="s3">\n    </span><span class="s1">]);</span><span class="s3">\n\n    </span><span class="s1">this.insertAfter(updatedExportDeclaration);</span><span class="s3">\n    </span><span class="s1">this.replaceWith(updatedDeclaration);</span><span class="s3">\n\n    </span><span class="s1">if (needBindingRegistration) {</span><span class="s3">\n      </span><span class="s1">scope.registerDeclaration(this);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">} else if (this.get(</span><span class="s3">\&quot;</span><span class="s1">specifiers</span><span class="s3">\&quot;</span><span class="s1">).length &gt; 0) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">It doesn't make sense to split exported specifiers.</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const bindingIdentifiers = declaration.getOuterBindingIdentifiers();</span><span class="s3">\n\n  </span><span class="s1">const specifiers = Object.keys(bindingIdentifiers).map(name =&gt; {</span><span class="s3">\n    </span><span class="s1">return exportSpecifier(identifier(name), identifier(name));</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">const aliasDeclar = exportNamedDeclaration(null, specifiers);</span><span class="s3">\n\n  </span><span class="s1">this.insertAfter(aliasDeclar);</span><span class="s3">\n  </span><span class="s1">this.replaceWith(declaration.node);</span><span class="s3">\n  </span><span class="s1">return this;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const refersOuterBindingVisitor: Visitor&lt;{</span><span class="s3">\n  </span><span class="s1">needsRename: boolean;</span><span class="s3">\n  </span><span class="s1">name: string;</span><span class="s3">\n</span><span class="s1">}&gt; = {</span><span class="s3">\n  \&quot;</span><span class="s1">ReferencedIdentifier|BindingIdentifier</span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\n    </span><span class="s1">path: NodePath&lt;t.Identifier&gt;,</span><span class="s3">\n    </span><span class="s1">state,</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">// check if this node matches our function id</span><span class="s3">\n    </span><span class="s1">if (path.node.name !== state.name) return;</span><span class="s3">\n    </span><span class="s1">state.needsRename = true;</span><span class="s3">\n    </span><span class="s1">path.stop();</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">Scope(path, state) {</span><span class="s3">\n    </span><span class="s1">if (path.scope.hasOwnBinding(state.name)) {</span><span class="s3">\n      </span><span class="s1">path.skip();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export function ensureFunctionName&lt;</span><span class="s3">\n  </span><span class="s1">N extends t.FunctionExpression | t.ClassExpression,</span><span class="s3">\n</span><span class="s1">&gt;(this: NodePath&lt;N&gt;, supportUnicodeId: boolean): null | NodePath&lt;N&gt; {</span><span class="s3">\n  </span><span class="s1">if (this.node.id) return this;</span><span class="s3">\n\n  </span><span class="s1">const res = getFunctionName(this.node, this.parent);</span><span class="s3">\n  </span><span class="s1">if (res == null) return this;</span><span class="s3">\n  </span><span class="s1">let { name } = res;</span><span class="s3">\n\n  </span><span class="s1">if (!supportUnicodeId &amp;&amp; /[</span><span class="s3">\\</span><span class="s1">uD800-</span><span class="s3">\\</span><span class="s1">uDFFF]/.test(name)) {</span><span class="s3">\n    </span><span class="s1">return null;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (name.startsWith(</span><span class="s3">\&quot;</span><span class="s1">get </span><span class="s3">\&quot;</span><span class="s1">) || name.startsWith(</span><span class="s3">\&quot;</span><span class="s1">set </span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n    </span><span class="s1">// TODO: Remove this to support naming getters and setters</span><span class="s3">\n    </span><span class="s1">return null;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">name = toBindingIdentifierName(name.replace(/[/ ]/g, </span><span class="s3">\&quot;</span><span class="s1">_</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n  </span><span class="s1">const id = identifier(name);</span><span class="s3">\n  </span><span class="s1">inherits(id, res.originalNode);</span><span class="s3">\n\n  </span><span class="s1">const state = { needsRename: false, name };</span><span class="s3">\n\n  </span><span class="s1">// check to see if we have a local binding of the id we're setting inside of</span><span class="s3">\n  </span><span class="s1">// the function, this is important as there are caveats associated</span><span class="s3">\n\n  </span><span class="s1">const { scope } = this;</span><span class="s3">\n  </span><span class="s1">const binding = scope.getOwnBinding(name);</span><span class="s3">\n  </span><span class="s1">if (binding) {</span><span class="s3">\n    </span><span class="s1">if (binding.kind === </span><span class="s3">\&quot;</span><span class="s1">param</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">// safari will blow up in strict mode with code like:</span><span class="s3">\n      </span><span class="s1">//</span><span class="s3">\n      </span><span class="s1">//   let t = function t(t) {};</span><span class="s3">\n      </span><span class="s1">//</span><span class="s3">\n      </span><span class="s1">// with the error:</span><span class="s3">\n      </span><span class="s1">//</span><span class="s3">\n      </span><span class="s1">//   Cannot declare a parameter named 't' as it shadows the name of a</span><span class="s3">\n      </span><span class="s1">//   strict mode function.</span><span class="s3">\n      </span><span class="s1">//</span><span class="s3">\n      </span><span class="s1">// this isn't to the spec and they've invented this behaviour which is</span><span class="s3">\n      </span><span class="s1">// **extremely** annoying so we avoid setting the name if it has a param</span><span class="s3">\n      </span><span class="s1">// with the same id</span><span class="s3">\n      </span><span class="s1">state.needsRename = true;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// otherwise it's defined somewhere in scope like:</span><span class="s3">\n      </span><span class="s1">//</span><span class="s3">\n      </span><span class="s1">//   let t = function () {</span><span class="s3">\n      </span><span class="s1">//     let t = 2;</span><span class="s3">\n      </span><span class="s1">//   };</span><span class="s3">\n      </span><span class="s1">//</span><span class="s3">\n      </span><span class="s1">// so we can safely just set the id and move along as it shadows the</span><span class="s3">\n      </span><span class="s1">// bound function id</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else if (scope.parent.hasBinding(name) || scope.hasGlobal(name)) {</span><span class="s3">\n    </span><span class="s1">this.traverse(refersOuterBindingVisitor, state);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (!state.needsRename) {</span><span class="s3">\n    </span><span class="s1">this.node.id = id;</span><span class="s3">\n    </span><span class="s1">scope.getProgramParent().references[id.name] = true;</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (scope.hasBinding(id.name) &amp;&amp; !scope.hasGlobal(id.name)) {</span><span class="s3">\n    </span><span class="s1">// we can just munge the local binding</span><span class="s3">\n    </span><span class="s1">scope.rename(id.name);</span><span class="s3">\n    </span><span class="s1">this.node.id = id;</span><span class="s3">\n    </span><span class="s1">scope.getProgramParent().references[id.name] = true;</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// TODO: we don't currently support wrapping class expressions</span><span class="s3">\n  </span><span class="s1">if (!isFunction(this.node)) return null;</span><span class="s3">\n\n  </span><span class="s1">// need to add a wrapper since we can't change the references</span><span class="s3">\n\n  </span><span class="s1">const key = scope.generateUidIdentifier(id.name);</span><span class="s3">\n  </span><span class="s1">// shim in dummy params to retain function arity, if you try to read the</span><span class="s3">\n  </span><span class="s1">// source then you'll get the original since it's proxied so it's all good</span><span class="s3">\n  </span><span class="s1">const params = [];</span><span class="s3">\n  </span><span class="s1">for (let i = 0, len = getFunctionArity(this.node); i &lt; len; i++) {</span><span class="s3">\n    </span><span class="s1">params.push(scope.generateUidIdentifier(</span><span class="s3">\&quot;</span><span class="s1">x</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const call = template.expression.ast`</span><span class="s3">\n    </span><span class="s1">(function (${key}) {</span><span class="s3">\n      </span><span class="s1">function ${id}(${params}) {</span><span class="s3">\n        </span><span class="s1">return ${cloneNode(key)}.apply(this, arguments);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">${cloneNode(id)}.toString = function () {</span><span class="s3">\n        </span><span class="s1">return ${cloneNode(key)}.toString();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return ${cloneNode(id)};</span><span class="s3">\n    </span><span class="s1">})(${toExpression(this.node)})</span><span class="s3">\n  </span><span class="s1">` as t.CallExpression;</span><span class="s3">\n\n  </span><span class="s1">return this.replaceWith(call)[0].get(</span><span class="s3">\&quot;</span><span class="s1">arguments.0</span><span class="s3">\&quot;</span><span class="s1">) as NodePath&lt;N&gt;;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function getFunctionArity(node: t.Function): number {</span><span class="s3">\n  </span><span class="s1">const count = node.params.findIndex(</span><span class="s3">\n    </span><span class="s1">param =&gt; isAssignmentPattern(param) || isRestElement(param),</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">return count === -1 ? node.params.length : count;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[]}</span></pre>
</body>
</html>