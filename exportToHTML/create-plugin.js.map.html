<html>
<head>
<title>create-plugin.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
create-plugin.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_pluginSyntaxJsx&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;_helperPluginUtils&quot;</span><span class="s0">,</span><span class="s1">&quot;_core&quot;</span><span class="s0">,</span><span class="s1">&quot;_helperModuleImports&quot;</span><span class="s0">,</span><span class="s1">&quot;_helperAnnotateAsPure&quot;</span><span class="s0">,</span><span class="s1">&quot;DEFAULT&quot;</span><span class="s0">,</span><span class="s1">&quot;importSource&quot;</span><span class="s0">,</span><span class="s1">&quot;runtime&quot;</span><span class="s0">,</span><span class="s1">&quot;pragma&quot;</span><span class="s0">,</span><span class="s1">&quot;pragmaFrag&quot;</span><span class="s0">,</span><span class="s1">&quot;JSX_SOURCE_ANNOTATION_REGEX&quot;</span><span class="s0">,</span><span class="s1">&quot;JSX_RUNTIME_ANNOTATION_REGEX&quot;</span><span class="s0">,</span><span class="s1">&quot;JSX_ANNOTATION_REGEX&quot;</span><span class="s0">,</span><span class="s1">&quot;JSX_FRAG_ANNOTATION_REGEX&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;pass&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;v&quot;</span><span class="s0">,</span><span class="s1">&quot;hasProto&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;properties&quot;</span><span class="s0">,</span><span class="s1">&quot;some&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;t&quot;</span><span class="s0">,</span><span class="s1">&quot;isObjectProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;computed&quot;</span><span class="s0">,</span><span class="s1">&quot;shorthand&quot;</span><span class="s0">,</span><span class="s1">&quot;isIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;isStringLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;createPlugin&quot;</span><span class="s0">,</span><span class="s1">&quot;development&quot;</span><span class="s0">,</span><span class="s1">&quot;declare&quot;</span><span class="s0">,</span><span class="s1">&quot;_&quot;</span><span class="s0">,</span><span class="s1">&quot;options&quot;</span><span class="s0">,</span><span class="s1">&quot;pure&quot;</span><span class="s0">,</span><span class="s1">&quot;PURE_ANNOTATION&quot;</span><span class="s0">,</span><span class="s1">&quot;throwIfNamespace&quot;</span><span class="s0">,</span><span class="s1">&quot;filter&quot;</span><span class="s0">,</span><span class="s1">&quot;RUNTIME_DEFAULT&quot;</span><span class="s0">,</span><span class="s1">&quot;IMPORT_SOURCE_DEFAULT&quot;</span><span class="s0">,</span><span class="s1">&quot;PRAGMA_DEFAULT&quot;</span><span class="s0">,</span><span class="s1">&quot;PRAGMA_FRAG_DEFAULT&quot;</span><span class="s0">,</span><span class="s1">&quot;useSpread&quot;</span><span class="s0">,</span><span class="s1">&quot;useBuiltIns&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;injectMetaPropertiesVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;JSXOpeningElement&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;state&quot;</span><span class="s0">,</span><span class="s1">&quot;attributes&quot;</span><span class="s0">,</span><span class="s1">&quot;isThisAllowed&quot;</span><span class="s0">,</span><span class="s1">&quot;scope&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;jsxAttribute&quot;</span><span class="s0">,</span><span class="s1">&quot;jsxIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;jsxExpressionContainer&quot;</span><span class="s0">,</span><span class="s1">&quot;thisExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;makeSource&quot;</span><span class="s0">,</span><span class="s1">&quot;pushContainer&quot;</span><span class="s0">,</span><span class="s1">&quot;inherits&quot;</span><span class="s0">,</span><span class="s1">&quot;jsx&quot;</span><span class="s0">,</span><span class="s1">&quot;visitor&quot;</span><span class="s0">,</span><span class="s1">&quot;JSXNamespacedName&quot;</span><span class="s0">,</span><span class="s1">&quot;buildCodeFrameError&quot;</span><span class="s0">,</span><span class="s1">&quot;JSXSpreadChild&quot;</span><span class="s0">,</span><span class="s1">&quot;Program&quot;</span><span class="s0">,</span><span class="s1">&quot;enter&quot;</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">,</span><span class="s1">&quot;source&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceSet&quot;</span><span class="s0">,</span><span class="s1">&quot;pragmaSet&quot;</span><span class="s0">,</span><span class="s1">&quot;pragmaFragSet&quot;</span><span class="s0">,</span><span class="s1">&quot;ast&quot;</span><span class="s0">,</span><span class="s1">&quot;comments&quot;</span><span class="s0">,</span><span class="s1">&quot;comment&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;exec&quot;</span><span class="s0">,</span><span class="s1">&quot;runtimeMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;jsxMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;jsxFragMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;createElement&quot;</span><span class="s0">,</span><span class="s1">&quot;toMemberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;fragment&quot;</span><span class="s0">,</span><span class="s1">&quot;cloneNode&quot;</span><span class="s0">,</span><span class="s1">&quot;define&quot;</span><span class="s0">,</span><span class="s1">&quot;id&quot;</span><span class="s0">,</span><span class="s1">&quot;createImportLazily&quot;</span><span class="s0">,</span><span class="s1">&quot;traverse&quot;</span><span class="s0">,</span><span class="s1">&quot;JSXFragment&quot;</span><span class="s0">,</span><span class="s1">&quot;exit&quot;</span><span class="s0">,</span><span class="s1">&quot;callExpr&quot;</span><span class="s0">,</span><span class="s1">&quot;buildCreateElementFragmentCall&quot;</span><span class="s0">,</span><span class="s1">&quot;buildJSXFragmentCall&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceWith&quot;</span><span class="s0">,</span><span class="s1">&quot;JSXElement&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldUseCreateElement&quot;</span><span class="s0">,</span><span class="s1">&quot;buildCreateElementCall&quot;</span><span class="s0">,</span><span class="s1">&quot;buildJSXElementCall&quot;</span><span class="s0">,</span><span class="s1">&quot;JSXAttribute&quot;</span><span class="s0">,</span><span class="s1">&quot;isJSXElement&quot;</span><span class="s0">,</span><span class="s1">&quot;isDerivedClass&quot;</span><span class="s0">,</span><span class="s1">&quot;classPath&quot;</span><span class="s0">,</span><span class="s1">&quot;superClass&quot;</span><span class="s0">,</span><span class="s1">&quot;isFunctionParent&quot;</span><span class="s0">,</span><span class="s1">&quot;isArrowFunctionExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;kind&quot;</span><span class="s0">,</span><span class="s1">&quot;parentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;isTSModuleBlock&quot;</span><span class="s0">,</span><span class="s1">&quot;parent&quot;</span><span class="s0">,</span><span class="s1">&quot;call&quot;</span><span class="s0">,</span><span class="s1">&quot;args&quot;</span><span class="s0">,</span><span class="s1">&quot;callExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;annotateAsPure&quot;</span><span class="s0">,</span><span class="s1">&quot;openingPath&quot;</span><span class="s0">,</span><span class="s1">&quot;seenPropsSpread&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;attr&quot;</span><span class="s0">,</span><span class="s1">&quot;isJSXAttribute&quot;</span><span class="s0">,</span><span class="s1">&quot;isJSXSpreadAttribute&quot;</span><span class="s0">,</span><span class="s1">&quot;convertJSXIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;isJSXIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;isReferenced&quot;</span><span class="s0">,</span><span class="s1">&quot;isValidIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;stringLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;isJSXMemberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;memberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;object&quot;</span><span class="s0">,</span><span class="s1">&quot;property&quot;</span><span class="s0">,</span><span class="s1">&quot;isJSXNamespacedName&quot;</span><span class="s0">,</span><span class="s1">&quot;namespace&quot;</span><span class="s0">,</span><span class="s1">&quot;convertAttributeValue&quot;</span><span class="s0">,</span><span class="s1">&quot;isJSXExpressionContainer&quot;</span><span class="s0">,</span><span class="s1">&quot;expression&quot;</span><span class="s0">,</span><span class="s1">&quot;accumulateAttribute&quot;</span><span class="s0">,</span><span class="s1">&quot;array&quot;</span><span class="s0">,</span><span class="s1">&quot;attribute&quot;</span><span class="s0">,</span><span class="s1">&quot;arg&quot;</span><span class="s0">,</span><span class="s1">&quot;argument&quot;</span><span class="s0">,</span><span class="s1">&quot;isObjectExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;spreadElement&quot;</span><span class="s0">,</span><span class="s1">&quot;booleanLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;_value$extra&quot;</span><span class="s0">,</span><span class="s1">&quot;replace&quot;</span><span class="s0">,</span><span class="s1">&quot;extra&quot;</span><span class="s0">,</span><span class="s1">&quot;raw&quot;</span><span class="s0">,</span><span class="s1">&quot;objectProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;buildChildrenProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;children&quot;</span><span class="s0">,</span><span class="s1">&quot;childrenNode&quot;</span><span class="s0">,</span><span class="s1">&quot;arrayExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;identifier&quot;</span><span class="s0">,</span><span class="s1">&quot;getTag&quot;</span><span class="s0">,</span><span class="s1">&quot;attribsArray&quot;</span><span class="s0">,</span><span class="s1">&quot;extracted&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;create&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceSelfError&quot;</span><span class="s0">,</span><span class="s1">&quot;keyValue&quot;</span><span class="s0">,</span><span class="s1">&quot;react&quot;</span><span class="s0">,</span><span class="s1">&quot;buildChildren&quot;</span><span class="s0">,</span><span class="s1">&quot;attribs&quot;</span><span class="s0">,</span><span class="s1">&quot;buildJSXOpeningElementAttributes&quot;</span><span class="s0">,</span><span class="s1">&quot;objectExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;_extracted$key&quot;</span><span class="s0">,</span><span class="s1">&quot;buildUndefinedNode&quot;</span><span class="s0">,</span><span class="s1">&quot;__source&quot;</span><span class="s0">,</span><span class="s1">&quot;__self&quot;</span><span class="s0">,</span><span class="s1">&quot;props&quot;</span><span class="s0">,</span><span class="s1">&quot;reduce&quot;</span><span class="s0">,</span><span class="s1">&quot;nullLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;buildCreateElementOpeningElementAttributes&quot;</span><span class="s0">,</span><span class="s1">&quot;tagExpr&quot;</span><span class="s0">,</span><span class="s1">&quot;tagName&quot;</span><span class="s0">,</span><span class="s1">&quot;isCompatTag&quot;</span><span class="s0">,</span><span class="s1">&quot;objs&quot;</span><span class="s0">,</span><span class="s1">&quot;start&quot;</span><span class="s0">,</span><span class="s1">&quot;forEach&quot;</span><span class="s0">,</span><span class="s1">&quot;prop&quot;</span><span class="s0">,</span><span class="s1">&quot;isSpreadElement&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;unshift&quot;</span><span class="s0">,</span><span class="s1">&quot;helper&quot;</span><span class="s0">,</span><span class="s1">&quot;addHelper&quot;</span><span class="s0">,</span><span class="s1">&quot;found&quot;</span><span class="s0">,</span><span class="s1">&quot;getSource&quot;</span><span class="s0">,</span><span class="s1">&quot;importName&quot;</span><span class="s0">,</span><span class="s1">&quot;actualSource&quot;</span><span class="s0">,</span><span class="s1">&quot;isModule&quot;</span><span class="s0">,</span><span class="s1">&quot;reference&quot;</span><span class="s0">,</span><span class="s1">&quot;addNamed&quot;</span><span class="s0">,</span><span class="s1">&quot;importedInterop&quot;</span><span class="s0">,</span><span class="s1">&quot;importPosition&quot;</span><span class="s0">,</span><span class="s1">&quot;addNamespace&quot;</span><span class="s0">,</span><span class="s1">&quot;split&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;location&quot;</span><span class="s0">,</span><span class="s1">&quot;loc&quot;</span><span class="s0">,</span><span class="s1">&quot;fileNameIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;filename&quot;</span><span class="s0">,</span><span class="s1">&quot;generateUidIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;getProgramParent&quot;</span><span class="s0">,</span><span class="s1">&quot;init&quot;</span><span class="s0">,</span><span class="s1">&quot;makeTrace&quot;</span><span class="s0">,</span><span class="s1">&quot;line&quot;</span><span class="s0">,</span><span class="s1">&quot;column&quot;</span><span class="s0">,</span><span class="s1">&quot;lineNumber&quot;</span><span class="s0">,</span><span class="s1">&quot;column0Based&quot;</span><span class="s0">,</span><span class="s1">&quot;fileLineLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;numericLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;fileColumnLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;template&quot;</span><span class="s0">,</span><span class="s1">&quot;pluginName&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../src/create-plugin.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import jsx from </span><span class="s3">\&quot;</span><span class="s1">@babel/plugin-syntax-jsx</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { declare } from </span><span class="s3">\&quot;</span><span class="s1">@babel/helper-plugin-utils</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { template, types as t } from </span><span class="s3">\&quot;</span><span class="s1">@babel/core</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { PluginPass, NodePath, Scope, Visitor } from </span><span class="s3">\&quot;</span><span class="s1">@babel/core</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { addNamed, addNamespace, isModule } from </span><span class="s3">\&quot;</span><span class="s1">@babel/helper-module-imports</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import annotateAsPure from </span><span class="s3">\&quot;</span><span class="s1">@babel/helper-annotate-as-pure</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">CallExpression,</span><span class="s3">\n  </span><span class="s1">Class,</span><span class="s3">\n  </span><span class="s1">Expression,</span><span class="s3">\n  </span><span class="s1">Identifier,</span><span class="s3">\n  </span><span class="s1">JSXAttribute,</span><span class="s3">\n  </span><span class="s1">JSXElement,</span><span class="s3">\n  </span><span class="s1">JSXFragment,</span><span class="s3">\n  </span><span class="s1">JSXOpeningElement,</span><span class="s3">\n  </span><span class="s1">JSXSpreadAttribute,</span><span class="s3">\n  </span><span class="s1">MemberExpression,</span><span class="s3">\n  </span><span class="s1">ObjectExpression,</span><span class="s3">\n  </span><span class="s1">Program,</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">@babel/types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">const DEFAULT = {</span><span class="s3">\n  </span><span class="s1">importSource: </span><span class="s3">\&quot;</span><span class="s1">react</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">runtime: </span><span class="s3">\&quot;</span><span class="s1">automatic</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">pragma: </span><span class="s3">\&quot;</span><span class="s1">React.createElement</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">pragmaFrag: </span><span class="s3">\&quot;</span><span class="s1">React.Fragment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">const JSX_SOURCE_ANNOTATION_REGEX =</span><span class="s3">\n  </span><span class="s1">/^</span><span class="s3">\\</span><span class="s1">s*(?:</span><span class="s3">\\</span><span class="s1">*</span><span class="s3">\\</span><span class="s1">s*)?@jsxImportSource</span><span class="s3">\\</span><span class="s1">s+(</span><span class="s3">\\</span><span class="s1">S+)</span><span class="s3">\\</span><span class="s1">s*$/m;</span><span class="s3">\n</span><span class="s1">const JSX_RUNTIME_ANNOTATION_REGEX = /^</span><span class="s3">\\</span><span class="s1">s*(?:</span><span class="s3">\\</span><span class="s1">*</span><span class="s3">\\</span><span class="s1">s*)?@jsxRuntime</span><span class="s3">\\</span><span class="s1">s+(</span><span class="s3">\\</span><span class="s1">S+)</span><span class="s3">\\</span><span class="s1">s*$/m;</span><span class="s3">\n\n</span><span class="s1">const JSX_ANNOTATION_REGEX = /^</span><span class="s3">\\</span><span class="s1">s*(?:</span><span class="s3">\\</span><span class="s1">*</span><span class="s3">\\</span><span class="s1">s*)?@jsx</span><span class="s3">\\</span><span class="s1">s+(</span><span class="s3">\\</span><span class="s1">S+)</span><span class="s3">\\</span><span class="s1">s*$/m;</span><span class="s3">\n</span><span class="s1">const JSX_FRAG_ANNOTATION_REGEX = /^</span><span class="s3">\\</span><span class="s1">s*(?:</span><span class="s3">\\</span><span class="s1">*</span><span class="s3">\\</span><span class="s1">s*)?@jsxFrag</span><span class="s3">\\</span><span class="s1">s+(</span><span class="s3">\\</span><span class="s1">S+)</span><span class="s3">\\</span><span class="s1">s*$/m;</span><span class="s3">\n\n</span><span class="s1">const get = (pass: PluginPass, name: string) =&gt;</span><span class="s3">\n  </span><span class="s1">pass.get(`@babel/plugin-react-jsx/${name}`);</span><span class="s3">\n</span><span class="s1">const set = (pass: PluginPass, name: string, v: any) =&gt;</span><span class="s3">\n  </span><span class="s1">pass.set(`@babel/plugin-react-jsx/${name}`, v);</span><span class="s3">\n\n</span><span class="s1">function hasProto(node: t.ObjectExpression) {</span><span class="s3">\n  </span><span class="s1">return node.properties.some(</span><span class="s3">\n    </span><span class="s1">value =&gt;</span><span class="s3">\n      </span><span class="s1">t.isObjectProperty(value, { computed: false, shorthand: false }) &amp;&amp;</span><span class="s3">\n      </span><span class="s1">(t.isIdentifier(value.key, { name: </span><span class="s3">\&quot;</span><span class="s1">__proto__</span><span class="s3">\&quot; </span><span class="s1">}) ||</span><span class="s3">\n        </span><span class="s1">t.isStringLiteral(value.key, { value: </span><span class="s3">\&quot;</span><span class="s1">__proto__</span><span class="s3">\&quot; </span><span class="s1">})),</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface Options {</span><span class="s3">\n  </span><span class="s1">filter?: (node: t.Node, pass: PluginPass) =&gt; boolean;</span><span class="s3">\n  </span><span class="s1">importSource?: string;</span><span class="s3">\n  </span><span class="s1">pragma?: string;</span><span class="s3">\n  </span><span class="s1">pragmaFrag?: string;</span><span class="s3">\n  </span><span class="s1">pure?: string;</span><span class="s3">\n  </span><span class="s1">runtime?: </span><span class="s3">\&quot;</span><span class="s1">automatic</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">classic</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">throwIfNamespace?: boolean;</span><span class="s3">\n  </span><span class="s1">useBuiltIns: boolean;</span><span class="s3">\n  </span><span class="s1">useSpread?: boolean;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export default function createPlugin({</span><span class="s3">\n  </span><span class="s1">name,</span><span class="s3">\n  </span><span class="s1">development,</span><span class="s3">\n</span><span class="s1">}: {</span><span class="s3">\n  </span><span class="s1">name: string;</span><span class="s3">\n  </span><span class="s1">development: boolean;</span><span class="s3">\n</span><span class="s1">}) {</span><span class="s3">\n  </span><span class="s1">return declare((_, options: Options) =&gt; {</span><span class="s3">\n    </span><span class="s1">const {</span><span class="s3">\n      </span><span class="s1">pure: PURE_ANNOTATION,</span><span class="s3">\n\n      </span><span class="s1">throwIfNamespace = true,</span><span class="s3">\n\n      </span><span class="s1">filter,</span><span class="s3">\n\n      </span><span class="s1">runtime: RUNTIME_DEFAULT = process.env.BABEL_8_BREAKING</span><span class="s3">\n        </span><span class="s1">? </span><span class="s3">\&quot;</span><span class="s1">automatic</span><span class="s3">\&quot;\n        </span><span class="s1">: development</span><span class="s3">\n          </span><span class="s1">? </span><span class="s3">\&quot;</span><span class="s1">automatic</span><span class="s3">\&quot;\n          </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">classic</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n\n      </span><span class="s1">importSource: IMPORT_SOURCE_DEFAULT = DEFAULT.importSource,</span><span class="s3">\n      </span><span class="s1">pragma: PRAGMA_DEFAULT = DEFAULT.pragma,</span><span class="s3">\n      </span><span class="s1">pragmaFrag: PRAGMA_FRAG_DEFAULT = DEFAULT.pragmaFrag,</span><span class="s3">\n    </span><span class="s1">} = options;</span><span class="s3">\n\n    </span><span class="s1">if (process.env.BABEL_8_BREAKING) {</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\&quot;</span><span class="s1">useSpread</span><span class="s3">\&quot; </span><span class="s1">in options) {</span><span class="s3">\n        </span><span class="s1">throw new Error(</span><span class="s3">\n          </span><span class="s1">'@babel/plugin-transform-react-jsx: Since Babel 8, an inline object with spread elements is always used, and the </span><span class="s3">\&quot;</span><span class="s1">useSpread</span><span class="s3">\&quot; </span><span class="s1">option is no longer available. Please remove it from your config.',</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (</span><span class="s3">\&quot;</span><span class="s1">useBuiltIns</span><span class="s3">\&quot; </span><span class="s1">in options) {</span><span class="s3">\n        </span><span class="s1">const useBuiltInsFormatted = JSON.stringify(options.useBuiltIns);</span><span class="s3">\n        </span><span class="s1">throw new Error(</span><span class="s3">\n          </span><span class="s1">`@babel/plugin-transform-react-jsx: Since </span><span class="s3">\&quot;</span><span class="s1">useBuiltIns</span><span class="s3">\&quot; </span><span class="s1">is removed in Babel 8, you can remove it from the config.</span><span class="s3">\n</span><span class="s1">- Babel 8 now transforms JSX spread to object spread. If you need to transpile object spread with</span><span class="s3">\n\\</span><span class="s1">`useBuiltIns: ${useBuiltInsFormatted}</span><span class="s3">\\</span><span class="s1">`, you can use the following config</span><span class="s3">\n</span><span class="s1">{</span><span class="s3">\n  \&quot;</span><span class="s1">plugins</span><span class="s3">\&quot;</span><span class="s1">: [</span><span class="s3">\n    \&quot;</span><span class="s1">@babel/plugin-transform-react-jsx</span><span class="s3">\&quot;\n    </span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">@babel/plugin-transform-object-rest-spread</span><span class="s3">\&quot;</span><span class="s1">, { </span><span class="s3">\&quot;</span><span class="s1">loose</span><span class="s3">\&quot;</span><span class="s1">: true, </span><span class="s3">\&quot;</span><span class="s1">useBuiltIns</span><span class="s3">\&quot;</span><span class="s1">: ${useBuiltInsFormatted} }]</span><span class="s3">\n  </span><span class="s1">]</span><span class="s3">\n</span><span class="s1">}`,</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (filter != null &amp;&amp; RUNTIME_DEFAULT === </span><span class="s3">\&quot;</span><span class="s1">automatic</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">throw new Error(</span><span class="s3">\n          </span><span class="s1">'@babel/plugin-transform-react-jsx: </span><span class="s3">\&quot;</span><span class="s1">filter</span><span class="s3">\&quot; </span><span class="s1">option can not be used with automatic runtime. If you are upgrading from Babel 7, please specify `runtime: </span><span class="s3">\&quot;</span><span class="s1">classic</span><span class="s3">\&quot;</span><span class="s1">`.',</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// eslint-disable-next-line no-var</span><span class="s3">\n      </span><span class="s1">var { useSpread = false, useBuiltIns = false } = options;</span><span class="s3">\n\n      </span><span class="s1">if (RUNTIME_DEFAULT === </span><span class="s3">\&quot;</span><span class="s1">classic</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">if (typeof useSpread !== </span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">throw new Error(</span><span class="s3">\n            \&quot;</span><span class="s1">transform-react-jsx currently only accepts a boolean option for </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n              \&quot;</span><span class="s1">useSpread (defaults to false)</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (typeof useBuiltIns !== </span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">throw new Error(</span><span class="s3">\n            \&quot;</span><span class="s1">transform-react-jsx currently only accepts a boolean option for </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n              \&quot;</span><span class="s1">useBuiltIns (defaults to false)</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (useSpread &amp;&amp; useBuiltIns) {</span><span class="s3">\n          </span><span class="s1">throw new Error(</span><span class="s3">\n            \&quot;</span><span class="s1">transform-react-jsx currently only accepts useBuiltIns or useSpread </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n              \&quot;</span><span class="s1">but not both</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const injectMetaPropertiesVisitor: Visitor&lt;PluginPass&gt; = {</span><span class="s3">\n      </span><span class="s1">JSXOpeningElement(path, state) {</span><span class="s3">\n        </span><span class="s1">const attributes = [];</span><span class="s3">\n        </span><span class="s1">if (isThisAllowed(path.scope)) {</span><span class="s3">\n          </span><span class="s1">attributes.push(</span><span class="s3">\n            </span><span class="s1">t.jsxAttribute(</span><span class="s3">\n              </span><span class="s1">t.jsxIdentifier(</span><span class="s3">\&quot;</span><span class="s1">__self</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n              </span><span class="s1">t.jsxExpressionContainer(t.thisExpression()),</span><span class="s3">\n            </span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">attributes.push(</span><span class="s3">\n          </span><span class="s1">t.jsxAttribute(</span><span class="s3">\n            </span><span class="s1">t.jsxIdentifier(</span><span class="s3">\&quot;</span><span class="s1">__source</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n            </span><span class="s1">t.jsxExpressionContainer(makeSource(path, state)),</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">path.pushContainer(</span><span class="s3">\&quot;</span><span class="s1">attributes</span><span class="s3">\&quot;</span><span class="s1">, attributes);</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">name,</span><span class="s3">\n      </span><span class="s1">inherits: jsx,</span><span class="s3">\n      </span><span class="s1">visitor: {</span><span class="s3">\n        </span><span class="s1">JSXNamespacedName(path) {</span><span class="s3">\n          </span><span class="s1">if (throwIfNamespace) {</span><span class="s3">\n            </span><span class="s1">throw path.buildCodeFrameError(</span><span class="s3">\n              </span><span class="s1">`Namespace tags are not supported by default. React's JSX doesn't support namespace tags. </span><span class="s3">\\\n</span><span class="s1">You can set </span><span class="s3">\\</span><span class="s1">`throwIfNamespace: false</span><span class="s3">\\</span><span class="s1">` to bypass this warning.`,</span><span class="s3">\n            </span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n\n        </span><span class="s1">JSXSpreadChild(path) {</span><span class="s3">\n          </span><span class="s1">throw path.buildCodeFrameError(</span><span class="s3">\n            \&quot;</span><span class="s1">Spread children are not supported in React.</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n\n        </span><span class="s1">Program: {</span><span class="s3">\n          </span><span class="s1">enter(path, state) {</span><span class="s3">\n            </span><span class="s1">const { file } = state;</span><span class="s3">\n            </span><span class="s1">let runtime: string = RUNTIME_DEFAULT;</span><span class="s3">\n\n            </span><span class="s1">let source: string = IMPORT_SOURCE_DEFAULT;</span><span class="s3">\n            </span><span class="s1">let pragma: string = PRAGMA_DEFAULT;</span><span class="s3">\n            </span><span class="s1">let pragmaFrag: string = PRAGMA_FRAG_DEFAULT;</span><span class="s3">\n\n            </span><span class="s1">let sourceSet = !!options.importSource;</span><span class="s3">\n            </span><span class="s1">let pragmaSet = !!options.pragma;</span><span class="s3">\n            </span><span class="s1">let pragmaFragSet = !!options.pragmaFrag;</span><span class="s3">\n\n            </span><span class="s1">if (file.ast.comments) {</span><span class="s3">\n              </span><span class="s1">for (const comment of file.ast.comments) {</span><span class="s3">\n                </span><span class="s1">const sourceMatches = JSX_SOURCE_ANNOTATION_REGEX.exec(</span><span class="s3">\n                  </span><span class="s1">comment.value,</span><span class="s3">\n                </span><span class="s1">);</span><span class="s3">\n                </span><span class="s1">if (sourceMatches) {</span><span class="s3">\n                  </span><span class="s1">source = sourceMatches[1];</span><span class="s3">\n                  </span><span class="s1">sourceSet = true;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n\n                </span><span class="s1">const runtimeMatches = JSX_RUNTIME_ANNOTATION_REGEX.exec(</span><span class="s3">\n                  </span><span class="s1">comment.value,</span><span class="s3">\n                </span><span class="s1">);</span><span class="s3">\n                </span><span class="s1">if (runtimeMatches) {</span><span class="s3">\n                  </span><span class="s1">runtime = runtimeMatches[1];</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n\n                </span><span class="s1">const jsxMatches = JSX_ANNOTATION_REGEX.exec(comment.value);</span><span class="s3">\n                </span><span class="s1">if (jsxMatches) {</span><span class="s3">\n                  </span><span class="s1">pragma = jsxMatches[1];</span><span class="s3">\n                  </span><span class="s1">pragmaSet = true;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">const jsxFragMatches = JSX_FRAG_ANNOTATION_REGEX.exec(</span><span class="s3">\n                  </span><span class="s1">comment.value,</span><span class="s3">\n                </span><span class="s1">);</span><span class="s3">\n                </span><span class="s1">if (jsxFragMatches) {</span><span class="s3">\n                  </span><span class="s1">pragmaFrag = jsxFragMatches[1];</span><span class="s3">\n                  </span><span class="s1">pragmaFragSet = true;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">set(state, </span><span class="s3">\&quot;</span><span class="s1">runtime</span><span class="s3">\&quot;</span><span class="s1">, runtime);</span><span class="s3">\n            </span><span class="s1">if (runtime === </span><span class="s3">\&quot;</span><span class="s1">classic</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n              </span><span class="s1">if (sourceSet) {</span><span class="s3">\n                </span><span class="s1">throw path.buildCodeFrameError(</span><span class="s3">\n                  </span><span class="s1">`importSource cannot be set when runtime is classic.`,</span><span class="s3">\n                </span><span class="s1">);</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n\n              </span><span class="s1">const createElement = toMemberExpression(pragma);</span><span class="s3">\n              </span><span class="s1">const fragment = toMemberExpression(pragmaFrag);</span><span class="s3">\n\n              </span><span class="s1">set(state, </span><span class="s3">\&quot;</span><span class="s1">id/createElement</span><span class="s3">\&quot;</span><span class="s1">, () =&gt; t.cloneNode(createElement));</span><span class="s3">\n              </span><span class="s1">set(state, </span><span class="s3">\&quot;</span><span class="s1">id/fragment</span><span class="s3">\&quot;</span><span class="s1">, () =&gt; t.cloneNode(fragment));</span><span class="s3">\n\n              </span><span class="s1">set(state, </span><span class="s3">\&quot;</span><span class="s1">defaultPure</span><span class="s3">\&quot;</span><span class="s1">, pragma === DEFAULT.pragma);</span><span class="s3">\n            </span><span class="s1">} else if (runtime === </span><span class="s3">\&quot;</span><span class="s1">automatic</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n              </span><span class="s1">if (pragmaSet || pragmaFragSet) {</span><span class="s3">\n                </span><span class="s1">throw path.buildCodeFrameError(</span><span class="s3">\n                  </span><span class="s1">`pragma and pragmaFrag cannot be set when runtime is automatic.`,</span><span class="s3">\n                </span><span class="s1">);</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n\n              </span><span class="s1">const define = (name: string, id: string) =&gt;</span><span class="s3">\n                </span><span class="s1">set(state, name, createImportLazily(state, path, id, source));</span><span class="s3">\n\n              </span><span class="s1">define(</span><span class="s3">\&quot;</span><span class="s1">id/jsx</span><span class="s3">\&quot;</span><span class="s1">, development ? </span><span class="s3">\&quot;</span><span class="s1">jsxDEV</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">jsx</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n              </span><span class="s1">define(</span><span class="s3">\&quot;</span><span class="s1">id/jsxs</span><span class="s3">\&quot;</span><span class="s1">, development ? </span><span class="s3">\&quot;</span><span class="s1">jsxDEV</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">jsxs</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n              </span><span class="s1">define(</span><span class="s3">\&quot;</span><span class="s1">id/createElement</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">createElement</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n              </span><span class="s1">define(</span><span class="s3">\&quot;</span><span class="s1">id/fragment</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">Fragment</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n              </span><span class="s1">set(state, </span><span class="s3">\&quot;</span><span class="s1">defaultPure</span><span class="s3">\&quot;</span><span class="s1">, source === DEFAULT.importSource);</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">throw path.buildCodeFrameError(</span><span class="s3">\n                </span><span class="s1">`Runtime must be either </span><span class="s3">\&quot;</span><span class="s1">classic</span><span class="s3">\&quot; </span><span class="s1">or </span><span class="s3">\&quot;</span><span class="s1">automatic</span><span class="s3">\&quot;</span><span class="s1">.`,</span><span class="s3">\n              </span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">if (development) {</span><span class="s3">\n              </span><span class="s1">path.traverse(injectMetaPropertiesVisitor, state);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n\n          </span><span class="s1">// TODO(Babel 8): Decide if this should be removed or brought back.</span><span class="s3">\n          </span><span class="s1">// see: https://github.com/babel/babel/pull/12253#discussion_r513086528</span><span class="s3">\n          </span><span class="s1">//</span><span class="s3">\n          </span><span class="s1">// exit(path, state) {</span><span class="s3">\n          </span><span class="s1">//   if (</span><span class="s3">\n          </span><span class="s1">//     get(state, </span><span class="s3">\&quot;</span><span class="s1">runtime</span><span class="s3">\&quot;</span><span class="s1">) === </span><span class="s3">\&quot;</span><span class="s1">classic</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n          </span><span class="s1">//     get(state, </span><span class="s3">\&quot;</span><span class="s1">pragmaSet</span><span class="s3">\&quot;</span><span class="s1">) &amp;&amp;</span><span class="s3">\n          </span><span class="s1">//     get(state, </span><span class="s3">\&quot;</span><span class="s1">usedFragment</span><span class="s3">\&quot;</span><span class="s1">) &amp;&amp;</span><span class="s3">\n          </span><span class="s1">//     !get(state, </span><span class="s3">\&quot;</span><span class="s1">pragmaFragSet</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">//   ) {</span><span class="s3">\n          </span><span class="s1">//     throw new Error(</span><span class="s3">\n          </span><span class="s1">//       </span><span class="s3">\&quot;</span><span class="s1">transform-react-jsx: pragma has been set but </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n          </span><span class="s1">//         </span><span class="s3">\&quot;</span><span class="s1">pragmaFrag has not been set</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n          </span><span class="s1">//     );</span><span class="s3">\n          </span><span class="s1">//   }</span><span class="s3">\n          </span><span class="s1">// },</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n\n        </span><span class="s1">JSXFragment: {</span><span class="s3">\n          </span><span class="s1">exit(path, file) {</span><span class="s3">\n            </span><span class="s1">let callExpr;</span><span class="s3">\n            </span><span class="s1">if (get(file, </span><span class="s3">\&quot;</span><span class="s1">runtime</span><span class="s3">\&quot;</span><span class="s1">) === </span><span class="s3">\&quot;</span><span class="s1">classic</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n              </span><span class="s1">callExpr = buildCreateElementFragmentCall(path, file);</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">callExpr = buildJSXFragmentCall(path, file);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">path.replaceWith(t.inherits(callExpr, path.node));</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n\n        </span><span class="s1">JSXElement: {</span><span class="s3">\n          </span><span class="s1">exit(path, file) {</span><span class="s3">\n            </span><span class="s1">let callExpr;</span><span class="s3">\n            </span><span class="s1">if (</span><span class="s3">\n              </span><span class="s1">get(file, </span><span class="s3">\&quot;</span><span class="s1">runtime</span><span class="s3">\&quot;</span><span class="s1">) === </span><span class="s3">\&quot;</span><span class="s1">classic</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n              </span><span class="s1">shouldUseCreateElement(path)</span><span class="s3">\n            </span><span class="s1">) {</span><span class="s3">\n              </span><span class="s1">callExpr = buildCreateElementCall(path, file);</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">callExpr = buildJSXElementCall(path, file);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">path.replaceWith(t.inherits(callExpr, path.node));</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n\n        </span><span class="s1">JSXAttribute(path) {</span><span class="s3">\n          </span><span class="s1">if (t.isJSXElement(path.node.value)) {</span><span class="s3">\n            </span><span class="s1">path.node.value = t.jsxExpressionContainer(path.node.value);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n\n    </span><span class="s1">// Returns whether the class has specified a superclass.</span><span class="s3">\n    </span><span class="s1">function isDerivedClass(classPath: NodePath&lt;Class&gt;) {</span><span class="s3">\n      </span><span class="s1">return classPath.node.superClass !== null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Returns whether `this` is allowed at given scope.</span><span class="s3">\n    </span><span class="s1">function isThisAllowed(scope: Scope) {</span><span class="s3">\n      </span><span class="s1">// This specifically skips arrow functions as they do not rewrite `this`.</span><span class="s3">\n      </span><span class="s1">do {</span><span class="s3">\n        </span><span class="s1">const { path } = scope;</span><span class="s3">\n        </span><span class="s1">if (path.isFunctionParent() &amp;&amp; !path.isArrowFunctionExpression()) {</span><span class="s3">\n          </span><span class="s1">if (!path.isMethod()) {</span><span class="s3">\n            </span><span class="s1">// If the closest parent is a regular function, `this` will be rebound, therefore it is fine to use `this`.</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">// Current node is within a method, so we need to check if the method is a constructor.</span><span class="s3">\n          </span><span class="s1">if (path.node.kind !== </span><span class="s3">\&quot;</span><span class="s1">constructor</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">// We are not in a constructor, therefore it is always fine to use `this`.</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">// Now we are in a constructor. If it is a derived class, we do not reference `this`.</span><span class="s3">\n          </span><span class="s1">return !isDerivedClass(path.parentPath.parentPath as NodePath&lt;Class&gt;);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (path.isTSModuleBlock()) {</span><span class="s3">\n          </span><span class="s1">// If the closest parent is a TS Module block, `this` will not be allowed.</span><span class="s3">\n          </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} while ((scope = scope.parent));</span><span class="s3">\n      </span><span class="s1">// We are not in a method or function. It is fine to use `this`.</span><span class="s3">\n      </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">function call(</span><span class="s3">\n      </span><span class="s1">pass: PluginPass,</span><span class="s3">\n      </span><span class="s1">name: string,</span><span class="s3">\n      </span><span class="s1">args: CallExpression[</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">const node = t.callExpression(get(pass, `id/${name}`)(), args);</span><span class="s3">\n      </span><span class="s1">if (PURE_ANNOTATION ?? get(pass, </span><span class="s3">\&quot;</span><span class="s1">defaultPure</span><span class="s3">\&quot;</span><span class="s1">)) annotateAsPure(node);</span><span class="s3">\n      </span><span class="s1">return node;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// We want to use React.createElement, even in the case of</span><span class="s3">\n    </span><span class="s1">// jsx, for &lt;div {...props} key={key} /&gt; to distinguish it</span><span class="s3">\n    </span><span class="s1">// from &lt;div key={key} {...props} /&gt;. This is an intermediary</span><span class="s3">\n    </span><span class="s1">// step while we deprecate key spread from props. Afterwards,</span><span class="s3">\n    </span><span class="s1">// we will stop using createElement in the transform.</span><span class="s3">\n    </span><span class="s1">function shouldUseCreateElement(path: NodePath&lt;JSXElement&gt;) {</span><span class="s3">\n      </span><span class="s1">const openingPath = path.get(</span><span class="s3">\&quot;</span><span class="s1">openingElement</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">const attributes = openingPath.node.attributes;</span><span class="s3">\n\n      </span><span class="s1">let seenPropsSpread = false;</span><span class="s3">\n      </span><span class="s1">for (let i = 0; i &lt; attributes.length; i++) {</span><span class="s3">\n        </span><span class="s1">const attr = attributes[i];</span><span class="s3">\n        </span><span class="s1">if (</span><span class="s3">\n          </span><span class="s1">seenPropsSpread &amp;&amp;</span><span class="s3">\n          </span><span class="s1">t.isJSXAttribute(attr) &amp;&amp;</span><span class="s3">\n          </span><span class="s1">attr.name.name === </span><span class="s3">\&quot;</span><span class="s1">key</span><span class="s3">\&quot;\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">} else if (t.isJSXSpreadAttribute(attr)) {</span><span class="s3">\n          </span><span class="s1">seenPropsSpread = true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">function convertJSXIdentifier(</span><span class="s3">\n      </span><span class="s1">node: t.JSXIdentifier | t.JSXMemberExpression | t.JSXNamespacedName,</span><span class="s3">\n      </span><span class="s1">parent: t.JSXOpeningElement | t.JSXMemberExpression,</span><span class="s3">\n    </span><span class="s1">): t.ThisExpression | t.StringLiteral | t.MemberExpression | t.Identifier {</span><span class="s3">\n      </span><span class="s1">if (t.isJSXIdentifier(node)) {</span><span class="s3">\n        </span><span class="s1">if (node.name === </span><span class="s3">\&quot;</span><span class="s1">this</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; t.isReferenced(node, parent)) {</span><span class="s3">\n          </span><span class="s1">return t.thisExpression();</span><span class="s3">\n        </span><span class="s1">} else if (t.isValidIdentifier(node.name, false)) {</span><span class="s3">\n          </span><span class="s1">// @ts-expect-error cast AST type to Identifier</span><span class="s3">\n          </span><span class="s1">node.type = </span><span class="s3">\&quot;</span><span class="s1">Identifier</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n          </span><span class="s1">return node as unknown as t.Identifier;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">return t.stringLiteral(node.name);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else if (t.isJSXMemberExpression(node)) {</span><span class="s3">\n        </span><span class="s1">return t.memberExpression(</span><span class="s3">\n          </span><span class="s1">convertJSXIdentifier(node.object, node),</span><span class="s3">\n          </span><span class="s1">convertJSXIdentifier(node.property, node),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">} else if (t.isJSXNamespacedName(node)) {</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* If the flag </span><span class="s3">\&quot;</span><span class="s1">throwIfNamespace</span><span class="s3">\&quot; </span><span class="s1">is false</span><span class="s3">\n         </span><span class="s1">* print XMLNamespace like string literal</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">return t.stringLiteral(`${node.namespace.name}:${node.name.name}`);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// todo: this branch should be unreachable</span><span class="s3">\n      </span><span class="s1">return node;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">function convertAttributeValue(</span><span class="s3">\n      </span><span class="s1">node: t.JSXAttribute[</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">] | t.BooleanLiteral,</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">if (t.isJSXExpressionContainer(node)) {</span><span class="s3">\n        </span><span class="s1">return node.expression;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">return node;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">function accumulateAttribute(</span><span class="s3">\n      </span><span class="s1">array: ObjectExpression[</span><span class="s3">\&quot;</span><span class="s1">properties</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n      </span><span class="s1">attribute: NodePath&lt;JSXAttribute | JSXSpreadAttribute&gt;,</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">if (t.isJSXSpreadAttribute(attribute.node)) {</span><span class="s3">\n        </span><span class="s1">const arg = attribute.node.argument;</span><span class="s3">\n        </span><span class="s1">// Collect properties into props array if spreading object expression</span><span class="s3">\n        </span><span class="s1">if (t.isObjectExpression(arg) &amp;&amp; !hasProto(arg)) {</span><span class="s3">\n          </span><span class="s1">array.push(...arg.properties);</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">array.push(t.spreadElement(arg));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return array;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const value = convertAttributeValue(</span><span class="s3">\n        </span><span class="s1">attribute.node.name.name !== </span><span class="s3">\&quot;</span><span class="s1">key</span><span class="s3">\&quot;\n          </span><span class="s1">? attribute.node.value || t.booleanLiteral(true)</span><span class="s3">\n          </span><span class="s1">: attribute.node.value,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n\n      </span><span class="s1">if (attribute.node.name.name === </span><span class="s3">\&quot;</span><span class="s1">key</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; value === null) {</span><span class="s3">\n        </span><span class="s1">throw attribute.buildCodeFrameError(</span><span class="s3">\n          </span><span class="s1">'Please provide an explicit key value. Using </span><span class="s3">\&quot;</span><span class="s1">key</span><span class="s3">\&quot; </span><span class="s1">as a shorthand for </span><span class="s3">\&quot;</span><span class="s1">key={true}</span><span class="s3">\&quot; </span><span class="s1">is not allowed.',</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">t.isStringLiteral(value) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">!t.isJSXExpressionContainer(attribute.node.value)</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">value.value = value.value.replace(/</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">s+/g, </span><span class="s3">\&quot; \&quot;</span><span class="s1">);</span><span class="s3">\n\n        </span><span class="s1">// </span><span class="s3">\&quot;</span><span class="s1">raw</span><span class="s3">\&quot; </span><span class="s1">JSXText should not be used from a StringLiteral because it needs to be escaped.</span><span class="s3">\n        </span><span class="s1">delete value.extra?.raw;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (t.isJSXNamespacedName(attribute.node.name)) {</span><span class="s3">\n        </span><span class="s1">// @ts-expect-error mutating AST</span><span class="s3">\n        </span><span class="s1">attribute.node.name = t.stringLiteral(</span><span class="s3">\n          </span><span class="s1">attribute.node.name.namespace.name +</span><span class="s3">\n            \&quot;</span><span class="s1">:</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n            </span><span class="s1">attribute.node.name.name.name,</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">} else if (t.isValidIdentifier(attribute.node.name.name, false)) {</span><span class="s3">\n        </span><span class="s1">// @ts-expect-error mutating AST</span><span class="s3">\n        </span><span class="s1">attribute.node.name.type = </span><span class="s3">\&quot;</span><span class="s1">Identifier</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// @ts-expect-error mutating AST</span><span class="s3">\n        </span><span class="s1">attribute.node.name = t.stringLiteral(attribute.node.name.name);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">array.push(</span><span class="s3">\n        </span><span class="s1">t.inherits(</span><span class="s3">\n          </span><span class="s1">t.objectProperty(</span><span class="s3">\n            </span><span class="s1">// @ts-expect-error The attribute.node.name is an Identifier now</span><span class="s3">\n            </span><span class="s1">attribute.node.name,</span><span class="s3">\n            </span><span class="s1">value,</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">attribute.node,</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">return array;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">function buildChildrenProperty(children: Expression[]) {</span><span class="s3">\n      </span><span class="s1">let childrenNode;</span><span class="s3">\n      </span><span class="s1">if (children.length === 1) {</span><span class="s3">\n        </span><span class="s1">childrenNode = children[0];</span><span class="s3">\n      </span><span class="s1">} else if (children.length &gt; 1) {</span><span class="s3">\n        </span><span class="s1">childrenNode = t.arrayExpression(children);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">return undefined;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return t.objectProperty(t.identifier(</span><span class="s3">\&quot;</span><span class="s1">children</span><span class="s3">\&quot;</span><span class="s1">), childrenNode);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Builds JSX into:</span><span class="s3">\n    </span><span class="s1">// Production: React.jsx(type, arguments, key)</span><span class="s3">\n    </span><span class="s1">// Development: React.jsxDEV(type, arguments, key, isStaticChildren, source, self)</span><span class="s3">\n    </span><span class="s1">function buildJSXElementCall(path: NodePath&lt;JSXElement&gt;, file: PluginPass) {</span><span class="s3">\n      </span><span class="s1">const openingPath = path.get(</span><span class="s3">\&quot;</span><span class="s1">openingElement</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">const args: t.Expression[] = [getTag(openingPath)];</span><span class="s3">\n\n      </span><span class="s1">const attribsArray = [];</span><span class="s3">\n      </span><span class="s1">const extracted = Object.create(null);</span><span class="s3">\n\n      </span><span class="s1">// for React.jsx, key, __source (dev), and __self (dev) is passed in as</span><span class="s3">\n      </span><span class="s1">// a separate argument rather than in the args object. We go through the</span><span class="s3">\n      </span><span class="s1">// props and filter out these three keywords so we can pass them in</span><span class="s3">\n      </span><span class="s1">// as separate arguments later</span><span class="s3">\n      </span><span class="s1">for (const attr of openingPath.get(</span><span class="s3">\&quot;</span><span class="s1">attributes</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n        </span><span class="s1">if (attr.isJSXAttribute() &amp;&amp; t.isJSXIdentifier(attr.node.name)) {</span><span class="s3">\n          </span><span class="s1">const { name } = attr.node.name;</span><span class="s3">\n          </span><span class="s1">switch (name) {</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">__source</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">__self</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n              </span><span class="s1">if (extracted[name]) throw sourceSelfError(path, name);</span><span class="s3">\n            </span><span class="s1">/* falls through */</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">key</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n              </span><span class="s1">const keyValue = convertAttributeValue(attr.node.value);</span><span class="s3">\n              </span><span class="s1">if (keyValue === null) {</span><span class="s3">\n                </span><span class="s1">throw attr.buildCodeFrameError(</span><span class="s3">\n                  </span><span class="s1">'Please provide an explicit key value. Using </span><span class="s3">\&quot;</span><span class="s1">key</span><span class="s3">\&quot; </span><span class="s1">as a shorthand for </span><span class="s3">\&quot;</span><span class="s1">key={true}</span><span class="s3">\&quot; </span><span class="s1">is not allowed.',</span><span class="s3">\n                </span><span class="s1">);</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n\n              </span><span class="s1">extracted[name] = keyValue;</span><span class="s3">\n              </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">default:</span><span class="s3">\n              </span><span class="s1">attribsArray.push(attr);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">attribsArray.push(attr);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const children = t.react.buildChildren(path.node);</span><span class="s3">\n\n      </span><span class="s1">let attribs: t.ObjectExpression;</span><span class="s3">\n\n      </span><span class="s1">if (attribsArray.length || children.length) {</span><span class="s3">\n        </span><span class="s1">attribs = buildJSXOpeningElementAttributes(</span><span class="s3">\n          </span><span class="s1">attribsArray,</span><span class="s3">\n          </span><span class="s1">//@ts-expect-error The children here contains JSXSpreadChild,</span><span class="s3">\n          </span><span class="s1">// which will be thrown later</span><span class="s3">\n          </span><span class="s1">children,</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// attributes should never be null</span><span class="s3">\n        </span><span class="s1">attribs = t.objectExpression([]);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">args.push(attribs);</span><span class="s3">\n\n      </span><span class="s1">if (development) {</span><span class="s3">\n        </span><span class="s1">// isStaticChildren, __source, and __self are only used in development</span><span class="s3">\n        </span><span class="s1">// automatically include __source and __self in this plugin</span><span class="s3">\n        </span><span class="s1">// so we can eliminate the need for separate Babel plugins in Babel 8</span><span class="s3">\n        </span><span class="s1">args.push(</span><span class="s3">\n          </span><span class="s1">extracted.key ?? path.scope.buildUndefinedNode(),</span><span class="s3">\n          </span><span class="s1">t.booleanLiteral(children.length &gt; 1),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">if (extracted.__source) {</span><span class="s3">\n          </span><span class="s1">args.push(extracted.__source);</span><span class="s3">\n          </span><span class="s1">if (extracted.__self) args.push(extracted.__self);</span><span class="s3">\n        </span><span class="s1">} else if (extracted.__self) {</span><span class="s3">\n          </span><span class="s1">args.push(path.scope.buildUndefinedNode(), extracted.__self);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else if (extracted.key !== undefined) {</span><span class="s3">\n        </span><span class="s1">args.push(extracted.key);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return call(file, children.length &gt; 1 ? </span><span class="s3">\&quot;</span><span class="s1">jsxs</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">jsx</span><span class="s3">\&quot;</span><span class="s1">, args);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Builds props for React.jsx. This function adds children into the props</span><span class="s3">\n    </span><span class="s1">// and ensures that props is always an object</span><span class="s3">\n    </span><span class="s1">function buildJSXOpeningElementAttributes(</span><span class="s3">\n      </span><span class="s1">attribs: NodePath&lt;JSXAttribute | JSXSpreadAttribute&gt;[],</span><span class="s3">\n      </span><span class="s1">children: Expression[],</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">const props = attribs.reduce(accumulateAttribute, []);</span><span class="s3">\n\n      </span><span class="s1">// In React.jsx, children is no longer a separate argument, but passed in</span><span class="s3">\n      </span><span class="s1">// through the argument object</span><span class="s3">\n      </span><span class="s1">if (children?.length &gt; 0) {</span><span class="s3">\n        </span><span class="s1">props.push(buildChildrenProperty(children));</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return t.objectExpression(props);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Builds JSX Fragment &lt;&gt;&lt;/&gt; into</span><span class="s3">\n    </span><span class="s1">// Production: React.jsx(type, arguments)</span><span class="s3">\n    </span><span class="s1">// Development: React.jsxDEV(type, { children })</span><span class="s3">\n    </span><span class="s1">function buildJSXFragmentCall(</span><span class="s3">\n      </span><span class="s1">path: NodePath&lt;JSXFragment&gt;,</span><span class="s3">\n      </span><span class="s1">file: PluginPass,</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">const args = [get(file, </span><span class="s3">\&quot;</span><span class="s1">id/fragment</span><span class="s3">\&quot;</span><span class="s1">)()];</span><span class="s3">\n\n      </span><span class="s1">const children = t.react.buildChildren(path.node);</span><span class="s3">\n\n      </span><span class="s1">args.push(</span><span class="s3">\n        </span><span class="s1">t.objectExpression(</span><span class="s3">\n          </span><span class="s1">children.length &gt; 0</span><span class="s3">\n            </span><span class="s1">? [</span><span class="s3">\n                </span><span class="s1">buildChildrenProperty(</span><span class="s3">\n                  </span><span class="s1">//@ts-expect-error The children here contains JSXSpreadChild,</span><span class="s3">\n                  </span><span class="s1">// which will be thrown later</span><span class="s3">\n                  </span><span class="s1">children,</span><span class="s3">\n                </span><span class="s1">),</span><span class="s3">\n              </span><span class="s1">]</span><span class="s3">\n            </span><span class="s1">: [],</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n\n      </span><span class="s1">if (development) {</span><span class="s3">\n        </span><span class="s1">args.push(</span><span class="s3">\n          </span><span class="s1">path.scope.buildUndefinedNode(),</span><span class="s3">\n          </span><span class="s1">t.booleanLiteral(children.length &gt; 1),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return call(file, children.length &gt; 1 ? </span><span class="s3">\&quot;</span><span class="s1">jsxs</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">jsx</span><span class="s3">\&quot;</span><span class="s1">, args);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Builds JSX Fragment &lt;&gt;&lt;/&gt; into</span><span class="s3">\n    </span><span class="s1">// React.createElement(React.Fragment, null, ...children)</span><span class="s3">\n    </span><span class="s1">function buildCreateElementFragmentCall(</span><span class="s3">\n      </span><span class="s1">path: NodePath&lt;JSXFragment&gt;,</span><span class="s3">\n      </span><span class="s1">file: PluginPass,</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">if (filter &amp;&amp; !filter(path.node, file)) return;</span><span class="s3">\n\n      </span><span class="s1">return call(file, </span><span class="s3">\&quot;</span><span class="s1">createElement</span><span class="s3">\&quot;</span><span class="s1">, [</span><span class="s3">\n        </span><span class="s1">get(file, </span><span class="s3">\&quot;</span><span class="s1">id/fragment</span><span class="s3">\&quot;</span><span class="s1">)(),</span><span class="s3">\n        </span><span class="s1">t.nullLiteral(),</span><span class="s3">\n        </span><span class="s1">...t.react.buildChildren(path.node),</span><span class="s3">\n      </span><span class="s1">]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Builds JSX into:</span><span class="s3">\n    </span><span class="s1">// Production: React.createElement(type, arguments, children)</span><span class="s3">\n    </span><span class="s1">// Development: React.createElement(type, arguments, children, source, self)</span><span class="s3">\n    </span><span class="s1">function buildCreateElementCall(</span><span class="s3">\n      </span><span class="s1">path: NodePath&lt;JSXElement&gt;,</span><span class="s3">\n      </span><span class="s1">file: PluginPass,</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">const openingPath = path.get(</span><span class="s3">\&quot;</span><span class="s1">openingElement</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n      </span><span class="s1">return call(file, </span><span class="s3">\&quot;</span><span class="s1">createElement</span><span class="s3">\&quot;</span><span class="s1">, [</span><span class="s3">\n        </span><span class="s1">getTag(openingPath),</span><span class="s3">\n        </span><span class="s1">buildCreateElementOpeningElementAttributes(</span><span class="s3">\n          </span><span class="s1">file,</span><span class="s3">\n          </span><span class="s1">path,</span><span class="s3">\n          </span><span class="s1">openingPath.get(</span><span class="s3">\&quot;</span><span class="s1">attributes</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">// @ts-expect-error JSXSpreadChild has been transformed in convertAttributeValue</span><span class="s3">\n        </span><span class="s1">...t.react.buildChildren(path.node),</span><span class="s3">\n      </span><span class="s1">]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">function getTag(openingPath: NodePath&lt;JSXOpeningElement&gt;) {</span><span class="s3">\n      </span><span class="s1">const tagExpr = convertJSXIdentifier(</span><span class="s3">\n        </span><span class="s1">openingPath.node.name,</span><span class="s3">\n        </span><span class="s1">openingPath.node,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n\n      </span><span class="s1">let tagName: string;</span><span class="s3">\n      </span><span class="s1">if (t.isIdentifier(tagExpr)) {</span><span class="s3">\n        </span><span class="s1">tagName = tagExpr.name;</span><span class="s3">\n      </span><span class="s1">} else if (t.isStringLiteral(tagExpr)) {</span><span class="s3">\n        </span><span class="s1">tagName = tagExpr.value;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (t.react.isCompatTag(tagName)) {</span><span class="s3">\n        </span><span class="s1">return t.stringLiteral(tagName);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">return tagExpr;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The logic for this is quite terse. It's because we need to</span><span class="s3">\n     </span><span class="s1">* support spread elements. We loop over all attributes,</span><span class="s3">\n     </span><span class="s1">* breaking on spreads, we then push a new object containing</span><span class="s3">\n     </span><span class="s1">* all prior attributes to an array for later processing.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function buildCreateElementOpeningElementAttributes(</span><span class="s3">\n      </span><span class="s1">file: PluginPass,</span><span class="s3">\n      </span><span class="s1">path: NodePath&lt;JSXElement&gt;,</span><span class="s3">\n      </span><span class="s1">attribs: NodePath&lt;JSXAttribute | JSXSpreadAttribute&gt;[],</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">const runtime = get(file, </span><span class="s3">\&quot;</span><span class="s1">runtime</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">if (!process.env.BABEL_8_BREAKING) {</span><span class="s3">\n        </span><span class="s1">if (runtime !== </span><span class="s3">\&quot;</span><span class="s1">automatic</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">const objs = [];</span><span class="s3">\n          </span><span class="s1">const props = attribs.reduce(accumulateAttribute, []);</span><span class="s3">\n\n          </span><span class="s1">if (!useSpread) {</span><span class="s3">\n            </span><span class="s1">// Convert syntax to use multiple objects instead of spread</span><span class="s3">\n            </span><span class="s1">let start = 0;</span><span class="s3">\n            </span><span class="s1">props.forEach((prop, i) =&gt; {</span><span class="s3">\n              </span><span class="s1">if (t.isSpreadElement(prop)) {</span><span class="s3">\n                </span><span class="s1">if (i &gt; start) {</span><span class="s3">\n                  </span><span class="s1">objs.push(t.objectExpression(props.slice(start, i)));</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">objs.push(prop.argument);</span><span class="s3">\n                </span><span class="s1">start = i + 1;</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">if (props.length &gt; start) {</span><span class="s3">\n              </span><span class="s1">objs.push(t.objectExpression(props.slice(start)));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">} else if (props.length) {</span><span class="s3">\n            </span><span class="s1">objs.push(t.objectExpression(props));</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">if (!objs.length) {</span><span class="s3">\n            </span><span class="s1">return t.nullLiteral();</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">if (objs.length === 1) {</span><span class="s3">\n            </span><span class="s1">if (</span><span class="s3">\n              </span><span class="s1">!(</span><span class="s3">\n                </span><span class="s1">t.isSpreadElement(props[0]) &amp;&amp;</span><span class="s3">\n                </span><span class="s1">// If an object expression is spread element's argument</span><span class="s3">\n                </span><span class="s1">// it is very likely to contain __proto__ and we should stop</span><span class="s3">\n                </span><span class="s1">// optimizing spread element</span><span class="s3">\n                </span><span class="s1">t.isObjectExpression(props[0].argument)</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">) {</span><span class="s3">\n              </span><span class="s1">return objs[0];</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">// looks like we have multiple objects</span><span class="s3">\n          </span><span class="s1">if (!t.isObjectExpression(objs[0])) {</span><span class="s3">\n            </span><span class="s1">objs.unshift(t.objectExpression([]));</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">const helper = useBuiltIns</span><span class="s3">\n            </span><span class="s1">? t.memberExpression(t.identifier(</span><span class="s3">\&quot;</span><span class="s1">Object</span><span class="s3">\&quot;</span><span class="s1">), t.identifier(</span><span class="s3">\&quot;</span><span class="s1">assign</span><span class="s3">\&quot;</span><span class="s1">))</span><span class="s3">\n            </span><span class="s1">: file.addHelper(</span><span class="s3">\&quot;</span><span class="s1">extends</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n          </span><span class="s1">// spread it</span><span class="s3">\n          </span><span class="s1">return t.callExpression(helper, objs);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const props: ObjectExpression[</span><span class="s3">\&quot;</span><span class="s1">properties</span><span class="s3">\&quot;</span><span class="s1">] = [];</span><span class="s3">\n      </span><span class="s1">const found = Object.create(null);</span><span class="s3">\n\n      </span><span class="s1">for (const attr of attribs) {</span><span class="s3">\n        </span><span class="s1">const { node } = attr;</span><span class="s3">\n        </span><span class="s1">const name =</span><span class="s3">\n          </span><span class="s1">t.isJSXAttribute(node) &amp;&amp;</span><span class="s3">\n          </span><span class="s1">t.isJSXIdentifier(node.name) &amp;&amp;</span><span class="s3">\n          </span><span class="s1">node.name.name;</span><span class="s3">\n\n        </span><span class="s1">if (</span><span class="s3">\n          </span><span class="s1">runtime === </span><span class="s3">\&quot;</span><span class="s1">automatic</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n          </span><span class="s1">(name === </span><span class="s3">\&quot;</span><span class="s1">__source</span><span class="s3">\&quot; </span><span class="s1">|| name === </span><span class="s3">\&quot;</span><span class="s1">__self</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">if (found[name]) throw sourceSelfError(path, name);</span><span class="s3">\n          </span><span class="s1">found[name] = true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">accumulateAttribute(props, attr);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return props.length === 1 &amp;&amp;</span><span class="s3">\n        </span><span class="s1">t.isSpreadElement(props[0]) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">// If an object expression is spread element's argument</span><span class="s3">\n        </span><span class="s1">// it is very likely to contain __proto__ and we should stop</span><span class="s3">\n        </span><span class="s1">// optimizing spread element</span><span class="s3">\n        </span><span class="s1">!t.isObjectExpression(props[0].argument)</span><span class="s3">\n        </span><span class="s1">? props[0].argument</span><span class="s3">\n        </span><span class="s1">: props.length &gt; 0</span><span class="s3">\n          </span><span class="s1">? t.objectExpression(props)</span><span class="s3">\n          </span><span class="s1">: t.nullLiteral();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">function getSource(source: string, importName: string) {</span><span class="s3">\n    </span><span class="s1">switch (importName) {</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">Fragment</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return `${source}/${development ? </span><span class="s3">\&quot;</span><span class="s1">jsx-dev-runtime</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">jsx-runtime</span><span class="s3">\&quot;</span><span class="s1">}`;</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">jsxDEV</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return `${source}/jsx-dev-runtime`;</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">jsx</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">jsxs</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return `${source}/jsx-runtime`;</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">createElement</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return source;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function createImportLazily(</span><span class="s3">\n    </span><span class="s1">pass: PluginPass,</span><span class="s3">\n    </span><span class="s1">path: NodePath&lt;Program&gt;,</span><span class="s3">\n    </span><span class="s1">importName: string,</span><span class="s3">\n    </span><span class="s1">source: string,</span><span class="s3">\n  </span><span class="s1">): () =&gt; Identifier | MemberExpression {</span><span class="s3">\n    </span><span class="s1">return () =&gt; {</span><span class="s3">\n      </span><span class="s1">const actualSource = getSource(source, importName);</span><span class="s3">\n      </span><span class="s1">if (isModule(path)) {</span><span class="s3">\n        </span><span class="s1">let reference = get(pass, `imports/${importName}`);</span><span class="s3">\n        </span><span class="s1">if (reference) return t.cloneNode(reference);</span><span class="s3">\n\n        </span><span class="s1">reference = addNamed(path, importName, actualSource, {</span><span class="s3">\n          </span><span class="s1">importedInterop: </span><span class="s3">\&quot;</span><span class="s1">uncompiled</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n          </span><span class="s1">importPosition: </span><span class="s3">\&quot;</span><span class="s1">after</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">set(pass, `imports/${importName}`, reference);</span><span class="s3">\n\n        </span><span class="s1">return reference;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">let reference = get(pass, `requires/${actualSource}`);</span><span class="s3">\n        </span><span class="s1">if (reference) {</span><span class="s3">\n          </span><span class="s1">reference = t.cloneNode(reference);</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">reference = addNamespace(path, actualSource, {</span><span class="s3">\n            </span><span class="s1">importedInterop: </span><span class="s3">\&quot;</span><span class="s1">uncompiled</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n          </span><span class="s1">set(pass, `requires/${actualSource}`, reference);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">return t.memberExpression(reference, t.identifier(importName));</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function toMemberExpression(id: string): Identifier | MemberExpression {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">id</span><span class="s3">\n      </span><span class="s1">.split(</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">.map(name =&gt; t.identifier(name))</span><span class="s3">\n      </span><span class="s1">// @ts-expect-error - The Array#reduce does not have a signature</span><span class="s3">\n      </span><span class="s1">// where the type of initial value differs from callback return type</span><span class="s3">\n      </span><span class="s1">.reduce((object, property) =&gt; t.memberExpression(object, property))</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function makeSource(path: NodePath, state: PluginPass) {</span><span class="s3">\n  </span><span class="s1">const location = path.node.loc;</span><span class="s3">\n  </span><span class="s1">if (!location) {</span><span class="s3">\n    </span><span class="s1">// the element was generated and doesn't have location information</span><span class="s3">\n    </span><span class="s1">return path.scope.buildUndefinedNode();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// @ts-expect-error todo: avoid mutating PluginPass</span><span class="s3">\n  </span><span class="s1">if (!state.fileNameIdentifier) {</span><span class="s3">\n    </span><span class="s1">const { filename = </span><span class="s3">\&quot;\&quot; </span><span class="s1">} = state;</span><span class="s3">\n\n    </span><span class="s1">const fileNameIdentifier = path.scope.generateUidIdentifier(</span><span class="s3">\&quot;</span><span class="s1">_jsxFileName</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">path.scope.getProgramParent().push({</span><span class="s3">\n      </span><span class="s1">id: fileNameIdentifier,</span><span class="s3">\n      </span><span class="s1">init: t.stringLiteral(filename),</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">// @ts-expect-error todo: avoid mutating PluginPass</span><span class="s3">\n    </span><span class="s1">state.fileNameIdentifier = fileNameIdentifier;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return makeTrace(</span><span class="s3">\n    </span><span class="s1">t.cloneNode(</span><span class="s3">\n      </span><span class="s1">// @ts-expect-error todo: avoid mutating PluginPass</span><span class="s3">\n      </span><span class="s1">state.fileNameIdentifier,</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">location.start.line,</span><span class="s3">\n    </span><span class="s1">location.start.column,</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function makeTrace(</span><span class="s3">\n  </span><span class="s1">fileNameIdentifier: Identifier,</span><span class="s3">\n  </span><span class="s1">lineNumber?: number,</span><span class="s3">\n  </span><span class="s1">column0Based?: number,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const fileLineLiteral =</span><span class="s3">\n    </span><span class="s1">lineNumber != null ? t.numericLiteral(lineNumber) : t.nullLiteral();</span><span class="s3">\n\n  </span><span class="s1">const fileColumnLiteral =</span><span class="s3">\n    </span><span class="s1">column0Based != null ? t.numericLiteral(column0Based + 1) : t.nullLiteral();</span><span class="s3">\n\n  </span><span class="s1">return template.expression.ast`{</span><span class="s3">\n    </span><span class="s1">fileName: ${fileNameIdentifier},</span><span class="s3">\n    </span><span class="s1">lineNumber: ${fileLineLiteral},</span><span class="s3">\n    </span><span class="s1">columnNumber: ${fileColumnLiteral},</span><span class="s3">\n  </span><span class="s1">}`;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function sourceSelfError(path: NodePath, name: string) {</span><span class="s3">\n  </span><span class="s1">const pluginName = `transform-react-jsx-${name.slice(2)}`;</span><span class="s3">\n\n  </span><span class="s1">return path.buildCodeFrameError(</span><span class="s3">\n    </span><span class="s1">`Duplicate ${name} prop found. You are most likely using the deprecated ${pluginName} Babel plugin. Both __source and __self are automatically set when using the automatic runtime. Please remove transform-react-jsx-source and transform-react-jsx-self from your Babel config.`,</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;AAAA,IAAAA,gBAAA,GAAAC,OAAA;AACA,IAAAC,kBAAA,GAAAD,OAAA;AACA,IAAAE,KAAA,GAAAF,OAAA;AAEA,IAAAG,oBAAA,GAAAH,OAAA;AACA,IAAAI,qBAAA,GAAAJ,OAAA;AAgBA,MAAMK,OAAO,GAAG;EACdC,YAAY,EAAE,OAAO;EACrBC,OAAO,EAAE,WAAW;EACpBC,MAAM,EAAE,qBAAqB;EAC7BC,UAAU,EAAE;AACd,CAAC;AAED,MAAMC,2BAA2B,GAC/B,6CAA6C;AAC/C,MAAMC,4BAA4B,GAAG,wCAAwC;AAE7E,MAAMC,oBAAoB,GAAG,iCAAiC;AAC9D,MAAMC,yBAAyB,GAAG,qCAAqC;AAEvE,MAAMC,GAAG,GAAGA,CAACC,IAAgB,EAAEC,IAAY,KACzCD,IAAI,CAACD,GAAG,CAAC,2BAA2BE,IAAI,EAAE,CAAC;AAC7C,MAAMC,GAAG,GAAGA,CAACF,IAAgB,EAAEC,IAAY,EAAEE,CAAM,KACjDH,IAAI,CAACE,GAAG,CAAC,2BAA2BD,IAAI,EAAE,EAAEE,CAAC,CAAC;AAEhD,SAASC,QAAQA,CAACC,IAAwB,EAAE;EAC1C,OAAOA,IAAI,CAACC,UAAU,CAACC,IAAI,CACzBC,KAAK,IACHC,WAAC,CAACC,gBAAgB,CAACF,KAAK,EAAE;IAAEG,QAAQ,EAAE,KAAK;IAAEC,SAAS,EAAE;EAAM,CAAC,CAAC,KAC/DH,WAAC,CAACI,YAAY,CAACL,KAAK,CAACM,GAAG,EAAE;IAAEb,IAAI,EAAE;EAAY,CAAC,CAAC,IAC/CQ,WAAC,CAACM,eAAe,CAACP,KAAK,CAACM,GAAG,EAAE;IAAEN,KAAK,EAAE;EAAY,CAAC,CAAC,CAC1D,CAAC;AACH;AAae,SAASQ,YAAYA,CAAC;EACnCf,IAAI;EACJgB;AAIF,CAAC,EAAE;EACD,OAAO,IAAAC,0BAAO,EAAC,CAACC,CAAC,EAAEC,OAAgB,KAAK;IACtC,MAAM;MACJC,IAAI,EAAEC,eAAe;MAErBC,gBAAgB,GAAG,IAAI;MAEvBC,MAAM;MAENhC,OAAO,EAAEiC,eAAe,GAEpBR,WAAW,GACT,WAAW,GACX,SAAS;MAEf1B,YAAY,EAAEmC,qBAAqB,GAAGpC,OAAO,CAACC,YAAY;MAC1DE,MAAM,EAAEkC,cAAc,GAAGrC,OAAO,CAACG,MAAM;MACvCC,UAAU,EAAEkC,mBAAmB,GAAGtC,OAAO,CAACI;IAC5C,CAAC,GAAG0B,OAAO;IA6BJ;MAEL,IAAI;QAAES,SAAS,GAAG,KAAK;QAAEC,WAAW,GAAG;MAAM,CAAC,GAAGV,OAAO;MAExD,IAAIK,eAAe,KAAK,SAAS,EAAE;QACjC,IAAI,OAAOI,SAAS,KAAK,SAAS,EAAE;UAClC,MAAM,IAAIE,KAAK,CACb,kEAAkE,GAChE,+BACJ,CAAC;QACH;QAEA,IAAI,OAAOD,WAAW,KAAK,SAAS,EAAE;UACpC,MAAM,IAAIC,KAAK,CACb,kEAAkE,GAChE,iCACJ,CAAC;QACH;QAEA,IAAIF,SAAS,IAAIC,WAAW,EAAE;UAC5B,MAAM,IAAIC,KAAK,CACb,sEAAsE,GACpE,cACJ,CAAC;QACH;MACF;IACF;IAEA,MAAMC,2BAAgD,GAAG;MACvDC,iBAAiBA,CAACC,IAAI,EAAEC,KAAK,EAAE;QAC7B,MAAMC,UAAU,GAAG,EAAE;QACrB,IAAIC,aAAa,CAACH,IAAI,CAACI,KAAK,CAAC,EAAE;UAC7BF,UAAU,CAACG,IAAI,CACb9B,WAAC,CAAC+B,YAAY,CACZ/B,WAAC,CAACgC,aAAa,CAAC,QAAQ,CAAC,EACzBhC,WAAC,CAACiC,sBAAsB,CAACjC,WAAC,CAACkC,cAAc,CAAC,CAAC,CAC7C,CACF,CAAC;QACH;QACAP,UAAU,CAACG,IAAI,CACb9B,WAAC,CAAC+B,YAAY,CACZ/B,WAAC,CAACgC,aAAa,CAAC,UAAU,CAAC,EAC3BhC,WAAC,CAACiC,sBAAsB,CAACE,UAAU,CAACV,IAAI,EAAEC,KAAK,CAAC,CAClD,CACF,CAAC;QACDD,IAAI,CAACW,aAAa,CAAC,YAAY,EAAET,UAAU,CAAC;MAC9C;IACF,CAAC;IAED,OAAO;MACLnC,IAAI;MACJ6C,QAAQ,EAAEC,wBAAG;MACbC,OAAO,EAAE;QACPC,iBAAiBA,CAACf,IAAI,EAAE;UACtB,IAAIX,gBAAgB,EAAE;YACpB,MAAMW,IAAI,CAACgB,mBAAmB,CAC5B;AACd,gEACY,CAAC;UACH;QACF,CAAC;QAEDC,cAAcA,CAACjB,IAAI,EAAE;UACnB,MAAMA,IAAI,CAACgB,mBAAmB,CAC5B,6CACF,CAAC;QACH,CAAC;QAEDE,OAAO,EAAE;UACPC,KAAKA,CAACnB,IAAI,EAAEC,KAAK,EAAE;YACjB,MAAM;cAAEmB;YAAK,CAAC,GAAGnB,KAAK;YACtB,IAAI3C,OAAe,GAAGiC,eAAe;YAErC,IAAI8B,MAAc,GAAG7B,qBAAqB;YAC1C,IAAIjC,MAAc,GAAGkC,cAAc;YACnC,IAAIjC,UAAkB,GAAGkC,mBAAmB;YAE5C,IAAI4B,SAAS,GAAG,CAAC,CAACpC,OAAO,CAAC7B,YAAY;YACtC,IAAIkE,SAAS,GAAG,CAAC,CAACrC,OAAO,CAAC3B,MAAM;YAChC,IAAIiE,aAAa,GAAG,CAAC,CAACtC,OAAO,CAAC1B,UAAU;YAExC,IAAI4D,IAAI,CAACK,GAAG,CAACC,QAAQ,EAAE;cACrB,KAAK,MAAMC,OAAO,IAAIP,IAAI,CAACK,GAAG,CAACC,QAAQ,EAAE;gBACvC,MAAME,aAAa,GAAGnE,2BAA2B,CAACoE,IAAI,CACpDF,OAAO,CAACrD,KACV,CAAC;gBACD,IAAIsD,aAAa,EAAE;kBACjBP,MAAM,GAAGO,aAAa,CAAC,CAAC,CAAC;kBACzBN,SAAS,GAAG,IAAI;gBAClB;gBAEA,MAAMQ,cAAc,GAAGpE,4BAA4B,CAACmE,IAAI,CACtDF,OAAO,CAACrD,KACV,CAAC;gBACD,IAAIwD,cAAc,EAAE;kBAClBxE,OAAO,GAAGwE,cAAc,CAAC,CAAC,CAAC;gBAC7B;gBAEA,MAAMC,UAAU,GAAGpE,oBAAoB,CAACkE,IAAI,CAACF,OAAO,CAACrD,KAAK,CAAC;gBAC3D,IAAIyD,UAAU,EAAE;kBACdxE,MAAM,GAAGwE,UAAU,CAAC,CAAC,CAAC;kBACtBR,SAAS,GAAG,IAAI;gBAClB;gBACA,MAAMS,cAAc,GAAGpE,yBAAyB,CAACiE,IAAI,CACnDF,OAAO,CAACrD,KACV,CAAC;gBACD,IAAI0D,cAAc,EAAE;kBAClBxE,UAAU,GAAGwE,cAAc,CAAC,CAAC,CAAC;kBAC9BR,aAAa,GAAG,IAAI;gBACtB;cACF;YACF;YAEAxD,GAAG,CAACiC,KAAK,EAAE,SAAS,EAAE3C,OAAO,CAAC;YAC9B,IAAIA,OAAO,KAAK,SAAS,EAAE;cACzB,IAAIgE,SAAS,EAAE;gBACb,MAAMtB,IAAI,CAACgB,mBAAmB,CAC5B,qDACF,CAAC;cACH;cAEA,MAAMiB,aAAa,GAAGC,kBAAkB,CAAC3E,MAAM,CAAC;cAChD,MAAM4E,QAAQ,GAAGD,kBAAkB,CAAC1E,UAAU,CAAC;cAE/CQ,GAAG,CAACiC,KAAK,EAAE,kBAAkB,EAAE,MAAM1B,WAAC,CAAC6D,SAAS,CAACH,aAAa,CAAC,CAAC;cAChEjE,GAAG,CAACiC,KAAK,EAAE,aAAa,EAAE,MAAM1B,WAAC,CAAC6D,SAAS,CAACD,QAAQ,CAAC,CAAC;cAEtDnE,GAAG,CAACiC,KAAK,EAAE,aAAa,EAAE1C,MAAM,KAAKH,OAAO,CAACG,MAAM,CAAC;YACtD,CAAC,MAAM,IAAID,OAAO,KAAK,WAAW,EAAE;cAClC,IAAIiE,SAAS,IAAIC,aAAa,EAAE;gBAC9B,MAAMxB,IAAI,CAACgB,mBAAmB,CAC5B,gEACF,CAAC;cACH;cAEA,MAAMqB,MAAM,GAAGA,CAACtE,IAAY,EAAEuE,EAAU,KACtCtE,GAAG,CAACiC,KAAK,EAAElC,IAAI,EAAEwE,kBAAkB,CAACtC,KAAK,EAAED,IAAI,EAAEsC,EAAE,EAAEjB,MAAM,CAAC,CAAC;cAE/DgB,MAAM,CAAC,QAAQ,EAAEtD,WAAW,GAAG,QAAQ,GAAG,KAAK,CAAC;cAChDsD,MAAM,CAAC,SAAS,EAAEtD,WAAW,GAAG,QAAQ,GAAG,MAAM,CAAC;cAClDsD,MAAM,CAAC,kBAAkB,EAAE,eAAe,CAAC;cAC3CA,MAAM,CAAC,aAAa,EAAE,UAAU,CAAC;cAEjCrE,GAAG,CAACiC,KAAK,EAAE,aAAa,EAAEoB,MAAM,KAAKjE,OAAO,CAACC,YAAY,CAAC;YAC5D,CAAC,MAAM;cACL,MAAM2C,IAAI,CAACgB,mBAAmB,CAC5B,kDACF,CAAC;YACH;YAEA,IAAIjC,WAAW,EAAE;cACfiB,IAAI,CAACwC,QAAQ,CAAC1C,2BAA2B,EAAEG,KAAK,CAAC;YACnD;UACF;QAkBF,CAAC;QAEDwC,WAAW,EAAE;UACXC,IAAIA,CAAC1C,IAAI,EAAEoB,IAAI,EAAE;YACf,IAAIuB,QAAQ;YACZ,IAAI9E,GAAG,CAACuD,IAAI,EAAE,SAAS,CAAC,KAAK,SAAS,EAAE;cACtCuB,QAAQ,GAAGC,8BAA8B,CAAC5C,IAAI,EAAEoB,IAAI,CAAC;YACvD,CAAC,MAAM;cACLuB,QAAQ,GAAGE,oBAAoB,CAAC7C,IAAI,EAAEoB,IAAI,CAAC;YAC7C;YAEApB,IAAI,CAAC8C,WAAW,CAACvE,WAAC,CAACqC,QAAQ,CAAC+B,QAAQ,EAAE3C,IAAI,CAAC7B,IAAI,CAAC,CAAC;UACnD;QACF,CAAC;QAED4E,UAAU,EAAE;UACVL,IAAIA,CAAC1C,IAAI,EAAEoB,IAAI,EAAE;YACf,IAAIuB,QAAQ;YACZ,IACE9E,GAAG,CAACuD,IAAI,EAAE,SAAS,CAAC,KAAK,SAAS,IAClC4B,sBAAsB,CAAChD,IAAI,CAAC,EAC5B;cACA2C,QAAQ,GAAGM,sBAAsB,CAACjD,IAAI,EAAEoB,IAAI,CAAC;YAC/C,CAAC,MAAM;cACLuB,QAAQ,GAAGO,mBAAmB,CAAClD,IAAI,EAAEoB,IAAI,CAAC;YAC5C;YAEApB,IAAI,CAAC8C,WAAW,CAACvE,WAAC,CAACqC,QAAQ,CAAC+B,QAAQ,EAAE3C,IAAI,CAAC7B,IAAI,CAAC,CAAC;UACnD;QACF,CAAC;QAEDgF,YAAYA,CAACnD,IAAI,EAAE;UACjB,IAAIzB,WAAC,CAAC6E,YAAY,CAACpD,IAAI,CAAC7B,IAAI,CAACG,KAAK,CAAC,EAAE;YACnC0B,IAAI,CAAC7B,IAAI,CAACG,KAAK,GAAGC,WAAC,CAACiC,sBAAsB,CAACR,IAAI,CAAC7B,IAAI,CAACG,KAAK,CAAC;UAC7D;QACF;MACF;IACF,CAAC;IAGD,SAAS+E,cAAcA,CAACC,SAA0B,EAAE;MAClD,OAAOA,SAAS,CAACnF,IAAI,CAACoF,UAAU,KAAK,IAAI;IAC3C;IAGA,SAASpD,aAAaA,CAACC,KAAY,EAAE;MAEnC,GAAG;QACD,MAAM;UAAEJ;QAAK,CAAC,GAAGI,KAAK;QACtB,IAAIJ,IAAI,CAACwD,gBAAgB,CAAC,CAAC,IAAI,CAACxD,IAAI,CAACyD,yBAAyB,CAAC,CAAC,EAAE;UAChE,IAAI,CAACzD,IAAI,CAAC0D,QAAQ,CAAC,CAAC,EAAE;YAEpB,OAAO,IAAI;UACb;UAEA,IAAI1D,IAAI,CAAC7B,IAAI,CAACwF,IAAI,KAAK,aAAa,EAAE;YAEpC,OAAO,IAAI;UACb;UAEA,OAAO,CAACN,cAAc,CAACrD,IAAI,CAAC4D,UAAU,CAACA,UAA6B,CAAC;QACvE;QACA,IAAI5D,IAAI,CAAC6D,eAAe,CAAC,CAAC,EAAE;UAE1B,OAAO,KAAK;QACd;MACF,CAAC,QAASzD,KAAK,GAAGA,KAAK,CAAC0D,MAAM;MAE9B,OAAO,IAAI;IACb;IAEA,SAASC,IAAIA,CACXjG,IAAgB,EAChBC,IAAY,EACZiG,IAAiC,EACjC;MACA,MAAM7F,IAAI,GAAGI,WAAC,CAAC0F,cAAc,CAACpG,GAAG,CAACC,IAAI,EAAE,MAAMC,IAAI,EAAE,CAAC,CAAC,CAAC,EAAEiG,IAAI,CAAC;MAC9D,IAAI5E,eAAe,WAAfA,eAAe,GAAIvB,GAAG,CAACC,IAAI,EAAE,aAAa,CAAC,EAAE,IAAAoG,6BAAc,EAAC/F,IAAI,CAAC;MACrE,OAAOA,IAAI;IACb;IAOA,SAAS6E,sBAAsBA,CAAChD,IAA0B,EAAE;MAC1D,MAAMmE,WAAW,GAAGnE,IAAI,CAACnC,GAAG,CAAC,gBAAgB,CAAC;MAC9C,MAAMqC,UAAU,GAAGiE,WAAW,CAAChG,IAAI,CAAC+B,UAAU;MAE9C,IAAIkE,eAAe,GAAG,KAAK;MAC3B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGnE,UAAU,CAACoE,MAAM,EAAED,CAAC,EAAE,EAAE;QAC1C,MAAME,IAAI,GAAGrE,UAAU,CAACmE,CAAC,CAAC;QAC1B,IACED,eAAe,IACf7F,WAAC,CAACiG,cAAc,CAACD,IAAI,CAAC,IACtBA,IAAI,CAACxG,IAAI,CAACA,IAAI,KAAK,KAAK,EACxB;UACA,OAAO,IAAI;QACb,CAAC,MAAM,IAAIQ,WAAC,CAACkG,oBAAoB,CAACF,IAAI,CAAC,EAAE;UACvCH,eAAe,GAAG,IAAI;QACxB;MACF;MACA,OAAO,KAAK;IACd;IAEA,SAASM,oBAAoBA,CAC3BvG,IAAmE,EACnE2F,MAAmD,EACqB;MACxE,IAAIvF,WAAC,CAACoG,eAAe,CAACxG,IAAI,CAAC,EAAE;QAC3B,IAAIA,IAAI,CAACJ,IAAI,KAAK,MAAM,IAAIQ,WAAC,CAACqG,YAAY,CAACzG,IAAI,EAAE2F,MAAM,CAAC,EAAE;UACxD,OAAOvF,WAAC,CAACkC,cAAc,CAAC,CAAC;QAC3B,CAAC,MAAM,IAAIlC,WAAC,CAACsG,iBAAiB,CAAC1G,IAAI,CAACJ,IAAI,EAAE,KAAK,CAAC,EAAE;UAEhDI,IAAI,CAAC2G,IAAI,GAAG,YAAY;UACxB,OAAO3G,IAAI;QACb,CAAC,MAAM;UACL,OAAOI,WAAC,CAACwG,aAAa,CAAC5G,IAAI,CAACJ,IAAI,CAAC;QACnC;MACF,CAAC,MAAM,IAAIQ,WAAC,CAACyG,qBAAqB,CAAC7G,IAAI,CAAC,EAAE;QACxC,OAAOI,WAAC,CAAC0G,gBAAgB,CACvBP,oBAAoB,CAACvG,IAAI,CAAC+G,MAAM,EAAE/G,IAAI,CAAC,EACvCuG,oBAAoB,CAACvG,IAAI,CAACgH,QAAQ,EAAEhH,IAAI,CAC1C,CAAC;MACH,CAAC,MAAM,IAAII,WAAC,CAAC6G,mBAAmB,CAACjH,IAAI,CAAC,EAAE;QAKtC,OAAOI,WAAC,CAACwG,aAAa,CAAC,GAAG5G,IAAI,CAACkH,SAAS,CAACtH,IAAI,IAAII,IAAI,CAACJ,IAAI,CAACA,IAAI,EAAE,CAAC;MACpE;MAGA,OAAOI,IAAI;IACb;IAEA,SAASmH,qBAAqBA,CAC5BnH,IAAgD,EAChD;MACA,IAAII,WAAC,CAACgH,wBAAwB,CAACpH,IAAI,CAAC,EAAE;QACpC,OAAOA,IAAI,CAACqH,UAAU;MACxB,CAAC,MAAM;QACL,OAAOrH,IAAI;MACb;IACF;IAEA,SAASsH,mBAAmBA,CAC1BC,KAAqC,EACrCC,SAAsD,EACtD;MACA,IAAIpH,WAAC,CAACkG,oBAAoB,CAACkB,SAAS,CAACxH,IAAI,CAAC,EAAE;QAC1C,MAAMyH,GAAG,GAAGD,SAAS,CAACxH,IAAI,CAAC0H,QAAQ;QAEnC,IAAItH,WAAC,CAACuH,kBAAkB,CAACF,GAAG,CAAC,IAAI,CAAC1H,QAAQ,CAAC0H,GAAG,CAAC,EAAE;UAC/CF,KAAK,CAACrF,IAAI,CAAC,GAAGuF,GAAG,CAACxH,UAAU,CAAC;QAC/B,CAAC,MAAM;UACLsH,KAAK,CAACrF,IAAI,CAAC9B,WAAC,CAACwH,aAAa,CAACH,GAAG,CAAC,CAAC;QAClC;QACA,OAAOF,KAAK;MACd;MAEA,MAAMpH,KAAK,GAAGgH,qBAAqB,CACjCK,SAAS,CAACxH,IAAI,CAACJ,IAAI,CAACA,IAAI,KAAK,KAAK,GAC9B4H,SAAS,CAACxH,IAAI,CAACG,KAAK,IAAIC,WAAC,CAACyH,cAAc,CAAC,IAAI,CAAC,GAC9CL,SAAS,CAACxH,IAAI,CAACG,KACrB,CAAC;MAED,IAAIqH,SAAS,CAACxH,IAAI,CAACJ,IAAI,CAACA,IAAI,KAAK,KAAK,IAAIO,KAAK,KAAK,IAAI,EAAE;QACxD,MAAMqH,SAAS,CAAC3E,mBAAmB,CACjC,mGACF,CAAC;MACH;MAEA,IACEzC,WAAC,CAACM,eAAe,CAACP,KAAK,CAAC,IACxB,CAACC,WAAC,CAACgH,wBAAwB,CAACI,SAAS,CAACxH,IAAI,CAACG,KAAK,CAAC,EACjD;QAAA,IAAA2H,YAAA;QACA3H,KAAK,CAACA,KAAK,GAAGA,KAAK,CAACA,KAAK,CAAC4H,OAAO,CAAC,QAAQ,EAAE,GAAG,CAAC;QAGhD,CAAAD,YAAA,GAAO3H,KAAK,CAAC6H,KAAK,aAAlB,OAAOF,YAAA,CAAaG,GAAG;MACzB;MAEA,IAAI7H,WAAC,CAAC6G,mBAAmB,CAACO,SAAS,CAACxH,IAAI,CAACJ,IAAI,CAAC,EAAE;QAE9C4H,SAAS,CAACxH,IAAI,CAACJ,IAAI,GAAGQ,WAAC,CAACwG,aAAa,CACnCY,SAAS,CAACxH,IAAI,CAACJ,IAAI,CAACsH,SAAS,CAACtH,IAAI,GAChC,GAAG,GACH4H,SAAS,CAACxH,IAAI,CAACJ,IAAI,CAACA,IAAI,CAACA,IAC7B,CAAC;MACH,CAAC,MAAM,IAAIQ,WAAC,CAACsG,iBAAiB,CAACc,SAAS,CAACxH,IAAI,CAACJ,IAAI,CAACA,IAAI,EAAE,KAAK,CAAC,EAAE;QAE/D4H,SAAS,CAACxH,IAAI,CAACJ,IAAI,CAAC+G,IAAI,GAAG,YAAY;MACzC,CAAC,MAAM;QAELa,SAAS,CAACxH,IAAI,CAACJ,IAAI,GAAGQ,WAAC,CAACwG,aAAa,CAACY,SAAS,CAACxH,IAAI,CAACJ,IAAI,CAACA,IAAI,CAAC;MACjE;MAEA2H,KAAK,CAACrF,IAAI,CACR9B,WAAC,CAACqC,QAAQ,CACRrC,WAAC,CAAC8H,cAAc,CAEdV,SAAS,CAACxH,IAAI,CAACJ,IAAI,EACnBO,KACF,CAAC,EACDqH,SAAS,CAACxH,IACZ,CACF,CAAC;MACD,OAAOuH,KAAK;IACd;IAEA,SAASY,qBAAqBA,CAACC,QAAsB,EAAE;MACrD,IAAIC,YAAY;MAChB,IAAID,QAAQ,CAACjC,MAAM,KAAK,CAAC,EAAE;QACzBkC,YAAY,GAAGD,QAAQ,CAAC,CAAC,CAAC;MAC5B,CAAC,MAAM,IAAIA,QAAQ,CAACjC,MAAM,GAAG,CAAC,EAAE;QAC9BkC,YAAY,GAAGjI,WAAC,CAACkI,eAAe,CAACF,QAAQ,CAAC;MAC5C,CAAC,MAAM;QACL,OAAOG,SAAS;MAClB;MAEA,OAAOnI,WAAC,CAAC8H,cAAc,CAAC9H,WAAC,CAACoI,UAAU,CAAC,UAAU,CAAC,EAAEH,YAAY,CAAC;IACjE;IAKA,SAAStD,mBAAmBA,CAAClD,IAA0B,EAAEoB,IAAgB,EAAE;MACzE,MAAM+C,WAAW,GAAGnE,IAAI,CAACnC,GAAG,CAAC,gBAAgB,CAAC;MAC9C,MAAMmG,IAAoB,GAAG,CAAC4C,MAAM,CAACzC,WAAW,CAAC,CAAC;MAElD,MAAM0C,YAAY,GAAG,EAAE;MACvB,MAAMC,SAAS,GAAGC,MAAM,CAACC,MAAM,CAAC,IAAI,CAAC;MAMrC,KAAK,MAAMzC,IAAI,IAAIJ,WAAW,CAACtG,GAAG,CAAC,YAAY,CAAC,EAAE;QAChD,IAAI0G,IAAI,CAACC,cAAc,CAAC,CAAC,IAAIjG,WAAC,CAACoG,eAAe,CAACJ,IAAI,CAACpG,IAAI,CAACJ,IAAI,CAAC,EAAE;UAC9D,MAAM;YAAEA;UAAK,CAAC,GAAGwG,IAAI,CAACpG,IAAI,CAACJ,IAAI;UAC/B,QAAQA,IAAI;YACV,KAAK,UAAU;YACf,KAAK,QAAQ;cACX,IAAI+I,SAAS,CAAC/I,IAAI,CAAC,EAAE,MAAMkJ,eAAe,CAACjH,IAAI,EAAEjC,IAAI,CAAC;YAExD,KAAK,KAAK;cAAE;gBACV,MAAMmJ,QAAQ,GAAG5B,qBAAqB,CAACf,IAAI,CAACpG,IAAI,CAACG,KAAK,CAAC;gBACvD,IAAI4I,QAAQ,KAAK,IAAI,EAAE;kBACrB,MAAM3C,IAAI,CAACvD,mBAAmB,CAC5B,mGACF,CAAC;gBACH;gBAEA8F,SAAS,CAAC/I,IAAI,CAAC,GAAGmJ,QAAQ;gBAC1B;cACF;YACA;cACEL,YAAY,CAACxG,IAAI,CAACkE,IAAI,CAAC;UAC3B;QACF,CAAC,MAAM;UACLsC,YAAY,CAACxG,IAAI,CAACkE,IAAI,CAAC;QACzB;MACF;MAEA,MAAMgC,QAAQ,GAAGhI,WAAC,CAAC4I,KAAK,CAACC,aAAa,CAACpH,IAAI,CAAC7B,IAAI,CAAC;MAEjD,IAAIkJ,OAA2B;MAE/B,IAAIR,YAAY,CAACvC,MAAM,IAAIiC,QAAQ,CAACjC,MAAM,EAAE;QAC1C+C,OAAO,GAAGC,gCAAgC,CACxCT,YAAY,EAGZN,QACF,CAAC;MACH,CAAC,MAAM;QAELc,OAAO,GAAG9I,WAAC,CAACgJ,gBAAgB,CAAC,EAAE,CAAC;MAClC;MAEAvD,IAAI,CAAC3D,IAAI,CAACgH,OAAO,CAAC;MAElB,IAAItI,WAAW,EAAE;QAAA,IAAAyI,cAAA;QAIfxD,IAAI,CAAC3D,IAAI,EAAAmH,cAAA,GACPV,SAAS,CAAClI,GAAG,YAAA4I,cAAA,GAAIxH,IAAI,CAACI,KAAK,CAACqH,kBAAkB,CAAC,CAAC,EAChDlJ,WAAC,CAACyH,cAAc,CAACO,QAAQ,CAACjC,MAAM,GAAG,CAAC,CACtC,CAAC;QACD,IAAIwC,SAAS,CAACY,QAAQ,EAAE;UACtB1D,IAAI,CAAC3D,IAAI,CAACyG,SAAS,CAACY,QAAQ,CAAC;UAC7B,IAAIZ,SAAS,CAACa,MAAM,EAAE3D,IAAI,CAAC3D,IAAI,CAACyG,SAAS,CAACa,MAAM,CAAC;QACnD,CAAC,MAAM,IAAIb,SAAS,CAACa,MAAM,EAAE;UAC3B3D,IAAI,CAAC3D,IAAI,CAACL,IAAI,CAACI,KAAK,CAACqH,kBAAkB,CAAC,CAAC,EAAEX,SAAS,CAACa,MAAM,CAAC;QAC9D;MACF,CAAC,MAAM,IAAIb,SAAS,CAAClI,GAAG,KAAK8H,SAAS,EAAE;QACtC1C,IAAI,CAAC3D,IAAI,CAACyG,SAAS,CAAClI,GAAG,CAAC;MAC1B;MAEA,OAAOmF,IAAI,CAAC3C,IAAI,EAAEmF,QAAQ,CAACjC,MAAM,GAAG,CAAC,GAAG,MAAM,GAAG,KAAK,EAAEN,IAAI,CAAC;IAC/D;IAIA,SAASsD,gCAAgCA,CACvCD,OAAsD,EACtDd,QAAsB,EACtB;MACA,MAAMqB,KAAK,GAAGP,OAAO,CAACQ,MAAM,CAACpC,mBAAmB,EAAE,EAAE,CAAC;MAIrD,IAAI,CAAAc,QAAQ,oBAARA,QAAQ,CAAEjC,MAAM,IAAG,CAAC,EAAE;QACxBsD,KAAK,CAACvH,IAAI,CAACiG,qBAAqB,CAACC,QAAQ,CAAC,CAAC;MAC7C;MAEA,OAAOhI,WAAC,CAACgJ,gBAAgB,CAACK,KAAK,CAAC;IAClC;IAKA,SAAS/E,oBAAoBA,CAC3B7C,IAA2B,EAC3BoB,IAAgB,EAChB;MACA,MAAM4C,IAAI,GAAG,CAACnG,GAAG,CAACuD,IAAI,EAAE,aAAa,CAAC,CAAC,CAAC,CAAC;MAEzC,MAAMmF,QAAQ,GAAGhI,WAAC,CAAC4I,KAAK,CAACC,aAAa,CAACpH,IAAI,CAAC7B,IAAI,CAAC;MAEjD6F,IAAI,CAAC3D,IAAI,CACP9B,WAAC,CAACgJ,gBAAgB,CAChBhB,QAAQ,CAACjC,MAAM,GAAG,CAAC,GACf,CACEgC,qBAAqB,CAGnBC,QACF,CAAC,CACF,GACD,EACN,CACF,CAAC;MAED,IAAIxH,WAAW,EAAE;QACfiF,IAAI,CAAC3D,IAAI,CACPL,IAAI,CAACI,KAAK,CAACqH,kBAAkB,CAAC,CAAC,EAC/BlJ,WAAC,CAACyH,cAAc,CAACO,QAAQ,CAACjC,MAAM,GAAG,CAAC,CACtC,CAAC;MACH;MAEA,OAAOP,IAAI,CAAC3C,IAAI,EAAEmF,QAAQ,CAACjC,MAAM,GAAG,CAAC,GAAG,MAAM,GAAG,KAAK,EAAEN,IAAI,CAAC;IAC/D;IAIA,SAASpB,8BAA8BA,CACrC5C,IAA2B,EAC3BoB,IAAgB,EAChB;MACA,IAAI9B,MAAM,IAAI,CAACA,MAAM,CAACU,IAAI,CAAC7B,IAAI,EAAEiD,IAAI,CAAC,EAAE;MAExC,OAAO2C,IAAI,CAAC3C,IAAI,EAAE,eAAe,EAAE,CACjCvD,GAAG,CAACuD,IAAI,EAAE,aAAa,CAAC,CAAC,CAAC,EAC1B7C,WAAC,CAACuJ,WAAW,CAAC,CAAC,EACf,GAAGvJ,WAAC,CAAC4I,KAAK,CAACC,aAAa,CAACpH,IAAI,CAAC7B,IAAI,CAAC,CACpC,CAAC;IACJ;IAKA,SAAS8E,sBAAsBA,CAC7BjD,IAA0B,EAC1BoB,IAAgB,EAChB;MACA,MAAM+C,WAAW,GAAGnE,IAAI,CAACnC,GAAG,CAAC,gBAAgB,CAAC;MAE9C,OAAOkG,IAAI,CAAC3C,IAAI,EAAE,eAAe,EAAE,CACjCwF,MAAM,CAACzC,WAAW,CAAC,EACnB4D,0CAA0C,CACxC3G,IAAI,EACJpB,IAAI,EACJmE,WAAW,CAACtG,GAAG,CAAC,YAAY,CAC9B,CAAC,EAED,GAAGU,WAAC,CAAC4I,KAAK,CAACC,aAAa,CAACpH,IAAI,CAAC7B,IAAI,CAAC,CACpC,CAAC;IACJ;IAEA,SAASyI,MAAMA,CAACzC,WAAwC,EAAE;MACxD,MAAM6D,OAAO,GAAGtD,oBAAoB,CAClCP,WAAW,CAAChG,IAAI,CAACJ,IAAI,EACrBoG,WAAW,CAAChG,IACd,CAAC;MAED,IAAI8J,OAAe;MACnB,IAAI1J,WAAC,CAACI,YAAY,CAACqJ,OAAO,CAAC,EAAE;QAC3BC,OAAO,GAAGD,OAAO,CAACjK,IAAI;MACxB,CAAC,MAAM,IAAIQ,WAAC,CAACM,eAAe,CAACmJ,OAAO,CAAC,EAAE;QACrCC,OAAO,GAAGD,OAAO,CAAC1J,KAAK;MACzB;MAEA,IAAIC,WAAC,CAAC4I,KAAK,CAACe,WAAW,CAACD,OAAO,CAAC,EAAE;QAChC,OAAO1J,WAAC,CAACwG,aAAa,CAACkD,OAAO,CAAC;MACjC,CAAC,MAAM;QACL,OAAOD,OAAO;MAChB;IACF;IAQA,SAASD,0CAA0CA,CACjD3G,IAAgB,EAChBpB,IAA0B,EAC1BqH,OAAsD,EACtD;MACA,MAAM/J,OAAO,GAAGO,GAAG,CAACuD,IAAI,EAAE,SAAS,CAAC;MACD;QACjC,IAAI9D,OAAO,KAAK,WAAW,EAAE;UAC3B,MAAM6K,IAAI,GAAG,EAAE;UACf,MAAMP,KAAK,GAAGP,OAAO,CAACQ,MAAM,CAACpC,mBAAmB,EAAE,EAAE,CAAC;UAErD,IAAI,CAAC9F,SAAS,EAAE;YAEd,IAAIyI,KAAK,GAAG,CAAC;YACbR,KAAK,CAACS,OAAO,CAAC,CAACC,IAAI,EAAEjE,CAAC,KAAK;cACzB,IAAI9F,WAAC,CAACgK,eAAe,CAACD,IAAI,CAAC,EAAE;gBAC3B,IAAIjE,CAAC,GAAG+D,KAAK,EAAE;kBACbD,IAAI,CAAC9H,IAAI,CAAC9B,WAAC,CAACgJ,gBAAgB,CAACK,KAAK,CAACY,KAAK,CAACJ,KAAK,EAAE/D,CAAC,CAAC,CAAC,CAAC;gBACtD;gBACA8D,IAAI,CAAC9H,IAAI,CAACiI,IAAI,CAACzC,QAAQ,CAAC;gBACxBuC,KAAK,GAAG/D,CAAC,GAAG,CAAC;cACf;YACF,CAAC,CAAC;YACF,IAAIuD,KAAK,CAACtD,MAAM,GAAG8D,KAAK,EAAE;cACxBD,IAAI,CAAC9H,IAAI,CAAC9B,WAAC,CAACgJ,gBAAgB,CAACK,KAAK,CAACY,KAAK,CAACJ,KAAK,CAAC,CAAC,CAAC;YACnD;UACF,CAAC,MAAM,IAAIR,KAAK,CAACtD,MAAM,EAAE;YACvB6D,IAAI,CAAC9H,IAAI,CAAC9B,WAAC,CAACgJ,gBAAgB,CAACK,KAAK,CAAC,CAAC;UACtC;UAEA,IAAI,CAACO,IAAI,CAAC7D,MAAM,EAAE;YAChB,OAAO/F,WAAC,CAACuJ,WAAW,CAAC,CAAC;UACxB;UAEA,IAAIK,IAAI,CAAC7D,MAAM,KAAK,CAAC,EAAE;YACrB,IACE,EACE/F,WAAC,CAACgK,eAAe,CAACX,KAAK,CAAC,CAAC,CAAC,CAAC,IAI3BrJ,WAAC,CAACuH,kBAAkB,CAAC8B,KAAK,CAAC,CAAC,CAAC,CAAC/B,QAAQ,CAAC,CACxC,EACD;cACA,OAAOsC,IAAI,CAAC,CAAC,CAAC;YAChB;UACF;UAGA,IAAI,CAAC5J,WAAC,CAACuH,kBAAkB,CAACqC,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE;YAClCA,IAAI,CAACM,OAAO,CAAClK,WAAC,CAACgJ,gBAAgB,CAAC,EAAE,CAAC,CAAC;UACtC;UAEA,MAAMmB,MAAM,GAAG9I,WAAW,GACtBrB,WAAC,CAAC0G,gBAAgB,CAAC1G,WAAC,CAACoI,UAAU,CAAC,QAAQ,CAAC,EAAEpI,WAAC,CAACoI,UAAU,CAAC,QAAQ,CAAC,CAAC,GAClEvF,IAAI,CAACuH,SAAS,CAAC,SAAS,CAAC;UAG7B,OAAOpK,WAAC,CAAC0F,cAAc,CAACyE,MAAM,EAAEP,IAAI,CAAC;QACvC;MACF;MAEA,MAAMP,KAAqC,GAAG,EAAE;MAChD,MAAMgB,KAAK,GAAG7B,MAAM,CAACC,MAAM,CAAC,IAAI,CAAC;MAEjC,KAAK,MAAMzC,IAAI,IAAI8C,OAAO,EAAE;QAC1B,MAAM;UAAElJ;QAAK,CAAC,GAAGoG,IAAI;QACrB,MAAMxG,IAAI,GACRQ,WAAC,CAACiG,cAAc,CAACrG,IAAI,CAAC,IACtBI,WAAC,CAACoG,eAAe,CAACxG,IAAI,CAACJ,IAAI,CAAC,IAC5BI,IAAI,CAACJ,IAAI,CAACA,IAAI;QAEhB,IACET,OAAO,KAAK,WAAW,KACtBS,IAAI,KAAK,UAAU,IAAIA,IAAI,KAAK,QAAQ,CAAC,EAC1C;UACA,IAAI6K,KAAK,CAAC7K,IAAI,CAAC,EAAE,MAAMkJ,eAAe,CAACjH,IAAI,EAAEjC,IAAI,CAAC;UAClD6K,KAAK,CAAC7K,IAAI,CAAC,GAAG,IAAI;QACpB;QAEA0H,mBAAmB,CAACmC,KAAK,EAAErD,IAAI,CAAC;MAClC;MAEA,OAAOqD,KAAK,CAACtD,MAAM,KAAK,CAAC,IACvB/F,WAAC,CAACgK,eAAe,CAACX,KAAK,CAAC,CAAC,CAAC,CAAC,IAI3B,CAACrJ,WAAC,CAACuH,kBAAkB,CAAC8B,KAAK,CAAC,CAAC,CAAC,CAAC/B,QAAQ,CAAC,GACtC+B,KAAK,CAAC,CAAC,CAAC,CAAC/B,QAAQ,GACjB+B,KAAK,CAACtD,MAAM,GAAG,CAAC,GACd/F,WAAC,CAACgJ,gBAAgB,CAACK,KAAK,CAAC,GACzBrJ,WAAC,CAACuJ,WAAW,CAAC,CAAC;IACvB;EACF,CAAC,CAAC;EAEF,SAASe,SAASA,CAACxH,MAAc,EAAEyH,UAAkB,EAAE;IACrD,QAAQA,UAAU;MAChB,KAAK,UAAU;QACb,OAAO,GAAGzH,MAAM,IAAItC,WAAW,GAAG,iBAAiB,GAAG,aAAa,EAAE;MACvE,KAAK,QAAQ;QACX,OAAO,GAAGsC,MAAM,kBAAkB;MACpC,KAAK,KAAK;MACV,KAAK,MAAM;QACT,OAAO,GAAGA,MAAM,cAAc;MAChC,KAAK,eAAe;QAClB,OAAOA,MAAM;IACjB;EACF;EAEA,SAASkB,kBAAkBA,CACzBzE,IAAgB,EAChBkC,IAAuB,EACvB8I,UAAkB,EAClBzH,MAAc,EACuB;IACrC,OAAO,MAAM;MACX,MAAM0H,YAAY,GAAGF,SAAS,CAACxH,MAAM,EAAEyH,UAAU,CAAC;MAClD,IAAI,IAAAE,6BAAQ,EAAChJ,IAAI,CAAC,EAAE;QAClB,IAAIiJ,SAAS,GAAGpL,GAAG,CAACC,IAAI,EAAE,WAAWgL,UAAU,EAAE,CAAC;QAClD,IAAIG,SAAS,EAAE,OAAO1K,WAAC,CAAC6D,SAAS,CAAC6G,SAAS,CAAC;QAE5CA,SAAS,GAAG,IAAAC,6BAAQ,EAAClJ,IAAI,EAAE8I,UAAU,EAAEC,YAAY,EAAE;UACnDI,eAAe,EAAE,YAAY;UAC7BC,cAAc,EAAE;QAClB,CAAC,CAAC;QACFpL,GAAG,CAACF,IAAI,EAAE,WAAWgL,UAAU,EAAE,EAAEG,SAAS,CAAC;QAE7C,OAAOA,SAAS;MAClB,CAAC,MAAM;QACL,IAAIA,SAAS,GAAGpL,GAAG,CAACC,IAAI,EAAE,YAAYiL,YAAY,EAAE,CAAC;QACrD,IAAIE,SAAS,EAAE;UACbA,SAAS,GAAG1K,WAAC,CAAC6D,SAAS,CAAC6G,SAAS,CAAC;QACpC,CAAC,MAAM;UACLA,SAAS,GAAG,IAAAI,iCAAY,EAACrJ,IAAI,EAAE+I,YAAY,EAAE;YAC3CI,eAAe,EAAE;UACnB,CAAC,CAAC;UACFnL,GAAG,CAACF,IAAI,EAAE,YAAYiL,YAAY,EAAE,EAAEE,SAAS,CAAC;QAClD;QAEA,OAAO1K,WAAC,CAAC0G,gBAAgB,CAACgE,SAAS,EAAE1K,WAAC,CAACoI,UAAU,CAACmC,UAAU,CAAC,CAAC;MAChE;IACF,CAAC;EACH;AACF;AAEA,SAAS5G,kBAAkBA,CAACI,EAAU,EAAiC;EACrE,OACEA,EAAE,CACCgH,KAAK,CAAC,GAAG,CAAC,CACVC,GAAG,CAACxL,IAAI,IAAIQ,WAAC,CAACoI,UAAU,CAAC5I,IAAI,CAAC,CAAC,CAG/B8J,MAAM,CAAC,CAAC3C,MAAM,EAAEC,QAAQ,KAAK5G,WAAC,CAAC0G,gBAAgB,CAACC,MAAM,EAAEC,QAAQ,CAAC,CAAC;AAEzE;AAEA,SAASzE,UAAUA,CAACV,IAAc,EAAEC,KAAiB,EAAE;EACrD,MAAMuJ,QAAQ,GAAGxJ,IAAI,CAAC7B,IAAI,CAACsL,GAAG;EAC9B,IAAI,CAACD,QAAQ,EAAE;IAEb,OAAOxJ,IAAI,CAACI,KAAK,CAACqH,kBAAkB,CAAC,CAAC;EACxC;EAGA,IAAI,CAACxH,KAAK,CAACyJ,kBAAkB,EAAE;IAC7B,MAAM;MAAEC,QAAQ,GAAG;IAAG,CAAC,GAAG1J,KAAK;IAE/B,MAAMyJ,kBAAkB,GAAG1J,IAAI,CAACI,KAAK,CAACwJ,qBAAqB,CAAC,cAAc,CAAC;IAC3E5J,IAAI,CAACI,KAAK,CAACyJ,gBAAgB,CAAC,CAAC,CAACxJ,IAAI,CAAC;MACjCiC,EAAE,EAAEoH,kBAAkB;MACtBI,IAAI,EAAEvL,WAAC,CAACwG,aAAa,CAAC4E,QAAQ;IAChC,CAAC,CAAC;IAEF1J,KAAK,CAACyJ,kBAAkB,GAAGA,kBAAkB;EAC/C;EAEA,OAAOK,SAAS,CACdxL,WAAC,CAAC6D,SAAS,CAETnC,KAAK,CAACyJ,kBACR,CAAC,EACDF,QAAQ,CAACpB,KAAK,CAAC4B,IAAI,EACnBR,QAAQ,CAACpB,KAAK,CAAC6B,MACjB,CAAC;AACH;AAEA,SAASF,SAASA,CAChBL,kBAA8B,EAC9BQ,UAAmB,EACnBC,YAAqB,EACrB;EACA,MAAMC,eAAe,GACnBF,UAAU,IAAI,IAAI,GAAG3L,WAAC,CAAC8L,cAAc,CAACH,UAAU,CAAC,GAAG3L,WAAC,CAACuJ,WAAW,CAAC,CAAC;EAErE,MAAMwC,iBAAiB,GACrBH,YAAY,IAAI,IAAI,GAAG5L,WAAC,CAAC8L,cAAc,CAACF,YAAY,GAAG,CAAC,CAAC,GAAG5L,WAAC,CAACuJ,WAAW,CAAC,CAAC;EAE7E,OAAOyC,cAAQ,CAAC/E,UAAU,CAAC/D,GAAG;AAChC,gBAAgBiI,kBAAkB;AAClC,kBAAkBU,eAAe;AACjC,oBAAoBE,iBAAiB;AACrC,IAAI;AACJ;AAEA,SAASrD,eAAeA,CAACjH,IAAc,EAAEjC,IAAY,EAAE;EACrD,MAAMyM,UAAU,GAAG,uBAAuBzM,IAAI,CAACyK,KAAK,CAAC,CAAC,CAAC,EAAE;EAEzD,OAAOxI,IAAI,CAACgB,mBAAmB,CAC7B,aAAajD,IAAI,yDAAyDyM,UAAU,+LACtF,CAAC;AACH&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[]}</span></pre>
</body>
</html>