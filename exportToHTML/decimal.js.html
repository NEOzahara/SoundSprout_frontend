<html>
<head>
<title>decimal.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #cf8e6d;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #7a7e85;}
.s5 { color: #2aacb8;}
.s6 { color: #42c3d4;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
decimal.js</font>
</center></td></tr></table>
<pre><span class="s0">;(</span><span class="s1">function </span><span class="s0">(</span><span class="s2">globalScope</span><span class="s0">) {</span>
  <span class="s3">'use strict'</span><span class="s0">;</span>


  <span class="s4">/*! 
   *  decimal.js v10.5.0 
   *  An arbitrary-precision Decimal type for JavaScript. 
   *  https://github.com/MikeMcl/decimal.js 
   *  Copyright (c) 2025 Michael Mclaughlin &lt;M8ch88l@gmail.com&gt; 
   *  MIT Licence 
   */</span>


  <span class="s4">// -----------------------------------  EDITABLE DEFAULTS  ------------------------------------ //</span>


    <span class="s4">// The maximum exponent magnitude.</span>
    <span class="s4">// The limit on the value of `toExpNeg`, `toExpPos`, `minE` and `maxE`.</span>
  <span class="s1">var </span><span class="s2">EXP_LIMIT </span><span class="s0">= </span><span class="s5">9e15</span><span class="s0">,                      </span><span class="s4">// 0 to 9e15</span>

    <span class="s4">// The limit on the value of `precision`, and on the value of the first argument to</span>
    <span class="s4">// `toDecimalPlaces`, `toExponential`, `toFixed`, `toPrecision` and `toSignificantDigits`.</span>
    <span class="s2">MAX_DIGITS </span><span class="s0">= </span><span class="s5">1e9</span><span class="s0">,                        </span><span class="s4">// 0 to 1e9</span>

    <span class="s4">// Base conversion alphabet.</span>
    <span class="s2">NUMERALS </span><span class="s0">= </span><span class="s3">'0123456789abcdef'</span><span class="s0">,</span>

    <span class="s4">// The natural logarithm of 10 (1025 digits).</span>
    <span class="s2">LN10 </span><span class="s0">= </span><span class="s3">'2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058'</span><span class="s0">,</span>

    <span class="s4">// Pi (1025 digits).</span>
    <span class="s2">PI </span><span class="s0">= </span><span class="s3">'3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789'</span><span class="s0">,</span>


    <span class="s4">// The initial configuration properties of the Decimal constructor.</span>
    <span class="s2">DEFAULTS </span><span class="s0">= {</span>

      <span class="s4">// These values must be integers within the stated ranges (inclusive).</span>
      <span class="s4">// Most of these values can be changed at run-time using the `Decimal.config` method.</span>

      <span class="s4">// The maximum number of significant digits of the result of a calculation or base conversion.</span>
      <span class="s4">// E.g. `Decimal.config({ precision: 20 });`</span>
      <span class="s2">precision</span><span class="s0">: </span><span class="s5">20</span><span class="s0">,                         </span><span class="s4">// 1 to MAX_DIGITS</span>

      <span class="s4">// The rounding mode used when rounding to `precision`.</span>
      <span class="s4">//</span>
      <span class="s4">// ROUND_UP         0 Away from zero.</span>
      <span class="s4">// ROUND_DOWN       1 Towards zero.</span>
      <span class="s4">// ROUND_CEIL       2 Towards +Infinity.</span>
      <span class="s4">// ROUND_FLOOR      3 Towards -Infinity.</span>
      <span class="s4">// ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.</span>
      <span class="s4">// ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.</span>
      <span class="s4">// ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.</span>
      <span class="s4">// ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.</span>
      <span class="s4">// ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.</span>
      <span class="s4">//</span>
      <span class="s4">// E.g.</span>
      <span class="s4">// `Decimal.rounding = 4;`</span>
      <span class="s4">// `Decimal.rounding = Decimal.ROUND_HALF_UP;`</span>
      <span class="s2">rounding</span><span class="s0">: </span><span class="s5">4</span><span class="s0">,                           </span><span class="s4">// 0 to 8</span>

      <span class="s4">// The modulo mode used when calculating the modulus: a mod n.</span>
      <span class="s4">// The quotient (q = a / n) is calculated according to the corresponding rounding mode.</span>
      <span class="s4">// The remainder (r) is calculated as: r = a - n * q.</span>
      <span class="s4">//</span>
      <span class="s4">// UP         0 The remainder is positive if the dividend is negative, else is negative.</span>
      <span class="s4">// DOWN       1 The remainder has the same sign as the dividend (JavaScript %).</span>
      <span class="s4">// FLOOR      3 The remainder has the same sign as the divisor (Python %).</span>
      <span class="s4">// HALF_EVEN  6 The IEEE 754 remainder function.</span>
      <span class="s4">// EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.</span>
      <span class="s4">//</span>
      <span class="s4">// Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian</span>
      <span class="s4">// division (9) are commonly used for the modulus operation. The other rounding modes can also</span>
      <span class="s4">// be used, but they may not give useful results.</span>
      <span class="s2">modulo</span><span class="s0">: </span><span class="s5">1</span><span class="s0">,                             </span><span class="s4">// 0 to 9</span>

      <span class="s4">// The exponent value at and beneath which `toString` returns exponential notation.</span>
      <span class="s4">// JavaScript numbers: -7</span>
      <span class="s2">toExpNeg</span><span class="s0">: -</span><span class="s5">7</span><span class="s0">,                          </span><span class="s4">// 0 to -EXP_LIMIT</span>

      <span class="s4">// The exponent value at and above which `toString` returns exponential notation.</span>
      <span class="s4">// JavaScript numbers: 21</span>
      <span class="s2">toExpPos</span><span class="s0">:  </span><span class="s5">21</span><span class="s0">,                         </span><span class="s4">// 0 to EXP_LIMIT</span>

      <span class="s4">// The minimum exponent value, beneath which underflow to zero occurs.</span>
      <span class="s4">// JavaScript numbers: -324  (5e-324)</span>
      <span class="s2">minE</span><span class="s0">: -</span><span class="s2">EXP_LIMIT</span><span class="s0">,                      </span><span class="s4">// -1 to -EXP_LIMIT</span>

      <span class="s4">// The maximum exponent value, above which overflow to Infinity occurs.</span>
      <span class="s4">// JavaScript numbers: 308  (1.7976931348623157e+308)</span>
      <span class="s2">maxE</span><span class="s0">: </span><span class="s2">EXP_LIMIT</span><span class="s0">,                       </span><span class="s4">// 1 to EXP_LIMIT</span>

      <span class="s4">// Whether to use cryptographically-secure random number generation, if available.</span>
      <span class="s2">crypto</span><span class="s0">: </span><span class="s1">false                          </span><span class="s4">// true/false</span>
    <span class="s0">},</span>


  <span class="s4">// ----------------------------------- END OF EDITABLE DEFAULTS ------------------------------- //</span>


    <span class="s2">Decimal</span><span class="s0">, </span><span class="s2">inexact</span><span class="s0">, </span><span class="s2">noConflict</span><span class="s0">, </span><span class="s2">quadrant</span><span class="s0">,</span>
    <span class="s2">external </span><span class="s0">= </span><span class="s1">true</span><span class="s0">,</span>

    <span class="s2">decimalError </span><span class="s0">= </span><span class="s3">'[DecimalError] '</span><span class="s0">,</span>
    <span class="s2">invalidArgument </span><span class="s0">= </span><span class="s2">decimalError </span><span class="s0">+ </span><span class="s3">'Invalid argument: '</span><span class="s0">,</span>
    <span class="s2">precisionLimitExceeded </span><span class="s0">= </span><span class="s2">decimalError </span><span class="s0">+ </span><span class="s3">'Precision limit exceeded'</span><span class="s0">,</span>
    <span class="s2">cryptoUnavailable </span><span class="s0">= </span><span class="s2">decimalError </span><span class="s0">+ </span><span class="s3">'crypto unavailable'</span><span class="s0">,</span>
    <span class="s2">tag </span><span class="s0">= </span><span class="s3">'[object Decimal]'</span><span class="s0">,</span>

    <span class="s2">mathfloor </span><span class="s0">= </span><span class="s2">Math</span><span class="s0">.</span><span class="s2">floor</span><span class="s0">,</span>
    <span class="s2">mathpow </span><span class="s0">= </span><span class="s2">Math</span><span class="s0">.</span><span class="s2">pow</span><span class="s0">,</span>

    <span class="s2">isBinary </span><span class="s0">= </span><span class="s6">/^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i</span><span class="s0">,</span>
    <span class="s2">isHex </span><span class="s0">= </span><span class="s6">/^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i</span><span class="s0">,</span>
    <span class="s2">isOctal </span><span class="s0">= </span><span class="s6">/^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i</span><span class="s0">,</span>
    <span class="s2">isDecimal </span><span class="s0">= </span><span class="s6">/^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i</span><span class="s0">,</span>

    <span class="s2">BASE </span><span class="s0">= </span><span class="s5">1e7</span><span class="s0">,</span>
    <span class="s2">LOG_BASE </span><span class="s0">= </span><span class="s5">7</span><span class="s0">,</span>
    <span class="s2">MAX_SAFE_INTEGER </span><span class="s0">= </span><span class="s5">9007199254740991</span><span class="s0">,</span>

    <span class="s2">LN10_PRECISION </span><span class="s0">= </span><span class="s2">LN10</span><span class="s0">.</span><span class="s2">length </span><span class="s0">- </span><span class="s5">1</span><span class="s0">,</span>
    <span class="s2">PI_PRECISION </span><span class="s0">= </span><span class="s2">PI</span><span class="s0">.</span><span class="s2">length </span><span class="s0">- </span><span class="s5">1</span><span class="s0">,</span>

    <span class="s4">// Decimal.prototype object</span>
    <span class="s2">P </span><span class="s0">= { </span><span class="s2">toStringTag</span><span class="s0">: </span><span class="s2">tag </span><span class="s0">};</span>


  <span class="s4">// Decimal prototype methods</span>


  <span class="s4">/* 
   *  absoluteValue             abs 
   *  ceil 
   *  clampedTo                 clamp 
   *  comparedTo                cmp 
   *  cosine                    cos 
   *  cubeRoot                  cbrt 
   *  decimalPlaces             dp 
   *  dividedBy                 div 
   *  dividedToIntegerBy        divToInt 
   *  equals                    eq 
   *  floor 
   *  greaterThan               gt 
   *  greaterThanOrEqualTo      gte 
   *  hyperbolicCosine          cosh 
   *  hyperbolicSine            sinh 
   *  hyperbolicTangent         tanh 
   *  inverseCosine             acos 
   *  inverseHyperbolicCosine   acosh 
   *  inverseHyperbolicSine     asinh 
   *  inverseHyperbolicTangent  atanh 
   *  inverseSine               asin 
   *  inverseTangent            atan 
   *  isFinite 
   *  isInteger                 isInt 
   *  isNaN 
   *  isNegative                isNeg 
   *  isPositive                isPos 
   *  isZero 
   *  lessThan                  lt 
   *  lessThanOrEqualTo         lte 
   *  logarithm                 log 
   *  [maximum]                 [max] 
   *  [minimum]                 [min] 
   *  minus                     sub 
   *  modulo                    mod 
   *  naturalExponential        exp 
   *  naturalLogarithm          ln 
   *  negated                   neg 
   *  plus                      add 
   *  precision                 sd 
   *  round 
   *  sine                      sin 
   *  squareRoot                sqrt 
   *  tangent                   tan 
   *  times                     mul 
   *  toBinary 
   *  toDecimalPlaces           toDP 
   *  toExponential 
   *  toFixed 
   *  toFraction 
   *  toHexadecimal             toHex 
   *  toNearest 
   *  toNumber 
   *  toOctal 
   *  toPower                   pow 
   *  toPrecision 
   *  toSignificantDigits       toSD 
   *  toString 
   *  truncated                 trunc 
   *  valueOf                   toJSON 
   */</span>


  <span class="s4">/* 
   * Return a new Decimal whose value is the absolute value of this Decimal. 
   * 
   */</span>
  <span class="s2">P</span><span class="s0">.</span><span class="s2">absoluteValue </span><span class="s0">= </span><span class="s2">P</span><span class="s0">.</span><span class="s2">abs </span><span class="s0">= </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">var </span><span class="s2">x </span><span class="s0">= </span><span class="s1">new this</span><span class="s0">.</span><span class="s2">constructor</span><span class="s0">(</span><span class="s1">this</span><span class="s0">);</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">x</span><span class="s0">.</span><span class="s2">s </span><span class="s0">&lt; </span><span class="s5">0</span><span class="s0">) </span><span class="s2">x</span><span class="s0">.</span><span class="s2">s </span><span class="s0">= </span><span class="s5">1</span><span class="s0">;</span>
    <span class="s1">return </span><span class="s2">finalise</span><span class="s0">(</span><span class="s2">x</span><span class="s0">);</span>
  <span class="s0">};</span>


  <span class="s4">/* 
   * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the 
   * direction of positive Infinity. 
   * 
   */</span>
  <span class="s2">P</span><span class="s0">.</span><span class="s2">ceil </span><span class="s0">= </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">return </span><span class="s2">finalise</span><span class="s0">(</span><span class="s1">new this</span><span class="s0">.</span><span class="s2">constructor</span><span class="s0">(</span><span class="s1">this</span><span class="s0">), </span><span class="s1">this</span><span class="s0">.</span><span class="s2">e </span><span class="s0">+ </span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">);</span>
  <span class="s0">};</span>


  <span class="s4">/* 
   * Return a new Decimal whose value is the value of this Decimal clamped to the range 
   * delineated by `min` and `max`. 
   * 
   * min {number|string|bigint|Decimal} 
   * max {number|string|bigint|Decimal} 
   * 
   */</span>
  <span class="s2">P</span><span class="s0">.</span><span class="s2">clampedTo </span><span class="s0">= </span><span class="s2">P</span><span class="s0">.</span><span class="s2">clamp </span><span class="s0">= </span><span class="s1">function </span><span class="s0">(</span><span class="s2">min</span><span class="s0">, </span><span class="s2">max</span><span class="s0">) {</span>
    <span class="s1">var </span><span class="s2">k</span><span class="s0">,</span>
      <span class="s2">x </span><span class="s0">= </span><span class="s1">this</span><span class="s0">,</span>
      <span class="s2">Ctor </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">constructor</span><span class="s0">;</span>
    <span class="s2">min </span><span class="s0">= </span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">min</span><span class="s0">);</span>
    <span class="s2">max </span><span class="s0">= </span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">max</span><span class="s0">);</span>
    <span class="s1">if </span><span class="s0">(!</span><span class="s2">min</span><span class="s0">.</span><span class="s2">s </span><span class="s0">|| !</span><span class="s2">max</span><span class="s0">.</span><span class="s2">s</span><span class="s0">) </span><span class="s1">return new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">NaN</span><span class="s0">);</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">min</span><span class="s0">.</span><span class="s2">gt</span><span class="s0">(</span><span class="s2">max</span><span class="s0">)) </span><span class="s1">throw </span><span class="s2">Error</span><span class="s0">(</span><span class="s2">invalidArgument </span><span class="s0">+ </span><span class="s2">max</span><span class="s0">);</span>
    <span class="s2">k </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">cmp</span><span class="s0">(</span><span class="s2">min</span><span class="s0">);</span>
    <span class="s1">return </span><span class="s2">k </span><span class="s0">&lt; </span><span class="s5">0 </span><span class="s0">? </span><span class="s2">min </span><span class="s0">: </span><span class="s2">x</span><span class="s0">.</span><span class="s2">cmp</span><span class="s0">(</span><span class="s2">max</span><span class="s0">) &gt; </span><span class="s5">0 </span><span class="s0">? </span><span class="s2">max </span><span class="s0">: </span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">x</span><span class="s0">);</span>
  <span class="s0">};</span>


  <span class="s4">/* 
   * Return 
   *   1    if the value of this Decimal is greater than the value of `y`, 
   *  -1    if the value of this Decimal is less than the value of `y`, 
   *   0    if they have the same value, 
   *   NaN  if the value of either Decimal is NaN. 
   * 
   */</span>
  <span class="s2">P</span><span class="s0">.</span><span class="s2">comparedTo </span><span class="s0">= </span><span class="s2">P</span><span class="s0">.</span><span class="s2">cmp </span><span class="s0">= </span><span class="s1">function </span><span class="s0">(</span><span class="s2">y</span><span class="s0">) {</span>
    <span class="s1">var </span><span class="s2">i</span><span class="s0">, </span><span class="s2">j</span><span class="s0">, </span><span class="s2">xdL</span><span class="s0">, </span><span class="s2">ydL</span><span class="s0">,</span>
      <span class="s2">x </span><span class="s0">= </span><span class="s1">this</span><span class="s0">,</span>
      <span class="s2">xd </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">d</span><span class="s0">,</span>
      <span class="s2">yd </span><span class="s0">= (</span><span class="s2">y </span><span class="s0">= </span><span class="s1">new </span><span class="s2">x</span><span class="s0">.</span><span class="s2">constructor</span><span class="s0">(</span><span class="s2">y</span><span class="s0">)).</span><span class="s2">d</span><span class="s0">,</span>
      <span class="s2">xs </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">s</span><span class="s0">,</span>
      <span class="s2">ys </span><span class="s0">= </span><span class="s2">y</span><span class="s0">.</span><span class="s2">s</span><span class="s0">;</span>

    <span class="s4">// Either NaN or ±Infinity?</span>
    <span class="s1">if </span><span class="s0">(!</span><span class="s2">xd </span><span class="s0">|| !</span><span class="s2">yd</span><span class="s0">) {</span>
      <span class="s1">return </span><span class="s0">!</span><span class="s2">xs </span><span class="s0">|| !</span><span class="s2">ys </span><span class="s0">? </span><span class="s2">NaN </span><span class="s0">: </span><span class="s2">xs </span><span class="s0">!== </span><span class="s2">ys </span><span class="s0">? </span><span class="s2">xs </span><span class="s0">: </span><span class="s2">xd </span><span class="s0">=== </span><span class="s2">yd </span><span class="s0">? </span><span class="s5">0 </span><span class="s0">: !</span><span class="s2">xd </span><span class="s0">^ </span><span class="s2">xs </span><span class="s0">&lt; </span><span class="s5">0 </span><span class="s0">? </span><span class="s5">1 </span><span class="s0">: -</span><span class="s5">1</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s4">// Either zero?</span>
    <span class="s1">if </span><span class="s0">(!</span><span class="s2">xd</span><span class="s0">[</span><span class="s5">0</span><span class="s0">] || !</span><span class="s2">yd</span><span class="s0">[</span><span class="s5">0</span><span class="s0">]) </span><span class="s1">return </span><span class="s2">xd</span><span class="s0">[</span><span class="s5">0</span><span class="s0">] ? </span><span class="s2">xs </span><span class="s0">: </span><span class="s2">yd</span><span class="s0">[</span><span class="s5">0</span><span class="s0">] ? -</span><span class="s2">ys </span><span class="s0">: </span><span class="s5">0</span><span class="s0">;</span>

    <span class="s4">// Signs differ?</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">xs </span><span class="s0">!== </span><span class="s2">ys</span><span class="s0">) </span><span class="s1">return </span><span class="s2">xs</span><span class="s0">;</span>

    <span class="s4">// Compare exponents.</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">x</span><span class="s0">.</span><span class="s2">e </span><span class="s0">!== </span><span class="s2">y</span><span class="s0">.</span><span class="s2">e</span><span class="s0">) </span><span class="s1">return </span><span class="s2">x</span><span class="s0">.</span><span class="s2">e </span><span class="s0">&gt; </span><span class="s2">y</span><span class="s0">.</span><span class="s2">e </span><span class="s0">^ </span><span class="s2">xs </span><span class="s0">&lt; </span><span class="s5">0 </span><span class="s0">? </span><span class="s5">1 </span><span class="s0">: -</span><span class="s5">1</span><span class="s0">;</span>

    <span class="s2">xdL </span><span class="s0">= </span><span class="s2">xd</span><span class="s0">.</span><span class="s2">length</span><span class="s0">;</span>
    <span class="s2">ydL </span><span class="s0">= </span><span class="s2">yd</span><span class="s0">.</span><span class="s2">length</span><span class="s0">;</span>

    <span class="s4">// Compare digit by digit.</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s2">i </span><span class="s0">= </span><span class="s5">0</span><span class="s0">, </span><span class="s2">j </span><span class="s0">= </span><span class="s2">xdL </span><span class="s0">&lt; </span><span class="s2">ydL </span><span class="s0">? </span><span class="s2">xdL </span><span class="s0">: </span><span class="s2">ydL</span><span class="s0">; </span><span class="s2">i </span><span class="s0">&lt; </span><span class="s2">j</span><span class="s0">; ++</span><span class="s2">i</span><span class="s0">) {</span>
      <span class="s1">if </span><span class="s0">(</span><span class="s2">xd</span><span class="s0">[</span><span class="s2">i</span><span class="s0">] !== </span><span class="s2">yd</span><span class="s0">[</span><span class="s2">i</span><span class="s0">]) </span><span class="s1">return </span><span class="s2">xd</span><span class="s0">[</span><span class="s2">i</span><span class="s0">] &gt; </span><span class="s2">yd</span><span class="s0">[</span><span class="s2">i</span><span class="s0">] ^ </span><span class="s2">xs </span><span class="s0">&lt; </span><span class="s5">0 </span><span class="s0">? </span><span class="s5">1 </span><span class="s0">: -</span><span class="s5">1</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s4">// Compare lengths.</span>
    <span class="s1">return </span><span class="s2">xdL </span><span class="s0">=== </span><span class="s2">ydL </span><span class="s0">? </span><span class="s5">0 </span><span class="s0">: </span><span class="s2">xdL </span><span class="s0">&gt; </span><span class="s2">ydL </span><span class="s0">^ </span><span class="s2">xs </span><span class="s0">&lt; </span><span class="s5">0 </span><span class="s0">? </span><span class="s5">1 </span><span class="s0">: -</span><span class="s5">1</span><span class="s0">;</span>
  <span class="s0">};</span>


  <span class="s4">/* 
   * Return a new Decimal whose value is the cosine of the value in radians of this Decimal. 
   * 
   * Domain: [-Infinity, Infinity] 
   * Range: [-1, 1] 
   * 
   * cos(0)         = 1 
   * cos(-0)        = 1 
   * cos(Infinity)  = NaN 
   * cos(-Infinity) = NaN 
   * cos(NaN)       = NaN 
   * 
   */</span>
  <span class="s2">P</span><span class="s0">.</span><span class="s2">cosine </span><span class="s0">= </span><span class="s2">P</span><span class="s0">.</span><span class="s2">cos </span><span class="s0">= </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">var </span><span class="s2">pr</span><span class="s0">, </span><span class="s2">rm</span><span class="s0">,</span>
      <span class="s2">x </span><span class="s0">= </span><span class="s1">this</span><span class="s0">,</span>
      <span class="s2">Ctor </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">constructor</span><span class="s0">;</span>

    <span class="s1">if </span><span class="s0">(!</span><span class="s2">x</span><span class="s0">.</span><span class="s2">d</span><span class="s0">) </span><span class="s1">return new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">NaN</span><span class="s0">);</span>

    <span class="s4">// cos(0) = cos(-0) = 1</span>
    <span class="s1">if </span><span class="s0">(!</span><span class="s2">x</span><span class="s0">.</span><span class="s2">d</span><span class="s0">[</span><span class="s5">0</span><span class="s0">]) </span><span class="s1">return new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s5">1</span><span class="s0">);</span>

    <span class="s2">pr </span><span class="s0">= </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">precision</span><span class="s0">;</span>
    <span class="s2">rm </span><span class="s0">= </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">rounding</span><span class="s0">;</span>
    <span class="s2">Ctor</span><span class="s0">.</span><span class="s2">precision </span><span class="s0">= </span><span class="s2">pr </span><span class="s0">+ </span><span class="s2">Math</span><span class="s0">.</span><span class="s2">max</span><span class="s0">(</span><span class="s2">x</span><span class="s0">.</span><span class="s2">e</span><span class="s0">, </span><span class="s2">x</span><span class="s0">.</span><span class="s2">sd</span><span class="s0">()) + </span><span class="s2">LOG_BASE</span><span class="s0">;</span>
    <span class="s2">Ctor</span><span class="s0">.</span><span class="s2">rounding </span><span class="s0">= </span><span class="s5">1</span><span class="s0">;</span>

    <span class="s2">x </span><span class="s0">= </span><span class="s2">cosine</span><span class="s0">(</span><span class="s2">Ctor</span><span class="s0">, </span><span class="s2">toLessThanHalfPi</span><span class="s0">(</span><span class="s2">Ctor</span><span class="s0">, </span><span class="s2">x</span><span class="s0">));</span>

    <span class="s2">Ctor</span><span class="s0">.</span><span class="s2">precision </span><span class="s0">= </span><span class="s2">pr</span><span class="s0">;</span>
    <span class="s2">Ctor</span><span class="s0">.</span><span class="s2">rounding </span><span class="s0">= </span><span class="s2">rm</span><span class="s0">;</span>

    <span class="s1">return </span><span class="s2">finalise</span><span class="s0">(</span><span class="s2">quadrant </span><span class="s0">== </span><span class="s5">2 </span><span class="s0">|| </span><span class="s2">quadrant </span><span class="s0">== </span><span class="s5">3 </span><span class="s0">? </span><span class="s2">x</span><span class="s0">.</span><span class="s2">neg</span><span class="s0">() : </span><span class="s2">x</span><span class="s0">, </span><span class="s2">pr</span><span class="s0">, </span><span class="s2">rm</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>
  <span class="s0">};</span>


  <span class="s4">/* 
   * 
   * Return a new Decimal whose value is the cube root of the value of this Decimal, rounded to 
   * `precision` significant digits using rounding mode `rounding`. 
   * 
   *  cbrt(0)  =  0 
   *  cbrt(-0) = -0 
   *  cbrt(1)  =  1 
   *  cbrt(-1) = -1 
   *  cbrt(N)  =  N 
   *  cbrt(-I) = -I 
   *  cbrt(I)  =  I 
   * 
   * Math.cbrt(x) = (x &lt; 0 ? -Math.pow(-x, 1/3) : Math.pow(x, 1/3)) 
   * 
   */</span>
  <span class="s2">P</span><span class="s0">.</span><span class="s2">cubeRoot </span><span class="s0">= </span><span class="s2">P</span><span class="s0">.</span><span class="s2">cbrt </span><span class="s0">= </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">var </span><span class="s2">e</span><span class="s0">, </span><span class="s2">m</span><span class="s0">, </span><span class="s2">n</span><span class="s0">, </span><span class="s2">r</span><span class="s0">, </span><span class="s2">rep</span><span class="s0">, </span><span class="s2">s</span><span class="s0">, </span><span class="s2">sd</span><span class="s0">, </span><span class="s2">t</span><span class="s0">, </span><span class="s2">t3</span><span class="s0">, </span><span class="s2">t3plusx</span><span class="s0">,</span>
      <span class="s2">x </span><span class="s0">= </span><span class="s1">this</span><span class="s0">,</span>
      <span class="s2">Ctor </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">constructor</span><span class="s0">;</span>

    <span class="s1">if </span><span class="s0">(!</span><span class="s2">x</span><span class="s0">.</span><span class="s2">isFinite</span><span class="s0">() || </span><span class="s2">x</span><span class="s0">.</span><span class="s2">isZero</span><span class="s0">()) </span><span class="s1">return new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">x</span><span class="s0">);</span>
    <span class="s2">external </span><span class="s0">= </span><span class="s1">false</span><span class="s0">;</span>

    <span class="s4">// Initial estimate.</span>
    <span class="s2">s </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">s </span><span class="s0">* </span><span class="s2">mathpow</span><span class="s0">(</span><span class="s2">x</span><span class="s0">.</span><span class="s2">s </span><span class="s0">* </span><span class="s2">x</span><span class="s0">, </span><span class="s5">1 </span><span class="s0">/ </span><span class="s5">3</span><span class="s0">);</span>

     <span class="s4">// Math.cbrt underflow/overflow?</span>
     <span class="s4">// Pass x to Math.pow as integer, then adjust the exponent of the result.</span>
    <span class="s1">if </span><span class="s0">(!</span><span class="s2">s </span><span class="s0">|| </span><span class="s2">Math</span><span class="s0">.</span><span class="s2">abs</span><span class="s0">(</span><span class="s2">s</span><span class="s0">) == </span><span class="s5">1 </span><span class="s0">/ </span><span class="s5">0</span><span class="s0">) {</span>
      <span class="s2">n </span><span class="s0">= </span><span class="s2">digitsToString</span><span class="s0">(</span><span class="s2">x</span><span class="s0">.</span><span class="s2">d</span><span class="s0">);</span>
      <span class="s2">e </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">e</span><span class="s0">;</span>

      <span class="s4">// Adjust n exponent so it is a multiple of 3 away from x exponent.</span>
      <span class="s1">if </span><span class="s0">(</span><span class="s2">s </span><span class="s0">= (</span><span class="s2">e </span><span class="s0">- </span><span class="s2">n</span><span class="s0">.</span><span class="s2">length </span><span class="s0">+ </span><span class="s5">1</span><span class="s0">) % </span><span class="s5">3</span><span class="s0">) </span><span class="s2">n </span><span class="s0">+= (</span><span class="s2">s </span><span class="s0">== </span><span class="s5">1 </span><span class="s0">|| </span><span class="s2">s </span><span class="s0">== -</span><span class="s5">2 </span><span class="s0">? </span><span class="s3">'0' </span><span class="s0">: </span><span class="s3">'00'</span><span class="s0">);</span>
      <span class="s2">s </span><span class="s0">= </span><span class="s2">mathpow</span><span class="s0">(</span><span class="s2">n</span><span class="s0">, </span><span class="s5">1 </span><span class="s0">/ </span><span class="s5">3</span><span class="s0">);</span>

      <span class="s4">// Rarely, e may be one less than the result exponent value.</span>
      <span class="s2">e </span><span class="s0">= </span><span class="s2">mathfloor</span><span class="s0">((</span><span class="s2">e </span><span class="s0">+ </span><span class="s5">1</span><span class="s0">) / </span><span class="s5">3</span><span class="s0">) - (</span><span class="s2">e </span><span class="s0">% </span><span class="s5">3 </span><span class="s0">== (</span><span class="s2">e </span><span class="s0">&lt; </span><span class="s5">0 </span><span class="s0">? -</span><span class="s5">1 </span><span class="s0">: </span><span class="s5">2</span><span class="s0">));</span>

      <span class="s1">if </span><span class="s0">(</span><span class="s2">s </span><span class="s0">== </span><span class="s5">1 </span><span class="s0">/ </span><span class="s5">0</span><span class="s0">) {</span>
        <span class="s2">n </span><span class="s0">= </span><span class="s3">'5e' </span><span class="s0">+ </span><span class="s2">e</span><span class="s0">;</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s2">n </span><span class="s0">= </span><span class="s2">s</span><span class="s0">.</span><span class="s2">toExponential</span><span class="s0">();</span>
        <span class="s2">n </span><span class="s0">= </span><span class="s2">n</span><span class="s0">.</span><span class="s2">slice</span><span class="s0">(</span><span class="s5">0</span><span class="s0">, </span><span class="s2">n</span><span class="s0">.</span><span class="s2">indexOf</span><span class="s0">(</span><span class="s3">'e'</span><span class="s0">) + </span><span class="s5">1</span><span class="s0">) + </span><span class="s2">e</span><span class="s0">;</span>
      <span class="s0">}</span>

      <span class="s2">r </span><span class="s0">= </span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">n</span><span class="s0">);</span>
      <span class="s2">r</span><span class="s0">.</span><span class="s2">s </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">s</span><span class="s0">;</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s2">r </span><span class="s0">= </span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">s</span><span class="s0">.</span><span class="s2">toString</span><span class="s0">());</span>
    <span class="s0">}</span>

    <span class="s2">sd </span><span class="s0">= (</span><span class="s2">e </span><span class="s0">= </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">precision</span><span class="s0">) + </span><span class="s5">3</span><span class="s0">;</span>

    <span class="s4">// Halley's method.</span>
    <span class="s4">// TODO? Compare Newton's method.</span>
    <span class="s1">for </span><span class="s0">(;;) {</span>
      <span class="s2">t </span><span class="s0">= </span><span class="s2">r</span><span class="s0">;</span>
      <span class="s2">t3 </span><span class="s0">= </span><span class="s2">t</span><span class="s0">.</span><span class="s2">times</span><span class="s0">(</span><span class="s2">t</span><span class="s0">).</span><span class="s2">times</span><span class="s0">(</span><span class="s2">t</span><span class="s0">);</span>
      <span class="s2">t3plusx </span><span class="s0">= </span><span class="s2">t3</span><span class="s0">.</span><span class="s2">plus</span><span class="s0">(</span><span class="s2">x</span><span class="s0">);</span>
      <span class="s2">r </span><span class="s0">= </span><span class="s2">divide</span><span class="s0">(</span><span class="s2">t3plusx</span><span class="s0">.</span><span class="s2">plus</span><span class="s0">(</span><span class="s2">x</span><span class="s0">).</span><span class="s2">times</span><span class="s0">(</span><span class="s2">t</span><span class="s0">), </span><span class="s2">t3plusx</span><span class="s0">.</span><span class="s2">plus</span><span class="s0">(</span><span class="s2">t3</span><span class="s0">), </span><span class="s2">sd </span><span class="s0">+ </span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s0">);</span>

      <span class="s4">// TODO? Replace with for-loop and checkRoundingDigits.</span>
      <span class="s1">if </span><span class="s0">(</span><span class="s2">digitsToString</span><span class="s0">(</span><span class="s2">t</span><span class="s0">.</span><span class="s2">d</span><span class="s0">).</span><span class="s2">slice</span><span class="s0">(</span><span class="s5">0</span><span class="s0">, </span><span class="s2">sd</span><span class="s0">) === (</span><span class="s2">n </span><span class="s0">= </span><span class="s2">digitsToString</span><span class="s0">(</span><span class="s2">r</span><span class="s0">.</span><span class="s2">d</span><span class="s0">)).</span><span class="s2">slice</span><span class="s0">(</span><span class="s5">0</span><span class="s0">, </span><span class="s2">sd</span><span class="s0">)) {</span>
        <span class="s2">n </span><span class="s0">= </span><span class="s2">n</span><span class="s0">.</span><span class="s2">slice</span><span class="s0">(</span><span class="s2">sd </span><span class="s0">- </span><span class="s5">3</span><span class="s0">, </span><span class="s2">sd </span><span class="s0">+ </span><span class="s5">1</span><span class="s0">);</span>

        <span class="s4">// The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or 4999</span>
        <span class="s4">// , i.e. approaching a rounding boundary, continue the iteration.</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s2">n </span><span class="s0">== </span><span class="s3">'9999' </span><span class="s0">|| !</span><span class="s2">rep </span><span class="s0">&amp;&amp; </span><span class="s2">n </span><span class="s0">== </span><span class="s3">'4999'</span><span class="s0">) {</span>

          <span class="s4">// On the first iteration only, check to see if rounding up gives the exact result as the</span>
          <span class="s4">// nines may infinitely repeat.</span>
          <span class="s1">if </span><span class="s0">(!</span><span class="s2">rep</span><span class="s0">) {</span>
            <span class="s2">finalise</span><span class="s0">(</span><span class="s2">t</span><span class="s0">, </span><span class="s2">e </span><span class="s0">+ </span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s0">);</span>

            <span class="s1">if </span><span class="s0">(</span><span class="s2">t</span><span class="s0">.</span><span class="s2">times</span><span class="s0">(</span><span class="s2">t</span><span class="s0">).</span><span class="s2">times</span><span class="s0">(</span><span class="s2">t</span><span class="s0">).</span><span class="s2">eq</span><span class="s0">(</span><span class="s2">x</span><span class="s0">)) {</span>
              <span class="s2">r </span><span class="s0">= </span><span class="s2">t</span><span class="s0">;</span>
              <span class="s1">break</span><span class="s0">;</span>
            <span class="s0">}</span>
          <span class="s0">}</span>

          <span class="s2">sd </span><span class="s0">+= </span><span class="s5">4</span><span class="s0">;</span>
          <span class="s2">rep </span><span class="s0">= </span><span class="s5">1</span><span class="s0">;</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>

          <span class="s4">// If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.</span>
          <span class="s4">// If not, then there are further digits and m will be truthy.</span>
          <span class="s1">if </span><span class="s0">(!+</span><span class="s2">n </span><span class="s0">|| !+</span><span class="s2">n</span><span class="s0">.</span><span class="s2">slice</span><span class="s0">(</span><span class="s5">1</span><span class="s0">) &amp;&amp; </span><span class="s2">n</span><span class="s0">.</span><span class="s2">charAt</span><span class="s0">(</span><span class="s5">0</span><span class="s0">) == </span><span class="s3">'5'</span><span class="s0">) {</span>

            <span class="s4">// Truncate to the first rounding digit.</span>
            <span class="s2">finalise</span><span class="s0">(</span><span class="s2">r</span><span class="s0">, </span><span class="s2">e </span><span class="s0">+ </span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s0">);</span>
            <span class="s2">m </span><span class="s0">= !</span><span class="s2">r</span><span class="s0">.</span><span class="s2">times</span><span class="s0">(</span><span class="s2">r</span><span class="s0">).</span><span class="s2">times</span><span class="s0">(</span><span class="s2">r</span><span class="s0">).</span><span class="s2">eq</span><span class="s0">(</span><span class="s2">x</span><span class="s0">);</span>
          <span class="s0">}</span>

          <span class="s1">break</span><span class="s0">;</span>
        <span class="s0">}</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s2">external </span><span class="s0">= </span><span class="s1">true</span><span class="s0">;</span>

    <span class="s1">return </span><span class="s2">finalise</span><span class="s0">(</span><span class="s2">r</span><span class="s0">, </span><span class="s2">e</span><span class="s0">, </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">rounding</span><span class="s0">, </span><span class="s2">m</span><span class="s0">);</span>
  <span class="s0">};</span>


  <span class="s4">/* 
   * Return the number of decimal places of the value of this Decimal. 
   * 
   */</span>
  <span class="s2">P</span><span class="s0">.</span><span class="s2">decimalPlaces </span><span class="s0">= </span><span class="s2">P</span><span class="s0">.</span><span class="s2">dp </span><span class="s0">= </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">var </span><span class="s2">w</span><span class="s0">,</span>
      <span class="s2">d </span><span class="s0">= </span><span class="s1">this</span><span class="s0">.</span><span class="s2">d</span><span class="s0">,</span>
      <span class="s2">n </span><span class="s0">= </span><span class="s2">NaN</span><span class="s0">;</span>

    <span class="s1">if </span><span class="s0">(</span><span class="s2">d</span><span class="s0">) {</span>
      <span class="s2">w </span><span class="s0">= </span><span class="s2">d</span><span class="s0">.</span><span class="s2">length </span><span class="s0">- </span><span class="s5">1</span><span class="s0">;</span>
      <span class="s2">n </span><span class="s0">= (</span><span class="s2">w </span><span class="s0">- </span><span class="s2">mathfloor</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.</span><span class="s2">e </span><span class="s0">/ </span><span class="s2">LOG_BASE</span><span class="s0">)) * </span><span class="s2">LOG_BASE</span><span class="s0">;</span>

      <span class="s4">// Subtract the number of trailing zeros of the last word.</span>
      <span class="s2">w </span><span class="s0">= </span><span class="s2">d</span><span class="s0">[</span><span class="s2">w</span><span class="s0">];</span>
      <span class="s1">if </span><span class="s0">(</span><span class="s2">w</span><span class="s0">) </span><span class="s1">for </span><span class="s0">(; </span><span class="s2">w </span><span class="s0">% </span><span class="s5">10 </span><span class="s0">== </span><span class="s5">0</span><span class="s0">; </span><span class="s2">w </span><span class="s0">/= </span><span class="s5">10</span><span class="s0">) </span><span class="s2">n</span><span class="s0">--;</span>
      <span class="s1">if </span><span class="s0">(</span><span class="s2">n </span><span class="s0">&lt; </span><span class="s5">0</span><span class="s0">) </span><span class="s2">n </span><span class="s0">= </span><span class="s5">0</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">return </span><span class="s2">n</span><span class="s0">;</span>
  <span class="s0">};</span>


  <span class="s4">/* 
   *  n / 0 = I 
   *  n / N = N 
   *  n / I = 0 
   *  0 / n = 0 
   *  0 / 0 = N 
   *  0 / N = N 
   *  0 / I = 0 
   *  N / n = N 
   *  N / 0 = N 
   *  N / N = N 
   *  N / I = N 
   *  I / n = I 
   *  I / 0 = I 
   *  I / N = N 
   *  I / I = N 
   * 
   * Return a new Decimal whose value is the value of this Decimal divided by `y`, rounded to 
   * `precision` significant digits using rounding mode `rounding`. 
   * 
   */</span>
  <span class="s2">P</span><span class="s0">.</span><span class="s2">dividedBy </span><span class="s0">= </span><span class="s2">P</span><span class="s0">.</span><span class="s2">div </span><span class="s0">= </span><span class="s1">function </span><span class="s0">(</span><span class="s2">y</span><span class="s0">) {</span>
    <span class="s1">return </span><span class="s2">divide</span><span class="s0">(</span><span class="s1">this</span><span class="s0">, </span><span class="s1">new this</span><span class="s0">.</span><span class="s2">constructor</span><span class="s0">(</span><span class="s2">y</span><span class="s0">));</span>
  <span class="s0">};</span>


  <span class="s4">/* 
   * Return a new Decimal whose value is the integer part of dividing the value of this Decimal 
   * by the value of `y`, rounded to `precision` significant digits using rounding mode `rounding`. 
   * 
   */</span>
  <span class="s2">P</span><span class="s0">.</span><span class="s2">dividedToIntegerBy </span><span class="s0">= </span><span class="s2">P</span><span class="s0">.</span><span class="s2">divToInt </span><span class="s0">= </span><span class="s1">function </span><span class="s0">(</span><span class="s2">y</span><span class="s0">) {</span>
    <span class="s1">var </span><span class="s2">x </span><span class="s0">= </span><span class="s1">this</span><span class="s0">,</span>
      <span class="s2">Ctor </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">constructor</span><span class="s0">;</span>
    <span class="s1">return </span><span class="s2">finalise</span><span class="s0">(</span><span class="s2">divide</span><span class="s0">(</span><span class="s2">x</span><span class="s0">, </span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">y</span><span class="s0">), </span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s0">), </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">precision</span><span class="s0">, </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">rounding</span><span class="s0">);</span>
  <span class="s0">};</span>


  <span class="s4">/* 
   * Return true if the value of this Decimal is equal to the value of `y`, otherwise return false. 
   * 
   */</span>
  <span class="s2">P</span><span class="s0">.</span><span class="s2">equals </span><span class="s0">= </span><span class="s2">P</span><span class="s0">.</span><span class="s2">eq </span><span class="s0">= </span><span class="s1">function </span><span class="s0">(</span><span class="s2">y</span><span class="s0">) {</span>
    <span class="s1">return this</span><span class="s0">.</span><span class="s2">cmp</span><span class="s0">(</span><span class="s2">y</span><span class="s0">) === </span><span class="s5">0</span><span class="s0">;</span>
  <span class="s0">};</span>


  <span class="s4">/* 
   * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the 
   * direction of negative Infinity. 
   * 
   */</span>
  <span class="s2">P</span><span class="s0">.</span><span class="s2">floor </span><span class="s0">= </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">return </span><span class="s2">finalise</span><span class="s0">(</span><span class="s1">new this</span><span class="s0">.</span><span class="s2">constructor</span><span class="s0">(</span><span class="s1">this</span><span class="s0">), </span><span class="s1">this</span><span class="s0">.</span><span class="s2">e </span><span class="s0">+ </span><span class="s5">1</span><span class="s0">, </span><span class="s5">3</span><span class="s0">);</span>
  <span class="s0">};</span>


  <span class="s4">/* 
   * Return true if the value of this Decimal is greater than the value of `y`, otherwise return 
   * false. 
   * 
   */</span>
  <span class="s2">P</span><span class="s0">.</span><span class="s2">greaterThan </span><span class="s0">= </span><span class="s2">P</span><span class="s0">.</span><span class="s2">gt </span><span class="s0">= </span><span class="s1">function </span><span class="s0">(</span><span class="s2">y</span><span class="s0">) {</span>
    <span class="s1">return this</span><span class="s0">.</span><span class="s2">cmp</span><span class="s0">(</span><span class="s2">y</span><span class="s0">) &gt; </span><span class="s5">0</span><span class="s0">;</span>
  <span class="s0">};</span>


  <span class="s4">/* 
   * Return true if the value of this Decimal is greater than or equal to the value of `y`, 
   * otherwise return false. 
   * 
   */</span>
  <span class="s2">P</span><span class="s0">.</span><span class="s2">greaterThanOrEqualTo </span><span class="s0">= </span><span class="s2">P</span><span class="s0">.</span><span class="s2">gte </span><span class="s0">= </span><span class="s1">function </span><span class="s0">(</span><span class="s2">y</span><span class="s0">) {</span>
    <span class="s1">var </span><span class="s2">k </span><span class="s0">= </span><span class="s1">this</span><span class="s0">.</span><span class="s2">cmp</span><span class="s0">(</span><span class="s2">y</span><span class="s0">);</span>
    <span class="s1">return </span><span class="s2">k </span><span class="s0">== </span><span class="s5">1 </span><span class="s0">|| </span><span class="s2">k </span><span class="s0">=== </span><span class="s5">0</span><span class="s0">;</span>
  <span class="s0">};</span>


  <span class="s4">/* 
   * Return a new Decimal whose value is the hyperbolic cosine of the value in radians of this 
   * Decimal. 
   * 
   * Domain: [-Infinity, Infinity] 
   * Range: [1, Infinity] 
   * 
   * cosh(x) = 1 + x^2/2! + x^4/4! + x^6/6! + ... 
   * 
   * cosh(0)         = 1 
   * cosh(-0)        = 1 
   * cosh(Infinity)  = Infinity 
   * cosh(-Infinity) = Infinity 
   * cosh(NaN)       = NaN 
   * 
   *  x        time taken (ms)   result 
   * 1000      9                 9.8503555700852349694e+433 
   * 10000     25                4.4034091128314607936e+4342 
   * 100000    171               1.4033316802130615897e+43429 
   * 1000000   3817              1.5166076984010437725e+434294 
   * 10000000  abandoned after 2 minute wait 
   * 
   * TODO? Compare performance of cosh(x) = 0.5 * (exp(x) + exp(-x)) 
   * 
   */</span>
  <span class="s2">P</span><span class="s0">.</span><span class="s2">hyperbolicCosine </span><span class="s0">= </span><span class="s2">P</span><span class="s0">.</span><span class="s2">cosh </span><span class="s0">= </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">var </span><span class="s2">k</span><span class="s0">, </span><span class="s2">n</span><span class="s0">, </span><span class="s2">pr</span><span class="s0">, </span><span class="s2">rm</span><span class="s0">, </span><span class="s2">len</span><span class="s0">,</span>
      <span class="s2">x </span><span class="s0">= </span><span class="s1">this</span><span class="s0">,</span>
      <span class="s2">Ctor </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">constructor</span><span class="s0">,</span>
      <span class="s2">one </span><span class="s0">= </span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s5">1</span><span class="s0">);</span>

    <span class="s1">if </span><span class="s0">(!</span><span class="s2">x</span><span class="s0">.</span><span class="s2">isFinite</span><span class="s0">()) </span><span class="s1">return new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">x</span><span class="s0">.</span><span class="s2">s </span><span class="s0">? </span><span class="s5">1 </span><span class="s0">/ </span><span class="s5">0 </span><span class="s0">: </span><span class="s2">NaN</span><span class="s0">);</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">x</span><span class="s0">.</span><span class="s2">isZero</span><span class="s0">()) </span><span class="s1">return </span><span class="s2">one</span><span class="s0">;</span>

    <span class="s2">pr </span><span class="s0">= </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">precision</span><span class="s0">;</span>
    <span class="s2">rm </span><span class="s0">= </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">rounding</span><span class="s0">;</span>
    <span class="s2">Ctor</span><span class="s0">.</span><span class="s2">precision </span><span class="s0">= </span><span class="s2">pr </span><span class="s0">+ </span><span class="s2">Math</span><span class="s0">.</span><span class="s2">max</span><span class="s0">(</span><span class="s2">x</span><span class="s0">.</span><span class="s2">e</span><span class="s0">, </span><span class="s2">x</span><span class="s0">.</span><span class="s2">sd</span><span class="s0">()) + </span><span class="s5">4</span><span class="s0">;</span>
    <span class="s2">Ctor</span><span class="s0">.</span><span class="s2">rounding </span><span class="s0">= </span><span class="s5">1</span><span class="s0">;</span>
    <span class="s2">len </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">d</span><span class="s0">.</span><span class="s2">length</span><span class="s0">;</span>

    <span class="s4">// Argument reduction: cos(4x) = 1 - 8cos^2(x) + 8cos^4(x) + 1</span>
    <span class="s4">// i.e. cos(x) = 1 - cos^2(x/4)(8 - 8cos^2(x/4))</span>

    <span class="s4">// Estimate the optimum number of times to use the argument reduction.</span>
    <span class="s4">// TODO? Estimation reused from cosine() and may not be optimal here.</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">len </span><span class="s0">&lt; </span><span class="s5">32</span><span class="s0">) {</span>
      <span class="s2">k </span><span class="s0">= </span><span class="s2">Math</span><span class="s0">.</span><span class="s2">ceil</span><span class="s0">(</span><span class="s2">len </span><span class="s0">/ </span><span class="s5">3</span><span class="s0">);</span>
      <span class="s2">n </span><span class="s0">= (</span><span class="s5">1 </span><span class="s0">/ </span><span class="s2">tinyPow</span><span class="s0">(</span><span class="s5">4</span><span class="s0">, </span><span class="s2">k</span><span class="s0">)).</span><span class="s2">toString</span><span class="s0">();</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s2">k </span><span class="s0">= </span><span class="s5">16</span><span class="s0">;</span>
      <span class="s2">n </span><span class="s0">= </span><span class="s3">'2.3283064365386962890625e-10'</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s2">x </span><span class="s0">= </span><span class="s2">taylorSeries</span><span class="s0">(</span><span class="s2">Ctor</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s2">x</span><span class="s0">.</span><span class="s2">times</span><span class="s0">(</span><span class="s2">n</span><span class="s0">), </span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s5">1</span><span class="s0">), </span><span class="s1">true</span><span class="s0">);</span>

    <span class="s4">// Reverse argument reduction</span>
    <span class="s1">var </span><span class="s2">cosh2_x</span><span class="s0">,</span>
      <span class="s2">i </span><span class="s0">= </span><span class="s2">k</span><span class="s0">,</span>
      <span class="s2">d8 </span><span class="s0">= </span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s5">8</span><span class="s0">);</span>
    <span class="s1">for </span><span class="s0">(; </span><span class="s2">i</span><span class="s0">--;) {</span>
      <span class="s2">cosh2_x </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">times</span><span class="s0">(</span><span class="s2">x</span><span class="s0">);</span>
      <span class="s2">x </span><span class="s0">= </span><span class="s2">one</span><span class="s0">.</span><span class="s2">minus</span><span class="s0">(</span><span class="s2">cosh2_x</span><span class="s0">.</span><span class="s2">times</span><span class="s0">(</span><span class="s2">d8</span><span class="s0">.</span><span class="s2">minus</span><span class="s0">(</span><span class="s2">cosh2_x</span><span class="s0">.</span><span class="s2">times</span><span class="s0">(</span><span class="s2">d8</span><span class="s0">))));</span>
    <span class="s0">}</span>

    <span class="s1">return </span><span class="s2">finalise</span><span class="s0">(</span><span class="s2">x</span><span class="s0">, </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">precision </span><span class="s0">= </span><span class="s2">pr</span><span class="s0">, </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">rounding </span><span class="s0">= </span><span class="s2">rm</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>
  <span class="s0">};</span>


  <span class="s4">/* 
   * Return a new Decimal whose value is the hyperbolic sine of the value in radians of this 
   * Decimal. 
   * 
   * Domain: [-Infinity, Infinity] 
   * Range: [-Infinity, Infinity] 
   * 
   * sinh(x) = x + x^3/3! + x^5/5! + x^7/7! + ... 
   * 
   * sinh(0)         = 0 
   * sinh(-0)        = -0 
   * sinh(Infinity)  = Infinity 
   * sinh(-Infinity) = -Infinity 
   * sinh(NaN)       = NaN 
   * 
   * x        time taken (ms) 
   * 10       2 ms 
   * 100      5 ms 
   * 1000     14 ms 
   * 10000    82 ms 
   * 100000   886 ms            1.4033316802130615897e+43429 
   * 200000   2613 ms 
   * 300000   5407 ms 
   * 400000   8824 ms 
   * 500000   13026 ms          8.7080643612718084129e+217146 
   * 1000000  48543 ms 
   * 
   * TODO? Compare performance of sinh(x) = 0.5 * (exp(x) - exp(-x)) 
   * 
   */</span>
  <span class="s2">P</span><span class="s0">.</span><span class="s2">hyperbolicSine </span><span class="s0">= </span><span class="s2">P</span><span class="s0">.</span><span class="s2">sinh </span><span class="s0">= </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">var </span><span class="s2">k</span><span class="s0">, </span><span class="s2">pr</span><span class="s0">, </span><span class="s2">rm</span><span class="s0">, </span><span class="s2">len</span><span class="s0">,</span>
      <span class="s2">x </span><span class="s0">= </span><span class="s1">this</span><span class="s0">,</span>
      <span class="s2">Ctor </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">constructor</span><span class="s0">;</span>

    <span class="s1">if </span><span class="s0">(!</span><span class="s2">x</span><span class="s0">.</span><span class="s2">isFinite</span><span class="s0">() || </span><span class="s2">x</span><span class="s0">.</span><span class="s2">isZero</span><span class="s0">()) </span><span class="s1">return new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">x</span><span class="s0">);</span>

    <span class="s2">pr </span><span class="s0">= </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">precision</span><span class="s0">;</span>
    <span class="s2">rm </span><span class="s0">= </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">rounding</span><span class="s0">;</span>
    <span class="s2">Ctor</span><span class="s0">.</span><span class="s2">precision </span><span class="s0">= </span><span class="s2">pr </span><span class="s0">+ </span><span class="s2">Math</span><span class="s0">.</span><span class="s2">max</span><span class="s0">(</span><span class="s2">x</span><span class="s0">.</span><span class="s2">e</span><span class="s0">, </span><span class="s2">x</span><span class="s0">.</span><span class="s2">sd</span><span class="s0">()) + </span><span class="s5">4</span><span class="s0">;</span>
    <span class="s2">Ctor</span><span class="s0">.</span><span class="s2">rounding </span><span class="s0">= </span><span class="s5">1</span><span class="s0">;</span>
    <span class="s2">len </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">d</span><span class="s0">.</span><span class="s2">length</span><span class="s0">;</span>

    <span class="s1">if </span><span class="s0">(</span><span class="s2">len </span><span class="s0">&lt; </span><span class="s5">3</span><span class="s0">) {</span>
      <span class="s2">x </span><span class="s0">= </span><span class="s2">taylorSeries</span><span class="s0">(</span><span class="s2">Ctor</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s2">x</span><span class="s0">, </span><span class="s2">x</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>

      <span class="s4">// Alternative argument reduction: sinh(3x) = sinh(x)(3 + 4sinh^2(x))</span>
      <span class="s4">// i.e. sinh(x) = sinh(x/3)(3 + 4sinh^2(x/3))</span>
      <span class="s4">// 3 multiplications and 1 addition</span>

      <span class="s4">// Argument reduction: sinh(5x) = sinh(x)(5 + sinh^2(x)(20 + 16sinh^2(x)))</span>
      <span class="s4">// i.e. sinh(x) = sinh(x/5)(5 + sinh^2(x/5)(20 + 16sinh^2(x/5)))</span>
      <span class="s4">// 4 multiplications and 2 additions</span>

      <span class="s4">// Estimate the optimum number of times to use the argument reduction.</span>
      <span class="s2">k </span><span class="s0">= </span><span class="s5">1.4 </span><span class="s0">* </span><span class="s2">Math</span><span class="s0">.</span><span class="s2">sqrt</span><span class="s0">(</span><span class="s2">len</span><span class="s0">);</span>
      <span class="s2">k </span><span class="s0">= </span><span class="s2">k </span><span class="s0">&gt; </span><span class="s5">16 </span><span class="s0">? </span><span class="s5">16 </span><span class="s0">: </span><span class="s2">k </span><span class="s0">| </span><span class="s5">0</span><span class="s0">;</span>

      <span class="s2">x </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">times</span><span class="s0">(</span><span class="s5">1 </span><span class="s0">/ </span><span class="s2">tinyPow</span><span class="s0">(</span><span class="s5">5</span><span class="s0">, </span><span class="s2">k</span><span class="s0">));</span>
      <span class="s2">x </span><span class="s0">= </span><span class="s2">taylorSeries</span><span class="s0">(</span><span class="s2">Ctor</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s2">x</span><span class="s0">, </span><span class="s2">x</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>

      <span class="s4">// Reverse argument reduction</span>
      <span class="s1">var </span><span class="s2">sinh2_x</span><span class="s0">,</span>
        <span class="s2">d5 </span><span class="s0">= </span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s5">5</span><span class="s0">),</span>
        <span class="s2">d16 </span><span class="s0">= </span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s5">16</span><span class="s0">),</span>
        <span class="s2">d20 </span><span class="s0">= </span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s5">20</span><span class="s0">);</span>
      <span class="s1">for </span><span class="s0">(; </span><span class="s2">k</span><span class="s0">--;) {</span>
        <span class="s2">sinh2_x </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">times</span><span class="s0">(</span><span class="s2">x</span><span class="s0">);</span>
        <span class="s2">x </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">times</span><span class="s0">(</span><span class="s2">d5</span><span class="s0">.</span><span class="s2">plus</span><span class="s0">(</span><span class="s2">sinh2_x</span><span class="s0">.</span><span class="s2">times</span><span class="s0">(</span><span class="s2">d16</span><span class="s0">.</span><span class="s2">times</span><span class="s0">(</span><span class="s2">sinh2_x</span><span class="s0">).</span><span class="s2">plus</span><span class="s0">(</span><span class="s2">d20</span><span class="s0">))));</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s2">Ctor</span><span class="s0">.</span><span class="s2">precision </span><span class="s0">= </span><span class="s2">pr</span><span class="s0">;</span>
    <span class="s2">Ctor</span><span class="s0">.</span><span class="s2">rounding </span><span class="s0">= </span><span class="s2">rm</span><span class="s0">;</span>

    <span class="s1">return </span><span class="s2">finalise</span><span class="s0">(</span><span class="s2">x</span><span class="s0">, </span><span class="s2">pr</span><span class="s0">, </span><span class="s2">rm</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>
  <span class="s0">};</span>


  <span class="s4">/* 
   * Return a new Decimal whose value is the hyperbolic tangent of the value in radians of this 
   * Decimal. 
   * 
   * Domain: [-Infinity, Infinity] 
   * Range: [-1, 1] 
   * 
   * tanh(x) = sinh(x) / cosh(x) 
   * 
   * tanh(0)         = 0 
   * tanh(-0)        = -0 
   * tanh(Infinity)  = 1 
   * tanh(-Infinity) = -1 
   * tanh(NaN)       = NaN 
   * 
   */</span>
  <span class="s2">P</span><span class="s0">.</span><span class="s2">hyperbolicTangent </span><span class="s0">= </span><span class="s2">P</span><span class="s0">.</span><span class="s2">tanh </span><span class="s0">= </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">var </span><span class="s2">pr</span><span class="s0">, </span><span class="s2">rm</span><span class="s0">,</span>
      <span class="s2">x </span><span class="s0">= </span><span class="s1">this</span><span class="s0">,</span>
      <span class="s2">Ctor </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">constructor</span><span class="s0">;</span>

    <span class="s1">if </span><span class="s0">(!</span><span class="s2">x</span><span class="s0">.</span><span class="s2">isFinite</span><span class="s0">()) </span><span class="s1">return new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">x</span><span class="s0">.</span><span class="s2">s</span><span class="s0">);</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">x</span><span class="s0">.</span><span class="s2">isZero</span><span class="s0">()) </span><span class="s1">return new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">x</span><span class="s0">);</span>

    <span class="s2">pr </span><span class="s0">= </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">precision</span><span class="s0">;</span>
    <span class="s2">rm </span><span class="s0">= </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">rounding</span><span class="s0">;</span>
    <span class="s2">Ctor</span><span class="s0">.</span><span class="s2">precision </span><span class="s0">= </span><span class="s2">pr </span><span class="s0">+ </span><span class="s5">7</span><span class="s0">;</span>
    <span class="s2">Ctor</span><span class="s0">.</span><span class="s2">rounding </span><span class="s0">= </span><span class="s5">1</span><span class="s0">;</span>

    <span class="s1">return </span><span class="s2">divide</span><span class="s0">(</span><span class="s2">x</span><span class="s0">.</span><span class="s2">sinh</span><span class="s0">(), </span><span class="s2">x</span><span class="s0">.</span><span class="s2">cosh</span><span class="s0">(), </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">precision </span><span class="s0">= </span><span class="s2">pr</span><span class="s0">, </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">rounding </span><span class="s0">= </span><span class="s2">rm</span><span class="s0">);</span>
  <span class="s0">};</span>


  <span class="s4">/* 
   * Return a new Decimal whose value is the arccosine (inverse cosine) in radians of the value of 
   * this Decimal. 
   * 
   * Domain: [-1, 1] 
   * Range: [0, pi] 
   * 
   * acos(x) = pi/2 - asin(x) 
   * 
   * acos(0)       = pi/2 
   * acos(-0)      = pi/2 
   * acos(1)       = 0 
   * acos(-1)      = pi 
   * acos(1/2)     = pi/3 
   * acos(-1/2)    = 2*pi/3 
   * acos(|x| &gt; 1) = NaN 
   * acos(NaN)     = NaN 
   * 
   */</span>
  <span class="s2">P</span><span class="s0">.</span><span class="s2">inverseCosine </span><span class="s0">= </span><span class="s2">P</span><span class="s0">.</span><span class="s2">acos </span><span class="s0">= </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">var </span><span class="s2">x </span><span class="s0">= </span><span class="s1">this</span><span class="s0">,</span>
      <span class="s2">Ctor </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">constructor</span><span class="s0">,</span>
      <span class="s2">k </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">abs</span><span class="s0">().</span><span class="s2">cmp</span><span class="s0">(</span><span class="s5">1</span><span class="s0">),</span>
      <span class="s2">pr </span><span class="s0">= </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">precision</span><span class="s0">,</span>
      <span class="s2">rm </span><span class="s0">= </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">rounding</span><span class="s0">;</span>

    <span class="s1">if </span><span class="s0">(</span><span class="s2">k </span><span class="s0">!== -</span><span class="s5">1</span><span class="s0">) {</span>
      <span class="s1">return </span><span class="s2">k </span><span class="s0">=== </span><span class="s5">0</span>
        <span class="s4">// |x| is 1</span>
        <span class="s0">? </span><span class="s2">x</span><span class="s0">.</span><span class="s2">isNeg</span><span class="s0">() ? </span><span class="s2">getPi</span><span class="s0">(</span><span class="s2">Ctor</span><span class="s0">, </span><span class="s2">pr</span><span class="s0">, </span><span class="s2">rm</span><span class="s0">) : </span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s5">0</span><span class="s0">)</span>
        <span class="s4">// |x| &gt; 1 or x is NaN</span>
        <span class="s0">: </span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">NaN</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(</span><span class="s2">x</span><span class="s0">.</span><span class="s2">isZero</span><span class="s0">()) </span><span class="s1">return </span><span class="s2">getPi</span><span class="s0">(</span><span class="s2">Ctor</span><span class="s0">, </span><span class="s2">pr </span><span class="s0">+ </span><span class="s5">4</span><span class="s0">, </span><span class="s2">rm</span><span class="s0">).</span><span class="s2">times</span><span class="s0">(</span><span class="s5">0.5</span><span class="s0">);</span>

    <span class="s4">// TODO? Special case acos(0.5) = pi/3 and acos(-0.5) = 2*pi/3</span>

    <span class="s2">Ctor</span><span class="s0">.</span><span class="s2">precision </span><span class="s0">= </span><span class="s2">pr </span><span class="s0">+ </span><span class="s5">6</span><span class="s0">;</span>
    <span class="s2">Ctor</span><span class="s0">.</span><span class="s2">rounding </span><span class="s0">= </span><span class="s5">1</span><span class="s0">;</span>

    <span class="s4">// See https://github.com/MikeMcl/decimal.js/pull/217</span>
    <span class="s2">x </span><span class="s0">= </span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s5">1</span><span class="s0">).</span><span class="s2">minus</span><span class="s0">(</span><span class="s2">x</span><span class="s0">).</span><span class="s2">div</span><span class="s0">(</span><span class="s2">x</span><span class="s0">.</span><span class="s2">plus</span><span class="s0">(</span><span class="s5">1</span><span class="s0">)).</span><span class="s2">sqrt</span><span class="s0">().</span><span class="s2">atan</span><span class="s0">();</span>

    <span class="s2">Ctor</span><span class="s0">.</span><span class="s2">precision </span><span class="s0">= </span><span class="s2">pr</span><span class="s0">;</span>
    <span class="s2">Ctor</span><span class="s0">.</span><span class="s2">rounding </span><span class="s0">= </span><span class="s2">rm</span><span class="s0">;</span>

    <span class="s1">return </span><span class="s2">x</span><span class="s0">.</span><span class="s2">times</span><span class="s0">(</span><span class="s5">2</span><span class="s0">);</span>
  <span class="s0">};</span>


  <span class="s4">/* 
   * Return a new Decimal whose value is the inverse of the hyperbolic cosine in radians of the 
   * value of this Decimal. 
   * 
   * Domain: [1, Infinity] 
   * Range: [0, Infinity] 
   * 
   * acosh(x) = ln(x + sqrt(x^2 - 1)) 
   * 
   * acosh(x &lt; 1)     = NaN 
   * acosh(NaN)       = NaN 
   * acosh(Infinity)  = Infinity 
   * acosh(-Infinity) = NaN 
   * acosh(0)         = NaN 
   * acosh(-0)        = NaN 
   * acosh(1)         = 0 
   * acosh(-1)        = NaN 
   * 
   */</span>
  <span class="s2">P</span><span class="s0">.</span><span class="s2">inverseHyperbolicCosine </span><span class="s0">= </span><span class="s2">P</span><span class="s0">.</span><span class="s2">acosh </span><span class="s0">= </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">var </span><span class="s2">pr</span><span class="s0">, </span><span class="s2">rm</span><span class="s0">,</span>
      <span class="s2">x </span><span class="s0">= </span><span class="s1">this</span><span class="s0">,</span>
      <span class="s2">Ctor </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">constructor</span><span class="s0">;</span>

    <span class="s1">if </span><span class="s0">(</span><span class="s2">x</span><span class="s0">.</span><span class="s2">lte</span><span class="s0">(</span><span class="s5">1</span><span class="s0">)) </span><span class="s1">return new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">x</span><span class="s0">.</span><span class="s2">eq</span><span class="s0">(</span><span class="s5">1</span><span class="s0">) ? </span><span class="s5">0 </span><span class="s0">: </span><span class="s2">NaN</span><span class="s0">);</span>
    <span class="s1">if </span><span class="s0">(!</span><span class="s2">x</span><span class="s0">.</span><span class="s2">isFinite</span><span class="s0">()) </span><span class="s1">return new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">x</span><span class="s0">);</span>

    <span class="s2">pr </span><span class="s0">= </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">precision</span><span class="s0">;</span>
    <span class="s2">rm </span><span class="s0">= </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">rounding</span><span class="s0">;</span>
    <span class="s2">Ctor</span><span class="s0">.</span><span class="s2">precision </span><span class="s0">= </span><span class="s2">pr </span><span class="s0">+ </span><span class="s2">Math</span><span class="s0">.</span><span class="s2">max</span><span class="s0">(</span><span class="s2">Math</span><span class="s0">.</span><span class="s2">abs</span><span class="s0">(</span><span class="s2">x</span><span class="s0">.</span><span class="s2">e</span><span class="s0">), </span><span class="s2">x</span><span class="s0">.</span><span class="s2">sd</span><span class="s0">()) + </span><span class="s5">4</span><span class="s0">;</span>
    <span class="s2">Ctor</span><span class="s0">.</span><span class="s2">rounding </span><span class="s0">= </span><span class="s5">1</span><span class="s0">;</span>
    <span class="s2">external </span><span class="s0">= </span><span class="s1">false</span><span class="s0">;</span>

    <span class="s2">x </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">times</span><span class="s0">(</span><span class="s2">x</span><span class="s0">).</span><span class="s2">minus</span><span class="s0">(</span><span class="s5">1</span><span class="s0">).</span><span class="s2">sqrt</span><span class="s0">().</span><span class="s2">plus</span><span class="s0">(</span><span class="s2">x</span><span class="s0">);</span>

    <span class="s2">external </span><span class="s0">= </span><span class="s1">true</span><span class="s0">;</span>
    <span class="s2">Ctor</span><span class="s0">.</span><span class="s2">precision </span><span class="s0">= </span><span class="s2">pr</span><span class="s0">;</span>
    <span class="s2">Ctor</span><span class="s0">.</span><span class="s2">rounding </span><span class="s0">= </span><span class="s2">rm</span><span class="s0">;</span>

    <span class="s1">return </span><span class="s2">x</span><span class="s0">.</span><span class="s2">ln</span><span class="s0">();</span>
  <span class="s0">};</span>


  <span class="s4">/* 
   * Return a new Decimal whose value is the inverse of the hyperbolic sine in radians of the value 
   * of this Decimal. 
   * 
   * Domain: [-Infinity, Infinity] 
   * Range: [-Infinity, Infinity] 
   * 
   * asinh(x) = ln(x + sqrt(x^2 + 1)) 
   * 
   * asinh(NaN)       = NaN 
   * asinh(Infinity)  = Infinity 
   * asinh(-Infinity) = -Infinity 
   * asinh(0)         = 0 
   * asinh(-0)        = -0 
   * 
   */</span>
  <span class="s2">P</span><span class="s0">.</span><span class="s2">inverseHyperbolicSine </span><span class="s0">= </span><span class="s2">P</span><span class="s0">.</span><span class="s2">asinh </span><span class="s0">= </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">var </span><span class="s2">pr</span><span class="s0">, </span><span class="s2">rm</span><span class="s0">,</span>
      <span class="s2">x </span><span class="s0">= </span><span class="s1">this</span><span class="s0">,</span>
      <span class="s2">Ctor </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">constructor</span><span class="s0">;</span>

    <span class="s1">if </span><span class="s0">(!</span><span class="s2">x</span><span class="s0">.</span><span class="s2">isFinite</span><span class="s0">() || </span><span class="s2">x</span><span class="s0">.</span><span class="s2">isZero</span><span class="s0">()) </span><span class="s1">return new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">x</span><span class="s0">);</span>

    <span class="s2">pr </span><span class="s0">= </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">precision</span><span class="s0">;</span>
    <span class="s2">rm </span><span class="s0">= </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">rounding</span><span class="s0">;</span>
    <span class="s2">Ctor</span><span class="s0">.</span><span class="s2">precision </span><span class="s0">= </span><span class="s2">pr </span><span class="s0">+ </span><span class="s5">2 </span><span class="s0">* </span><span class="s2">Math</span><span class="s0">.</span><span class="s2">max</span><span class="s0">(</span><span class="s2">Math</span><span class="s0">.</span><span class="s2">abs</span><span class="s0">(</span><span class="s2">x</span><span class="s0">.</span><span class="s2">e</span><span class="s0">), </span><span class="s2">x</span><span class="s0">.</span><span class="s2">sd</span><span class="s0">()) + </span><span class="s5">6</span><span class="s0">;</span>
    <span class="s2">Ctor</span><span class="s0">.</span><span class="s2">rounding </span><span class="s0">= </span><span class="s5">1</span><span class="s0">;</span>
    <span class="s2">external </span><span class="s0">= </span><span class="s1">false</span><span class="s0">;</span>

    <span class="s2">x </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">times</span><span class="s0">(</span><span class="s2">x</span><span class="s0">).</span><span class="s2">plus</span><span class="s0">(</span><span class="s5">1</span><span class="s0">).</span><span class="s2">sqrt</span><span class="s0">().</span><span class="s2">plus</span><span class="s0">(</span><span class="s2">x</span><span class="s0">);</span>

    <span class="s2">external </span><span class="s0">= </span><span class="s1">true</span><span class="s0">;</span>
    <span class="s2">Ctor</span><span class="s0">.</span><span class="s2">precision </span><span class="s0">= </span><span class="s2">pr</span><span class="s0">;</span>
    <span class="s2">Ctor</span><span class="s0">.</span><span class="s2">rounding </span><span class="s0">= </span><span class="s2">rm</span><span class="s0">;</span>

    <span class="s1">return </span><span class="s2">x</span><span class="s0">.</span><span class="s2">ln</span><span class="s0">();</span>
  <span class="s0">};</span>


  <span class="s4">/* 
   * Return a new Decimal whose value is the inverse of the hyperbolic tangent in radians of the 
   * value of this Decimal. 
   * 
   * Domain: [-1, 1] 
   * Range: [-Infinity, Infinity] 
   * 
   * atanh(x) = 0.5 * ln((1 + x) / (1 - x)) 
   * 
   * atanh(|x| &gt; 1)   = NaN 
   * atanh(NaN)       = NaN 
   * atanh(Infinity)  = NaN 
   * atanh(-Infinity) = NaN 
   * atanh(0)         = 0 
   * atanh(-0)        = -0 
   * atanh(1)         = Infinity 
   * atanh(-1)        = -Infinity 
   * 
   */</span>
  <span class="s2">P</span><span class="s0">.</span><span class="s2">inverseHyperbolicTangent </span><span class="s0">= </span><span class="s2">P</span><span class="s0">.</span><span class="s2">atanh </span><span class="s0">= </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">var </span><span class="s2">pr</span><span class="s0">, </span><span class="s2">rm</span><span class="s0">, </span><span class="s2">wpr</span><span class="s0">, </span><span class="s2">xsd</span><span class="s0">,</span>
      <span class="s2">x </span><span class="s0">= </span><span class="s1">this</span><span class="s0">,</span>
      <span class="s2">Ctor </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">constructor</span><span class="s0">;</span>

    <span class="s1">if </span><span class="s0">(!</span><span class="s2">x</span><span class="s0">.</span><span class="s2">isFinite</span><span class="s0">()) </span><span class="s1">return new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">NaN</span><span class="s0">);</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">x</span><span class="s0">.</span><span class="s2">e </span><span class="s0">&gt;= </span><span class="s5">0</span><span class="s0">) </span><span class="s1">return new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">x</span><span class="s0">.</span><span class="s2">abs</span><span class="s0">().</span><span class="s2">eq</span><span class="s0">(</span><span class="s5">1</span><span class="s0">) ? </span><span class="s2">x</span><span class="s0">.</span><span class="s2">s </span><span class="s0">/ </span><span class="s5">0 </span><span class="s0">: </span><span class="s2">x</span><span class="s0">.</span><span class="s2">isZero</span><span class="s0">() ? </span><span class="s2">x </span><span class="s0">: </span><span class="s2">NaN</span><span class="s0">);</span>

    <span class="s2">pr </span><span class="s0">= </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">precision</span><span class="s0">;</span>
    <span class="s2">rm </span><span class="s0">= </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">rounding</span><span class="s0">;</span>
    <span class="s2">xsd </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">sd</span><span class="s0">();</span>

    <span class="s1">if </span><span class="s0">(</span><span class="s2">Math</span><span class="s0">.</span><span class="s2">max</span><span class="s0">(</span><span class="s2">xsd</span><span class="s0">, </span><span class="s2">pr</span><span class="s0">) &lt; </span><span class="s5">2 </span><span class="s0">* -</span><span class="s2">x</span><span class="s0">.</span><span class="s2">e </span><span class="s0">- </span><span class="s5">1</span><span class="s0">) </span><span class="s1">return </span><span class="s2">finalise</span><span class="s0">(</span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">x</span><span class="s0">), </span><span class="s2">pr</span><span class="s0">, </span><span class="s2">rm</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>

    <span class="s2">Ctor</span><span class="s0">.</span><span class="s2">precision </span><span class="s0">= </span><span class="s2">wpr </span><span class="s0">= </span><span class="s2">xsd </span><span class="s0">- </span><span class="s2">x</span><span class="s0">.</span><span class="s2">e</span><span class="s0">;</span>

    <span class="s2">x </span><span class="s0">= </span><span class="s2">divide</span><span class="s0">(</span><span class="s2">x</span><span class="s0">.</span><span class="s2">plus</span><span class="s0">(</span><span class="s5">1</span><span class="s0">), </span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s5">1</span><span class="s0">).</span><span class="s2">minus</span><span class="s0">(</span><span class="s2">x</span><span class="s0">), </span><span class="s2">wpr </span><span class="s0">+ </span><span class="s2">pr</span><span class="s0">, </span><span class="s5">1</span><span class="s0">);</span>

    <span class="s2">Ctor</span><span class="s0">.</span><span class="s2">precision </span><span class="s0">= </span><span class="s2">pr </span><span class="s0">+ </span><span class="s5">4</span><span class="s0">;</span>
    <span class="s2">Ctor</span><span class="s0">.</span><span class="s2">rounding </span><span class="s0">= </span><span class="s5">1</span><span class="s0">;</span>

    <span class="s2">x </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">ln</span><span class="s0">();</span>

    <span class="s2">Ctor</span><span class="s0">.</span><span class="s2">precision </span><span class="s0">= </span><span class="s2">pr</span><span class="s0">;</span>
    <span class="s2">Ctor</span><span class="s0">.</span><span class="s2">rounding </span><span class="s0">= </span><span class="s2">rm</span><span class="s0">;</span>

    <span class="s1">return </span><span class="s2">x</span><span class="s0">.</span><span class="s2">times</span><span class="s0">(</span><span class="s5">0.5</span><span class="s0">);</span>
  <span class="s0">};</span>


  <span class="s4">/* 
   * Return a new Decimal whose value is the arcsine (inverse sine) in radians of the value of this 
   * Decimal. 
   * 
   * Domain: [-Infinity, Infinity] 
   * Range: [-pi/2, pi/2] 
   * 
   * asin(x) = 2*atan(x/(1 + sqrt(1 - x^2))) 
   * 
   * asin(0)       = 0 
   * asin(-0)      = -0 
   * asin(1/2)     = pi/6 
   * asin(-1/2)    = -pi/6 
   * asin(1)       = pi/2 
   * asin(-1)      = -pi/2 
   * asin(|x| &gt; 1) = NaN 
   * asin(NaN)     = NaN 
   * 
   * TODO? Compare performance of Taylor series. 
   * 
   */</span>
  <span class="s2">P</span><span class="s0">.</span><span class="s2">inverseSine </span><span class="s0">= </span><span class="s2">P</span><span class="s0">.</span><span class="s2">asin </span><span class="s0">= </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">var </span><span class="s2">halfPi</span><span class="s0">, </span><span class="s2">k</span><span class="s0">,</span>
      <span class="s2">pr</span><span class="s0">, </span><span class="s2">rm</span><span class="s0">,</span>
      <span class="s2">x </span><span class="s0">= </span><span class="s1">this</span><span class="s0">,</span>
      <span class="s2">Ctor </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">constructor</span><span class="s0">;</span>

    <span class="s1">if </span><span class="s0">(</span><span class="s2">x</span><span class="s0">.</span><span class="s2">isZero</span><span class="s0">()) </span><span class="s1">return new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">x</span><span class="s0">);</span>

    <span class="s2">k </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">abs</span><span class="s0">().</span><span class="s2">cmp</span><span class="s0">(</span><span class="s5">1</span><span class="s0">);</span>
    <span class="s2">pr </span><span class="s0">= </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">precision</span><span class="s0">;</span>
    <span class="s2">rm </span><span class="s0">= </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">rounding</span><span class="s0">;</span>

    <span class="s1">if </span><span class="s0">(</span><span class="s2">k </span><span class="s0">!== -</span><span class="s5">1</span><span class="s0">) {</span>

      <span class="s4">// |x| is 1</span>
      <span class="s1">if </span><span class="s0">(</span><span class="s2">k </span><span class="s0">=== </span><span class="s5">0</span><span class="s0">) {</span>
        <span class="s2">halfPi </span><span class="s0">= </span><span class="s2">getPi</span><span class="s0">(</span><span class="s2">Ctor</span><span class="s0">, </span><span class="s2">pr </span><span class="s0">+ </span><span class="s5">4</span><span class="s0">, </span><span class="s2">rm</span><span class="s0">).</span><span class="s2">times</span><span class="s0">(</span><span class="s5">0.5</span><span class="s0">);</span>
        <span class="s2">halfPi</span><span class="s0">.</span><span class="s2">s </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">s</span><span class="s0">;</span>
        <span class="s1">return </span><span class="s2">halfPi</span><span class="s0">;</span>
      <span class="s0">}</span>

      <span class="s4">// |x| &gt; 1 or x is NaN</span>
      <span class="s1">return new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">NaN</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s4">// TODO? Special case asin(1/2) = pi/6 and asin(-1/2) = -pi/6</span>

    <span class="s2">Ctor</span><span class="s0">.</span><span class="s2">precision </span><span class="s0">= </span><span class="s2">pr </span><span class="s0">+ </span><span class="s5">6</span><span class="s0">;</span>
    <span class="s2">Ctor</span><span class="s0">.</span><span class="s2">rounding </span><span class="s0">= </span><span class="s5">1</span><span class="s0">;</span>

    <span class="s2">x </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">div</span><span class="s0">(</span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s5">1</span><span class="s0">).</span><span class="s2">minus</span><span class="s0">(</span><span class="s2">x</span><span class="s0">.</span><span class="s2">times</span><span class="s0">(</span><span class="s2">x</span><span class="s0">)).</span><span class="s2">sqrt</span><span class="s0">().</span><span class="s2">plus</span><span class="s0">(</span><span class="s5">1</span><span class="s0">)).</span><span class="s2">atan</span><span class="s0">();</span>

    <span class="s2">Ctor</span><span class="s0">.</span><span class="s2">precision </span><span class="s0">= </span><span class="s2">pr</span><span class="s0">;</span>
    <span class="s2">Ctor</span><span class="s0">.</span><span class="s2">rounding </span><span class="s0">= </span><span class="s2">rm</span><span class="s0">;</span>

    <span class="s1">return </span><span class="s2">x</span><span class="s0">.</span><span class="s2">times</span><span class="s0">(</span><span class="s5">2</span><span class="s0">);</span>
  <span class="s0">};</span>


  <span class="s4">/* 
   * Return a new Decimal whose value is the arctangent (inverse tangent) in radians of the value 
   * of this Decimal. 
   * 
   * Domain: [-Infinity, Infinity] 
   * Range: [-pi/2, pi/2] 
   * 
   * atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ... 
   * 
   * atan(0)         = 0 
   * atan(-0)        = -0 
   * atan(1)         = pi/4 
   * atan(-1)        = -pi/4 
   * atan(Infinity)  = pi/2 
   * atan(-Infinity) = -pi/2 
   * atan(NaN)       = NaN 
   * 
   */</span>
  <span class="s2">P</span><span class="s0">.</span><span class="s2">inverseTangent </span><span class="s0">= </span><span class="s2">P</span><span class="s0">.</span><span class="s2">atan </span><span class="s0">= </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">var </span><span class="s2">i</span><span class="s0">, </span><span class="s2">j</span><span class="s0">, </span><span class="s2">k</span><span class="s0">, </span><span class="s2">n</span><span class="s0">, </span><span class="s2">px</span><span class="s0">, </span><span class="s2">t</span><span class="s0">, </span><span class="s2">r</span><span class="s0">, </span><span class="s2">wpr</span><span class="s0">, </span><span class="s2">x2</span><span class="s0">,</span>
      <span class="s2">x </span><span class="s0">= </span><span class="s1">this</span><span class="s0">,</span>
      <span class="s2">Ctor </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">constructor</span><span class="s0">,</span>
      <span class="s2">pr </span><span class="s0">= </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">precision</span><span class="s0">,</span>
      <span class="s2">rm </span><span class="s0">= </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">rounding</span><span class="s0">;</span>

    <span class="s1">if </span><span class="s0">(!</span><span class="s2">x</span><span class="s0">.</span><span class="s2">isFinite</span><span class="s0">()) {</span>
      <span class="s1">if </span><span class="s0">(!</span><span class="s2">x</span><span class="s0">.</span><span class="s2">s</span><span class="s0">) </span><span class="s1">return new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">NaN</span><span class="s0">);</span>
      <span class="s1">if </span><span class="s0">(</span><span class="s2">pr </span><span class="s0">+ </span><span class="s5">4 </span><span class="s0">&lt;= </span><span class="s2">PI_PRECISION</span><span class="s0">) {</span>
        <span class="s2">r </span><span class="s0">= </span><span class="s2">getPi</span><span class="s0">(</span><span class="s2">Ctor</span><span class="s0">, </span><span class="s2">pr </span><span class="s0">+ </span><span class="s5">4</span><span class="s0">, </span><span class="s2">rm</span><span class="s0">).</span><span class="s2">times</span><span class="s0">(</span><span class="s5">0.5</span><span class="s0">);</span>
        <span class="s2">r</span><span class="s0">.</span><span class="s2">s </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">s</span><span class="s0">;</span>
        <span class="s1">return </span><span class="s2">r</span><span class="s0">;</span>
      <span class="s0">}</span>
    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(</span><span class="s2">x</span><span class="s0">.</span><span class="s2">isZero</span><span class="s0">()) {</span>
      <span class="s1">return new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">x</span><span class="s0">);</span>
    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(</span><span class="s2">x</span><span class="s0">.</span><span class="s2">abs</span><span class="s0">().</span><span class="s2">eq</span><span class="s0">(</span><span class="s5">1</span><span class="s0">) &amp;&amp; </span><span class="s2">pr </span><span class="s0">+ </span><span class="s5">4 </span><span class="s0">&lt;= </span><span class="s2">PI_PRECISION</span><span class="s0">) {</span>
      <span class="s2">r </span><span class="s0">= </span><span class="s2">getPi</span><span class="s0">(</span><span class="s2">Ctor</span><span class="s0">, </span><span class="s2">pr </span><span class="s0">+ </span><span class="s5">4</span><span class="s0">, </span><span class="s2">rm</span><span class="s0">).</span><span class="s2">times</span><span class="s0">(</span><span class="s5">0.25</span><span class="s0">);</span>
      <span class="s2">r</span><span class="s0">.</span><span class="s2">s </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">s</span><span class="s0">;</span>
      <span class="s1">return </span><span class="s2">r</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s2">Ctor</span><span class="s0">.</span><span class="s2">precision </span><span class="s0">= </span><span class="s2">wpr </span><span class="s0">= </span><span class="s2">pr </span><span class="s0">+ </span><span class="s5">10</span><span class="s0">;</span>
    <span class="s2">Ctor</span><span class="s0">.</span><span class="s2">rounding </span><span class="s0">= </span><span class="s5">1</span><span class="s0">;</span>

    <span class="s4">// TODO? if (x &gt;= 1 &amp;&amp; pr &lt;= PI_PRECISION) atan(x) = halfPi * x.s - atan(1 / x);</span>

    <span class="s4">// Argument reduction</span>
    <span class="s4">// Ensure |x| &lt; 0.42</span>
    <span class="s4">// atan(x) = 2 * atan(x / (1 + sqrt(1 + x^2)))</span>

    <span class="s2">k </span><span class="s0">= </span><span class="s2">Math</span><span class="s0">.</span><span class="s2">min</span><span class="s0">(</span><span class="s5">28</span><span class="s0">, </span><span class="s2">wpr </span><span class="s0">/ </span><span class="s2">LOG_BASE </span><span class="s0">+ </span><span class="s5">2 </span><span class="s0">| </span><span class="s5">0</span><span class="s0">);</span>

    <span class="s1">for </span><span class="s0">(</span><span class="s2">i </span><span class="s0">= </span><span class="s2">k</span><span class="s0">; </span><span class="s2">i</span><span class="s0">; --</span><span class="s2">i</span><span class="s0">) </span><span class="s2">x </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">div</span><span class="s0">(</span><span class="s2">x</span><span class="s0">.</span><span class="s2">times</span><span class="s0">(</span><span class="s2">x</span><span class="s0">).</span><span class="s2">plus</span><span class="s0">(</span><span class="s5">1</span><span class="s0">).</span><span class="s2">sqrt</span><span class="s0">().</span><span class="s2">plus</span><span class="s0">(</span><span class="s5">1</span><span class="s0">));</span>

    <span class="s2">external </span><span class="s0">= </span><span class="s1">false</span><span class="s0">;</span>

    <span class="s2">j </span><span class="s0">= </span><span class="s2">Math</span><span class="s0">.</span><span class="s2">ceil</span><span class="s0">(</span><span class="s2">wpr </span><span class="s0">/ </span><span class="s2">LOG_BASE</span><span class="s0">);</span>
    <span class="s2">n </span><span class="s0">= </span><span class="s5">1</span><span class="s0">;</span>
    <span class="s2">x2 </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">times</span><span class="s0">(</span><span class="s2">x</span><span class="s0">);</span>
    <span class="s2">r </span><span class="s0">= </span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">x</span><span class="s0">);</span>
    <span class="s2">px </span><span class="s0">= </span><span class="s2">x</span><span class="s0">;</span>

    <span class="s4">// atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...</span>
    <span class="s1">for </span><span class="s0">(; </span><span class="s2">i </span><span class="s0">!== -</span><span class="s5">1</span><span class="s0">;) {</span>
      <span class="s2">px </span><span class="s0">= </span><span class="s2">px</span><span class="s0">.</span><span class="s2">times</span><span class="s0">(</span><span class="s2">x2</span><span class="s0">);</span>
      <span class="s2">t </span><span class="s0">= </span><span class="s2">r</span><span class="s0">.</span><span class="s2">minus</span><span class="s0">(</span><span class="s2">px</span><span class="s0">.</span><span class="s2">div</span><span class="s0">(</span><span class="s2">n </span><span class="s0">+= </span><span class="s5">2</span><span class="s0">));</span>

      <span class="s2">px </span><span class="s0">= </span><span class="s2">px</span><span class="s0">.</span><span class="s2">times</span><span class="s0">(</span><span class="s2">x2</span><span class="s0">);</span>
      <span class="s2">r </span><span class="s0">= </span><span class="s2">t</span><span class="s0">.</span><span class="s2">plus</span><span class="s0">(</span><span class="s2">px</span><span class="s0">.</span><span class="s2">div</span><span class="s0">(</span><span class="s2">n </span><span class="s0">+= </span><span class="s5">2</span><span class="s0">));</span>

      <span class="s1">if </span><span class="s0">(</span><span class="s2">r</span><span class="s0">.</span><span class="s2">d</span><span class="s0">[</span><span class="s2">j</span><span class="s0">] !== </span><span class="s1">void </span><span class="s5">0</span><span class="s0">) </span><span class="s1">for </span><span class="s0">(</span><span class="s2">i </span><span class="s0">= </span><span class="s2">j</span><span class="s0">; </span><span class="s2">r</span><span class="s0">.</span><span class="s2">d</span><span class="s0">[</span><span class="s2">i</span><span class="s0">] === </span><span class="s2">t</span><span class="s0">.</span><span class="s2">d</span><span class="s0">[</span><span class="s2">i</span><span class="s0">] &amp;&amp; </span><span class="s2">i</span><span class="s0">--;);</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(</span><span class="s2">k</span><span class="s0">) </span><span class="s2">r </span><span class="s0">= </span><span class="s2">r</span><span class="s0">.</span><span class="s2">times</span><span class="s0">(</span><span class="s5">2 </span><span class="s0">&lt;&lt; (</span><span class="s2">k </span><span class="s0">- </span><span class="s5">1</span><span class="s0">));</span>

    <span class="s2">external </span><span class="s0">= </span><span class="s1">true</span><span class="s0">;</span>

    <span class="s1">return </span><span class="s2">finalise</span><span class="s0">(</span><span class="s2">r</span><span class="s0">, </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">precision </span><span class="s0">= </span><span class="s2">pr</span><span class="s0">, </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">rounding </span><span class="s0">= </span><span class="s2">rm</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>
  <span class="s0">};</span>


  <span class="s4">/* 
   * Return true if the value of this Decimal is a finite number, otherwise return false. 
   * 
   */</span>
  <span class="s2">P</span><span class="s0">.</span><span class="s2">isFinite </span><span class="s0">= </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">return </span><span class="s0">!!</span><span class="s1">this</span><span class="s0">.</span><span class="s2">d</span><span class="s0">;</span>
  <span class="s0">};</span>


  <span class="s4">/* 
   * Return true if the value of this Decimal is an integer, otherwise return false. 
   * 
   */</span>
  <span class="s2">P</span><span class="s0">.</span><span class="s2">isInteger </span><span class="s0">= </span><span class="s2">P</span><span class="s0">.</span><span class="s2">isInt </span><span class="s0">= </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">return </span><span class="s0">!!</span><span class="s1">this</span><span class="s0">.</span><span class="s2">d </span><span class="s0">&amp;&amp; </span><span class="s2">mathfloor</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.</span><span class="s2">e </span><span class="s0">/ </span><span class="s2">LOG_BASE</span><span class="s0">) &gt; </span><span class="s1">this</span><span class="s0">.</span><span class="s2">d</span><span class="s0">.</span><span class="s2">length </span><span class="s0">- </span><span class="s5">2</span><span class="s0">;</span>
  <span class="s0">};</span>


  <span class="s4">/* 
   * Return true if the value of this Decimal is NaN, otherwise return false. 
   * 
   */</span>
  <span class="s2">P</span><span class="s0">.</span><span class="s2">isNaN </span><span class="s0">= </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">return </span><span class="s0">!</span><span class="s1">this</span><span class="s0">.</span><span class="s2">s</span><span class="s0">;</span>
  <span class="s0">};</span>


  <span class="s4">/* 
   * Return true if the value of this Decimal is negative, otherwise return false. 
   * 
   */</span>
  <span class="s2">P</span><span class="s0">.</span><span class="s2">isNegative </span><span class="s0">= </span><span class="s2">P</span><span class="s0">.</span><span class="s2">isNeg </span><span class="s0">= </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">return this</span><span class="s0">.</span><span class="s2">s </span><span class="s0">&lt; </span><span class="s5">0</span><span class="s0">;</span>
  <span class="s0">};</span>


  <span class="s4">/* 
   * Return true if the value of this Decimal is positive, otherwise return false. 
   * 
   */</span>
  <span class="s2">P</span><span class="s0">.</span><span class="s2">isPositive </span><span class="s0">= </span><span class="s2">P</span><span class="s0">.</span><span class="s2">isPos </span><span class="s0">= </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">return this</span><span class="s0">.</span><span class="s2">s </span><span class="s0">&gt; </span><span class="s5">0</span><span class="s0">;</span>
  <span class="s0">};</span>


  <span class="s4">/* 
   * Return true if the value of this Decimal is 0 or -0, otherwise return false. 
   * 
   */</span>
  <span class="s2">P</span><span class="s0">.</span><span class="s2">isZero </span><span class="s0">= </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">return </span><span class="s0">!!</span><span class="s1">this</span><span class="s0">.</span><span class="s2">d </span><span class="s0">&amp;&amp; </span><span class="s1">this</span><span class="s0">.</span><span class="s2">d</span><span class="s0">[</span><span class="s5">0</span><span class="s0">] === </span><span class="s5">0</span><span class="s0">;</span>
  <span class="s0">};</span>


  <span class="s4">/* 
   * Return true if the value of this Decimal is less than `y`, otherwise return false. 
   * 
   */</span>
  <span class="s2">P</span><span class="s0">.</span><span class="s2">lessThan </span><span class="s0">= </span><span class="s2">P</span><span class="s0">.</span><span class="s2">lt </span><span class="s0">= </span><span class="s1">function </span><span class="s0">(</span><span class="s2">y</span><span class="s0">) {</span>
    <span class="s1">return this</span><span class="s0">.</span><span class="s2">cmp</span><span class="s0">(</span><span class="s2">y</span><span class="s0">) &lt; </span><span class="s5">0</span><span class="s0">;</span>
  <span class="s0">};</span>


  <span class="s4">/* 
   * Return true if the value of this Decimal is less than or equal to `y`, otherwise return false. 
   * 
   */</span>
  <span class="s2">P</span><span class="s0">.</span><span class="s2">lessThanOrEqualTo </span><span class="s0">= </span><span class="s2">P</span><span class="s0">.</span><span class="s2">lte </span><span class="s0">= </span><span class="s1">function </span><span class="s0">(</span><span class="s2">y</span><span class="s0">) {</span>
    <span class="s1">return this</span><span class="s0">.</span><span class="s2">cmp</span><span class="s0">(</span><span class="s2">y</span><span class="s0">) &lt; </span><span class="s5">1</span><span class="s0">;</span>
  <span class="s0">};</span>


  <span class="s4">/* 
   * Return the logarithm of the value of this Decimal to the specified base, rounded to `precision` 
   * significant digits using rounding mode `rounding`. 
   * 
   * If no base is specified, return log[10](arg). 
   * 
   * log[base](arg) = ln(arg) / ln(base) 
   * 
   * The result will always be correctly rounded if the base of the log is 10, and 'almost always' 
   * otherwise: 
   * 
   * Depending on the rounding mode, the result may be incorrectly rounded if the first fifteen 
   * rounding digits are [49]99999999999999 or [50]00000000000000. In that case, the maximum error 
   * between the result and the correctly rounded result will be one ulp (unit in the last place). 
   * 
   * log[-b](a)       = NaN 
   * log[0](a)        = NaN 
   * log[1](a)        = NaN 
   * log[NaN](a)      = NaN 
   * log[Infinity](a) = NaN 
   * log[b](0)        = -Infinity 
   * log[b](-0)       = -Infinity 
   * log[b](-a)       = NaN 
   * log[b](1)        = 0 
   * log[b](Infinity) = Infinity 
   * log[b](NaN)      = NaN 
   * 
   * [base] {number|string|bigint|Decimal} The base of the logarithm. 
   * 
   */</span>
  <span class="s2">P</span><span class="s0">.</span><span class="s2">logarithm </span><span class="s0">= </span><span class="s2">P</span><span class="s0">.</span><span class="s2">log </span><span class="s0">= </span><span class="s1">function </span><span class="s0">(</span><span class="s2">base</span><span class="s0">) {</span>
    <span class="s1">var </span><span class="s2">isBase10</span><span class="s0">, </span><span class="s2">d</span><span class="s0">, </span><span class="s2">denominator</span><span class="s0">, </span><span class="s2">k</span><span class="s0">, </span><span class="s2">inf</span><span class="s0">, </span><span class="s2">num</span><span class="s0">, </span><span class="s2">sd</span><span class="s0">, </span><span class="s2">r</span><span class="s0">,</span>
      <span class="s2">arg </span><span class="s0">= </span><span class="s1">this</span><span class="s0">,</span>
      <span class="s2">Ctor </span><span class="s0">= </span><span class="s2">arg</span><span class="s0">.</span><span class="s2">constructor</span><span class="s0">,</span>
      <span class="s2">pr </span><span class="s0">= </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">precision</span><span class="s0">,</span>
      <span class="s2">rm </span><span class="s0">= </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">rounding</span><span class="s0">,</span>
      <span class="s2">guard </span><span class="s0">= </span><span class="s5">5</span><span class="s0">;</span>

    <span class="s4">// Default base is 10.</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">base </span><span class="s0">== </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s2">base </span><span class="s0">= </span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s5">10</span><span class="s0">);</span>
      <span class="s2">isBase10 </span><span class="s0">= </span><span class="s1">true</span><span class="s0">;</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s2">base </span><span class="s0">= </span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">base</span><span class="s0">);</span>
      <span class="s2">d </span><span class="s0">= </span><span class="s2">base</span><span class="s0">.</span><span class="s2">d</span><span class="s0">;</span>

      <span class="s4">// Return NaN if base is negative, or non-finite, or is 0 or 1.</span>
      <span class="s1">if </span><span class="s0">(</span><span class="s2">base</span><span class="s0">.</span><span class="s2">s </span><span class="s0">&lt; </span><span class="s5">0 </span><span class="s0">|| !</span><span class="s2">d </span><span class="s0">|| !</span><span class="s2">d</span><span class="s0">[</span><span class="s5">0</span><span class="s0">] || </span><span class="s2">base</span><span class="s0">.</span><span class="s2">eq</span><span class="s0">(</span><span class="s5">1</span><span class="s0">)) </span><span class="s1">return new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">NaN</span><span class="s0">);</span>

      <span class="s2">isBase10 </span><span class="s0">= </span><span class="s2">base</span><span class="s0">.</span><span class="s2">eq</span><span class="s0">(</span><span class="s5">10</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s2">d </span><span class="s0">= </span><span class="s2">arg</span><span class="s0">.</span><span class="s2">d</span><span class="s0">;</span>

    <span class="s4">// Is arg negative, non-finite, 0 or 1?</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">arg</span><span class="s0">.</span><span class="s2">s </span><span class="s0">&lt; </span><span class="s5">0 </span><span class="s0">|| !</span><span class="s2">d </span><span class="s0">|| !</span><span class="s2">d</span><span class="s0">[</span><span class="s5">0</span><span class="s0">] || </span><span class="s2">arg</span><span class="s0">.</span><span class="s2">eq</span><span class="s0">(</span><span class="s5">1</span><span class="s0">)) {</span>
      <span class="s1">return new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">d </span><span class="s0">&amp;&amp; !</span><span class="s2">d</span><span class="s0">[</span><span class="s5">0</span><span class="s0">] ? -</span><span class="s5">1 </span><span class="s0">/ </span><span class="s5">0 </span><span class="s0">: </span><span class="s2">arg</span><span class="s0">.</span><span class="s2">s </span><span class="s0">!= </span><span class="s5">1 </span><span class="s0">? </span><span class="s2">NaN </span><span class="s0">: </span><span class="s2">d </span><span class="s0">? </span><span class="s5">0 </span><span class="s0">: </span><span class="s5">1 </span><span class="s0">/ </span><span class="s5">0</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s4">// The result will have a non-terminating decimal expansion if base is 10 and arg is not an</span>
    <span class="s4">// integer power of 10.</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">isBase10</span><span class="s0">) {</span>
      <span class="s1">if </span><span class="s0">(</span><span class="s2">d</span><span class="s0">.</span><span class="s2">length </span><span class="s0">&gt; </span><span class="s5">1</span><span class="s0">) {</span>
        <span class="s2">inf </span><span class="s0">= </span><span class="s1">true</span><span class="s0">;</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s2">k </span><span class="s0">= </span><span class="s2">d</span><span class="s0">[</span><span class="s5">0</span><span class="s0">]; </span><span class="s2">k </span><span class="s0">% </span><span class="s5">10 </span><span class="s0">=== </span><span class="s5">0</span><span class="s0">;) </span><span class="s2">k </span><span class="s0">/= </span><span class="s5">10</span><span class="s0">;</span>
        <span class="s2">inf </span><span class="s0">= </span><span class="s2">k </span><span class="s0">!== </span><span class="s5">1</span><span class="s0">;</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s2">external </span><span class="s0">= </span><span class="s1">false</span><span class="s0">;</span>
    <span class="s2">sd </span><span class="s0">= </span><span class="s2">pr </span><span class="s0">+ </span><span class="s2">guard</span><span class="s0">;</span>
    <span class="s2">num </span><span class="s0">= </span><span class="s2">naturalLogarithm</span><span class="s0">(</span><span class="s2">arg</span><span class="s0">, </span><span class="s2">sd</span><span class="s0">);</span>
    <span class="s2">denominator </span><span class="s0">= </span><span class="s2">isBase10 </span><span class="s0">? </span><span class="s2">getLn10</span><span class="s0">(</span><span class="s2">Ctor</span><span class="s0">, </span><span class="s2">sd </span><span class="s0">+ </span><span class="s5">10</span><span class="s0">) : </span><span class="s2">naturalLogarithm</span><span class="s0">(</span><span class="s2">base</span><span class="s0">, </span><span class="s2">sd</span><span class="s0">);</span>

    <span class="s4">// The result will have 5 rounding digits.</span>
    <span class="s2">r </span><span class="s0">= </span><span class="s2">divide</span><span class="s0">(</span><span class="s2">num</span><span class="s0">, </span><span class="s2">denominator</span><span class="s0">, </span><span class="s2">sd</span><span class="s0">, </span><span class="s5">1</span><span class="s0">);</span>

    <span class="s4">// If at a rounding boundary, i.e. the result's rounding digits are [49]9999 or [50]0000,</span>
    <span class="s4">// calculate 10 further digits.</span>
    <span class="s4">//</span>
    <span class="s4">// If the result is known to have an infinite decimal expansion, repeat this until it is clear</span>
    <span class="s4">// that the result is above or below the boundary. Otherwise, if after calculating the 10</span>
    <span class="s4">// further digits, the last 14 are nines, round up and assume the result is exact.</span>
    <span class="s4">// Also assume the result is exact if the last 14 are zero.</span>
    <span class="s4">//</span>
    <span class="s4">// Example of a result that will be incorrectly rounded:</span>
    <span class="s4">// log[1048576](4503599627370502) = 2.60000000000000009610279511444746...</span>
    <span class="s4">// The above result correctly rounded using ROUND_CEIL to 1 decimal place should be 2.7, but it</span>
    <span class="s4">// will be given as 2.6 as there are 15 zeros immediately after the requested decimal place, so</span>
    <span class="s4">// the exact result would be assumed to be 2.6, which rounded using ROUND_CEIL to 1 decimal</span>
    <span class="s4">// place is still 2.6.</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">checkRoundingDigits</span><span class="s0">(</span><span class="s2">r</span><span class="s0">.</span><span class="s2">d</span><span class="s0">, </span><span class="s2">k </span><span class="s0">= </span><span class="s2">pr</span><span class="s0">, </span><span class="s2">rm</span><span class="s0">)) {</span>

      <span class="s1">do </span><span class="s0">{</span>
        <span class="s2">sd </span><span class="s0">+= </span><span class="s5">10</span><span class="s0">;</span>
        <span class="s2">num </span><span class="s0">= </span><span class="s2">naturalLogarithm</span><span class="s0">(</span><span class="s2">arg</span><span class="s0">, </span><span class="s2">sd</span><span class="s0">);</span>
        <span class="s2">denominator </span><span class="s0">= </span><span class="s2">isBase10 </span><span class="s0">? </span><span class="s2">getLn10</span><span class="s0">(</span><span class="s2">Ctor</span><span class="s0">, </span><span class="s2">sd </span><span class="s0">+ </span><span class="s5">10</span><span class="s0">) : </span><span class="s2">naturalLogarithm</span><span class="s0">(</span><span class="s2">base</span><span class="s0">, </span><span class="s2">sd</span><span class="s0">);</span>
        <span class="s2">r </span><span class="s0">= </span><span class="s2">divide</span><span class="s0">(</span><span class="s2">num</span><span class="s0">, </span><span class="s2">denominator</span><span class="s0">, </span><span class="s2">sd</span><span class="s0">, </span><span class="s5">1</span><span class="s0">);</span>

        <span class="s1">if </span><span class="s0">(!</span><span class="s2">inf</span><span class="s0">) {</span>

          <span class="s4">// Check for 14 nines from the 2nd rounding digit, as the first may be 4.</span>
          <span class="s1">if </span><span class="s0">(+</span><span class="s2">digitsToString</span><span class="s0">(</span><span class="s2">r</span><span class="s0">.</span><span class="s2">d</span><span class="s0">).</span><span class="s2">slice</span><span class="s0">(</span><span class="s2">k </span><span class="s0">+ </span><span class="s5">1</span><span class="s0">, </span><span class="s2">k </span><span class="s0">+ </span><span class="s5">15</span><span class="s0">) + </span><span class="s5">1 </span><span class="s0">== </span><span class="s5">1e14</span><span class="s0">) {</span>
            <span class="s2">r </span><span class="s0">= </span><span class="s2">finalise</span><span class="s0">(</span><span class="s2">r</span><span class="s0">, </span><span class="s2">pr </span><span class="s0">+ </span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s0">);</span>
          <span class="s0">}</span>

          <span class="s1">break</span><span class="s0">;</span>
        <span class="s0">}</span>
      <span class="s0">} </span><span class="s1">while </span><span class="s0">(</span><span class="s2">checkRoundingDigits</span><span class="s0">(</span><span class="s2">r</span><span class="s0">.</span><span class="s2">d</span><span class="s0">, </span><span class="s2">k </span><span class="s0">+= </span><span class="s5">10</span><span class="s0">, </span><span class="s2">rm</span><span class="s0">));</span>
    <span class="s0">}</span>

    <span class="s2">external </span><span class="s0">= </span><span class="s1">true</span><span class="s0">;</span>

    <span class="s1">return </span><span class="s2">finalise</span><span class="s0">(</span><span class="s2">r</span><span class="s0">, </span><span class="s2">pr</span><span class="s0">, </span><span class="s2">rm</span><span class="s0">);</span>
  <span class="s0">};</span>


  <span class="s4">/* 
   * Return a new Decimal whose value is the maximum of the arguments and the value of this Decimal. 
   * 
   * arguments {number|string|bigint|Decimal} 
   * 
  P.max = function () { 
    Array.prototype.push.call(arguments, this); 
    return maxOrMin(this.constructor, arguments, -1); 
  }; 
   */</span>


  <span class="s4">/* 
   * Return a new Decimal whose value is the minimum of the arguments and the value of this Decimal. 
   * 
   * arguments {number|string|bigint|Decimal} 
   * 
  P.min = function () { 
    Array.prototype.push.call(arguments, this); 
    return maxOrMin(this.constructor, arguments, 1); 
  }; 
   */</span>


  <span class="s4">/* 
   *  n - 0 = n 
   *  n - N = N 
   *  n - I = -I 
   *  0 - n = -n 
   *  0 - 0 = 0 
   *  0 - N = N 
   *  0 - I = -I 
   *  N - n = N 
   *  N - 0 = N 
   *  N - N = N 
   *  N - I = N 
   *  I - n = I 
   *  I - 0 = I 
   *  I - N = N 
   *  I - I = N 
   * 
   * Return a new Decimal whose value is the value of this Decimal minus `y`, rounded to `precision` 
   * significant digits using rounding mode `rounding`. 
   * 
   */</span>
  <span class="s2">P</span><span class="s0">.</span><span class="s2">minus </span><span class="s0">= </span><span class="s2">P</span><span class="s0">.</span><span class="s2">sub </span><span class="s0">= </span><span class="s1">function </span><span class="s0">(</span><span class="s2">y</span><span class="s0">) {</span>
    <span class="s1">var </span><span class="s2">d</span><span class="s0">, </span><span class="s2">e</span><span class="s0">, </span><span class="s2">i</span><span class="s0">, </span><span class="s2">j</span><span class="s0">, </span><span class="s2">k</span><span class="s0">, </span><span class="s2">len</span><span class="s0">, </span><span class="s2">pr</span><span class="s0">, </span><span class="s2">rm</span><span class="s0">, </span><span class="s2">xd</span><span class="s0">, </span><span class="s2">xe</span><span class="s0">, </span><span class="s2">xLTy</span><span class="s0">, </span><span class="s2">yd</span><span class="s0">,</span>
      <span class="s2">x </span><span class="s0">= </span><span class="s1">this</span><span class="s0">,</span>
      <span class="s2">Ctor </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">constructor</span><span class="s0">;</span>

    <span class="s2">y </span><span class="s0">= </span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">y</span><span class="s0">);</span>

    <span class="s4">// If either is not finite...</span>
    <span class="s1">if </span><span class="s0">(!</span><span class="s2">x</span><span class="s0">.</span><span class="s2">d </span><span class="s0">|| !</span><span class="s2">y</span><span class="s0">.</span><span class="s2">d</span><span class="s0">) {</span>

      <span class="s4">// Return NaN if either is NaN.</span>
      <span class="s1">if </span><span class="s0">(!</span><span class="s2">x</span><span class="s0">.</span><span class="s2">s </span><span class="s0">|| !</span><span class="s2">y</span><span class="s0">.</span><span class="s2">s</span><span class="s0">) </span><span class="s2">y </span><span class="s0">= </span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">NaN</span><span class="s0">);</span>

      <span class="s4">// Return y negated if x is finite and y is ±Infinity.</span>
      <span class="s1">else if </span><span class="s0">(</span><span class="s2">x</span><span class="s0">.</span><span class="s2">d</span><span class="s0">) </span><span class="s2">y</span><span class="s0">.</span><span class="s2">s </span><span class="s0">= -</span><span class="s2">y</span><span class="s0">.</span><span class="s2">s</span><span class="s0">;</span>

      <span class="s4">// Return x if y is finite and x is ±Infinity.</span>
      <span class="s4">// Return x if both are ±Infinity with different signs.</span>
      <span class="s4">// Return NaN if both are ±Infinity with the same sign.</span>
      <span class="s1">else </span><span class="s2">y </span><span class="s0">= </span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">y</span><span class="s0">.</span><span class="s2">d </span><span class="s0">|| </span><span class="s2">x</span><span class="s0">.</span><span class="s2">s </span><span class="s0">!== </span><span class="s2">y</span><span class="s0">.</span><span class="s2">s </span><span class="s0">? </span><span class="s2">x </span><span class="s0">: </span><span class="s2">NaN</span><span class="s0">);</span>

      <span class="s1">return </span><span class="s2">y</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s4">// If signs differ...</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">x</span><span class="s0">.</span><span class="s2">s </span><span class="s0">!= </span><span class="s2">y</span><span class="s0">.</span><span class="s2">s</span><span class="s0">) {</span>
      <span class="s2">y</span><span class="s0">.</span><span class="s2">s </span><span class="s0">= -</span><span class="s2">y</span><span class="s0">.</span><span class="s2">s</span><span class="s0">;</span>
      <span class="s1">return </span><span class="s2">x</span><span class="s0">.</span><span class="s2">plus</span><span class="s0">(</span><span class="s2">y</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s2">xd </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">d</span><span class="s0">;</span>
    <span class="s2">yd </span><span class="s0">= </span><span class="s2">y</span><span class="s0">.</span><span class="s2">d</span><span class="s0">;</span>
    <span class="s2">pr </span><span class="s0">= </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">precision</span><span class="s0">;</span>
    <span class="s2">rm </span><span class="s0">= </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">rounding</span><span class="s0">;</span>

    <span class="s4">// If either is zero...</span>
    <span class="s1">if </span><span class="s0">(!</span><span class="s2">xd</span><span class="s0">[</span><span class="s5">0</span><span class="s0">] || !</span><span class="s2">yd</span><span class="s0">[</span><span class="s5">0</span><span class="s0">]) {</span>

      <span class="s4">// Return y negated if x is zero and y is non-zero.</span>
      <span class="s1">if </span><span class="s0">(</span><span class="s2">yd</span><span class="s0">[</span><span class="s5">0</span><span class="s0">]) </span><span class="s2">y</span><span class="s0">.</span><span class="s2">s </span><span class="s0">= -</span><span class="s2">y</span><span class="s0">.</span><span class="s2">s</span><span class="s0">;</span>

      <span class="s4">// Return x if y is zero and x is non-zero.</span>
      <span class="s1">else if </span><span class="s0">(</span><span class="s2">xd</span><span class="s0">[</span><span class="s5">0</span><span class="s0">]) </span><span class="s2">y </span><span class="s0">= </span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">x</span><span class="s0">);</span>

      <span class="s4">// Return zero if both are zero.</span>
      <span class="s4">// From IEEE 754 (2008) 6.3: 0 - 0 = -0 - -0 = -0 when rounding to -Infinity.</span>
      <span class="s1">else return new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">rm </span><span class="s0">=== </span><span class="s5">3 </span><span class="s0">? -</span><span class="s5">0 </span><span class="s0">: </span><span class="s5">0</span><span class="s0">);</span>

      <span class="s1">return </span><span class="s2">external </span><span class="s0">? </span><span class="s2">finalise</span><span class="s0">(</span><span class="s2">y</span><span class="s0">, </span><span class="s2">pr</span><span class="s0">, </span><span class="s2">rm</span><span class="s0">) : </span><span class="s2">y</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s4">// x and y are finite, non-zero numbers with the same sign.</span>

    <span class="s4">// Calculate base 1e7 exponents.</span>
    <span class="s2">e </span><span class="s0">= </span><span class="s2">mathfloor</span><span class="s0">(</span><span class="s2">y</span><span class="s0">.</span><span class="s2">e </span><span class="s0">/ </span><span class="s2">LOG_BASE</span><span class="s0">);</span>
    <span class="s2">xe </span><span class="s0">= </span><span class="s2">mathfloor</span><span class="s0">(</span><span class="s2">x</span><span class="s0">.</span><span class="s2">e </span><span class="s0">/ </span><span class="s2">LOG_BASE</span><span class="s0">);</span>

    <span class="s2">xd </span><span class="s0">= </span><span class="s2">xd</span><span class="s0">.</span><span class="s2">slice</span><span class="s0">();</span>
    <span class="s2">k </span><span class="s0">= </span><span class="s2">xe </span><span class="s0">- </span><span class="s2">e</span><span class="s0">;</span>

    <span class="s4">// If base 1e7 exponents differ...</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">k</span><span class="s0">) {</span>
      <span class="s2">xLTy </span><span class="s0">= </span><span class="s2">k </span><span class="s0">&lt; </span><span class="s5">0</span><span class="s0">;</span>

      <span class="s1">if </span><span class="s0">(</span><span class="s2">xLTy</span><span class="s0">) {</span>
        <span class="s2">d </span><span class="s0">= </span><span class="s2">xd</span><span class="s0">;</span>
        <span class="s2">k </span><span class="s0">= -</span><span class="s2">k</span><span class="s0">;</span>
        <span class="s2">len </span><span class="s0">= </span><span class="s2">yd</span><span class="s0">.</span><span class="s2">length</span><span class="s0">;</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s2">d </span><span class="s0">= </span><span class="s2">yd</span><span class="s0">;</span>
        <span class="s2">e </span><span class="s0">= </span><span class="s2">xe</span><span class="s0">;</span>
        <span class="s2">len </span><span class="s0">= </span><span class="s2">xd</span><span class="s0">.</span><span class="s2">length</span><span class="s0">;</span>
      <span class="s0">}</span>

      <span class="s4">// Numbers with massively different exponents would result in a very high number of</span>
      <span class="s4">// zeros needing to be prepended, but this can be avoided while still ensuring correct</span>
      <span class="s4">// rounding by limiting the number of zeros to `Math.ceil(pr / LOG_BASE) + 2`.</span>
      <span class="s2">i </span><span class="s0">= </span><span class="s2">Math</span><span class="s0">.</span><span class="s2">max</span><span class="s0">(</span><span class="s2">Math</span><span class="s0">.</span><span class="s2">ceil</span><span class="s0">(</span><span class="s2">pr </span><span class="s0">/ </span><span class="s2">LOG_BASE</span><span class="s0">), </span><span class="s2">len</span><span class="s0">) + </span><span class="s5">2</span><span class="s0">;</span>

      <span class="s1">if </span><span class="s0">(</span><span class="s2">k </span><span class="s0">&gt; </span><span class="s2">i</span><span class="s0">) {</span>
        <span class="s2">k </span><span class="s0">= </span><span class="s2">i</span><span class="s0">;</span>
        <span class="s2">d</span><span class="s0">.</span><span class="s2">length </span><span class="s0">= </span><span class="s5">1</span><span class="s0">;</span>
      <span class="s0">}</span>

      <span class="s4">// Prepend zeros to equalise exponents.</span>
      <span class="s2">d</span><span class="s0">.</span><span class="s2">reverse</span><span class="s0">();</span>
      <span class="s1">for </span><span class="s0">(</span><span class="s2">i </span><span class="s0">= </span><span class="s2">k</span><span class="s0">; </span><span class="s2">i</span><span class="s0">--;) </span><span class="s2">d</span><span class="s0">.</span><span class="s2">push</span><span class="s0">(</span><span class="s5">0</span><span class="s0">);</span>
      <span class="s2">d</span><span class="s0">.</span><span class="s2">reverse</span><span class="s0">();</span>

    <span class="s4">// Base 1e7 exponents equal.</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>

      <span class="s4">// Check digits to determine which is the bigger number.</span>

      <span class="s2">i </span><span class="s0">= </span><span class="s2">xd</span><span class="s0">.</span><span class="s2">length</span><span class="s0">;</span>
      <span class="s2">len </span><span class="s0">= </span><span class="s2">yd</span><span class="s0">.</span><span class="s2">length</span><span class="s0">;</span>
      <span class="s2">xLTy </span><span class="s0">= </span><span class="s2">i </span><span class="s0">&lt; </span><span class="s2">len</span><span class="s0">;</span>
      <span class="s1">if </span><span class="s0">(</span><span class="s2">xLTy</span><span class="s0">) </span><span class="s2">len </span><span class="s0">= </span><span class="s2">i</span><span class="s0">;</span>

      <span class="s1">for </span><span class="s0">(</span><span class="s2">i </span><span class="s0">= </span><span class="s5">0</span><span class="s0">; </span><span class="s2">i </span><span class="s0">&lt; </span><span class="s2">len</span><span class="s0">; </span><span class="s2">i</span><span class="s0">++) {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s2">xd</span><span class="s0">[</span><span class="s2">i</span><span class="s0">] != </span><span class="s2">yd</span><span class="s0">[</span><span class="s2">i</span><span class="s0">]) {</span>
          <span class="s2">xLTy </span><span class="s0">= </span><span class="s2">xd</span><span class="s0">[</span><span class="s2">i</span><span class="s0">] &lt; </span><span class="s2">yd</span><span class="s0">[</span><span class="s2">i</span><span class="s0">];</span>
          <span class="s1">break</span><span class="s0">;</span>
        <span class="s0">}</span>
      <span class="s0">}</span>

      <span class="s2">k </span><span class="s0">= </span><span class="s5">0</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(</span><span class="s2">xLTy</span><span class="s0">) {</span>
      <span class="s2">d </span><span class="s0">= </span><span class="s2">xd</span><span class="s0">;</span>
      <span class="s2">xd </span><span class="s0">= </span><span class="s2">yd</span><span class="s0">;</span>
      <span class="s2">yd </span><span class="s0">= </span><span class="s2">d</span><span class="s0">;</span>
      <span class="s2">y</span><span class="s0">.</span><span class="s2">s </span><span class="s0">= -</span><span class="s2">y</span><span class="s0">.</span><span class="s2">s</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s2">len </span><span class="s0">= </span><span class="s2">xd</span><span class="s0">.</span><span class="s2">length</span><span class="s0">;</span>

    <span class="s4">// Append zeros to `xd` if shorter.</span>
    <span class="s4">// Don't add zeros to `yd` if shorter as subtraction only needs to start at `yd` length.</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s2">i </span><span class="s0">= </span><span class="s2">yd</span><span class="s0">.</span><span class="s2">length </span><span class="s0">- </span><span class="s2">len</span><span class="s0">; </span><span class="s2">i </span><span class="s0">&gt; </span><span class="s5">0</span><span class="s0">; --</span><span class="s2">i</span><span class="s0">) </span><span class="s2">xd</span><span class="s0">[</span><span class="s2">len</span><span class="s0">++] = </span><span class="s5">0</span><span class="s0">;</span>

    <span class="s4">// Subtract yd from xd.</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s2">i </span><span class="s0">= </span><span class="s2">yd</span><span class="s0">.</span><span class="s2">length</span><span class="s0">; </span><span class="s2">i </span><span class="s0">&gt; </span><span class="s2">k</span><span class="s0">;) {</span>

      <span class="s1">if </span><span class="s0">(</span><span class="s2">xd</span><span class="s0">[--</span><span class="s2">i</span><span class="s0">] &lt; </span><span class="s2">yd</span><span class="s0">[</span><span class="s2">i</span><span class="s0">]) {</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s2">j </span><span class="s0">= </span><span class="s2">i</span><span class="s0">; </span><span class="s2">j </span><span class="s0">&amp;&amp; </span><span class="s2">xd</span><span class="s0">[--</span><span class="s2">j</span><span class="s0">] === </span><span class="s5">0</span><span class="s0">;) </span><span class="s2">xd</span><span class="s0">[</span><span class="s2">j</span><span class="s0">] = </span><span class="s2">BASE </span><span class="s0">- </span><span class="s5">1</span><span class="s0">;</span>
        <span class="s0">--</span><span class="s2">xd</span><span class="s0">[</span><span class="s2">j</span><span class="s0">];</span>
        <span class="s2">xd</span><span class="s0">[</span><span class="s2">i</span><span class="s0">] += </span><span class="s2">BASE</span><span class="s0">;</span>
      <span class="s0">}</span>

      <span class="s2">xd</span><span class="s0">[</span><span class="s2">i</span><span class="s0">] -= </span><span class="s2">yd</span><span class="s0">[</span><span class="s2">i</span><span class="s0">];</span>
    <span class="s0">}</span>

    <span class="s4">// Remove trailing zeros.</span>
    <span class="s1">for </span><span class="s0">(; </span><span class="s2">xd</span><span class="s0">[--</span><span class="s2">len</span><span class="s0">] === </span><span class="s5">0</span><span class="s0">;) </span><span class="s2">xd</span><span class="s0">.</span><span class="s2">pop</span><span class="s0">();</span>

    <span class="s4">// Remove leading zeros and adjust exponent accordingly.</span>
    <span class="s1">for </span><span class="s0">(; </span><span class="s2">xd</span><span class="s0">[</span><span class="s5">0</span><span class="s0">] === </span><span class="s5">0</span><span class="s0">; </span><span class="s2">xd</span><span class="s0">.</span><span class="s2">shift</span><span class="s0">()) --</span><span class="s2">e</span><span class="s0">;</span>

    <span class="s4">// Zero?</span>
    <span class="s1">if </span><span class="s0">(!</span><span class="s2">xd</span><span class="s0">[</span><span class="s5">0</span><span class="s0">]) </span><span class="s1">return new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">rm </span><span class="s0">=== </span><span class="s5">3 </span><span class="s0">? -</span><span class="s5">0 </span><span class="s0">: </span><span class="s5">0</span><span class="s0">);</span>

    <span class="s2">y</span><span class="s0">.</span><span class="s2">d </span><span class="s0">= </span><span class="s2">xd</span><span class="s0">;</span>
    <span class="s2">y</span><span class="s0">.</span><span class="s2">e </span><span class="s0">= </span><span class="s2">getBase10Exponent</span><span class="s0">(</span><span class="s2">xd</span><span class="s0">, </span><span class="s2">e</span><span class="s0">);</span>

    <span class="s1">return </span><span class="s2">external </span><span class="s0">? </span><span class="s2">finalise</span><span class="s0">(</span><span class="s2">y</span><span class="s0">, </span><span class="s2">pr</span><span class="s0">, </span><span class="s2">rm</span><span class="s0">) : </span><span class="s2">y</span><span class="s0">;</span>
  <span class="s0">};</span>


  <span class="s4">/* 
   *   n % 0 =  N 
   *   n % N =  N 
   *   n % I =  n 
   *   0 % n =  0 
   *  -0 % n = -0 
   *   0 % 0 =  N 
   *   0 % N =  N 
   *   0 % I =  0 
   *   N % n =  N 
   *   N % 0 =  N 
   *   N % N =  N 
   *   N % I =  N 
   *   I % n =  N 
   *   I % 0 =  N 
   *   I % N =  N 
   *   I % I =  N 
   * 
   * Return a new Decimal whose value is the value of this Decimal modulo `y`, rounded to 
   * `precision` significant digits using rounding mode `rounding`. 
   * 
   * The result depends on the modulo mode. 
   * 
   */</span>
  <span class="s2">P</span><span class="s0">.</span><span class="s2">modulo </span><span class="s0">= </span><span class="s2">P</span><span class="s0">.</span><span class="s2">mod </span><span class="s0">= </span><span class="s1">function </span><span class="s0">(</span><span class="s2">y</span><span class="s0">) {</span>
    <span class="s1">var </span><span class="s2">q</span><span class="s0">,</span>
      <span class="s2">x </span><span class="s0">= </span><span class="s1">this</span><span class="s0">,</span>
      <span class="s2">Ctor </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">constructor</span><span class="s0">;</span>

    <span class="s2">y </span><span class="s0">= </span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">y</span><span class="s0">);</span>

    <span class="s4">// Return NaN if x is ±Infinity or NaN, or y is NaN or ±0.</span>
    <span class="s1">if </span><span class="s0">(!</span><span class="s2">x</span><span class="s0">.</span><span class="s2">d </span><span class="s0">|| !</span><span class="s2">y</span><span class="s0">.</span><span class="s2">s </span><span class="s0">|| </span><span class="s2">y</span><span class="s0">.</span><span class="s2">d </span><span class="s0">&amp;&amp; !</span><span class="s2">y</span><span class="s0">.</span><span class="s2">d</span><span class="s0">[</span><span class="s5">0</span><span class="s0">]) </span><span class="s1">return new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">NaN</span><span class="s0">);</span>

    <span class="s4">// Return x if y is ±Infinity or x is ±0.</span>
    <span class="s1">if </span><span class="s0">(!</span><span class="s2">y</span><span class="s0">.</span><span class="s2">d </span><span class="s0">|| </span><span class="s2">x</span><span class="s0">.</span><span class="s2">d </span><span class="s0">&amp;&amp; !</span><span class="s2">x</span><span class="s0">.</span><span class="s2">d</span><span class="s0">[</span><span class="s5">0</span><span class="s0">]) {</span>
      <span class="s1">return </span><span class="s2">finalise</span><span class="s0">(</span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">x</span><span class="s0">), </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">precision</span><span class="s0">, </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">rounding</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s4">// Prevent rounding of intermediate calculations.</span>
    <span class="s2">external </span><span class="s0">= </span><span class="s1">false</span><span class="s0">;</span>

    <span class="s1">if </span><span class="s0">(</span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">modulo </span><span class="s0">== </span><span class="s5">9</span><span class="s0">) {</span>

      <span class="s4">// Euclidian division: q = sign(y) * floor(x / abs(y))</span>
      <span class="s4">// result = x - q * y    where  0 &lt;= result &lt; abs(y)</span>
      <span class="s2">q </span><span class="s0">= </span><span class="s2">divide</span><span class="s0">(</span><span class="s2">x</span><span class="s0">, </span><span class="s2">y</span><span class="s0">.</span><span class="s2">abs</span><span class="s0">(), </span><span class="s5">0</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">1</span><span class="s0">);</span>
      <span class="s2">q</span><span class="s0">.</span><span class="s2">s </span><span class="s0">*= </span><span class="s2">y</span><span class="s0">.</span><span class="s2">s</span><span class="s0">;</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s2">q </span><span class="s0">= </span><span class="s2">divide</span><span class="s0">(</span><span class="s2">x</span><span class="s0">, </span><span class="s2">y</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">modulo</span><span class="s0">, </span><span class="s5">1</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s2">q </span><span class="s0">= </span><span class="s2">q</span><span class="s0">.</span><span class="s2">times</span><span class="s0">(</span><span class="s2">y</span><span class="s0">);</span>

    <span class="s2">external </span><span class="s0">= </span><span class="s1">true</span><span class="s0">;</span>

    <span class="s1">return </span><span class="s2">x</span><span class="s0">.</span><span class="s2">minus</span><span class="s0">(</span><span class="s2">q</span><span class="s0">);</span>
  <span class="s0">};</span>


  <span class="s4">/* 
   * Return a new Decimal whose value is the natural exponential of the value of this Decimal, 
   * i.e. the base e raised to the power the value of this Decimal, rounded to `precision` 
   * significant digits using rounding mode `rounding`. 
   * 
   */</span>
  <span class="s2">P</span><span class="s0">.</span><span class="s2">naturalExponential </span><span class="s0">= </span><span class="s2">P</span><span class="s0">.</span><span class="s2">exp </span><span class="s0">= </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">return </span><span class="s2">naturalExponential</span><span class="s0">(</span><span class="s1">this</span><span class="s0">);</span>
  <span class="s0">};</span>


  <span class="s4">/* 
   * Return a new Decimal whose value is the natural logarithm of the value of this Decimal, 
   * rounded to `precision` significant digits using rounding mode `rounding`. 
   * 
   */</span>
  <span class="s2">P</span><span class="s0">.</span><span class="s2">naturalLogarithm </span><span class="s0">= </span><span class="s2">P</span><span class="s0">.</span><span class="s2">ln </span><span class="s0">= </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">return </span><span class="s2">naturalLogarithm</span><span class="s0">(</span><span class="s1">this</span><span class="s0">);</span>
  <span class="s0">};</span>


  <span class="s4">/* 
   * Return a new Decimal whose value is the value of this Decimal negated, i.e. as if multiplied by 
   * -1. 
   * 
   */</span>
  <span class="s2">P</span><span class="s0">.</span><span class="s2">negated </span><span class="s0">= </span><span class="s2">P</span><span class="s0">.</span><span class="s2">neg </span><span class="s0">= </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">var </span><span class="s2">x </span><span class="s0">= </span><span class="s1">new this</span><span class="s0">.</span><span class="s2">constructor</span><span class="s0">(</span><span class="s1">this</span><span class="s0">);</span>
    <span class="s2">x</span><span class="s0">.</span><span class="s2">s </span><span class="s0">= -</span><span class="s2">x</span><span class="s0">.</span><span class="s2">s</span><span class="s0">;</span>
    <span class="s1">return </span><span class="s2">finalise</span><span class="s0">(</span><span class="s2">x</span><span class="s0">);</span>
  <span class="s0">};</span>


  <span class="s4">/* 
   *  n + 0 = n 
   *  n + N = N 
   *  n + I = I 
   *  0 + n = n 
   *  0 + 0 = 0 
   *  0 + N = N 
   *  0 + I = I 
   *  N + n = N 
   *  N + 0 = N 
   *  N + N = N 
   *  N + I = N 
   *  I + n = I 
   *  I + 0 = I 
   *  I + N = N 
   *  I + I = I 
   * 
   * Return a new Decimal whose value is the value of this Decimal plus `y`, rounded to `precision` 
   * significant digits using rounding mode `rounding`. 
   * 
   */</span>
  <span class="s2">P</span><span class="s0">.</span><span class="s2">plus </span><span class="s0">= </span><span class="s2">P</span><span class="s0">.</span><span class="s2">add </span><span class="s0">= </span><span class="s1">function </span><span class="s0">(</span><span class="s2">y</span><span class="s0">) {</span>
    <span class="s1">var </span><span class="s2">carry</span><span class="s0">, </span><span class="s2">d</span><span class="s0">, </span><span class="s2">e</span><span class="s0">, </span><span class="s2">i</span><span class="s0">, </span><span class="s2">k</span><span class="s0">, </span><span class="s2">len</span><span class="s0">, </span><span class="s2">pr</span><span class="s0">, </span><span class="s2">rm</span><span class="s0">, </span><span class="s2">xd</span><span class="s0">, </span><span class="s2">yd</span><span class="s0">,</span>
      <span class="s2">x </span><span class="s0">= </span><span class="s1">this</span><span class="s0">,</span>
      <span class="s2">Ctor </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">constructor</span><span class="s0">;</span>

    <span class="s2">y </span><span class="s0">= </span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">y</span><span class="s0">);</span>

    <span class="s4">// If either is not finite...</span>
    <span class="s1">if </span><span class="s0">(!</span><span class="s2">x</span><span class="s0">.</span><span class="s2">d </span><span class="s0">|| !</span><span class="s2">y</span><span class="s0">.</span><span class="s2">d</span><span class="s0">) {</span>

      <span class="s4">// Return NaN if either is NaN.</span>
      <span class="s1">if </span><span class="s0">(!</span><span class="s2">x</span><span class="s0">.</span><span class="s2">s </span><span class="s0">|| !</span><span class="s2">y</span><span class="s0">.</span><span class="s2">s</span><span class="s0">) </span><span class="s2">y </span><span class="s0">= </span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">NaN</span><span class="s0">);</span>

      <span class="s4">// Return x if y is finite and x is ±Infinity.</span>
      <span class="s4">// Return x if both are ±Infinity with the same sign.</span>
      <span class="s4">// Return NaN if both are ±Infinity with different signs.</span>
      <span class="s4">// Return y if x is finite and y is ±Infinity.</span>
      <span class="s1">else if </span><span class="s0">(!</span><span class="s2">x</span><span class="s0">.</span><span class="s2">d</span><span class="s0">) </span><span class="s2">y </span><span class="s0">= </span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">y</span><span class="s0">.</span><span class="s2">d </span><span class="s0">|| </span><span class="s2">x</span><span class="s0">.</span><span class="s2">s </span><span class="s0">=== </span><span class="s2">y</span><span class="s0">.</span><span class="s2">s </span><span class="s0">? </span><span class="s2">x </span><span class="s0">: </span><span class="s2">NaN</span><span class="s0">);</span>

      <span class="s1">return </span><span class="s2">y</span><span class="s0">;</span>
    <span class="s0">}</span>

     <span class="s4">// If signs differ...</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">x</span><span class="s0">.</span><span class="s2">s </span><span class="s0">!= </span><span class="s2">y</span><span class="s0">.</span><span class="s2">s</span><span class="s0">) {</span>
      <span class="s2">y</span><span class="s0">.</span><span class="s2">s </span><span class="s0">= -</span><span class="s2">y</span><span class="s0">.</span><span class="s2">s</span><span class="s0">;</span>
      <span class="s1">return </span><span class="s2">x</span><span class="s0">.</span><span class="s2">minus</span><span class="s0">(</span><span class="s2">y</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s2">xd </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">d</span><span class="s0">;</span>
    <span class="s2">yd </span><span class="s0">= </span><span class="s2">y</span><span class="s0">.</span><span class="s2">d</span><span class="s0">;</span>
    <span class="s2">pr </span><span class="s0">= </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">precision</span><span class="s0">;</span>
    <span class="s2">rm </span><span class="s0">= </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">rounding</span><span class="s0">;</span>

    <span class="s4">// If either is zero...</span>
    <span class="s1">if </span><span class="s0">(!</span><span class="s2">xd</span><span class="s0">[</span><span class="s5">0</span><span class="s0">] || !</span><span class="s2">yd</span><span class="s0">[</span><span class="s5">0</span><span class="s0">]) {</span>

      <span class="s4">// Return x if y is zero.</span>
      <span class="s4">// Return y if y is non-zero.</span>
      <span class="s1">if </span><span class="s0">(!</span><span class="s2">yd</span><span class="s0">[</span><span class="s5">0</span><span class="s0">]) </span><span class="s2">y </span><span class="s0">= </span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">x</span><span class="s0">);</span>

      <span class="s1">return </span><span class="s2">external </span><span class="s0">? </span><span class="s2">finalise</span><span class="s0">(</span><span class="s2">y</span><span class="s0">, </span><span class="s2">pr</span><span class="s0">, </span><span class="s2">rm</span><span class="s0">) : </span><span class="s2">y</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s4">// x and y are finite, non-zero numbers with the same sign.</span>

    <span class="s4">// Calculate base 1e7 exponents.</span>
    <span class="s2">k </span><span class="s0">= </span><span class="s2">mathfloor</span><span class="s0">(</span><span class="s2">x</span><span class="s0">.</span><span class="s2">e </span><span class="s0">/ </span><span class="s2">LOG_BASE</span><span class="s0">);</span>
    <span class="s2">e </span><span class="s0">= </span><span class="s2">mathfloor</span><span class="s0">(</span><span class="s2">y</span><span class="s0">.</span><span class="s2">e </span><span class="s0">/ </span><span class="s2">LOG_BASE</span><span class="s0">);</span>

    <span class="s2">xd </span><span class="s0">= </span><span class="s2">xd</span><span class="s0">.</span><span class="s2">slice</span><span class="s0">();</span>
    <span class="s2">i </span><span class="s0">= </span><span class="s2">k </span><span class="s0">- </span><span class="s2">e</span><span class="s0">;</span>

    <span class="s4">// If base 1e7 exponents differ...</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">i</span><span class="s0">) {</span>

      <span class="s1">if </span><span class="s0">(</span><span class="s2">i </span><span class="s0">&lt; </span><span class="s5">0</span><span class="s0">) {</span>
        <span class="s2">d </span><span class="s0">= </span><span class="s2">xd</span><span class="s0">;</span>
        <span class="s2">i </span><span class="s0">= -</span><span class="s2">i</span><span class="s0">;</span>
        <span class="s2">len </span><span class="s0">= </span><span class="s2">yd</span><span class="s0">.</span><span class="s2">length</span><span class="s0">;</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s2">d </span><span class="s0">= </span><span class="s2">yd</span><span class="s0">;</span>
        <span class="s2">e </span><span class="s0">= </span><span class="s2">k</span><span class="s0">;</span>
        <span class="s2">len </span><span class="s0">= </span><span class="s2">xd</span><span class="s0">.</span><span class="s2">length</span><span class="s0">;</span>
      <span class="s0">}</span>

      <span class="s4">// Limit number of zeros prepended to max(ceil(pr / LOG_BASE), len) + 1.</span>
      <span class="s2">k </span><span class="s0">= </span><span class="s2">Math</span><span class="s0">.</span><span class="s2">ceil</span><span class="s0">(</span><span class="s2">pr </span><span class="s0">/ </span><span class="s2">LOG_BASE</span><span class="s0">);</span>
      <span class="s2">len </span><span class="s0">= </span><span class="s2">k </span><span class="s0">&gt; </span><span class="s2">len </span><span class="s0">? </span><span class="s2">k </span><span class="s0">+ </span><span class="s5">1 </span><span class="s0">: </span><span class="s2">len </span><span class="s0">+ </span><span class="s5">1</span><span class="s0">;</span>

      <span class="s1">if </span><span class="s0">(</span><span class="s2">i </span><span class="s0">&gt; </span><span class="s2">len</span><span class="s0">) {</span>
        <span class="s2">i </span><span class="s0">= </span><span class="s2">len</span><span class="s0">;</span>
        <span class="s2">d</span><span class="s0">.</span><span class="s2">length </span><span class="s0">= </span><span class="s5">1</span><span class="s0">;</span>
      <span class="s0">}</span>

      <span class="s4">// Prepend zeros to equalise exponents. Note: Faster to use reverse then do unshifts.</span>
      <span class="s2">d</span><span class="s0">.</span><span class="s2">reverse</span><span class="s0">();</span>
      <span class="s1">for </span><span class="s0">(; </span><span class="s2">i</span><span class="s0">--;) </span><span class="s2">d</span><span class="s0">.</span><span class="s2">push</span><span class="s0">(</span><span class="s5">0</span><span class="s0">);</span>
      <span class="s2">d</span><span class="s0">.</span><span class="s2">reverse</span><span class="s0">();</span>
    <span class="s0">}</span>

    <span class="s2">len </span><span class="s0">= </span><span class="s2">xd</span><span class="s0">.</span><span class="s2">length</span><span class="s0">;</span>
    <span class="s2">i </span><span class="s0">= </span><span class="s2">yd</span><span class="s0">.</span><span class="s2">length</span><span class="s0">;</span>

    <span class="s4">// If yd is longer than xd, swap xd and yd so xd points to the longer array.</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">len </span><span class="s0">- </span><span class="s2">i </span><span class="s0">&lt; </span><span class="s5">0</span><span class="s0">) {</span>
      <span class="s2">i </span><span class="s0">= </span><span class="s2">len</span><span class="s0">;</span>
      <span class="s2">d </span><span class="s0">= </span><span class="s2">yd</span><span class="s0">;</span>
      <span class="s2">yd </span><span class="s0">= </span><span class="s2">xd</span><span class="s0">;</span>
      <span class="s2">xd </span><span class="s0">= </span><span class="s2">d</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s4">// Only start adding at yd.length - 1 as the further digits of xd can be left as they are.</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s2">carry </span><span class="s0">= </span><span class="s5">0</span><span class="s0">; </span><span class="s2">i</span><span class="s0">;) {</span>
      <span class="s2">carry </span><span class="s0">= (</span><span class="s2">xd</span><span class="s0">[--</span><span class="s2">i</span><span class="s0">] = </span><span class="s2">xd</span><span class="s0">[</span><span class="s2">i</span><span class="s0">] + </span><span class="s2">yd</span><span class="s0">[</span><span class="s2">i</span><span class="s0">] + </span><span class="s2">carry</span><span class="s0">) / </span><span class="s2">BASE </span><span class="s0">| </span><span class="s5">0</span><span class="s0">;</span>
      <span class="s2">xd</span><span class="s0">[</span><span class="s2">i</span><span class="s0">] %= </span><span class="s2">BASE</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(</span><span class="s2">carry</span><span class="s0">) {</span>
      <span class="s2">xd</span><span class="s0">.</span><span class="s2">unshift</span><span class="s0">(</span><span class="s2">carry</span><span class="s0">);</span>
      <span class="s0">++</span><span class="s2">e</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s4">// Remove trailing zeros.</span>
    <span class="s4">// No need to check for zero, as +x + +y != 0 &amp;&amp; -x + -y != 0</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s2">len </span><span class="s0">= </span><span class="s2">xd</span><span class="s0">.</span><span class="s2">length</span><span class="s0">; </span><span class="s2">xd</span><span class="s0">[--</span><span class="s2">len</span><span class="s0">] == </span><span class="s5">0</span><span class="s0">;) </span><span class="s2">xd</span><span class="s0">.</span><span class="s2">pop</span><span class="s0">();</span>

    <span class="s2">y</span><span class="s0">.</span><span class="s2">d </span><span class="s0">= </span><span class="s2">xd</span><span class="s0">;</span>
    <span class="s2">y</span><span class="s0">.</span><span class="s2">e </span><span class="s0">= </span><span class="s2">getBase10Exponent</span><span class="s0">(</span><span class="s2">xd</span><span class="s0">, </span><span class="s2">e</span><span class="s0">);</span>

    <span class="s1">return </span><span class="s2">external </span><span class="s0">? </span><span class="s2">finalise</span><span class="s0">(</span><span class="s2">y</span><span class="s0">, </span><span class="s2">pr</span><span class="s0">, </span><span class="s2">rm</span><span class="s0">) : </span><span class="s2">y</span><span class="s0">;</span>
  <span class="s0">};</span>


  <span class="s4">/* 
   * Return the number of significant digits of the value of this Decimal. 
   * 
   * [z] {boolean|number} Whether to count integer-part trailing zeros: true, false, 1 or 0. 
   * 
   */</span>
  <span class="s2">P</span><span class="s0">.</span><span class="s2">precision </span><span class="s0">= </span><span class="s2">P</span><span class="s0">.</span><span class="s2">sd </span><span class="s0">= </span><span class="s1">function </span><span class="s0">(</span><span class="s2">z</span><span class="s0">) {</span>
    <span class="s1">var </span><span class="s2">k</span><span class="s0">,</span>
      <span class="s2">x </span><span class="s0">= </span><span class="s1">this</span><span class="s0">;</span>

    <span class="s1">if </span><span class="s0">(</span><span class="s2">z </span><span class="s0">!== </span><span class="s1">void </span><span class="s5">0 </span><span class="s0">&amp;&amp; </span><span class="s2">z </span><span class="s0">!== !!</span><span class="s2">z </span><span class="s0">&amp;&amp; </span><span class="s2">z </span><span class="s0">!== </span><span class="s5">1 </span><span class="s0">&amp;&amp; </span><span class="s2">z </span><span class="s0">!== </span><span class="s5">0</span><span class="s0">) </span><span class="s1">throw </span><span class="s2">Error</span><span class="s0">(</span><span class="s2">invalidArgument </span><span class="s0">+ </span><span class="s2">z</span><span class="s0">);</span>

    <span class="s1">if </span><span class="s0">(</span><span class="s2">x</span><span class="s0">.</span><span class="s2">d</span><span class="s0">) {</span>
      <span class="s2">k </span><span class="s0">= </span><span class="s2">getPrecision</span><span class="s0">(</span><span class="s2">x</span><span class="s0">.</span><span class="s2">d</span><span class="s0">);</span>
      <span class="s1">if </span><span class="s0">(</span><span class="s2">z </span><span class="s0">&amp;&amp; </span><span class="s2">x</span><span class="s0">.</span><span class="s2">e </span><span class="s0">+ </span><span class="s5">1 </span><span class="s0">&gt; </span><span class="s2">k</span><span class="s0">) </span><span class="s2">k </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">e </span><span class="s0">+ </span><span class="s5">1</span><span class="s0">;</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s2">k </span><span class="s0">= </span><span class="s2">NaN</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">return </span><span class="s2">k</span><span class="s0">;</span>
  <span class="s0">};</span>


  <span class="s4">/* 
   * Return a new Decimal whose value is the value of this Decimal rounded to a whole number using 
   * rounding mode `rounding`. 
   * 
   */</span>
  <span class="s2">P</span><span class="s0">.</span><span class="s2">round </span><span class="s0">= </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">var </span><span class="s2">x </span><span class="s0">= </span><span class="s1">this</span><span class="s0">,</span>
      <span class="s2">Ctor </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">constructor</span><span class="s0">;</span>

    <span class="s1">return </span><span class="s2">finalise</span><span class="s0">(</span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">x</span><span class="s0">), </span><span class="s2">x</span><span class="s0">.</span><span class="s2">e </span><span class="s0">+ </span><span class="s5">1</span><span class="s0">, </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">rounding</span><span class="s0">);</span>
  <span class="s0">};</span>


  <span class="s4">/* 
   * Return a new Decimal whose value is the sine of the value in radians of this Decimal. 
   * 
   * Domain: [-Infinity, Infinity] 
   * Range: [-1, 1] 
   * 
   * sin(x) = x - x^3/3! + x^5/5! - ... 
   * 
   * sin(0)         = 0 
   * sin(-0)        = -0 
   * sin(Infinity)  = NaN 
   * sin(-Infinity) = NaN 
   * sin(NaN)       = NaN 
   * 
   */</span>
  <span class="s2">P</span><span class="s0">.</span><span class="s2">sine </span><span class="s0">= </span><span class="s2">P</span><span class="s0">.</span><span class="s2">sin </span><span class="s0">= </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">var </span><span class="s2">pr</span><span class="s0">, </span><span class="s2">rm</span><span class="s0">,</span>
      <span class="s2">x </span><span class="s0">= </span><span class="s1">this</span><span class="s0">,</span>
      <span class="s2">Ctor </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">constructor</span><span class="s0">;</span>

    <span class="s1">if </span><span class="s0">(!</span><span class="s2">x</span><span class="s0">.</span><span class="s2">isFinite</span><span class="s0">()) </span><span class="s1">return new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">NaN</span><span class="s0">);</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">x</span><span class="s0">.</span><span class="s2">isZero</span><span class="s0">()) </span><span class="s1">return new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">x</span><span class="s0">);</span>

    <span class="s2">pr </span><span class="s0">= </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">precision</span><span class="s0">;</span>
    <span class="s2">rm </span><span class="s0">= </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">rounding</span><span class="s0">;</span>
    <span class="s2">Ctor</span><span class="s0">.</span><span class="s2">precision </span><span class="s0">= </span><span class="s2">pr </span><span class="s0">+ </span><span class="s2">Math</span><span class="s0">.</span><span class="s2">max</span><span class="s0">(</span><span class="s2">x</span><span class="s0">.</span><span class="s2">e</span><span class="s0">, </span><span class="s2">x</span><span class="s0">.</span><span class="s2">sd</span><span class="s0">()) + </span><span class="s2">LOG_BASE</span><span class="s0">;</span>
    <span class="s2">Ctor</span><span class="s0">.</span><span class="s2">rounding </span><span class="s0">= </span><span class="s5">1</span><span class="s0">;</span>

    <span class="s2">x </span><span class="s0">= </span><span class="s2">sine</span><span class="s0">(</span><span class="s2">Ctor</span><span class="s0">, </span><span class="s2">toLessThanHalfPi</span><span class="s0">(</span><span class="s2">Ctor</span><span class="s0">, </span><span class="s2">x</span><span class="s0">));</span>

    <span class="s2">Ctor</span><span class="s0">.</span><span class="s2">precision </span><span class="s0">= </span><span class="s2">pr</span><span class="s0">;</span>
    <span class="s2">Ctor</span><span class="s0">.</span><span class="s2">rounding </span><span class="s0">= </span><span class="s2">rm</span><span class="s0">;</span>

    <span class="s1">return </span><span class="s2">finalise</span><span class="s0">(</span><span class="s2">quadrant </span><span class="s0">&gt; </span><span class="s5">2 </span><span class="s0">? </span><span class="s2">x</span><span class="s0">.</span><span class="s2">neg</span><span class="s0">() : </span><span class="s2">x</span><span class="s0">, </span><span class="s2">pr</span><span class="s0">, </span><span class="s2">rm</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>
  <span class="s0">};</span>


  <span class="s4">/* 
   * Return a new Decimal whose value is the square root of this Decimal, rounded to `precision` 
   * significant digits using rounding mode `rounding`. 
   * 
   *  sqrt(-n) =  N 
   *  sqrt(N)  =  N 
   *  sqrt(-I) =  N 
   *  sqrt(I)  =  I 
   *  sqrt(0)  =  0 
   *  sqrt(-0) = -0 
   * 
   */</span>
  <span class="s2">P</span><span class="s0">.</span><span class="s2">squareRoot </span><span class="s0">= </span><span class="s2">P</span><span class="s0">.</span><span class="s2">sqrt </span><span class="s0">= </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">var </span><span class="s2">m</span><span class="s0">, </span><span class="s2">n</span><span class="s0">, </span><span class="s2">sd</span><span class="s0">, </span><span class="s2">r</span><span class="s0">, </span><span class="s2">rep</span><span class="s0">, </span><span class="s2">t</span><span class="s0">,</span>
      <span class="s2">x </span><span class="s0">= </span><span class="s1">this</span><span class="s0">,</span>
      <span class="s2">d </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">d</span><span class="s0">,</span>
      <span class="s2">e </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">e</span><span class="s0">,</span>
      <span class="s2">s </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">s</span><span class="s0">,</span>
      <span class="s2">Ctor </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">constructor</span><span class="s0">;</span>

    <span class="s4">// Negative/NaN/Infinity/zero?</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">s </span><span class="s0">!== </span><span class="s5">1 </span><span class="s0">|| !</span><span class="s2">d </span><span class="s0">|| !</span><span class="s2">d</span><span class="s0">[</span><span class="s5">0</span><span class="s0">]) {</span>
      <span class="s1">return new </span><span class="s2">Ctor</span><span class="s0">(!</span><span class="s2">s </span><span class="s0">|| </span><span class="s2">s </span><span class="s0">&lt; </span><span class="s5">0 </span><span class="s0">&amp;&amp; (!</span><span class="s2">d </span><span class="s0">|| </span><span class="s2">d</span><span class="s0">[</span><span class="s5">0</span><span class="s0">]) ? </span><span class="s2">NaN </span><span class="s0">: </span><span class="s2">d </span><span class="s0">? </span><span class="s2">x </span><span class="s0">: </span><span class="s5">1 </span><span class="s0">/ </span><span class="s5">0</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s2">external </span><span class="s0">= </span><span class="s1">false</span><span class="s0">;</span>

    <span class="s4">// Initial estimate.</span>
    <span class="s2">s </span><span class="s0">= </span><span class="s2">Math</span><span class="s0">.</span><span class="s2">sqrt</span><span class="s0">(+</span><span class="s2">x</span><span class="s0">);</span>

    <span class="s4">// Math.sqrt underflow/overflow?</span>
    <span class="s4">// Pass x to Math.sqrt as integer, then adjust the exponent of the result.</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">s </span><span class="s0">== </span><span class="s5">0 </span><span class="s0">|| </span><span class="s2">s </span><span class="s0">== </span><span class="s5">1 </span><span class="s0">/ </span><span class="s5">0</span><span class="s0">) {</span>
      <span class="s2">n </span><span class="s0">= </span><span class="s2">digitsToString</span><span class="s0">(</span><span class="s2">d</span><span class="s0">);</span>

      <span class="s1">if </span><span class="s0">((</span><span class="s2">n</span><span class="s0">.</span><span class="s2">length </span><span class="s0">+ </span><span class="s2">e</span><span class="s0">) % </span><span class="s5">2 </span><span class="s0">== </span><span class="s5">0</span><span class="s0">) </span><span class="s2">n </span><span class="s0">+= </span><span class="s3">'0'</span><span class="s0">;</span>
      <span class="s2">s </span><span class="s0">= </span><span class="s2">Math</span><span class="s0">.</span><span class="s2">sqrt</span><span class="s0">(</span><span class="s2">n</span><span class="s0">);</span>
      <span class="s2">e </span><span class="s0">= </span><span class="s2">mathfloor</span><span class="s0">((</span><span class="s2">e </span><span class="s0">+ </span><span class="s5">1</span><span class="s0">) / </span><span class="s5">2</span><span class="s0">) - (</span><span class="s2">e </span><span class="s0">&lt; </span><span class="s5">0 </span><span class="s0">|| </span><span class="s2">e </span><span class="s0">% </span><span class="s5">2</span><span class="s0">);</span>

      <span class="s1">if </span><span class="s0">(</span><span class="s2">s </span><span class="s0">== </span><span class="s5">1 </span><span class="s0">/ </span><span class="s5">0</span><span class="s0">) {</span>
        <span class="s2">n </span><span class="s0">= </span><span class="s3">'5e' </span><span class="s0">+ </span><span class="s2">e</span><span class="s0">;</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s2">n </span><span class="s0">= </span><span class="s2">s</span><span class="s0">.</span><span class="s2">toExponential</span><span class="s0">();</span>
        <span class="s2">n </span><span class="s0">= </span><span class="s2">n</span><span class="s0">.</span><span class="s2">slice</span><span class="s0">(</span><span class="s5">0</span><span class="s0">, </span><span class="s2">n</span><span class="s0">.</span><span class="s2">indexOf</span><span class="s0">(</span><span class="s3">'e'</span><span class="s0">) + </span><span class="s5">1</span><span class="s0">) + </span><span class="s2">e</span><span class="s0">;</span>
      <span class="s0">}</span>

      <span class="s2">r </span><span class="s0">= </span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">n</span><span class="s0">);</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s2">r </span><span class="s0">= </span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">s</span><span class="s0">.</span><span class="s2">toString</span><span class="s0">());</span>
    <span class="s0">}</span>

    <span class="s2">sd </span><span class="s0">= (</span><span class="s2">e </span><span class="s0">= </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">precision</span><span class="s0">) + </span><span class="s5">3</span><span class="s0">;</span>

    <span class="s4">// Newton-Raphson iteration.</span>
    <span class="s1">for </span><span class="s0">(;;) {</span>
      <span class="s2">t </span><span class="s0">= </span><span class="s2">r</span><span class="s0">;</span>
      <span class="s2">r </span><span class="s0">= </span><span class="s2">t</span><span class="s0">.</span><span class="s2">plus</span><span class="s0">(</span><span class="s2">divide</span><span class="s0">(</span><span class="s2">x</span><span class="s0">, </span><span class="s2">t</span><span class="s0">, </span><span class="s2">sd </span><span class="s0">+ </span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s0">)).</span><span class="s2">times</span><span class="s0">(</span><span class="s5">0.5</span><span class="s0">);</span>

      <span class="s4">// TODO? Replace with for-loop and checkRoundingDigits.</span>
      <span class="s1">if </span><span class="s0">(</span><span class="s2">digitsToString</span><span class="s0">(</span><span class="s2">t</span><span class="s0">.</span><span class="s2">d</span><span class="s0">).</span><span class="s2">slice</span><span class="s0">(</span><span class="s5">0</span><span class="s0">, </span><span class="s2">sd</span><span class="s0">) === (</span><span class="s2">n </span><span class="s0">= </span><span class="s2">digitsToString</span><span class="s0">(</span><span class="s2">r</span><span class="s0">.</span><span class="s2">d</span><span class="s0">)).</span><span class="s2">slice</span><span class="s0">(</span><span class="s5">0</span><span class="s0">, </span><span class="s2">sd</span><span class="s0">)) {</span>
        <span class="s2">n </span><span class="s0">= </span><span class="s2">n</span><span class="s0">.</span><span class="s2">slice</span><span class="s0">(</span><span class="s2">sd </span><span class="s0">- </span><span class="s5">3</span><span class="s0">, </span><span class="s2">sd </span><span class="s0">+ </span><span class="s5">1</span><span class="s0">);</span>

        <span class="s4">// The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or</span>
        <span class="s4">// 4999, i.e. approaching a rounding boundary, continue the iteration.</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s2">n </span><span class="s0">== </span><span class="s3">'9999' </span><span class="s0">|| !</span><span class="s2">rep </span><span class="s0">&amp;&amp; </span><span class="s2">n </span><span class="s0">== </span><span class="s3">'4999'</span><span class="s0">) {</span>

          <span class="s4">// On the first iteration only, check to see if rounding up gives the exact result as the</span>
          <span class="s4">// nines may infinitely repeat.</span>
          <span class="s1">if </span><span class="s0">(!</span><span class="s2">rep</span><span class="s0">) {</span>
            <span class="s2">finalise</span><span class="s0">(</span><span class="s2">t</span><span class="s0">, </span><span class="s2">e </span><span class="s0">+ </span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s0">);</span>

            <span class="s1">if </span><span class="s0">(</span><span class="s2">t</span><span class="s0">.</span><span class="s2">times</span><span class="s0">(</span><span class="s2">t</span><span class="s0">).</span><span class="s2">eq</span><span class="s0">(</span><span class="s2">x</span><span class="s0">)) {</span>
              <span class="s2">r </span><span class="s0">= </span><span class="s2">t</span><span class="s0">;</span>
              <span class="s1">break</span><span class="s0">;</span>
            <span class="s0">}</span>
          <span class="s0">}</span>

          <span class="s2">sd </span><span class="s0">+= </span><span class="s5">4</span><span class="s0">;</span>
          <span class="s2">rep </span><span class="s0">= </span><span class="s5">1</span><span class="s0">;</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>

          <span class="s4">// If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.</span>
          <span class="s4">// If not, then there are further digits and m will be truthy.</span>
          <span class="s1">if </span><span class="s0">(!+</span><span class="s2">n </span><span class="s0">|| !+</span><span class="s2">n</span><span class="s0">.</span><span class="s2">slice</span><span class="s0">(</span><span class="s5">1</span><span class="s0">) &amp;&amp; </span><span class="s2">n</span><span class="s0">.</span><span class="s2">charAt</span><span class="s0">(</span><span class="s5">0</span><span class="s0">) == </span><span class="s3">'5'</span><span class="s0">) {</span>

            <span class="s4">// Truncate to the first rounding digit.</span>
            <span class="s2">finalise</span><span class="s0">(</span><span class="s2">r</span><span class="s0">, </span><span class="s2">e </span><span class="s0">+ </span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s0">);</span>
            <span class="s2">m </span><span class="s0">= !</span><span class="s2">r</span><span class="s0">.</span><span class="s2">times</span><span class="s0">(</span><span class="s2">r</span><span class="s0">).</span><span class="s2">eq</span><span class="s0">(</span><span class="s2">x</span><span class="s0">);</span>
          <span class="s0">}</span>

          <span class="s1">break</span><span class="s0">;</span>
        <span class="s0">}</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s2">external </span><span class="s0">= </span><span class="s1">true</span><span class="s0">;</span>

    <span class="s1">return </span><span class="s2">finalise</span><span class="s0">(</span><span class="s2">r</span><span class="s0">, </span><span class="s2">e</span><span class="s0">, </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">rounding</span><span class="s0">, </span><span class="s2">m</span><span class="s0">);</span>
  <span class="s0">};</span>


  <span class="s4">/* 
   * Return a new Decimal whose value is the tangent of the value in radians of this Decimal. 
   * 
   * Domain: [-Infinity, Infinity] 
   * Range: [-Infinity, Infinity] 
   * 
   * tan(0)         = 0 
   * tan(-0)        = -0 
   * tan(Infinity)  = NaN 
   * tan(-Infinity) = NaN 
   * tan(NaN)       = NaN 
   * 
   */</span>
  <span class="s2">P</span><span class="s0">.</span><span class="s2">tangent </span><span class="s0">= </span><span class="s2">P</span><span class="s0">.</span><span class="s2">tan </span><span class="s0">= </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">var </span><span class="s2">pr</span><span class="s0">, </span><span class="s2">rm</span><span class="s0">,</span>
      <span class="s2">x </span><span class="s0">= </span><span class="s1">this</span><span class="s0">,</span>
      <span class="s2">Ctor </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">constructor</span><span class="s0">;</span>

    <span class="s1">if </span><span class="s0">(!</span><span class="s2">x</span><span class="s0">.</span><span class="s2">isFinite</span><span class="s0">()) </span><span class="s1">return new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">NaN</span><span class="s0">);</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">x</span><span class="s0">.</span><span class="s2">isZero</span><span class="s0">()) </span><span class="s1">return new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">x</span><span class="s0">);</span>

    <span class="s2">pr </span><span class="s0">= </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">precision</span><span class="s0">;</span>
    <span class="s2">rm </span><span class="s0">= </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">rounding</span><span class="s0">;</span>
    <span class="s2">Ctor</span><span class="s0">.</span><span class="s2">precision </span><span class="s0">= </span><span class="s2">pr </span><span class="s0">+ </span><span class="s5">10</span><span class="s0">;</span>
    <span class="s2">Ctor</span><span class="s0">.</span><span class="s2">rounding </span><span class="s0">= </span><span class="s5">1</span><span class="s0">;</span>

    <span class="s2">x </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">sin</span><span class="s0">();</span>
    <span class="s2">x</span><span class="s0">.</span><span class="s2">s </span><span class="s0">= </span><span class="s5">1</span><span class="s0">;</span>
    <span class="s2">x </span><span class="s0">= </span><span class="s2">divide</span><span class="s0">(</span><span class="s2">x</span><span class="s0">, </span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s5">1</span><span class="s0">).</span><span class="s2">minus</span><span class="s0">(</span><span class="s2">x</span><span class="s0">.</span><span class="s2">times</span><span class="s0">(</span><span class="s2">x</span><span class="s0">)).</span><span class="s2">sqrt</span><span class="s0">(), </span><span class="s2">pr </span><span class="s0">+ </span><span class="s5">10</span><span class="s0">, </span><span class="s5">0</span><span class="s0">);</span>

    <span class="s2">Ctor</span><span class="s0">.</span><span class="s2">precision </span><span class="s0">= </span><span class="s2">pr</span><span class="s0">;</span>
    <span class="s2">Ctor</span><span class="s0">.</span><span class="s2">rounding </span><span class="s0">= </span><span class="s2">rm</span><span class="s0">;</span>

    <span class="s1">return </span><span class="s2">finalise</span><span class="s0">(</span><span class="s2">quadrant </span><span class="s0">== </span><span class="s5">2 </span><span class="s0">|| </span><span class="s2">quadrant </span><span class="s0">== </span><span class="s5">4 </span><span class="s0">? </span><span class="s2">x</span><span class="s0">.</span><span class="s2">neg</span><span class="s0">() : </span><span class="s2">x</span><span class="s0">, </span><span class="s2">pr</span><span class="s0">, </span><span class="s2">rm</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>
  <span class="s0">};</span>


  <span class="s4">/* 
   *  n * 0 = 0 
   *  n * N = N 
   *  n * I = I 
   *  0 * n = 0 
   *  0 * 0 = 0 
   *  0 * N = N 
   *  0 * I = N 
   *  N * n = N 
   *  N * 0 = N 
   *  N * N = N 
   *  N * I = N 
   *  I * n = I 
   *  I * 0 = N 
   *  I * N = N 
   *  I * I = I 
   * 
   * Return a new Decimal whose value is this Decimal times `y`, rounded to `precision` significant 
   * digits using rounding mode `rounding`. 
   * 
   */</span>
  <span class="s2">P</span><span class="s0">.</span><span class="s2">times </span><span class="s0">= </span><span class="s2">P</span><span class="s0">.</span><span class="s2">mul </span><span class="s0">= </span><span class="s1">function </span><span class="s0">(</span><span class="s2">y</span><span class="s0">) {</span>
    <span class="s1">var </span><span class="s2">carry</span><span class="s0">, </span><span class="s2">e</span><span class="s0">, </span><span class="s2">i</span><span class="s0">, </span><span class="s2">k</span><span class="s0">, </span><span class="s2">r</span><span class="s0">, </span><span class="s2">rL</span><span class="s0">, </span><span class="s2">t</span><span class="s0">, </span><span class="s2">xdL</span><span class="s0">, </span><span class="s2">ydL</span><span class="s0">,</span>
      <span class="s2">x </span><span class="s0">= </span><span class="s1">this</span><span class="s0">,</span>
      <span class="s2">Ctor </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">constructor</span><span class="s0">,</span>
      <span class="s2">xd </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">d</span><span class="s0">,</span>
      <span class="s2">yd </span><span class="s0">= (</span><span class="s2">y </span><span class="s0">= </span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">y</span><span class="s0">)).</span><span class="s2">d</span><span class="s0">;</span>

    <span class="s2">y</span><span class="s0">.</span><span class="s2">s </span><span class="s0">*= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">s</span><span class="s0">;</span>

     <span class="s4">// If either is NaN, ±Infinity or ±0...</span>
    <span class="s1">if </span><span class="s0">(!</span><span class="s2">xd </span><span class="s0">|| !</span><span class="s2">xd</span><span class="s0">[</span><span class="s5">0</span><span class="s0">] || !</span><span class="s2">yd </span><span class="s0">|| !</span><span class="s2">yd</span><span class="s0">[</span><span class="s5">0</span><span class="s0">]) {</span>

      <span class="s1">return new </span><span class="s2">Ctor</span><span class="s0">(!</span><span class="s2">y</span><span class="s0">.</span><span class="s2">s </span><span class="s0">|| </span><span class="s2">xd </span><span class="s0">&amp;&amp; !</span><span class="s2">xd</span><span class="s0">[</span><span class="s5">0</span><span class="s0">] &amp;&amp; !</span><span class="s2">yd </span><span class="s0">|| </span><span class="s2">yd </span><span class="s0">&amp;&amp; !</span><span class="s2">yd</span><span class="s0">[</span><span class="s5">0</span><span class="s0">] &amp;&amp; !</span><span class="s2">xd</span>

        <span class="s4">// Return NaN if either is NaN.</span>
        <span class="s4">// Return NaN if x is ±0 and y is ±Infinity, or y is ±0 and x is ±Infinity.</span>
        <span class="s0">? </span><span class="s2">NaN</span>

        <span class="s4">// Return ±Infinity if either is ±Infinity.</span>
        <span class="s4">// Return ±0 if either is ±0.</span>
        <span class="s0">: !</span><span class="s2">xd </span><span class="s0">|| !</span><span class="s2">yd </span><span class="s0">? </span><span class="s2">y</span><span class="s0">.</span><span class="s2">s </span><span class="s0">/ </span><span class="s5">0 </span><span class="s0">: </span><span class="s2">y</span><span class="s0">.</span><span class="s2">s </span><span class="s0">* </span><span class="s5">0</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s2">e </span><span class="s0">= </span><span class="s2">mathfloor</span><span class="s0">(</span><span class="s2">x</span><span class="s0">.</span><span class="s2">e </span><span class="s0">/ </span><span class="s2">LOG_BASE</span><span class="s0">) + </span><span class="s2">mathfloor</span><span class="s0">(</span><span class="s2">y</span><span class="s0">.</span><span class="s2">e </span><span class="s0">/ </span><span class="s2">LOG_BASE</span><span class="s0">);</span>
    <span class="s2">xdL </span><span class="s0">= </span><span class="s2">xd</span><span class="s0">.</span><span class="s2">length</span><span class="s0">;</span>
    <span class="s2">ydL </span><span class="s0">= </span><span class="s2">yd</span><span class="s0">.</span><span class="s2">length</span><span class="s0">;</span>

    <span class="s4">// Ensure xd points to the longer array.</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">xdL </span><span class="s0">&lt; </span><span class="s2">ydL</span><span class="s0">) {</span>
      <span class="s2">r </span><span class="s0">= </span><span class="s2">xd</span><span class="s0">;</span>
      <span class="s2">xd </span><span class="s0">= </span><span class="s2">yd</span><span class="s0">;</span>
      <span class="s2">yd </span><span class="s0">= </span><span class="s2">r</span><span class="s0">;</span>
      <span class="s2">rL </span><span class="s0">= </span><span class="s2">xdL</span><span class="s0">;</span>
      <span class="s2">xdL </span><span class="s0">= </span><span class="s2">ydL</span><span class="s0">;</span>
      <span class="s2">ydL </span><span class="s0">= </span><span class="s2">rL</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s4">// Initialise the result array with zeros.</span>
    <span class="s2">r </span><span class="s0">= [];</span>
    <span class="s2">rL </span><span class="s0">= </span><span class="s2">xdL </span><span class="s0">+ </span><span class="s2">ydL</span><span class="s0">;</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s2">i </span><span class="s0">= </span><span class="s2">rL</span><span class="s0">; </span><span class="s2">i</span><span class="s0">--;) </span><span class="s2">r</span><span class="s0">.</span><span class="s2">push</span><span class="s0">(</span><span class="s5">0</span><span class="s0">);</span>

    <span class="s4">// Multiply!</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s2">i </span><span class="s0">= </span><span class="s2">ydL</span><span class="s0">; --</span><span class="s2">i </span><span class="s0">&gt;= </span><span class="s5">0</span><span class="s0">;) {</span>
      <span class="s2">carry </span><span class="s0">= </span><span class="s5">0</span><span class="s0">;</span>
      <span class="s1">for </span><span class="s0">(</span><span class="s2">k </span><span class="s0">= </span><span class="s2">xdL </span><span class="s0">+ </span><span class="s2">i</span><span class="s0">; </span><span class="s2">k </span><span class="s0">&gt; </span><span class="s2">i</span><span class="s0">;) {</span>
        <span class="s2">t </span><span class="s0">= </span><span class="s2">r</span><span class="s0">[</span><span class="s2">k</span><span class="s0">] + </span><span class="s2">yd</span><span class="s0">[</span><span class="s2">i</span><span class="s0">] * </span><span class="s2">xd</span><span class="s0">[</span><span class="s2">k </span><span class="s0">- </span><span class="s2">i </span><span class="s0">- </span><span class="s5">1</span><span class="s0">] + </span><span class="s2">carry</span><span class="s0">;</span>
        <span class="s2">r</span><span class="s0">[</span><span class="s2">k</span><span class="s0">--] = </span><span class="s2">t </span><span class="s0">% </span><span class="s2">BASE </span><span class="s0">| </span><span class="s5">0</span><span class="s0">;</span>
        <span class="s2">carry </span><span class="s0">= </span><span class="s2">t </span><span class="s0">/ </span><span class="s2">BASE </span><span class="s0">| </span><span class="s5">0</span><span class="s0">;</span>
      <span class="s0">}</span>

      <span class="s2">r</span><span class="s0">[</span><span class="s2">k</span><span class="s0">] = (</span><span class="s2">r</span><span class="s0">[</span><span class="s2">k</span><span class="s0">] + </span><span class="s2">carry</span><span class="s0">) % </span><span class="s2">BASE </span><span class="s0">| </span><span class="s5">0</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s4">// Remove trailing zeros.</span>
    <span class="s1">for </span><span class="s0">(; !</span><span class="s2">r</span><span class="s0">[--</span><span class="s2">rL</span><span class="s0">];) </span><span class="s2">r</span><span class="s0">.</span><span class="s2">pop</span><span class="s0">();</span>

    <span class="s1">if </span><span class="s0">(</span><span class="s2">carry</span><span class="s0">) ++</span><span class="s2">e</span><span class="s0">;</span>
    <span class="s1">else </span><span class="s2">r</span><span class="s0">.</span><span class="s2">shift</span><span class="s0">();</span>

    <span class="s2">y</span><span class="s0">.</span><span class="s2">d </span><span class="s0">= </span><span class="s2">r</span><span class="s0">;</span>
    <span class="s2">y</span><span class="s0">.</span><span class="s2">e </span><span class="s0">= </span><span class="s2">getBase10Exponent</span><span class="s0">(</span><span class="s2">r</span><span class="s0">, </span><span class="s2">e</span><span class="s0">);</span>

    <span class="s1">return </span><span class="s2">external </span><span class="s0">? </span><span class="s2">finalise</span><span class="s0">(</span><span class="s2">y</span><span class="s0">, </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">precision</span><span class="s0">, </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">rounding</span><span class="s0">) : </span><span class="s2">y</span><span class="s0">;</span>
  <span class="s0">};</span>


  <span class="s4">/* 
   * Return a string representing the value of this Decimal in base 2, round to `sd` significant 
   * digits using rounding mode `rm`. 
   * 
   * If the optional `sd` argument is present then return binary exponential notation. 
   * 
   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive. 
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive. 
   * 
   */</span>
  <span class="s2">P</span><span class="s0">.</span><span class="s2">toBinary </span><span class="s0">= </span><span class="s1">function </span><span class="s0">(</span><span class="s2">sd</span><span class="s0">, </span><span class="s2">rm</span><span class="s0">) {</span>
    <span class="s1">return </span><span class="s2">toStringBinary</span><span class="s0">(</span><span class="s1">this</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s2">sd</span><span class="s0">, </span><span class="s2">rm</span><span class="s0">);</span>
  <span class="s0">};</span>


  <span class="s4">/* 
   * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `dp` 
   * decimal places using rounding mode `rm` or `rounding` if `rm` is omitted. 
   * 
   * If `dp` is omitted, return a new Decimal whose value is the value of this Decimal. 
   * 
   * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive. 
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive. 
   * 
   */</span>
  <span class="s2">P</span><span class="s0">.</span><span class="s2">toDecimalPlaces </span><span class="s0">= </span><span class="s2">P</span><span class="s0">.</span><span class="s2">toDP </span><span class="s0">= </span><span class="s1">function </span><span class="s0">(</span><span class="s2">dp</span><span class="s0">, </span><span class="s2">rm</span><span class="s0">) {</span>
    <span class="s1">var </span><span class="s2">x </span><span class="s0">= </span><span class="s1">this</span><span class="s0">,</span>
      <span class="s2">Ctor </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">constructor</span><span class="s0">;</span>

    <span class="s2">x </span><span class="s0">= </span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">x</span><span class="s0">);</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">dp </span><span class="s0">=== </span><span class="s1">void </span><span class="s5">0</span><span class="s0">) </span><span class="s1">return </span><span class="s2">x</span><span class="s0">;</span>

    <span class="s2">checkInt32</span><span class="s0">(</span><span class="s2">dp</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s2">MAX_DIGITS</span><span class="s0">);</span>

    <span class="s1">if </span><span class="s0">(</span><span class="s2">rm </span><span class="s0">=== </span><span class="s1">void </span><span class="s5">0</span><span class="s0">) </span><span class="s2">rm </span><span class="s0">= </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">rounding</span><span class="s0">;</span>
    <span class="s1">else </span><span class="s2">checkInt32</span><span class="s0">(</span><span class="s2">rm</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">8</span><span class="s0">);</span>

    <span class="s1">return </span><span class="s2">finalise</span><span class="s0">(</span><span class="s2">x</span><span class="s0">, </span><span class="s2">dp </span><span class="s0">+ </span><span class="s2">x</span><span class="s0">.</span><span class="s2">e </span><span class="s0">+ </span><span class="s5">1</span><span class="s0">, </span><span class="s2">rm</span><span class="s0">);</span>
  <span class="s0">};</span>


  <span class="s4">/* 
   * Return a string representing the value of this Decimal in exponential notation rounded to 
   * `dp` fixed decimal places using rounding mode `rounding`. 
   * 
   * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive. 
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive. 
   * 
   */</span>
  <span class="s2">P</span><span class="s0">.</span><span class="s2">toExponential </span><span class="s0">= </span><span class="s1">function </span><span class="s0">(</span><span class="s2">dp</span><span class="s0">, </span><span class="s2">rm</span><span class="s0">) {</span>
    <span class="s1">var </span><span class="s2">str</span><span class="s0">,</span>
      <span class="s2">x </span><span class="s0">= </span><span class="s1">this</span><span class="s0">,</span>
      <span class="s2">Ctor </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">constructor</span><span class="s0">;</span>

    <span class="s1">if </span><span class="s0">(</span><span class="s2">dp </span><span class="s0">=== </span><span class="s1">void </span><span class="s5">0</span><span class="s0">) {</span>
      <span class="s2">str </span><span class="s0">= </span><span class="s2">finiteToString</span><span class="s0">(</span><span class="s2">x</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s2">checkInt32</span><span class="s0">(</span><span class="s2">dp</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s2">MAX_DIGITS</span><span class="s0">);</span>

      <span class="s1">if </span><span class="s0">(</span><span class="s2">rm </span><span class="s0">=== </span><span class="s1">void </span><span class="s5">0</span><span class="s0">) </span><span class="s2">rm </span><span class="s0">= </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">rounding</span><span class="s0">;</span>
      <span class="s1">else </span><span class="s2">checkInt32</span><span class="s0">(</span><span class="s2">rm</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">8</span><span class="s0">);</span>

      <span class="s2">x </span><span class="s0">= </span><span class="s2">finalise</span><span class="s0">(</span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">x</span><span class="s0">), </span><span class="s2">dp </span><span class="s0">+ </span><span class="s5">1</span><span class="s0">, </span><span class="s2">rm</span><span class="s0">);</span>
      <span class="s2">str </span><span class="s0">= </span><span class="s2">finiteToString</span><span class="s0">(</span><span class="s2">x</span><span class="s0">, </span><span class="s1">true</span><span class="s0">, </span><span class="s2">dp </span><span class="s0">+ </span><span class="s5">1</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s1">return </span><span class="s2">x</span><span class="s0">.</span><span class="s2">isNeg</span><span class="s0">() &amp;&amp; !</span><span class="s2">x</span><span class="s0">.</span><span class="s2">isZero</span><span class="s0">() ? </span><span class="s3">'-' </span><span class="s0">+ </span><span class="s2">str </span><span class="s0">: </span><span class="s2">str</span><span class="s0">;</span>
  <span class="s0">};</span>


  <span class="s4">/* 
   * Return a string representing the value of this Decimal in normal (fixed-point) notation to 
   * `dp` fixed decimal places and rounded using rounding mode `rm` or `rounding` if `rm` is 
   * omitted. 
   * 
   * As with JavaScript numbers, (-0).toFixed(0) is '0', but e.g. (-0.00001).toFixed(0) is '-0'. 
   * 
   * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive. 
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive. 
   * 
   * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'. 
   * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'. 
   * (-0).toFixed(3) is '0.000'. 
   * (-0.5).toFixed(0) is '-0'. 
   * 
   */</span>
  <span class="s2">P</span><span class="s0">.</span><span class="s2">toFixed </span><span class="s0">= </span><span class="s1">function </span><span class="s0">(</span><span class="s2">dp</span><span class="s0">, </span><span class="s2">rm</span><span class="s0">) {</span>
    <span class="s1">var </span><span class="s2">str</span><span class="s0">, </span><span class="s2">y</span><span class="s0">,</span>
      <span class="s2">x </span><span class="s0">= </span><span class="s1">this</span><span class="s0">,</span>
      <span class="s2">Ctor </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">constructor</span><span class="s0">;</span>

    <span class="s1">if </span><span class="s0">(</span><span class="s2">dp </span><span class="s0">=== </span><span class="s1">void </span><span class="s5">0</span><span class="s0">) {</span>
      <span class="s2">str </span><span class="s0">= </span><span class="s2">finiteToString</span><span class="s0">(</span><span class="s2">x</span><span class="s0">);</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s2">checkInt32</span><span class="s0">(</span><span class="s2">dp</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s2">MAX_DIGITS</span><span class="s0">);</span>

      <span class="s1">if </span><span class="s0">(</span><span class="s2">rm </span><span class="s0">=== </span><span class="s1">void </span><span class="s5">0</span><span class="s0">) </span><span class="s2">rm </span><span class="s0">= </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">rounding</span><span class="s0">;</span>
      <span class="s1">else </span><span class="s2">checkInt32</span><span class="s0">(</span><span class="s2">rm</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">8</span><span class="s0">);</span>

      <span class="s2">y </span><span class="s0">= </span><span class="s2">finalise</span><span class="s0">(</span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">x</span><span class="s0">), </span><span class="s2">dp </span><span class="s0">+ </span><span class="s2">x</span><span class="s0">.</span><span class="s2">e </span><span class="s0">+ </span><span class="s5">1</span><span class="s0">, </span><span class="s2">rm</span><span class="s0">);</span>
      <span class="s2">str </span><span class="s0">= </span><span class="s2">finiteToString</span><span class="s0">(</span><span class="s2">y</span><span class="s0">, </span><span class="s1">false</span><span class="s0">, </span><span class="s2">dp </span><span class="s0">+ </span><span class="s2">y</span><span class="s0">.</span><span class="s2">e </span><span class="s0">+ </span><span class="s5">1</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s4">// To determine whether to add the minus sign look at the value before it was rounded,</span>
    <span class="s4">// i.e. look at `x` rather than `y`.</span>
    <span class="s1">return </span><span class="s2">x</span><span class="s0">.</span><span class="s2">isNeg</span><span class="s0">() &amp;&amp; !</span><span class="s2">x</span><span class="s0">.</span><span class="s2">isZero</span><span class="s0">() ? </span><span class="s3">'-' </span><span class="s0">+ </span><span class="s2">str </span><span class="s0">: </span><span class="s2">str</span><span class="s0">;</span>
  <span class="s0">};</span>


  <span class="s4">/* 
   * Return an array representing the value of this Decimal as a simple fraction with an integer 
   * numerator and an integer denominator. 
   * 
   * The denominator will be a positive non-zero value less than or equal to the specified maximum 
   * denominator. If a maximum denominator is not specified, the denominator will be the lowest 
   * value necessary to represent the number exactly. 
   * 
   * [maxD] {number|string|bigint|Decimal} Maximum denominator. Integer &gt;= 1 and &lt; Infinity. 
   * 
   */</span>
  <span class="s2">P</span><span class="s0">.</span><span class="s2">toFraction </span><span class="s0">= </span><span class="s1">function </span><span class="s0">(</span><span class="s2">maxD</span><span class="s0">) {</span>
    <span class="s1">var </span><span class="s2">d</span><span class="s0">, </span><span class="s2">d0</span><span class="s0">, </span><span class="s2">d1</span><span class="s0">, </span><span class="s2">d2</span><span class="s0">, </span><span class="s2">e</span><span class="s0">, </span><span class="s2">k</span><span class="s0">, </span><span class="s2">n</span><span class="s0">, </span><span class="s2">n0</span><span class="s0">, </span><span class="s2">n1</span><span class="s0">, </span><span class="s2">pr</span><span class="s0">, </span><span class="s2">q</span><span class="s0">, </span><span class="s2">r</span><span class="s0">,</span>
      <span class="s2">x </span><span class="s0">= </span><span class="s1">this</span><span class="s0">,</span>
      <span class="s2">xd </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">d</span><span class="s0">,</span>
      <span class="s2">Ctor </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">constructor</span><span class="s0">;</span>

    <span class="s1">if </span><span class="s0">(!</span><span class="s2">xd</span><span class="s0">) </span><span class="s1">return new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">x</span><span class="s0">);</span>

    <span class="s2">n1 </span><span class="s0">= </span><span class="s2">d0 </span><span class="s0">= </span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s5">1</span><span class="s0">);</span>
    <span class="s2">d1 </span><span class="s0">= </span><span class="s2">n0 </span><span class="s0">= </span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s5">0</span><span class="s0">);</span>

    <span class="s2">d </span><span class="s0">= </span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">d1</span><span class="s0">);</span>
    <span class="s2">e </span><span class="s0">= </span><span class="s2">d</span><span class="s0">.</span><span class="s2">e </span><span class="s0">= </span><span class="s2">getPrecision</span><span class="s0">(</span><span class="s2">xd</span><span class="s0">) - </span><span class="s2">x</span><span class="s0">.</span><span class="s2">e </span><span class="s0">- </span><span class="s5">1</span><span class="s0">;</span>
    <span class="s2">k </span><span class="s0">= </span><span class="s2">e </span><span class="s0">% </span><span class="s2">LOG_BASE</span><span class="s0">;</span>
    <span class="s2">d</span><span class="s0">.</span><span class="s2">d</span><span class="s0">[</span><span class="s5">0</span><span class="s0">] = </span><span class="s2">mathpow</span><span class="s0">(</span><span class="s5">10</span><span class="s0">, </span><span class="s2">k </span><span class="s0">&lt; </span><span class="s5">0 </span><span class="s0">? </span><span class="s2">LOG_BASE </span><span class="s0">+ </span><span class="s2">k </span><span class="s0">: </span><span class="s2">k</span><span class="s0">);</span>

    <span class="s1">if </span><span class="s0">(</span><span class="s2">maxD </span><span class="s0">== </span><span class="s1">null</span><span class="s0">) {</span>

      <span class="s4">// d is 10**e, the minimum max-denominator needed.</span>
      <span class="s2">maxD </span><span class="s0">= </span><span class="s2">e </span><span class="s0">&gt; </span><span class="s5">0 </span><span class="s0">? </span><span class="s2">d </span><span class="s0">: </span><span class="s2">n1</span><span class="s0">;</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s2">n </span><span class="s0">= </span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">maxD</span><span class="s0">);</span>
      <span class="s1">if </span><span class="s0">(!</span><span class="s2">n</span><span class="s0">.</span><span class="s2">isInt</span><span class="s0">() || </span><span class="s2">n</span><span class="s0">.</span><span class="s2">lt</span><span class="s0">(</span><span class="s2">n1</span><span class="s0">)) </span><span class="s1">throw </span><span class="s2">Error</span><span class="s0">(</span><span class="s2">invalidArgument </span><span class="s0">+ </span><span class="s2">n</span><span class="s0">);</span>
      <span class="s2">maxD </span><span class="s0">= </span><span class="s2">n</span><span class="s0">.</span><span class="s2">gt</span><span class="s0">(</span><span class="s2">d</span><span class="s0">) ? (</span><span class="s2">e </span><span class="s0">&gt; </span><span class="s5">0 </span><span class="s0">? </span><span class="s2">d </span><span class="s0">: </span><span class="s2">n1</span><span class="s0">) : </span><span class="s2">n</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s2">external </span><span class="s0">= </span><span class="s1">false</span><span class="s0">;</span>
    <span class="s2">n </span><span class="s0">= </span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">digitsToString</span><span class="s0">(</span><span class="s2">xd</span><span class="s0">));</span>
    <span class="s2">pr </span><span class="s0">= </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">precision</span><span class="s0">;</span>
    <span class="s2">Ctor</span><span class="s0">.</span><span class="s2">precision </span><span class="s0">= </span><span class="s2">e </span><span class="s0">= </span><span class="s2">xd</span><span class="s0">.</span><span class="s2">length </span><span class="s0">* </span><span class="s2">LOG_BASE </span><span class="s0">* </span><span class="s5">2</span><span class="s0">;</span>

    <span class="s1">for </span><span class="s0">(;;)  {</span>
      <span class="s2">q </span><span class="s0">= </span><span class="s2">divide</span><span class="s0">(</span><span class="s2">n</span><span class="s0">, </span><span class="s2">d</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s0">);</span>
      <span class="s2">d2 </span><span class="s0">= </span><span class="s2">d0</span><span class="s0">.</span><span class="s2">plus</span><span class="s0">(</span><span class="s2">q</span><span class="s0">.</span><span class="s2">times</span><span class="s0">(</span><span class="s2">d1</span><span class="s0">));</span>
      <span class="s1">if </span><span class="s0">(</span><span class="s2">d2</span><span class="s0">.</span><span class="s2">cmp</span><span class="s0">(</span><span class="s2">maxD</span><span class="s0">) == </span><span class="s5">1</span><span class="s0">) </span><span class="s1">break</span><span class="s0">;</span>
      <span class="s2">d0 </span><span class="s0">= </span><span class="s2">d1</span><span class="s0">;</span>
      <span class="s2">d1 </span><span class="s0">= </span><span class="s2">d2</span><span class="s0">;</span>
      <span class="s2">d2 </span><span class="s0">= </span><span class="s2">n1</span><span class="s0">;</span>
      <span class="s2">n1 </span><span class="s0">= </span><span class="s2">n0</span><span class="s0">.</span><span class="s2">plus</span><span class="s0">(</span><span class="s2">q</span><span class="s0">.</span><span class="s2">times</span><span class="s0">(</span><span class="s2">d2</span><span class="s0">));</span>
      <span class="s2">n0 </span><span class="s0">= </span><span class="s2">d2</span><span class="s0">;</span>
      <span class="s2">d2 </span><span class="s0">= </span><span class="s2">d</span><span class="s0">;</span>
      <span class="s2">d </span><span class="s0">= </span><span class="s2">n</span><span class="s0">.</span><span class="s2">minus</span><span class="s0">(</span><span class="s2">q</span><span class="s0">.</span><span class="s2">times</span><span class="s0">(</span><span class="s2">d2</span><span class="s0">));</span>
      <span class="s2">n </span><span class="s0">= </span><span class="s2">d2</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s2">d2 </span><span class="s0">= </span><span class="s2">divide</span><span class="s0">(</span><span class="s2">maxD</span><span class="s0">.</span><span class="s2">minus</span><span class="s0">(</span><span class="s2">d0</span><span class="s0">), </span><span class="s2">d1</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s0">);</span>
    <span class="s2">n0 </span><span class="s0">= </span><span class="s2">n0</span><span class="s0">.</span><span class="s2">plus</span><span class="s0">(</span><span class="s2">d2</span><span class="s0">.</span><span class="s2">times</span><span class="s0">(</span><span class="s2">n1</span><span class="s0">));</span>
    <span class="s2">d0 </span><span class="s0">= </span><span class="s2">d0</span><span class="s0">.</span><span class="s2">plus</span><span class="s0">(</span><span class="s2">d2</span><span class="s0">.</span><span class="s2">times</span><span class="s0">(</span><span class="s2">d1</span><span class="s0">));</span>
    <span class="s2">n0</span><span class="s0">.</span><span class="s2">s </span><span class="s0">= </span><span class="s2">n1</span><span class="s0">.</span><span class="s2">s </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">s</span><span class="s0">;</span>

    <span class="s4">// Determine which fraction is closer to x, n0/d0 or n1/d1?</span>
    <span class="s2">r </span><span class="s0">= </span><span class="s2">divide</span><span class="s0">(</span><span class="s2">n1</span><span class="s0">, </span><span class="s2">d1</span><span class="s0">, </span><span class="s2">e</span><span class="s0">, </span><span class="s5">1</span><span class="s0">).</span><span class="s2">minus</span><span class="s0">(</span><span class="s2">x</span><span class="s0">).</span><span class="s2">abs</span><span class="s0">().</span><span class="s2">cmp</span><span class="s0">(</span><span class="s2">divide</span><span class="s0">(</span><span class="s2">n0</span><span class="s0">, </span><span class="s2">d0</span><span class="s0">, </span><span class="s2">e</span><span class="s0">, </span><span class="s5">1</span><span class="s0">).</span><span class="s2">minus</span><span class="s0">(</span><span class="s2">x</span><span class="s0">).</span><span class="s2">abs</span><span class="s0">()) &lt; </span><span class="s5">1</span>
        <span class="s0">? [</span><span class="s2">n1</span><span class="s0">, </span><span class="s2">d1</span><span class="s0">] : [</span><span class="s2">n0</span><span class="s0">, </span><span class="s2">d0</span><span class="s0">];</span>

    <span class="s2">Ctor</span><span class="s0">.</span><span class="s2">precision </span><span class="s0">= </span><span class="s2">pr</span><span class="s0">;</span>
    <span class="s2">external </span><span class="s0">= </span><span class="s1">true</span><span class="s0">;</span>

    <span class="s1">return </span><span class="s2">r</span><span class="s0">;</span>
  <span class="s0">};</span>


  <span class="s4">/* 
   * Return a string representing the value of this Decimal in base 16, round to `sd` significant 
   * digits using rounding mode `rm`. 
   * 
   * If the optional `sd` argument is present then return binary exponential notation. 
   * 
   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive. 
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive. 
   * 
   */</span>
  <span class="s2">P</span><span class="s0">.</span><span class="s2">toHexadecimal </span><span class="s0">= </span><span class="s2">P</span><span class="s0">.</span><span class="s2">toHex </span><span class="s0">= </span><span class="s1">function </span><span class="s0">(</span><span class="s2">sd</span><span class="s0">, </span><span class="s2">rm</span><span class="s0">) {</span>
    <span class="s1">return </span><span class="s2">toStringBinary</span><span class="s0">(</span><span class="s1">this</span><span class="s0">, </span><span class="s5">16</span><span class="s0">, </span><span class="s2">sd</span><span class="s0">, </span><span class="s2">rm</span><span class="s0">);</span>
  <span class="s0">};</span>


  <span class="s4">/* 
   * Returns a new Decimal whose value is the nearest multiple of `y` in the direction of rounding 
   * mode `rm`, or `Decimal.rounding` if `rm` is omitted, to the value of this Decimal. 
   * 
   * The return value will always have the same sign as this Decimal, unless either this Decimal 
   * or `y` is NaN, in which case the return value will be also be NaN. 
   * 
   * The return value is not affected by the value of `precision`. 
   * 
   * y {number|string|bigint|Decimal} The magnitude to round to a multiple of. 
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive. 
   * 
   * 'toNearest() rounding mode not an integer: {rm}' 
   * 'toNearest() rounding mode out of range: {rm}' 
   * 
   */</span>
  <span class="s2">P</span><span class="s0">.</span><span class="s2">toNearest </span><span class="s0">= </span><span class="s1">function </span><span class="s0">(</span><span class="s2">y</span><span class="s0">, </span><span class="s2">rm</span><span class="s0">) {</span>
    <span class="s1">var </span><span class="s2">x </span><span class="s0">= </span><span class="s1">this</span><span class="s0">,</span>
      <span class="s2">Ctor </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">constructor</span><span class="s0">;</span>

    <span class="s2">x </span><span class="s0">= </span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">x</span><span class="s0">);</span>

    <span class="s1">if </span><span class="s0">(</span><span class="s2">y </span><span class="s0">== </span><span class="s1">null</span><span class="s0">) {</span>

      <span class="s4">// If x is not finite, return x.</span>
      <span class="s1">if </span><span class="s0">(!</span><span class="s2">x</span><span class="s0">.</span><span class="s2">d</span><span class="s0">) </span><span class="s1">return </span><span class="s2">x</span><span class="s0">;</span>

      <span class="s2">y </span><span class="s0">= </span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s5">1</span><span class="s0">);</span>
      <span class="s2">rm </span><span class="s0">= </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">rounding</span><span class="s0">;</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s2">y </span><span class="s0">= </span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">y</span><span class="s0">);</span>
      <span class="s1">if </span><span class="s0">(</span><span class="s2">rm </span><span class="s0">=== </span><span class="s1">void </span><span class="s5">0</span><span class="s0">) {</span>
        <span class="s2">rm </span><span class="s0">= </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">rounding</span><span class="s0">;</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s2">checkInt32</span><span class="s0">(</span><span class="s2">rm</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">8</span><span class="s0">);</span>
      <span class="s0">}</span>

      <span class="s4">// If x is not finite, return x if y is not NaN, else NaN.</span>
      <span class="s1">if </span><span class="s0">(!</span><span class="s2">x</span><span class="s0">.</span><span class="s2">d</span><span class="s0">) </span><span class="s1">return </span><span class="s2">y</span><span class="s0">.</span><span class="s2">s </span><span class="s0">? </span><span class="s2">x </span><span class="s0">: </span><span class="s2">y</span><span class="s0">;</span>

      <span class="s4">// If y is not finite, return Infinity with the sign of x if y is Infinity, else NaN.</span>
      <span class="s1">if </span><span class="s0">(!</span><span class="s2">y</span><span class="s0">.</span><span class="s2">d</span><span class="s0">) {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s2">y</span><span class="s0">.</span><span class="s2">s</span><span class="s0">) </span><span class="s2">y</span><span class="s0">.</span><span class="s2">s </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">s</span><span class="s0">;</span>
        <span class="s1">return </span><span class="s2">y</span><span class="s0">;</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s4">// If y is not zero, calculate the nearest multiple of y to x.</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">y</span><span class="s0">.</span><span class="s2">d</span><span class="s0">[</span><span class="s5">0</span><span class="s0">]) {</span>
      <span class="s2">external </span><span class="s0">= </span><span class="s1">false</span><span class="s0">;</span>
      <span class="s2">x </span><span class="s0">= </span><span class="s2">divide</span><span class="s0">(</span><span class="s2">x</span><span class="s0">, </span><span class="s2">y</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s2">rm</span><span class="s0">, </span><span class="s5">1</span><span class="s0">).</span><span class="s2">times</span><span class="s0">(</span><span class="s2">y</span><span class="s0">);</span>
      <span class="s2">external </span><span class="s0">= </span><span class="s1">true</span><span class="s0">;</span>
      <span class="s2">finalise</span><span class="s0">(</span><span class="s2">x</span><span class="s0">);</span>

    <span class="s4">// If y is zero, return zero with the sign of x.</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s2">y</span><span class="s0">.</span><span class="s2">s </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">s</span><span class="s0">;</span>
      <span class="s2">x </span><span class="s0">= </span><span class="s2">y</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">return </span><span class="s2">x</span><span class="s0">;</span>
  <span class="s0">};</span>


  <span class="s4">/* 
   * Return the value of this Decimal converted to a number primitive. 
   * Zero keeps its sign. 
   * 
   */</span>
  <span class="s2">P</span><span class="s0">.</span><span class="s2">toNumber </span><span class="s0">= </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">return </span><span class="s0">+</span><span class="s1">this</span><span class="s0">;</span>
  <span class="s0">};</span>


  <span class="s4">/* 
   * Return a string representing the value of this Decimal in base 8, round to `sd` significant 
   * digits using rounding mode `rm`. 
   * 
   * If the optional `sd` argument is present then return binary exponential notation. 
   * 
   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive. 
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive. 
   * 
   */</span>
  <span class="s2">P</span><span class="s0">.</span><span class="s2">toOctal </span><span class="s0">= </span><span class="s1">function </span><span class="s0">(</span><span class="s2">sd</span><span class="s0">, </span><span class="s2">rm</span><span class="s0">) {</span>
    <span class="s1">return </span><span class="s2">toStringBinary</span><span class="s0">(</span><span class="s1">this</span><span class="s0">, </span><span class="s5">8</span><span class="s0">, </span><span class="s2">sd</span><span class="s0">, </span><span class="s2">rm</span><span class="s0">);</span>
  <span class="s0">};</span>


  <span class="s4">/* 
   * Return a new Decimal whose value is the value of this Decimal raised to the power `y`, rounded 
   * to `precision` significant digits using rounding mode `rounding`. 
   * 
   * ECMAScript compliant. 
   * 
   *   pow(x, NaN)                           = NaN 
   *   pow(x, ±0)                            = 1 
 
   *   pow(NaN, non-zero)                    = NaN 
   *   pow(abs(x) &gt; 1, +Infinity)            = +Infinity 
   *   pow(abs(x) &gt; 1, -Infinity)            = +0 
   *   pow(abs(x) == 1, ±Infinity)           = NaN 
   *   pow(abs(x) &lt; 1, +Infinity)            = +0 
   *   pow(abs(x) &lt; 1, -Infinity)            = +Infinity 
   *   pow(+Infinity, y &gt; 0)                 = +Infinity 
   *   pow(+Infinity, y &lt; 0)                 = +0 
   *   pow(-Infinity, odd integer &gt; 0)       = -Infinity 
   *   pow(-Infinity, even integer &gt; 0)      = +Infinity 
   *   pow(-Infinity, odd integer &lt; 0)       = -0 
   *   pow(-Infinity, even integer &lt; 0)      = +0 
   *   pow(+0, y &gt; 0)                        = +0 
   *   pow(+0, y &lt; 0)                        = +Infinity 
   *   pow(-0, odd integer &gt; 0)              = -0 
   *   pow(-0, even integer &gt; 0)             = +0 
   *   pow(-0, odd integer &lt; 0)              = -Infinity 
   *   pow(-0, even integer &lt; 0)             = +Infinity 
   *   pow(finite x &lt; 0, finite non-integer) = NaN 
   * 
   * For non-integer or very large exponents pow(x, y) is calculated using 
   * 
   *   x^y = exp(y*ln(x)) 
   * 
   * Assuming the first 15 rounding digits are each equally likely to be any digit 0-9, the 
   * probability of an incorrectly rounded result 
   * P([49]9{14} | [50]0{14}) = 2 * 0.2 * 10^-14 = 4e-15 = 1/2.5e+14 
   * i.e. 1 in 250,000,000,000,000 
   * 
   * If a result is incorrectly rounded the maximum error will be 1 ulp (unit in last place). 
   * 
   * y {number|string|bigint|Decimal} The power to which to raise this Decimal. 
   * 
   */</span>
  <span class="s2">P</span><span class="s0">.</span><span class="s2">toPower </span><span class="s0">= </span><span class="s2">P</span><span class="s0">.</span><span class="s2">pow </span><span class="s0">= </span><span class="s1">function </span><span class="s0">(</span><span class="s2">y</span><span class="s0">) {</span>
    <span class="s1">var </span><span class="s2">e</span><span class="s0">, </span><span class="s2">k</span><span class="s0">, </span><span class="s2">pr</span><span class="s0">, </span><span class="s2">r</span><span class="s0">, </span><span class="s2">rm</span><span class="s0">, </span><span class="s2">s</span><span class="s0">,</span>
      <span class="s2">x </span><span class="s0">= </span><span class="s1">this</span><span class="s0">,</span>
      <span class="s2">Ctor </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">constructor</span><span class="s0">,</span>
      <span class="s2">yn </span><span class="s0">= +(</span><span class="s2">y </span><span class="s0">= </span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">y</span><span class="s0">));</span>

    <span class="s4">// Either ±Infinity, NaN or ±0?</span>
    <span class="s1">if </span><span class="s0">(!</span><span class="s2">x</span><span class="s0">.</span><span class="s2">d </span><span class="s0">|| !</span><span class="s2">y</span><span class="s0">.</span><span class="s2">d </span><span class="s0">|| !</span><span class="s2">x</span><span class="s0">.</span><span class="s2">d</span><span class="s0">[</span><span class="s5">0</span><span class="s0">] || !</span><span class="s2">y</span><span class="s0">.</span><span class="s2">d</span><span class="s0">[</span><span class="s5">0</span><span class="s0">]) </span><span class="s1">return new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">mathpow</span><span class="s0">(+</span><span class="s2">x</span><span class="s0">, </span><span class="s2">yn</span><span class="s0">));</span>

    <span class="s2">x </span><span class="s0">= </span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">x</span><span class="s0">);</span>

    <span class="s1">if </span><span class="s0">(</span><span class="s2">x</span><span class="s0">.</span><span class="s2">eq</span><span class="s0">(</span><span class="s5">1</span><span class="s0">)) </span><span class="s1">return </span><span class="s2">x</span><span class="s0">;</span>

    <span class="s2">pr </span><span class="s0">= </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">precision</span><span class="s0">;</span>
    <span class="s2">rm </span><span class="s0">= </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">rounding</span><span class="s0">;</span>

    <span class="s1">if </span><span class="s0">(</span><span class="s2">y</span><span class="s0">.</span><span class="s2">eq</span><span class="s0">(</span><span class="s5">1</span><span class="s0">)) </span><span class="s1">return </span><span class="s2">finalise</span><span class="s0">(</span><span class="s2">x</span><span class="s0">, </span><span class="s2">pr</span><span class="s0">, </span><span class="s2">rm</span><span class="s0">);</span>

    <span class="s4">// y exponent</span>
    <span class="s2">e </span><span class="s0">= </span><span class="s2">mathfloor</span><span class="s0">(</span><span class="s2">y</span><span class="s0">.</span><span class="s2">e </span><span class="s0">/ </span><span class="s2">LOG_BASE</span><span class="s0">);</span>

    <span class="s4">// If y is a small integer use the 'exponentiation by squaring' algorithm.</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">e </span><span class="s0">&gt;= </span><span class="s2">y</span><span class="s0">.</span><span class="s2">d</span><span class="s0">.</span><span class="s2">length </span><span class="s0">- </span><span class="s5">1 </span><span class="s0">&amp;&amp; (</span><span class="s2">k </span><span class="s0">= </span><span class="s2">yn </span><span class="s0">&lt; </span><span class="s5">0 </span><span class="s0">? -</span><span class="s2">yn </span><span class="s0">: </span><span class="s2">yn</span><span class="s0">) &lt;= </span><span class="s2">MAX_SAFE_INTEGER</span><span class="s0">) {</span>
      <span class="s2">r </span><span class="s0">= </span><span class="s2">intPow</span><span class="s0">(</span><span class="s2">Ctor</span><span class="s0">, </span><span class="s2">x</span><span class="s0">, </span><span class="s2">k</span><span class="s0">, </span><span class="s2">pr</span><span class="s0">);</span>
      <span class="s1">return </span><span class="s2">y</span><span class="s0">.</span><span class="s2">s </span><span class="s0">&lt; </span><span class="s5">0 </span><span class="s0">? </span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s5">1</span><span class="s0">).</span><span class="s2">div</span><span class="s0">(</span><span class="s2">r</span><span class="s0">) : </span><span class="s2">finalise</span><span class="s0">(</span><span class="s2">r</span><span class="s0">, </span><span class="s2">pr</span><span class="s0">, </span><span class="s2">rm</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s2">s </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">s</span><span class="s0">;</span>

    <span class="s4">// if x is negative</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">s </span><span class="s0">&lt; </span><span class="s5">0</span><span class="s0">) {</span>

      <span class="s4">// if y is not an integer</span>
      <span class="s1">if </span><span class="s0">(</span><span class="s2">e </span><span class="s0">&lt; </span><span class="s2">y</span><span class="s0">.</span><span class="s2">d</span><span class="s0">.</span><span class="s2">length </span><span class="s0">- </span><span class="s5">1</span><span class="s0">) </span><span class="s1">return new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">NaN</span><span class="s0">);</span>

      <span class="s4">// Result is positive if x is negative and the last digit of integer y is even.</span>
      <span class="s1">if </span><span class="s0">((</span><span class="s2">y</span><span class="s0">.</span><span class="s2">d</span><span class="s0">[</span><span class="s2">e</span><span class="s0">] &amp; </span><span class="s5">1</span><span class="s0">) == </span><span class="s5">0</span><span class="s0">) </span><span class="s2">s </span><span class="s0">= </span><span class="s5">1</span><span class="s0">;</span>

      <span class="s4">// if x.eq(-1)</span>
      <span class="s1">if </span><span class="s0">(</span><span class="s2">x</span><span class="s0">.</span><span class="s2">e </span><span class="s0">== </span><span class="s5">0 </span><span class="s0">&amp;&amp; </span><span class="s2">x</span><span class="s0">.</span><span class="s2">d</span><span class="s0">[</span><span class="s5">0</span><span class="s0">] == </span><span class="s5">1 </span><span class="s0">&amp;&amp; </span><span class="s2">x</span><span class="s0">.</span><span class="s2">d</span><span class="s0">.</span><span class="s2">length </span><span class="s0">== </span><span class="s5">1</span><span class="s0">) {</span>
        <span class="s2">x</span><span class="s0">.</span><span class="s2">s </span><span class="s0">= </span><span class="s2">s</span><span class="s0">;</span>
        <span class="s1">return </span><span class="s2">x</span><span class="s0">;</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s4">// Estimate result exponent.</span>
    <span class="s4">// x^y = 10^e,  where e = y * log10(x)</span>
    <span class="s4">// log10(x) = log10(x_significand) + x_exponent</span>
    <span class="s4">// log10(x_significand) = ln(x_significand) / ln(10)</span>
    <span class="s2">k </span><span class="s0">= </span><span class="s2">mathpow</span><span class="s0">(+</span><span class="s2">x</span><span class="s0">, </span><span class="s2">yn</span><span class="s0">);</span>
    <span class="s2">e </span><span class="s0">= </span><span class="s2">k </span><span class="s0">== </span><span class="s5">0 </span><span class="s0">|| !</span><span class="s2">isFinite</span><span class="s0">(</span><span class="s2">k</span><span class="s0">)</span>
      <span class="s0">? </span><span class="s2">mathfloor</span><span class="s0">(</span><span class="s2">yn </span><span class="s0">* (</span><span class="s2">Math</span><span class="s0">.</span><span class="s2">log</span><span class="s0">(</span><span class="s3">'0.' </span><span class="s0">+ </span><span class="s2">digitsToString</span><span class="s0">(</span><span class="s2">x</span><span class="s0">.</span><span class="s2">d</span><span class="s0">)) / </span><span class="s2">Math</span><span class="s0">.</span><span class="s2">LN10 </span><span class="s0">+ </span><span class="s2">x</span><span class="s0">.</span><span class="s2">e </span><span class="s0">+ </span><span class="s5">1</span><span class="s0">))</span>
      <span class="s0">: </span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">k </span><span class="s0">+ </span><span class="s3">''</span><span class="s0">).</span><span class="s2">e</span><span class="s0">;</span>

    <span class="s4">// Exponent estimate may be incorrect e.g. x: 0.999999999999999999, y: 2.29, e: 0, r.e: -1.</span>

    <span class="s4">// Overflow/underflow?</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">e </span><span class="s0">&gt; </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">maxE </span><span class="s0">+ </span><span class="s5">1 </span><span class="s0">|| </span><span class="s2">e </span><span class="s0">&lt; </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">minE </span><span class="s0">- </span><span class="s5">1</span><span class="s0">) </span><span class="s1">return new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">e </span><span class="s0">&gt; </span><span class="s5">0 </span><span class="s0">? </span><span class="s2">s </span><span class="s0">/ </span><span class="s5">0 </span><span class="s0">: </span><span class="s5">0</span><span class="s0">);</span>

    <span class="s2">external </span><span class="s0">= </span><span class="s1">false</span><span class="s0">;</span>
    <span class="s2">Ctor</span><span class="s0">.</span><span class="s2">rounding </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">s </span><span class="s0">= </span><span class="s5">1</span><span class="s0">;</span>

    <span class="s4">// Estimate the extra guard digits needed to ensure five correct rounding digits from</span>
    <span class="s4">// naturalLogarithm(x). Example of failure without these extra digits (precision: 10):</span>
    <span class="s4">// new Decimal(2.32456).pow('2087987436534566.46411')</span>
    <span class="s4">// should be 1.162377823e+764914905173815, but is 1.162355823e+764914905173815</span>
    <span class="s2">k </span><span class="s0">= </span><span class="s2">Math</span><span class="s0">.</span><span class="s2">min</span><span class="s0">(</span><span class="s5">12</span><span class="s0">, (</span><span class="s2">e </span><span class="s0">+ </span><span class="s3">''</span><span class="s0">).</span><span class="s2">length</span><span class="s0">);</span>

    <span class="s4">// r = x^y = exp(y*ln(x))</span>
    <span class="s2">r </span><span class="s0">= </span><span class="s2">naturalExponential</span><span class="s0">(</span><span class="s2">y</span><span class="s0">.</span><span class="s2">times</span><span class="s0">(</span><span class="s2">naturalLogarithm</span><span class="s0">(</span><span class="s2">x</span><span class="s0">, </span><span class="s2">pr </span><span class="s0">+ </span><span class="s2">k</span><span class="s0">)), </span><span class="s2">pr</span><span class="s0">);</span>

    <span class="s4">// r may be Infinity, e.g. (0.9999999999999999).pow(-1e+40)</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">r</span><span class="s0">.</span><span class="s2">d</span><span class="s0">) {</span>

      <span class="s4">// Truncate to the required precision plus five rounding digits.</span>
      <span class="s2">r </span><span class="s0">= </span><span class="s2">finalise</span><span class="s0">(</span><span class="s2">r</span><span class="s0">, </span><span class="s2">pr </span><span class="s0">+ </span><span class="s5">5</span><span class="s0">, </span><span class="s5">1</span><span class="s0">);</span>

      <span class="s4">// If the rounding digits are [49]9999 or [50]0000 increase the precision by 10 and recalculate</span>
      <span class="s4">// the result.</span>
      <span class="s1">if </span><span class="s0">(</span><span class="s2">checkRoundingDigits</span><span class="s0">(</span><span class="s2">r</span><span class="s0">.</span><span class="s2">d</span><span class="s0">, </span><span class="s2">pr</span><span class="s0">, </span><span class="s2">rm</span><span class="s0">)) {</span>
        <span class="s2">e </span><span class="s0">= </span><span class="s2">pr </span><span class="s0">+ </span><span class="s5">10</span><span class="s0">;</span>

        <span class="s4">// Truncate to the increased precision plus five rounding digits.</span>
        <span class="s2">r </span><span class="s0">= </span><span class="s2">finalise</span><span class="s0">(</span><span class="s2">naturalExponential</span><span class="s0">(</span><span class="s2">y</span><span class="s0">.</span><span class="s2">times</span><span class="s0">(</span><span class="s2">naturalLogarithm</span><span class="s0">(</span><span class="s2">x</span><span class="s0">, </span><span class="s2">e </span><span class="s0">+ </span><span class="s2">k</span><span class="s0">)), </span><span class="s2">e</span><span class="s0">), </span><span class="s2">e </span><span class="s0">+ </span><span class="s5">5</span><span class="s0">, </span><span class="s5">1</span><span class="s0">);</span>

        <span class="s4">// Check for 14 nines from the 2nd rounding digit (the first rounding digit may be 4 or 9).</span>
        <span class="s1">if </span><span class="s0">(+</span><span class="s2">digitsToString</span><span class="s0">(</span><span class="s2">r</span><span class="s0">.</span><span class="s2">d</span><span class="s0">).</span><span class="s2">slice</span><span class="s0">(</span><span class="s2">pr </span><span class="s0">+ </span><span class="s5">1</span><span class="s0">, </span><span class="s2">pr </span><span class="s0">+ </span><span class="s5">15</span><span class="s0">) + </span><span class="s5">1 </span><span class="s0">== </span><span class="s5">1e14</span><span class="s0">) {</span>
          <span class="s2">r </span><span class="s0">= </span><span class="s2">finalise</span><span class="s0">(</span><span class="s2">r</span><span class="s0">, </span><span class="s2">pr </span><span class="s0">+ </span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s0">);</span>
        <span class="s0">}</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s2">r</span><span class="s0">.</span><span class="s2">s </span><span class="s0">= </span><span class="s2">s</span><span class="s0">;</span>
    <span class="s2">external </span><span class="s0">= </span><span class="s1">true</span><span class="s0">;</span>
    <span class="s2">Ctor</span><span class="s0">.</span><span class="s2">rounding </span><span class="s0">= </span><span class="s2">rm</span><span class="s0">;</span>

    <span class="s1">return </span><span class="s2">finalise</span><span class="s0">(</span><span class="s2">r</span><span class="s0">, </span><span class="s2">pr</span><span class="s0">, </span><span class="s2">rm</span><span class="s0">);</span>
  <span class="s0">};</span>


  <span class="s4">/* 
   * Return a string representing the value of this Decimal rounded to `sd` significant digits 
   * using rounding mode `rounding`. 
   * 
   * Return exponential notation if `sd` is less than the number of digits necessary to represent 
   * the integer part of the value in normal notation. 
   * 
   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive. 
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive. 
   * 
   */</span>
  <span class="s2">P</span><span class="s0">.</span><span class="s2">toPrecision </span><span class="s0">= </span><span class="s1">function </span><span class="s0">(</span><span class="s2">sd</span><span class="s0">, </span><span class="s2">rm</span><span class="s0">) {</span>
    <span class="s1">var </span><span class="s2">str</span><span class="s0">,</span>
      <span class="s2">x </span><span class="s0">= </span><span class="s1">this</span><span class="s0">,</span>
      <span class="s2">Ctor </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">constructor</span><span class="s0">;</span>

    <span class="s1">if </span><span class="s0">(</span><span class="s2">sd </span><span class="s0">=== </span><span class="s1">void </span><span class="s5">0</span><span class="s0">) {</span>
      <span class="s2">str </span><span class="s0">= </span><span class="s2">finiteToString</span><span class="s0">(</span><span class="s2">x</span><span class="s0">, </span><span class="s2">x</span><span class="s0">.</span><span class="s2">e </span><span class="s0">&lt;= </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">toExpNeg </span><span class="s0">|| </span><span class="s2">x</span><span class="s0">.</span><span class="s2">e </span><span class="s0">&gt;= </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">toExpPos</span><span class="s0">);</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s2">checkInt32</span><span class="s0">(</span><span class="s2">sd</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s2">MAX_DIGITS</span><span class="s0">);</span>

      <span class="s1">if </span><span class="s0">(</span><span class="s2">rm </span><span class="s0">=== </span><span class="s1">void </span><span class="s5">0</span><span class="s0">) </span><span class="s2">rm </span><span class="s0">= </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">rounding</span><span class="s0">;</span>
      <span class="s1">else </span><span class="s2">checkInt32</span><span class="s0">(</span><span class="s2">rm</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">8</span><span class="s0">);</span>

      <span class="s2">x </span><span class="s0">= </span><span class="s2">finalise</span><span class="s0">(</span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">x</span><span class="s0">), </span><span class="s2">sd</span><span class="s0">, </span><span class="s2">rm</span><span class="s0">);</span>
      <span class="s2">str </span><span class="s0">= </span><span class="s2">finiteToString</span><span class="s0">(</span><span class="s2">x</span><span class="s0">, </span><span class="s2">sd </span><span class="s0">&lt;= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">e </span><span class="s0">|| </span><span class="s2">x</span><span class="s0">.</span><span class="s2">e </span><span class="s0">&lt;= </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">toExpNeg</span><span class="s0">, </span><span class="s2">sd</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s1">return </span><span class="s2">x</span><span class="s0">.</span><span class="s2">isNeg</span><span class="s0">() &amp;&amp; !</span><span class="s2">x</span><span class="s0">.</span><span class="s2">isZero</span><span class="s0">() ? </span><span class="s3">'-' </span><span class="s0">+ </span><span class="s2">str </span><span class="s0">: </span><span class="s2">str</span><span class="s0">;</span>
  <span class="s0">};</span>


  <span class="s4">/* 
   * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `sd` 
   * significant digits using rounding mode `rm`, or to `precision` and `rounding` respectively if 
   * omitted. 
   * 
   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive. 
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive. 
   * 
   * 'toSD() digits out of range: {sd}' 
   * 'toSD() digits not an integer: {sd}' 
   * 'toSD() rounding mode not an integer: {rm}' 
   * 'toSD() rounding mode out of range: {rm}' 
   * 
   */</span>
  <span class="s2">P</span><span class="s0">.</span><span class="s2">toSignificantDigits </span><span class="s0">= </span><span class="s2">P</span><span class="s0">.</span><span class="s2">toSD </span><span class="s0">= </span><span class="s1">function </span><span class="s0">(</span><span class="s2">sd</span><span class="s0">, </span><span class="s2">rm</span><span class="s0">) {</span>
    <span class="s1">var </span><span class="s2">x </span><span class="s0">= </span><span class="s1">this</span><span class="s0">,</span>
      <span class="s2">Ctor </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">constructor</span><span class="s0">;</span>

    <span class="s1">if </span><span class="s0">(</span><span class="s2">sd </span><span class="s0">=== </span><span class="s1">void </span><span class="s5">0</span><span class="s0">) {</span>
      <span class="s2">sd </span><span class="s0">= </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">precision</span><span class="s0">;</span>
      <span class="s2">rm </span><span class="s0">= </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">rounding</span><span class="s0">;</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s2">checkInt32</span><span class="s0">(</span><span class="s2">sd</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s2">MAX_DIGITS</span><span class="s0">);</span>

      <span class="s1">if </span><span class="s0">(</span><span class="s2">rm </span><span class="s0">=== </span><span class="s1">void </span><span class="s5">0</span><span class="s0">) </span><span class="s2">rm </span><span class="s0">= </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">rounding</span><span class="s0">;</span>
      <span class="s1">else </span><span class="s2">checkInt32</span><span class="s0">(</span><span class="s2">rm</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">8</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s1">return </span><span class="s2">finalise</span><span class="s0">(</span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">x</span><span class="s0">), </span><span class="s2">sd</span><span class="s0">, </span><span class="s2">rm</span><span class="s0">);</span>
  <span class="s0">};</span>


  <span class="s4">/* 
   * Return a string representing the value of this Decimal. 
   * 
   * Return exponential notation if this Decimal has a positive exponent equal to or greater than 
   * `toExpPos`, or a negative exponent equal to or less than `toExpNeg`. 
   * 
   */</span>
  <span class="s2">P</span><span class="s0">.</span><span class="s2">toString </span><span class="s0">= </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">var </span><span class="s2">x </span><span class="s0">= </span><span class="s1">this</span><span class="s0">,</span>
      <span class="s2">Ctor </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">constructor</span><span class="s0">,</span>
      <span class="s2">str </span><span class="s0">= </span><span class="s2">finiteToString</span><span class="s0">(</span><span class="s2">x</span><span class="s0">, </span><span class="s2">x</span><span class="s0">.</span><span class="s2">e </span><span class="s0">&lt;= </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">toExpNeg </span><span class="s0">|| </span><span class="s2">x</span><span class="s0">.</span><span class="s2">e </span><span class="s0">&gt;= </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">toExpPos</span><span class="s0">);</span>

    <span class="s1">return </span><span class="s2">x</span><span class="s0">.</span><span class="s2">isNeg</span><span class="s0">() &amp;&amp; !</span><span class="s2">x</span><span class="s0">.</span><span class="s2">isZero</span><span class="s0">() ? </span><span class="s3">'-' </span><span class="s0">+ </span><span class="s2">str </span><span class="s0">: </span><span class="s2">str</span><span class="s0">;</span>
  <span class="s0">};</span>


  <span class="s4">/* 
   * Return a new Decimal whose value is the value of this Decimal truncated to a whole number. 
   * 
   */</span>
  <span class="s2">P</span><span class="s0">.</span><span class="s2">truncated </span><span class="s0">= </span><span class="s2">P</span><span class="s0">.</span><span class="s2">trunc </span><span class="s0">= </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">return </span><span class="s2">finalise</span><span class="s0">(</span><span class="s1">new this</span><span class="s0">.</span><span class="s2">constructor</span><span class="s0">(</span><span class="s1">this</span><span class="s0">), </span><span class="s1">this</span><span class="s0">.</span><span class="s2">e </span><span class="s0">+ </span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s0">);</span>
  <span class="s0">};</span>


  <span class="s4">/* 
   * Return a string representing the value of this Decimal. 
   * Unlike `toString`, negative zero will include the minus sign. 
   * 
   */</span>
  <span class="s2">P</span><span class="s0">.</span><span class="s2">valueOf </span><span class="s0">= </span><span class="s2">P</span><span class="s0">.</span><span class="s2">toJSON </span><span class="s0">= </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">var </span><span class="s2">x </span><span class="s0">= </span><span class="s1">this</span><span class="s0">,</span>
      <span class="s2">Ctor </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">constructor</span><span class="s0">,</span>
      <span class="s2">str </span><span class="s0">= </span><span class="s2">finiteToString</span><span class="s0">(</span><span class="s2">x</span><span class="s0">, </span><span class="s2">x</span><span class="s0">.</span><span class="s2">e </span><span class="s0">&lt;= </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">toExpNeg </span><span class="s0">|| </span><span class="s2">x</span><span class="s0">.</span><span class="s2">e </span><span class="s0">&gt;= </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">toExpPos</span><span class="s0">);</span>

    <span class="s1">return </span><span class="s2">x</span><span class="s0">.</span><span class="s2">isNeg</span><span class="s0">() ? </span><span class="s3">'-' </span><span class="s0">+ </span><span class="s2">str </span><span class="s0">: </span><span class="s2">str</span><span class="s0">;</span>
  <span class="s0">};</span>


  <span class="s4">// Helper functions for Decimal.prototype (P) and/or Decimal methods, and their callers.</span>


  <span class="s4">/* 
   *  digitsToString           P.cubeRoot, P.logarithm, P.squareRoot, P.toFraction, P.toPower, 
   *                           finiteToString, naturalExponential, naturalLogarithm 
   *  checkInt32               P.toDecimalPlaces, P.toExponential, P.toFixed, P.toNearest, 
   *                           P.toPrecision, P.toSignificantDigits, toStringBinary, random 
   *  checkRoundingDigits      P.logarithm, P.toPower, naturalExponential, naturalLogarithm 
   *  convertBase              toStringBinary, parseOther 
   *  cos                      P.cos 
   *  divide                   P.atanh, P.cubeRoot, P.dividedBy, P.dividedToIntegerBy, 
   *                           P.logarithm, P.modulo, P.squareRoot, P.tan, P.tanh, P.toFraction, 
   *                           P.toNearest, toStringBinary, naturalExponential, naturalLogarithm, 
   *                           taylorSeries, atan2, parseOther 
   *  finalise                 P.absoluteValue, P.atan, P.atanh, P.ceil, P.cos, P.cosh, 
   *                           P.cubeRoot, P.dividedToIntegerBy, P.floor, P.logarithm, P.minus, 
   *                           P.modulo, P.negated, P.plus, P.round, P.sin, P.sinh, P.squareRoot, 
   *                           P.tan, P.times, P.toDecimalPlaces, P.toExponential, P.toFixed, 
   *                           P.toNearest, P.toPower, P.toPrecision, P.toSignificantDigits, 
   *                           P.truncated, divide, getLn10, getPi, naturalExponential, 
   *                           naturalLogarithm, ceil, floor, round, trunc 
   *  finiteToString           P.toExponential, P.toFixed, P.toPrecision, P.toString, P.valueOf, 
   *                           toStringBinary 
   *  getBase10Exponent        P.minus, P.plus, P.times, parseOther 
   *  getLn10                  P.logarithm, naturalLogarithm 
   *  getPi                    P.acos, P.asin, P.atan, toLessThanHalfPi, atan2 
   *  getPrecision             P.precision, P.toFraction 
   *  getZeroString            digitsToString, finiteToString 
   *  intPow                   P.toPower, parseOther 
   *  isOdd                    toLessThanHalfPi 
   *  maxOrMin                 max, min 
   *  naturalExponential       P.naturalExponential, P.toPower 
   *  naturalLogarithm         P.acosh, P.asinh, P.atanh, P.logarithm, P.naturalLogarithm, 
   *                           P.toPower, naturalExponential 
   *  nonFiniteToString        finiteToString, toStringBinary 
   *  parseDecimal             Decimal 
   *  parseOther               Decimal 
   *  sin                      P.sin 
   *  taylorSeries             P.cosh, P.sinh, cos, sin 
   *  toLessThanHalfPi         P.cos, P.sin 
   *  toStringBinary           P.toBinary, P.toHexadecimal, P.toOctal 
   *  truncate                 intPow 
   * 
   *  Throws:                  P.logarithm, P.precision, P.toFraction, checkInt32, getLn10, getPi, 
   *                           naturalLogarithm, config, parseOther, random, Decimal 
   */</span>


  <span class="s1">function </span><span class="s2">digitsToString</span><span class="s0">(</span><span class="s2">d</span><span class="s0">) {</span>
    <span class="s1">var </span><span class="s2">i</span><span class="s0">, </span><span class="s2">k</span><span class="s0">, </span><span class="s2">ws</span><span class="s0">,</span>
      <span class="s2">indexOfLastWord </span><span class="s0">= </span><span class="s2">d</span><span class="s0">.</span><span class="s2">length </span><span class="s0">- </span><span class="s5">1</span><span class="s0">,</span>
      <span class="s2">str </span><span class="s0">= </span><span class="s3">''</span><span class="s0">,</span>
      <span class="s2">w </span><span class="s0">= </span><span class="s2">d</span><span class="s0">[</span><span class="s5">0</span><span class="s0">];</span>

    <span class="s1">if </span><span class="s0">(</span><span class="s2">indexOfLastWord </span><span class="s0">&gt; </span><span class="s5">0</span><span class="s0">) {</span>
      <span class="s2">str </span><span class="s0">+= </span><span class="s2">w</span><span class="s0">;</span>
      <span class="s1">for </span><span class="s0">(</span><span class="s2">i </span><span class="s0">= </span><span class="s5">1</span><span class="s0">; </span><span class="s2">i </span><span class="s0">&lt; </span><span class="s2">indexOfLastWord</span><span class="s0">; </span><span class="s2">i</span><span class="s0">++) {</span>
        <span class="s2">ws </span><span class="s0">= </span><span class="s2">d</span><span class="s0">[</span><span class="s2">i</span><span class="s0">] + </span><span class="s3">''</span><span class="s0">;</span>
        <span class="s2">k </span><span class="s0">= </span><span class="s2">LOG_BASE </span><span class="s0">- </span><span class="s2">ws</span><span class="s0">.</span><span class="s2">length</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s2">k</span><span class="s0">) </span><span class="s2">str </span><span class="s0">+= </span><span class="s2">getZeroString</span><span class="s0">(</span><span class="s2">k</span><span class="s0">);</span>
        <span class="s2">str </span><span class="s0">+= </span><span class="s2">ws</span><span class="s0">;</span>
      <span class="s0">}</span>

      <span class="s2">w </span><span class="s0">= </span><span class="s2">d</span><span class="s0">[</span><span class="s2">i</span><span class="s0">];</span>
      <span class="s2">ws </span><span class="s0">= </span><span class="s2">w </span><span class="s0">+ </span><span class="s3">''</span><span class="s0">;</span>
      <span class="s2">k </span><span class="s0">= </span><span class="s2">LOG_BASE </span><span class="s0">- </span><span class="s2">ws</span><span class="s0">.</span><span class="s2">length</span><span class="s0">;</span>
      <span class="s1">if </span><span class="s0">(</span><span class="s2">k</span><span class="s0">) </span><span class="s2">str </span><span class="s0">+= </span><span class="s2">getZeroString</span><span class="s0">(</span><span class="s2">k</span><span class="s0">);</span>
    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(</span><span class="s2">w </span><span class="s0">=== </span><span class="s5">0</span><span class="s0">) {</span>
      <span class="s1">return </span><span class="s3">'0'</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s4">// Remove trailing zeros of last w.</span>
    <span class="s1">for </span><span class="s0">(; </span><span class="s2">w </span><span class="s0">% </span><span class="s5">10 </span><span class="s0">=== </span><span class="s5">0</span><span class="s0">;) </span><span class="s2">w </span><span class="s0">/= </span><span class="s5">10</span><span class="s0">;</span>

    <span class="s1">return </span><span class="s2">str </span><span class="s0">+ </span><span class="s2">w</span><span class="s0">;</span>
  <span class="s0">}</span>


  <span class="s1">function </span><span class="s2">checkInt32</span><span class="s0">(</span><span class="s2">i</span><span class="s0">, </span><span class="s2">min</span><span class="s0">, </span><span class="s2">max</span><span class="s0">) {</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">i </span><span class="s0">!== ~~</span><span class="s2">i </span><span class="s0">|| </span><span class="s2">i </span><span class="s0">&lt; </span><span class="s2">min </span><span class="s0">|| </span><span class="s2">i </span><span class="s0">&gt; </span><span class="s2">max</span><span class="s0">) {</span>
      <span class="s1">throw </span><span class="s2">Error</span><span class="s0">(</span><span class="s2">invalidArgument </span><span class="s0">+ </span><span class="s2">i</span><span class="s0">);</span>
    <span class="s0">}</span>
  <span class="s0">}</span>


  <span class="s4">/* 
   * Check 5 rounding digits if `repeating` is null, 4 otherwise. 
   * `repeating == null` if caller is `log` or `pow`, 
   * `repeating != null` if caller is `naturalLogarithm` or `naturalExponential`. 
   */</span>
  <span class="s1">function </span><span class="s2">checkRoundingDigits</span><span class="s0">(</span><span class="s2">d</span><span class="s0">, </span><span class="s2">i</span><span class="s0">, </span><span class="s2">rm</span><span class="s0">, </span><span class="s2">repeating</span><span class="s0">) {</span>
    <span class="s1">var </span><span class="s2">di</span><span class="s0">, </span><span class="s2">k</span><span class="s0">, </span><span class="s2">r</span><span class="s0">, </span><span class="s2">rd</span><span class="s0">;</span>

    <span class="s4">// Get the length of the first word of the array d.</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s2">k </span><span class="s0">= </span><span class="s2">d</span><span class="s0">[</span><span class="s5">0</span><span class="s0">]; </span><span class="s2">k </span><span class="s0">&gt;= </span><span class="s5">10</span><span class="s0">; </span><span class="s2">k </span><span class="s0">/= </span><span class="s5">10</span><span class="s0">) --</span><span class="s2">i</span><span class="s0">;</span>

    <span class="s4">// Is the rounding digit in the first word of d?</span>
    <span class="s1">if </span><span class="s0">(--</span><span class="s2">i </span><span class="s0">&lt; </span><span class="s5">0</span><span class="s0">) {</span>
      <span class="s2">i </span><span class="s0">+= </span><span class="s2">LOG_BASE</span><span class="s0">;</span>
      <span class="s2">di </span><span class="s0">= </span><span class="s5">0</span><span class="s0">;</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s2">di </span><span class="s0">= </span><span class="s2">Math</span><span class="s0">.</span><span class="s2">ceil</span><span class="s0">((</span><span class="s2">i </span><span class="s0">+ </span><span class="s5">1</span><span class="s0">) / </span><span class="s2">LOG_BASE</span><span class="s0">);</span>
      <span class="s2">i </span><span class="s0">%= </span><span class="s2">LOG_BASE</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s4">// i is the index (0 - 6) of the rounding digit.</span>
    <span class="s4">// E.g. if within the word 3487563 the first rounding digit is 5,</span>
    <span class="s4">// then i = 4, k = 1000, rd = 3487563 % 1000 = 563</span>
    <span class="s2">k </span><span class="s0">= </span><span class="s2">mathpow</span><span class="s0">(</span><span class="s5">10</span><span class="s0">, </span><span class="s2">LOG_BASE </span><span class="s0">- </span><span class="s2">i</span><span class="s0">);</span>
    <span class="s2">rd </span><span class="s0">= </span><span class="s2">d</span><span class="s0">[</span><span class="s2">di</span><span class="s0">] % </span><span class="s2">k </span><span class="s0">| </span><span class="s5">0</span><span class="s0">;</span>

    <span class="s1">if </span><span class="s0">(</span><span class="s2">repeating </span><span class="s0">== </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s1">if </span><span class="s0">(</span><span class="s2">i </span><span class="s0">&lt; </span><span class="s5">3</span><span class="s0">) {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s2">i </span><span class="s0">== </span><span class="s5">0</span><span class="s0">) </span><span class="s2">rd </span><span class="s0">= </span><span class="s2">rd </span><span class="s0">/ </span><span class="s5">100 </span><span class="s0">| </span><span class="s5">0</span><span class="s0">;</span>
        <span class="s1">else if </span><span class="s0">(</span><span class="s2">i </span><span class="s0">== </span><span class="s5">1</span><span class="s0">) </span><span class="s2">rd </span><span class="s0">= </span><span class="s2">rd </span><span class="s0">/ </span><span class="s5">10 </span><span class="s0">| </span><span class="s5">0</span><span class="s0">;</span>
        <span class="s2">r </span><span class="s0">= </span><span class="s2">rm </span><span class="s0">&lt; </span><span class="s5">4 </span><span class="s0">&amp;&amp; </span><span class="s2">rd </span><span class="s0">== </span><span class="s5">99999 </span><span class="s0">|| </span><span class="s2">rm </span><span class="s0">&gt; </span><span class="s5">3 </span><span class="s0">&amp;&amp; </span><span class="s2">rd </span><span class="s0">== </span><span class="s5">49999 </span><span class="s0">|| </span><span class="s2">rd </span><span class="s0">== </span><span class="s5">50000 </span><span class="s0">|| </span><span class="s2">rd </span><span class="s0">== </span><span class="s5">0</span><span class="s0">;</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s2">r </span><span class="s0">= (</span><span class="s2">rm </span><span class="s0">&lt; </span><span class="s5">4 </span><span class="s0">&amp;&amp; </span><span class="s2">rd </span><span class="s0">+ </span><span class="s5">1 </span><span class="s0">== </span><span class="s2">k </span><span class="s0">|| </span><span class="s2">rm </span><span class="s0">&gt; </span><span class="s5">3 </span><span class="s0">&amp;&amp; </span><span class="s2">rd </span><span class="s0">+ </span><span class="s5">1 </span><span class="s0">== </span><span class="s2">k </span><span class="s0">/ </span><span class="s5">2</span><span class="s0">) &amp;&amp;</span>
          <span class="s0">(</span><span class="s2">d</span><span class="s0">[</span><span class="s2">di </span><span class="s0">+ </span><span class="s5">1</span><span class="s0">] / </span><span class="s2">k </span><span class="s0">/ </span><span class="s5">100 </span><span class="s0">| </span><span class="s5">0</span><span class="s0">) == </span><span class="s2">mathpow</span><span class="s0">(</span><span class="s5">10</span><span class="s0">, </span><span class="s2">i </span><span class="s0">- </span><span class="s5">2</span><span class="s0">) - </span><span class="s5">1 </span><span class="s0">||</span>
            <span class="s0">(</span><span class="s2">rd </span><span class="s0">== </span><span class="s2">k </span><span class="s0">/ </span><span class="s5">2 </span><span class="s0">|| </span><span class="s2">rd </span><span class="s0">== </span><span class="s5">0</span><span class="s0">) &amp;&amp; (</span><span class="s2">d</span><span class="s0">[</span><span class="s2">di </span><span class="s0">+ </span><span class="s5">1</span><span class="s0">] / </span><span class="s2">k </span><span class="s0">/ </span><span class="s5">100 </span><span class="s0">| </span><span class="s5">0</span><span class="s0">) == </span><span class="s5">0</span><span class="s0">;</span>
      <span class="s0">}</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s1">if </span><span class="s0">(</span><span class="s2">i </span><span class="s0">&lt; </span><span class="s5">4</span><span class="s0">) {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s2">i </span><span class="s0">== </span><span class="s5">0</span><span class="s0">) </span><span class="s2">rd </span><span class="s0">= </span><span class="s2">rd </span><span class="s0">/ </span><span class="s5">1000 </span><span class="s0">| </span><span class="s5">0</span><span class="s0">;</span>
        <span class="s1">else if </span><span class="s0">(</span><span class="s2">i </span><span class="s0">== </span><span class="s5">1</span><span class="s0">) </span><span class="s2">rd </span><span class="s0">= </span><span class="s2">rd </span><span class="s0">/ </span><span class="s5">100 </span><span class="s0">| </span><span class="s5">0</span><span class="s0">;</span>
        <span class="s1">else if </span><span class="s0">(</span><span class="s2">i </span><span class="s0">== </span><span class="s5">2</span><span class="s0">) </span><span class="s2">rd </span><span class="s0">= </span><span class="s2">rd </span><span class="s0">/ </span><span class="s5">10 </span><span class="s0">| </span><span class="s5">0</span><span class="s0">;</span>
        <span class="s2">r </span><span class="s0">= (</span><span class="s2">repeating </span><span class="s0">|| </span><span class="s2">rm </span><span class="s0">&lt; </span><span class="s5">4</span><span class="s0">) &amp;&amp; </span><span class="s2">rd </span><span class="s0">== </span><span class="s5">9999 </span><span class="s0">|| !</span><span class="s2">repeating </span><span class="s0">&amp;&amp; </span><span class="s2">rm </span><span class="s0">&gt; </span><span class="s5">3 </span><span class="s0">&amp;&amp; </span><span class="s2">rd </span><span class="s0">== </span><span class="s5">4999</span><span class="s0">;</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s2">r </span><span class="s0">= ((</span><span class="s2">repeating </span><span class="s0">|| </span><span class="s2">rm </span><span class="s0">&lt; </span><span class="s5">4</span><span class="s0">) &amp;&amp; </span><span class="s2">rd </span><span class="s0">+ </span><span class="s5">1 </span><span class="s0">== </span><span class="s2">k </span><span class="s0">||</span>
        <span class="s0">(!</span><span class="s2">repeating </span><span class="s0">&amp;&amp; </span><span class="s2">rm </span><span class="s0">&gt; </span><span class="s5">3</span><span class="s0">) &amp;&amp; </span><span class="s2">rd </span><span class="s0">+ </span><span class="s5">1 </span><span class="s0">== </span><span class="s2">k </span><span class="s0">/ </span><span class="s5">2</span><span class="s0">) &amp;&amp;</span>
          <span class="s0">(</span><span class="s2">d</span><span class="s0">[</span><span class="s2">di </span><span class="s0">+ </span><span class="s5">1</span><span class="s0">] / </span><span class="s2">k </span><span class="s0">/ </span><span class="s5">1000 </span><span class="s0">| </span><span class="s5">0</span><span class="s0">) == </span><span class="s2">mathpow</span><span class="s0">(</span><span class="s5">10</span><span class="s0">, </span><span class="s2">i </span><span class="s0">- </span><span class="s5">3</span><span class="s0">) - </span><span class="s5">1</span><span class="s0">;</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">return </span><span class="s2">r</span><span class="s0">;</span>
  <span class="s0">}</span>


  <span class="s4">// Convert string of `baseIn` to an array of numbers of `baseOut`.</span>
  <span class="s4">// Eg. convertBase('255', 10, 16) returns [15, 15].</span>
  <span class="s4">// Eg. convertBase('ff', 16, 10) returns [2, 5, 5].</span>
  <span class="s1">function </span><span class="s2">convertBase</span><span class="s0">(</span><span class="s2">str</span><span class="s0">, </span><span class="s2">baseIn</span><span class="s0">, </span><span class="s2">baseOut</span><span class="s0">) {</span>
    <span class="s1">var </span><span class="s2">j</span><span class="s0">,</span>
      <span class="s2">arr </span><span class="s0">= [</span><span class="s5">0</span><span class="s0">],</span>
      <span class="s2">arrL</span><span class="s0">,</span>
      <span class="s2">i </span><span class="s0">= </span><span class="s5">0</span><span class="s0">,</span>
      <span class="s2">strL </span><span class="s0">= </span><span class="s2">str</span><span class="s0">.</span><span class="s2">length</span><span class="s0">;</span>

    <span class="s1">for </span><span class="s0">(; </span><span class="s2">i </span><span class="s0">&lt; </span><span class="s2">strL</span><span class="s0">;) {</span>
      <span class="s1">for </span><span class="s0">(</span><span class="s2">arrL </span><span class="s0">= </span><span class="s2">arr</span><span class="s0">.</span><span class="s2">length</span><span class="s0">; </span><span class="s2">arrL</span><span class="s0">--;) </span><span class="s2">arr</span><span class="s0">[</span><span class="s2">arrL</span><span class="s0">] *= </span><span class="s2">baseIn</span><span class="s0">;</span>
      <span class="s2">arr</span><span class="s0">[</span><span class="s5">0</span><span class="s0">] += </span><span class="s2">NUMERALS</span><span class="s0">.</span><span class="s2">indexOf</span><span class="s0">(</span><span class="s2">str</span><span class="s0">.</span><span class="s2">charAt</span><span class="s0">(</span><span class="s2">i</span><span class="s0">++));</span>
      <span class="s1">for </span><span class="s0">(</span><span class="s2">j </span><span class="s0">= </span><span class="s5">0</span><span class="s0">; </span><span class="s2">j </span><span class="s0">&lt; </span><span class="s2">arr</span><span class="s0">.</span><span class="s2">length</span><span class="s0">; </span><span class="s2">j</span><span class="s0">++) {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s2">arr</span><span class="s0">[</span><span class="s2">j</span><span class="s0">] &gt; </span><span class="s2">baseOut </span><span class="s0">- </span><span class="s5">1</span><span class="s0">) {</span>
          <span class="s1">if </span><span class="s0">(</span><span class="s2">arr</span><span class="s0">[</span><span class="s2">j </span><span class="s0">+ </span><span class="s5">1</span><span class="s0">] === </span><span class="s1">void </span><span class="s5">0</span><span class="s0">) </span><span class="s2">arr</span><span class="s0">[</span><span class="s2">j </span><span class="s0">+ </span><span class="s5">1</span><span class="s0">] = </span><span class="s5">0</span><span class="s0">;</span>
          <span class="s2">arr</span><span class="s0">[</span><span class="s2">j </span><span class="s0">+ </span><span class="s5">1</span><span class="s0">] += </span><span class="s2">arr</span><span class="s0">[</span><span class="s2">j</span><span class="s0">] / </span><span class="s2">baseOut </span><span class="s0">| </span><span class="s5">0</span><span class="s0">;</span>
          <span class="s2">arr</span><span class="s0">[</span><span class="s2">j</span><span class="s0">] %= </span><span class="s2">baseOut</span><span class="s0">;</span>
        <span class="s0">}</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">return </span><span class="s2">arr</span><span class="s0">.</span><span class="s2">reverse</span><span class="s0">();</span>
  <span class="s0">}</span>


  <span class="s4">/* 
   * cos(x) = 1 - x^2/2! + x^4/4! - ... 
   * |x| &lt; pi/2 
   * 
   */</span>
  <span class="s1">function </span><span class="s2">cosine</span><span class="s0">(</span><span class="s2">Ctor</span><span class="s0">, </span><span class="s2">x</span><span class="s0">) {</span>
    <span class="s1">var </span><span class="s2">k</span><span class="s0">, </span><span class="s2">len</span><span class="s0">, </span><span class="s2">y</span><span class="s0">;</span>

    <span class="s1">if </span><span class="s0">(</span><span class="s2">x</span><span class="s0">.</span><span class="s2">isZero</span><span class="s0">()) </span><span class="s1">return </span><span class="s2">x</span><span class="s0">;</span>

    <span class="s4">// Argument reduction: cos(4x) = 8*(cos^4(x) - cos^2(x)) + 1</span>
    <span class="s4">// i.e. cos(x) = 8*(cos^4(x/4) - cos^2(x/4)) + 1</span>

    <span class="s4">// Estimate the optimum number of times to use the argument reduction.</span>
    <span class="s2">len </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">d</span><span class="s0">.</span><span class="s2">length</span><span class="s0">;</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">len </span><span class="s0">&lt; </span><span class="s5">32</span><span class="s0">) {</span>
      <span class="s2">k </span><span class="s0">= </span><span class="s2">Math</span><span class="s0">.</span><span class="s2">ceil</span><span class="s0">(</span><span class="s2">len </span><span class="s0">/ </span><span class="s5">3</span><span class="s0">);</span>
      <span class="s2">y </span><span class="s0">= (</span><span class="s5">1 </span><span class="s0">/ </span><span class="s2">tinyPow</span><span class="s0">(</span><span class="s5">4</span><span class="s0">, </span><span class="s2">k</span><span class="s0">)).</span><span class="s2">toString</span><span class="s0">();</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s2">k </span><span class="s0">= </span><span class="s5">16</span><span class="s0">;</span>
      <span class="s2">y </span><span class="s0">= </span><span class="s3">'2.3283064365386962890625e-10'</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s2">Ctor</span><span class="s0">.</span><span class="s2">precision </span><span class="s0">+= </span><span class="s2">k</span><span class="s0">;</span>

    <span class="s2">x </span><span class="s0">= </span><span class="s2">taylorSeries</span><span class="s0">(</span><span class="s2">Ctor</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s2">x</span><span class="s0">.</span><span class="s2">times</span><span class="s0">(</span><span class="s2">y</span><span class="s0">), </span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s5">1</span><span class="s0">));</span>

    <span class="s4">// Reverse argument reduction</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s2">i </span><span class="s0">= </span><span class="s2">k</span><span class="s0">; </span><span class="s2">i</span><span class="s0">--;) {</span>
      <span class="s1">var </span><span class="s2">cos2x </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">times</span><span class="s0">(</span><span class="s2">x</span><span class="s0">);</span>
      <span class="s2">x </span><span class="s0">= </span><span class="s2">cos2x</span><span class="s0">.</span><span class="s2">times</span><span class="s0">(</span><span class="s2">cos2x</span><span class="s0">).</span><span class="s2">minus</span><span class="s0">(</span><span class="s2">cos2x</span><span class="s0">).</span><span class="s2">times</span><span class="s0">(</span><span class="s5">8</span><span class="s0">).</span><span class="s2">plus</span><span class="s0">(</span><span class="s5">1</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s2">Ctor</span><span class="s0">.</span><span class="s2">precision </span><span class="s0">-= </span><span class="s2">k</span><span class="s0">;</span>

    <span class="s1">return </span><span class="s2">x</span><span class="s0">;</span>
  <span class="s0">}</span>


  <span class="s4">/* 
   * Perform division in the specified base. 
   */</span>
  <span class="s1">var </span><span class="s2">divide </span><span class="s0">= (</span><span class="s1">function </span><span class="s0">() {</span>

    <span class="s4">// Assumes non-zero x and k, and hence non-zero result.</span>
    <span class="s1">function </span><span class="s2">multiplyInteger</span><span class="s0">(</span><span class="s2">x</span><span class="s0">, </span><span class="s2">k</span><span class="s0">, </span><span class="s2">base</span><span class="s0">) {</span>
      <span class="s1">var </span><span class="s2">temp</span><span class="s0">,</span>
        <span class="s2">carry </span><span class="s0">= </span><span class="s5">0</span><span class="s0">,</span>
        <span class="s2">i </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">length</span><span class="s0">;</span>

      <span class="s1">for </span><span class="s0">(</span><span class="s2">x </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">slice</span><span class="s0">(); </span><span class="s2">i</span><span class="s0">--;) {</span>
        <span class="s2">temp </span><span class="s0">= </span><span class="s2">x</span><span class="s0">[</span><span class="s2">i</span><span class="s0">] * </span><span class="s2">k </span><span class="s0">+ </span><span class="s2">carry</span><span class="s0">;</span>
        <span class="s2">x</span><span class="s0">[</span><span class="s2">i</span><span class="s0">] = </span><span class="s2">temp </span><span class="s0">% </span><span class="s2">base </span><span class="s0">| </span><span class="s5">0</span><span class="s0">;</span>
        <span class="s2">carry </span><span class="s0">= </span><span class="s2">temp </span><span class="s0">/ </span><span class="s2">base </span><span class="s0">| </span><span class="s5">0</span><span class="s0">;</span>
      <span class="s0">}</span>

      <span class="s1">if </span><span class="s0">(</span><span class="s2">carry</span><span class="s0">) </span><span class="s2">x</span><span class="s0">.</span><span class="s2">unshift</span><span class="s0">(</span><span class="s2">carry</span><span class="s0">);</span>

      <span class="s1">return </span><span class="s2">x</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s2">compare</span><span class="s0">(</span><span class="s2">a</span><span class="s0">, </span><span class="s2">b</span><span class="s0">, </span><span class="s2">aL</span><span class="s0">, </span><span class="s2">bL</span><span class="s0">) {</span>
      <span class="s1">var </span><span class="s2">i</span><span class="s0">, </span><span class="s2">r</span><span class="s0">;</span>

      <span class="s1">if </span><span class="s0">(</span><span class="s2">aL </span><span class="s0">!= </span><span class="s2">bL</span><span class="s0">) {</span>
        <span class="s2">r </span><span class="s0">= </span><span class="s2">aL </span><span class="s0">&gt; </span><span class="s2">bL </span><span class="s0">? </span><span class="s5">1 </span><span class="s0">: -</span><span class="s5">1</span><span class="s0">;</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s2">i </span><span class="s0">= </span><span class="s2">r </span><span class="s0">= </span><span class="s5">0</span><span class="s0">; </span><span class="s2">i </span><span class="s0">&lt; </span><span class="s2">aL</span><span class="s0">; </span><span class="s2">i</span><span class="s0">++) {</span>
          <span class="s1">if </span><span class="s0">(</span><span class="s2">a</span><span class="s0">[</span><span class="s2">i</span><span class="s0">] != </span><span class="s2">b</span><span class="s0">[</span><span class="s2">i</span><span class="s0">]) {</span>
            <span class="s2">r </span><span class="s0">= </span><span class="s2">a</span><span class="s0">[</span><span class="s2">i</span><span class="s0">] &gt; </span><span class="s2">b</span><span class="s0">[</span><span class="s2">i</span><span class="s0">] ? </span><span class="s5">1 </span><span class="s0">: -</span><span class="s5">1</span><span class="s0">;</span>
            <span class="s1">break</span><span class="s0">;</span>
          <span class="s0">}</span>
        <span class="s0">}</span>
      <span class="s0">}</span>

      <span class="s1">return </span><span class="s2">r</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s2">subtract</span><span class="s0">(</span><span class="s2">a</span><span class="s0">, </span><span class="s2">b</span><span class="s0">, </span><span class="s2">aL</span><span class="s0">, </span><span class="s2">base</span><span class="s0">) {</span>
      <span class="s1">var </span><span class="s2">i </span><span class="s0">= </span><span class="s5">0</span><span class="s0">;</span>

      <span class="s4">// Subtract b from a.</span>
      <span class="s1">for </span><span class="s0">(; </span><span class="s2">aL</span><span class="s0">--;) {</span>
        <span class="s2">a</span><span class="s0">[</span><span class="s2">aL</span><span class="s0">] -= </span><span class="s2">i</span><span class="s0">;</span>
        <span class="s2">i </span><span class="s0">= </span><span class="s2">a</span><span class="s0">[</span><span class="s2">aL</span><span class="s0">] &lt; </span><span class="s2">b</span><span class="s0">[</span><span class="s2">aL</span><span class="s0">] ? </span><span class="s5">1 </span><span class="s0">: </span><span class="s5">0</span><span class="s0">;</span>
        <span class="s2">a</span><span class="s0">[</span><span class="s2">aL</span><span class="s0">] = </span><span class="s2">i </span><span class="s0">* </span><span class="s2">base </span><span class="s0">+ </span><span class="s2">a</span><span class="s0">[</span><span class="s2">aL</span><span class="s0">] - </span><span class="s2">b</span><span class="s0">[</span><span class="s2">aL</span><span class="s0">];</span>
      <span class="s0">}</span>

      <span class="s4">// Remove leading zeros.</span>
      <span class="s1">for </span><span class="s0">(; !</span><span class="s2">a</span><span class="s0">[</span><span class="s5">0</span><span class="s0">] &amp;&amp; </span><span class="s2">a</span><span class="s0">.</span><span class="s2">length </span><span class="s0">&gt; </span><span class="s5">1</span><span class="s0">;) </span><span class="s2">a</span><span class="s0">.</span><span class="s2">shift</span><span class="s0">();</span>
    <span class="s0">}</span>

    <span class="s1">return function </span><span class="s0">(</span><span class="s2">x</span><span class="s0">, </span><span class="s2">y</span><span class="s0">, </span><span class="s2">pr</span><span class="s0">, </span><span class="s2">rm</span><span class="s0">, </span><span class="s2">dp</span><span class="s0">, </span><span class="s2">base</span><span class="s0">) {</span>
      <span class="s1">var </span><span class="s2">cmp</span><span class="s0">, </span><span class="s2">e</span><span class="s0">, </span><span class="s2">i</span><span class="s0">, </span><span class="s2">k</span><span class="s0">, </span><span class="s2">logBase</span><span class="s0">, </span><span class="s2">more</span><span class="s0">, </span><span class="s2">prod</span><span class="s0">, </span><span class="s2">prodL</span><span class="s0">, </span><span class="s2">q</span><span class="s0">, </span><span class="s2">qd</span><span class="s0">, </span><span class="s2">rem</span><span class="s0">, </span><span class="s2">remL</span><span class="s0">, </span><span class="s2">rem0</span><span class="s0">, </span><span class="s2">sd</span><span class="s0">, </span><span class="s2">t</span><span class="s0">, </span><span class="s2">xi</span><span class="s0">, </span><span class="s2">xL</span><span class="s0">, </span><span class="s2">yd0</span><span class="s0">,</span>
        <span class="s2">yL</span><span class="s0">, </span><span class="s2">yz</span><span class="s0">,</span>
        <span class="s2">Ctor </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">constructor</span><span class="s0">,</span>
        <span class="s2">sign </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">s </span><span class="s0">== </span><span class="s2">y</span><span class="s0">.</span><span class="s2">s </span><span class="s0">? </span><span class="s5">1 </span><span class="s0">: -</span><span class="s5">1</span><span class="s0">,</span>
        <span class="s2">xd </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">d</span><span class="s0">,</span>
        <span class="s2">yd </span><span class="s0">= </span><span class="s2">y</span><span class="s0">.</span><span class="s2">d</span><span class="s0">;</span>

      <span class="s4">// Either NaN, Infinity or 0?</span>
      <span class="s1">if </span><span class="s0">(!</span><span class="s2">xd </span><span class="s0">|| !</span><span class="s2">xd</span><span class="s0">[</span><span class="s5">0</span><span class="s0">] || !</span><span class="s2">yd </span><span class="s0">|| !</span><span class="s2">yd</span><span class="s0">[</span><span class="s5">0</span><span class="s0">]) {</span>

        <span class="s1">return new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s4">// Return NaN if either NaN, or both Infinity or 0.</span>
          <span class="s0">!</span><span class="s2">x</span><span class="s0">.</span><span class="s2">s </span><span class="s0">|| !</span><span class="s2">y</span><span class="s0">.</span><span class="s2">s </span><span class="s0">|| (</span><span class="s2">xd </span><span class="s0">? </span><span class="s2">yd </span><span class="s0">&amp;&amp; </span><span class="s2">xd</span><span class="s0">[</span><span class="s5">0</span><span class="s0">] == </span><span class="s2">yd</span><span class="s0">[</span><span class="s5">0</span><span class="s0">] : !</span><span class="s2">yd</span><span class="s0">) ? </span><span class="s2">NaN </span><span class="s0">:</span>

          <span class="s4">// Return ±0 if x is 0 or y is ±Infinity, or return ±Infinity as y is 0.</span>
          <span class="s2">xd </span><span class="s0">&amp;&amp; </span><span class="s2">xd</span><span class="s0">[</span><span class="s5">0</span><span class="s0">] == </span><span class="s5">0 </span><span class="s0">|| !</span><span class="s2">yd </span><span class="s0">? </span><span class="s2">sign </span><span class="s0">* </span><span class="s5">0 </span><span class="s0">: </span><span class="s2">sign </span><span class="s0">/ </span><span class="s5">0</span><span class="s0">);</span>
      <span class="s0">}</span>

      <span class="s1">if </span><span class="s0">(</span><span class="s2">base</span><span class="s0">) {</span>
        <span class="s2">logBase </span><span class="s0">= </span><span class="s5">1</span><span class="s0">;</span>
        <span class="s2">e </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">e </span><span class="s0">- </span><span class="s2">y</span><span class="s0">.</span><span class="s2">e</span><span class="s0">;</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s2">base </span><span class="s0">= </span><span class="s2">BASE</span><span class="s0">;</span>
        <span class="s2">logBase </span><span class="s0">= </span><span class="s2">LOG_BASE</span><span class="s0">;</span>
        <span class="s2">e </span><span class="s0">= </span><span class="s2">mathfloor</span><span class="s0">(</span><span class="s2">x</span><span class="s0">.</span><span class="s2">e </span><span class="s0">/ </span><span class="s2">logBase</span><span class="s0">) - </span><span class="s2">mathfloor</span><span class="s0">(</span><span class="s2">y</span><span class="s0">.</span><span class="s2">e </span><span class="s0">/ </span><span class="s2">logBase</span><span class="s0">);</span>
      <span class="s0">}</span>

      <span class="s2">yL </span><span class="s0">= </span><span class="s2">yd</span><span class="s0">.</span><span class="s2">length</span><span class="s0">;</span>
      <span class="s2">xL </span><span class="s0">= </span><span class="s2">xd</span><span class="s0">.</span><span class="s2">length</span><span class="s0">;</span>
      <span class="s2">q </span><span class="s0">= </span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">sign</span><span class="s0">);</span>
      <span class="s2">qd </span><span class="s0">= </span><span class="s2">q</span><span class="s0">.</span><span class="s2">d </span><span class="s0">= [];</span>

      <span class="s4">// Result exponent may be one less than e.</span>
      <span class="s4">// The digit array of a Decimal from toStringBinary may have trailing zeros.</span>
      <span class="s1">for </span><span class="s0">(</span><span class="s2">i </span><span class="s0">= </span><span class="s5">0</span><span class="s0">; </span><span class="s2">yd</span><span class="s0">[</span><span class="s2">i</span><span class="s0">] == (</span><span class="s2">xd</span><span class="s0">[</span><span class="s2">i</span><span class="s0">] || </span><span class="s5">0</span><span class="s0">); </span><span class="s2">i</span><span class="s0">++);</span>

      <span class="s1">if </span><span class="s0">(</span><span class="s2">yd</span><span class="s0">[</span><span class="s2">i</span><span class="s0">] &gt; (</span><span class="s2">xd</span><span class="s0">[</span><span class="s2">i</span><span class="s0">] || </span><span class="s5">0</span><span class="s0">)) </span><span class="s2">e</span><span class="s0">--;</span>

      <span class="s1">if </span><span class="s0">(</span><span class="s2">pr </span><span class="s0">== </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s2">sd </span><span class="s0">= </span><span class="s2">pr </span><span class="s0">= </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">precision</span><span class="s0">;</span>
        <span class="s2">rm </span><span class="s0">= </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">rounding</span><span class="s0">;</span>
      <span class="s0">} </span><span class="s1">else if </span><span class="s0">(</span><span class="s2">dp</span><span class="s0">) {</span>
        <span class="s2">sd </span><span class="s0">= </span><span class="s2">pr </span><span class="s0">+ (</span><span class="s2">x</span><span class="s0">.</span><span class="s2">e </span><span class="s0">- </span><span class="s2">y</span><span class="s0">.</span><span class="s2">e</span><span class="s0">) + </span><span class="s5">1</span><span class="s0">;</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s2">sd </span><span class="s0">= </span><span class="s2">pr</span><span class="s0">;</span>
      <span class="s0">}</span>

      <span class="s1">if </span><span class="s0">(</span><span class="s2">sd </span><span class="s0">&lt; </span><span class="s5">0</span><span class="s0">) {</span>
        <span class="s2">qd</span><span class="s0">.</span><span class="s2">push</span><span class="s0">(</span><span class="s5">1</span><span class="s0">);</span>
        <span class="s2">more </span><span class="s0">= </span><span class="s1">true</span><span class="s0">;</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>

        <span class="s4">// Convert precision in number of base 10 digits to base 1e7 digits.</span>
        <span class="s2">sd </span><span class="s0">= </span><span class="s2">sd </span><span class="s0">/ </span><span class="s2">logBase </span><span class="s0">+ </span><span class="s5">2 </span><span class="s0">| </span><span class="s5">0</span><span class="s0">;</span>
        <span class="s2">i </span><span class="s0">= </span><span class="s5">0</span><span class="s0">;</span>

        <span class="s4">// divisor &lt; 1e7</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s2">yL </span><span class="s0">== </span><span class="s5">1</span><span class="s0">) {</span>
          <span class="s2">k </span><span class="s0">= </span><span class="s5">0</span><span class="s0">;</span>
          <span class="s2">yd </span><span class="s0">= </span><span class="s2">yd</span><span class="s0">[</span><span class="s5">0</span><span class="s0">];</span>
          <span class="s2">sd</span><span class="s0">++;</span>

          <span class="s4">// k is the carry.</span>
          <span class="s1">for </span><span class="s0">(; (</span><span class="s2">i </span><span class="s0">&lt; </span><span class="s2">xL </span><span class="s0">|| </span><span class="s2">k</span><span class="s0">) &amp;&amp; </span><span class="s2">sd</span><span class="s0">--; </span><span class="s2">i</span><span class="s0">++) {</span>
            <span class="s2">t </span><span class="s0">= </span><span class="s2">k </span><span class="s0">* </span><span class="s2">base </span><span class="s0">+ (</span><span class="s2">xd</span><span class="s0">[</span><span class="s2">i</span><span class="s0">] || </span><span class="s5">0</span><span class="s0">);</span>
            <span class="s2">qd</span><span class="s0">[</span><span class="s2">i</span><span class="s0">] = </span><span class="s2">t </span><span class="s0">/ </span><span class="s2">yd </span><span class="s0">| </span><span class="s5">0</span><span class="s0">;</span>
            <span class="s2">k </span><span class="s0">= </span><span class="s2">t </span><span class="s0">% </span><span class="s2">yd </span><span class="s0">| </span><span class="s5">0</span><span class="s0">;</span>
          <span class="s0">}</span>

          <span class="s2">more </span><span class="s0">= </span><span class="s2">k </span><span class="s0">|| </span><span class="s2">i </span><span class="s0">&lt; </span><span class="s2">xL</span><span class="s0">;</span>

        <span class="s4">// divisor &gt;= 1e7</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>

          <span class="s4">// Normalise xd and yd so highest order digit of yd is &gt;= base/2</span>
          <span class="s2">k </span><span class="s0">= </span><span class="s2">base </span><span class="s0">/ (</span><span class="s2">yd</span><span class="s0">[</span><span class="s5">0</span><span class="s0">] + </span><span class="s5">1</span><span class="s0">) | </span><span class="s5">0</span><span class="s0">;</span>

          <span class="s1">if </span><span class="s0">(</span><span class="s2">k </span><span class="s0">&gt; </span><span class="s5">1</span><span class="s0">) {</span>
            <span class="s2">yd </span><span class="s0">= </span><span class="s2">multiplyInteger</span><span class="s0">(</span><span class="s2">yd</span><span class="s0">, </span><span class="s2">k</span><span class="s0">, </span><span class="s2">base</span><span class="s0">);</span>
            <span class="s2">xd </span><span class="s0">= </span><span class="s2">multiplyInteger</span><span class="s0">(</span><span class="s2">xd</span><span class="s0">, </span><span class="s2">k</span><span class="s0">, </span><span class="s2">base</span><span class="s0">);</span>
            <span class="s2">yL </span><span class="s0">= </span><span class="s2">yd</span><span class="s0">.</span><span class="s2">length</span><span class="s0">;</span>
            <span class="s2">xL </span><span class="s0">= </span><span class="s2">xd</span><span class="s0">.</span><span class="s2">length</span><span class="s0">;</span>
          <span class="s0">}</span>

          <span class="s2">xi </span><span class="s0">= </span><span class="s2">yL</span><span class="s0">;</span>
          <span class="s2">rem </span><span class="s0">= </span><span class="s2">xd</span><span class="s0">.</span><span class="s2">slice</span><span class="s0">(</span><span class="s5">0</span><span class="s0">, </span><span class="s2">yL</span><span class="s0">);</span>
          <span class="s2">remL </span><span class="s0">= </span><span class="s2">rem</span><span class="s0">.</span><span class="s2">length</span><span class="s0">;</span>

          <span class="s4">// Add zeros to make remainder as long as divisor.</span>
          <span class="s1">for </span><span class="s0">(; </span><span class="s2">remL </span><span class="s0">&lt; </span><span class="s2">yL</span><span class="s0">;) </span><span class="s2">rem</span><span class="s0">[</span><span class="s2">remL</span><span class="s0">++] = </span><span class="s5">0</span><span class="s0">;</span>

          <span class="s2">yz </span><span class="s0">= </span><span class="s2">yd</span><span class="s0">.</span><span class="s2">slice</span><span class="s0">();</span>
          <span class="s2">yz</span><span class="s0">.</span><span class="s2">unshift</span><span class="s0">(</span><span class="s5">0</span><span class="s0">);</span>
          <span class="s2">yd0 </span><span class="s0">= </span><span class="s2">yd</span><span class="s0">[</span><span class="s5">0</span><span class="s0">];</span>

          <span class="s1">if </span><span class="s0">(</span><span class="s2">yd</span><span class="s0">[</span><span class="s5">1</span><span class="s0">] &gt;= </span><span class="s2">base </span><span class="s0">/ </span><span class="s5">2</span><span class="s0">) ++</span><span class="s2">yd0</span><span class="s0">;</span>

          <span class="s1">do </span><span class="s0">{</span>
            <span class="s2">k </span><span class="s0">= </span><span class="s5">0</span><span class="s0">;</span>

            <span class="s4">// Compare divisor and remainder.</span>
            <span class="s2">cmp </span><span class="s0">= </span><span class="s2">compare</span><span class="s0">(</span><span class="s2">yd</span><span class="s0">, </span><span class="s2">rem</span><span class="s0">, </span><span class="s2">yL</span><span class="s0">, </span><span class="s2">remL</span><span class="s0">);</span>

            <span class="s4">// If divisor &lt; remainder.</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s2">cmp </span><span class="s0">&lt; </span><span class="s5">0</span><span class="s0">) {</span>

              <span class="s4">// Calculate trial digit, k.</span>
              <span class="s2">rem0 </span><span class="s0">= </span><span class="s2">rem</span><span class="s0">[</span><span class="s5">0</span><span class="s0">];</span>
              <span class="s1">if </span><span class="s0">(</span><span class="s2">yL </span><span class="s0">!= </span><span class="s2">remL</span><span class="s0">) </span><span class="s2">rem0 </span><span class="s0">= </span><span class="s2">rem0 </span><span class="s0">* </span><span class="s2">base </span><span class="s0">+ (</span><span class="s2">rem</span><span class="s0">[</span><span class="s5">1</span><span class="s0">] || </span><span class="s5">0</span><span class="s0">);</span>

              <span class="s4">// k will be how many times the divisor goes into the current remainder.</span>
              <span class="s2">k </span><span class="s0">= </span><span class="s2">rem0 </span><span class="s0">/ </span><span class="s2">yd0 </span><span class="s0">| </span><span class="s5">0</span><span class="s0">;</span>

              <span class="s4">//  Algorithm:</span>
              <span class="s4">//  1. product = divisor * trial digit (k)</span>
              <span class="s4">//  2. if product &gt; remainder: product -= divisor, k--</span>
              <span class="s4">//  3. remainder -= product</span>
              <span class="s4">//  4. if product was &lt; remainder at 2:</span>
              <span class="s4">//    5. compare new remainder and divisor</span>
              <span class="s4">//    6. If remainder &gt; divisor: remainder -= divisor, k++</span>

              <span class="s1">if </span><span class="s0">(</span><span class="s2">k </span><span class="s0">&gt; </span><span class="s5">1</span><span class="s0">) {</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s2">k </span><span class="s0">&gt;= </span><span class="s2">base</span><span class="s0">) </span><span class="s2">k </span><span class="s0">= </span><span class="s2">base </span><span class="s0">- </span><span class="s5">1</span><span class="s0">;</span>

                <span class="s4">// product = divisor * trial digit.</span>
                <span class="s2">prod </span><span class="s0">= </span><span class="s2">multiplyInteger</span><span class="s0">(</span><span class="s2">yd</span><span class="s0">, </span><span class="s2">k</span><span class="s0">, </span><span class="s2">base</span><span class="s0">);</span>
                <span class="s2">prodL </span><span class="s0">= </span><span class="s2">prod</span><span class="s0">.</span><span class="s2">length</span><span class="s0">;</span>
                <span class="s2">remL </span><span class="s0">= </span><span class="s2">rem</span><span class="s0">.</span><span class="s2">length</span><span class="s0">;</span>

                <span class="s4">// Compare product and remainder.</span>
                <span class="s2">cmp </span><span class="s0">= </span><span class="s2">compare</span><span class="s0">(</span><span class="s2">prod</span><span class="s0">, </span><span class="s2">rem</span><span class="s0">, </span><span class="s2">prodL</span><span class="s0">, </span><span class="s2">remL</span><span class="s0">);</span>

                <span class="s4">// product &gt; remainder.</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s2">cmp </span><span class="s0">== </span><span class="s5">1</span><span class="s0">) {</span>
                  <span class="s2">k</span><span class="s0">--;</span>

                  <span class="s4">// Subtract divisor from product.</span>
                  <span class="s2">subtract</span><span class="s0">(</span><span class="s2">prod</span><span class="s0">, </span><span class="s2">yL </span><span class="s0">&lt; </span><span class="s2">prodL </span><span class="s0">? </span><span class="s2">yz </span><span class="s0">: </span><span class="s2">yd</span><span class="s0">, </span><span class="s2">prodL</span><span class="s0">, </span><span class="s2">base</span><span class="s0">);</span>
                <span class="s0">}</span>
              <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>

                <span class="s4">// cmp is -1.</span>
                <span class="s4">// If k is 0, there is no need to compare yd and rem again below, so change cmp to 1</span>
                <span class="s4">// to avoid it. If k is 1 there is a need to compare yd and rem again below.</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s2">k </span><span class="s0">== </span><span class="s5">0</span><span class="s0">) </span><span class="s2">cmp </span><span class="s0">= </span><span class="s2">k </span><span class="s0">= </span><span class="s5">1</span><span class="s0">;</span>
                <span class="s2">prod </span><span class="s0">= </span><span class="s2">yd</span><span class="s0">.</span><span class="s2">slice</span><span class="s0">();</span>
              <span class="s0">}</span>

              <span class="s2">prodL </span><span class="s0">= </span><span class="s2">prod</span><span class="s0">.</span><span class="s2">length</span><span class="s0">;</span>
              <span class="s1">if </span><span class="s0">(</span><span class="s2">prodL </span><span class="s0">&lt; </span><span class="s2">remL</span><span class="s0">) </span><span class="s2">prod</span><span class="s0">.</span><span class="s2">unshift</span><span class="s0">(</span><span class="s5">0</span><span class="s0">);</span>

              <span class="s4">// Subtract product from remainder.</span>
              <span class="s2">subtract</span><span class="s0">(</span><span class="s2">rem</span><span class="s0">, </span><span class="s2">prod</span><span class="s0">, </span><span class="s2">remL</span><span class="s0">, </span><span class="s2">base</span><span class="s0">);</span>

              <span class="s4">// If product was &lt; previous remainder.</span>
              <span class="s1">if </span><span class="s0">(</span><span class="s2">cmp </span><span class="s0">== -</span><span class="s5">1</span><span class="s0">) {</span>
                <span class="s2">remL </span><span class="s0">= </span><span class="s2">rem</span><span class="s0">.</span><span class="s2">length</span><span class="s0">;</span>

                <span class="s4">// Compare divisor and new remainder.</span>
                <span class="s2">cmp </span><span class="s0">= </span><span class="s2">compare</span><span class="s0">(</span><span class="s2">yd</span><span class="s0">, </span><span class="s2">rem</span><span class="s0">, </span><span class="s2">yL</span><span class="s0">, </span><span class="s2">remL</span><span class="s0">);</span>

                <span class="s4">// If divisor &lt; new remainder, subtract divisor from remainder.</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s2">cmp </span><span class="s0">&lt; </span><span class="s5">1</span><span class="s0">) {</span>
                  <span class="s2">k</span><span class="s0">++;</span>

                  <span class="s4">// Subtract divisor from remainder.</span>
                  <span class="s2">subtract</span><span class="s0">(</span><span class="s2">rem</span><span class="s0">, </span><span class="s2">yL </span><span class="s0">&lt; </span><span class="s2">remL </span><span class="s0">? </span><span class="s2">yz </span><span class="s0">: </span><span class="s2">yd</span><span class="s0">, </span><span class="s2">remL</span><span class="s0">, </span><span class="s2">base</span><span class="s0">);</span>
                <span class="s0">}</span>
              <span class="s0">}</span>

              <span class="s2">remL </span><span class="s0">= </span><span class="s2">rem</span><span class="s0">.</span><span class="s2">length</span><span class="s0">;</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(</span><span class="s2">cmp </span><span class="s0">=== </span><span class="s5">0</span><span class="s0">) {</span>
              <span class="s2">k</span><span class="s0">++;</span>
              <span class="s2">rem </span><span class="s0">= [</span><span class="s5">0</span><span class="s0">];</span>
            <span class="s0">}    </span><span class="s4">// if cmp === 1, k will be 0</span>

            <span class="s4">// Add the next digit, k, to the result array.</span>
            <span class="s2">qd</span><span class="s0">[</span><span class="s2">i</span><span class="s0">++] = </span><span class="s2">k</span><span class="s0">;</span>

            <span class="s4">// Update the remainder.</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s2">cmp </span><span class="s0">&amp;&amp; </span><span class="s2">rem</span><span class="s0">[</span><span class="s5">0</span><span class="s0">]) {</span>
              <span class="s2">rem</span><span class="s0">[</span><span class="s2">remL</span><span class="s0">++] = </span><span class="s2">xd</span><span class="s0">[</span><span class="s2">xi</span><span class="s0">] || </span><span class="s5">0</span><span class="s0">;</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
              <span class="s2">rem </span><span class="s0">= [</span><span class="s2">xd</span><span class="s0">[</span><span class="s2">xi</span><span class="s0">]];</span>
              <span class="s2">remL </span><span class="s0">= </span><span class="s5">1</span><span class="s0">;</span>
            <span class="s0">}</span>

          <span class="s0">} </span><span class="s1">while </span><span class="s0">((</span><span class="s2">xi</span><span class="s0">++ &lt; </span><span class="s2">xL </span><span class="s0">|| </span><span class="s2">rem</span><span class="s0">[</span><span class="s5">0</span><span class="s0">] !== </span><span class="s1">void </span><span class="s5">0</span><span class="s0">) &amp;&amp; </span><span class="s2">sd</span><span class="s0">--);</span>

          <span class="s2">more </span><span class="s0">= </span><span class="s2">rem</span><span class="s0">[</span><span class="s5">0</span><span class="s0">] !== </span><span class="s1">void </span><span class="s5">0</span><span class="s0">;</span>
        <span class="s0">}</span>

        <span class="s4">// Leading zero?</span>
        <span class="s1">if </span><span class="s0">(!</span><span class="s2">qd</span><span class="s0">[</span><span class="s5">0</span><span class="s0">]) </span><span class="s2">qd</span><span class="s0">.</span><span class="s2">shift</span><span class="s0">();</span>
      <span class="s0">}</span>

      <span class="s4">// logBase is 1 when divide is being used for base conversion.</span>
      <span class="s1">if </span><span class="s0">(</span><span class="s2">logBase </span><span class="s0">== </span><span class="s5">1</span><span class="s0">) {</span>
        <span class="s2">q</span><span class="s0">.</span><span class="s2">e </span><span class="s0">= </span><span class="s2">e</span><span class="s0">;</span>
        <span class="s2">inexact </span><span class="s0">= </span><span class="s2">more</span><span class="s0">;</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>

        <span class="s4">// To calculate q.e, first get the number of digits of qd[0].</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s2">i </span><span class="s0">= </span><span class="s5">1</span><span class="s0">, </span><span class="s2">k </span><span class="s0">= </span><span class="s2">qd</span><span class="s0">[</span><span class="s5">0</span><span class="s0">]; </span><span class="s2">k </span><span class="s0">&gt;= </span><span class="s5">10</span><span class="s0">; </span><span class="s2">k </span><span class="s0">/= </span><span class="s5">10</span><span class="s0">) </span><span class="s2">i</span><span class="s0">++;</span>
        <span class="s2">q</span><span class="s0">.</span><span class="s2">e </span><span class="s0">= </span><span class="s2">i </span><span class="s0">+ </span><span class="s2">e </span><span class="s0">* </span><span class="s2">logBase </span><span class="s0">- </span><span class="s5">1</span><span class="s0">;</span>

        <span class="s2">finalise</span><span class="s0">(</span><span class="s2">q</span><span class="s0">, </span><span class="s2">dp </span><span class="s0">? </span><span class="s2">pr </span><span class="s0">+ </span><span class="s2">q</span><span class="s0">.</span><span class="s2">e </span><span class="s0">+ </span><span class="s5">1 </span><span class="s0">: </span><span class="s2">pr</span><span class="s0">, </span><span class="s2">rm</span><span class="s0">, </span><span class="s2">more</span><span class="s0">);</span>
      <span class="s0">}</span>

      <span class="s1">return </span><span class="s2">q</span><span class="s0">;</span>
    <span class="s0">};</span>
  <span class="s0">})();</span>


  <span class="s4">/* 
   * Round `x` to `sd` significant digits using rounding mode `rm`. 
   * Check for over/under-flow. 
   */</span>
   <span class="s1">function </span><span class="s2">finalise</span><span class="s0">(</span><span class="s2">x</span><span class="s0">, </span><span class="s2">sd</span><span class="s0">, </span><span class="s2">rm</span><span class="s0">, </span><span class="s2">isTruncated</span><span class="s0">) {</span>
    <span class="s1">var </span><span class="s2">digits</span><span class="s0">, </span><span class="s2">i</span><span class="s0">, </span><span class="s2">j</span><span class="s0">, </span><span class="s2">k</span><span class="s0">, </span><span class="s2">rd</span><span class="s0">, </span><span class="s2">roundUp</span><span class="s0">, </span><span class="s2">w</span><span class="s0">, </span><span class="s2">xd</span><span class="s0">, </span><span class="s2">xdi</span><span class="s0">,</span>
      <span class="s2">Ctor </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">constructor</span><span class="s0">;</span>

    <span class="s4">// Don't round if sd is null or undefined.</span>
    <span class="s2">out</span><span class="s0">: </span><span class="s1">if </span><span class="s0">(</span><span class="s2">sd </span><span class="s0">!= </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s2">xd </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">d</span><span class="s0">;</span>

      <span class="s4">// Infinity/NaN.</span>
      <span class="s1">if </span><span class="s0">(!</span><span class="s2">xd</span><span class="s0">) </span><span class="s1">return </span><span class="s2">x</span><span class="s0">;</span>

      <span class="s4">// rd: the rounding digit, i.e. the digit after the digit that may be rounded up.</span>
      <span class="s4">// w: the word of xd containing rd, a base 1e7 number.</span>
      <span class="s4">// xdi: the index of w within xd.</span>
      <span class="s4">// digits: the number of digits of w.</span>
      <span class="s4">// i: what would be the index of rd within w if all the numbers were 7 digits long (i.e. if</span>
      <span class="s4">// they had leading zeros)</span>
      <span class="s4">// j: if &gt; 0, the actual index of rd within w (if &lt; 0, rd is a leading zero).</span>

      <span class="s4">// Get the length of the first word of the digits array xd.</span>
      <span class="s1">for </span><span class="s0">(</span><span class="s2">digits </span><span class="s0">= </span><span class="s5">1</span><span class="s0">, </span><span class="s2">k </span><span class="s0">= </span><span class="s2">xd</span><span class="s0">[</span><span class="s5">0</span><span class="s0">]; </span><span class="s2">k </span><span class="s0">&gt;= </span><span class="s5">10</span><span class="s0">; </span><span class="s2">k </span><span class="s0">/= </span><span class="s5">10</span><span class="s0">) </span><span class="s2">digits</span><span class="s0">++;</span>
      <span class="s2">i </span><span class="s0">= </span><span class="s2">sd </span><span class="s0">- </span><span class="s2">digits</span><span class="s0">;</span>

      <span class="s4">// Is the rounding digit in the first word of xd?</span>
      <span class="s1">if </span><span class="s0">(</span><span class="s2">i </span><span class="s0">&lt; </span><span class="s5">0</span><span class="s0">) {</span>
        <span class="s2">i </span><span class="s0">+= </span><span class="s2">LOG_BASE</span><span class="s0">;</span>
        <span class="s2">j </span><span class="s0">= </span><span class="s2">sd</span><span class="s0">;</span>
        <span class="s2">w </span><span class="s0">= </span><span class="s2">xd</span><span class="s0">[</span><span class="s2">xdi </span><span class="s0">= </span><span class="s5">0</span><span class="s0">];</span>

        <span class="s4">// Get the rounding digit at index j of w.</span>
        <span class="s2">rd </span><span class="s0">= </span><span class="s2">w </span><span class="s0">/ </span><span class="s2">mathpow</span><span class="s0">(</span><span class="s5">10</span><span class="s0">, </span><span class="s2">digits </span><span class="s0">- </span><span class="s2">j </span><span class="s0">- </span><span class="s5">1</span><span class="s0">) % </span><span class="s5">10 </span><span class="s0">| </span><span class="s5">0</span><span class="s0">;</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s2">xdi </span><span class="s0">= </span><span class="s2">Math</span><span class="s0">.</span><span class="s2">ceil</span><span class="s0">((</span><span class="s2">i </span><span class="s0">+ </span><span class="s5">1</span><span class="s0">) / </span><span class="s2">LOG_BASE</span><span class="s0">);</span>
        <span class="s2">k </span><span class="s0">= </span><span class="s2">xd</span><span class="s0">.</span><span class="s2">length</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s2">xdi </span><span class="s0">&gt;= </span><span class="s2">k</span><span class="s0">) {</span>
          <span class="s1">if </span><span class="s0">(</span><span class="s2">isTruncated</span><span class="s0">) {</span>

            <span class="s4">// Needed by `naturalExponential`, `naturalLogarithm` and `squareRoot`.</span>
            <span class="s1">for </span><span class="s0">(; </span><span class="s2">k</span><span class="s0">++ &lt;= </span><span class="s2">xdi</span><span class="s0">;) </span><span class="s2">xd</span><span class="s0">.</span><span class="s2">push</span><span class="s0">(</span><span class="s5">0</span><span class="s0">);</span>
            <span class="s2">w </span><span class="s0">= </span><span class="s2">rd </span><span class="s0">= </span><span class="s5">0</span><span class="s0">;</span>
            <span class="s2">digits </span><span class="s0">= </span><span class="s5">1</span><span class="s0">;</span>
            <span class="s2">i </span><span class="s0">%= </span><span class="s2">LOG_BASE</span><span class="s0">;</span>
            <span class="s2">j </span><span class="s0">= </span><span class="s2">i </span><span class="s0">- </span><span class="s2">LOG_BASE </span><span class="s0">+ </span><span class="s5">1</span><span class="s0">;</span>
          <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s1">break </span><span class="s2">out</span><span class="s0">;</span>
          <span class="s0">}</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
          <span class="s2">w </span><span class="s0">= </span><span class="s2">k </span><span class="s0">= </span><span class="s2">xd</span><span class="s0">[</span><span class="s2">xdi</span><span class="s0">];</span>

          <span class="s4">// Get the number of digits of w.</span>
          <span class="s1">for </span><span class="s0">(</span><span class="s2">digits </span><span class="s0">= </span><span class="s5">1</span><span class="s0">; </span><span class="s2">k </span><span class="s0">&gt;= </span><span class="s5">10</span><span class="s0">; </span><span class="s2">k </span><span class="s0">/= </span><span class="s5">10</span><span class="s0">) </span><span class="s2">digits</span><span class="s0">++;</span>

          <span class="s4">// Get the index of rd within w.</span>
          <span class="s2">i </span><span class="s0">%= </span><span class="s2">LOG_BASE</span><span class="s0">;</span>

          <span class="s4">// Get the index of rd within w, adjusted for leading zeros.</span>
          <span class="s4">// The number of leading zeros of w is given by LOG_BASE - digits.</span>
          <span class="s2">j </span><span class="s0">= </span><span class="s2">i </span><span class="s0">- </span><span class="s2">LOG_BASE </span><span class="s0">+ </span><span class="s2">digits</span><span class="s0">;</span>

          <span class="s4">// Get the rounding digit at index j of w.</span>
          <span class="s2">rd </span><span class="s0">= </span><span class="s2">j </span><span class="s0">&lt; </span><span class="s5">0 </span><span class="s0">? </span><span class="s5">0 </span><span class="s0">: </span><span class="s2">w </span><span class="s0">/ </span><span class="s2">mathpow</span><span class="s0">(</span><span class="s5">10</span><span class="s0">, </span><span class="s2">digits </span><span class="s0">- </span><span class="s2">j </span><span class="s0">- </span><span class="s5">1</span><span class="s0">) % </span><span class="s5">10 </span><span class="s0">| </span><span class="s5">0</span><span class="s0">;</span>
        <span class="s0">}</span>
      <span class="s0">}</span>

      <span class="s4">// Are there any non-zero digits after the rounding digit?</span>
      <span class="s2">isTruncated </span><span class="s0">= </span><span class="s2">isTruncated </span><span class="s0">|| </span><span class="s2">sd </span><span class="s0">&lt; </span><span class="s5">0 </span><span class="s0">||</span>
        <span class="s2">xd</span><span class="s0">[</span><span class="s2">xdi </span><span class="s0">+ </span><span class="s5">1</span><span class="s0">] !== </span><span class="s1">void </span><span class="s5">0 </span><span class="s0">|| (</span><span class="s2">j </span><span class="s0">&lt; </span><span class="s5">0 </span><span class="s0">? </span><span class="s2">w </span><span class="s0">: </span><span class="s2">w </span><span class="s0">% </span><span class="s2">mathpow</span><span class="s0">(</span><span class="s5">10</span><span class="s0">, </span><span class="s2">digits </span><span class="s0">- </span><span class="s2">j </span><span class="s0">- </span><span class="s5">1</span><span class="s0">));</span>

      <span class="s4">// The expression `w % mathpow(10, digits - j - 1)` returns all the digits of w to the right</span>
      <span class="s4">// of the digit at (left-to-right) index j, e.g. if w is 908714 and j is 2, the expression</span>
      <span class="s4">// will give 714.</span>

      <span class="s2">roundUp </span><span class="s0">= </span><span class="s2">rm </span><span class="s0">&lt; </span><span class="s5">4</span>
        <span class="s0">? (</span><span class="s2">rd </span><span class="s0">|| </span><span class="s2">isTruncated</span><span class="s0">) &amp;&amp; (</span><span class="s2">rm </span><span class="s0">== </span><span class="s5">0 </span><span class="s0">|| </span><span class="s2">rm </span><span class="s0">== (</span><span class="s2">x</span><span class="s0">.</span><span class="s2">s </span><span class="s0">&lt; </span><span class="s5">0 </span><span class="s0">? </span><span class="s5">3 </span><span class="s0">: </span><span class="s5">2</span><span class="s0">))</span>
        <span class="s0">: </span><span class="s2">rd </span><span class="s0">&gt; </span><span class="s5">5 </span><span class="s0">|| </span><span class="s2">rd </span><span class="s0">== </span><span class="s5">5 </span><span class="s0">&amp;&amp; (</span><span class="s2">rm </span><span class="s0">== </span><span class="s5">4 </span><span class="s0">|| </span><span class="s2">isTruncated </span><span class="s0">|| </span><span class="s2">rm </span><span class="s0">== </span><span class="s5">6 </span><span class="s0">&amp;&amp;</span>

          <span class="s4">// Check whether the digit to the left of the rounding digit is odd.</span>
          <span class="s0">((</span><span class="s2">i </span><span class="s0">&gt; </span><span class="s5">0 </span><span class="s0">? </span><span class="s2">j </span><span class="s0">&gt; </span><span class="s5">0 </span><span class="s0">? </span><span class="s2">w </span><span class="s0">/ </span><span class="s2">mathpow</span><span class="s0">(</span><span class="s5">10</span><span class="s0">, </span><span class="s2">digits </span><span class="s0">- </span><span class="s2">j</span><span class="s0">) : </span><span class="s5">0 </span><span class="s0">: </span><span class="s2">xd</span><span class="s0">[</span><span class="s2">xdi </span><span class="s0">- </span><span class="s5">1</span><span class="s0">]) % </span><span class="s5">10</span><span class="s0">) &amp; </span><span class="s5">1 </span><span class="s0">||</span>
            <span class="s2">rm </span><span class="s0">== (</span><span class="s2">x</span><span class="s0">.</span><span class="s2">s </span><span class="s0">&lt; </span><span class="s5">0 </span><span class="s0">? </span><span class="s5">8 </span><span class="s0">: </span><span class="s5">7</span><span class="s0">));</span>

      <span class="s1">if </span><span class="s0">(</span><span class="s2">sd </span><span class="s0">&lt; </span><span class="s5">1 </span><span class="s0">|| !</span><span class="s2">xd</span><span class="s0">[</span><span class="s5">0</span><span class="s0">]) {</span>
        <span class="s2">xd</span><span class="s0">.</span><span class="s2">length </span><span class="s0">= </span><span class="s5">0</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s2">roundUp</span><span class="s0">) {</span>

          <span class="s4">// Convert sd to decimal places.</span>
          <span class="s2">sd </span><span class="s0">-= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">e </span><span class="s0">+ </span><span class="s5">1</span><span class="s0">;</span>

          <span class="s4">// 1, 0.1, 0.01, 0.001, 0.0001 etc.</span>
          <span class="s2">xd</span><span class="s0">[</span><span class="s5">0</span><span class="s0">] = </span><span class="s2">mathpow</span><span class="s0">(</span><span class="s5">10</span><span class="s0">, (</span><span class="s2">LOG_BASE </span><span class="s0">- </span><span class="s2">sd </span><span class="s0">% </span><span class="s2">LOG_BASE</span><span class="s0">) % </span><span class="s2">LOG_BASE</span><span class="s0">);</span>
          <span class="s2">x</span><span class="s0">.</span><span class="s2">e </span><span class="s0">= -</span><span class="s2">sd </span><span class="s0">|| </span><span class="s5">0</span><span class="s0">;</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>

          <span class="s4">// Zero.</span>
          <span class="s2">xd</span><span class="s0">[</span><span class="s5">0</span><span class="s0">] = </span><span class="s2">x</span><span class="s0">.</span><span class="s2">e </span><span class="s0">= </span><span class="s5">0</span><span class="s0">;</span>
        <span class="s0">}</span>

        <span class="s1">return </span><span class="s2">x</span><span class="s0">;</span>
      <span class="s0">}</span>

      <span class="s4">// Remove excess digits.</span>
      <span class="s1">if </span><span class="s0">(</span><span class="s2">i </span><span class="s0">== </span><span class="s5">0</span><span class="s0">) {</span>
        <span class="s2">xd</span><span class="s0">.</span><span class="s2">length </span><span class="s0">= </span><span class="s2">xdi</span><span class="s0">;</span>
        <span class="s2">k </span><span class="s0">= </span><span class="s5">1</span><span class="s0">;</span>
        <span class="s2">xdi</span><span class="s0">--;</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s2">xd</span><span class="s0">.</span><span class="s2">length </span><span class="s0">= </span><span class="s2">xdi </span><span class="s0">+ </span><span class="s5">1</span><span class="s0">;</span>
        <span class="s2">k </span><span class="s0">= </span><span class="s2">mathpow</span><span class="s0">(</span><span class="s5">10</span><span class="s0">, </span><span class="s2">LOG_BASE </span><span class="s0">- </span><span class="s2">i</span><span class="s0">);</span>

        <span class="s4">// E.g. 56700 becomes 56000 if 7 is the rounding digit.</span>
        <span class="s4">// j &gt; 0 means i &gt; number of leading zeros of w.</span>
        <span class="s2">xd</span><span class="s0">[</span><span class="s2">xdi</span><span class="s0">] = </span><span class="s2">j </span><span class="s0">&gt; </span><span class="s5">0 </span><span class="s0">? (</span><span class="s2">w </span><span class="s0">/ </span><span class="s2">mathpow</span><span class="s0">(</span><span class="s5">10</span><span class="s0">, </span><span class="s2">digits </span><span class="s0">- </span><span class="s2">j</span><span class="s0">) % </span><span class="s2">mathpow</span><span class="s0">(</span><span class="s5">10</span><span class="s0">, </span><span class="s2">j</span><span class="s0">) | </span><span class="s5">0</span><span class="s0">) * </span><span class="s2">k </span><span class="s0">: </span><span class="s5">0</span><span class="s0">;</span>
      <span class="s0">}</span>

      <span class="s1">if </span><span class="s0">(</span><span class="s2">roundUp</span><span class="s0">) {</span>
        <span class="s1">for </span><span class="s0">(;;) {</span>

          <span class="s4">// Is the digit to be rounded up in the first word of xd?</span>
          <span class="s1">if </span><span class="s0">(</span><span class="s2">xdi </span><span class="s0">== </span><span class="s5">0</span><span class="s0">) {</span>

            <span class="s4">// i will be the length of xd[0] before k is added.</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s2">i </span><span class="s0">= </span><span class="s5">1</span><span class="s0">, </span><span class="s2">j </span><span class="s0">= </span><span class="s2">xd</span><span class="s0">[</span><span class="s5">0</span><span class="s0">]; </span><span class="s2">j </span><span class="s0">&gt;= </span><span class="s5">10</span><span class="s0">; </span><span class="s2">j </span><span class="s0">/= </span><span class="s5">10</span><span class="s0">) </span><span class="s2">i</span><span class="s0">++;</span>
            <span class="s2">j </span><span class="s0">= </span><span class="s2">xd</span><span class="s0">[</span><span class="s5">0</span><span class="s0">] += </span><span class="s2">k</span><span class="s0">;</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s2">k </span><span class="s0">= </span><span class="s5">1</span><span class="s0">; </span><span class="s2">j </span><span class="s0">&gt;= </span><span class="s5">10</span><span class="s0">; </span><span class="s2">j </span><span class="s0">/= </span><span class="s5">10</span><span class="s0">) </span><span class="s2">k</span><span class="s0">++;</span>

            <span class="s4">// if i != k the length has increased.</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s2">i </span><span class="s0">!= </span><span class="s2">k</span><span class="s0">) {</span>
              <span class="s2">x</span><span class="s0">.</span><span class="s2">e</span><span class="s0">++;</span>
              <span class="s1">if </span><span class="s0">(</span><span class="s2">xd</span><span class="s0">[</span><span class="s5">0</span><span class="s0">] == </span><span class="s2">BASE</span><span class="s0">) </span><span class="s2">xd</span><span class="s0">[</span><span class="s5">0</span><span class="s0">] = </span><span class="s5">1</span><span class="s0">;</span>
            <span class="s0">}</span>

            <span class="s1">break</span><span class="s0">;</span>
          <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s2">xd</span><span class="s0">[</span><span class="s2">xdi</span><span class="s0">] += </span><span class="s2">k</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s2">xd</span><span class="s0">[</span><span class="s2">xdi</span><span class="s0">] != </span><span class="s2">BASE</span><span class="s0">) </span><span class="s1">break</span><span class="s0">;</span>
            <span class="s2">xd</span><span class="s0">[</span><span class="s2">xdi</span><span class="s0">--] = </span><span class="s5">0</span><span class="s0">;</span>
            <span class="s2">k </span><span class="s0">= </span><span class="s5">1</span><span class="s0">;</span>
          <span class="s0">}</span>
        <span class="s0">}</span>
      <span class="s0">}</span>

      <span class="s4">// Remove trailing zeros.</span>
      <span class="s1">for </span><span class="s0">(</span><span class="s2">i </span><span class="s0">= </span><span class="s2">xd</span><span class="s0">.</span><span class="s2">length</span><span class="s0">; </span><span class="s2">xd</span><span class="s0">[--</span><span class="s2">i</span><span class="s0">] === </span><span class="s5">0</span><span class="s0">;) </span><span class="s2">xd</span><span class="s0">.</span><span class="s2">pop</span><span class="s0">();</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(</span><span class="s2">external</span><span class="s0">) {</span>

      <span class="s4">// Overflow?</span>
      <span class="s1">if </span><span class="s0">(</span><span class="s2">x</span><span class="s0">.</span><span class="s2">e </span><span class="s0">&gt; </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">maxE</span><span class="s0">) {</span>

        <span class="s4">// Infinity.</span>
        <span class="s2">x</span><span class="s0">.</span><span class="s2">d </span><span class="s0">= </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s2">x</span><span class="s0">.</span><span class="s2">e </span><span class="s0">= </span><span class="s2">NaN</span><span class="s0">;</span>

      <span class="s4">// Underflow?</span>
      <span class="s0">} </span><span class="s1">else if </span><span class="s0">(</span><span class="s2">x</span><span class="s0">.</span><span class="s2">e </span><span class="s0">&lt; </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">minE</span><span class="s0">) {</span>

        <span class="s4">// Zero.</span>
        <span class="s2">x</span><span class="s0">.</span><span class="s2">e </span><span class="s0">= </span><span class="s5">0</span><span class="s0">;</span>
        <span class="s2">x</span><span class="s0">.</span><span class="s2">d </span><span class="s0">= [</span><span class="s5">0</span><span class="s0">];</span>
        <span class="s4">// Ctor.underflow = true;</span>
      <span class="s0">} </span><span class="s4">// else Ctor.underflow = false;</span>
    <span class="s0">}</span>

    <span class="s1">return </span><span class="s2">x</span><span class="s0">;</span>
  <span class="s0">}</span>


  <span class="s1">function </span><span class="s2">finiteToString</span><span class="s0">(</span><span class="s2">x</span><span class="s0">, </span><span class="s2">isExp</span><span class="s0">, </span><span class="s2">sd</span><span class="s0">) {</span>
    <span class="s1">if </span><span class="s0">(!</span><span class="s2">x</span><span class="s0">.</span><span class="s2">isFinite</span><span class="s0">()) </span><span class="s1">return </span><span class="s2">nonFiniteToString</span><span class="s0">(</span><span class="s2">x</span><span class="s0">);</span>
    <span class="s1">var </span><span class="s2">k</span><span class="s0">,</span>
      <span class="s2">e </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">e</span><span class="s0">,</span>
      <span class="s2">str </span><span class="s0">= </span><span class="s2">digitsToString</span><span class="s0">(</span><span class="s2">x</span><span class="s0">.</span><span class="s2">d</span><span class="s0">),</span>
      <span class="s2">len </span><span class="s0">= </span><span class="s2">str</span><span class="s0">.</span><span class="s2">length</span><span class="s0">;</span>

    <span class="s1">if </span><span class="s0">(</span><span class="s2">isExp</span><span class="s0">) {</span>
      <span class="s1">if </span><span class="s0">(</span><span class="s2">sd </span><span class="s0">&amp;&amp; (</span><span class="s2">k </span><span class="s0">= </span><span class="s2">sd </span><span class="s0">- </span><span class="s2">len</span><span class="s0">) &gt; </span><span class="s5">0</span><span class="s0">) {</span>
        <span class="s2">str </span><span class="s0">= </span><span class="s2">str</span><span class="s0">.</span><span class="s2">charAt</span><span class="s0">(</span><span class="s5">0</span><span class="s0">) + </span><span class="s3">'.' </span><span class="s0">+ </span><span class="s2">str</span><span class="s0">.</span><span class="s2">slice</span><span class="s0">(</span><span class="s5">1</span><span class="s0">) + </span><span class="s2">getZeroString</span><span class="s0">(</span><span class="s2">k</span><span class="s0">);</span>
      <span class="s0">} </span><span class="s1">else if </span><span class="s0">(</span><span class="s2">len </span><span class="s0">&gt; </span><span class="s5">1</span><span class="s0">) {</span>
        <span class="s2">str </span><span class="s0">= </span><span class="s2">str</span><span class="s0">.</span><span class="s2">charAt</span><span class="s0">(</span><span class="s5">0</span><span class="s0">) + </span><span class="s3">'.' </span><span class="s0">+ </span><span class="s2">str</span><span class="s0">.</span><span class="s2">slice</span><span class="s0">(</span><span class="s5">1</span><span class="s0">);</span>
      <span class="s0">}</span>

      <span class="s2">str </span><span class="s0">= </span><span class="s2">str </span><span class="s0">+ (</span><span class="s2">x</span><span class="s0">.</span><span class="s2">e </span><span class="s0">&lt; </span><span class="s5">0 </span><span class="s0">? </span><span class="s3">'e' </span><span class="s0">: </span><span class="s3">'e+'</span><span class="s0">) + </span><span class="s2">x</span><span class="s0">.</span><span class="s2">e</span><span class="s0">;</span>
    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(</span><span class="s2">e </span><span class="s0">&lt; </span><span class="s5">0</span><span class="s0">) {</span>
      <span class="s2">str </span><span class="s0">= </span><span class="s3">'0.' </span><span class="s0">+ </span><span class="s2">getZeroString</span><span class="s0">(-</span><span class="s2">e </span><span class="s0">- </span><span class="s5">1</span><span class="s0">) + </span><span class="s2">str</span><span class="s0">;</span>
      <span class="s1">if </span><span class="s0">(</span><span class="s2">sd </span><span class="s0">&amp;&amp; (</span><span class="s2">k </span><span class="s0">= </span><span class="s2">sd </span><span class="s0">- </span><span class="s2">len</span><span class="s0">) &gt; </span><span class="s5">0</span><span class="s0">) </span><span class="s2">str </span><span class="s0">+= </span><span class="s2">getZeroString</span><span class="s0">(</span><span class="s2">k</span><span class="s0">);</span>
    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(</span><span class="s2">e </span><span class="s0">&gt;= </span><span class="s2">len</span><span class="s0">) {</span>
      <span class="s2">str </span><span class="s0">+= </span><span class="s2">getZeroString</span><span class="s0">(</span><span class="s2">e </span><span class="s0">+ </span><span class="s5">1 </span><span class="s0">- </span><span class="s2">len</span><span class="s0">);</span>
      <span class="s1">if </span><span class="s0">(</span><span class="s2">sd </span><span class="s0">&amp;&amp; (</span><span class="s2">k </span><span class="s0">= </span><span class="s2">sd </span><span class="s0">- </span><span class="s2">e </span><span class="s0">- </span><span class="s5">1</span><span class="s0">) &gt; </span><span class="s5">0</span><span class="s0">) </span><span class="s2">str </span><span class="s0">= </span><span class="s2">str </span><span class="s0">+ </span><span class="s3">'.' </span><span class="s0">+ </span><span class="s2">getZeroString</span><span class="s0">(</span><span class="s2">k</span><span class="s0">);</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s1">if </span><span class="s0">((</span><span class="s2">k </span><span class="s0">= </span><span class="s2">e </span><span class="s0">+ </span><span class="s5">1</span><span class="s0">) &lt; </span><span class="s2">len</span><span class="s0">) </span><span class="s2">str </span><span class="s0">= </span><span class="s2">str</span><span class="s0">.</span><span class="s2">slice</span><span class="s0">(</span><span class="s5">0</span><span class="s0">, </span><span class="s2">k</span><span class="s0">) + </span><span class="s3">'.' </span><span class="s0">+ </span><span class="s2">str</span><span class="s0">.</span><span class="s2">slice</span><span class="s0">(</span><span class="s2">k</span><span class="s0">);</span>
      <span class="s1">if </span><span class="s0">(</span><span class="s2">sd </span><span class="s0">&amp;&amp; (</span><span class="s2">k </span><span class="s0">= </span><span class="s2">sd </span><span class="s0">- </span><span class="s2">len</span><span class="s0">) &gt; </span><span class="s5">0</span><span class="s0">) {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s2">e </span><span class="s0">+ </span><span class="s5">1 </span><span class="s0">=== </span><span class="s2">len</span><span class="s0">) </span><span class="s2">str </span><span class="s0">+= </span><span class="s3">'.'</span><span class="s0">;</span>
        <span class="s2">str </span><span class="s0">+= </span><span class="s2">getZeroString</span><span class="s0">(</span><span class="s2">k</span><span class="s0">);</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">return </span><span class="s2">str</span><span class="s0">;</span>
  <span class="s0">}</span>


  <span class="s4">// Calculate the base 10 exponent from the base 1e7 exponent.</span>
  <span class="s1">function </span><span class="s2">getBase10Exponent</span><span class="s0">(</span><span class="s2">digits</span><span class="s0">, </span><span class="s2">e</span><span class="s0">) {</span>
    <span class="s1">var </span><span class="s2">w </span><span class="s0">= </span><span class="s2">digits</span><span class="s0">[</span><span class="s5">0</span><span class="s0">];</span>

    <span class="s4">// Add the number of digits of the first word of the digits array.</span>
    <span class="s1">for </span><span class="s0">( </span><span class="s2">e </span><span class="s0">*= </span><span class="s2">LOG_BASE</span><span class="s0">; </span><span class="s2">w </span><span class="s0">&gt;= </span><span class="s5">10</span><span class="s0">; </span><span class="s2">w </span><span class="s0">/= </span><span class="s5">10</span><span class="s0">) </span><span class="s2">e</span><span class="s0">++;</span>
    <span class="s1">return </span><span class="s2">e</span><span class="s0">;</span>
  <span class="s0">}</span>


  <span class="s1">function </span><span class="s2">getLn10</span><span class="s0">(</span><span class="s2">Ctor</span><span class="s0">, </span><span class="s2">sd</span><span class="s0">, </span><span class="s2">pr</span><span class="s0">) {</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">sd </span><span class="s0">&gt; </span><span class="s2">LN10_PRECISION</span><span class="s0">) {</span>

      <span class="s4">// Reset global state in case the exception is caught.</span>
      <span class="s2">external </span><span class="s0">= </span><span class="s1">true</span><span class="s0">;</span>
      <span class="s1">if </span><span class="s0">(</span><span class="s2">pr</span><span class="s0">) </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">precision </span><span class="s0">= </span><span class="s2">pr</span><span class="s0">;</span>
      <span class="s1">throw </span><span class="s2">Error</span><span class="s0">(</span><span class="s2">precisionLimitExceeded</span><span class="s0">);</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s2">finalise</span><span class="s0">(</span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">LN10</span><span class="s0">), </span><span class="s2">sd</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>
  <span class="s0">}</span>


  <span class="s1">function </span><span class="s2">getPi</span><span class="s0">(</span><span class="s2">Ctor</span><span class="s0">, </span><span class="s2">sd</span><span class="s0">, </span><span class="s2">rm</span><span class="s0">) {</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">sd </span><span class="s0">&gt; </span><span class="s2">PI_PRECISION</span><span class="s0">) </span><span class="s1">throw </span><span class="s2">Error</span><span class="s0">(</span><span class="s2">precisionLimitExceeded</span><span class="s0">);</span>
    <span class="s1">return </span><span class="s2">finalise</span><span class="s0">(</span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">PI</span><span class="s0">), </span><span class="s2">sd</span><span class="s0">, </span><span class="s2">rm</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>
  <span class="s0">}</span>


  <span class="s1">function </span><span class="s2">getPrecision</span><span class="s0">(</span><span class="s2">digits</span><span class="s0">) {</span>
    <span class="s1">var </span><span class="s2">w </span><span class="s0">= </span><span class="s2">digits</span><span class="s0">.</span><span class="s2">length </span><span class="s0">- </span><span class="s5">1</span><span class="s0">,</span>
      <span class="s2">len </span><span class="s0">= </span><span class="s2">w </span><span class="s0">* </span><span class="s2">LOG_BASE </span><span class="s0">+ </span><span class="s5">1</span><span class="s0">;</span>

    <span class="s2">w </span><span class="s0">= </span><span class="s2">digits</span><span class="s0">[</span><span class="s2">w</span><span class="s0">];</span>

    <span class="s4">// If non-zero...</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">w</span><span class="s0">) {</span>

      <span class="s4">// Subtract the number of trailing zeros of the last word.</span>
      <span class="s1">for </span><span class="s0">(; </span><span class="s2">w </span><span class="s0">% </span><span class="s5">10 </span><span class="s0">== </span><span class="s5">0</span><span class="s0">; </span><span class="s2">w </span><span class="s0">/= </span><span class="s5">10</span><span class="s0">) </span><span class="s2">len</span><span class="s0">--;</span>

      <span class="s4">// Add the number of digits of the first word.</span>
      <span class="s1">for </span><span class="s0">(</span><span class="s2">w </span><span class="s0">= </span><span class="s2">digits</span><span class="s0">[</span><span class="s5">0</span><span class="s0">]; </span><span class="s2">w </span><span class="s0">&gt;= </span><span class="s5">10</span><span class="s0">; </span><span class="s2">w </span><span class="s0">/= </span><span class="s5">10</span><span class="s0">) </span><span class="s2">len</span><span class="s0">++;</span>
    <span class="s0">}</span>

    <span class="s1">return </span><span class="s2">len</span><span class="s0">;</span>
  <span class="s0">}</span>


  <span class="s1">function </span><span class="s2">getZeroString</span><span class="s0">(</span><span class="s2">k</span><span class="s0">) {</span>
    <span class="s1">var </span><span class="s2">zs </span><span class="s0">= </span><span class="s3">''</span><span class="s0">;</span>
    <span class="s1">for </span><span class="s0">(; </span><span class="s2">k</span><span class="s0">--;) </span><span class="s2">zs </span><span class="s0">+= </span><span class="s3">'0'</span><span class="s0">;</span>
    <span class="s1">return </span><span class="s2">zs</span><span class="s0">;</span>
  <span class="s0">}</span>


  <span class="s4">/* 
   * Return a new Decimal whose value is the value of Decimal `x` to the power `n`, where `n` is an 
   * integer of type number. 
   * 
   * Implements 'exponentiation by squaring'. Called by `pow` and `parseOther`. 
   * 
   */</span>
  <span class="s1">function </span><span class="s2">intPow</span><span class="s0">(</span><span class="s2">Ctor</span><span class="s0">, </span><span class="s2">x</span><span class="s0">, </span><span class="s2">n</span><span class="s0">, </span><span class="s2">pr</span><span class="s0">) {</span>
    <span class="s1">var </span><span class="s2">isTruncated</span><span class="s0">,</span>
      <span class="s2">r </span><span class="s0">= </span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s5">1</span><span class="s0">),</span>

      <span class="s4">// Max n of 9007199254740991 takes 53 loop iterations.</span>
      <span class="s4">// Maximum digits array length; leaves [28, 34] guard digits.</span>
      <span class="s2">k </span><span class="s0">= </span><span class="s2">Math</span><span class="s0">.</span><span class="s2">ceil</span><span class="s0">(</span><span class="s2">pr </span><span class="s0">/ </span><span class="s2">LOG_BASE </span><span class="s0">+ </span><span class="s5">4</span><span class="s0">);</span>

    <span class="s2">external </span><span class="s0">= </span><span class="s1">false</span><span class="s0">;</span>

    <span class="s1">for </span><span class="s0">(;;) {</span>
      <span class="s1">if </span><span class="s0">(</span><span class="s2">n </span><span class="s0">% </span><span class="s5">2</span><span class="s0">) {</span>
        <span class="s2">r </span><span class="s0">= </span><span class="s2">r</span><span class="s0">.</span><span class="s2">times</span><span class="s0">(</span><span class="s2">x</span><span class="s0">);</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s2">truncate</span><span class="s0">(</span><span class="s2">r</span><span class="s0">.</span><span class="s2">d</span><span class="s0">, </span><span class="s2">k</span><span class="s0">)) </span><span class="s2">isTruncated </span><span class="s0">= </span><span class="s1">true</span><span class="s0">;</span>
      <span class="s0">}</span>

      <span class="s2">n </span><span class="s0">= </span><span class="s2">mathfloor</span><span class="s0">(</span><span class="s2">n </span><span class="s0">/ </span><span class="s5">2</span><span class="s0">);</span>
      <span class="s1">if </span><span class="s0">(</span><span class="s2">n </span><span class="s0">=== </span><span class="s5">0</span><span class="s0">) {</span>

        <span class="s4">// To ensure correct rounding when r.d is truncated, increment the last word if it is zero.</span>
        <span class="s2">n </span><span class="s0">= </span><span class="s2">r</span><span class="s0">.</span><span class="s2">d</span><span class="s0">.</span><span class="s2">length </span><span class="s0">- </span><span class="s5">1</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s2">isTruncated </span><span class="s0">&amp;&amp; </span><span class="s2">r</span><span class="s0">.</span><span class="s2">d</span><span class="s0">[</span><span class="s2">n</span><span class="s0">] === </span><span class="s5">0</span><span class="s0">) ++</span><span class="s2">r</span><span class="s0">.</span><span class="s2">d</span><span class="s0">[</span><span class="s2">n</span><span class="s0">];</span>
        <span class="s1">break</span><span class="s0">;</span>
      <span class="s0">}</span>

      <span class="s2">x </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">times</span><span class="s0">(</span><span class="s2">x</span><span class="s0">);</span>
      <span class="s2">truncate</span><span class="s0">(</span><span class="s2">x</span><span class="s0">.</span><span class="s2">d</span><span class="s0">, </span><span class="s2">k</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s2">external </span><span class="s0">= </span><span class="s1">true</span><span class="s0">;</span>

    <span class="s1">return </span><span class="s2">r</span><span class="s0">;</span>
  <span class="s0">}</span>


  <span class="s1">function </span><span class="s2">isOdd</span><span class="s0">(</span><span class="s2">n</span><span class="s0">) {</span>
    <span class="s1">return </span><span class="s2">n</span><span class="s0">.</span><span class="s2">d</span><span class="s0">[</span><span class="s2">n</span><span class="s0">.</span><span class="s2">d</span><span class="s0">.</span><span class="s2">length </span><span class="s0">- </span><span class="s5">1</span><span class="s0">] &amp; </span><span class="s5">1</span><span class="s0">;</span>
  <span class="s0">}</span>


  <span class="s4">/* 
   * Handle `max` (`n` is -1) and `min` (`n` is 1). 
   */</span>
  <span class="s1">function </span><span class="s2">maxOrMin</span><span class="s0">(</span><span class="s2">Ctor</span><span class="s0">, </span><span class="s2">args</span><span class="s0">, </span><span class="s2">n</span><span class="s0">) {</span>
    <span class="s1">var </span><span class="s2">k</span><span class="s0">, </span><span class="s2">y</span><span class="s0">,</span>
      <span class="s2">x </span><span class="s0">= </span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">args</span><span class="s0">[</span><span class="s5">0</span><span class="s0">]),</span>
      <span class="s2">i </span><span class="s0">= </span><span class="s5">0</span><span class="s0">;</span>

    <span class="s1">for </span><span class="s0">(; ++</span><span class="s2">i </span><span class="s0">&lt; </span><span class="s2">args</span><span class="s0">.</span><span class="s2">length</span><span class="s0">;) {</span>
      <span class="s2">y </span><span class="s0">= </span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">args</span><span class="s0">[</span><span class="s2">i</span><span class="s0">]);</span>

      <span class="s4">// NaN?</span>
      <span class="s1">if </span><span class="s0">(!</span><span class="s2">y</span><span class="s0">.</span><span class="s2">s</span><span class="s0">) {</span>
        <span class="s2">x </span><span class="s0">= </span><span class="s2">y</span><span class="s0">;</span>
        <span class="s1">break</span><span class="s0">;</span>
      <span class="s0">}</span>

      <span class="s2">k </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">cmp</span><span class="s0">(</span><span class="s2">y</span><span class="s0">);</span>

      <span class="s1">if </span><span class="s0">(</span><span class="s2">k </span><span class="s0">=== </span><span class="s2">n </span><span class="s0">|| </span><span class="s2">k </span><span class="s0">=== </span><span class="s5">0 </span><span class="s0">&amp;&amp; </span><span class="s2">x</span><span class="s0">.</span><span class="s2">s </span><span class="s0">=== </span><span class="s2">n</span><span class="s0">) {</span>
        <span class="s2">x </span><span class="s0">= </span><span class="s2">y</span><span class="s0">;</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">return </span><span class="s2">x</span><span class="s0">;</span>
  <span class="s0">}</span>


  <span class="s4">/* 
   * Return a new Decimal whose value is the natural exponential of `x` rounded to `sd` significant 
   * digits. 
   * 
   * Taylor/Maclaurin series. 
   * 
   * exp(x) = x^0/0! + x^1/1! + x^2/2! + x^3/3! + ... 
   * 
   * Argument reduction: 
   *   Repeat x = x / 32, k += 5, until |x| &lt; 0.1 
   *   exp(x) = exp(x / 2^k)^(2^k) 
   * 
   * Previously, the argument was initially reduced by 
   * exp(x) = exp(r) * 10^k  where r = x - k * ln10, k = floor(x / ln10) 
   * to first put r in the range [0, ln10], before dividing by 32 until |x| &lt; 0.1, but this was 
   * found to be slower than just dividing repeatedly by 32 as above. 
   * 
   * Max integer argument: exp('20723265836946413') = 6.3e+9000000000000000 
   * Min integer argument: exp('-20723265836946411') = 1.2e-9000000000000000 
   * (Math object integer min/max: Math.exp(709) = 8.2e+307, Math.exp(-745) = 5e-324) 
   * 
   *  exp(Infinity)  = Infinity 
   *  exp(-Infinity) = 0 
   *  exp(NaN)       = NaN 
   *  exp(±0)        = 1 
   * 
   *  exp(x) is non-terminating for any finite, non-zero x. 
   * 
   *  The result will always be correctly rounded. 
   * 
   */</span>
  <span class="s1">function </span><span class="s2">naturalExponential</span><span class="s0">(</span><span class="s2">x</span><span class="s0">, </span><span class="s2">sd</span><span class="s0">) {</span>
    <span class="s1">var </span><span class="s2">denominator</span><span class="s0">, </span><span class="s2">guard</span><span class="s0">, </span><span class="s2">j</span><span class="s0">, </span><span class="s2">pow</span><span class="s0">, </span><span class="s2">sum</span><span class="s0">, </span><span class="s2">t</span><span class="s0">, </span><span class="s2">wpr</span><span class="s0">,</span>
      <span class="s2">rep </span><span class="s0">= </span><span class="s5">0</span><span class="s0">,</span>
      <span class="s2">i </span><span class="s0">= </span><span class="s5">0</span><span class="s0">,</span>
      <span class="s2">k </span><span class="s0">= </span><span class="s5">0</span><span class="s0">,</span>
      <span class="s2">Ctor </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">constructor</span><span class="s0">,</span>
      <span class="s2">rm </span><span class="s0">= </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">rounding</span><span class="s0">,</span>
      <span class="s2">pr </span><span class="s0">= </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">precision</span><span class="s0">;</span>

    <span class="s4">// 0/NaN/Infinity?</span>
    <span class="s1">if </span><span class="s0">(!</span><span class="s2">x</span><span class="s0">.</span><span class="s2">d </span><span class="s0">|| !</span><span class="s2">x</span><span class="s0">.</span><span class="s2">d</span><span class="s0">[</span><span class="s5">0</span><span class="s0">] || </span><span class="s2">x</span><span class="s0">.</span><span class="s2">e </span><span class="s0">&gt; </span><span class="s5">17</span><span class="s0">) {</span>

      <span class="s1">return new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">x</span><span class="s0">.</span><span class="s2">d</span>
        <span class="s0">? !</span><span class="s2">x</span><span class="s0">.</span><span class="s2">d</span><span class="s0">[</span><span class="s5">0</span><span class="s0">] ? </span><span class="s5">1 </span><span class="s0">: </span><span class="s2">x</span><span class="s0">.</span><span class="s2">s </span><span class="s0">&lt; </span><span class="s5">0 </span><span class="s0">? </span><span class="s5">0 </span><span class="s0">: </span><span class="s5">1 </span><span class="s0">/ </span><span class="s5">0</span>
        <span class="s0">: </span><span class="s2">x</span><span class="s0">.</span><span class="s2">s </span><span class="s0">? </span><span class="s2">x</span><span class="s0">.</span><span class="s2">s </span><span class="s0">&lt; </span><span class="s5">0 </span><span class="s0">? </span><span class="s5">0 </span><span class="s0">: </span><span class="s2">x </span><span class="s0">: </span><span class="s5">0 </span><span class="s0">/ </span><span class="s5">0</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(</span><span class="s2">sd </span><span class="s0">== </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s2">external </span><span class="s0">= </span><span class="s1">false</span><span class="s0">;</span>
      <span class="s2">wpr </span><span class="s0">= </span><span class="s2">pr</span><span class="s0">;</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s2">wpr </span><span class="s0">= </span><span class="s2">sd</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s2">t </span><span class="s0">= </span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s5">0.03125</span><span class="s0">);</span>

    <span class="s4">// while abs(x) &gt;= 0.1</span>
    <span class="s1">while </span><span class="s0">(</span><span class="s2">x</span><span class="s0">.</span><span class="s2">e </span><span class="s0">&gt; -</span><span class="s5">2</span><span class="s0">) {</span>

      <span class="s4">// x = x / 2^5</span>
      <span class="s2">x </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">times</span><span class="s0">(</span><span class="s2">t</span><span class="s0">);</span>
      <span class="s2">k </span><span class="s0">+= </span><span class="s5">5</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s4">// Use 2 * log10(2^k) + 5 (empirically derived) to estimate the increase in precision</span>
    <span class="s4">// necessary to ensure the first 4 rounding digits are correct.</span>
    <span class="s2">guard </span><span class="s0">= </span><span class="s2">Math</span><span class="s0">.</span><span class="s2">log</span><span class="s0">(</span><span class="s2">mathpow</span><span class="s0">(</span><span class="s5">2</span><span class="s0">, </span><span class="s2">k</span><span class="s0">)) / </span><span class="s2">Math</span><span class="s0">.</span><span class="s2">LN10 </span><span class="s0">* </span><span class="s5">2 </span><span class="s0">+ </span><span class="s5">5 </span><span class="s0">| </span><span class="s5">0</span><span class="s0">;</span>
    <span class="s2">wpr </span><span class="s0">+= </span><span class="s2">guard</span><span class="s0">;</span>
    <span class="s2">denominator </span><span class="s0">= </span><span class="s2">pow </span><span class="s0">= </span><span class="s2">sum </span><span class="s0">= </span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s5">1</span><span class="s0">);</span>
    <span class="s2">Ctor</span><span class="s0">.</span><span class="s2">precision </span><span class="s0">= </span><span class="s2">wpr</span><span class="s0">;</span>

    <span class="s1">for </span><span class="s0">(;;) {</span>
      <span class="s2">pow </span><span class="s0">= </span><span class="s2">finalise</span><span class="s0">(</span><span class="s2">pow</span><span class="s0">.</span><span class="s2">times</span><span class="s0">(</span><span class="s2">x</span><span class="s0">), </span><span class="s2">wpr</span><span class="s0">, </span><span class="s5">1</span><span class="s0">);</span>
      <span class="s2">denominator </span><span class="s0">= </span><span class="s2">denominator</span><span class="s0">.</span><span class="s2">times</span><span class="s0">(++</span><span class="s2">i</span><span class="s0">);</span>
      <span class="s2">t </span><span class="s0">= </span><span class="s2">sum</span><span class="s0">.</span><span class="s2">plus</span><span class="s0">(</span><span class="s2">divide</span><span class="s0">(</span><span class="s2">pow</span><span class="s0">, </span><span class="s2">denominator</span><span class="s0">, </span><span class="s2">wpr</span><span class="s0">, </span><span class="s5">1</span><span class="s0">));</span>

      <span class="s1">if </span><span class="s0">(</span><span class="s2">digitsToString</span><span class="s0">(</span><span class="s2">t</span><span class="s0">.</span><span class="s2">d</span><span class="s0">).</span><span class="s2">slice</span><span class="s0">(</span><span class="s5">0</span><span class="s0">, </span><span class="s2">wpr</span><span class="s0">) === </span><span class="s2">digitsToString</span><span class="s0">(</span><span class="s2">sum</span><span class="s0">.</span><span class="s2">d</span><span class="s0">).</span><span class="s2">slice</span><span class="s0">(</span><span class="s5">0</span><span class="s0">, </span><span class="s2">wpr</span><span class="s0">)) {</span>
        <span class="s2">j </span><span class="s0">= </span><span class="s2">k</span><span class="s0">;</span>
        <span class="s1">while </span><span class="s0">(</span><span class="s2">j</span><span class="s0">--) </span><span class="s2">sum </span><span class="s0">= </span><span class="s2">finalise</span><span class="s0">(</span><span class="s2">sum</span><span class="s0">.</span><span class="s2">times</span><span class="s0">(</span><span class="s2">sum</span><span class="s0">), </span><span class="s2">wpr</span><span class="s0">, </span><span class="s5">1</span><span class="s0">);</span>

        <span class="s4">// Check to see if the first 4 rounding digits are [49]999.</span>
        <span class="s4">// If so, repeat the summation with a higher precision, otherwise</span>
        <span class="s4">// e.g. with precision: 18, rounding: 1</span>
        <span class="s4">// exp(18.404272462595034083567793919843761) = 98372560.1229999999 (should be 98372560.123)</span>
        <span class="s4">// `wpr - guard` is the index of first rounding digit.</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s2">sd </span><span class="s0">== </span><span class="s1">null</span><span class="s0">) {</span>

          <span class="s1">if </span><span class="s0">(</span><span class="s2">rep </span><span class="s0">&lt; </span><span class="s5">3 </span><span class="s0">&amp;&amp; </span><span class="s2">checkRoundingDigits</span><span class="s0">(</span><span class="s2">sum</span><span class="s0">.</span><span class="s2">d</span><span class="s0">, </span><span class="s2">wpr </span><span class="s0">- </span><span class="s2">guard</span><span class="s0">, </span><span class="s2">rm</span><span class="s0">, </span><span class="s2">rep</span><span class="s0">)) {</span>
            <span class="s2">Ctor</span><span class="s0">.</span><span class="s2">precision </span><span class="s0">= </span><span class="s2">wpr </span><span class="s0">+= </span><span class="s5">10</span><span class="s0">;</span>
            <span class="s2">denominator </span><span class="s0">= </span><span class="s2">pow </span><span class="s0">= </span><span class="s2">t </span><span class="s0">= </span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s5">1</span><span class="s0">);</span>
            <span class="s2">i </span><span class="s0">= </span><span class="s5">0</span><span class="s0">;</span>
            <span class="s2">rep</span><span class="s0">++;</span>
          <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s1">return </span><span class="s2">finalise</span><span class="s0">(</span><span class="s2">sum</span><span class="s0">, </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">precision </span><span class="s0">= </span><span class="s2">pr</span><span class="s0">, </span><span class="s2">rm</span><span class="s0">, </span><span class="s2">external </span><span class="s0">= </span><span class="s1">true</span><span class="s0">);</span>
          <span class="s0">}</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
          <span class="s2">Ctor</span><span class="s0">.</span><span class="s2">precision </span><span class="s0">= </span><span class="s2">pr</span><span class="s0">;</span>
          <span class="s1">return </span><span class="s2">sum</span><span class="s0">;</span>
        <span class="s0">}</span>
      <span class="s0">}</span>

      <span class="s2">sum </span><span class="s0">= </span><span class="s2">t</span><span class="s0">;</span>
    <span class="s0">}</span>
  <span class="s0">}</span>


  <span class="s4">/* 
   * Return a new Decimal whose value is the natural logarithm of `x` rounded to `sd` significant 
   * digits. 
   * 
   *  ln(-n)        = NaN 
   *  ln(0)         = -Infinity 
   *  ln(-0)        = -Infinity 
   *  ln(1)         = 0 
   *  ln(Infinity)  = Infinity 
   *  ln(-Infinity) = NaN 
   *  ln(NaN)       = NaN 
   * 
   *  ln(n) (n != 1) is non-terminating. 
   * 
   */</span>
  <span class="s1">function </span><span class="s2">naturalLogarithm</span><span class="s0">(</span><span class="s2">y</span><span class="s0">, </span><span class="s2">sd</span><span class="s0">) {</span>
    <span class="s1">var </span><span class="s2">c</span><span class="s0">, </span><span class="s2">c0</span><span class="s0">, </span><span class="s2">denominator</span><span class="s0">, </span><span class="s2">e</span><span class="s0">, </span><span class="s2">numerator</span><span class="s0">, </span><span class="s2">rep</span><span class="s0">, </span><span class="s2">sum</span><span class="s0">, </span><span class="s2">t</span><span class="s0">, </span><span class="s2">wpr</span><span class="s0">, </span><span class="s2">x1</span><span class="s0">, </span><span class="s2">x2</span><span class="s0">,</span>
      <span class="s2">n </span><span class="s0">= </span><span class="s5">1</span><span class="s0">,</span>
      <span class="s2">guard </span><span class="s0">= </span><span class="s5">10</span><span class="s0">,</span>
      <span class="s2">x </span><span class="s0">= </span><span class="s2">y</span><span class="s0">,</span>
      <span class="s2">xd </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">d</span><span class="s0">,</span>
      <span class="s2">Ctor </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">constructor</span><span class="s0">,</span>
      <span class="s2">rm </span><span class="s0">= </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">rounding</span><span class="s0">,</span>
      <span class="s2">pr </span><span class="s0">= </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">precision</span><span class="s0">;</span>

    <span class="s4">// Is x negative or Infinity, NaN, 0 or 1?</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">x</span><span class="s0">.</span><span class="s2">s </span><span class="s0">&lt; </span><span class="s5">0 </span><span class="s0">|| !</span><span class="s2">xd </span><span class="s0">|| !</span><span class="s2">xd</span><span class="s0">[</span><span class="s5">0</span><span class="s0">] || !</span><span class="s2">x</span><span class="s0">.</span><span class="s2">e </span><span class="s0">&amp;&amp; </span><span class="s2">xd</span><span class="s0">[</span><span class="s5">0</span><span class="s0">] == </span><span class="s5">1 </span><span class="s0">&amp;&amp; </span><span class="s2">xd</span><span class="s0">.</span><span class="s2">length </span><span class="s0">== </span><span class="s5">1</span><span class="s0">) {</span>
      <span class="s1">return new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">xd </span><span class="s0">&amp;&amp; !</span><span class="s2">xd</span><span class="s0">[</span><span class="s5">0</span><span class="s0">] ? -</span><span class="s5">1 </span><span class="s0">/ </span><span class="s5">0 </span><span class="s0">: </span><span class="s2">x</span><span class="s0">.</span><span class="s2">s </span><span class="s0">!= </span><span class="s5">1 </span><span class="s0">? </span><span class="s2">NaN </span><span class="s0">: </span><span class="s2">xd </span><span class="s0">? </span><span class="s5">0 </span><span class="s0">: </span><span class="s2">x</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(</span><span class="s2">sd </span><span class="s0">== </span><span class="s1">null</span><span class="s0">) {</span>
      <span class="s2">external </span><span class="s0">= </span><span class="s1">false</span><span class="s0">;</span>
      <span class="s2">wpr </span><span class="s0">= </span><span class="s2">pr</span><span class="s0">;</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s2">wpr </span><span class="s0">= </span><span class="s2">sd</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s2">Ctor</span><span class="s0">.</span><span class="s2">precision </span><span class="s0">= </span><span class="s2">wpr </span><span class="s0">+= </span><span class="s2">guard</span><span class="s0">;</span>
    <span class="s2">c </span><span class="s0">= </span><span class="s2">digitsToString</span><span class="s0">(</span><span class="s2">xd</span><span class="s0">);</span>
    <span class="s2">c0 </span><span class="s0">= </span><span class="s2">c</span><span class="s0">.</span><span class="s2">charAt</span><span class="s0">(</span><span class="s5">0</span><span class="s0">);</span>

    <span class="s1">if </span><span class="s0">(</span><span class="s2">Math</span><span class="s0">.</span><span class="s2">abs</span><span class="s0">(</span><span class="s2">e </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">e</span><span class="s0">) &lt; </span><span class="s5">1.5e15</span><span class="s0">) {</span>

      <span class="s4">// Argument reduction.</span>
      <span class="s4">// The series converges faster the closer the argument is to 1, so using</span>
      <span class="s4">// ln(a^b) = b * ln(a),   ln(a) = ln(a^b) / b</span>
      <span class="s4">// multiply the argument by itself until the leading digits of the significand are 7, 8, 9,</span>
      <span class="s4">// 10, 11, 12 or 13, recording the number of multiplications so the sum of the series can</span>
      <span class="s4">// later be divided by this number, then separate out the power of 10 using</span>
      <span class="s4">// ln(a*10^b) = ln(a) + b*ln(10).</span>

      <span class="s4">// max n is 21 (gives 0.9, 1.0 or 1.1) (9e15 / 21 = 4.2e14).</span>
      <span class="s4">//while (c0 &lt; 9 &amp;&amp; c0 != 1 || c0 == 1 &amp;&amp; c.charAt(1) &gt; 1) {</span>
      <span class="s4">// max n is 6 (gives 0.7 - 1.3)</span>
      <span class="s1">while </span><span class="s0">(</span><span class="s2">c0 </span><span class="s0">&lt; </span><span class="s5">7 </span><span class="s0">&amp;&amp; </span><span class="s2">c0 </span><span class="s0">!= </span><span class="s5">1 </span><span class="s0">|| </span><span class="s2">c0 </span><span class="s0">== </span><span class="s5">1 </span><span class="s0">&amp;&amp; </span><span class="s2">c</span><span class="s0">.</span><span class="s2">charAt</span><span class="s0">(</span><span class="s5">1</span><span class="s0">) &gt; </span><span class="s5">3</span><span class="s0">) {</span>
        <span class="s2">x </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">times</span><span class="s0">(</span><span class="s2">y</span><span class="s0">);</span>
        <span class="s2">c </span><span class="s0">= </span><span class="s2">digitsToString</span><span class="s0">(</span><span class="s2">x</span><span class="s0">.</span><span class="s2">d</span><span class="s0">);</span>
        <span class="s2">c0 </span><span class="s0">= </span><span class="s2">c</span><span class="s0">.</span><span class="s2">charAt</span><span class="s0">(</span><span class="s5">0</span><span class="s0">);</span>
        <span class="s2">n</span><span class="s0">++;</span>
      <span class="s0">}</span>

      <span class="s2">e </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">e</span><span class="s0">;</span>

      <span class="s1">if </span><span class="s0">(</span><span class="s2">c0 </span><span class="s0">&gt; </span><span class="s5">1</span><span class="s0">) {</span>
        <span class="s2">x </span><span class="s0">= </span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s3">'0.' </span><span class="s0">+ </span><span class="s2">c</span><span class="s0">);</span>
        <span class="s2">e</span><span class="s0">++;</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s2">x </span><span class="s0">= </span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">c0 </span><span class="s0">+ </span><span class="s3">'.' </span><span class="s0">+ </span><span class="s2">c</span><span class="s0">.</span><span class="s2">slice</span><span class="s0">(</span><span class="s5">1</span><span class="s0">));</span>
      <span class="s0">}</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>

      <span class="s4">// The argument reduction method above may result in overflow if the argument y is a massive</span>
      <span class="s4">// number with exponent &gt;= 1500000000000000 (9e15 / 6 = 1.5e15), so instead recall this</span>
      <span class="s4">// function using ln(x*10^e) = ln(x) + e*ln(10).</span>
      <span class="s2">t </span><span class="s0">= </span><span class="s2">getLn10</span><span class="s0">(</span><span class="s2">Ctor</span><span class="s0">, </span><span class="s2">wpr </span><span class="s0">+ </span><span class="s5">2</span><span class="s0">, </span><span class="s2">pr</span><span class="s0">).</span><span class="s2">times</span><span class="s0">(</span><span class="s2">e </span><span class="s0">+ </span><span class="s3">''</span><span class="s0">);</span>
      <span class="s2">x </span><span class="s0">= </span><span class="s2">naturalLogarithm</span><span class="s0">(</span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">c0 </span><span class="s0">+ </span><span class="s3">'.' </span><span class="s0">+ </span><span class="s2">c</span><span class="s0">.</span><span class="s2">slice</span><span class="s0">(</span><span class="s5">1</span><span class="s0">)), </span><span class="s2">wpr </span><span class="s0">- </span><span class="s2">guard</span><span class="s0">).</span><span class="s2">plus</span><span class="s0">(</span><span class="s2">t</span><span class="s0">);</span>
      <span class="s2">Ctor</span><span class="s0">.</span><span class="s2">precision </span><span class="s0">= </span><span class="s2">pr</span><span class="s0">;</span>

      <span class="s1">return </span><span class="s2">sd </span><span class="s0">== </span><span class="s1">null </span><span class="s0">? </span><span class="s2">finalise</span><span class="s0">(</span><span class="s2">x</span><span class="s0">, </span><span class="s2">pr</span><span class="s0">, </span><span class="s2">rm</span><span class="s0">, </span><span class="s2">external </span><span class="s0">= </span><span class="s1">true</span><span class="s0">) : </span><span class="s2">x</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s4">// x1 is x reduced to a value near 1.</span>
    <span class="s2">x1 </span><span class="s0">= </span><span class="s2">x</span><span class="s0">;</span>

    <span class="s4">// Taylor series.</span>
    <span class="s4">// ln(y) = ln((1 + x)/(1 - x)) = 2(x + x^3/3 + x^5/5 + x^7/7 + ...)</span>
    <span class="s4">// where x = (y - 1)/(y + 1)    (|x| &lt; 1)</span>
    <span class="s2">sum </span><span class="s0">= </span><span class="s2">numerator </span><span class="s0">= </span><span class="s2">x </span><span class="s0">= </span><span class="s2">divide</span><span class="s0">(</span><span class="s2">x</span><span class="s0">.</span><span class="s2">minus</span><span class="s0">(</span><span class="s5">1</span><span class="s0">), </span><span class="s2">x</span><span class="s0">.</span><span class="s2">plus</span><span class="s0">(</span><span class="s5">1</span><span class="s0">), </span><span class="s2">wpr</span><span class="s0">, </span><span class="s5">1</span><span class="s0">);</span>
    <span class="s2">x2 </span><span class="s0">= </span><span class="s2">finalise</span><span class="s0">(</span><span class="s2">x</span><span class="s0">.</span><span class="s2">times</span><span class="s0">(</span><span class="s2">x</span><span class="s0">), </span><span class="s2">wpr</span><span class="s0">, </span><span class="s5">1</span><span class="s0">);</span>
    <span class="s2">denominator </span><span class="s0">= </span><span class="s5">3</span><span class="s0">;</span>

    <span class="s1">for </span><span class="s0">(;;) {</span>
      <span class="s2">numerator </span><span class="s0">= </span><span class="s2">finalise</span><span class="s0">(</span><span class="s2">numerator</span><span class="s0">.</span><span class="s2">times</span><span class="s0">(</span><span class="s2">x2</span><span class="s0">), </span><span class="s2">wpr</span><span class="s0">, </span><span class="s5">1</span><span class="s0">);</span>
      <span class="s2">t </span><span class="s0">= </span><span class="s2">sum</span><span class="s0">.</span><span class="s2">plus</span><span class="s0">(</span><span class="s2">divide</span><span class="s0">(</span><span class="s2">numerator</span><span class="s0">, </span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">denominator</span><span class="s0">), </span><span class="s2">wpr</span><span class="s0">, </span><span class="s5">1</span><span class="s0">));</span>

      <span class="s1">if </span><span class="s0">(</span><span class="s2">digitsToString</span><span class="s0">(</span><span class="s2">t</span><span class="s0">.</span><span class="s2">d</span><span class="s0">).</span><span class="s2">slice</span><span class="s0">(</span><span class="s5">0</span><span class="s0">, </span><span class="s2">wpr</span><span class="s0">) === </span><span class="s2">digitsToString</span><span class="s0">(</span><span class="s2">sum</span><span class="s0">.</span><span class="s2">d</span><span class="s0">).</span><span class="s2">slice</span><span class="s0">(</span><span class="s5">0</span><span class="s0">, </span><span class="s2">wpr</span><span class="s0">)) {</span>
        <span class="s2">sum </span><span class="s0">= </span><span class="s2">sum</span><span class="s0">.</span><span class="s2">times</span><span class="s0">(</span><span class="s5">2</span><span class="s0">);</span>

        <span class="s4">// Reverse the argument reduction. Check that e is not 0 because, besides preventing an</span>
        <span class="s4">// unnecessary calculation, -0 + 0 = +0 and to ensure correct rounding -0 needs to stay -0.</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s2">e </span><span class="s0">!== </span><span class="s5">0</span><span class="s0">) </span><span class="s2">sum </span><span class="s0">= </span><span class="s2">sum</span><span class="s0">.</span><span class="s2">plus</span><span class="s0">(</span><span class="s2">getLn10</span><span class="s0">(</span><span class="s2">Ctor</span><span class="s0">, </span><span class="s2">wpr </span><span class="s0">+ </span><span class="s5">2</span><span class="s0">, </span><span class="s2">pr</span><span class="s0">).</span><span class="s2">times</span><span class="s0">(</span><span class="s2">e </span><span class="s0">+ </span><span class="s3">''</span><span class="s0">));</span>
        <span class="s2">sum </span><span class="s0">= </span><span class="s2">divide</span><span class="s0">(</span><span class="s2">sum</span><span class="s0">, </span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">n</span><span class="s0">), </span><span class="s2">wpr</span><span class="s0">, </span><span class="s5">1</span><span class="s0">);</span>

        <span class="s4">// Is rm &gt; 3 and the first 4 rounding digits 4999, or rm &lt; 4 (or the summation has</span>
        <span class="s4">// been repeated previously) and the first 4 rounding digits 9999?</span>
        <span class="s4">// If so, restart the summation with a higher precision, otherwise</span>
        <span class="s4">// e.g. with precision: 12, rounding: 1</span>
        <span class="s4">// ln(135520028.6126091714265381533) = 18.7246299999 when it should be 18.72463.</span>
        <span class="s4">// `wpr - guard` is the index of first rounding digit.</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s2">sd </span><span class="s0">== </span><span class="s1">null</span><span class="s0">) {</span>
          <span class="s1">if </span><span class="s0">(</span><span class="s2">checkRoundingDigits</span><span class="s0">(</span><span class="s2">sum</span><span class="s0">.</span><span class="s2">d</span><span class="s0">, </span><span class="s2">wpr </span><span class="s0">- </span><span class="s2">guard</span><span class="s0">, </span><span class="s2">rm</span><span class="s0">, </span><span class="s2">rep</span><span class="s0">)) {</span>
            <span class="s2">Ctor</span><span class="s0">.</span><span class="s2">precision </span><span class="s0">= </span><span class="s2">wpr </span><span class="s0">+= </span><span class="s2">guard</span><span class="s0">;</span>
            <span class="s2">t </span><span class="s0">= </span><span class="s2">numerator </span><span class="s0">= </span><span class="s2">x </span><span class="s0">= </span><span class="s2">divide</span><span class="s0">(</span><span class="s2">x1</span><span class="s0">.</span><span class="s2">minus</span><span class="s0">(</span><span class="s5">1</span><span class="s0">), </span><span class="s2">x1</span><span class="s0">.</span><span class="s2">plus</span><span class="s0">(</span><span class="s5">1</span><span class="s0">), </span><span class="s2">wpr</span><span class="s0">, </span><span class="s5">1</span><span class="s0">);</span>
            <span class="s2">x2 </span><span class="s0">= </span><span class="s2">finalise</span><span class="s0">(</span><span class="s2">x</span><span class="s0">.</span><span class="s2">times</span><span class="s0">(</span><span class="s2">x</span><span class="s0">), </span><span class="s2">wpr</span><span class="s0">, </span><span class="s5">1</span><span class="s0">);</span>
            <span class="s2">denominator </span><span class="s0">= </span><span class="s2">rep </span><span class="s0">= </span><span class="s5">1</span><span class="s0">;</span>
          <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s1">return </span><span class="s2">finalise</span><span class="s0">(</span><span class="s2">sum</span><span class="s0">, </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">precision </span><span class="s0">= </span><span class="s2">pr</span><span class="s0">, </span><span class="s2">rm</span><span class="s0">, </span><span class="s2">external </span><span class="s0">= </span><span class="s1">true</span><span class="s0">);</span>
          <span class="s0">}</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
          <span class="s2">Ctor</span><span class="s0">.</span><span class="s2">precision </span><span class="s0">= </span><span class="s2">pr</span><span class="s0">;</span>
          <span class="s1">return </span><span class="s2">sum</span><span class="s0">;</span>
        <span class="s0">}</span>
      <span class="s0">}</span>

      <span class="s2">sum </span><span class="s0">= </span><span class="s2">t</span><span class="s0">;</span>
      <span class="s2">denominator </span><span class="s0">+= </span><span class="s5">2</span><span class="s0">;</span>
    <span class="s0">}</span>
  <span class="s0">}</span>


  <span class="s4">// ±Infinity, NaN.</span>
  <span class="s1">function </span><span class="s2">nonFiniteToString</span><span class="s0">(</span><span class="s2">x</span><span class="s0">) {</span>
    <span class="s4">// Unsigned.</span>
    <span class="s1">return </span><span class="s2">String</span><span class="s0">(</span><span class="s2">x</span><span class="s0">.</span><span class="s2">s </span><span class="s0">* </span><span class="s2">x</span><span class="s0">.</span><span class="s2">s </span><span class="s0">/ </span><span class="s5">0</span><span class="s0">);</span>
  <span class="s0">}</span>


  <span class="s4">/* 
   * Parse the value of a new Decimal `x` from string `str`. 
   */</span>
  <span class="s1">function </span><span class="s2">parseDecimal</span><span class="s0">(</span><span class="s2">x</span><span class="s0">, </span><span class="s2">str</span><span class="s0">) {</span>
    <span class="s1">var </span><span class="s2">e</span><span class="s0">, </span><span class="s2">i</span><span class="s0">, </span><span class="s2">len</span><span class="s0">;</span>

    <span class="s4">// TODO BigInt str: no need to check for decimal point, exponential form or leading zeros.</span>

    <span class="s4">// Decimal point?</span>
    <span class="s1">if </span><span class="s0">((</span><span class="s2">e </span><span class="s0">= </span><span class="s2">str</span><span class="s0">.</span><span class="s2">indexOf</span><span class="s0">(</span><span class="s3">'.'</span><span class="s0">)) &gt; -</span><span class="s5">1</span><span class="s0">) </span><span class="s2">str </span><span class="s0">= </span><span class="s2">str</span><span class="s0">.</span><span class="s2">replace</span><span class="s0">(</span><span class="s3">'.'</span><span class="s0">, </span><span class="s3">''</span><span class="s0">);</span>

    <span class="s4">// Exponential form?</span>
    <span class="s1">if </span><span class="s0">((</span><span class="s2">i </span><span class="s0">= </span><span class="s2">str</span><span class="s0">.</span><span class="s2">search</span><span class="s0">(</span><span class="s6">/e/i</span><span class="s0">)) &gt; </span><span class="s5">0</span><span class="s0">) {</span>

      <span class="s4">// Determine exponent.</span>
      <span class="s1">if </span><span class="s0">(</span><span class="s2">e </span><span class="s0">&lt; </span><span class="s5">0</span><span class="s0">) </span><span class="s2">e </span><span class="s0">= </span><span class="s2">i</span><span class="s0">;</span>
      <span class="s2">e </span><span class="s0">+= +</span><span class="s2">str</span><span class="s0">.</span><span class="s2">slice</span><span class="s0">(</span><span class="s2">i </span><span class="s0">+ </span><span class="s5">1</span><span class="s0">);</span>
      <span class="s2">str </span><span class="s0">= </span><span class="s2">str</span><span class="s0">.</span><span class="s2">substring</span><span class="s0">(</span><span class="s5">0</span><span class="s0">, </span><span class="s2">i</span><span class="s0">);</span>
    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(</span><span class="s2">e </span><span class="s0">&lt; </span><span class="s5">0</span><span class="s0">) {</span>

      <span class="s4">// Integer.</span>
      <span class="s2">e </span><span class="s0">= </span><span class="s2">str</span><span class="s0">.</span><span class="s2">length</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s4">// Determine leading zeros.</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s2">i </span><span class="s0">= </span><span class="s5">0</span><span class="s0">; </span><span class="s2">str</span><span class="s0">.</span><span class="s2">charCodeAt</span><span class="s0">(</span><span class="s2">i</span><span class="s0">) === </span><span class="s5">48</span><span class="s0">; </span><span class="s2">i</span><span class="s0">++);</span>

    <span class="s4">// Determine trailing zeros.</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s2">len </span><span class="s0">= </span><span class="s2">str</span><span class="s0">.</span><span class="s2">length</span><span class="s0">; </span><span class="s2">str</span><span class="s0">.</span><span class="s2">charCodeAt</span><span class="s0">(</span><span class="s2">len </span><span class="s0">- </span><span class="s5">1</span><span class="s0">) === </span><span class="s5">48</span><span class="s0">; --</span><span class="s2">len</span><span class="s0">);</span>
    <span class="s2">str </span><span class="s0">= </span><span class="s2">str</span><span class="s0">.</span><span class="s2">slice</span><span class="s0">(</span><span class="s2">i</span><span class="s0">, </span><span class="s2">len</span><span class="s0">);</span>

    <span class="s1">if </span><span class="s0">(</span><span class="s2">str</span><span class="s0">) {</span>
      <span class="s2">len </span><span class="s0">-= </span><span class="s2">i</span><span class="s0">;</span>
      <span class="s2">x</span><span class="s0">.</span><span class="s2">e </span><span class="s0">= </span><span class="s2">e </span><span class="s0">= </span><span class="s2">e </span><span class="s0">- </span><span class="s2">i </span><span class="s0">- </span><span class="s5">1</span><span class="s0">;</span>
      <span class="s2">x</span><span class="s0">.</span><span class="s2">d </span><span class="s0">= [];</span>

      <span class="s4">// Transform base</span>

      <span class="s4">// e is the base 10 exponent.</span>
      <span class="s4">// i is where to slice str to get the first word of the digits array.</span>
      <span class="s2">i </span><span class="s0">= (</span><span class="s2">e </span><span class="s0">+ </span><span class="s5">1</span><span class="s0">) % </span><span class="s2">LOG_BASE</span><span class="s0">;</span>
      <span class="s1">if </span><span class="s0">(</span><span class="s2">e </span><span class="s0">&lt; </span><span class="s5">0</span><span class="s0">) </span><span class="s2">i </span><span class="s0">+= </span><span class="s2">LOG_BASE</span><span class="s0">;</span>

      <span class="s1">if </span><span class="s0">(</span><span class="s2">i </span><span class="s0">&lt; </span><span class="s2">len</span><span class="s0">) {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s2">i</span><span class="s0">) </span><span class="s2">x</span><span class="s0">.</span><span class="s2">d</span><span class="s0">.</span><span class="s2">push</span><span class="s0">(+</span><span class="s2">str</span><span class="s0">.</span><span class="s2">slice</span><span class="s0">(</span><span class="s5">0</span><span class="s0">, </span><span class="s2">i</span><span class="s0">));</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s2">len </span><span class="s0">-= </span><span class="s2">LOG_BASE</span><span class="s0">; </span><span class="s2">i </span><span class="s0">&lt; </span><span class="s2">len</span><span class="s0">;) </span><span class="s2">x</span><span class="s0">.</span><span class="s2">d</span><span class="s0">.</span><span class="s2">push</span><span class="s0">(+</span><span class="s2">str</span><span class="s0">.</span><span class="s2">slice</span><span class="s0">(</span><span class="s2">i</span><span class="s0">, </span><span class="s2">i </span><span class="s0">+= </span><span class="s2">LOG_BASE</span><span class="s0">));</span>
        <span class="s2">str </span><span class="s0">= </span><span class="s2">str</span><span class="s0">.</span><span class="s2">slice</span><span class="s0">(</span><span class="s2">i</span><span class="s0">);</span>
        <span class="s2">i </span><span class="s0">= </span><span class="s2">LOG_BASE </span><span class="s0">- </span><span class="s2">str</span><span class="s0">.</span><span class="s2">length</span><span class="s0">;</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s2">i </span><span class="s0">-= </span><span class="s2">len</span><span class="s0">;</span>
      <span class="s0">}</span>

      <span class="s1">for </span><span class="s0">(; </span><span class="s2">i</span><span class="s0">--;) </span><span class="s2">str </span><span class="s0">+= </span><span class="s3">'0'</span><span class="s0">;</span>
      <span class="s2">x</span><span class="s0">.</span><span class="s2">d</span><span class="s0">.</span><span class="s2">push</span><span class="s0">(+</span><span class="s2">str</span><span class="s0">);</span>

      <span class="s1">if </span><span class="s0">(</span><span class="s2">external</span><span class="s0">) {</span>

        <span class="s4">// Overflow?</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s2">x</span><span class="s0">.</span><span class="s2">e </span><span class="s0">&gt; </span><span class="s2">x</span><span class="s0">.</span><span class="s2">constructor</span><span class="s0">.</span><span class="s2">maxE</span><span class="s0">) {</span>

          <span class="s4">// Infinity.</span>
          <span class="s2">x</span><span class="s0">.</span><span class="s2">d </span><span class="s0">= </span><span class="s1">null</span><span class="s0">;</span>
          <span class="s2">x</span><span class="s0">.</span><span class="s2">e </span><span class="s0">= </span><span class="s2">NaN</span><span class="s0">;</span>

        <span class="s4">// Underflow?</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(</span><span class="s2">x</span><span class="s0">.</span><span class="s2">e </span><span class="s0">&lt; </span><span class="s2">x</span><span class="s0">.</span><span class="s2">constructor</span><span class="s0">.</span><span class="s2">minE</span><span class="s0">) {</span>

          <span class="s4">// Zero.</span>
          <span class="s2">x</span><span class="s0">.</span><span class="s2">e </span><span class="s0">= </span><span class="s5">0</span><span class="s0">;</span>
          <span class="s2">x</span><span class="s0">.</span><span class="s2">d </span><span class="s0">= [</span><span class="s5">0</span><span class="s0">];</span>
          <span class="s4">// x.constructor.underflow = true;</span>
        <span class="s0">} </span><span class="s4">// else x.constructor.underflow = false;</span>
      <span class="s0">}</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>

      <span class="s4">// Zero.</span>
      <span class="s2">x</span><span class="s0">.</span><span class="s2">e </span><span class="s0">= </span><span class="s5">0</span><span class="s0">;</span>
      <span class="s2">x</span><span class="s0">.</span><span class="s2">d </span><span class="s0">= [</span><span class="s5">0</span><span class="s0">];</span>
    <span class="s0">}</span>

    <span class="s1">return </span><span class="s2">x</span><span class="s0">;</span>
  <span class="s0">}</span>


  <span class="s4">/* 
   * Parse the value of a new Decimal `x` from a string `str`, which is not a decimal value. 
   */</span>
  <span class="s1">function </span><span class="s2">parseOther</span><span class="s0">(</span><span class="s2">x</span><span class="s0">, </span><span class="s2">str</span><span class="s0">) {</span>
    <span class="s1">var </span><span class="s2">base</span><span class="s0">, </span><span class="s2">Ctor</span><span class="s0">, </span><span class="s2">divisor</span><span class="s0">, </span><span class="s2">i</span><span class="s0">, </span><span class="s2">isFloat</span><span class="s0">, </span><span class="s2">len</span><span class="s0">, </span><span class="s2">p</span><span class="s0">, </span><span class="s2">xd</span><span class="s0">, </span><span class="s2">xe</span><span class="s0">;</span>

    <span class="s1">if </span><span class="s0">(</span><span class="s2">str</span><span class="s0">.</span><span class="s2">indexOf</span><span class="s0">(</span><span class="s3">'_'</span><span class="s0">) &gt; -</span><span class="s5">1</span><span class="s0">) {</span>
      <span class="s2">str </span><span class="s0">= </span><span class="s2">str</span><span class="s0">.</span><span class="s2">replace</span><span class="s0">(</span><span class="s6">/(\d)_(?=\d)/g</span><span class="s0">, </span><span class="s3">'$1'</span><span class="s0">);</span>
      <span class="s1">if </span><span class="s0">(</span><span class="s2">isDecimal</span><span class="s0">.</span><span class="s2">test</span><span class="s0">(</span><span class="s2">str</span><span class="s0">)) </span><span class="s1">return </span><span class="s2">parseDecimal</span><span class="s0">(</span><span class="s2">x</span><span class="s0">, </span><span class="s2">str</span><span class="s0">);</span>
    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(</span><span class="s2">str </span><span class="s0">=== </span><span class="s3">'Infinity' </span><span class="s0">|| </span><span class="s2">str </span><span class="s0">=== </span><span class="s3">'NaN'</span><span class="s0">) {</span>
      <span class="s1">if </span><span class="s0">(!+</span><span class="s2">str</span><span class="s0">) </span><span class="s2">x</span><span class="s0">.</span><span class="s2">s </span><span class="s0">= </span><span class="s2">NaN</span><span class="s0">;</span>
      <span class="s2">x</span><span class="s0">.</span><span class="s2">e </span><span class="s0">= </span><span class="s2">NaN</span><span class="s0">;</span>
      <span class="s2">x</span><span class="s0">.</span><span class="s2">d </span><span class="s0">= </span><span class="s1">null</span><span class="s0">;</span>
      <span class="s1">return </span><span class="s2">x</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(</span><span class="s2">isHex</span><span class="s0">.</span><span class="s2">test</span><span class="s0">(</span><span class="s2">str</span><span class="s0">))  {</span>
      <span class="s2">base </span><span class="s0">= </span><span class="s5">16</span><span class="s0">;</span>
      <span class="s2">str </span><span class="s0">= </span><span class="s2">str</span><span class="s0">.</span><span class="s2">toLowerCase</span><span class="s0">();</span>
    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(</span><span class="s2">isBinary</span><span class="s0">.</span><span class="s2">test</span><span class="s0">(</span><span class="s2">str</span><span class="s0">))  {</span>
      <span class="s2">base </span><span class="s0">= </span><span class="s5">2</span><span class="s0">;</span>
    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(</span><span class="s2">isOctal</span><span class="s0">.</span><span class="s2">test</span><span class="s0">(</span><span class="s2">str</span><span class="s0">))  {</span>
      <span class="s2">base </span><span class="s0">= </span><span class="s5">8</span><span class="s0">;</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s1">throw </span><span class="s2">Error</span><span class="s0">(</span><span class="s2">invalidArgument </span><span class="s0">+ </span><span class="s2">str</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s4">// Is there a binary exponent part?</span>
    <span class="s2">i </span><span class="s0">= </span><span class="s2">str</span><span class="s0">.</span><span class="s2">search</span><span class="s0">(</span><span class="s6">/p/i</span><span class="s0">);</span>

    <span class="s1">if </span><span class="s0">(</span><span class="s2">i </span><span class="s0">&gt; </span><span class="s5">0</span><span class="s0">) {</span>
      <span class="s2">p </span><span class="s0">= +</span><span class="s2">str</span><span class="s0">.</span><span class="s2">slice</span><span class="s0">(</span><span class="s2">i </span><span class="s0">+ </span><span class="s5">1</span><span class="s0">);</span>
      <span class="s2">str </span><span class="s0">= </span><span class="s2">str</span><span class="s0">.</span><span class="s2">substring</span><span class="s0">(</span><span class="s5">2</span><span class="s0">, </span><span class="s2">i</span><span class="s0">);</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s2">str </span><span class="s0">= </span><span class="s2">str</span><span class="s0">.</span><span class="s2">slice</span><span class="s0">(</span><span class="s5">2</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s4">// Convert `str` as an integer then divide the result by `base` raised to a power such that the</span>
    <span class="s4">// fraction part will be restored.</span>
    <span class="s2">i </span><span class="s0">= </span><span class="s2">str</span><span class="s0">.</span><span class="s2">indexOf</span><span class="s0">(</span><span class="s3">'.'</span><span class="s0">);</span>
    <span class="s2">isFloat </span><span class="s0">= </span><span class="s2">i </span><span class="s0">&gt;= </span><span class="s5">0</span><span class="s0">;</span>
    <span class="s2">Ctor </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">constructor</span><span class="s0">;</span>

    <span class="s1">if </span><span class="s0">(</span><span class="s2">isFloat</span><span class="s0">) {</span>
      <span class="s2">str </span><span class="s0">= </span><span class="s2">str</span><span class="s0">.</span><span class="s2">replace</span><span class="s0">(</span><span class="s3">'.'</span><span class="s0">, </span><span class="s3">''</span><span class="s0">);</span>
      <span class="s2">len </span><span class="s0">= </span><span class="s2">str</span><span class="s0">.</span><span class="s2">length</span><span class="s0">;</span>
      <span class="s2">i </span><span class="s0">= </span><span class="s2">len </span><span class="s0">- </span><span class="s2">i</span><span class="s0">;</span>

      <span class="s4">// log[10](16) = 1.2041... , log[10](88) = 1.9444....</span>
      <span class="s2">divisor </span><span class="s0">= </span><span class="s2">intPow</span><span class="s0">(</span><span class="s2">Ctor</span><span class="s0">, </span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">base</span><span class="s0">), </span><span class="s2">i</span><span class="s0">, </span><span class="s2">i </span><span class="s0">* </span><span class="s5">2</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s2">xd </span><span class="s0">= </span><span class="s2">convertBase</span><span class="s0">(</span><span class="s2">str</span><span class="s0">, </span><span class="s2">base</span><span class="s0">, </span><span class="s2">BASE</span><span class="s0">);</span>
    <span class="s2">xe </span><span class="s0">= </span><span class="s2">xd</span><span class="s0">.</span><span class="s2">length </span><span class="s0">- </span><span class="s5">1</span><span class="s0">;</span>

    <span class="s4">// Remove trailing zeros.</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s2">i </span><span class="s0">= </span><span class="s2">xe</span><span class="s0">; </span><span class="s2">xd</span><span class="s0">[</span><span class="s2">i</span><span class="s0">] === </span><span class="s5">0</span><span class="s0">; --</span><span class="s2">i</span><span class="s0">) </span><span class="s2">xd</span><span class="s0">.</span><span class="s2">pop</span><span class="s0">();</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">i </span><span class="s0">&lt; </span><span class="s5">0</span><span class="s0">) </span><span class="s1">return new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">x</span><span class="s0">.</span><span class="s2">s </span><span class="s0">* </span><span class="s5">0</span><span class="s0">);</span>
    <span class="s2">x</span><span class="s0">.</span><span class="s2">e </span><span class="s0">= </span><span class="s2">getBase10Exponent</span><span class="s0">(</span><span class="s2">xd</span><span class="s0">, </span><span class="s2">xe</span><span class="s0">);</span>
    <span class="s2">x</span><span class="s0">.</span><span class="s2">d </span><span class="s0">= </span><span class="s2">xd</span><span class="s0">;</span>
    <span class="s2">external </span><span class="s0">= </span><span class="s1">false</span><span class="s0">;</span>

    <span class="s4">// At what precision to perform the division to ensure exact conversion?</span>
    <span class="s4">// maxDecimalIntegerPartDigitCount = ceil(log[10](b) * otherBaseIntegerPartDigitCount)</span>
    <span class="s4">// log[10](2) = 0.30103, log[10](8) = 0.90309, log[10](16) = 1.20412</span>
    <span class="s4">// E.g. ceil(1.2 * 3) = 4, so up to 4 decimal digits are needed to represent 3 hex int digits.</span>
    <span class="s4">// maxDecimalFractionPartDigitCount = {Hex:4|Oct:3|Bin:1} * otherBaseFractionPartDigitCount</span>
    <span class="s4">// Therefore using 4 * the number of digits of str will always be enough.</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">isFloat</span><span class="s0">) </span><span class="s2">x </span><span class="s0">= </span><span class="s2">divide</span><span class="s0">(</span><span class="s2">x</span><span class="s0">, </span><span class="s2">divisor</span><span class="s0">, </span><span class="s2">len </span><span class="s0">* </span><span class="s5">4</span><span class="s0">);</span>

    <span class="s4">// Multiply by the binary exponent part if present.</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">p</span><span class="s0">) </span><span class="s2">x </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">times</span><span class="s0">(</span><span class="s2">Math</span><span class="s0">.</span><span class="s2">abs</span><span class="s0">(</span><span class="s2">p</span><span class="s0">) &lt; </span><span class="s5">54 </span><span class="s0">? </span><span class="s2">mathpow</span><span class="s0">(</span><span class="s5">2</span><span class="s0">, </span><span class="s2">p</span><span class="s0">) : </span><span class="s2">Decimal</span><span class="s0">.</span><span class="s2">pow</span><span class="s0">(</span><span class="s5">2</span><span class="s0">, </span><span class="s2">p</span><span class="s0">));</span>
    <span class="s2">external </span><span class="s0">= </span><span class="s1">true</span><span class="s0">;</span>

    <span class="s1">return </span><span class="s2">x</span><span class="s0">;</span>
  <span class="s0">}</span>


  <span class="s4">/* 
   * sin(x) = x - x^3/3! + x^5/5! - ... 
   * |x| &lt; pi/2 
   * 
   */</span>
  <span class="s1">function </span><span class="s2">sine</span><span class="s0">(</span><span class="s2">Ctor</span><span class="s0">, </span><span class="s2">x</span><span class="s0">) {</span>
    <span class="s1">var </span><span class="s2">k</span><span class="s0">,</span>
      <span class="s2">len </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">d</span><span class="s0">.</span><span class="s2">length</span><span class="s0">;</span>

    <span class="s1">if </span><span class="s0">(</span><span class="s2">len </span><span class="s0">&lt; </span><span class="s5">3</span><span class="s0">) {</span>
      <span class="s1">return </span><span class="s2">x</span><span class="s0">.</span><span class="s2">isZero</span><span class="s0">() ? </span><span class="s2">x </span><span class="s0">: </span><span class="s2">taylorSeries</span><span class="s0">(</span><span class="s2">Ctor</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s2">x</span><span class="s0">, </span><span class="s2">x</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s4">// Argument reduction: sin(5x) = 16*sin^5(x) - 20*sin^3(x) + 5*sin(x)</span>
    <span class="s4">// i.e. sin(x) = 16*sin^5(x/5) - 20*sin^3(x/5) + 5*sin(x/5)</span>
    <span class="s4">// and  sin(x) = sin(x/5)(5 + sin^2(x/5)(16sin^2(x/5) - 20))</span>

    <span class="s4">// Estimate the optimum number of times to use the argument reduction.</span>
    <span class="s2">k </span><span class="s0">= </span><span class="s5">1.4 </span><span class="s0">* </span><span class="s2">Math</span><span class="s0">.</span><span class="s2">sqrt</span><span class="s0">(</span><span class="s2">len</span><span class="s0">);</span>
    <span class="s2">k </span><span class="s0">= </span><span class="s2">k </span><span class="s0">&gt; </span><span class="s5">16 </span><span class="s0">? </span><span class="s5">16 </span><span class="s0">: </span><span class="s2">k </span><span class="s0">| </span><span class="s5">0</span><span class="s0">;</span>

    <span class="s2">x </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">times</span><span class="s0">(</span><span class="s5">1 </span><span class="s0">/ </span><span class="s2">tinyPow</span><span class="s0">(</span><span class="s5">5</span><span class="s0">, </span><span class="s2">k</span><span class="s0">));</span>
    <span class="s2">x </span><span class="s0">= </span><span class="s2">taylorSeries</span><span class="s0">(</span><span class="s2">Ctor</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s2">x</span><span class="s0">, </span><span class="s2">x</span><span class="s0">);</span>

    <span class="s4">// Reverse argument reduction</span>
    <span class="s1">var </span><span class="s2">sin2_x</span><span class="s0">,</span>
      <span class="s2">d5 </span><span class="s0">= </span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s5">5</span><span class="s0">),</span>
      <span class="s2">d16 </span><span class="s0">= </span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s5">16</span><span class="s0">),</span>
      <span class="s2">d20 </span><span class="s0">= </span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s5">20</span><span class="s0">);</span>
    <span class="s1">for </span><span class="s0">(; </span><span class="s2">k</span><span class="s0">--;) {</span>
      <span class="s2">sin2_x </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">times</span><span class="s0">(</span><span class="s2">x</span><span class="s0">);</span>
      <span class="s2">x </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">times</span><span class="s0">(</span><span class="s2">d5</span><span class="s0">.</span><span class="s2">plus</span><span class="s0">(</span><span class="s2">sin2_x</span><span class="s0">.</span><span class="s2">times</span><span class="s0">(</span><span class="s2">d16</span><span class="s0">.</span><span class="s2">times</span><span class="s0">(</span><span class="s2">sin2_x</span><span class="s0">).</span><span class="s2">minus</span><span class="s0">(</span><span class="s2">d20</span><span class="s0">))));</span>
    <span class="s0">}</span>

    <span class="s1">return </span><span class="s2">x</span><span class="s0">;</span>
  <span class="s0">}</span>


  <span class="s4">// Calculate Taylor series for `cos`, `cosh`, `sin` and `sinh`.</span>
  <span class="s1">function </span><span class="s2">taylorSeries</span><span class="s0">(</span><span class="s2">Ctor</span><span class="s0">, </span><span class="s2">n</span><span class="s0">, </span><span class="s2">x</span><span class="s0">, </span><span class="s2">y</span><span class="s0">, </span><span class="s2">isHyperbolic</span><span class="s0">) {</span>
    <span class="s1">var </span><span class="s2">j</span><span class="s0">, </span><span class="s2">t</span><span class="s0">, </span><span class="s2">u</span><span class="s0">, </span><span class="s2">x2</span><span class="s0">,</span>
      <span class="s2">i </span><span class="s0">= </span><span class="s5">1</span><span class="s0">,</span>
      <span class="s2">pr </span><span class="s0">= </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">precision</span><span class="s0">,</span>
      <span class="s2">k </span><span class="s0">= </span><span class="s2">Math</span><span class="s0">.</span><span class="s2">ceil</span><span class="s0">(</span><span class="s2">pr </span><span class="s0">/ </span><span class="s2">LOG_BASE</span><span class="s0">);</span>

    <span class="s2">external </span><span class="s0">= </span><span class="s1">false</span><span class="s0">;</span>
    <span class="s2">x2 </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">times</span><span class="s0">(</span><span class="s2">x</span><span class="s0">);</span>
    <span class="s2">u </span><span class="s0">= </span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">y</span><span class="s0">);</span>

    <span class="s1">for </span><span class="s0">(;;) {</span>
      <span class="s2">t </span><span class="s0">= </span><span class="s2">divide</span><span class="s0">(</span><span class="s2">u</span><span class="s0">.</span><span class="s2">times</span><span class="s0">(</span><span class="s2">x2</span><span class="s0">), </span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">n</span><span class="s0">++ * </span><span class="s2">n</span><span class="s0">++), </span><span class="s2">pr</span><span class="s0">, </span><span class="s5">1</span><span class="s0">);</span>
      <span class="s2">u </span><span class="s0">= </span><span class="s2">isHyperbolic </span><span class="s0">? </span><span class="s2">y</span><span class="s0">.</span><span class="s2">plus</span><span class="s0">(</span><span class="s2">t</span><span class="s0">) : </span><span class="s2">y</span><span class="s0">.</span><span class="s2">minus</span><span class="s0">(</span><span class="s2">t</span><span class="s0">);</span>
      <span class="s2">y </span><span class="s0">= </span><span class="s2">divide</span><span class="s0">(</span><span class="s2">t</span><span class="s0">.</span><span class="s2">times</span><span class="s0">(</span><span class="s2">x2</span><span class="s0">), </span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">n</span><span class="s0">++ * </span><span class="s2">n</span><span class="s0">++), </span><span class="s2">pr</span><span class="s0">, </span><span class="s5">1</span><span class="s0">);</span>
      <span class="s2">t </span><span class="s0">= </span><span class="s2">u</span><span class="s0">.</span><span class="s2">plus</span><span class="s0">(</span><span class="s2">y</span><span class="s0">);</span>

      <span class="s1">if </span><span class="s0">(</span><span class="s2">t</span><span class="s0">.</span><span class="s2">d</span><span class="s0">[</span><span class="s2">k</span><span class="s0">] !== </span><span class="s1">void </span><span class="s5">0</span><span class="s0">) {</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s2">j </span><span class="s0">= </span><span class="s2">k</span><span class="s0">; </span><span class="s2">t</span><span class="s0">.</span><span class="s2">d</span><span class="s0">[</span><span class="s2">j</span><span class="s0">] === </span><span class="s2">u</span><span class="s0">.</span><span class="s2">d</span><span class="s0">[</span><span class="s2">j</span><span class="s0">] &amp;&amp; </span><span class="s2">j</span><span class="s0">--;);</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s2">j </span><span class="s0">== -</span><span class="s5">1</span><span class="s0">) </span><span class="s1">break</span><span class="s0">;</span>
      <span class="s0">}</span>

      <span class="s2">j </span><span class="s0">= </span><span class="s2">u</span><span class="s0">;</span>
      <span class="s2">u </span><span class="s0">= </span><span class="s2">y</span><span class="s0">;</span>
      <span class="s2">y </span><span class="s0">= </span><span class="s2">t</span><span class="s0">;</span>
      <span class="s2">t </span><span class="s0">= </span><span class="s2">j</span><span class="s0">;</span>
      <span class="s2">i</span><span class="s0">++;</span>
    <span class="s0">}</span>

    <span class="s2">external </span><span class="s0">= </span><span class="s1">true</span><span class="s0">;</span>
    <span class="s2">t</span><span class="s0">.</span><span class="s2">d</span><span class="s0">.</span><span class="s2">length </span><span class="s0">= </span><span class="s2">k </span><span class="s0">+ </span><span class="s5">1</span><span class="s0">;</span>

    <span class="s1">return </span><span class="s2">t</span><span class="s0">;</span>
  <span class="s0">}</span>


  <span class="s4">// Exponent e must be positive and non-zero.</span>
  <span class="s1">function </span><span class="s2">tinyPow</span><span class="s0">(</span><span class="s2">b</span><span class="s0">, </span><span class="s2">e</span><span class="s0">) {</span>
    <span class="s1">var </span><span class="s2">n </span><span class="s0">= </span><span class="s2">b</span><span class="s0">;</span>
    <span class="s1">while </span><span class="s0">(--</span><span class="s2">e</span><span class="s0">) </span><span class="s2">n </span><span class="s0">*= </span><span class="s2">b</span><span class="s0">;</span>
    <span class="s1">return </span><span class="s2">n</span><span class="s0">;</span>
  <span class="s0">}</span>


  <span class="s4">// Return the absolute value of `x` reduced to less than or equal to half pi.</span>
  <span class="s1">function </span><span class="s2">toLessThanHalfPi</span><span class="s0">(</span><span class="s2">Ctor</span><span class="s0">, </span><span class="s2">x</span><span class="s0">) {</span>
    <span class="s1">var </span><span class="s2">t</span><span class="s0">,</span>
      <span class="s2">isNeg </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">s </span><span class="s0">&lt; </span><span class="s5">0</span><span class="s0">,</span>
      <span class="s2">pi </span><span class="s0">= </span><span class="s2">getPi</span><span class="s0">(</span><span class="s2">Ctor</span><span class="s0">, </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">precision</span><span class="s0">, </span><span class="s5">1</span><span class="s0">),</span>
      <span class="s2">halfPi </span><span class="s0">= </span><span class="s2">pi</span><span class="s0">.</span><span class="s2">times</span><span class="s0">(</span><span class="s5">0.5</span><span class="s0">);</span>

    <span class="s2">x </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">abs</span><span class="s0">();</span>

    <span class="s1">if </span><span class="s0">(</span><span class="s2">x</span><span class="s0">.</span><span class="s2">lte</span><span class="s0">(</span><span class="s2">halfPi</span><span class="s0">)) {</span>
      <span class="s2">quadrant </span><span class="s0">= </span><span class="s2">isNeg </span><span class="s0">? </span><span class="s5">4 </span><span class="s0">: </span><span class="s5">1</span><span class="s0">;</span>
      <span class="s1">return </span><span class="s2">x</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s2">t </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">divToInt</span><span class="s0">(</span><span class="s2">pi</span><span class="s0">);</span>

    <span class="s1">if </span><span class="s0">(</span><span class="s2">t</span><span class="s0">.</span><span class="s2">isZero</span><span class="s0">()) {</span>
      <span class="s2">quadrant </span><span class="s0">= </span><span class="s2">isNeg </span><span class="s0">? </span><span class="s5">3 </span><span class="s0">: </span><span class="s5">2</span><span class="s0">;</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s2">x </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">minus</span><span class="s0">(</span><span class="s2">t</span><span class="s0">.</span><span class="s2">times</span><span class="s0">(</span><span class="s2">pi</span><span class="s0">));</span>

      <span class="s4">// 0 &lt;= x &lt; pi</span>
      <span class="s1">if </span><span class="s0">(</span><span class="s2">x</span><span class="s0">.</span><span class="s2">lte</span><span class="s0">(</span><span class="s2">halfPi</span><span class="s0">)) {</span>
        <span class="s2">quadrant </span><span class="s0">= </span><span class="s2">isOdd</span><span class="s0">(</span><span class="s2">t</span><span class="s0">) ? (</span><span class="s2">isNeg </span><span class="s0">? </span><span class="s5">2 </span><span class="s0">: </span><span class="s5">3</span><span class="s0">) : (</span><span class="s2">isNeg </span><span class="s0">? </span><span class="s5">4 </span><span class="s0">: </span><span class="s5">1</span><span class="s0">);</span>
        <span class="s1">return </span><span class="s2">x</span><span class="s0">;</span>
      <span class="s0">}</span>

      <span class="s2">quadrant </span><span class="s0">= </span><span class="s2">isOdd</span><span class="s0">(</span><span class="s2">t</span><span class="s0">) ? (</span><span class="s2">isNeg </span><span class="s0">? </span><span class="s5">1 </span><span class="s0">: </span><span class="s5">4</span><span class="s0">) : (</span><span class="s2">isNeg </span><span class="s0">? </span><span class="s5">3 </span><span class="s0">: </span><span class="s5">2</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s1">return </span><span class="s2">x</span><span class="s0">.</span><span class="s2">minus</span><span class="s0">(</span><span class="s2">pi</span><span class="s0">).</span><span class="s2">abs</span><span class="s0">();</span>
  <span class="s0">}</span>


  <span class="s4">/* 
   * Return the value of Decimal `x` as a string in base `baseOut`. 
   * 
   * If the optional `sd` argument is present include a binary exponent suffix. 
   */</span>
  <span class="s1">function </span><span class="s2">toStringBinary</span><span class="s0">(</span><span class="s2">x</span><span class="s0">, </span><span class="s2">baseOut</span><span class="s0">, </span><span class="s2">sd</span><span class="s0">, </span><span class="s2">rm</span><span class="s0">) {</span>
    <span class="s1">var </span><span class="s2">base</span><span class="s0">, </span><span class="s2">e</span><span class="s0">, </span><span class="s2">i</span><span class="s0">, </span><span class="s2">k</span><span class="s0">, </span><span class="s2">len</span><span class="s0">, </span><span class="s2">roundUp</span><span class="s0">, </span><span class="s2">str</span><span class="s0">, </span><span class="s2">xd</span><span class="s0">, </span><span class="s2">y</span><span class="s0">,</span>
      <span class="s2">Ctor </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">constructor</span><span class="s0">,</span>
      <span class="s2">isExp </span><span class="s0">= </span><span class="s2">sd </span><span class="s0">!== </span><span class="s1">void </span><span class="s5">0</span><span class="s0">;</span>

    <span class="s1">if </span><span class="s0">(</span><span class="s2">isExp</span><span class="s0">) {</span>
      <span class="s2">checkInt32</span><span class="s0">(</span><span class="s2">sd</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s2">MAX_DIGITS</span><span class="s0">);</span>
      <span class="s1">if </span><span class="s0">(</span><span class="s2">rm </span><span class="s0">=== </span><span class="s1">void </span><span class="s5">0</span><span class="s0">) </span><span class="s2">rm </span><span class="s0">= </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">rounding</span><span class="s0">;</span>
      <span class="s1">else </span><span class="s2">checkInt32</span><span class="s0">(</span><span class="s2">rm</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">8</span><span class="s0">);</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s2">sd </span><span class="s0">= </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">precision</span><span class="s0">;</span>
      <span class="s2">rm </span><span class="s0">= </span><span class="s2">Ctor</span><span class="s0">.</span><span class="s2">rounding</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(!</span><span class="s2">x</span><span class="s0">.</span><span class="s2">isFinite</span><span class="s0">()) {</span>
      <span class="s2">str </span><span class="s0">= </span><span class="s2">nonFiniteToString</span><span class="s0">(</span><span class="s2">x</span><span class="s0">);</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s2">str </span><span class="s0">= </span><span class="s2">finiteToString</span><span class="s0">(</span><span class="s2">x</span><span class="s0">);</span>
      <span class="s2">i </span><span class="s0">= </span><span class="s2">str</span><span class="s0">.</span><span class="s2">indexOf</span><span class="s0">(</span><span class="s3">'.'</span><span class="s0">);</span>

      <span class="s4">// Use exponential notation according to `toExpPos` and `toExpNeg`? No, but if required:</span>
      <span class="s4">// maxBinaryExponent = floor((decimalExponent + 1) * log[2](10))</span>
      <span class="s4">// minBinaryExponent = floor(decimalExponent * log[2](10))</span>
      <span class="s4">// log[2](10) = 3.321928094887362347870319429489390175864</span>

      <span class="s1">if </span><span class="s0">(</span><span class="s2">isExp</span><span class="s0">) {</span>
        <span class="s2">base </span><span class="s0">= </span><span class="s5">2</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s2">baseOut </span><span class="s0">== </span><span class="s5">16</span><span class="s0">) {</span>
          <span class="s2">sd </span><span class="s0">= </span><span class="s2">sd </span><span class="s0">* </span><span class="s5">4 </span><span class="s0">- </span><span class="s5">3</span><span class="s0">;</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(</span><span class="s2">baseOut </span><span class="s0">== </span><span class="s5">8</span><span class="s0">) {</span>
          <span class="s2">sd </span><span class="s0">= </span><span class="s2">sd </span><span class="s0">* </span><span class="s5">3 </span><span class="s0">- </span><span class="s5">2</span><span class="s0">;</span>
        <span class="s0">}</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s2">base </span><span class="s0">= </span><span class="s2">baseOut</span><span class="s0">;</span>
      <span class="s0">}</span>

      <span class="s4">// Convert the number as an integer then divide the result by its base raised to a power such</span>
      <span class="s4">// that the fraction part will be restored.</span>

      <span class="s4">// Non-integer.</span>
      <span class="s1">if </span><span class="s0">(</span><span class="s2">i </span><span class="s0">&gt;= </span><span class="s5">0</span><span class="s0">) {</span>
        <span class="s2">str </span><span class="s0">= </span><span class="s2">str</span><span class="s0">.</span><span class="s2">replace</span><span class="s0">(</span><span class="s3">'.'</span><span class="s0">, </span><span class="s3">''</span><span class="s0">);</span>
        <span class="s2">y </span><span class="s0">= </span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s5">1</span><span class="s0">);</span>
        <span class="s2">y</span><span class="s0">.</span><span class="s2">e </span><span class="s0">= </span><span class="s2">str</span><span class="s0">.</span><span class="s2">length </span><span class="s0">- </span><span class="s2">i</span><span class="s0">;</span>
        <span class="s2">y</span><span class="s0">.</span><span class="s2">d </span><span class="s0">= </span><span class="s2">convertBase</span><span class="s0">(</span><span class="s2">finiteToString</span><span class="s0">(</span><span class="s2">y</span><span class="s0">), </span><span class="s5">10</span><span class="s0">, </span><span class="s2">base</span><span class="s0">);</span>
        <span class="s2">y</span><span class="s0">.</span><span class="s2">e </span><span class="s0">= </span><span class="s2">y</span><span class="s0">.</span><span class="s2">d</span><span class="s0">.</span><span class="s2">length</span><span class="s0">;</span>
      <span class="s0">}</span>

      <span class="s2">xd </span><span class="s0">= </span><span class="s2">convertBase</span><span class="s0">(</span><span class="s2">str</span><span class="s0">, </span><span class="s5">10</span><span class="s0">, </span><span class="s2">base</span><span class="s0">);</span>
      <span class="s2">e </span><span class="s0">= </span><span class="s2">len </span><span class="s0">= </span><span class="s2">xd</span><span class="s0">.</span><span class="s2">length</span><span class="s0">;</span>

      <span class="s4">// Remove trailing zeros.</span>
      <span class="s1">for </span><span class="s0">(; </span><span class="s2">xd</span><span class="s0">[--</span><span class="s2">len</span><span class="s0">] == </span><span class="s5">0</span><span class="s0">;) </span><span class="s2">xd</span><span class="s0">.</span><span class="s2">pop</span><span class="s0">();</span>

      <span class="s1">if </span><span class="s0">(!</span><span class="s2">xd</span><span class="s0">[</span><span class="s5">0</span><span class="s0">]) {</span>
        <span class="s2">str </span><span class="s0">= </span><span class="s2">isExp </span><span class="s0">? </span><span class="s3">'0p+0' </span><span class="s0">: </span><span class="s3">'0'</span><span class="s0">;</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s2">i </span><span class="s0">&lt; </span><span class="s5">0</span><span class="s0">) {</span>
          <span class="s2">e</span><span class="s0">--;</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
          <span class="s2">x </span><span class="s0">= </span><span class="s1">new </span><span class="s2">Ctor</span><span class="s0">(</span><span class="s2">x</span><span class="s0">);</span>
          <span class="s2">x</span><span class="s0">.</span><span class="s2">d </span><span class="s0">= </span><span class="s2">xd</span><span class="s0">;</span>
          <span class="s2">x</span><span class="s0">.</span><span class="s2">e </span><span class="s0">= </span><span class="s2">e</span><span class="s0">;</span>
          <span class="s2">x </span><span class="s0">= </span><span class="s2">divide</span><span class="s0">(</span><span class="s2">x</span><span class="s0">, </span><span class="s2">y</span><span class="s0">, </span><span class="s2">sd</span><span class="s0">, </span><span class="s2">rm</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s2">base</span><span class="s0">);</span>
          <span class="s2">xd </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">d</span><span class="s0">;</span>
          <span class="s2">e </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">e</span><span class="s0">;</span>
          <span class="s2">roundUp </span><span class="s0">= </span><span class="s2">inexact</span><span class="s0">;</span>
        <span class="s0">}</span>

        <span class="s4">// The rounding digit, i.e. the digit after the digit that may be rounded up.</span>
        <span class="s2">i </span><span class="s0">= </span><span class="s2">xd</span><span class="s0">[</span><span class="s2">sd</span><span class="s0">];</span>
        <span class="s2">k </span><span class="s0">= </span><span class="s2">base </span><span class="s0">/ </span><span class="s5">2</span><span class="s0">;</span>
        <span class="s2">roundUp </span><span class="s0">= </span><span class="s2">roundUp </span><span class="s0">|| </span><span class="s2">xd</span><span class="s0">[</span><span class="s2">sd </span><span class="s0">+ </span><span class="s5">1</span><span class="s0">] !== </span><span class="s1">void </span><span class="s5">0</span><span class="s0">;</span>

        <span class="s2">roundUp </span><span class="s0">= </span><span class="s2">rm </span><span class="s0">&lt; </span><span class="s5">4</span>
          <span class="s0">? (</span><span class="s2">i </span><span class="s0">!== </span><span class="s1">void </span><span class="s5">0 </span><span class="s0">|| </span><span class="s2">roundUp</span><span class="s0">) &amp;&amp; (</span><span class="s2">rm </span><span class="s0">=== </span><span class="s5">0 </span><span class="s0">|| </span><span class="s2">rm </span><span class="s0">=== (</span><span class="s2">x</span><span class="s0">.</span><span class="s2">s </span><span class="s0">&lt; </span><span class="s5">0 </span><span class="s0">? </span><span class="s5">3 </span><span class="s0">: </span><span class="s5">2</span><span class="s0">))</span>
          <span class="s0">: </span><span class="s2">i </span><span class="s0">&gt; </span><span class="s2">k </span><span class="s0">|| </span><span class="s2">i </span><span class="s0">=== </span><span class="s2">k </span><span class="s0">&amp;&amp; (</span><span class="s2">rm </span><span class="s0">=== </span><span class="s5">4 </span><span class="s0">|| </span><span class="s2">roundUp </span><span class="s0">|| </span><span class="s2">rm </span><span class="s0">=== </span><span class="s5">6 </span><span class="s0">&amp;&amp; </span><span class="s2">xd</span><span class="s0">[</span><span class="s2">sd </span><span class="s0">- </span><span class="s5">1</span><span class="s0">] &amp; </span><span class="s5">1 </span><span class="s0">||</span>
            <span class="s2">rm </span><span class="s0">=== (</span><span class="s2">x</span><span class="s0">.</span><span class="s2">s </span><span class="s0">&lt; </span><span class="s5">0 </span><span class="s0">? </span><span class="s5">8 </span><span class="s0">: </span><span class="s5">7</span><span class="s0">));</span>

        <span class="s2">xd</span><span class="s0">.</span><span class="s2">length </span><span class="s0">= </span><span class="s2">sd</span><span class="s0">;</span>

        <span class="s1">if </span><span class="s0">(</span><span class="s2">roundUp</span><span class="s0">) {</span>

          <span class="s4">// Rounding up may mean the previous digit has to be rounded up and so on.</span>
          <span class="s1">for </span><span class="s0">(; ++</span><span class="s2">xd</span><span class="s0">[--</span><span class="s2">sd</span><span class="s0">] &gt; </span><span class="s2">base </span><span class="s0">- </span><span class="s5">1</span><span class="s0">;) {</span>
            <span class="s2">xd</span><span class="s0">[</span><span class="s2">sd</span><span class="s0">] = </span><span class="s5">0</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(!</span><span class="s2">sd</span><span class="s0">) {</span>
              <span class="s0">++</span><span class="s2">e</span><span class="s0">;</span>
              <span class="s2">xd</span><span class="s0">.</span><span class="s2">unshift</span><span class="s0">(</span><span class="s5">1</span><span class="s0">);</span>
            <span class="s0">}</span>
          <span class="s0">}</span>
        <span class="s0">}</span>

        <span class="s4">// Determine trailing zeros.</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s2">len </span><span class="s0">= </span><span class="s2">xd</span><span class="s0">.</span><span class="s2">length</span><span class="s0">; !</span><span class="s2">xd</span><span class="s0">[</span><span class="s2">len </span><span class="s0">- </span><span class="s5">1</span><span class="s0">]; --</span><span class="s2">len</span><span class="s0">);</span>

        <span class="s4">// E.g. [4, 11, 15] becomes 4bf.</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s2">i </span><span class="s0">= </span><span class="s5">0</span><span class="s0">, </span><span class="s2">str </span><span class="s0">= </span><span class="s3">''</span><span class="s0">; </span><span class="s2">i </span><span class="s0">&lt; </span><span class="s2">len</span><span class="s0">; </span><span class="s2">i</span><span class="s0">++) </span><span class="s2">str </span><span class="s0">+= </span><span class="s2">NUMERALS</span><span class="s0">.</span><span class="s2">charAt</span><span class="s0">(</span><span class="s2">xd</span><span class="s0">[</span><span class="s2">i</span><span class="s0">]);</span>

        <span class="s4">// Add binary exponent suffix?</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s2">isExp</span><span class="s0">) {</span>
          <span class="s1">if </span><span class="s0">(</span><span class="s2">len </span><span class="s0">&gt; </span><span class="s5">1</span><span class="s0">) {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s2">baseOut </span><span class="s0">== </span><span class="s5">16 </span><span class="s0">|| </span><span class="s2">baseOut </span><span class="s0">== </span><span class="s5">8</span><span class="s0">) {</span>
              <span class="s2">i </span><span class="s0">= </span><span class="s2">baseOut </span><span class="s0">== </span><span class="s5">16 </span><span class="s0">? </span><span class="s5">4 </span><span class="s0">: </span><span class="s5">3</span><span class="s0">;</span>
              <span class="s1">for </span><span class="s0">(--</span><span class="s2">len</span><span class="s0">; </span><span class="s2">len </span><span class="s0">% </span><span class="s2">i</span><span class="s0">; </span><span class="s2">len</span><span class="s0">++) </span><span class="s2">str </span><span class="s0">+= </span><span class="s3">'0'</span><span class="s0">;</span>
              <span class="s2">xd </span><span class="s0">= </span><span class="s2">convertBase</span><span class="s0">(</span><span class="s2">str</span><span class="s0">, </span><span class="s2">base</span><span class="s0">, </span><span class="s2">baseOut</span><span class="s0">);</span>
              <span class="s1">for </span><span class="s0">(</span><span class="s2">len </span><span class="s0">= </span><span class="s2">xd</span><span class="s0">.</span><span class="s2">length</span><span class="s0">; !</span><span class="s2">xd</span><span class="s0">[</span><span class="s2">len </span><span class="s0">- </span><span class="s5">1</span><span class="s0">]; --</span><span class="s2">len</span><span class="s0">);</span>

              <span class="s4">// xd[0] will always be be 1</span>
              <span class="s1">for </span><span class="s0">(</span><span class="s2">i </span><span class="s0">= </span><span class="s5">1</span><span class="s0">, </span><span class="s2">str </span><span class="s0">= </span><span class="s3">'1.'</span><span class="s0">; </span><span class="s2">i </span><span class="s0">&lt; </span><span class="s2">len</span><span class="s0">; </span><span class="s2">i</span><span class="s0">++) </span><span class="s2">str </span><span class="s0">+= </span><span class="s2">NUMERALS</span><span class="s0">.</span><span class="s2">charAt</span><span class="s0">(</span><span class="s2">xd</span><span class="s0">[</span><span class="s2">i</span><span class="s0">]);</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
              <span class="s2">str </span><span class="s0">= </span><span class="s2">str</span><span class="s0">.</span><span class="s2">charAt</span><span class="s0">(</span><span class="s5">0</span><span class="s0">) + </span><span class="s3">'.' </span><span class="s0">+ </span><span class="s2">str</span><span class="s0">.</span><span class="s2">slice</span><span class="s0">(</span><span class="s5">1</span><span class="s0">);</span>
            <span class="s0">}</span>
          <span class="s0">}</span>

          <span class="s2">str </span><span class="s0">=  </span><span class="s2">str </span><span class="s0">+ (</span><span class="s2">e </span><span class="s0">&lt; </span><span class="s5">0 </span><span class="s0">? </span><span class="s3">'p' </span><span class="s0">: </span><span class="s3">'p+'</span><span class="s0">) + </span><span class="s2">e</span><span class="s0">;</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(</span><span class="s2">e </span><span class="s0">&lt; </span><span class="s5">0</span><span class="s0">) {</span>
          <span class="s1">for </span><span class="s0">(; ++</span><span class="s2">e</span><span class="s0">;) </span><span class="s2">str </span><span class="s0">= </span><span class="s3">'0' </span><span class="s0">+ </span><span class="s2">str</span><span class="s0">;</span>
          <span class="s2">str </span><span class="s0">= </span><span class="s3">'0.' </span><span class="s0">+ </span><span class="s2">str</span><span class="s0">;</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
          <span class="s1">if </span><span class="s0">(++</span><span class="s2">e </span><span class="s0">&gt; </span><span class="s2">len</span><span class="s0">) </span><span class="s1">for </span><span class="s0">(</span><span class="s2">e </span><span class="s0">-= </span><span class="s2">len</span><span class="s0">; </span><span class="s2">e</span><span class="s0">-- ;) </span><span class="s2">str </span><span class="s0">+= </span><span class="s3">'0'</span><span class="s0">;</span>
          <span class="s1">else if </span><span class="s0">(</span><span class="s2">e </span><span class="s0">&lt; </span><span class="s2">len</span><span class="s0">) </span><span class="s2">str </span><span class="s0">= </span><span class="s2">str</span><span class="s0">.</span><span class="s2">slice</span><span class="s0">(</span><span class="s5">0</span><span class="s0">, </span><span class="s2">e</span><span class="s0">) + </span><span class="s3">'.' </span><span class="s0">+ </span><span class="s2">str</span><span class="s0">.</span><span class="s2">slice</span><span class="s0">(</span><span class="s2">e</span><span class="s0">);</span>
        <span class="s0">}</span>
      <span class="s0">}</span>

      <span class="s2">str </span><span class="s0">= (</span><span class="s2">baseOut </span><span class="s0">== </span><span class="s5">16 </span><span class="s0">? </span><span class="s3">'0x' </span><span class="s0">: </span><span class="s2">baseOut </span><span class="s0">== </span><span class="s5">2 </span><span class="s0">? </span><span class="s3">'0b' </span><span class="s0">: </span><span class="s2">baseOut </span><span class="s0">== </span><span class="s5">8 </span><span class="s0">? </span><span class="s3">'0o' </span><span class="s0">: </span><span class="s3">''</span><span class="s0">) + </span><span class="s2">str</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">return </span><span class="s2">x</span><span class="s0">.</span><span class="s2">s </span><span class="s0">&lt; </span><span class="s5">0 </span><span class="s0">? </span><span class="s3">'-' </span><span class="s0">+ </span><span class="s2">str </span><span class="s0">: </span><span class="s2">str</span><span class="s0">;</span>
  <span class="s0">}</span>


  <span class="s4">// Does not strip trailing zeros.</span>
  <span class="s1">function </span><span class="s2">truncate</span><span class="s0">(</span><span class="s2">arr</span><span class="s0">, </span><span class="s2">len</span><span class="s0">) {</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">arr</span><span class="s0">.</span><span class="s2">length </span><span class="s0">&gt; </span><span class="s2">len</span><span class="s0">) {</span>
      <span class="s2">arr</span><span class="s0">.</span><span class="s2">length </span><span class="s0">= </span><span class="s2">len</span><span class="s0">;</span>
      <span class="s1">return true</span><span class="s0">;</span>
    <span class="s0">}</span>
  <span class="s0">}</span>


  <span class="s4">// Decimal methods</span>


  <span class="s4">/* 
   *  abs 
   *  acos 
   *  acosh 
   *  add 
   *  asin 
   *  asinh 
   *  atan 
   *  atanh 
   *  atan2 
   *  cbrt 
   *  ceil 
   *  clamp 
   *  clone 
   *  config 
   *  cos 
   *  cosh 
   *  div 
   *  exp 
   *  floor 
   *  hypot 
   *  ln 
   *  log 
   *  log2 
   *  log10 
   *  max 
   *  min 
   *  mod 
   *  mul 
   *  pow 
   *  random 
   *  round 
   *  set 
   *  sign 
   *  sin 
   *  sinh 
   *  sqrt 
   *  sub 
   *  sum 
   *  tan 
   *  tanh 
   *  trunc 
   */</span>


  <span class="s4">/* 
   * Return a new Decimal whose value is the absolute value of `x`. 
   * 
   * x {number|string|bigint|Decimal} 
   * 
   */</span>
  <span class="s1">function </span><span class="s2">abs</span><span class="s0">(</span><span class="s2">x</span><span class="s0">) {</span>
    <span class="s1">return new this</span><span class="s0">(</span><span class="s2">x</span><span class="s0">).</span><span class="s2">abs</span><span class="s0">();</span>
  <span class="s0">}</span>


  <span class="s4">/* 
   * Return a new Decimal whose value is the arccosine in radians of `x`. 
   * 
   * x {number|string|bigint|Decimal} 
   * 
   */</span>
  <span class="s1">function </span><span class="s2">acos</span><span class="s0">(</span><span class="s2">x</span><span class="s0">) {</span>
    <span class="s1">return new this</span><span class="s0">(</span><span class="s2">x</span><span class="s0">).</span><span class="s2">acos</span><span class="s0">();</span>
  <span class="s0">}</span>


  <span class="s4">/* 
   * Return a new Decimal whose value is the inverse of the hyperbolic cosine of `x`, rounded to 
   * `precision` significant digits using rounding mode `rounding`. 
   * 
   * x {number|string|bigint|Decimal} A value in radians. 
   * 
   */</span>
  <span class="s1">function </span><span class="s2">acosh</span><span class="s0">(</span><span class="s2">x</span><span class="s0">) {</span>
    <span class="s1">return new this</span><span class="s0">(</span><span class="s2">x</span><span class="s0">).</span><span class="s2">acosh</span><span class="s0">();</span>
  <span class="s0">}</span>


  <span class="s4">/* 
   * Return a new Decimal whose value is the sum of `x` and `y`, rounded to `precision` significant 
   * digits using rounding mode `rounding`. 
   * 
   * x {number|string|bigint|Decimal} 
   * y {number|string|bigint|Decimal} 
   * 
   */</span>
  <span class="s1">function </span><span class="s2">add</span><span class="s0">(</span><span class="s2">x</span><span class="s0">, </span><span class="s2">y</span><span class="s0">) {</span>
    <span class="s1">return new this</span><span class="s0">(</span><span class="s2">x</span><span class="s0">).</span><span class="s2">plus</span><span class="s0">(</span><span class="s2">y</span><span class="s0">);</span>
  <span class="s0">}</span>


  <span class="s4">/* 
   * Return a new Decimal whose value is the arcsine in radians of `x`, rounded to `precision` 
   * significant digits using rounding mode `rounding`. 
   * 
   * x {number|string|bigint|Decimal} 
   * 
   */</span>
  <span class="s1">function </span><span class="s2">asin</span><span class="s0">(</span><span class="s2">x</span><span class="s0">) {</span>
    <span class="s1">return new this</span><span class="s0">(</span><span class="s2">x</span><span class="s0">).</span><span class="s2">asin</span><span class="s0">();</span>
  <span class="s0">}</span>


  <span class="s4">/* 
   * Return a new Decimal whose value is the inverse of the hyperbolic sine of `x`, rounded to 
   * `precision` significant digits using rounding mode `rounding`. 
   * 
   * x {number|string|bigint|Decimal} A value in radians. 
   * 
   */</span>
  <span class="s1">function </span><span class="s2">asinh</span><span class="s0">(</span><span class="s2">x</span><span class="s0">) {</span>
    <span class="s1">return new this</span><span class="s0">(</span><span class="s2">x</span><span class="s0">).</span><span class="s2">asinh</span><span class="s0">();</span>
  <span class="s0">}</span>


  <span class="s4">/* 
   * Return a new Decimal whose value is the arctangent in radians of `x`, rounded to `precision` 
   * significant digits using rounding mode `rounding`. 
   * 
   * x {number|string|bigint|Decimal} 
   * 
   */</span>
  <span class="s1">function </span><span class="s2">atan</span><span class="s0">(</span><span class="s2">x</span><span class="s0">) {</span>
    <span class="s1">return new this</span><span class="s0">(</span><span class="s2">x</span><span class="s0">).</span><span class="s2">atan</span><span class="s0">();</span>
  <span class="s0">}</span>


  <span class="s4">/* 
   * Return a new Decimal whose value is the inverse of the hyperbolic tangent of `x`, rounded to 
   * `precision` significant digits using rounding mode `rounding`. 
   * 
   * x {number|string|bigint|Decimal} A value in radians. 
   * 
   */</span>
  <span class="s1">function </span><span class="s2">atanh</span><span class="s0">(</span><span class="s2">x</span><span class="s0">) {</span>
    <span class="s1">return new this</span><span class="s0">(</span><span class="s2">x</span><span class="s0">).</span><span class="s2">atanh</span><span class="s0">();</span>
  <span class="s0">}</span>


  <span class="s4">/* 
   * Return a new Decimal whose value is the arctangent in radians of `y/x` in the range -pi to pi 
   * (inclusive), rounded to `precision` significant digits using rounding mode `rounding`. 
   * 
   * Domain: [-Infinity, Infinity] 
   * Range: [-pi, pi] 
   * 
   * y {number|string|bigint|Decimal} The y-coordinate. 
   * x {number|string|bigint|Decimal} The x-coordinate. 
   * 
   * atan2(±0, -0)               = ±pi 
   * atan2(±0, +0)               = ±0 
   * atan2(±0, -x)               = ±pi for x &gt; 0 
   * atan2(±0, x)                = ±0 for x &gt; 0 
   * atan2(-y, ±0)               = -pi/2 for y &gt; 0 
   * atan2(y, ±0)                = pi/2 for y &gt; 0 
   * atan2(±y, -Infinity)        = ±pi for finite y &gt; 0 
   * atan2(±y, +Infinity)        = ±0 for finite y &gt; 0 
   * atan2(±Infinity, x)         = ±pi/2 for finite x 
   * atan2(±Infinity, -Infinity) = ±3*pi/4 
   * atan2(±Infinity, +Infinity) = ±pi/4 
   * atan2(NaN, x) = NaN 
   * atan2(y, NaN) = NaN 
   * 
   */</span>
  <span class="s1">function </span><span class="s2">atan2</span><span class="s0">(</span><span class="s2">y</span><span class="s0">, </span><span class="s2">x</span><span class="s0">) {</span>
    <span class="s2">y </span><span class="s0">= </span><span class="s1">new this</span><span class="s0">(</span><span class="s2">y</span><span class="s0">);</span>
    <span class="s2">x </span><span class="s0">= </span><span class="s1">new this</span><span class="s0">(</span><span class="s2">x</span><span class="s0">);</span>
    <span class="s1">var </span><span class="s2">r</span><span class="s0">,</span>
      <span class="s2">pr </span><span class="s0">= </span><span class="s1">this</span><span class="s0">.</span><span class="s2">precision</span><span class="s0">,</span>
      <span class="s2">rm </span><span class="s0">= </span><span class="s1">this</span><span class="s0">.</span><span class="s2">rounding</span><span class="s0">,</span>
      <span class="s2">wpr </span><span class="s0">= </span><span class="s2">pr </span><span class="s0">+ </span><span class="s5">4</span><span class="s0">;</span>

    <span class="s4">// Either NaN</span>
    <span class="s1">if </span><span class="s0">(!</span><span class="s2">y</span><span class="s0">.</span><span class="s2">s </span><span class="s0">|| !</span><span class="s2">x</span><span class="s0">.</span><span class="s2">s</span><span class="s0">) {</span>
      <span class="s2">r </span><span class="s0">= </span><span class="s1">new this</span><span class="s0">(</span><span class="s2">NaN</span><span class="s0">);</span>

    <span class="s4">// Both ±Infinity</span>
    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(!</span><span class="s2">y</span><span class="s0">.</span><span class="s2">d </span><span class="s0">&amp;&amp; !</span><span class="s2">x</span><span class="s0">.</span><span class="s2">d</span><span class="s0">) {</span>
      <span class="s2">r </span><span class="s0">= </span><span class="s2">getPi</span><span class="s0">(</span><span class="s1">this</span><span class="s0">, </span><span class="s2">wpr</span><span class="s0">, </span><span class="s5">1</span><span class="s0">).</span><span class="s2">times</span><span class="s0">(</span><span class="s2">x</span><span class="s0">.</span><span class="s2">s </span><span class="s0">&gt; </span><span class="s5">0 </span><span class="s0">? </span><span class="s5">0.25 </span><span class="s0">: </span><span class="s5">0.75</span><span class="s0">);</span>
      <span class="s2">r</span><span class="s0">.</span><span class="s2">s </span><span class="s0">= </span><span class="s2">y</span><span class="s0">.</span><span class="s2">s</span><span class="s0">;</span>

    <span class="s4">// x is ±Infinity or y is ±0</span>
    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(!</span><span class="s2">x</span><span class="s0">.</span><span class="s2">d </span><span class="s0">|| </span><span class="s2">y</span><span class="s0">.</span><span class="s2">isZero</span><span class="s0">()) {</span>
      <span class="s2">r </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">s </span><span class="s0">&lt; </span><span class="s5">0 </span><span class="s0">? </span><span class="s2">getPi</span><span class="s0">(</span><span class="s1">this</span><span class="s0">, </span><span class="s2">pr</span><span class="s0">, </span><span class="s2">rm</span><span class="s0">) : </span><span class="s1">new this</span><span class="s0">(</span><span class="s5">0</span><span class="s0">);</span>
      <span class="s2">r</span><span class="s0">.</span><span class="s2">s </span><span class="s0">= </span><span class="s2">y</span><span class="s0">.</span><span class="s2">s</span><span class="s0">;</span>

    <span class="s4">// y is ±Infinity or x is ±0</span>
    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(!</span><span class="s2">y</span><span class="s0">.</span><span class="s2">d </span><span class="s0">|| </span><span class="s2">x</span><span class="s0">.</span><span class="s2">isZero</span><span class="s0">()) {</span>
      <span class="s2">r </span><span class="s0">= </span><span class="s2">getPi</span><span class="s0">(</span><span class="s1">this</span><span class="s0">, </span><span class="s2">wpr</span><span class="s0">, </span><span class="s5">1</span><span class="s0">).</span><span class="s2">times</span><span class="s0">(</span><span class="s5">0.5</span><span class="s0">);</span>
      <span class="s2">r</span><span class="s0">.</span><span class="s2">s </span><span class="s0">= </span><span class="s2">y</span><span class="s0">.</span><span class="s2">s</span><span class="s0">;</span>

    <span class="s4">// Both non-zero and finite</span>
    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(</span><span class="s2">x</span><span class="s0">.</span><span class="s2">s </span><span class="s0">&lt; </span><span class="s5">0</span><span class="s0">) {</span>
      <span class="s1">this</span><span class="s0">.</span><span class="s2">precision </span><span class="s0">= </span><span class="s2">wpr</span><span class="s0">;</span>
      <span class="s1">this</span><span class="s0">.</span><span class="s2">rounding </span><span class="s0">= </span><span class="s5">1</span><span class="s0">;</span>
      <span class="s2">r </span><span class="s0">= </span><span class="s1">this</span><span class="s0">.</span><span class="s2">atan</span><span class="s0">(</span><span class="s2">divide</span><span class="s0">(</span><span class="s2">y</span><span class="s0">, </span><span class="s2">x</span><span class="s0">, </span><span class="s2">wpr</span><span class="s0">, </span><span class="s5">1</span><span class="s0">));</span>
      <span class="s2">x </span><span class="s0">= </span><span class="s2">getPi</span><span class="s0">(</span><span class="s1">this</span><span class="s0">, </span><span class="s2">wpr</span><span class="s0">, </span><span class="s5">1</span><span class="s0">);</span>
      <span class="s1">this</span><span class="s0">.</span><span class="s2">precision </span><span class="s0">= </span><span class="s2">pr</span><span class="s0">;</span>
      <span class="s1">this</span><span class="s0">.</span><span class="s2">rounding </span><span class="s0">= </span><span class="s2">rm</span><span class="s0">;</span>
      <span class="s2">r </span><span class="s0">= </span><span class="s2">y</span><span class="s0">.</span><span class="s2">s </span><span class="s0">&lt; </span><span class="s5">0 </span><span class="s0">? </span><span class="s2">r</span><span class="s0">.</span><span class="s2">minus</span><span class="s0">(</span><span class="s2">x</span><span class="s0">) : </span><span class="s2">r</span><span class="s0">.</span><span class="s2">plus</span><span class="s0">(</span><span class="s2">x</span><span class="s0">);</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s2">r </span><span class="s0">= </span><span class="s1">this</span><span class="s0">.</span><span class="s2">atan</span><span class="s0">(</span><span class="s2">divide</span><span class="s0">(</span><span class="s2">y</span><span class="s0">, </span><span class="s2">x</span><span class="s0">, </span><span class="s2">wpr</span><span class="s0">, </span><span class="s5">1</span><span class="s0">));</span>
    <span class="s0">}</span>

    <span class="s1">return </span><span class="s2">r</span><span class="s0">;</span>
  <span class="s0">}</span>


  <span class="s4">/* 
   * Return a new Decimal whose value is the cube root of `x`, rounded to `precision` significant 
   * digits using rounding mode `rounding`. 
   * 
   * x {number|string|bigint|Decimal} 
   * 
   */</span>
  <span class="s1">function </span><span class="s2">cbrt</span><span class="s0">(</span><span class="s2">x</span><span class="s0">) {</span>
    <span class="s1">return new this</span><span class="s0">(</span><span class="s2">x</span><span class="s0">).</span><span class="s2">cbrt</span><span class="s0">();</span>
  <span class="s0">}</span>


  <span class="s4">/* 
   * Return a new Decimal whose value is `x` rounded to an integer using `ROUND_CEIL`. 
   * 
   * x {number|string|bigint|Decimal} 
   * 
   */</span>
  <span class="s1">function </span><span class="s2">ceil</span><span class="s0">(</span><span class="s2">x</span><span class="s0">) {</span>
    <span class="s1">return </span><span class="s2">finalise</span><span class="s0">(</span><span class="s2">x </span><span class="s0">= </span><span class="s1">new this</span><span class="s0">(</span><span class="s2">x</span><span class="s0">), </span><span class="s2">x</span><span class="s0">.</span><span class="s2">e </span><span class="s0">+ </span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">);</span>
  <span class="s0">}</span>


  <span class="s4">/* 
   * Return a new Decimal whose value is `x` clamped to the range delineated by `min` and `max`. 
   * 
   * x {number|string|bigint|Decimal} 
   * min {number|string|bigint|Decimal} 
   * max {number|string|bigint|Decimal} 
   * 
   */</span>
  <span class="s1">function </span><span class="s2">clamp</span><span class="s0">(</span><span class="s2">x</span><span class="s0">, </span><span class="s2">min</span><span class="s0">, </span><span class="s2">max</span><span class="s0">) {</span>
    <span class="s1">return new this</span><span class="s0">(</span><span class="s2">x</span><span class="s0">).</span><span class="s2">clamp</span><span class="s0">(</span><span class="s2">min</span><span class="s0">, </span><span class="s2">max</span><span class="s0">);</span>
  <span class="s0">}</span>


  <span class="s4">/* 
   * Configure global settings for a Decimal constructor. 
   * 
   * `obj` is an object with one or more of the following properties, 
   * 
   *   precision  {number} 
   *   rounding   {number} 
   *   toExpNeg   {number} 
   *   toExpPos   {number} 
   *   maxE       {number} 
   *   minE       {number} 
   *   modulo     {number} 
   *   crypto     {boolean|number} 
   *   defaults   {true} 
   * 
   * E.g. Decimal.config({ precision: 20, rounding: 4 }) 
   * 
   */</span>
  <span class="s1">function </span><span class="s2">config</span><span class="s0">(</span><span class="s2">obj</span><span class="s0">) {</span>
    <span class="s1">if </span><span class="s0">(!</span><span class="s2">obj </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s2">obj </span><span class="s0">!== </span><span class="s3">'object'</span><span class="s0">) </span><span class="s1">throw </span><span class="s2">Error</span><span class="s0">(</span><span class="s2">decimalError </span><span class="s0">+ </span><span class="s3">'Object expected'</span><span class="s0">);</span>
    <span class="s1">var </span><span class="s2">i</span><span class="s0">, </span><span class="s2">p</span><span class="s0">, </span><span class="s2">v</span><span class="s0">,</span>
      <span class="s2">useDefaults </span><span class="s0">= </span><span class="s2">obj</span><span class="s0">.</span><span class="s2">defaults </span><span class="s0">=== </span><span class="s1">true</span><span class="s0">,</span>
      <span class="s2">ps </span><span class="s0">= [</span>
        <span class="s3">'precision'</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s2">MAX_DIGITS</span><span class="s0">,</span>
        <span class="s3">'rounding'</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">8</span><span class="s0">,</span>
        <span class="s3">'toExpNeg'</span><span class="s0">, -</span><span class="s2">EXP_LIMIT</span><span class="s0">, </span><span class="s5">0</span><span class="s0">,</span>
        <span class="s3">'toExpPos'</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s2">EXP_LIMIT</span><span class="s0">,</span>
        <span class="s3">'maxE'</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s2">EXP_LIMIT</span><span class="s0">,</span>
        <span class="s3">'minE'</span><span class="s0">, -</span><span class="s2">EXP_LIMIT</span><span class="s0">, </span><span class="s5">0</span><span class="s0">,</span>
        <span class="s3">'modulo'</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">9</span>
      <span class="s0">];</span>

    <span class="s1">for </span><span class="s0">(</span><span class="s2">i </span><span class="s0">= </span><span class="s5">0</span><span class="s0">; </span><span class="s2">i </span><span class="s0">&lt; </span><span class="s2">ps</span><span class="s0">.</span><span class="s2">length</span><span class="s0">; </span><span class="s2">i </span><span class="s0">+= </span><span class="s5">3</span><span class="s0">) {</span>
      <span class="s1">if </span><span class="s0">(</span><span class="s2">p </span><span class="s0">= </span><span class="s2">ps</span><span class="s0">[</span><span class="s2">i</span><span class="s0">], </span><span class="s2">useDefaults</span><span class="s0">) </span><span class="s1">this</span><span class="s0">[</span><span class="s2">p</span><span class="s0">] = </span><span class="s2">DEFAULTS</span><span class="s0">[</span><span class="s2">p</span><span class="s0">];</span>
      <span class="s1">if </span><span class="s0">((</span><span class="s2">v </span><span class="s0">= </span><span class="s2">obj</span><span class="s0">[</span><span class="s2">p</span><span class="s0">]) !== </span><span class="s1">void </span><span class="s5">0</span><span class="s0">) {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s2">mathfloor</span><span class="s0">(</span><span class="s2">v</span><span class="s0">) === </span><span class="s2">v </span><span class="s0">&amp;&amp; </span><span class="s2">v </span><span class="s0">&gt;= </span><span class="s2">ps</span><span class="s0">[</span><span class="s2">i </span><span class="s0">+ </span><span class="s5">1</span><span class="s0">] &amp;&amp; </span><span class="s2">v </span><span class="s0">&lt;= </span><span class="s2">ps</span><span class="s0">[</span><span class="s2">i </span><span class="s0">+ </span><span class="s5">2</span><span class="s0">]) </span><span class="s1">this</span><span class="s0">[</span><span class="s2">p</span><span class="s0">] = </span><span class="s2">v</span><span class="s0">;</span>
        <span class="s1">else throw </span><span class="s2">Error</span><span class="s0">(</span><span class="s2">invalidArgument </span><span class="s0">+ </span><span class="s2">p </span><span class="s0">+ </span><span class="s3">': ' </span><span class="s0">+ </span><span class="s2">v</span><span class="s0">);</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(</span><span class="s2">p </span><span class="s0">= </span><span class="s3">'crypto'</span><span class="s0">, </span><span class="s2">useDefaults</span><span class="s0">) </span><span class="s1">this</span><span class="s0">[</span><span class="s2">p</span><span class="s0">] = </span><span class="s2">DEFAULTS</span><span class="s0">[</span><span class="s2">p</span><span class="s0">];</span>
    <span class="s1">if </span><span class="s0">((</span><span class="s2">v </span><span class="s0">= </span><span class="s2">obj</span><span class="s0">[</span><span class="s2">p</span><span class="s0">]) !== </span><span class="s1">void </span><span class="s5">0</span><span class="s0">) {</span>
      <span class="s1">if </span><span class="s0">(</span><span class="s2">v </span><span class="s0">=== </span><span class="s1">true </span><span class="s0">|| </span><span class="s2">v </span><span class="s0">=== </span><span class="s1">false </span><span class="s0">|| </span><span class="s2">v </span><span class="s0">=== </span><span class="s5">0 </span><span class="s0">|| </span><span class="s2">v </span><span class="s0">=== </span><span class="s5">1</span><span class="s0">) {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s2">v</span><span class="s0">) {</span>
          <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s2">crypto </span><span class="s0">!= </span><span class="s3">'undefined' </span><span class="s0">&amp;&amp; </span><span class="s2">crypto </span><span class="s0">&amp;&amp;</span>
            <span class="s0">(</span><span class="s2">crypto</span><span class="s0">.</span><span class="s2">getRandomValues </span><span class="s0">|| </span><span class="s2">crypto</span><span class="s0">.</span><span class="s2">randomBytes</span><span class="s0">)) {</span>
            <span class="s1">this</span><span class="s0">[</span><span class="s2">p</span><span class="s0">] = </span><span class="s1">true</span><span class="s0">;</span>
          <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s1">throw </span><span class="s2">Error</span><span class="s0">(</span><span class="s2">cryptoUnavailable</span><span class="s0">);</span>
          <span class="s0">}</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
          <span class="s1">this</span><span class="s0">[</span><span class="s2">p</span><span class="s0">] = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s0">}</span>
      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s1">throw </span><span class="s2">Error</span><span class="s0">(</span><span class="s2">invalidArgument </span><span class="s0">+ </span><span class="s2">p </span><span class="s0">+ </span><span class="s3">': ' </span><span class="s0">+ </span><span class="s2">v</span><span class="s0">);</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">return this</span><span class="s0">;</span>
  <span class="s0">}</span>


  <span class="s4">/* 
   * Return a new Decimal whose value is the cosine of `x`, rounded to `precision` significant 
   * digits using rounding mode `rounding`. 
   * 
   * x {number|string|bigint|Decimal} A value in radians. 
   * 
   */</span>
  <span class="s1">function </span><span class="s2">cos</span><span class="s0">(</span><span class="s2">x</span><span class="s0">) {</span>
    <span class="s1">return new this</span><span class="s0">(</span><span class="s2">x</span><span class="s0">).</span><span class="s2">cos</span><span class="s0">();</span>
  <span class="s0">}</span>


  <span class="s4">/* 
   * Return a new Decimal whose value is the hyperbolic cosine of `x`, rounded to precision 
   * significant digits using rounding mode `rounding`. 
   * 
   * x {number|string|bigint|Decimal} A value in radians. 
   * 
   */</span>
  <span class="s1">function </span><span class="s2">cosh</span><span class="s0">(</span><span class="s2">x</span><span class="s0">) {</span>
    <span class="s1">return new this</span><span class="s0">(</span><span class="s2">x</span><span class="s0">).</span><span class="s2">cosh</span><span class="s0">();</span>
  <span class="s0">}</span>


  <span class="s4">/* 
   * Create and return a Decimal constructor with the same configuration properties as this Decimal 
   * constructor. 
   * 
   */</span>
  <span class="s1">function </span><span class="s2">clone</span><span class="s0">(</span><span class="s2">obj</span><span class="s0">) {</span>
    <span class="s1">var </span><span class="s2">i</span><span class="s0">, </span><span class="s2">p</span><span class="s0">, </span><span class="s2">ps</span><span class="s0">;</span>

    <span class="s4">/* 
     * The Decimal constructor and exported function. 
     * Return a new Decimal instance. 
     * 
     * v {number|string|bigint|Decimal} A numeric value. 
     * 
     */</span>
    <span class="s1">function </span><span class="s2">Decimal</span><span class="s0">(</span><span class="s2">v</span><span class="s0">) {</span>
      <span class="s1">var </span><span class="s2">e</span><span class="s0">, </span><span class="s2">i</span><span class="s0">, </span><span class="s2">t</span><span class="s0">,</span>
        <span class="s2">x </span><span class="s0">= </span><span class="s1">this</span><span class="s0">;</span>

      <span class="s4">// Decimal called without new.</span>
      <span class="s1">if </span><span class="s0">(!(</span><span class="s2">x </span><span class="s1">instanceof </span><span class="s2">Decimal</span><span class="s0">)) </span><span class="s1">return new </span><span class="s2">Decimal</span><span class="s0">(</span><span class="s2">v</span><span class="s0">);</span>

      <span class="s4">// Retain a reference to this Decimal constructor, and shadow Decimal.prototype.constructor</span>
      <span class="s4">// which points to Object.</span>
      <span class="s2">x</span><span class="s0">.</span><span class="s2">constructor </span><span class="s0">= </span><span class="s2">Decimal</span><span class="s0">;</span>

      <span class="s1">if </span><span class="s0">(</span><span class="s2">isDecimalInstance</span><span class="s0">(</span><span class="s2">v</span><span class="s0">)) {</span>
        <span class="s2">x</span><span class="s0">.</span><span class="s2">s </span><span class="s0">= </span><span class="s2">v</span><span class="s0">.</span><span class="s2">s</span><span class="s0">;</span>

        <span class="s1">if </span><span class="s0">(</span><span class="s2">external</span><span class="s0">) {</span>
          <span class="s1">if </span><span class="s0">(!</span><span class="s2">v</span><span class="s0">.</span><span class="s2">d </span><span class="s0">|| </span><span class="s2">v</span><span class="s0">.</span><span class="s2">e </span><span class="s0">&gt; </span><span class="s2">Decimal</span><span class="s0">.</span><span class="s2">maxE</span><span class="s0">) {</span>

            <span class="s4">// Infinity.</span>
            <span class="s2">x</span><span class="s0">.</span><span class="s2">e </span><span class="s0">= </span><span class="s2">NaN</span><span class="s0">;</span>
            <span class="s2">x</span><span class="s0">.</span><span class="s2">d </span><span class="s0">= </span><span class="s1">null</span><span class="s0">;</span>
          <span class="s0">} </span><span class="s1">else if </span><span class="s0">(</span><span class="s2">v</span><span class="s0">.</span><span class="s2">e </span><span class="s0">&lt; </span><span class="s2">Decimal</span><span class="s0">.</span><span class="s2">minE</span><span class="s0">) {</span>

            <span class="s4">// Zero.</span>
            <span class="s2">x</span><span class="s0">.</span><span class="s2">e </span><span class="s0">= </span><span class="s5">0</span><span class="s0">;</span>
            <span class="s2">x</span><span class="s0">.</span><span class="s2">d </span><span class="s0">= [</span><span class="s5">0</span><span class="s0">];</span>
          <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s2">x</span><span class="s0">.</span><span class="s2">e </span><span class="s0">= </span><span class="s2">v</span><span class="s0">.</span><span class="s2">e</span><span class="s0">;</span>
            <span class="s2">x</span><span class="s0">.</span><span class="s2">d </span><span class="s0">= </span><span class="s2">v</span><span class="s0">.</span><span class="s2">d</span><span class="s0">.</span><span class="s2">slice</span><span class="s0">();</span>
          <span class="s0">}</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
          <span class="s2">x</span><span class="s0">.</span><span class="s2">e </span><span class="s0">= </span><span class="s2">v</span><span class="s0">.</span><span class="s2">e</span><span class="s0">;</span>
          <span class="s2">x</span><span class="s0">.</span><span class="s2">d </span><span class="s0">= </span><span class="s2">v</span><span class="s0">.</span><span class="s2">d </span><span class="s0">? </span><span class="s2">v</span><span class="s0">.</span><span class="s2">d</span><span class="s0">.</span><span class="s2">slice</span><span class="s0">() : </span><span class="s2">v</span><span class="s0">.</span><span class="s2">d</span><span class="s0">;</span>
        <span class="s0">}</span>

        <span class="s1">return</span><span class="s0">;</span>
      <span class="s0">}</span>

      <span class="s2">t </span><span class="s0">= </span><span class="s1">typeof </span><span class="s2">v</span><span class="s0">;</span>

      <span class="s1">if </span><span class="s0">(</span><span class="s2">t </span><span class="s0">=== </span><span class="s3">'number'</span><span class="s0">) {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s2">v </span><span class="s0">=== </span><span class="s5">0</span><span class="s0">) {</span>
          <span class="s2">x</span><span class="s0">.</span><span class="s2">s </span><span class="s0">= </span><span class="s5">1 </span><span class="s0">/ </span><span class="s2">v </span><span class="s0">&lt; </span><span class="s5">0 </span><span class="s0">? -</span><span class="s5">1 </span><span class="s0">: </span><span class="s5">1</span><span class="s0">;</span>
          <span class="s2">x</span><span class="s0">.</span><span class="s2">e </span><span class="s0">= </span><span class="s5">0</span><span class="s0">;</span>
          <span class="s2">x</span><span class="s0">.</span><span class="s2">d </span><span class="s0">= [</span><span class="s5">0</span><span class="s0">];</span>
          <span class="s1">return</span><span class="s0">;</span>
        <span class="s0">}</span>

        <span class="s1">if </span><span class="s0">(</span><span class="s2">v </span><span class="s0">&lt; </span><span class="s5">0</span><span class="s0">) {</span>
          <span class="s2">v </span><span class="s0">= -</span><span class="s2">v</span><span class="s0">;</span>
          <span class="s2">x</span><span class="s0">.</span><span class="s2">s </span><span class="s0">= -</span><span class="s5">1</span><span class="s0">;</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
          <span class="s2">x</span><span class="s0">.</span><span class="s2">s </span><span class="s0">= </span><span class="s5">1</span><span class="s0">;</span>
        <span class="s0">}</span>

        <span class="s4">// Fast path for small integers.</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s2">v </span><span class="s0">=== ~~</span><span class="s2">v </span><span class="s0">&amp;&amp; </span><span class="s2">v </span><span class="s0">&lt; </span><span class="s5">1e7</span><span class="s0">) {</span>
          <span class="s1">for </span><span class="s0">(</span><span class="s2">e </span><span class="s0">= </span><span class="s5">0</span><span class="s0">, </span><span class="s2">i </span><span class="s0">= </span><span class="s2">v</span><span class="s0">; </span><span class="s2">i </span><span class="s0">&gt;= </span><span class="s5">10</span><span class="s0">; </span><span class="s2">i </span><span class="s0">/= </span><span class="s5">10</span><span class="s0">) </span><span class="s2">e</span><span class="s0">++;</span>

          <span class="s1">if </span><span class="s0">(</span><span class="s2">external</span><span class="s0">) {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s2">e </span><span class="s0">&gt; </span><span class="s2">Decimal</span><span class="s0">.</span><span class="s2">maxE</span><span class="s0">) {</span>
              <span class="s2">x</span><span class="s0">.</span><span class="s2">e </span><span class="s0">= </span><span class="s2">NaN</span><span class="s0">;</span>
              <span class="s2">x</span><span class="s0">.</span><span class="s2">d </span><span class="s0">= </span><span class="s1">null</span><span class="s0">;</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(</span><span class="s2">e </span><span class="s0">&lt; </span><span class="s2">Decimal</span><span class="s0">.</span><span class="s2">minE</span><span class="s0">) {</span>
              <span class="s2">x</span><span class="s0">.</span><span class="s2">e </span><span class="s0">= </span><span class="s5">0</span><span class="s0">;</span>
              <span class="s2">x</span><span class="s0">.</span><span class="s2">d </span><span class="s0">= [</span><span class="s5">0</span><span class="s0">];</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
              <span class="s2">x</span><span class="s0">.</span><span class="s2">e </span><span class="s0">= </span><span class="s2">e</span><span class="s0">;</span>
              <span class="s2">x</span><span class="s0">.</span><span class="s2">d </span><span class="s0">= [</span><span class="s2">v</span><span class="s0">];</span>
            <span class="s0">}</span>
          <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s2">x</span><span class="s0">.</span><span class="s2">e </span><span class="s0">= </span><span class="s2">e</span><span class="s0">;</span>
            <span class="s2">x</span><span class="s0">.</span><span class="s2">d </span><span class="s0">= [</span><span class="s2">v</span><span class="s0">];</span>
          <span class="s0">}</span>

          <span class="s1">return</span><span class="s0">;</span>
        <span class="s0">}</span>

        <span class="s4">// Infinity or NaN?</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s2">v </span><span class="s0">* </span><span class="s5">0 </span><span class="s0">!== </span><span class="s5">0</span><span class="s0">) {</span>
          <span class="s1">if </span><span class="s0">(!</span><span class="s2">v</span><span class="s0">) </span><span class="s2">x</span><span class="s0">.</span><span class="s2">s </span><span class="s0">= </span><span class="s2">NaN</span><span class="s0">;</span>
          <span class="s2">x</span><span class="s0">.</span><span class="s2">e </span><span class="s0">= </span><span class="s2">NaN</span><span class="s0">;</span>
          <span class="s2">x</span><span class="s0">.</span><span class="s2">d </span><span class="s0">= </span><span class="s1">null</span><span class="s0">;</span>
          <span class="s1">return</span><span class="s0">;</span>
        <span class="s0">}</span>

        <span class="s1">return </span><span class="s2">parseDecimal</span><span class="s0">(</span><span class="s2">x</span><span class="s0">, </span><span class="s2">v</span><span class="s0">.</span><span class="s2">toString</span><span class="s0">());</span>
      <span class="s0">}</span>

      <span class="s1">if </span><span class="s0">(</span><span class="s2">t </span><span class="s0">=== </span><span class="s3">'string'</span><span class="s0">) {</span>
        <span class="s1">if </span><span class="s0">((</span><span class="s2">i </span><span class="s0">= </span><span class="s2">v</span><span class="s0">.</span><span class="s2">charCodeAt</span><span class="s0">(</span><span class="s5">0</span><span class="s0">)) === </span><span class="s5">45</span><span class="s0">) {  </span><span class="s4">// minus sign</span>
          <span class="s2">v </span><span class="s0">= </span><span class="s2">v</span><span class="s0">.</span><span class="s2">slice</span><span class="s0">(</span><span class="s5">1</span><span class="s0">);</span>
          <span class="s2">x</span><span class="s0">.</span><span class="s2">s </span><span class="s0">= -</span><span class="s5">1</span><span class="s0">;</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
          <span class="s1">if </span><span class="s0">(</span><span class="s2">i </span><span class="s0">=== </span><span class="s5">43</span><span class="s0">) </span><span class="s2">v </span><span class="s0">= </span><span class="s2">v</span><span class="s0">.</span><span class="s2">slice</span><span class="s0">(</span><span class="s5">1</span><span class="s0">);  </span><span class="s4">// plus sign</span>
          <span class="s2">x</span><span class="s0">.</span><span class="s2">s </span><span class="s0">= </span><span class="s5">1</span><span class="s0">;</span>
        <span class="s0">}</span>

        <span class="s1">return </span><span class="s2">isDecimal</span><span class="s0">.</span><span class="s2">test</span><span class="s0">(</span><span class="s2">v</span><span class="s0">) ? </span><span class="s2">parseDecimal</span><span class="s0">(</span><span class="s2">x</span><span class="s0">, </span><span class="s2">v</span><span class="s0">) : </span><span class="s2">parseOther</span><span class="s0">(</span><span class="s2">x</span><span class="s0">, </span><span class="s2">v</span><span class="s0">);</span>
      <span class="s0">}</span>

      <span class="s1">if </span><span class="s0">(</span><span class="s2">t </span><span class="s0">=== </span><span class="s3">'bigint'</span><span class="s0">) {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s2">v </span><span class="s0">&lt; </span><span class="s5">0</span><span class="s0">) {</span>
          <span class="s2">v </span><span class="s0">= -</span><span class="s2">v</span><span class="s0">;</span>
          <span class="s2">x</span><span class="s0">.</span><span class="s2">s </span><span class="s0">= -</span><span class="s5">1</span><span class="s0">;</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
          <span class="s2">x</span><span class="s0">.</span><span class="s2">s </span><span class="s0">= </span><span class="s5">1</span><span class="s0">;</span>
        <span class="s0">}</span>

        <span class="s1">return </span><span class="s2">parseDecimal</span><span class="s0">(</span><span class="s2">x</span><span class="s0">, </span><span class="s2">v</span><span class="s0">.</span><span class="s2">toString</span><span class="s0">());</span>
      <span class="s0">}</span>

      <span class="s1">throw </span><span class="s2">Error</span><span class="s0">(</span><span class="s2">invalidArgument </span><span class="s0">+ </span><span class="s2">v</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s2">Decimal</span><span class="s0">.</span><span class="s2">prototype </span><span class="s0">= </span><span class="s2">P</span><span class="s0">;</span>

    <span class="s2">Decimal</span><span class="s0">.</span><span class="s2">ROUND_UP </span><span class="s0">= </span><span class="s5">0</span><span class="s0">;</span>
    <span class="s2">Decimal</span><span class="s0">.</span><span class="s2">ROUND_DOWN </span><span class="s0">= </span><span class="s5">1</span><span class="s0">;</span>
    <span class="s2">Decimal</span><span class="s0">.</span><span class="s2">ROUND_CEIL </span><span class="s0">= </span><span class="s5">2</span><span class="s0">;</span>
    <span class="s2">Decimal</span><span class="s0">.</span><span class="s2">ROUND_FLOOR </span><span class="s0">= </span><span class="s5">3</span><span class="s0">;</span>
    <span class="s2">Decimal</span><span class="s0">.</span><span class="s2">ROUND_HALF_UP </span><span class="s0">= </span><span class="s5">4</span><span class="s0">;</span>
    <span class="s2">Decimal</span><span class="s0">.</span><span class="s2">ROUND_HALF_DOWN </span><span class="s0">= </span><span class="s5">5</span><span class="s0">;</span>
    <span class="s2">Decimal</span><span class="s0">.</span><span class="s2">ROUND_HALF_EVEN </span><span class="s0">= </span><span class="s5">6</span><span class="s0">;</span>
    <span class="s2">Decimal</span><span class="s0">.</span><span class="s2">ROUND_HALF_CEIL </span><span class="s0">= </span><span class="s5">7</span><span class="s0">;</span>
    <span class="s2">Decimal</span><span class="s0">.</span><span class="s2">ROUND_HALF_FLOOR </span><span class="s0">= </span><span class="s5">8</span><span class="s0">;</span>
    <span class="s2">Decimal</span><span class="s0">.</span><span class="s2">EUCLID </span><span class="s0">= </span><span class="s5">9</span><span class="s0">;</span>

    <span class="s2">Decimal</span><span class="s0">.</span><span class="s2">config </span><span class="s0">= </span><span class="s2">Decimal</span><span class="s0">.</span><span class="s2">set </span><span class="s0">= </span><span class="s2">config</span><span class="s0">;</span>
    <span class="s2">Decimal</span><span class="s0">.</span><span class="s2">clone </span><span class="s0">= </span><span class="s2">clone</span><span class="s0">;</span>
    <span class="s2">Decimal</span><span class="s0">.</span><span class="s2">isDecimal </span><span class="s0">= </span><span class="s2">isDecimalInstance</span><span class="s0">;</span>

    <span class="s2">Decimal</span><span class="s0">.</span><span class="s2">abs </span><span class="s0">= </span><span class="s2">abs</span><span class="s0">;</span>
    <span class="s2">Decimal</span><span class="s0">.</span><span class="s2">acos </span><span class="s0">= </span><span class="s2">acos</span><span class="s0">;</span>
    <span class="s2">Decimal</span><span class="s0">.</span><span class="s2">acosh </span><span class="s0">= </span><span class="s2">acosh</span><span class="s0">;        </span><span class="s4">// ES6</span>
    <span class="s2">Decimal</span><span class="s0">.</span><span class="s2">add </span><span class="s0">= </span><span class="s2">add</span><span class="s0">;</span>
    <span class="s2">Decimal</span><span class="s0">.</span><span class="s2">asin </span><span class="s0">= </span><span class="s2">asin</span><span class="s0">;</span>
    <span class="s2">Decimal</span><span class="s0">.</span><span class="s2">asinh </span><span class="s0">= </span><span class="s2">asinh</span><span class="s0">;        </span><span class="s4">// ES6</span>
    <span class="s2">Decimal</span><span class="s0">.</span><span class="s2">atan </span><span class="s0">= </span><span class="s2">atan</span><span class="s0">;</span>
    <span class="s2">Decimal</span><span class="s0">.</span><span class="s2">atanh </span><span class="s0">= </span><span class="s2">atanh</span><span class="s0">;        </span><span class="s4">// ES6</span>
    <span class="s2">Decimal</span><span class="s0">.</span><span class="s2">atan2 </span><span class="s0">= </span><span class="s2">atan2</span><span class="s0">;</span>
    <span class="s2">Decimal</span><span class="s0">.</span><span class="s2">cbrt </span><span class="s0">= </span><span class="s2">cbrt</span><span class="s0">;          </span><span class="s4">// ES6</span>
    <span class="s2">Decimal</span><span class="s0">.</span><span class="s2">ceil </span><span class="s0">= </span><span class="s2">ceil</span><span class="s0">;</span>
    <span class="s2">Decimal</span><span class="s0">.</span><span class="s2">clamp </span><span class="s0">= </span><span class="s2">clamp</span><span class="s0">;</span>
    <span class="s2">Decimal</span><span class="s0">.</span><span class="s2">cos </span><span class="s0">= </span><span class="s2">cos</span><span class="s0">;</span>
    <span class="s2">Decimal</span><span class="s0">.</span><span class="s2">cosh </span><span class="s0">= </span><span class="s2">cosh</span><span class="s0">;          </span><span class="s4">// ES6</span>
    <span class="s2">Decimal</span><span class="s0">.</span><span class="s2">div </span><span class="s0">= </span><span class="s2">div</span><span class="s0">;</span>
    <span class="s2">Decimal</span><span class="s0">.</span><span class="s2">exp </span><span class="s0">= </span><span class="s2">exp</span><span class="s0">;</span>
    <span class="s2">Decimal</span><span class="s0">.</span><span class="s2">floor </span><span class="s0">= </span><span class="s2">floor</span><span class="s0">;</span>
    <span class="s2">Decimal</span><span class="s0">.</span><span class="s2">hypot </span><span class="s0">= </span><span class="s2">hypot</span><span class="s0">;        </span><span class="s4">// ES6</span>
    <span class="s2">Decimal</span><span class="s0">.</span><span class="s2">ln </span><span class="s0">= </span><span class="s2">ln</span><span class="s0">;</span>
    <span class="s2">Decimal</span><span class="s0">.</span><span class="s2">log </span><span class="s0">= </span><span class="s2">log</span><span class="s0">;</span>
    <span class="s2">Decimal</span><span class="s0">.</span><span class="s2">log10 </span><span class="s0">= </span><span class="s2">log10</span><span class="s0">;        </span><span class="s4">// ES6</span>
    <span class="s2">Decimal</span><span class="s0">.</span><span class="s2">log2 </span><span class="s0">= </span><span class="s2">log2</span><span class="s0">;          </span><span class="s4">// ES6</span>
    <span class="s2">Decimal</span><span class="s0">.</span><span class="s2">max </span><span class="s0">= </span><span class="s2">max</span><span class="s0">;</span>
    <span class="s2">Decimal</span><span class="s0">.</span><span class="s2">min </span><span class="s0">= </span><span class="s2">min</span><span class="s0">;</span>
    <span class="s2">Decimal</span><span class="s0">.</span><span class="s2">mod </span><span class="s0">= </span><span class="s2">mod</span><span class="s0">;</span>
    <span class="s2">Decimal</span><span class="s0">.</span><span class="s2">mul </span><span class="s0">= </span><span class="s2">mul</span><span class="s0">;</span>
    <span class="s2">Decimal</span><span class="s0">.</span><span class="s2">pow </span><span class="s0">= </span><span class="s2">pow</span><span class="s0">;</span>
    <span class="s2">Decimal</span><span class="s0">.</span><span class="s2">random </span><span class="s0">= </span><span class="s2">random</span><span class="s0">;</span>
    <span class="s2">Decimal</span><span class="s0">.</span><span class="s2">round </span><span class="s0">= </span><span class="s2">round</span><span class="s0">;</span>
    <span class="s2">Decimal</span><span class="s0">.</span><span class="s2">sign </span><span class="s0">= </span><span class="s2">sign</span><span class="s0">;          </span><span class="s4">// ES6</span>
    <span class="s2">Decimal</span><span class="s0">.</span><span class="s2">sin </span><span class="s0">= </span><span class="s2">sin</span><span class="s0">;</span>
    <span class="s2">Decimal</span><span class="s0">.</span><span class="s2">sinh </span><span class="s0">= </span><span class="s2">sinh</span><span class="s0">;          </span><span class="s4">// ES6</span>
    <span class="s2">Decimal</span><span class="s0">.</span><span class="s2">sqrt </span><span class="s0">= </span><span class="s2">sqrt</span><span class="s0">;</span>
    <span class="s2">Decimal</span><span class="s0">.</span><span class="s2">sub </span><span class="s0">= </span><span class="s2">sub</span><span class="s0">;</span>
    <span class="s2">Decimal</span><span class="s0">.</span><span class="s2">sum </span><span class="s0">= </span><span class="s2">sum</span><span class="s0">;</span>
    <span class="s2">Decimal</span><span class="s0">.</span><span class="s2">tan </span><span class="s0">= </span><span class="s2">tan</span><span class="s0">;</span>
    <span class="s2">Decimal</span><span class="s0">.</span><span class="s2">tanh </span><span class="s0">= </span><span class="s2">tanh</span><span class="s0">;          </span><span class="s4">// ES6</span>
    <span class="s2">Decimal</span><span class="s0">.</span><span class="s2">trunc </span><span class="s0">= </span><span class="s2">trunc</span><span class="s0">;        </span><span class="s4">// ES6</span>

    <span class="s1">if </span><span class="s0">(</span><span class="s2">obj </span><span class="s0">=== </span><span class="s1">void </span><span class="s5">0</span><span class="s0">) </span><span class="s2">obj </span><span class="s0">= {};</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">obj</span><span class="s0">) {</span>
      <span class="s1">if </span><span class="s0">(</span><span class="s2">obj</span><span class="s0">.</span><span class="s2">defaults </span><span class="s0">!== </span><span class="s1">true</span><span class="s0">) {</span>
        <span class="s2">ps </span><span class="s0">= [</span><span class="s3">'precision'</span><span class="s0">, </span><span class="s3">'rounding'</span><span class="s0">, </span><span class="s3">'toExpNeg'</span><span class="s0">, </span><span class="s3">'toExpPos'</span><span class="s0">, </span><span class="s3">'maxE'</span><span class="s0">, </span><span class="s3">'minE'</span><span class="s0">, </span><span class="s3">'modulo'</span><span class="s0">, </span><span class="s3">'crypto'</span><span class="s0">];</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s2">i </span><span class="s0">= </span><span class="s5">0</span><span class="s0">; </span><span class="s2">i </span><span class="s0">&lt; </span><span class="s2">ps</span><span class="s0">.</span><span class="s2">length</span><span class="s0">;) </span><span class="s1">if </span><span class="s0">(!</span><span class="s2">obj</span><span class="s0">.</span><span class="s2">hasOwnProperty</span><span class="s0">(</span><span class="s2">p </span><span class="s0">= </span><span class="s2">ps</span><span class="s0">[</span><span class="s2">i</span><span class="s0">++])) </span><span class="s2">obj</span><span class="s0">[</span><span class="s2">p</span><span class="s0">] = </span><span class="s1">this</span><span class="s0">[</span><span class="s2">p</span><span class="s0">];</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s2">Decimal</span><span class="s0">.</span><span class="s2">config</span><span class="s0">(</span><span class="s2">obj</span><span class="s0">);</span>

    <span class="s1">return </span><span class="s2">Decimal</span><span class="s0">;</span>
  <span class="s0">}</span>


  <span class="s4">/* 
   * Return a new Decimal whose value is `x` divided by `y`, rounded to `precision` significant 
   * digits using rounding mode `rounding`. 
   * 
   * x {number|string|bigint|Decimal} 
   * y {number|string|bigint|Decimal} 
   * 
   */</span>
  <span class="s1">function </span><span class="s2">div</span><span class="s0">(</span><span class="s2">x</span><span class="s0">, </span><span class="s2">y</span><span class="s0">) {</span>
    <span class="s1">return new this</span><span class="s0">(</span><span class="s2">x</span><span class="s0">).</span><span class="s2">div</span><span class="s0">(</span><span class="s2">y</span><span class="s0">);</span>
  <span class="s0">}</span>


  <span class="s4">/* 
   * Return a new Decimal whose value is the natural exponential of `x`, rounded to `precision` 
   * significant digits using rounding mode `rounding`. 
   * 
   * x {number|string|bigint|Decimal} The power to which to raise the base of the natural log. 
   * 
   */</span>
  <span class="s1">function </span><span class="s2">exp</span><span class="s0">(</span><span class="s2">x</span><span class="s0">) {</span>
    <span class="s1">return new this</span><span class="s0">(</span><span class="s2">x</span><span class="s0">).</span><span class="s2">exp</span><span class="s0">();</span>
  <span class="s0">}</span>


  <span class="s4">/* 
   * Return a new Decimal whose value is `x` round to an integer using `ROUND_FLOOR`. 
   * 
   * x {number|string|bigint|Decimal} 
   * 
   */</span>
  <span class="s1">function </span><span class="s2">floor</span><span class="s0">(</span><span class="s2">x</span><span class="s0">) {</span>
    <span class="s1">return </span><span class="s2">finalise</span><span class="s0">(</span><span class="s2">x </span><span class="s0">= </span><span class="s1">new this</span><span class="s0">(</span><span class="s2">x</span><span class="s0">), </span><span class="s2">x</span><span class="s0">.</span><span class="s2">e </span><span class="s0">+ </span><span class="s5">1</span><span class="s0">, </span><span class="s5">3</span><span class="s0">);</span>
  <span class="s0">}</span>


  <span class="s4">/* 
   * Return a new Decimal whose value is the square root of the sum of the squares of the arguments, 
   * rounded to `precision` significant digits using rounding mode `rounding`. 
   * 
   * hypot(a, b, ...) = sqrt(a^2 + b^2 + ...) 
   * 
   * arguments {number|string|bigint|Decimal} 
   * 
   */</span>
  <span class="s1">function </span><span class="s2">hypot</span><span class="s0">() {</span>
    <span class="s1">var </span><span class="s2">i</span><span class="s0">, </span><span class="s2">n</span><span class="s0">,</span>
      <span class="s2">t </span><span class="s0">= </span><span class="s1">new this</span><span class="s0">(</span><span class="s5">0</span><span class="s0">);</span>

    <span class="s2">external </span><span class="s0">= </span><span class="s1">false</span><span class="s0">;</span>

    <span class="s1">for </span><span class="s0">(</span><span class="s2">i </span><span class="s0">= </span><span class="s5">0</span><span class="s0">; </span><span class="s2">i </span><span class="s0">&lt; </span><span class="s2">arguments</span><span class="s0">.</span><span class="s2">length</span><span class="s0">;) {</span>
      <span class="s2">n </span><span class="s0">= </span><span class="s1">new this</span><span class="s0">(</span><span class="s2">arguments</span><span class="s0">[</span><span class="s2">i</span><span class="s0">++]);</span>
      <span class="s1">if </span><span class="s0">(!</span><span class="s2">n</span><span class="s0">.</span><span class="s2">d</span><span class="s0">) {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s2">n</span><span class="s0">.</span><span class="s2">s</span><span class="s0">) {</span>
          <span class="s2">external </span><span class="s0">= </span><span class="s1">true</span><span class="s0">;</span>
          <span class="s1">return new this</span><span class="s0">(</span><span class="s5">1 </span><span class="s0">/ </span><span class="s5">0</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s2">t </span><span class="s0">= </span><span class="s2">n</span><span class="s0">;</span>
      <span class="s0">} </span><span class="s1">else if </span><span class="s0">(</span><span class="s2">t</span><span class="s0">.</span><span class="s2">d</span><span class="s0">) {</span>
        <span class="s2">t </span><span class="s0">= </span><span class="s2">t</span><span class="s0">.</span><span class="s2">plus</span><span class="s0">(</span><span class="s2">n</span><span class="s0">.</span><span class="s2">times</span><span class="s0">(</span><span class="s2">n</span><span class="s0">));</span>
      <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s2">external </span><span class="s0">= </span><span class="s1">true</span><span class="s0">;</span>

    <span class="s1">return </span><span class="s2">t</span><span class="s0">.</span><span class="s2">sqrt</span><span class="s0">();</span>
  <span class="s0">}</span>


  <span class="s4">/* 
   * Return true if object is a Decimal instance (where Decimal is any Decimal constructor), 
   * otherwise return false. 
   * 
   */</span>
  <span class="s1">function </span><span class="s2">isDecimalInstance</span><span class="s0">(</span><span class="s2">obj</span><span class="s0">) {</span>
    <span class="s1">return </span><span class="s2">obj </span><span class="s1">instanceof </span><span class="s2">Decimal </span><span class="s0">|| </span><span class="s2">obj </span><span class="s0">&amp;&amp; </span><span class="s2">obj</span><span class="s0">.</span><span class="s2">toStringTag </span><span class="s0">=== </span><span class="s2">tag </span><span class="s0">|| </span><span class="s1">false</span><span class="s0">;</span>
  <span class="s0">}</span>


  <span class="s4">/* 
   * Return a new Decimal whose value is the natural logarithm of `x`, rounded to `precision` 
   * significant digits using rounding mode `rounding`. 
   * 
   * x {number|string|bigint|Decimal} 
   * 
   */</span>
  <span class="s1">function </span><span class="s2">ln</span><span class="s0">(</span><span class="s2">x</span><span class="s0">) {</span>
    <span class="s1">return new this</span><span class="s0">(</span><span class="s2">x</span><span class="s0">).</span><span class="s2">ln</span><span class="s0">();</span>
  <span class="s0">}</span>


  <span class="s4">/* 
   * Return a new Decimal whose value is the log of `x` to the base `y`, or to base 10 if no base 
   * is specified, rounded to `precision` significant digits using rounding mode `rounding`. 
   * 
   * log[y](x) 
   * 
   * x {number|string|bigint|Decimal} The argument of the logarithm. 
   * y {number|string|bigint|Decimal} The base of the logarithm. 
   * 
   */</span>
  <span class="s1">function </span><span class="s2">log</span><span class="s0">(</span><span class="s2">x</span><span class="s0">, </span><span class="s2">y</span><span class="s0">) {</span>
    <span class="s1">return new this</span><span class="s0">(</span><span class="s2">x</span><span class="s0">).</span><span class="s2">log</span><span class="s0">(</span><span class="s2">y</span><span class="s0">);</span>
  <span class="s0">}</span>


  <span class="s4">/* 
   * Return a new Decimal whose value is the base 2 logarithm of `x`, rounded to `precision` 
   * significant digits using rounding mode `rounding`. 
   * 
   * x {number|string|bigint|Decimal} 
   * 
   */</span>
  <span class="s1">function </span><span class="s2">log2</span><span class="s0">(</span><span class="s2">x</span><span class="s0">) {</span>
    <span class="s1">return new this</span><span class="s0">(</span><span class="s2">x</span><span class="s0">).</span><span class="s2">log</span><span class="s0">(</span><span class="s5">2</span><span class="s0">);</span>
  <span class="s0">}</span>


  <span class="s4">/* 
   * Return a new Decimal whose value is the base 10 logarithm of `x`, rounded to `precision` 
   * significant digits using rounding mode `rounding`. 
   * 
   * x {number|string|bigint|Decimal} 
   * 
   */</span>
  <span class="s1">function </span><span class="s2">log10</span><span class="s0">(</span><span class="s2">x</span><span class="s0">) {</span>
    <span class="s1">return new this</span><span class="s0">(</span><span class="s2">x</span><span class="s0">).</span><span class="s2">log</span><span class="s0">(</span><span class="s5">10</span><span class="s0">);</span>
  <span class="s0">}</span>


  <span class="s4">/* 
   * Return a new Decimal whose value is the maximum of the arguments. 
   * 
   * arguments {number|string|bigint|Decimal} 
   * 
   */</span>
  <span class="s1">function </span><span class="s2">max</span><span class="s0">() {</span>
    <span class="s1">return </span><span class="s2">maxOrMin</span><span class="s0">(</span><span class="s1">this</span><span class="s0">, </span><span class="s2">arguments</span><span class="s0">, -</span><span class="s5">1</span><span class="s0">);</span>
  <span class="s0">}</span>


  <span class="s4">/* 
   * Return a new Decimal whose value is the minimum of the arguments. 
   * 
   * arguments {number|string|bigint|Decimal} 
   * 
   */</span>
  <span class="s1">function </span><span class="s2">min</span><span class="s0">() {</span>
    <span class="s1">return </span><span class="s2">maxOrMin</span><span class="s0">(</span><span class="s1">this</span><span class="s0">, </span><span class="s2">arguments</span><span class="s0">, </span><span class="s5">1</span><span class="s0">);</span>
  <span class="s0">}</span>


  <span class="s4">/* 
   * Return a new Decimal whose value is `x` modulo `y`, rounded to `precision` significant digits 
   * using rounding mode `rounding`. 
   * 
   * x {number|string|bigint|Decimal} 
   * y {number|string|bigint|Decimal} 
   * 
   */</span>
  <span class="s1">function </span><span class="s2">mod</span><span class="s0">(</span><span class="s2">x</span><span class="s0">, </span><span class="s2">y</span><span class="s0">) {</span>
    <span class="s1">return new this</span><span class="s0">(</span><span class="s2">x</span><span class="s0">).</span><span class="s2">mod</span><span class="s0">(</span><span class="s2">y</span><span class="s0">);</span>
  <span class="s0">}</span>


  <span class="s4">/* 
   * Return a new Decimal whose value is `x` multiplied by `y`, rounded to `precision` significant 
   * digits using rounding mode `rounding`. 
   * 
   * x {number|string|bigint|Decimal} 
   * y {number|string|bigint|Decimal} 
   * 
   */</span>
  <span class="s1">function </span><span class="s2">mul</span><span class="s0">(</span><span class="s2">x</span><span class="s0">, </span><span class="s2">y</span><span class="s0">) {</span>
    <span class="s1">return new this</span><span class="s0">(</span><span class="s2">x</span><span class="s0">).</span><span class="s2">mul</span><span class="s0">(</span><span class="s2">y</span><span class="s0">);</span>
  <span class="s0">}</span>


  <span class="s4">/* 
   * Return a new Decimal whose value is `x` raised to the power `y`, rounded to precision 
   * significant digits using rounding mode `rounding`. 
   * 
   * x {number|string|bigint|Decimal} The base. 
   * y {number|string|bigint|Decimal} The exponent. 
   * 
   */</span>
  <span class="s1">function </span><span class="s2">pow</span><span class="s0">(</span><span class="s2">x</span><span class="s0">, </span><span class="s2">y</span><span class="s0">) {</span>
    <span class="s1">return new this</span><span class="s0">(</span><span class="s2">x</span><span class="s0">).</span><span class="s2">pow</span><span class="s0">(</span><span class="s2">y</span><span class="s0">);</span>
  <span class="s0">}</span>


  <span class="s4">/* 
   * Returns a new Decimal with a random value equal to or greater than 0 and less than 1, and with 
   * `sd`, or `Decimal.precision` if `sd` is omitted, significant digits (or less if trailing zeros 
   * are produced). 
   * 
   * [sd] {number} Significant digits. Integer, 0 to MAX_DIGITS inclusive. 
   * 
   */</span>
  <span class="s1">function </span><span class="s2">random</span><span class="s0">(</span><span class="s2">sd</span><span class="s0">) {</span>
    <span class="s1">var </span><span class="s2">d</span><span class="s0">, </span><span class="s2">e</span><span class="s0">, </span><span class="s2">k</span><span class="s0">, </span><span class="s2">n</span><span class="s0">,</span>
      <span class="s2">i </span><span class="s0">= </span><span class="s5">0</span><span class="s0">,</span>
      <span class="s2">r </span><span class="s0">= </span><span class="s1">new this</span><span class="s0">(</span><span class="s5">1</span><span class="s0">),</span>
      <span class="s2">rd </span><span class="s0">= [];</span>

    <span class="s1">if </span><span class="s0">(</span><span class="s2">sd </span><span class="s0">=== </span><span class="s1">void </span><span class="s5">0</span><span class="s0">) </span><span class="s2">sd </span><span class="s0">= </span><span class="s1">this</span><span class="s0">.</span><span class="s2">precision</span><span class="s0">;</span>
    <span class="s1">else </span><span class="s2">checkInt32</span><span class="s0">(</span><span class="s2">sd</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s2">MAX_DIGITS</span><span class="s0">);</span>

    <span class="s2">k </span><span class="s0">= </span><span class="s2">Math</span><span class="s0">.</span><span class="s2">ceil</span><span class="s0">(</span><span class="s2">sd </span><span class="s0">/ </span><span class="s2">LOG_BASE</span><span class="s0">);</span>

    <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.</span><span class="s2">crypto</span><span class="s0">) {</span>
      <span class="s1">for </span><span class="s0">(; </span><span class="s2">i </span><span class="s0">&lt; </span><span class="s2">k</span><span class="s0">;) </span><span class="s2">rd</span><span class="s0">[</span><span class="s2">i</span><span class="s0">++] = </span><span class="s2">Math</span><span class="s0">.</span><span class="s2">random</span><span class="s0">() * </span><span class="s5">1e7 </span><span class="s0">| </span><span class="s5">0</span><span class="s0">;</span>

    <span class="s4">// Browsers supporting crypto.getRandomValues.</span>
    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(</span><span class="s2">crypto</span><span class="s0">.</span><span class="s2">getRandomValues</span><span class="s0">) {</span>
      <span class="s2">d </span><span class="s0">= </span><span class="s2">crypto</span><span class="s0">.</span><span class="s2">getRandomValues</span><span class="s0">(</span><span class="s1">new </span><span class="s2">Uint32Array</span><span class="s0">(</span><span class="s2">k</span><span class="s0">));</span>

      <span class="s1">for </span><span class="s0">(; </span><span class="s2">i </span><span class="s0">&lt; </span><span class="s2">k</span><span class="s0">;) {</span>
        <span class="s2">n </span><span class="s0">= </span><span class="s2">d</span><span class="s0">[</span><span class="s2">i</span><span class="s0">];</span>

        <span class="s4">// 0 &lt;= n &lt; 4294967296</span>
        <span class="s4">// Probability n &gt;= 4.29e9, is 4967296 / 4294967296 = 0.00116 (1 in 865).</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s2">n </span><span class="s0">&gt;= </span><span class="s5">4.29e9</span><span class="s0">) {</span>
          <span class="s2">d</span><span class="s0">[</span><span class="s2">i</span><span class="s0">] = </span><span class="s2">crypto</span><span class="s0">.</span><span class="s2">getRandomValues</span><span class="s0">(</span><span class="s1">new </span><span class="s2">Uint32Array</span><span class="s0">(</span><span class="s5">1</span><span class="s0">))[</span><span class="s5">0</span><span class="s0">];</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>

          <span class="s4">// 0 &lt;= n &lt;= 4289999999</span>
          <span class="s4">// 0 &lt;= (n % 1e7) &lt;= 9999999</span>
          <span class="s2">rd</span><span class="s0">[</span><span class="s2">i</span><span class="s0">++] = </span><span class="s2">n </span><span class="s0">% </span><span class="s5">1e7</span><span class="s0">;</span>
        <span class="s0">}</span>
      <span class="s0">}</span>

    <span class="s4">// Node.js supporting crypto.randomBytes.</span>
    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(</span><span class="s2">crypto</span><span class="s0">.</span><span class="s2">randomBytes</span><span class="s0">) {</span>

      <span class="s4">// buffer</span>
      <span class="s2">d </span><span class="s0">= </span><span class="s2">crypto</span><span class="s0">.</span><span class="s2">randomBytes</span><span class="s0">(</span><span class="s2">k </span><span class="s0">*= </span><span class="s5">4</span><span class="s0">);</span>

      <span class="s1">for </span><span class="s0">(; </span><span class="s2">i </span><span class="s0">&lt; </span><span class="s2">k</span><span class="s0">;) {</span>

        <span class="s4">// 0 &lt;= n &lt; 2147483648</span>
        <span class="s2">n </span><span class="s0">= </span><span class="s2">d</span><span class="s0">[</span><span class="s2">i</span><span class="s0">] + (</span><span class="s2">d</span><span class="s0">[</span><span class="s2">i </span><span class="s0">+ </span><span class="s5">1</span><span class="s0">] &lt;&lt; </span><span class="s5">8</span><span class="s0">) + (</span><span class="s2">d</span><span class="s0">[</span><span class="s2">i </span><span class="s0">+ </span><span class="s5">2</span><span class="s0">] &lt;&lt; </span><span class="s5">16</span><span class="s0">) + ((</span><span class="s2">d</span><span class="s0">[</span><span class="s2">i </span><span class="s0">+ </span><span class="s5">3</span><span class="s0">] &amp; </span><span class="s5">0x7f</span><span class="s0">) &lt;&lt; </span><span class="s5">24</span><span class="s0">);</span>

        <span class="s4">// Probability n &gt;= 2.14e9, is 7483648 / 2147483648 = 0.0035 (1 in 286).</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s2">n </span><span class="s0">&gt;= </span><span class="s5">2.14e9</span><span class="s0">) {</span>
          <span class="s2">crypto</span><span class="s0">.</span><span class="s2">randomBytes</span><span class="s0">(</span><span class="s5">4</span><span class="s0">).</span><span class="s2">copy</span><span class="s0">(</span><span class="s2">d</span><span class="s0">, </span><span class="s2">i</span><span class="s0">);</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>

          <span class="s4">// 0 &lt;= n &lt;= 2139999999</span>
          <span class="s4">// 0 &lt;= (n % 1e7) &lt;= 9999999</span>
          <span class="s2">rd</span><span class="s0">.</span><span class="s2">push</span><span class="s0">(</span><span class="s2">n </span><span class="s0">% </span><span class="s5">1e7</span><span class="s0">);</span>
          <span class="s2">i </span><span class="s0">+= </span><span class="s5">4</span><span class="s0">;</span>
        <span class="s0">}</span>
      <span class="s0">}</span>

      <span class="s2">i </span><span class="s0">= </span><span class="s2">k </span><span class="s0">/ </span><span class="s5">4</span><span class="s0">;</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s1">throw </span><span class="s2">Error</span><span class="s0">(</span><span class="s2">cryptoUnavailable</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s2">k </span><span class="s0">= </span><span class="s2">rd</span><span class="s0">[--</span><span class="s2">i</span><span class="s0">];</span>
    <span class="s2">sd </span><span class="s0">%= </span><span class="s2">LOG_BASE</span><span class="s0">;</span>

    <span class="s4">// Convert trailing digits to zeros according to sd.</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">k </span><span class="s0">&amp;&amp; </span><span class="s2">sd</span><span class="s0">) {</span>
      <span class="s2">n </span><span class="s0">= </span><span class="s2">mathpow</span><span class="s0">(</span><span class="s5">10</span><span class="s0">, </span><span class="s2">LOG_BASE </span><span class="s0">- </span><span class="s2">sd</span><span class="s0">);</span>
      <span class="s2">rd</span><span class="s0">[</span><span class="s2">i</span><span class="s0">] = (</span><span class="s2">k </span><span class="s0">/ </span><span class="s2">n </span><span class="s0">| </span><span class="s5">0</span><span class="s0">) * </span><span class="s2">n</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s4">// Remove trailing words which are zero.</span>
    <span class="s1">for </span><span class="s0">(; </span><span class="s2">rd</span><span class="s0">[</span><span class="s2">i</span><span class="s0">] === </span><span class="s5">0</span><span class="s0">; </span><span class="s2">i</span><span class="s0">--) </span><span class="s2">rd</span><span class="s0">.</span><span class="s2">pop</span><span class="s0">();</span>

    <span class="s4">// Zero?</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">i </span><span class="s0">&lt; </span><span class="s5">0</span><span class="s0">) {</span>
      <span class="s2">e </span><span class="s0">= </span><span class="s5">0</span><span class="s0">;</span>
      <span class="s2">rd </span><span class="s0">= [</span><span class="s5">0</span><span class="s0">];</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
      <span class="s2">e </span><span class="s0">= -</span><span class="s5">1</span><span class="s0">;</span>

      <span class="s4">// Remove leading words which are zero and adjust exponent accordingly.</span>
      <span class="s1">for </span><span class="s0">(; </span><span class="s2">rd</span><span class="s0">[</span><span class="s5">0</span><span class="s0">] === </span><span class="s5">0</span><span class="s0">; </span><span class="s2">e </span><span class="s0">-= </span><span class="s2">LOG_BASE</span><span class="s0">) </span><span class="s2">rd</span><span class="s0">.</span><span class="s2">shift</span><span class="s0">();</span>

      <span class="s4">// Count the digits of the first word of rd to determine leading zeros.</span>
      <span class="s1">for </span><span class="s0">(</span><span class="s2">k </span><span class="s0">= </span><span class="s5">1</span><span class="s0">, </span><span class="s2">n </span><span class="s0">= </span><span class="s2">rd</span><span class="s0">[</span><span class="s5">0</span><span class="s0">]; </span><span class="s2">n </span><span class="s0">&gt;= </span><span class="s5">10</span><span class="s0">; </span><span class="s2">n </span><span class="s0">/= </span><span class="s5">10</span><span class="s0">) </span><span class="s2">k</span><span class="s0">++;</span>

      <span class="s4">// Adjust the exponent for leading zeros of the first word of rd.</span>
      <span class="s1">if </span><span class="s0">(</span><span class="s2">k </span><span class="s0">&lt; </span><span class="s2">LOG_BASE</span><span class="s0">) </span><span class="s2">e </span><span class="s0">-= </span><span class="s2">LOG_BASE </span><span class="s0">- </span><span class="s2">k</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s2">r</span><span class="s0">.</span><span class="s2">e </span><span class="s0">= </span><span class="s2">e</span><span class="s0">;</span>
    <span class="s2">r</span><span class="s0">.</span><span class="s2">d </span><span class="s0">= </span><span class="s2">rd</span><span class="s0">;</span>

    <span class="s1">return </span><span class="s2">r</span><span class="s0">;</span>
  <span class="s0">}</span>


  <span class="s4">/* 
   * Return a new Decimal whose value is `x` rounded to an integer using rounding mode `rounding`. 
   * 
   * To emulate `Math.round`, set rounding to 7 (ROUND_HALF_CEIL). 
   * 
   * x {number|string|bigint|Decimal} 
   * 
   */</span>
  <span class="s1">function </span><span class="s2">round</span><span class="s0">(</span><span class="s2">x</span><span class="s0">) {</span>
    <span class="s1">return </span><span class="s2">finalise</span><span class="s0">(</span><span class="s2">x </span><span class="s0">= </span><span class="s1">new this</span><span class="s0">(</span><span class="s2">x</span><span class="s0">), </span><span class="s2">x</span><span class="s0">.</span><span class="s2">e </span><span class="s0">+ </span><span class="s5">1</span><span class="s0">, </span><span class="s1">this</span><span class="s0">.</span><span class="s2">rounding</span><span class="s0">);</span>
  <span class="s0">}</span>


  <span class="s4">/* 
   * Return 
   *   1    if x &gt; 0, 
   *  -1    if x &lt; 0, 
   *   0    if x is 0, 
   *  -0    if x is -0, 
   *   NaN  otherwise 
   * 
   * x {number|string|bigint|Decimal} 
   * 
   */</span>
  <span class="s1">function </span><span class="s2">sign</span><span class="s0">(</span><span class="s2">x</span><span class="s0">) {</span>
    <span class="s2">x </span><span class="s0">= </span><span class="s1">new this</span><span class="s0">(</span><span class="s2">x</span><span class="s0">);</span>
    <span class="s1">return </span><span class="s2">x</span><span class="s0">.</span><span class="s2">d </span><span class="s0">? (</span><span class="s2">x</span><span class="s0">.</span><span class="s2">d</span><span class="s0">[</span><span class="s5">0</span><span class="s0">] ? </span><span class="s2">x</span><span class="s0">.</span><span class="s2">s </span><span class="s0">: </span><span class="s5">0 </span><span class="s0">* </span><span class="s2">x</span><span class="s0">.</span><span class="s2">s</span><span class="s0">) : </span><span class="s2">x</span><span class="s0">.</span><span class="s2">s </span><span class="s0">|| </span><span class="s2">NaN</span><span class="s0">;</span>
  <span class="s0">}</span>


  <span class="s4">/* 
   * Return a new Decimal whose value is the sine of `x`, rounded to `precision` significant digits 
   * using rounding mode `rounding`. 
   * 
   * x {number|string|bigint|Decimal} A value in radians. 
   * 
   */</span>
  <span class="s1">function </span><span class="s2">sin</span><span class="s0">(</span><span class="s2">x</span><span class="s0">) {</span>
    <span class="s1">return new this</span><span class="s0">(</span><span class="s2">x</span><span class="s0">).</span><span class="s2">sin</span><span class="s0">();</span>
  <span class="s0">}</span>


  <span class="s4">/* 
   * Return a new Decimal whose value is the hyperbolic sine of `x`, rounded to `precision` 
   * significant digits using rounding mode `rounding`. 
   * 
   * x {number|string|bigint|Decimal} A value in radians. 
   * 
   */</span>
  <span class="s1">function </span><span class="s2">sinh</span><span class="s0">(</span><span class="s2">x</span><span class="s0">) {</span>
    <span class="s1">return new this</span><span class="s0">(</span><span class="s2">x</span><span class="s0">).</span><span class="s2">sinh</span><span class="s0">();</span>
  <span class="s0">}</span>


  <span class="s4">/* 
   * Return a new Decimal whose value is the square root of `x`, rounded to `precision` significant 
   * digits using rounding mode `rounding`. 
   * 
   * x {number|string|bigint|Decimal} 
   * 
   */</span>
  <span class="s1">function </span><span class="s2">sqrt</span><span class="s0">(</span><span class="s2">x</span><span class="s0">) {</span>
    <span class="s1">return new this</span><span class="s0">(</span><span class="s2">x</span><span class="s0">).</span><span class="s2">sqrt</span><span class="s0">();</span>
  <span class="s0">}</span>


  <span class="s4">/* 
   * Return a new Decimal whose value is `x` minus `y`, rounded to `precision` significant digits 
   * using rounding mode `rounding`. 
   * 
   * x {number|string|bigint|Decimal} 
   * y {number|string|bigint|Decimal} 
   * 
   */</span>
  <span class="s1">function </span><span class="s2">sub</span><span class="s0">(</span><span class="s2">x</span><span class="s0">, </span><span class="s2">y</span><span class="s0">) {</span>
    <span class="s1">return new this</span><span class="s0">(</span><span class="s2">x</span><span class="s0">).</span><span class="s2">sub</span><span class="s0">(</span><span class="s2">y</span><span class="s0">);</span>
  <span class="s0">}</span>


  <span class="s4">/* 
   * Return a new Decimal whose value is the sum of the arguments, rounded to `precision` 
   * significant digits using rounding mode `rounding`. 
   * 
   * Only the result is rounded, not the intermediate calculations. 
   * 
   * arguments {number|string|bigint|Decimal} 
   * 
   */</span>
  <span class="s1">function </span><span class="s2">sum</span><span class="s0">() {</span>
    <span class="s1">var </span><span class="s2">i </span><span class="s0">= </span><span class="s5">0</span><span class="s0">,</span>
      <span class="s2">args </span><span class="s0">= </span><span class="s2">arguments</span><span class="s0">,</span>
      <span class="s2">x </span><span class="s0">= </span><span class="s1">new this</span><span class="s0">(</span><span class="s2">args</span><span class="s0">[</span><span class="s2">i</span><span class="s0">]);</span>

    <span class="s2">external </span><span class="s0">= </span><span class="s1">false</span><span class="s0">;</span>
    <span class="s1">for </span><span class="s0">(; </span><span class="s2">x</span><span class="s0">.</span><span class="s2">s </span><span class="s0">&amp;&amp; ++</span><span class="s2">i </span><span class="s0">&lt; </span><span class="s2">args</span><span class="s0">.</span><span class="s2">length</span><span class="s0">;) </span><span class="s2">x </span><span class="s0">= </span><span class="s2">x</span><span class="s0">.</span><span class="s2">plus</span><span class="s0">(</span><span class="s2">args</span><span class="s0">[</span><span class="s2">i</span><span class="s0">]);</span>
    <span class="s2">external </span><span class="s0">= </span><span class="s1">true</span><span class="s0">;</span>

    <span class="s1">return </span><span class="s2">finalise</span><span class="s0">(</span><span class="s2">x</span><span class="s0">, </span><span class="s1">this</span><span class="s0">.</span><span class="s2">precision</span><span class="s0">, </span><span class="s1">this</span><span class="s0">.</span><span class="s2">rounding</span><span class="s0">);</span>
  <span class="s0">}</span>


  <span class="s4">/* 
   * Return a new Decimal whose value is the tangent of `x`, rounded to `precision` significant 
   * digits using rounding mode `rounding`. 
   * 
   * x {number|string|bigint|Decimal} A value in radians. 
   * 
   */</span>
  <span class="s1">function </span><span class="s2">tan</span><span class="s0">(</span><span class="s2">x</span><span class="s0">) {</span>
    <span class="s1">return new this</span><span class="s0">(</span><span class="s2">x</span><span class="s0">).</span><span class="s2">tan</span><span class="s0">();</span>
  <span class="s0">}</span>


  <span class="s4">/* 
   * Return a new Decimal whose value is the hyperbolic tangent of `x`, rounded to `precision` 
   * significant digits using rounding mode `rounding`. 
   * 
   * x {number|string|bigint|Decimal} A value in radians. 
   * 
   */</span>
  <span class="s1">function </span><span class="s2">tanh</span><span class="s0">(</span><span class="s2">x</span><span class="s0">) {</span>
    <span class="s1">return new this</span><span class="s0">(</span><span class="s2">x</span><span class="s0">).</span><span class="s2">tanh</span><span class="s0">();</span>
  <span class="s0">}</span>


  <span class="s4">/* 
   * Return a new Decimal whose value is `x` truncated to an integer. 
   * 
   * x {number|string|bigint|Decimal} 
   * 
   */</span>
  <span class="s1">function </span><span class="s2">trunc</span><span class="s0">(</span><span class="s2">x</span><span class="s0">) {</span>
    <span class="s1">return </span><span class="s2">finalise</span><span class="s0">(</span><span class="s2">x </span><span class="s0">= </span><span class="s1">new this</span><span class="s0">(</span><span class="s2">x</span><span class="s0">), </span><span class="s2">x</span><span class="s0">.</span><span class="s2">e </span><span class="s0">+ </span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s0">);</span>
  <span class="s0">}</span>


  <span class="s4">// Create and configure initial Decimal constructor.</span>
  <span class="s2">Decimal </span><span class="s0">= </span><span class="s2">clone</span><span class="s0">(</span><span class="s2">DEFAULTS</span><span class="s0">);</span>
  <span class="s2">Decimal</span><span class="s0">.</span><span class="s2">prototype</span><span class="s0">.</span><span class="s2">constructor </span><span class="s0">= </span><span class="s2">Decimal</span><span class="s0">;</span>
  <span class="s2">Decimal</span><span class="s0">[</span><span class="s3">'default'</span><span class="s0">] = </span><span class="s2">Decimal</span><span class="s0">.</span><span class="s2">Decimal </span><span class="s0">= </span><span class="s2">Decimal</span><span class="s0">;</span>

  <span class="s4">// Create the internal constants from their string values.</span>
  <span class="s2">LN10 </span><span class="s0">= </span><span class="s1">new </span><span class="s2">Decimal</span><span class="s0">(</span><span class="s2">LN10</span><span class="s0">);</span>
  <span class="s2">PI </span><span class="s0">= </span><span class="s1">new </span><span class="s2">Decimal</span><span class="s0">(</span><span class="s2">PI</span><span class="s0">);</span>


  <span class="s4">// Export.</span>


  <span class="s4">// AMD.</span>
  <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s2">define </span><span class="s0">== </span><span class="s3">'function' </span><span class="s0">&amp;&amp; </span><span class="s2">define</span><span class="s0">.</span><span class="s2">amd</span><span class="s0">) {</span>
    <span class="s2">define</span><span class="s0">(</span><span class="s1">function </span><span class="s0">() {</span>
      <span class="s1">return </span><span class="s2">Decimal</span><span class="s0">;</span>
    <span class="s0">});</span>

  <span class="s4">// Node and other environments that support module.exports.</span>
  <span class="s0">} </span><span class="s1">else if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s2">module </span><span class="s0">!= </span><span class="s3">'undefined' </span><span class="s0">&amp;&amp; </span><span class="s2">module</span><span class="s0">.</span><span class="s2">exports</span><span class="s0">) {</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s2">Symbol </span><span class="s0">== </span><span class="s3">'function' </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s2">Symbol</span><span class="s0">.</span><span class="s2">iterator </span><span class="s0">== </span><span class="s3">'symbol'</span><span class="s0">) {</span>
      <span class="s2">P</span><span class="s0">[</span><span class="s2">Symbol</span><span class="s0">[</span><span class="s3">'for'</span><span class="s0">](</span><span class="s3">'nodejs.util.inspect.custom'</span><span class="s0">)] = </span><span class="s2">P</span><span class="s0">.</span><span class="s2">toString</span><span class="s0">;</span>
      <span class="s2">P</span><span class="s0">[</span><span class="s2">Symbol</span><span class="s0">.</span><span class="s2">toStringTag</span><span class="s0">] = </span><span class="s3">'Decimal'</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s2">module</span><span class="s0">.</span><span class="s2">exports </span><span class="s0">= </span><span class="s2">Decimal</span><span class="s0">;</span>

  <span class="s4">// Browser.</span>
  <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
    <span class="s1">if </span><span class="s0">(!</span><span class="s2">globalScope</span><span class="s0">) {</span>
      <span class="s2">globalScope </span><span class="s0">= </span><span class="s1">typeof </span><span class="s2">self </span><span class="s0">!= </span><span class="s3">'undefined' </span><span class="s0">&amp;&amp; </span><span class="s2">self </span><span class="s0">&amp;&amp; </span><span class="s2">self</span><span class="s0">.</span><span class="s2">self </span><span class="s0">== </span><span class="s2">self </span><span class="s0">? </span><span class="s2">self </span><span class="s0">: </span><span class="s2">window</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s2">noConflict </span><span class="s0">= </span><span class="s2">globalScope</span><span class="s0">.</span><span class="s2">Decimal</span><span class="s0">;</span>
    <span class="s2">Decimal</span><span class="s0">.</span><span class="s2">noConflict </span><span class="s0">= </span><span class="s1">function </span><span class="s0">() {</span>
      <span class="s2">globalScope</span><span class="s0">.</span><span class="s2">Decimal </span><span class="s0">= </span><span class="s2">noConflict</span><span class="s0">;</span>
      <span class="s1">return </span><span class="s2">Decimal</span><span class="s0">;</span>
    <span class="s0">};</span>

    <span class="s2">globalScope</span><span class="s0">.</span><span class="s2">Decimal </span><span class="s0">= </span><span class="s2">Decimal</span><span class="s0">;</span>
  <span class="s0">}</span>
<span class="s0">})(</span><span class="s1">this</span><span class="s0">);</span>
</pre>
</body>
</html>