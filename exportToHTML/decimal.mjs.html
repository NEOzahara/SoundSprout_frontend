<html>
<head>
<title>decimal.mjs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #2aacb8;}
.s5 { color: #6aab73;}
.s6 { color: #42c3d4;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
decimal.mjs</font>
</center></td></tr></table>
<pre><span class="s0">/*! 
 *  decimal.js v10.5.0 
 *  An arbitrary-precision Decimal type for JavaScript. 
 *  https://github.com/MikeMcl/decimal.js 
 *  Copyright (c) 2025 Michael Mclaughlin &lt;M8ch88l@gmail.com&gt; 
 *  MIT Licence 
 */</span>


<span class="s0">// -----------------------------------  EDITABLE DEFAULTS  ------------------------------------ //</span>


  <span class="s0">// The maximum exponent magnitude.</span>
  <span class="s0">// The limit on the value of `toExpNeg`, `toExpPos`, `minE` and `maxE`.</span>
<span class="s2">var </span><span class="s1">EXP_LIMIT </span><span class="s3">= </span><span class="s4">9e15</span><span class="s3">,                      </span><span class="s0">// 0 to 9e15</span>

  <span class="s0">// The limit on the value of `precision`, and on the value of the first argument to</span>
  <span class="s0">// `toDecimalPlaces`, `toExponential`, `toFixed`, `toPrecision` and `toSignificantDigits`.</span>
  <span class="s1">MAX_DIGITS </span><span class="s3">= </span><span class="s4">1e9</span><span class="s3">,                        </span><span class="s0">// 0 to 1e9</span>

  <span class="s0">// Base conversion alphabet.</span>
  <span class="s1">NUMERALS </span><span class="s3">= </span><span class="s5">'0123456789abcdef'</span><span class="s3">,</span>

  <span class="s0">// The natural logarithm of 10 (1025 digits).</span>
  <span class="s1">LN10 </span><span class="s3">= </span><span class="s5">'2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058'</span><span class="s3">,</span>

  <span class="s0">// Pi (1025 digits).</span>
  <span class="s1">PI </span><span class="s3">= </span><span class="s5">'3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789'</span><span class="s3">,</span>


  <span class="s0">// The initial configuration properties of the Decimal constructor.</span>
  <span class="s1">DEFAULTS </span><span class="s3">= {</span>

    <span class="s0">// These values must be integers within the stated ranges (inclusive).</span>
    <span class="s0">// Most of these values can be changed at run-time using the `Decimal.config` method.</span>

    <span class="s0">// The maximum number of significant digits of the result of a calculation or base conversion.</span>
    <span class="s0">// E.g. `Decimal.config({ precision: 20 });`</span>
    <span class="s1">precision</span><span class="s3">: </span><span class="s4">20</span><span class="s3">,                         </span><span class="s0">// 1 to MAX_DIGITS</span>

    <span class="s0">// The rounding mode used when rounding to `precision`.</span>
    <span class="s0">//</span>
    <span class="s0">// ROUND_UP         0 Away from zero.</span>
    <span class="s0">// ROUND_DOWN       1 Towards zero.</span>
    <span class="s0">// ROUND_CEIL       2 Towards +Infinity.</span>
    <span class="s0">// ROUND_FLOOR      3 Towards -Infinity.</span>
    <span class="s0">// ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.</span>
    <span class="s0">// ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.</span>
    <span class="s0">// ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.</span>
    <span class="s0">// ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.</span>
    <span class="s0">// ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.</span>
    <span class="s0">//</span>
    <span class="s0">// E.g.</span>
    <span class="s0">// `Decimal.rounding = 4;`</span>
    <span class="s0">// `Decimal.rounding = Decimal.ROUND_HALF_UP;`</span>
    <span class="s1">rounding</span><span class="s3">: </span><span class="s4">4</span><span class="s3">,                           </span><span class="s0">// 0 to 8</span>

    <span class="s0">// The modulo mode used when calculating the modulus: a mod n.</span>
    <span class="s0">// The quotient (q = a / n) is calculated according to the corresponding rounding mode.</span>
    <span class="s0">// The remainder (r) is calculated as: r = a - n * q.</span>
    <span class="s0">//</span>
    <span class="s0">// UP         0 The remainder is positive if the dividend is negative, else is negative.</span>
    <span class="s0">// DOWN       1 The remainder has the same sign as the dividend (JavaScript %).</span>
    <span class="s0">// FLOOR      3 The remainder has the same sign as the divisor (Python %).</span>
    <span class="s0">// HALF_EVEN  6 The IEEE 754 remainder function.</span>
    <span class="s0">// EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.</span>
    <span class="s0">//</span>
    <span class="s0">// Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian</span>
    <span class="s0">// division (9) are commonly used for the modulus operation. The other rounding modes can also</span>
    <span class="s0">// be used, but they may not give useful results.</span>
    <span class="s1">modulo</span><span class="s3">: </span><span class="s4">1</span><span class="s3">,                             </span><span class="s0">// 0 to 9</span>

    <span class="s0">// The exponent value at and beneath which `toString` returns exponential notation.</span>
    <span class="s0">// JavaScript numbers: -7</span>
    <span class="s1">toExpNeg</span><span class="s3">: -</span><span class="s4">7</span><span class="s3">,                          </span><span class="s0">// 0 to -EXP_LIMIT</span>

    <span class="s0">// The exponent value at and above which `toString` returns exponential notation.</span>
    <span class="s0">// JavaScript numbers: 21</span>
    <span class="s1">toExpPos</span><span class="s3">:  </span><span class="s4">21</span><span class="s3">,                         </span><span class="s0">// 0 to EXP_LIMIT</span>

    <span class="s0">// The minimum exponent value, beneath which underflow to zero occurs.</span>
    <span class="s0">// JavaScript numbers: -324  (5e-324)</span>
    <span class="s1">minE</span><span class="s3">: -</span><span class="s1">EXP_LIMIT</span><span class="s3">,                      </span><span class="s0">// -1 to -EXP_LIMIT</span>

    <span class="s0">// The maximum exponent value, above which overflow to Infinity occurs.</span>
    <span class="s0">// JavaScript numbers: 308  (1.7976931348623157e+308)</span>
    <span class="s1">maxE</span><span class="s3">: </span><span class="s1">EXP_LIMIT</span><span class="s3">,                       </span><span class="s0">// 1 to EXP_LIMIT</span>

    <span class="s0">// Whether to use cryptographically-secure random number generation, if available.</span>
    <span class="s1">crypto</span><span class="s3">: </span><span class="s2">false                          </span><span class="s0">// true/false</span>
  <span class="s3">},</span>


<span class="s0">// ----------------------------------- END OF EDITABLE DEFAULTS ------------------------------- //</span>


  <span class="s1">inexact</span><span class="s3">, </span><span class="s1">quadrant</span><span class="s3">,</span>
  <span class="s1">external </span><span class="s3">= </span><span class="s2">true</span><span class="s3">,</span>

  <span class="s1">decimalError </span><span class="s3">= </span><span class="s5">'[DecimalError] '</span><span class="s3">,</span>
  <span class="s1">invalidArgument </span><span class="s3">= </span><span class="s1">decimalError </span><span class="s3">+ </span><span class="s5">'Invalid argument: '</span><span class="s3">,</span>
  <span class="s1">precisionLimitExceeded </span><span class="s3">= </span><span class="s1">decimalError </span><span class="s3">+ </span><span class="s5">'Precision limit exceeded'</span><span class="s3">,</span>
  <span class="s1">cryptoUnavailable </span><span class="s3">= </span><span class="s1">decimalError </span><span class="s3">+ </span><span class="s5">'crypto unavailable'</span><span class="s3">,</span>
  <span class="s1">tag </span><span class="s3">= </span><span class="s5">'[object Decimal]'</span><span class="s3">,</span>

  <span class="s1">mathfloor </span><span class="s3">= </span><span class="s1">Math</span><span class="s3">.</span><span class="s1">floor</span><span class="s3">,</span>
  <span class="s1">mathpow </span><span class="s3">= </span><span class="s1">Math</span><span class="s3">.</span><span class="s1">pow</span><span class="s3">,</span>

  <span class="s1">isBinary </span><span class="s3">= </span><span class="s6">/^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i</span><span class="s3">,</span>
  <span class="s1">isHex </span><span class="s3">= </span><span class="s6">/^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i</span><span class="s3">,</span>
  <span class="s1">isOctal </span><span class="s3">= </span><span class="s6">/^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i</span><span class="s3">,</span>
  <span class="s1">isDecimal </span><span class="s3">= </span><span class="s6">/^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i</span><span class="s3">,</span>

  <span class="s1">BASE </span><span class="s3">= </span><span class="s4">1e7</span><span class="s3">,</span>
  <span class="s1">LOG_BASE </span><span class="s3">= </span><span class="s4">7</span><span class="s3">,</span>
  <span class="s1">MAX_SAFE_INTEGER </span><span class="s3">= </span><span class="s4">9007199254740991</span><span class="s3">,</span>

  <span class="s1">LN10_PRECISION </span><span class="s3">= </span><span class="s1">LN10</span><span class="s3">.</span><span class="s1">length </span><span class="s3">- </span><span class="s4">1</span><span class="s3">,</span>
  <span class="s1">PI_PRECISION </span><span class="s3">= </span><span class="s1">PI</span><span class="s3">.</span><span class="s1">length </span><span class="s3">- </span><span class="s4">1</span><span class="s3">,</span>

  <span class="s0">// Decimal.prototype object</span>
  <span class="s1">P </span><span class="s3">= { </span><span class="s1">toStringTag</span><span class="s3">: </span><span class="s1">tag </span><span class="s3">};</span>


<span class="s0">// Decimal prototype methods</span>


<span class="s0">/* 
 *  absoluteValue             abs 
 *  ceil 
 *  clampedTo                 clamp 
 *  comparedTo                cmp 
 *  cosine                    cos 
 *  cubeRoot                  cbrt 
 *  decimalPlaces             dp 
 *  dividedBy                 div 
 *  dividedToIntegerBy        divToInt 
 *  equals                    eq 
 *  floor 
 *  greaterThan               gt 
 *  greaterThanOrEqualTo      gte 
 *  hyperbolicCosine          cosh 
 *  hyperbolicSine            sinh 
 *  hyperbolicTangent         tanh 
 *  inverseCosine             acos 
 *  inverseHyperbolicCosine   acosh 
 *  inverseHyperbolicSine     asinh 
 *  inverseHyperbolicTangent  atanh 
 *  inverseSine               asin 
 *  inverseTangent            atan 
 *  isFinite 
 *  isInteger                 isInt 
 *  isNaN 
 *  isNegative                isNeg 
 *  isPositive                isPos 
 *  isZero 
 *  lessThan                  lt 
 *  lessThanOrEqualTo         lte 
 *  logarithm                 log 
 *  [maximum]                 [max] 
 *  [minimum]                 [min] 
 *  minus                     sub 
 *  modulo                    mod 
 *  naturalExponential        exp 
 *  naturalLogarithm          ln 
 *  negated                   neg 
 *  plus                      add 
 *  precision                 sd 
 *  round 
 *  sine                      sin 
 *  squareRoot                sqrt 
 *  tangent                   tan 
 *  times                     mul 
 *  toBinary 
 *  toDecimalPlaces           toDP 
 *  toExponential 
 *  toFixed 
 *  toFraction 
 *  toHexadecimal             toHex 
 *  toNearest 
 *  toNumber 
 *  toOctal 
 *  toPower                   pow 
 *  toPrecision 
 *  toSignificantDigits       toSD 
 *  toString 
 *  truncated                 trunc 
 *  valueOf                   toJSON 
 */</span>


<span class="s0">/* 
 * Return a new Decimal whose value is the absolute value of this Decimal. 
 * 
 */</span>
<span class="s1">P</span><span class="s3">.</span><span class="s1">absoluteValue </span><span class="s3">= </span><span class="s1">P</span><span class="s3">.</span><span class="s1">abs </span><span class="s3">= </span><span class="s2">function </span><span class="s3">() {</span>
  <span class="s2">var </span><span class="s1">x </span><span class="s3">= </span><span class="s2">new this</span><span class="s3">.</span><span class="s1">constructor</span><span class="s3">(</span><span class="s2">this</span><span class="s3">);</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">s </span><span class="s3">&lt; </span><span class="s4">0</span><span class="s3">) </span><span class="s1">x</span><span class="s3">.</span><span class="s1">s </span><span class="s3">= </span><span class="s4">1</span><span class="s3">;</span>
  <span class="s2">return </span><span class="s1">finalise</span><span class="s3">(</span><span class="s1">x</span><span class="s3">);</span>
<span class="s3">};</span>


<span class="s0">/* 
 * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the 
 * direction of positive Infinity. 
 * 
 */</span>
<span class="s1">P</span><span class="s3">.</span><span class="s1">ceil </span><span class="s3">= </span><span class="s2">function </span><span class="s3">() {</span>
  <span class="s2">return </span><span class="s1">finalise</span><span class="s3">(</span><span class="s2">new this</span><span class="s3">.</span><span class="s1">constructor</span><span class="s3">(</span><span class="s2">this</span><span class="s3">), </span><span class="s2">this</span><span class="s3">.</span><span class="s1">e </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">);</span>
<span class="s3">};</span>


<span class="s0">/* 
 * Return a new Decimal whose value is the value of this Decimal clamped to the range 
 * delineated by `min` and `max`. 
 * 
 * min {number|string|bigint|Decimal} 
 * max {number|string|bigint|Decimal} 
 * 
 */</span>
<span class="s1">P</span><span class="s3">.</span><span class="s1">clampedTo </span><span class="s3">= </span><span class="s1">P</span><span class="s3">.</span><span class="s1">clamp </span><span class="s3">= </span><span class="s2">function </span><span class="s3">(</span><span class="s1">min</span><span class="s3">, </span><span class="s1">max</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">k</span><span class="s3">,</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s2">this</span><span class="s3">,</span>
    <span class="s1">Ctor </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">constructor</span><span class="s3">;</span>
  <span class="s1">min </span><span class="s3">= </span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">min</span><span class="s3">);</span>
  <span class="s1">max </span><span class="s3">= </span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">max</span><span class="s3">);</span>
  <span class="s2">if </span><span class="s3">(!</span><span class="s1">min</span><span class="s3">.</span><span class="s1">s </span><span class="s3">|| !</span><span class="s1">max</span><span class="s3">.</span><span class="s1">s</span><span class="s3">) </span><span class="s2">return new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">NaN</span><span class="s3">);</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">min</span><span class="s3">.</span><span class="s1">gt</span><span class="s3">(</span><span class="s1">max</span><span class="s3">)) </span><span class="s2">throw </span><span class="s1">Error</span><span class="s3">(</span><span class="s1">invalidArgument </span><span class="s3">+ </span><span class="s1">max</span><span class="s3">);</span>
  <span class="s1">k </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">cmp</span><span class="s3">(</span><span class="s1">min</span><span class="s3">);</span>
  <span class="s2">return </span><span class="s1">k </span><span class="s3">&lt; </span><span class="s4">0 </span><span class="s3">? </span><span class="s1">min </span><span class="s3">: </span><span class="s1">x</span><span class="s3">.</span><span class="s1">cmp</span><span class="s3">(</span><span class="s1">max</span><span class="s3">) &gt; </span><span class="s4">0 </span><span class="s3">? </span><span class="s1">max </span><span class="s3">: </span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">x</span><span class="s3">);</span>
<span class="s3">};</span>


<span class="s0">/* 
 * Return 
 *   1    if the value of this Decimal is greater than the value of `y`, 
 *  -1    if the value of this Decimal is less than the value of `y`, 
 *   0    if they have the same value, 
 *   NaN  if the value of either Decimal is NaN. 
 * 
 */</span>
<span class="s1">P</span><span class="s3">.</span><span class="s1">comparedTo </span><span class="s3">= </span><span class="s1">P</span><span class="s3">.</span><span class="s1">cmp </span><span class="s3">= </span><span class="s2">function </span><span class="s3">(</span><span class="s1">y</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">i</span><span class="s3">, </span><span class="s1">j</span><span class="s3">, </span><span class="s1">xdL</span><span class="s3">, </span><span class="s1">ydL</span><span class="s3">,</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s2">this</span><span class="s3">,</span>
    <span class="s1">xd </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">d</span><span class="s3">,</span>
    <span class="s1">yd </span><span class="s3">= (</span><span class="s1">y </span><span class="s3">= </span><span class="s2">new </span><span class="s1">x</span><span class="s3">.</span><span class="s1">constructor</span><span class="s3">(</span><span class="s1">y</span><span class="s3">)).</span><span class="s1">d</span><span class="s3">,</span>
    <span class="s1">xs </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">s</span><span class="s3">,</span>
    <span class="s1">ys </span><span class="s3">= </span><span class="s1">y</span><span class="s3">.</span><span class="s1">s</span><span class="s3">;</span>

  <span class="s0">// Either NaN or Â±Infinity?</span>
  <span class="s2">if </span><span class="s3">(!</span><span class="s1">xd </span><span class="s3">|| !</span><span class="s1">yd</span><span class="s3">) {</span>
    <span class="s2">return </span><span class="s3">!</span><span class="s1">xs </span><span class="s3">|| !</span><span class="s1">ys </span><span class="s3">? </span><span class="s1">NaN </span><span class="s3">: </span><span class="s1">xs </span><span class="s3">!== </span><span class="s1">ys </span><span class="s3">? </span><span class="s1">xs </span><span class="s3">: </span><span class="s1">xd </span><span class="s3">=== </span><span class="s1">yd </span><span class="s3">? </span><span class="s4">0 </span><span class="s3">: !</span><span class="s1">xd </span><span class="s3">^ </span><span class="s1">xs </span><span class="s3">&lt; </span><span class="s4">0 </span><span class="s3">? </span><span class="s4">1 </span><span class="s3">: -</span><span class="s4">1</span><span class="s3">;</span>
  <span class="s3">}</span>

  <span class="s0">// Either zero?</span>
  <span class="s2">if </span><span class="s3">(!</span><span class="s1">xd</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] || !</span><span class="s1">yd</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]) </span><span class="s2">return </span><span class="s1">xd</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] ? </span><span class="s1">xs </span><span class="s3">: </span><span class="s1">yd</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] ? -</span><span class="s1">ys </span><span class="s3">: </span><span class="s4">0</span><span class="s3">;</span>

  <span class="s0">// Signs differ?</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">xs </span><span class="s3">!== </span><span class="s1">ys</span><span class="s3">) </span><span class="s2">return </span><span class="s1">xs</span><span class="s3">;</span>

  <span class="s0">// Compare exponents.</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">e </span><span class="s3">!== </span><span class="s1">y</span><span class="s3">.</span><span class="s1">e</span><span class="s3">) </span><span class="s2">return </span><span class="s1">x</span><span class="s3">.</span><span class="s1">e </span><span class="s3">&gt; </span><span class="s1">y</span><span class="s3">.</span><span class="s1">e </span><span class="s3">^ </span><span class="s1">xs </span><span class="s3">&lt; </span><span class="s4">0 </span><span class="s3">? </span><span class="s4">1 </span><span class="s3">: -</span><span class="s4">1</span><span class="s3">;</span>

  <span class="s1">xdL </span><span class="s3">= </span><span class="s1">xd</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span>
  <span class="s1">ydL </span><span class="s3">= </span><span class="s1">yd</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span>

  <span class="s0">// Compare digit by digit.</span>
  <span class="s2">for </span><span class="s3">(</span><span class="s1">i </span><span class="s3">= </span><span class="s4">0</span><span class="s3">, </span><span class="s1">j </span><span class="s3">= </span><span class="s1">xdL </span><span class="s3">&lt; </span><span class="s1">ydL </span><span class="s3">? </span><span class="s1">xdL </span><span class="s3">: </span><span class="s1">ydL</span><span class="s3">; </span><span class="s1">i </span><span class="s3">&lt; </span><span class="s1">j</span><span class="s3">; ++</span><span class="s1">i</span><span class="s3">) {</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">xd</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] !== </span><span class="s1">yd</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]) </span><span class="s2">return </span><span class="s1">xd</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] &gt; </span><span class="s1">yd</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] ^ </span><span class="s1">xs </span><span class="s3">&lt; </span><span class="s4">0 </span><span class="s3">? </span><span class="s4">1 </span><span class="s3">: -</span><span class="s4">1</span><span class="s3">;</span>
  <span class="s3">}</span>

  <span class="s0">// Compare lengths.</span>
  <span class="s2">return </span><span class="s1">xdL </span><span class="s3">=== </span><span class="s1">ydL </span><span class="s3">? </span><span class="s4">0 </span><span class="s3">: </span><span class="s1">xdL </span><span class="s3">&gt; </span><span class="s1">ydL </span><span class="s3">^ </span><span class="s1">xs </span><span class="s3">&lt; </span><span class="s4">0 </span><span class="s3">? </span><span class="s4">1 </span><span class="s3">: -</span><span class="s4">1</span><span class="s3">;</span>
<span class="s3">};</span>


<span class="s0">/* 
 * Return a new Decimal whose value is the cosine of the value in radians of this Decimal. 
 * 
 * Domain: [-Infinity, Infinity] 
 * Range: [-1, 1] 
 * 
 * cos(0)         = 1 
 * cos(-0)        = 1 
 * cos(Infinity)  = NaN 
 * cos(-Infinity) = NaN 
 * cos(NaN)       = NaN 
 * 
 */</span>
<span class="s1">P</span><span class="s3">.</span><span class="s1">cosine </span><span class="s3">= </span><span class="s1">P</span><span class="s3">.</span><span class="s1">cos </span><span class="s3">= </span><span class="s2">function </span><span class="s3">() {</span>
  <span class="s2">var </span><span class="s1">pr</span><span class="s3">, </span><span class="s1">rm</span><span class="s3">,</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s2">this</span><span class="s3">,</span>
    <span class="s1">Ctor </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">constructor</span><span class="s3">;</span>

  <span class="s2">if </span><span class="s3">(!</span><span class="s1">x</span><span class="s3">.</span><span class="s1">d</span><span class="s3">) </span><span class="s2">return new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">NaN</span><span class="s3">);</span>

  <span class="s0">// cos(0) = cos(-0) = 1</span>
  <span class="s2">if </span><span class="s3">(!</span><span class="s1">x</span><span class="s3">.</span><span class="s1">d</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]) </span><span class="s2">return new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s4">1</span><span class="s3">);</span>

  <span class="s1">pr </span><span class="s3">= </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">precision</span><span class="s3">;</span>
  <span class="s1">rm </span><span class="s3">= </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">rounding</span><span class="s3">;</span>
  <span class="s1">Ctor</span><span class="s3">.</span><span class="s1">precision </span><span class="s3">= </span><span class="s1">pr </span><span class="s3">+ </span><span class="s1">Math</span><span class="s3">.</span><span class="s1">max</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">e</span><span class="s3">, </span><span class="s1">x</span><span class="s3">.</span><span class="s1">sd</span><span class="s3">()) + </span><span class="s1">LOG_BASE</span><span class="s3">;</span>
  <span class="s1">Ctor</span><span class="s3">.</span><span class="s1">rounding </span><span class="s3">= </span><span class="s4">1</span><span class="s3">;</span>

  <span class="s1">x </span><span class="s3">= </span><span class="s1">cosine</span><span class="s3">(</span><span class="s1">Ctor</span><span class="s3">, </span><span class="s1">toLessThanHalfPi</span><span class="s3">(</span><span class="s1">Ctor</span><span class="s3">, </span><span class="s1">x</span><span class="s3">));</span>

  <span class="s1">Ctor</span><span class="s3">.</span><span class="s1">precision </span><span class="s3">= </span><span class="s1">pr</span><span class="s3">;</span>
  <span class="s1">Ctor</span><span class="s3">.</span><span class="s1">rounding </span><span class="s3">= </span><span class="s1">rm</span><span class="s3">;</span>

  <span class="s2">return </span><span class="s1">finalise</span><span class="s3">(</span><span class="s1">quadrant </span><span class="s3">== </span><span class="s4">2 </span><span class="s3">|| </span><span class="s1">quadrant </span><span class="s3">== </span><span class="s4">3 </span><span class="s3">? </span><span class="s1">x</span><span class="s3">.</span><span class="s1">neg</span><span class="s3">() : </span><span class="s1">x</span><span class="s3">, </span><span class="s1">pr</span><span class="s3">, </span><span class="s1">rm</span><span class="s3">, </span><span class="s2">true</span><span class="s3">);</span>
<span class="s3">};</span>


<span class="s0">/* 
 * 
 * Return a new Decimal whose value is the cube root of the value of this Decimal, rounded to 
 * `precision` significant digits using rounding mode `rounding`. 
 * 
 *  cbrt(0)  =  0 
 *  cbrt(-0) = -0 
 *  cbrt(1)  =  1 
 *  cbrt(-1) = -1 
 *  cbrt(N)  =  N 
 *  cbrt(-I) = -I 
 *  cbrt(I)  =  I 
 * 
 * Math.cbrt(x) = (x &lt; 0 ? -Math.pow(-x, 1/3) : Math.pow(x, 1/3)) 
 * 
 */</span>
<span class="s1">P</span><span class="s3">.</span><span class="s1">cubeRoot </span><span class="s3">= </span><span class="s1">P</span><span class="s3">.</span><span class="s1">cbrt </span><span class="s3">= </span><span class="s2">function </span><span class="s3">() {</span>
  <span class="s2">var </span><span class="s1">e</span><span class="s3">, </span><span class="s1">m</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">r</span><span class="s3">, </span><span class="s1">rep</span><span class="s3">, </span><span class="s1">s</span><span class="s3">, </span><span class="s1">sd</span><span class="s3">, </span><span class="s1">t</span><span class="s3">, </span><span class="s1">t3</span><span class="s3">, </span><span class="s1">t3plusx</span><span class="s3">,</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s2">this</span><span class="s3">,</span>
    <span class="s1">Ctor </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">constructor</span><span class="s3">;</span>

  <span class="s2">if </span><span class="s3">(!</span><span class="s1">x</span><span class="s3">.</span><span class="s1">isFinite</span><span class="s3">() || </span><span class="s1">x</span><span class="s3">.</span><span class="s1">isZero</span><span class="s3">()) </span><span class="s2">return new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">x</span><span class="s3">);</span>
  <span class="s1">external </span><span class="s3">= </span><span class="s2">false</span><span class="s3">;</span>

  <span class="s0">// Initial estimate.</span>
  <span class="s1">s </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">s </span><span class="s3">* </span><span class="s1">mathpow</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">s </span><span class="s3">* </span><span class="s1">x</span><span class="s3">, </span><span class="s4">1 </span><span class="s3">/ </span><span class="s4">3</span><span class="s3">);</span>

   <span class="s0">// Math.cbrt underflow/overflow?</span>
   <span class="s0">// Pass x to Math.pow as integer, then adjust the exponent of the result.</span>
  <span class="s2">if </span><span class="s3">(!</span><span class="s1">s </span><span class="s3">|| </span><span class="s1">Math</span><span class="s3">.</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">s</span><span class="s3">) == </span><span class="s4">1 </span><span class="s3">/ </span><span class="s4">0</span><span class="s3">) {</span>
    <span class="s1">n </span><span class="s3">= </span><span class="s1">digitsToString</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">d</span><span class="s3">);</span>
    <span class="s1">e </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">e</span><span class="s3">;</span>

    <span class="s0">// Adjust n exponent so it is a multiple of 3 away from x exponent.</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">s </span><span class="s3">= (</span><span class="s1">e </span><span class="s3">- </span><span class="s1">n</span><span class="s3">.</span><span class="s1">length </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">) % </span><span class="s4">3</span><span class="s3">) </span><span class="s1">n </span><span class="s3">+= (</span><span class="s1">s </span><span class="s3">== </span><span class="s4">1 </span><span class="s3">|| </span><span class="s1">s </span><span class="s3">== -</span><span class="s4">2 </span><span class="s3">? </span><span class="s5">'0' </span><span class="s3">: </span><span class="s5">'00'</span><span class="s3">);</span>
    <span class="s1">s </span><span class="s3">= </span><span class="s1">mathpow</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s4">1 </span><span class="s3">/ </span><span class="s4">3</span><span class="s3">);</span>

    <span class="s0">// Rarely, e may be one less than the result exponent value.</span>
    <span class="s1">e </span><span class="s3">= </span><span class="s1">mathfloor</span><span class="s3">((</span><span class="s1">e </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">) / </span><span class="s4">3</span><span class="s3">) - (</span><span class="s1">e </span><span class="s3">% </span><span class="s4">3 </span><span class="s3">== (</span><span class="s1">e </span><span class="s3">&lt; </span><span class="s4">0 </span><span class="s3">? -</span><span class="s4">1 </span><span class="s3">: </span><span class="s4">2</span><span class="s3">));</span>

    <span class="s2">if </span><span class="s3">(</span><span class="s1">s </span><span class="s3">== </span><span class="s4">1 </span><span class="s3">/ </span><span class="s4">0</span><span class="s3">) {</span>
      <span class="s1">n </span><span class="s3">= </span><span class="s5">'5e' </span><span class="s3">+ </span><span class="s1">e</span><span class="s3">;</span>
    <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
      <span class="s1">n </span><span class="s3">= </span><span class="s1">s</span><span class="s3">.</span><span class="s1">toExponential</span><span class="s3">();</span>
      <span class="s1">n </span><span class="s3">= </span><span class="s1">n</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span><span class="s4">0</span><span class="s3">, </span><span class="s1">n</span><span class="s3">.</span><span class="s1">indexOf</span><span class="s3">(</span><span class="s5">'e'</span><span class="s3">) + </span><span class="s4">1</span><span class="s3">) + </span><span class="s1">e</span><span class="s3">;</span>
    <span class="s3">}</span>

    <span class="s1">r </span><span class="s3">= </span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">n</span><span class="s3">);</span>
    <span class="s1">r</span><span class="s3">.</span><span class="s1">s </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">s</span><span class="s3">;</span>
  <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
    <span class="s1">r </span><span class="s3">= </span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">s</span><span class="s3">.</span><span class="s1">toString</span><span class="s3">());</span>
  <span class="s3">}</span>

  <span class="s1">sd </span><span class="s3">= (</span><span class="s1">e </span><span class="s3">= </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">precision</span><span class="s3">) + </span><span class="s4">3</span><span class="s3">;</span>

  <span class="s0">// Halley's method.</span>
  <span class="s0">// TODO? Compare Newton's method.</span>
  <span class="s2">for </span><span class="s3">(;;) {</span>
    <span class="s1">t </span><span class="s3">= </span><span class="s1">r</span><span class="s3">;</span>
    <span class="s1">t3 </span><span class="s3">= </span><span class="s1">t</span><span class="s3">.</span><span class="s1">times</span><span class="s3">(</span><span class="s1">t</span><span class="s3">).</span><span class="s1">times</span><span class="s3">(</span><span class="s1">t</span><span class="s3">);</span>
    <span class="s1">t3plusx </span><span class="s3">= </span><span class="s1">t3</span><span class="s3">.</span><span class="s1">plus</span><span class="s3">(</span><span class="s1">x</span><span class="s3">);</span>
    <span class="s1">r </span><span class="s3">= </span><span class="s1">divide</span><span class="s3">(</span><span class="s1">t3plusx</span><span class="s3">.</span><span class="s1">plus</span><span class="s3">(</span><span class="s1">x</span><span class="s3">).</span><span class="s1">times</span><span class="s3">(</span><span class="s1">t</span><span class="s3">), </span><span class="s1">t3plusx</span><span class="s3">.</span><span class="s1">plus</span><span class="s3">(</span><span class="s1">t3</span><span class="s3">), </span><span class="s1">sd </span><span class="s3">+ </span><span class="s4">2</span><span class="s3">, </span><span class="s4">1</span><span class="s3">);</span>

    <span class="s0">// TODO? Replace with for-loop and checkRoundingDigits.</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">digitsToString</span><span class="s3">(</span><span class="s1">t</span><span class="s3">.</span><span class="s1">d</span><span class="s3">).</span><span class="s1">slice</span><span class="s3">(</span><span class="s4">0</span><span class="s3">, </span><span class="s1">sd</span><span class="s3">) === (</span><span class="s1">n </span><span class="s3">= </span><span class="s1">digitsToString</span><span class="s3">(</span><span class="s1">r</span><span class="s3">.</span><span class="s1">d</span><span class="s3">)).</span><span class="s1">slice</span><span class="s3">(</span><span class="s4">0</span><span class="s3">, </span><span class="s1">sd</span><span class="s3">)) {</span>
      <span class="s1">n </span><span class="s3">= </span><span class="s1">n</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span><span class="s1">sd </span><span class="s3">- </span><span class="s4">3</span><span class="s3">, </span><span class="s1">sd </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">);</span>

      <span class="s0">// The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or 4999</span>
      <span class="s0">// , i.e. approaching a rounding boundary, continue the iteration.</span>
      <span class="s2">if </span><span class="s3">(</span><span class="s1">n </span><span class="s3">== </span><span class="s5">'9999' </span><span class="s3">|| !</span><span class="s1">rep </span><span class="s3">&amp;&amp; </span><span class="s1">n </span><span class="s3">== </span><span class="s5">'4999'</span><span class="s3">) {</span>

        <span class="s0">// On the first iteration only, check to see if rounding up gives the exact result as the</span>
        <span class="s0">// nines may infinitely repeat.</span>
        <span class="s2">if </span><span class="s3">(!</span><span class="s1">rep</span><span class="s3">) {</span>
          <span class="s1">finalise</span><span class="s3">(</span><span class="s1">t</span><span class="s3">, </span><span class="s1">e </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">, </span><span class="s4">0</span><span class="s3">);</span>

          <span class="s2">if </span><span class="s3">(</span><span class="s1">t</span><span class="s3">.</span><span class="s1">times</span><span class="s3">(</span><span class="s1">t</span><span class="s3">).</span><span class="s1">times</span><span class="s3">(</span><span class="s1">t</span><span class="s3">).</span><span class="s1">eq</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)) {</span>
            <span class="s1">r </span><span class="s3">= </span><span class="s1">t</span><span class="s3">;</span>
            <span class="s2">break</span><span class="s3">;</span>
          <span class="s3">}</span>
        <span class="s3">}</span>

        <span class="s1">sd </span><span class="s3">+= </span><span class="s4">4</span><span class="s3">;</span>
        <span class="s1">rep </span><span class="s3">= </span><span class="s4">1</span><span class="s3">;</span>
      <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>

        <span class="s0">// If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.</span>
        <span class="s0">// If not, then there are further digits and m will be truthy.</span>
        <span class="s2">if </span><span class="s3">(!+</span><span class="s1">n </span><span class="s3">|| !+</span><span class="s1">n</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span><span class="s4">1</span><span class="s3">) &amp;&amp; </span><span class="s1">n</span><span class="s3">.</span><span class="s1">charAt</span><span class="s3">(</span><span class="s4">0</span><span class="s3">) == </span><span class="s5">'5'</span><span class="s3">) {</span>

          <span class="s0">// Truncate to the first rounding digit.</span>
          <span class="s1">finalise</span><span class="s3">(</span><span class="s1">r</span><span class="s3">, </span><span class="s1">e </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">);</span>
          <span class="s1">m </span><span class="s3">= !</span><span class="s1">r</span><span class="s3">.</span><span class="s1">times</span><span class="s3">(</span><span class="s1">r</span><span class="s3">).</span><span class="s1">times</span><span class="s3">(</span><span class="s1">r</span><span class="s3">).</span><span class="s1">eq</span><span class="s3">(</span><span class="s1">x</span><span class="s3">);</span>
        <span class="s3">}</span>

        <span class="s2">break</span><span class="s3">;</span>
      <span class="s3">}</span>
    <span class="s3">}</span>
  <span class="s3">}</span>

  <span class="s1">external </span><span class="s3">= </span><span class="s2">true</span><span class="s3">;</span>

  <span class="s2">return </span><span class="s1">finalise</span><span class="s3">(</span><span class="s1">r</span><span class="s3">, </span><span class="s1">e</span><span class="s3">, </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">rounding</span><span class="s3">, </span><span class="s1">m</span><span class="s3">);</span>
<span class="s3">};</span>


<span class="s0">/* 
 * Return the number of decimal places of the value of this Decimal. 
 * 
 */</span>
<span class="s1">P</span><span class="s3">.</span><span class="s1">decimalPlaces </span><span class="s3">= </span><span class="s1">P</span><span class="s3">.</span><span class="s1">dp </span><span class="s3">= </span><span class="s2">function </span><span class="s3">() {</span>
  <span class="s2">var </span><span class="s1">w</span><span class="s3">,</span>
    <span class="s1">d </span><span class="s3">= </span><span class="s2">this</span><span class="s3">.</span><span class="s1">d</span><span class="s3">,</span>
    <span class="s1">n </span><span class="s3">= </span><span class="s1">NaN</span><span class="s3">;</span>

  <span class="s2">if </span><span class="s3">(</span><span class="s1">d</span><span class="s3">) {</span>
    <span class="s1">w </span><span class="s3">= </span><span class="s1">d</span><span class="s3">.</span><span class="s1">length </span><span class="s3">- </span><span class="s4">1</span><span class="s3">;</span>
    <span class="s1">n </span><span class="s3">= (</span><span class="s1">w </span><span class="s3">- </span><span class="s1">mathfloor</span><span class="s3">(</span><span class="s2">this</span><span class="s3">.</span><span class="s1">e </span><span class="s3">/ </span><span class="s1">LOG_BASE</span><span class="s3">)) * </span><span class="s1">LOG_BASE</span><span class="s3">;</span>

    <span class="s0">// Subtract the number of trailing zeros of the last word.</span>
    <span class="s1">w </span><span class="s3">= </span><span class="s1">d</span><span class="s3">[</span><span class="s1">w</span><span class="s3">];</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">w</span><span class="s3">) </span><span class="s2">for </span><span class="s3">(; </span><span class="s1">w </span><span class="s3">% </span><span class="s4">10 </span><span class="s3">== </span><span class="s4">0</span><span class="s3">; </span><span class="s1">w </span><span class="s3">/= </span><span class="s4">10</span><span class="s3">) </span><span class="s1">n</span><span class="s3">--;</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">n </span><span class="s3">&lt; </span><span class="s4">0</span><span class="s3">) </span><span class="s1">n </span><span class="s3">= </span><span class="s4">0</span><span class="s3">;</span>
  <span class="s3">}</span>

  <span class="s2">return </span><span class="s1">n</span><span class="s3">;</span>
<span class="s3">};</span>


<span class="s0">/* 
 *  n / 0 = I 
 *  n / N = N 
 *  n / I = 0 
 *  0 / n = 0 
 *  0 / 0 = N 
 *  0 / N = N 
 *  0 / I = 0 
 *  N / n = N 
 *  N / 0 = N 
 *  N / N = N 
 *  N / I = N 
 *  I / n = I 
 *  I / 0 = I 
 *  I / N = N 
 *  I / I = N 
 * 
 * Return a new Decimal whose value is the value of this Decimal divided by `y`, rounded to 
 * `precision` significant digits using rounding mode `rounding`. 
 * 
 */</span>
<span class="s1">P</span><span class="s3">.</span><span class="s1">dividedBy </span><span class="s3">= </span><span class="s1">P</span><span class="s3">.</span><span class="s1">div </span><span class="s3">= </span><span class="s2">function </span><span class="s3">(</span><span class="s1">y</span><span class="s3">) {</span>
  <span class="s2">return </span><span class="s1">divide</span><span class="s3">(</span><span class="s2">this</span><span class="s3">, </span><span class="s2">new this</span><span class="s3">.</span><span class="s1">constructor</span><span class="s3">(</span><span class="s1">y</span><span class="s3">));</span>
<span class="s3">};</span>


<span class="s0">/* 
 * Return a new Decimal whose value is the integer part of dividing the value of this Decimal 
 * by the value of `y`, rounded to `precision` significant digits using rounding mode `rounding`. 
 * 
 */</span>
<span class="s1">P</span><span class="s3">.</span><span class="s1">dividedToIntegerBy </span><span class="s3">= </span><span class="s1">P</span><span class="s3">.</span><span class="s1">divToInt </span><span class="s3">= </span><span class="s2">function </span><span class="s3">(</span><span class="s1">y</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">x </span><span class="s3">= </span><span class="s2">this</span><span class="s3">,</span>
    <span class="s1">Ctor </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">constructor</span><span class="s3">;</span>
  <span class="s2">return </span><span class="s1">finalise</span><span class="s3">(</span><span class="s1">divide</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">y</span><span class="s3">), </span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">), </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">precision</span><span class="s3">, </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">rounding</span><span class="s3">);</span>
<span class="s3">};</span>


<span class="s0">/* 
 * Return true if the value of this Decimal is equal to the value of `y`, otherwise return false. 
 * 
 */</span>
<span class="s1">P</span><span class="s3">.</span><span class="s1">equals </span><span class="s3">= </span><span class="s1">P</span><span class="s3">.</span><span class="s1">eq </span><span class="s3">= </span><span class="s2">function </span><span class="s3">(</span><span class="s1">y</span><span class="s3">) {</span>
  <span class="s2">return this</span><span class="s3">.</span><span class="s1">cmp</span><span class="s3">(</span><span class="s1">y</span><span class="s3">) === </span><span class="s4">0</span><span class="s3">;</span>
<span class="s3">};</span>


<span class="s0">/* 
 * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the 
 * direction of negative Infinity. 
 * 
 */</span>
<span class="s1">P</span><span class="s3">.</span><span class="s1">floor </span><span class="s3">= </span><span class="s2">function </span><span class="s3">() {</span>
  <span class="s2">return </span><span class="s1">finalise</span><span class="s3">(</span><span class="s2">new this</span><span class="s3">.</span><span class="s1">constructor</span><span class="s3">(</span><span class="s2">this</span><span class="s3">), </span><span class="s2">this</span><span class="s3">.</span><span class="s1">e </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">, </span><span class="s4">3</span><span class="s3">);</span>
<span class="s3">};</span>


<span class="s0">/* 
 * Return true if the value of this Decimal is greater than the value of `y`, otherwise return 
 * false. 
 * 
 */</span>
<span class="s1">P</span><span class="s3">.</span><span class="s1">greaterThan </span><span class="s3">= </span><span class="s1">P</span><span class="s3">.</span><span class="s1">gt </span><span class="s3">= </span><span class="s2">function </span><span class="s3">(</span><span class="s1">y</span><span class="s3">) {</span>
  <span class="s2">return this</span><span class="s3">.</span><span class="s1">cmp</span><span class="s3">(</span><span class="s1">y</span><span class="s3">) &gt; </span><span class="s4">0</span><span class="s3">;</span>
<span class="s3">};</span>


<span class="s0">/* 
 * Return true if the value of this Decimal is greater than or equal to the value of `y`, 
 * otherwise return false. 
 * 
 */</span>
<span class="s1">P</span><span class="s3">.</span><span class="s1">greaterThanOrEqualTo </span><span class="s3">= </span><span class="s1">P</span><span class="s3">.</span><span class="s1">gte </span><span class="s3">= </span><span class="s2">function </span><span class="s3">(</span><span class="s1">y</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">k </span><span class="s3">= </span><span class="s2">this</span><span class="s3">.</span><span class="s1">cmp</span><span class="s3">(</span><span class="s1">y</span><span class="s3">);</span>
  <span class="s2">return </span><span class="s1">k </span><span class="s3">== </span><span class="s4">1 </span><span class="s3">|| </span><span class="s1">k </span><span class="s3">=== </span><span class="s4">0</span><span class="s3">;</span>
<span class="s3">};</span>


<span class="s0">/* 
 * Return a new Decimal whose value is the hyperbolic cosine of the value in radians of this 
 * Decimal. 
 * 
 * Domain: [-Infinity, Infinity] 
 * Range: [1, Infinity] 
 * 
 * cosh(x) = 1 + x^2/2! + x^4/4! + x^6/6! + ... 
 * 
 * cosh(0)         = 1 
 * cosh(-0)        = 1 
 * cosh(Infinity)  = Infinity 
 * cosh(-Infinity) = Infinity 
 * cosh(NaN)       = NaN 
 * 
 *  x        time taken (ms)   result 
 * 1000      9                 9.8503555700852349694e+433 
 * 10000     25                4.4034091128314607936e+4342 
 * 100000    171               1.4033316802130615897e+43429 
 * 1000000   3817              1.5166076984010437725e+434294 
 * 10000000  abandoned after 2 minute wait 
 * 
 * TODO? Compare performance of cosh(x) = 0.5 * (exp(x) + exp(-x)) 
 * 
 */</span>
<span class="s1">P</span><span class="s3">.</span><span class="s1">hyperbolicCosine </span><span class="s3">= </span><span class="s1">P</span><span class="s3">.</span><span class="s1">cosh </span><span class="s3">= </span><span class="s2">function </span><span class="s3">() {</span>
  <span class="s2">var </span><span class="s1">k</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">pr</span><span class="s3">, </span><span class="s1">rm</span><span class="s3">, </span><span class="s1">len</span><span class="s3">,</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s2">this</span><span class="s3">,</span>
    <span class="s1">Ctor </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">constructor</span><span class="s3">,</span>
    <span class="s1">one </span><span class="s3">= </span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s4">1</span><span class="s3">);</span>

  <span class="s2">if </span><span class="s3">(!</span><span class="s1">x</span><span class="s3">.</span><span class="s1">isFinite</span><span class="s3">()) </span><span class="s2">return new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">s </span><span class="s3">? </span><span class="s4">1 </span><span class="s3">/ </span><span class="s4">0 </span><span class="s3">: </span><span class="s1">NaN</span><span class="s3">);</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">isZero</span><span class="s3">()) </span><span class="s2">return </span><span class="s1">one</span><span class="s3">;</span>

  <span class="s1">pr </span><span class="s3">= </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">precision</span><span class="s3">;</span>
  <span class="s1">rm </span><span class="s3">= </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">rounding</span><span class="s3">;</span>
  <span class="s1">Ctor</span><span class="s3">.</span><span class="s1">precision </span><span class="s3">= </span><span class="s1">pr </span><span class="s3">+ </span><span class="s1">Math</span><span class="s3">.</span><span class="s1">max</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">e</span><span class="s3">, </span><span class="s1">x</span><span class="s3">.</span><span class="s1">sd</span><span class="s3">()) + </span><span class="s4">4</span><span class="s3">;</span>
  <span class="s1">Ctor</span><span class="s3">.</span><span class="s1">rounding </span><span class="s3">= </span><span class="s4">1</span><span class="s3">;</span>
  <span class="s1">len </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">d</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span>

  <span class="s0">// Argument reduction: cos(4x) = 1 - 8cos^2(x) + 8cos^4(x) + 1</span>
  <span class="s0">// i.e. cos(x) = 1 - cos^2(x/4)(8 - 8cos^2(x/4))</span>

  <span class="s0">// Estimate the optimum number of times to use the argument reduction.</span>
  <span class="s0">// TODO? Estimation reused from cosine() and may not be optimal here.</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">len </span><span class="s3">&lt; </span><span class="s4">32</span><span class="s3">) {</span>
    <span class="s1">k </span><span class="s3">= </span><span class="s1">Math</span><span class="s3">.</span><span class="s1">ceil</span><span class="s3">(</span><span class="s1">len </span><span class="s3">/ </span><span class="s4">3</span><span class="s3">);</span>
    <span class="s1">n </span><span class="s3">= (</span><span class="s4">1 </span><span class="s3">/ </span><span class="s1">tinyPow</span><span class="s3">(</span><span class="s4">4</span><span class="s3">, </span><span class="s1">k</span><span class="s3">)).</span><span class="s1">toString</span><span class="s3">();</span>
  <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
    <span class="s1">k </span><span class="s3">= </span><span class="s4">16</span><span class="s3">;</span>
    <span class="s1">n </span><span class="s3">= </span><span class="s5">'2.3283064365386962890625e-10'</span><span class="s3">;</span>
  <span class="s3">}</span>

  <span class="s1">x </span><span class="s3">= </span><span class="s1">taylorSeries</span><span class="s3">(</span><span class="s1">Ctor</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s1">x</span><span class="s3">.</span><span class="s1">times</span><span class="s3">(</span><span class="s1">n</span><span class="s3">), </span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s4">1</span><span class="s3">), </span><span class="s2">true</span><span class="s3">);</span>

  <span class="s0">// Reverse argument reduction</span>
  <span class="s2">var </span><span class="s1">cosh2_x</span><span class="s3">,</span>
    <span class="s1">i </span><span class="s3">= </span><span class="s1">k</span><span class="s3">,</span>
    <span class="s1">d8 </span><span class="s3">= </span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s4">8</span><span class="s3">);</span>
  <span class="s2">for </span><span class="s3">(; </span><span class="s1">i</span><span class="s3">--;) {</span>
    <span class="s1">cosh2_x </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">times</span><span class="s3">(</span><span class="s1">x</span><span class="s3">);</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s1">one</span><span class="s3">.</span><span class="s1">minus</span><span class="s3">(</span><span class="s1">cosh2_x</span><span class="s3">.</span><span class="s1">times</span><span class="s3">(</span><span class="s1">d8</span><span class="s3">.</span><span class="s1">minus</span><span class="s3">(</span><span class="s1">cosh2_x</span><span class="s3">.</span><span class="s1">times</span><span class="s3">(</span><span class="s1">d8</span><span class="s3">))));</span>
  <span class="s3">}</span>

  <span class="s2">return </span><span class="s1">finalise</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">precision </span><span class="s3">= </span><span class="s1">pr</span><span class="s3">, </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">rounding </span><span class="s3">= </span><span class="s1">rm</span><span class="s3">, </span><span class="s2">true</span><span class="s3">);</span>
<span class="s3">};</span>


<span class="s0">/* 
 * Return a new Decimal whose value is the hyperbolic sine of the value in radians of this 
 * Decimal. 
 * 
 * Domain: [-Infinity, Infinity] 
 * Range: [-Infinity, Infinity] 
 * 
 * sinh(x) = x + x^3/3! + x^5/5! + x^7/7! + ... 
 * 
 * sinh(0)         = 0 
 * sinh(-0)        = -0 
 * sinh(Infinity)  = Infinity 
 * sinh(-Infinity) = -Infinity 
 * sinh(NaN)       = NaN 
 * 
 * x        time taken (ms) 
 * 10       2 ms 
 * 100      5 ms 
 * 1000     14 ms 
 * 10000    82 ms 
 * 100000   886 ms            1.4033316802130615897e+43429 
 * 200000   2613 ms 
 * 300000   5407 ms 
 * 400000   8824 ms 
 * 500000   13026 ms          8.7080643612718084129e+217146 
 * 1000000  48543 ms 
 * 
 * TODO? Compare performance of sinh(x) = 0.5 * (exp(x) - exp(-x)) 
 * 
 */</span>
<span class="s1">P</span><span class="s3">.</span><span class="s1">hyperbolicSine </span><span class="s3">= </span><span class="s1">P</span><span class="s3">.</span><span class="s1">sinh </span><span class="s3">= </span><span class="s2">function </span><span class="s3">() {</span>
  <span class="s2">var </span><span class="s1">k</span><span class="s3">, </span><span class="s1">pr</span><span class="s3">, </span><span class="s1">rm</span><span class="s3">, </span><span class="s1">len</span><span class="s3">,</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s2">this</span><span class="s3">,</span>
    <span class="s1">Ctor </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">constructor</span><span class="s3">;</span>

  <span class="s2">if </span><span class="s3">(!</span><span class="s1">x</span><span class="s3">.</span><span class="s1">isFinite</span><span class="s3">() || </span><span class="s1">x</span><span class="s3">.</span><span class="s1">isZero</span><span class="s3">()) </span><span class="s2">return new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">x</span><span class="s3">);</span>

  <span class="s1">pr </span><span class="s3">= </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">precision</span><span class="s3">;</span>
  <span class="s1">rm </span><span class="s3">= </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">rounding</span><span class="s3">;</span>
  <span class="s1">Ctor</span><span class="s3">.</span><span class="s1">precision </span><span class="s3">= </span><span class="s1">pr </span><span class="s3">+ </span><span class="s1">Math</span><span class="s3">.</span><span class="s1">max</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">e</span><span class="s3">, </span><span class="s1">x</span><span class="s3">.</span><span class="s1">sd</span><span class="s3">()) + </span><span class="s4">4</span><span class="s3">;</span>
  <span class="s1">Ctor</span><span class="s3">.</span><span class="s1">rounding </span><span class="s3">= </span><span class="s4">1</span><span class="s3">;</span>
  <span class="s1">len </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">d</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span>

  <span class="s2">if </span><span class="s3">(</span><span class="s1">len </span><span class="s3">&lt; </span><span class="s4">3</span><span class="s3">) {</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s1">taylorSeries</span><span class="s3">(</span><span class="s1">Ctor</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s2">true</span><span class="s3">);</span>
  <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>

    <span class="s0">// Alternative argument reduction: sinh(3x) = sinh(x)(3 + 4sinh^2(x))</span>
    <span class="s0">// i.e. sinh(x) = sinh(x/3)(3 + 4sinh^2(x/3))</span>
    <span class="s0">// 3 multiplications and 1 addition</span>

    <span class="s0">// Argument reduction: sinh(5x) = sinh(x)(5 + sinh^2(x)(20 + 16sinh^2(x)))</span>
    <span class="s0">// i.e. sinh(x) = sinh(x/5)(5 + sinh^2(x/5)(20 + 16sinh^2(x/5)))</span>
    <span class="s0">// 4 multiplications and 2 additions</span>

    <span class="s0">// Estimate the optimum number of times to use the argument reduction.</span>
    <span class="s1">k </span><span class="s3">= </span><span class="s4">1.4 </span><span class="s3">* </span><span class="s1">Math</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">len</span><span class="s3">);</span>
    <span class="s1">k </span><span class="s3">= </span><span class="s1">k </span><span class="s3">&gt; </span><span class="s4">16 </span><span class="s3">? </span><span class="s4">16 </span><span class="s3">: </span><span class="s1">k </span><span class="s3">| </span><span class="s4">0</span><span class="s3">;</span>

    <span class="s1">x </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">times</span><span class="s3">(</span><span class="s4">1 </span><span class="s3">/ </span><span class="s1">tinyPow</span><span class="s3">(</span><span class="s4">5</span><span class="s3">, </span><span class="s1">k</span><span class="s3">));</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s1">taylorSeries</span><span class="s3">(</span><span class="s1">Ctor</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s2">true</span><span class="s3">);</span>

    <span class="s0">// Reverse argument reduction</span>
    <span class="s2">var </span><span class="s1">sinh2_x</span><span class="s3">,</span>
      <span class="s1">d5 </span><span class="s3">= </span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s4">5</span><span class="s3">),</span>
      <span class="s1">d16 </span><span class="s3">= </span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s4">16</span><span class="s3">),</span>
      <span class="s1">d20 </span><span class="s3">= </span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s4">20</span><span class="s3">);</span>
    <span class="s2">for </span><span class="s3">(; </span><span class="s1">k</span><span class="s3">--;) {</span>
      <span class="s1">sinh2_x </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">times</span><span class="s3">(</span><span class="s1">x</span><span class="s3">);</span>
      <span class="s1">x </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">times</span><span class="s3">(</span><span class="s1">d5</span><span class="s3">.</span><span class="s1">plus</span><span class="s3">(</span><span class="s1">sinh2_x</span><span class="s3">.</span><span class="s1">times</span><span class="s3">(</span><span class="s1">d16</span><span class="s3">.</span><span class="s1">times</span><span class="s3">(</span><span class="s1">sinh2_x</span><span class="s3">).</span><span class="s1">plus</span><span class="s3">(</span><span class="s1">d20</span><span class="s3">))));</span>
    <span class="s3">}</span>
  <span class="s3">}</span>

  <span class="s1">Ctor</span><span class="s3">.</span><span class="s1">precision </span><span class="s3">= </span><span class="s1">pr</span><span class="s3">;</span>
  <span class="s1">Ctor</span><span class="s3">.</span><span class="s1">rounding </span><span class="s3">= </span><span class="s1">rm</span><span class="s3">;</span>

  <span class="s2">return </span><span class="s1">finalise</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">pr</span><span class="s3">, </span><span class="s1">rm</span><span class="s3">, </span><span class="s2">true</span><span class="s3">);</span>
<span class="s3">};</span>


<span class="s0">/* 
 * Return a new Decimal whose value is the hyperbolic tangent of the value in radians of this 
 * Decimal. 
 * 
 * Domain: [-Infinity, Infinity] 
 * Range: [-1, 1] 
 * 
 * tanh(x) = sinh(x) / cosh(x) 
 * 
 * tanh(0)         = 0 
 * tanh(-0)        = -0 
 * tanh(Infinity)  = 1 
 * tanh(-Infinity) = -1 
 * tanh(NaN)       = NaN 
 * 
 */</span>
<span class="s1">P</span><span class="s3">.</span><span class="s1">hyperbolicTangent </span><span class="s3">= </span><span class="s1">P</span><span class="s3">.</span><span class="s1">tanh </span><span class="s3">= </span><span class="s2">function </span><span class="s3">() {</span>
  <span class="s2">var </span><span class="s1">pr</span><span class="s3">, </span><span class="s1">rm</span><span class="s3">,</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s2">this</span><span class="s3">,</span>
    <span class="s1">Ctor </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">constructor</span><span class="s3">;</span>

  <span class="s2">if </span><span class="s3">(!</span><span class="s1">x</span><span class="s3">.</span><span class="s1">isFinite</span><span class="s3">()) </span><span class="s2">return new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">s</span><span class="s3">);</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">isZero</span><span class="s3">()) </span><span class="s2">return new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">x</span><span class="s3">);</span>

  <span class="s1">pr </span><span class="s3">= </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">precision</span><span class="s3">;</span>
  <span class="s1">rm </span><span class="s3">= </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">rounding</span><span class="s3">;</span>
  <span class="s1">Ctor</span><span class="s3">.</span><span class="s1">precision </span><span class="s3">= </span><span class="s1">pr </span><span class="s3">+ </span><span class="s4">7</span><span class="s3">;</span>
  <span class="s1">Ctor</span><span class="s3">.</span><span class="s1">rounding </span><span class="s3">= </span><span class="s4">1</span><span class="s3">;</span>

  <span class="s2">return </span><span class="s1">divide</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">sinh</span><span class="s3">(), </span><span class="s1">x</span><span class="s3">.</span><span class="s1">cosh</span><span class="s3">(), </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">precision </span><span class="s3">= </span><span class="s1">pr</span><span class="s3">, </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">rounding </span><span class="s3">= </span><span class="s1">rm</span><span class="s3">);</span>
<span class="s3">};</span>


<span class="s0">/* 
 * Return a new Decimal whose value is the arccosine (inverse cosine) in radians of the value of 
 * this Decimal. 
 * 
 * Domain: [-1, 1] 
 * Range: [0, pi] 
 * 
 * acos(x) = pi/2 - asin(x) 
 * 
 * acos(0)       = pi/2 
 * acos(-0)      = pi/2 
 * acos(1)       = 0 
 * acos(-1)      = pi 
 * acos(1/2)     = pi/3 
 * acos(-1/2)    = 2*pi/3 
 * acos(|x| &gt; 1) = NaN 
 * acos(NaN)     = NaN 
 * 
 */</span>
<span class="s1">P</span><span class="s3">.</span><span class="s1">inverseCosine </span><span class="s3">= </span><span class="s1">P</span><span class="s3">.</span><span class="s1">acos </span><span class="s3">= </span><span class="s2">function </span><span class="s3">() {</span>
  <span class="s2">var </span><span class="s1">x </span><span class="s3">= </span><span class="s2">this</span><span class="s3">,</span>
    <span class="s1">Ctor </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">constructor</span><span class="s3">,</span>
    <span class="s1">k </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">abs</span><span class="s3">().</span><span class="s1">cmp</span><span class="s3">(</span><span class="s4">1</span><span class="s3">),</span>
    <span class="s1">pr </span><span class="s3">= </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">precision</span><span class="s3">,</span>
    <span class="s1">rm </span><span class="s3">= </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">rounding</span><span class="s3">;</span>

  <span class="s2">if </span><span class="s3">(</span><span class="s1">k </span><span class="s3">!== -</span><span class="s4">1</span><span class="s3">) {</span>
    <span class="s2">return </span><span class="s1">k </span><span class="s3">=== </span><span class="s4">0</span>
      <span class="s0">// |x| is 1</span>
      <span class="s3">? </span><span class="s1">x</span><span class="s3">.</span><span class="s1">isNeg</span><span class="s3">() ? </span><span class="s1">getPi</span><span class="s3">(</span><span class="s1">Ctor</span><span class="s3">, </span><span class="s1">pr</span><span class="s3">, </span><span class="s1">rm</span><span class="s3">) : </span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s4">0</span><span class="s3">)</span>
      <span class="s0">// |x| &gt; 1 or x is NaN</span>
      <span class="s3">: </span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">NaN</span><span class="s3">);</span>
  <span class="s3">}</span>

  <span class="s2">if </span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">isZero</span><span class="s3">()) </span><span class="s2">return </span><span class="s1">getPi</span><span class="s3">(</span><span class="s1">Ctor</span><span class="s3">, </span><span class="s1">pr </span><span class="s3">+ </span><span class="s4">4</span><span class="s3">, </span><span class="s1">rm</span><span class="s3">).</span><span class="s1">times</span><span class="s3">(</span><span class="s4">0.5</span><span class="s3">);</span>

  <span class="s0">// TODO? Special case acos(0.5) = pi/3 and acos(-0.5) = 2*pi/3</span>

  <span class="s1">Ctor</span><span class="s3">.</span><span class="s1">precision </span><span class="s3">= </span><span class="s1">pr </span><span class="s3">+ </span><span class="s4">6</span><span class="s3">;</span>
  <span class="s1">Ctor</span><span class="s3">.</span><span class="s1">rounding </span><span class="s3">= </span><span class="s4">1</span><span class="s3">;</span>

  <span class="s0">// See https://github.com/MikeMcl/decimal.js/pull/217</span>
  <span class="s1">x </span><span class="s3">= </span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s4">1</span><span class="s3">).</span><span class="s1">minus</span><span class="s3">(</span><span class="s1">x</span><span class="s3">).</span><span class="s1">div</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">plus</span><span class="s3">(</span><span class="s4">1</span><span class="s3">)).</span><span class="s1">sqrt</span><span class="s3">().</span><span class="s1">atan</span><span class="s3">();</span>

  <span class="s1">Ctor</span><span class="s3">.</span><span class="s1">precision </span><span class="s3">= </span><span class="s1">pr</span><span class="s3">;</span>
  <span class="s1">Ctor</span><span class="s3">.</span><span class="s1">rounding </span><span class="s3">= </span><span class="s1">rm</span><span class="s3">;</span>

  <span class="s2">return </span><span class="s1">x</span><span class="s3">.</span><span class="s1">times</span><span class="s3">(</span><span class="s4">2</span><span class="s3">);</span>
<span class="s3">};</span>


<span class="s0">/* 
 * Return a new Decimal whose value is the inverse of the hyperbolic cosine in radians of the 
 * value of this Decimal. 
 * 
 * Domain: [1, Infinity] 
 * Range: [0, Infinity] 
 * 
 * acosh(x) = ln(x + sqrt(x^2 - 1)) 
 * 
 * acosh(x &lt; 1)     = NaN 
 * acosh(NaN)       = NaN 
 * acosh(Infinity)  = Infinity 
 * acosh(-Infinity) = NaN 
 * acosh(0)         = NaN 
 * acosh(-0)        = NaN 
 * acosh(1)         = 0 
 * acosh(-1)        = NaN 
 * 
 */</span>
<span class="s1">P</span><span class="s3">.</span><span class="s1">inverseHyperbolicCosine </span><span class="s3">= </span><span class="s1">P</span><span class="s3">.</span><span class="s1">acosh </span><span class="s3">= </span><span class="s2">function </span><span class="s3">() {</span>
  <span class="s2">var </span><span class="s1">pr</span><span class="s3">, </span><span class="s1">rm</span><span class="s3">,</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s2">this</span><span class="s3">,</span>
    <span class="s1">Ctor </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">constructor</span><span class="s3">;</span>

  <span class="s2">if </span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">lte</span><span class="s3">(</span><span class="s4">1</span><span class="s3">)) </span><span class="s2">return new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">eq</span><span class="s3">(</span><span class="s4">1</span><span class="s3">) ? </span><span class="s4">0 </span><span class="s3">: </span><span class="s1">NaN</span><span class="s3">);</span>
  <span class="s2">if </span><span class="s3">(!</span><span class="s1">x</span><span class="s3">.</span><span class="s1">isFinite</span><span class="s3">()) </span><span class="s2">return new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">x</span><span class="s3">);</span>

  <span class="s1">pr </span><span class="s3">= </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">precision</span><span class="s3">;</span>
  <span class="s1">rm </span><span class="s3">= </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">rounding</span><span class="s3">;</span>
  <span class="s1">Ctor</span><span class="s3">.</span><span class="s1">precision </span><span class="s3">= </span><span class="s1">pr </span><span class="s3">+ </span><span class="s1">Math</span><span class="s3">.</span><span class="s1">max</span><span class="s3">(</span><span class="s1">Math</span><span class="s3">.</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">e</span><span class="s3">), </span><span class="s1">x</span><span class="s3">.</span><span class="s1">sd</span><span class="s3">()) + </span><span class="s4">4</span><span class="s3">;</span>
  <span class="s1">Ctor</span><span class="s3">.</span><span class="s1">rounding </span><span class="s3">= </span><span class="s4">1</span><span class="s3">;</span>
  <span class="s1">external </span><span class="s3">= </span><span class="s2">false</span><span class="s3">;</span>

  <span class="s1">x </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">times</span><span class="s3">(</span><span class="s1">x</span><span class="s3">).</span><span class="s1">minus</span><span class="s3">(</span><span class="s4">1</span><span class="s3">).</span><span class="s1">sqrt</span><span class="s3">().</span><span class="s1">plus</span><span class="s3">(</span><span class="s1">x</span><span class="s3">);</span>

  <span class="s1">external </span><span class="s3">= </span><span class="s2">true</span><span class="s3">;</span>
  <span class="s1">Ctor</span><span class="s3">.</span><span class="s1">precision </span><span class="s3">= </span><span class="s1">pr</span><span class="s3">;</span>
  <span class="s1">Ctor</span><span class="s3">.</span><span class="s1">rounding </span><span class="s3">= </span><span class="s1">rm</span><span class="s3">;</span>

  <span class="s2">return </span><span class="s1">x</span><span class="s3">.</span><span class="s1">ln</span><span class="s3">();</span>
<span class="s3">};</span>


<span class="s0">/* 
 * Return a new Decimal whose value is the inverse of the hyperbolic sine in radians of the value 
 * of this Decimal. 
 * 
 * Domain: [-Infinity, Infinity] 
 * Range: [-Infinity, Infinity] 
 * 
 * asinh(x) = ln(x + sqrt(x^2 + 1)) 
 * 
 * asinh(NaN)       = NaN 
 * asinh(Infinity)  = Infinity 
 * asinh(-Infinity) = -Infinity 
 * asinh(0)         = 0 
 * asinh(-0)        = -0 
 * 
 */</span>
<span class="s1">P</span><span class="s3">.</span><span class="s1">inverseHyperbolicSine </span><span class="s3">= </span><span class="s1">P</span><span class="s3">.</span><span class="s1">asinh </span><span class="s3">= </span><span class="s2">function </span><span class="s3">() {</span>
  <span class="s2">var </span><span class="s1">pr</span><span class="s3">, </span><span class="s1">rm</span><span class="s3">,</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s2">this</span><span class="s3">,</span>
    <span class="s1">Ctor </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">constructor</span><span class="s3">;</span>

  <span class="s2">if </span><span class="s3">(!</span><span class="s1">x</span><span class="s3">.</span><span class="s1">isFinite</span><span class="s3">() || </span><span class="s1">x</span><span class="s3">.</span><span class="s1">isZero</span><span class="s3">()) </span><span class="s2">return new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">x</span><span class="s3">);</span>

  <span class="s1">pr </span><span class="s3">= </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">precision</span><span class="s3">;</span>
  <span class="s1">rm </span><span class="s3">= </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">rounding</span><span class="s3">;</span>
  <span class="s1">Ctor</span><span class="s3">.</span><span class="s1">precision </span><span class="s3">= </span><span class="s1">pr </span><span class="s3">+ </span><span class="s4">2 </span><span class="s3">* </span><span class="s1">Math</span><span class="s3">.</span><span class="s1">max</span><span class="s3">(</span><span class="s1">Math</span><span class="s3">.</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">e</span><span class="s3">), </span><span class="s1">x</span><span class="s3">.</span><span class="s1">sd</span><span class="s3">()) + </span><span class="s4">6</span><span class="s3">;</span>
  <span class="s1">Ctor</span><span class="s3">.</span><span class="s1">rounding </span><span class="s3">= </span><span class="s4">1</span><span class="s3">;</span>
  <span class="s1">external </span><span class="s3">= </span><span class="s2">false</span><span class="s3">;</span>

  <span class="s1">x </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">times</span><span class="s3">(</span><span class="s1">x</span><span class="s3">).</span><span class="s1">plus</span><span class="s3">(</span><span class="s4">1</span><span class="s3">).</span><span class="s1">sqrt</span><span class="s3">().</span><span class="s1">plus</span><span class="s3">(</span><span class="s1">x</span><span class="s3">);</span>

  <span class="s1">external </span><span class="s3">= </span><span class="s2">true</span><span class="s3">;</span>
  <span class="s1">Ctor</span><span class="s3">.</span><span class="s1">precision </span><span class="s3">= </span><span class="s1">pr</span><span class="s3">;</span>
  <span class="s1">Ctor</span><span class="s3">.</span><span class="s1">rounding </span><span class="s3">= </span><span class="s1">rm</span><span class="s3">;</span>

  <span class="s2">return </span><span class="s1">x</span><span class="s3">.</span><span class="s1">ln</span><span class="s3">();</span>
<span class="s3">};</span>


<span class="s0">/* 
 * Return a new Decimal whose value is the inverse of the hyperbolic tangent in radians of the 
 * value of this Decimal. 
 * 
 * Domain: [-1, 1] 
 * Range: [-Infinity, Infinity] 
 * 
 * atanh(x) = 0.5 * ln((1 + x) / (1 - x)) 
 * 
 * atanh(|x| &gt; 1)   = NaN 
 * atanh(NaN)       = NaN 
 * atanh(Infinity)  = NaN 
 * atanh(-Infinity) = NaN 
 * atanh(0)         = 0 
 * atanh(-0)        = -0 
 * atanh(1)         = Infinity 
 * atanh(-1)        = -Infinity 
 * 
 */</span>
<span class="s1">P</span><span class="s3">.</span><span class="s1">inverseHyperbolicTangent </span><span class="s3">= </span><span class="s1">P</span><span class="s3">.</span><span class="s1">atanh </span><span class="s3">= </span><span class="s2">function </span><span class="s3">() {</span>
  <span class="s2">var </span><span class="s1">pr</span><span class="s3">, </span><span class="s1">rm</span><span class="s3">, </span><span class="s1">wpr</span><span class="s3">, </span><span class="s1">xsd</span><span class="s3">,</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s2">this</span><span class="s3">,</span>
    <span class="s1">Ctor </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">constructor</span><span class="s3">;</span>

  <span class="s2">if </span><span class="s3">(!</span><span class="s1">x</span><span class="s3">.</span><span class="s1">isFinite</span><span class="s3">()) </span><span class="s2">return new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">NaN</span><span class="s3">);</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">e </span><span class="s3">&gt;= </span><span class="s4">0</span><span class="s3">) </span><span class="s2">return new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">abs</span><span class="s3">().</span><span class="s1">eq</span><span class="s3">(</span><span class="s4">1</span><span class="s3">) ? </span><span class="s1">x</span><span class="s3">.</span><span class="s1">s </span><span class="s3">/ </span><span class="s4">0 </span><span class="s3">: </span><span class="s1">x</span><span class="s3">.</span><span class="s1">isZero</span><span class="s3">() ? </span><span class="s1">x </span><span class="s3">: </span><span class="s1">NaN</span><span class="s3">);</span>

  <span class="s1">pr </span><span class="s3">= </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">precision</span><span class="s3">;</span>
  <span class="s1">rm </span><span class="s3">= </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">rounding</span><span class="s3">;</span>
  <span class="s1">xsd </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">sd</span><span class="s3">();</span>

  <span class="s2">if </span><span class="s3">(</span><span class="s1">Math</span><span class="s3">.</span><span class="s1">max</span><span class="s3">(</span><span class="s1">xsd</span><span class="s3">, </span><span class="s1">pr</span><span class="s3">) &lt; </span><span class="s4">2 </span><span class="s3">* -</span><span class="s1">x</span><span class="s3">.</span><span class="s1">e </span><span class="s3">- </span><span class="s4">1</span><span class="s3">) </span><span class="s2">return </span><span class="s1">finalise</span><span class="s3">(</span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">x</span><span class="s3">), </span><span class="s1">pr</span><span class="s3">, </span><span class="s1">rm</span><span class="s3">, </span><span class="s2">true</span><span class="s3">);</span>

  <span class="s1">Ctor</span><span class="s3">.</span><span class="s1">precision </span><span class="s3">= </span><span class="s1">wpr </span><span class="s3">= </span><span class="s1">xsd </span><span class="s3">- </span><span class="s1">x</span><span class="s3">.</span><span class="s1">e</span><span class="s3">;</span>

  <span class="s1">x </span><span class="s3">= </span><span class="s1">divide</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">plus</span><span class="s3">(</span><span class="s4">1</span><span class="s3">), </span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s4">1</span><span class="s3">).</span><span class="s1">minus</span><span class="s3">(</span><span class="s1">x</span><span class="s3">), </span><span class="s1">wpr </span><span class="s3">+ </span><span class="s1">pr</span><span class="s3">, </span><span class="s4">1</span><span class="s3">);</span>

  <span class="s1">Ctor</span><span class="s3">.</span><span class="s1">precision </span><span class="s3">= </span><span class="s1">pr </span><span class="s3">+ </span><span class="s4">4</span><span class="s3">;</span>
  <span class="s1">Ctor</span><span class="s3">.</span><span class="s1">rounding </span><span class="s3">= </span><span class="s4">1</span><span class="s3">;</span>

  <span class="s1">x </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">ln</span><span class="s3">();</span>

  <span class="s1">Ctor</span><span class="s3">.</span><span class="s1">precision </span><span class="s3">= </span><span class="s1">pr</span><span class="s3">;</span>
  <span class="s1">Ctor</span><span class="s3">.</span><span class="s1">rounding </span><span class="s3">= </span><span class="s1">rm</span><span class="s3">;</span>

  <span class="s2">return </span><span class="s1">x</span><span class="s3">.</span><span class="s1">times</span><span class="s3">(</span><span class="s4">0.5</span><span class="s3">);</span>
<span class="s3">};</span>


<span class="s0">/* 
 * Return a new Decimal whose value is the arcsine (inverse sine) in radians of the value of this 
 * Decimal. 
 * 
 * Domain: [-Infinity, Infinity] 
 * Range: [-pi/2, pi/2] 
 * 
 * asin(x) = 2*atan(x/(1 + sqrt(1 - x^2))) 
 * 
 * asin(0)       = 0 
 * asin(-0)      = -0 
 * asin(1/2)     = pi/6 
 * asin(-1/2)    = -pi/6 
 * asin(1)       = pi/2 
 * asin(-1)      = -pi/2 
 * asin(|x| &gt; 1) = NaN 
 * asin(NaN)     = NaN 
 * 
 * TODO? Compare performance of Taylor series. 
 * 
 */</span>
<span class="s1">P</span><span class="s3">.</span><span class="s1">inverseSine </span><span class="s3">= </span><span class="s1">P</span><span class="s3">.</span><span class="s1">asin </span><span class="s3">= </span><span class="s2">function </span><span class="s3">() {</span>
  <span class="s2">var </span><span class="s1">halfPi</span><span class="s3">, </span><span class="s1">k</span><span class="s3">,</span>
    <span class="s1">pr</span><span class="s3">, </span><span class="s1">rm</span><span class="s3">,</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s2">this</span><span class="s3">,</span>
    <span class="s1">Ctor </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">constructor</span><span class="s3">;</span>

  <span class="s2">if </span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">isZero</span><span class="s3">()) </span><span class="s2">return new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">x</span><span class="s3">);</span>

  <span class="s1">k </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">abs</span><span class="s3">().</span><span class="s1">cmp</span><span class="s3">(</span><span class="s4">1</span><span class="s3">);</span>
  <span class="s1">pr </span><span class="s3">= </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">precision</span><span class="s3">;</span>
  <span class="s1">rm </span><span class="s3">= </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">rounding</span><span class="s3">;</span>

  <span class="s2">if </span><span class="s3">(</span><span class="s1">k </span><span class="s3">!== -</span><span class="s4">1</span><span class="s3">) {</span>

    <span class="s0">// |x| is 1</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">k </span><span class="s3">=== </span><span class="s4">0</span><span class="s3">) {</span>
      <span class="s1">halfPi </span><span class="s3">= </span><span class="s1">getPi</span><span class="s3">(</span><span class="s1">Ctor</span><span class="s3">, </span><span class="s1">pr </span><span class="s3">+ </span><span class="s4">4</span><span class="s3">, </span><span class="s1">rm</span><span class="s3">).</span><span class="s1">times</span><span class="s3">(</span><span class="s4">0.5</span><span class="s3">);</span>
      <span class="s1">halfPi</span><span class="s3">.</span><span class="s1">s </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">s</span><span class="s3">;</span>
      <span class="s2">return </span><span class="s1">halfPi</span><span class="s3">;</span>
    <span class="s3">}</span>

    <span class="s0">// |x| &gt; 1 or x is NaN</span>
    <span class="s2">return new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">NaN</span><span class="s3">);</span>
  <span class="s3">}</span>

  <span class="s0">// TODO? Special case asin(1/2) = pi/6 and asin(-1/2) = -pi/6</span>

  <span class="s1">Ctor</span><span class="s3">.</span><span class="s1">precision </span><span class="s3">= </span><span class="s1">pr </span><span class="s3">+ </span><span class="s4">6</span><span class="s3">;</span>
  <span class="s1">Ctor</span><span class="s3">.</span><span class="s1">rounding </span><span class="s3">= </span><span class="s4">1</span><span class="s3">;</span>

  <span class="s1">x </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">div</span><span class="s3">(</span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s4">1</span><span class="s3">).</span><span class="s1">minus</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">times</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)).</span><span class="s1">sqrt</span><span class="s3">().</span><span class="s1">plus</span><span class="s3">(</span><span class="s4">1</span><span class="s3">)).</span><span class="s1">atan</span><span class="s3">();</span>

  <span class="s1">Ctor</span><span class="s3">.</span><span class="s1">precision </span><span class="s3">= </span><span class="s1">pr</span><span class="s3">;</span>
  <span class="s1">Ctor</span><span class="s3">.</span><span class="s1">rounding </span><span class="s3">= </span><span class="s1">rm</span><span class="s3">;</span>

  <span class="s2">return </span><span class="s1">x</span><span class="s3">.</span><span class="s1">times</span><span class="s3">(</span><span class="s4">2</span><span class="s3">);</span>
<span class="s3">};</span>


<span class="s0">/* 
 * Return a new Decimal whose value is the arctangent (inverse tangent) in radians of the value 
 * of this Decimal. 
 * 
 * Domain: [-Infinity, Infinity] 
 * Range: [-pi/2, pi/2] 
 * 
 * atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ... 
 * 
 * atan(0)         = 0 
 * atan(-0)        = -0 
 * atan(1)         = pi/4 
 * atan(-1)        = -pi/4 
 * atan(Infinity)  = pi/2 
 * atan(-Infinity) = -pi/2 
 * atan(NaN)       = NaN 
 * 
 */</span>
<span class="s1">P</span><span class="s3">.</span><span class="s1">inverseTangent </span><span class="s3">= </span><span class="s1">P</span><span class="s3">.</span><span class="s1">atan </span><span class="s3">= </span><span class="s2">function </span><span class="s3">() {</span>
  <span class="s2">var </span><span class="s1">i</span><span class="s3">, </span><span class="s1">j</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">px</span><span class="s3">, </span><span class="s1">t</span><span class="s3">, </span><span class="s1">r</span><span class="s3">, </span><span class="s1">wpr</span><span class="s3">, </span><span class="s1">x2</span><span class="s3">,</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s2">this</span><span class="s3">,</span>
    <span class="s1">Ctor </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">constructor</span><span class="s3">,</span>
    <span class="s1">pr </span><span class="s3">= </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">precision</span><span class="s3">,</span>
    <span class="s1">rm </span><span class="s3">= </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">rounding</span><span class="s3">;</span>

  <span class="s2">if </span><span class="s3">(!</span><span class="s1">x</span><span class="s3">.</span><span class="s1">isFinite</span><span class="s3">()) {</span>
    <span class="s2">if </span><span class="s3">(!</span><span class="s1">x</span><span class="s3">.</span><span class="s1">s</span><span class="s3">) </span><span class="s2">return new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">NaN</span><span class="s3">);</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">pr </span><span class="s3">+ </span><span class="s4">4 </span><span class="s3">&lt;= </span><span class="s1">PI_PRECISION</span><span class="s3">) {</span>
      <span class="s1">r </span><span class="s3">= </span><span class="s1">getPi</span><span class="s3">(</span><span class="s1">Ctor</span><span class="s3">, </span><span class="s1">pr </span><span class="s3">+ </span><span class="s4">4</span><span class="s3">, </span><span class="s1">rm</span><span class="s3">).</span><span class="s1">times</span><span class="s3">(</span><span class="s4">0.5</span><span class="s3">);</span>
      <span class="s1">r</span><span class="s3">.</span><span class="s1">s </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">s</span><span class="s3">;</span>
      <span class="s2">return </span><span class="s1">r</span><span class="s3">;</span>
    <span class="s3">}</span>
  <span class="s3">} </span><span class="s2">else if </span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">isZero</span><span class="s3">()) {</span>
    <span class="s2">return new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">x</span><span class="s3">);</span>
  <span class="s3">} </span><span class="s2">else if </span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">abs</span><span class="s3">().</span><span class="s1">eq</span><span class="s3">(</span><span class="s4">1</span><span class="s3">) &amp;&amp; </span><span class="s1">pr </span><span class="s3">+ </span><span class="s4">4 </span><span class="s3">&lt;= </span><span class="s1">PI_PRECISION</span><span class="s3">) {</span>
    <span class="s1">r </span><span class="s3">= </span><span class="s1">getPi</span><span class="s3">(</span><span class="s1">Ctor</span><span class="s3">, </span><span class="s1">pr </span><span class="s3">+ </span><span class="s4">4</span><span class="s3">, </span><span class="s1">rm</span><span class="s3">).</span><span class="s1">times</span><span class="s3">(</span><span class="s4">0.25</span><span class="s3">);</span>
    <span class="s1">r</span><span class="s3">.</span><span class="s1">s </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">s</span><span class="s3">;</span>
    <span class="s2">return </span><span class="s1">r</span><span class="s3">;</span>
  <span class="s3">}</span>

  <span class="s1">Ctor</span><span class="s3">.</span><span class="s1">precision </span><span class="s3">= </span><span class="s1">wpr </span><span class="s3">= </span><span class="s1">pr </span><span class="s3">+ </span><span class="s4">10</span><span class="s3">;</span>
  <span class="s1">Ctor</span><span class="s3">.</span><span class="s1">rounding </span><span class="s3">= </span><span class="s4">1</span><span class="s3">;</span>

  <span class="s0">// TODO? if (x &gt;= 1 &amp;&amp; pr &lt;= PI_PRECISION) atan(x) = halfPi * x.s - atan(1 / x);</span>

  <span class="s0">// Argument reduction</span>
  <span class="s0">// Ensure |x| &lt; 0.42</span>
  <span class="s0">// atan(x) = 2 * atan(x / (1 + sqrt(1 + x^2)))</span>

  <span class="s1">k </span><span class="s3">= </span><span class="s1">Math</span><span class="s3">.</span><span class="s1">min</span><span class="s3">(</span><span class="s4">28</span><span class="s3">, </span><span class="s1">wpr </span><span class="s3">/ </span><span class="s1">LOG_BASE </span><span class="s3">+ </span><span class="s4">2 </span><span class="s3">| </span><span class="s4">0</span><span class="s3">);</span>

  <span class="s2">for </span><span class="s3">(</span><span class="s1">i </span><span class="s3">= </span><span class="s1">k</span><span class="s3">; </span><span class="s1">i</span><span class="s3">; --</span><span class="s1">i</span><span class="s3">) </span><span class="s1">x </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">div</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">times</span><span class="s3">(</span><span class="s1">x</span><span class="s3">).</span><span class="s1">plus</span><span class="s3">(</span><span class="s4">1</span><span class="s3">).</span><span class="s1">sqrt</span><span class="s3">().</span><span class="s1">plus</span><span class="s3">(</span><span class="s4">1</span><span class="s3">));</span>

  <span class="s1">external </span><span class="s3">= </span><span class="s2">false</span><span class="s3">;</span>

  <span class="s1">j </span><span class="s3">= </span><span class="s1">Math</span><span class="s3">.</span><span class="s1">ceil</span><span class="s3">(</span><span class="s1">wpr </span><span class="s3">/ </span><span class="s1">LOG_BASE</span><span class="s3">);</span>
  <span class="s1">n </span><span class="s3">= </span><span class="s4">1</span><span class="s3">;</span>
  <span class="s1">x2 </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">times</span><span class="s3">(</span><span class="s1">x</span><span class="s3">);</span>
  <span class="s1">r </span><span class="s3">= </span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">x</span><span class="s3">);</span>
  <span class="s1">px </span><span class="s3">= </span><span class="s1">x</span><span class="s3">;</span>

  <span class="s0">// atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...</span>
  <span class="s2">for </span><span class="s3">(; </span><span class="s1">i </span><span class="s3">!== -</span><span class="s4">1</span><span class="s3">;) {</span>
    <span class="s1">px </span><span class="s3">= </span><span class="s1">px</span><span class="s3">.</span><span class="s1">times</span><span class="s3">(</span><span class="s1">x2</span><span class="s3">);</span>
    <span class="s1">t </span><span class="s3">= </span><span class="s1">r</span><span class="s3">.</span><span class="s1">minus</span><span class="s3">(</span><span class="s1">px</span><span class="s3">.</span><span class="s1">div</span><span class="s3">(</span><span class="s1">n </span><span class="s3">+= </span><span class="s4">2</span><span class="s3">));</span>

    <span class="s1">px </span><span class="s3">= </span><span class="s1">px</span><span class="s3">.</span><span class="s1">times</span><span class="s3">(</span><span class="s1">x2</span><span class="s3">);</span>
    <span class="s1">r </span><span class="s3">= </span><span class="s1">t</span><span class="s3">.</span><span class="s1">plus</span><span class="s3">(</span><span class="s1">px</span><span class="s3">.</span><span class="s1">div</span><span class="s3">(</span><span class="s1">n </span><span class="s3">+= </span><span class="s4">2</span><span class="s3">));</span>

    <span class="s2">if </span><span class="s3">(</span><span class="s1">r</span><span class="s3">.</span><span class="s1">d</span><span class="s3">[</span><span class="s1">j</span><span class="s3">] !== </span><span class="s2">void </span><span class="s4">0</span><span class="s3">) </span><span class="s2">for </span><span class="s3">(</span><span class="s1">i </span><span class="s3">= </span><span class="s1">j</span><span class="s3">; </span><span class="s1">r</span><span class="s3">.</span><span class="s1">d</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] === </span><span class="s1">t</span><span class="s3">.</span><span class="s1">d</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] &amp;&amp; </span><span class="s1">i</span><span class="s3">--;);</span>
  <span class="s3">}</span>

  <span class="s2">if </span><span class="s3">(</span><span class="s1">k</span><span class="s3">) </span><span class="s1">r </span><span class="s3">= </span><span class="s1">r</span><span class="s3">.</span><span class="s1">times</span><span class="s3">(</span><span class="s4">2 </span><span class="s3">&lt;&lt; (</span><span class="s1">k </span><span class="s3">- </span><span class="s4">1</span><span class="s3">));</span>

  <span class="s1">external </span><span class="s3">= </span><span class="s2">true</span><span class="s3">;</span>

  <span class="s2">return </span><span class="s1">finalise</span><span class="s3">(</span><span class="s1">r</span><span class="s3">, </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">precision </span><span class="s3">= </span><span class="s1">pr</span><span class="s3">, </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">rounding </span><span class="s3">= </span><span class="s1">rm</span><span class="s3">, </span><span class="s2">true</span><span class="s3">);</span>
<span class="s3">};</span>


<span class="s0">/* 
 * Return true if the value of this Decimal is a finite number, otherwise return false. 
 * 
 */</span>
<span class="s1">P</span><span class="s3">.</span><span class="s1">isFinite </span><span class="s3">= </span><span class="s2">function </span><span class="s3">() {</span>
  <span class="s2">return </span><span class="s3">!!</span><span class="s2">this</span><span class="s3">.</span><span class="s1">d</span><span class="s3">;</span>
<span class="s3">};</span>


<span class="s0">/* 
 * Return true if the value of this Decimal is an integer, otherwise return false. 
 * 
 */</span>
<span class="s1">P</span><span class="s3">.</span><span class="s1">isInteger </span><span class="s3">= </span><span class="s1">P</span><span class="s3">.</span><span class="s1">isInt </span><span class="s3">= </span><span class="s2">function </span><span class="s3">() {</span>
  <span class="s2">return </span><span class="s3">!!</span><span class="s2">this</span><span class="s3">.</span><span class="s1">d </span><span class="s3">&amp;&amp; </span><span class="s1">mathfloor</span><span class="s3">(</span><span class="s2">this</span><span class="s3">.</span><span class="s1">e </span><span class="s3">/ </span><span class="s1">LOG_BASE</span><span class="s3">) &gt; </span><span class="s2">this</span><span class="s3">.</span><span class="s1">d</span><span class="s3">.</span><span class="s1">length </span><span class="s3">- </span><span class="s4">2</span><span class="s3">;</span>
<span class="s3">};</span>


<span class="s0">/* 
 * Return true if the value of this Decimal is NaN, otherwise return false. 
 * 
 */</span>
<span class="s1">P</span><span class="s3">.</span><span class="s1">isNaN </span><span class="s3">= </span><span class="s2">function </span><span class="s3">() {</span>
  <span class="s2">return </span><span class="s3">!</span><span class="s2">this</span><span class="s3">.</span><span class="s1">s</span><span class="s3">;</span>
<span class="s3">};</span>


<span class="s0">/* 
 * Return true if the value of this Decimal is negative, otherwise return false. 
 * 
 */</span>
<span class="s1">P</span><span class="s3">.</span><span class="s1">isNegative </span><span class="s3">= </span><span class="s1">P</span><span class="s3">.</span><span class="s1">isNeg </span><span class="s3">= </span><span class="s2">function </span><span class="s3">() {</span>
  <span class="s2">return this</span><span class="s3">.</span><span class="s1">s </span><span class="s3">&lt; </span><span class="s4">0</span><span class="s3">;</span>
<span class="s3">};</span>


<span class="s0">/* 
 * Return true if the value of this Decimal is positive, otherwise return false. 
 * 
 */</span>
<span class="s1">P</span><span class="s3">.</span><span class="s1">isPositive </span><span class="s3">= </span><span class="s1">P</span><span class="s3">.</span><span class="s1">isPos </span><span class="s3">= </span><span class="s2">function </span><span class="s3">() {</span>
  <span class="s2">return this</span><span class="s3">.</span><span class="s1">s </span><span class="s3">&gt; </span><span class="s4">0</span><span class="s3">;</span>
<span class="s3">};</span>


<span class="s0">/* 
 * Return true if the value of this Decimal is 0 or -0, otherwise return false. 
 * 
 */</span>
<span class="s1">P</span><span class="s3">.</span><span class="s1">isZero </span><span class="s3">= </span><span class="s2">function </span><span class="s3">() {</span>
  <span class="s2">return </span><span class="s3">!!</span><span class="s2">this</span><span class="s3">.</span><span class="s1">d </span><span class="s3">&amp;&amp; </span><span class="s2">this</span><span class="s3">.</span><span class="s1">d</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] === </span><span class="s4">0</span><span class="s3">;</span>
<span class="s3">};</span>


<span class="s0">/* 
 * Return true if the value of this Decimal is less than `y`, otherwise return false. 
 * 
 */</span>
<span class="s1">P</span><span class="s3">.</span><span class="s1">lessThan </span><span class="s3">= </span><span class="s1">P</span><span class="s3">.</span><span class="s1">lt </span><span class="s3">= </span><span class="s2">function </span><span class="s3">(</span><span class="s1">y</span><span class="s3">) {</span>
  <span class="s2">return this</span><span class="s3">.</span><span class="s1">cmp</span><span class="s3">(</span><span class="s1">y</span><span class="s3">) &lt; </span><span class="s4">0</span><span class="s3">;</span>
<span class="s3">};</span>


<span class="s0">/* 
 * Return true if the value of this Decimal is less than or equal to `y`, otherwise return false. 
 * 
 */</span>
<span class="s1">P</span><span class="s3">.</span><span class="s1">lessThanOrEqualTo </span><span class="s3">= </span><span class="s1">P</span><span class="s3">.</span><span class="s1">lte </span><span class="s3">= </span><span class="s2">function </span><span class="s3">(</span><span class="s1">y</span><span class="s3">) {</span>
  <span class="s2">return this</span><span class="s3">.</span><span class="s1">cmp</span><span class="s3">(</span><span class="s1">y</span><span class="s3">) &lt; </span><span class="s4">1</span><span class="s3">;</span>
<span class="s3">};</span>


<span class="s0">/* 
 * Return the logarithm of the value of this Decimal to the specified base, rounded to `precision` 
 * significant digits using rounding mode `rounding`. 
 * 
 * If no base is specified, return log[10](arg). 
 * 
 * log[base](arg) = ln(arg) / ln(base) 
 * 
 * The result will always be correctly rounded if the base of the log is 10, and 'almost always' 
 * otherwise: 
 * 
 * Depending on the rounding mode, the result may be incorrectly rounded if the first fifteen 
 * rounding digits are [49]99999999999999 or [50]00000000000000. In that case, the maximum error 
 * between the result and the correctly rounded result will be one ulp (unit in the last place). 
 * 
 * log[-b](a)       = NaN 
 * log[0](a)        = NaN 
 * log[1](a)        = NaN 
 * log[NaN](a)      = NaN 
 * log[Infinity](a) = NaN 
 * log[b](0)        = -Infinity 
 * log[b](-0)       = -Infinity 
 * log[b](-a)       = NaN 
 * log[b](1)        = 0 
 * log[b](Infinity) = Infinity 
 * log[b](NaN)      = NaN 
 * 
 * [base] {number|string|bigint|Decimal} The base of the logarithm. 
 * 
 */</span>
<span class="s1">P</span><span class="s3">.</span><span class="s1">logarithm </span><span class="s3">= </span><span class="s1">P</span><span class="s3">.</span><span class="s1">log </span><span class="s3">= </span><span class="s2">function </span><span class="s3">(</span><span class="s1">base</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">isBase10</span><span class="s3">, </span><span class="s1">d</span><span class="s3">, </span><span class="s1">denominator</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">inf</span><span class="s3">, </span><span class="s1">num</span><span class="s3">, </span><span class="s1">sd</span><span class="s3">, </span><span class="s1">r</span><span class="s3">,</span>
    <span class="s1">arg </span><span class="s3">= </span><span class="s2">this</span><span class="s3">,</span>
    <span class="s1">Ctor </span><span class="s3">= </span><span class="s1">arg</span><span class="s3">.</span><span class="s1">constructor</span><span class="s3">,</span>
    <span class="s1">pr </span><span class="s3">= </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">precision</span><span class="s3">,</span>
    <span class="s1">rm </span><span class="s3">= </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">rounding</span><span class="s3">,</span>
    <span class="s1">guard </span><span class="s3">= </span><span class="s4">5</span><span class="s3">;</span>

  <span class="s0">// Default base is 10.</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">base </span><span class="s3">== </span><span class="s2">null</span><span class="s3">) {</span>
    <span class="s1">base </span><span class="s3">= </span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s4">10</span><span class="s3">);</span>
    <span class="s1">isBase10 </span><span class="s3">= </span><span class="s2">true</span><span class="s3">;</span>
  <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
    <span class="s1">base </span><span class="s3">= </span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">base</span><span class="s3">);</span>
    <span class="s1">d </span><span class="s3">= </span><span class="s1">base</span><span class="s3">.</span><span class="s1">d</span><span class="s3">;</span>

    <span class="s0">// Return NaN if base is negative, or non-finite, or is 0 or 1.</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">base</span><span class="s3">.</span><span class="s1">s </span><span class="s3">&lt; </span><span class="s4">0 </span><span class="s3">|| !</span><span class="s1">d </span><span class="s3">|| !</span><span class="s1">d</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] || </span><span class="s1">base</span><span class="s3">.</span><span class="s1">eq</span><span class="s3">(</span><span class="s4">1</span><span class="s3">)) </span><span class="s2">return new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">NaN</span><span class="s3">);</span>

    <span class="s1">isBase10 </span><span class="s3">= </span><span class="s1">base</span><span class="s3">.</span><span class="s1">eq</span><span class="s3">(</span><span class="s4">10</span><span class="s3">);</span>
  <span class="s3">}</span>

  <span class="s1">d </span><span class="s3">= </span><span class="s1">arg</span><span class="s3">.</span><span class="s1">d</span><span class="s3">;</span>

  <span class="s0">// Is arg negative, non-finite, 0 or 1?</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">arg</span><span class="s3">.</span><span class="s1">s </span><span class="s3">&lt; </span><span class="s4">0 </span><span class="s3">|| !</span><span class="s1">d </span><span class="s3">|| !</span><span class="s1">d</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] || </span><span class="s1">arg</span><span class="s3">.</span><span class="s1">eq</span><span class="s3">(</span><span class="s4">1</span><span class="s3">)) {</span>
    <span class="s2">return new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">d </span><span class="s3">&amp;&amp; !</span><span class="s1">d</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] ? -</span><span class="s4">1 </span><span class="s3">/ </span><span class="s4">0 </span><span class="s3">: </span><span class="s1">arg</span><span class="s3">.</span><span class="s1">s </span><span class="s3">!= </span><span class="s4">1 </span><span class="s3">? </span><span class="s1">NaN </span><span class="s3">: </span><span class="s1">d </span><span class="s3">? </span><span class="s4">0 </span><span class="s3">: </span><span class="s4">1 </span><span class="s3">/ </span><span class="s4">0</span><span class="s3">);</span>
  <span class="s3">}</span>

  <span class="s0">// The result will have a non-terminating decimal expansion if base is 10 and arg is not an</span>
  <span class="s0">// integer power of 10.</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">isBase10</span><span class="s3">) {</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">d</span><span class="s3">.</span><span class="s1">length </span><span class="s3">&gt; </span><span class="s4">1</span><span class="s3">) {</span>
      <span class="s1">inf </span><span class="s3">= </span><span class="s2">true</span><span class="s3">;</span>
    <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
      <span class="s2">for </span><span class="s3">(</span><span class="s1">k </span><span class="s3">= </span><span class="s1">d</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]; </span><span class="s1">k </span><span class="s3">% </span><span class="s4">10 </span><span class="s3">=== </span><span class="s4">0</span><span class="s3">;) </span><span class="s1">k </span><span class="s3">/= </span><span class="s4">10</span><span class="s3">;</span>
      <span class="s1">inf </span><span class="s3">= </span><span class="s1">k </span><span class="s3">!== </span><span class="s4">1</span><span class="s3">;</span>
    <span class="s3">}</span>
  <span class="s3">}</span>

  <span class="s1">external </span><span class="s3">= </span><span class="s2">false</span><span class="s3">;</span>
  <span class="s1">sd </span><span class="s3">= </span><span class="s1">pr </span><span class="s3">+ </span><span class="s1">guard</span><span class="s3">;</span>
  <span class="s1">num </span><span class="s3">= </span><span class="s1">naturalLogarithm</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">, </span><span class="s1">sd</span><span class="s3">);</span>
  <span class="s1">denominator </span><span class="s3">= </span><span class="s1">isBase10 </span><span class="s3">? </span><span class="s1">getLn10</span><span class="s3">(</span><span class="s1">Ctor</span><span class="s3">, </span><span class="s1">sd </span><span class="s3">+ </span><span class="s4">10</span><span class="s3">) : </span><span class="s1">naturalLogarithm</span><span class="s3">(</span><span class="s1">base</span><span class="s3">, </span><span class="s1">sd</span><span class="s3">);</span>

  <span class="s0">// The result will have 5 rounding digits.</span>
  <span class="s1">r </span><span class="s3">= </span><span class="s1">divide</span><span class="s3">(</span><span class="s1">num</span><span class="s3">, </span><span class="s1">denominator</span><span class="s3">, </span><span class="s1">sd</span><span class="s3">, </span><span class="s4">1</span><span class="s3">);</span>

  <span class="s0">// If at a rounding boundary, i.e. the result's rounding digits are [49]9999 or [50]0000,</span>
  <span class="s0">// calculate 10 further digits.</span>
  <span class="s0">//</span>
  <span class="s0">// If the result is known to have an infinite decimal expansion, repeat this until it is clear</span>
  <span class="s0">// that the result is above or below the boundary. Otherwise, if after calculating the 10</span>
  <span class="s0">// further digits, the last 14 are nines, round up and assume the result is exact.</span>
  <span class="s0">// Also assume the result is exact if the last 14 are zero.</span>
  <span class="s0">//</span>
  <span class="s0">// Example of a result that will be incorrectly rounded:</span>
  <span class="s0">// log[1048576](4503599627370502) = 2.60000000000000009610279511444746...</span>
  <span class="s0">// The above result correctly rounded using ROUND_CEIL to 1 decimal place should be 2.7, but it</span>
  <span class="s0">// will be given as 2.6 as there are 15 zeros immediately after the requested decimal place, so</span>
  <span class="s0">// the exact result would be assumed to be 2.6, which rounded using ROUND_CEIL to 1 decimal</span>
  <span class="s0">// place is still 2.6.</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">checkRoundingDigits</span><span class="s3">(</span><span class="s1">r</span><span class="s3">.</span><span class="s1">d</span><span class="s3">, </span><span class="s1">k </span><span class="s3">= </span><span class="s1">pr</span><span class="s3">, </span><span class="s1">rm</span><span class="s3">)) {</span>

    <span class="s2">do </span><span class="s3">{</span>
      <span class="s1">sd </span><span class="s3">+= </span><span class="s4">10</span><span class="s3">;</span>
      <span class="s1">num </span><span class="s3">= </span><span class="s1">naturalLogarithm</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">, </span><span class="s1">sd</span><span class="s3">);</span>
      <span class="s1">denominator </span><span class="s3">= </span><span class="s1">isBase10 </span><span class="s3">? </span><span class="s1">getLn10</span><span class="s3">(</span><span class="s1">Ctor</span><span class="s3">, </span><span class="s1">sd </span><span class="s3">+ </span><span class="s4">10</span><span class="s3">) : </span><span class="s1">naturalLogarithm</span><span class="s3">(</span><span class="s1">base</span><span class="s3">, </span><span class="s1">sd</span><span class="s3">);</span>
      <span class="s1">r </span><span class="s3">= </span><span class="s1">divide</span><span class="s3">(</span><span class="s1">num</span><span class="s3">, </span><span class="s1">denominator</span><span class="s3">, </span><span class="s1">sd</span><span class="s3">, </span><span class="s4">1</span><span class="s3">);</span>

      <span class="s2">if </span><span class="s3">(!</span><span class="s1">inf</span><span class="s3">) {</span>

        <span class="s0">// Check for 14 nines from the 2nd rounding digit, as the first may be 4.</span>
        <span class="s2">if </span><span class="s3">(+</span><span class="s1">digitsToString</span><span class="s3">(</span><span class="s1">r</span><span class="s3">.</span><span class="s1">d</span><span class="s3">).</span><span class="s1">slice</span><span class="s3">(</span><span class="s1">k </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">, </span><span class="s1">k </span><span class="s3">+ </span><span class="s4">15</span><span class="s3">) + </span><span class="s4">1 </span><span class="s3">== </span><span class="s4">1e14</span><span class="s3">) {</span>
          <span class="s1">r </span><span class="s3">= </span><span class="s1">finalise</span><span class="s3">(</span><span class="s1">r</span><span class="s3">, </span><span class="s1">pr </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">, </span><span class="s4">0</span><span class="s3">);</span>
        <span class="s3">}</span>

        <span class="s2">break</span><span class="s3">;</span>
      <span class="s3">}</span>
    <span class="s3">} </span><span class="s2">while </span><span class="s3">(</span><span class="s1">checkRoundingDigits</span><span class="s3">(</span><span class="s1">r</span><span class="s3">.</span><span class="s1">d</span><span class="s3">, </span><span class="s1">k </span><span class="s3">+= </span><span class="s4">10</span><span class="s3">, </span><span class="s1">rm</span><span class="s3">));</span>
  <span class="s3">}</span>

  <span class="s1">external </span><span class="s3">= </span><span class="s2">true</span><span class="s3">;</span>

  <span class="s2">return </span><span class="s1">finalise</span><span class="s3">(</span><span class="s1">r</span><span class="s3">, </span><span class="s1">pr</span><span class="s3">, </span><span class="s1">rm</span><span class="s3">);</span>
<span class="s3">};</span>


<span class="s0">/* 
 * Return a new Decimal whose value is the maximum of the arguments and the value of this Decimal. 
 * 
 * arguments {number|string|bigint|Decimal} 
 * 
P.max = function () { 
  Array.prototype.push.call(arguments, this); 
  return maxOrMin(this.constructor, arguments, -1); 
}; 
 */</span>


<span class="s0">/* 
 * Return a new Decimal whose value is the minimum of the arguments and the value of this Decimal. 
 * 
 * arguments {number|string|bigint|Decimal} 
 * 
P.min = function () { 
  Array.prototype.push.call(arguments, this); 
  return maxOrMin(this.constructor, arguments, 1); 
}; 
 */</span>


<span class="s0">/* 
 *  n - 0 = n 
 *  n - N = N 
 *  n - I = -I 
 *  0 - n = -n 
 *  0 - 0 = 0 
 *  0 - N = N 
 *  0 - I = -I 
 *  N - n = N 
 *  N - 0 = N 
 *  N - N = N 
 *  N - I = N 
 *  I - n = I 
 *  I - 0 = I 
 *  I - N = N 
 *  I - I = N 
 * 
 * Return a new Decimal whose value is the value of this Decimal minus `y`, rounded to `precision` 
 * significant digits using rounding mode `rounding`. 
 * 
 */</span>
<span class="s1">P</span><span class="s3">.</span><span class="s1">minus </span><span class="s3">= </span><span class="s1">P</span><span class="s3">.</span><span class="s1">sub </span><span class="s3">= </span><span class="s2">function </span><span class="s3">(</span><span class="s1">y</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">d</span><span class="s3">, </span><span class="s1">e</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">j</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">len</span><span class="s3">, </span><span class="s1">pr</span><span class="s3">, </span><span class="s1">rm</span><span class="s3">, </span><span class="s1">xd</span><span class="s3">, </span><span class="s1">xe</span><span class="s3">, </span><span class="s1">xLTy</span><span class="s3">, </span><span class="s1">yd</span><span class="s3">,</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s2">this</span><span class="s3">,</span>
    <span class="s1">Ctor </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">constructor</span><span class="s3">;</span>

  <span class="s1">y </span><span class="s3">= </span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">y</span><span class="s3">);</span>

  <span class="s0">// If either is not finite...</span>
  <span class="s2">if </span><span class="s3">(!</span><span class="s1">x</span><span class="s3">.</span><span class="s1">d </span><span class="s3">|| !</span><span class="s1">y</span><span class="s3">.</span><span class="s1">d</span><span class="s3">) {</span>

    <span class="s0">// Return NaN if either is NaN.</span>
    <span class="s2">if </span><span class="s3">(!</span><span class="s1">x</span><span class="s3">.</span><span class="s1">s </span><span class="s3">|| !</span><span class="s1">y</span><span class="s3">.</span><span class="s1">s</span><span class="s3">) </span><span class="s1">y </span><span class="s3">= </span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">NaN</span><span class="s3">);</span>

    <span class="s0">// Return y negated if x is finite and y is Â±Infinity.</span>
    <span class="s2">else if </span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">d</span><span class="s3">) </span><span class="s1">y</span><span class="s3">.</span><span class="s1">s </span><span class="s3">= -</span><span class="s1">y</span><span class="s3">.</span><span class="s1">s</span><span class="s3">;</span>

    <span class="s0">// Return x if y is finite and x is Â±Infinity.</span>
    <span class="s0">// Return x if both are Â±Infinity with different signs.</span>
    <span class="s0">// Return NaN if both are Â±Infinity with the same sign.</span>
    <span class="s2">else </span><span class="s1">y </span><span class="s3">= </span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">y</span><span class="s3">.</span><span class="s1">d </span><span class="s3">|| </span><span class="s1">x</span><span class="s3">.</span><span class="s1">s </span><span class="s3">!== </span><span class="s1">y</span><span class="s3">.</span><span class="s1">s </span><span class="s3">? </span><span class="s1">x </span><span class="s3">: </span><span class="s1">NaN</span><span class="s3">);</span>

    <span class="s2">return </span><span class="s1">y</span><span class="s3">;</span>
  <span class="s3">}</span>

  <span class="s0">// If signs differ...</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">s </span><span class="s3">!= </span><span class="s1">y</span><span class="s3">.</span><span class="s1">s</span><span class="s3">) {</span>
    <span class="s1">y</span><span class="s3">.</span><span class="s1">s </span><span class="s3">= -</span><span class="s1">y</span><span class="s3">.</span><span class="s1">s</span><span class="s3">;</span>
    <span class="s2">return </span><span class="s1">x</span><span class="s3">.</span><span class="s1">plus</span><span class="s3">(</span><span class="s1">y</span><span class="s3">);</span>
  <span class="s3">}</span>

  <span class="s1">xd </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">d</span><span class="s3">;</span>
  <span class="s1">yd </span><span class="s3">= </span><span class="s1">y</span><span class="s3">.</span><span class="s1">d</span><span class="s3">;</span>
  <span class="s1">pr </span><span class="s3">= </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">precision</span><span class="s3">;</span>
  <span class="s1">rm </span><span class="s3">= </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">rounding</span><span class="s3">;</span>

  <span class="s0">// If either is zero...</span>
  <span class="s2">if </span><span class="s3">(!</span><span class="s1">xd</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] || !</span><span class="s1">yd</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]) {</span>

    <span class="s0">// Return y negated if x is zero and y is non-zero.</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">yd</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]) </span><span class="s1">y</span><span class="s3">.</span><span class="s1">s </span><span class="s3">= -</span><span class="s1">y</span><span class="s3">.</span><span class="s1">s</span><span class="s3">;</span>

    <span class="s0">// Return x if y is zero and x is non-zero.</span>
    <span class="s2">else if </span><span class="s3">(</span><span class="s1">xd</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]) </span><span class="s1">y </span><span class="s3">= </span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">x</span><span class="s3">);</span>

    <span class="s0">// Return zero if both are zero.</span>
    <span class="s0">// From IEEE 754 (2008) 6.3: 0 - 0 = -0 - -0 = -0 when rounding to -Infinity.</span>
    <span class="s2">else return new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">rm </span><span class="s3">=== </span><span class="s4">3 </span><span class="s3">? -</span><span class="s4">0 </span><span class="s3">: </span><span class="s4">0</span><span class="s3">);</span>

    <span class="s2">return </span><span class="s1">external </span><span class="s3">? </span><span class="s1">finalise</span><span class="s3">(</span><span class="s1">y</span><span class="s3">, </span><span class="s1">pr</span><span class="s3">, </span><span class="s1">rm</span><span class="s3">) : </span><span class="s1">y</span><span class="s3">;</span>
  <span class="s3">}</span>

  <span class="s0">// x and y are finite, non-zero numbers with the same sign.</span>

  <span class="s0">// Calculate base 1e7 exponents.</span>
  <span class="s1">e </span><span class="s3">= </span><span class="s1">mathfloor</span><span class="s3">(</span><span class="s1">y</span><span class="s3">.</span><span class="s1">e </span><span class="s3">/ </span><span class="s1">LOG_BASE</span><span class="s3">);</span>
  <span class="s1">xe </span><span class="s3">= </span><span class="s1">mathfloor</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">e </span><span class="s3">/ </span><span class="s1">LOG_BASE</span><span class="s3">);</span>

  <span class="s1">xd </span><span class="s3">= </span><span class="s1">xd</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">();</span>
  <span class="s1">k </span><span class="s3">= </span><span class="s1">xe </span><span class="s3">- </span><span class="s1">e</span><span class="s3">;</span>

  <span class="s0">// If base 1e7 exponents differ...</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">k</span><span class="s3">) {</span>
    <span class="s1">xLTy </span><span class="s3">= </span><span class="s1">k </span><span class="s3">&lt; </span><span class="s4">0</span><span class="s3">;</span>

    <span class="s2">if </span><span class="s3">(</span><span class="s1">xLTy</span><span class="s3">) {</span>
      <span class="s1">d </span><span class="s3">= </span><span class="s1">xd</span><span class="s3">;</span>
      <span class="s1">k </span><span class="s3">= -</span><span class="s1">k</span><span class="s3">;</span>
      <span class="s1">len </span><span class="s3">= </span><span class="s1">yd</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span>
    <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
      <span class="s1">d </span><span class="s3">= </span><span class="s1">yd</span><span class="s3">;</span>
      <span class="s1">e </span><span class="s3">= </span><span class="s1">xe</span><span class="s3">;</span>
      <span class="s1">len </span><span class="s3">= </span><span class="s1">xd</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span>
    <span class="s3">}</span>

    <span class="s0">// Numbers with massively different exponents would result in a very high number of</span>
    <span class="s0">// zeros needing to be prepended, but this can be avoided while still ensuring correct</span>
    <span class="s0">// rounding by limiting the number of zeros to `Math.ceil(pr / LOG_BASE) + 2`.</span>
    <span class="s1">i </span><span class="s3">= </span><span class="s1">Math</span><span class="s3">.</span><span class="s1">max</span><span class="s3">(</span><span class="s1">Math</span><span class="s3">.</span><span class="s1">ceil</span><span class="s3">(</span><span class="s1">pr </span><span class="s3">/ </span><span class="s1">LOG_BASE</span><span class="s3">), </span><span class="s1">len</span><span class="s3">) + </span><span class="s4">2</span><span class="s3">;</span>

    <span class="s2">if </span><span class="s3">(</span><span class="s1">k </span><span class="s3">&gt; </span><span class="s1">i</span><span class="s3">) {</span>
      <span class="s1">k </span><span class="s3">= </span><span class="s1">i</span><span class="s3">;</span>
      <span class="s1">d</span><span class="s3">.</span><span class="s1">length </span><span class="s3">= </span><span class="s4">1</span><span class="s3">;</span>
    <span class="s3">}</span>

    <span class="s0">// Prepend zeros to equalise exponents.</span>
    <span class="s1">d</span><span class="s3">.</span><span class="s1">reverse</span><span class="s3">();</span>
    <span class="s2">for </span><span class="s3">(</span><span class="s1">i </span><span class="s3">= </span><span class="s1">k</span><span class="s3">; </span><span class="s1">i</span><span class="s3">--;) </span><span class="s1">d</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s4">0</span><span class="s3">);</span>
    <span class="s1">d</span><span class="s3">.</span><span class="s1">reverse</span><span class="s3">();</span>

  <span class="s0">// Base 1e7 exponents equal.</span>
  <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>

    <span class="s0">// Check digits to determine which is the bigger number.</span>

    <span class="s1">i </span><span class="s3">= </span><span class="s1">xd</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span>
    <span class="s1">len </span><span class="s3">= </span><span class="s1">yd</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span>
    <span class="s1">xLTy </span><span class="s3">= </span><span class="s1">i </span><span class="s3">&lt; </span><span class="s1">len</span><span class="s3">;</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">xLTy</span><span class="s3">) </span><span class="s1">len </span><span class="s3">= </span><span class="s1">i</span><span class="s3">;</span>

    <span class="s2">for </span><span class="s3">(</span><span class="s1">i </span><span class="s3">= </span><span class="s4">0</span><span class="s3">; </span><span class="s1">i </span><span class="s3">&lt; </span><span class="s1">len</span><span class="s3">; </span><span class="s1">i</span><span class="s3">++) {</span>
      <span class="s2">if </span><span class="s3">(</span><span class="s1">xd</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] != </span><span class="s1">yd</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]) {</span>
        <span class="s1">xLTy </span><span class="s3">= </span><span class="s1">xd</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] &lt; </span><span class="s1">yd</span><span class="s3">[</span><span class="s1">i</span><span class="s3">];</span>
        <span class="s2">break</span><span class="s3">;</span>
      <span class="s3">}</span>
    <span class="s3">}</span>

    <span class="s1">k </span><span class="s3">= </span><span class="s4">0</span><span class="s3">;</span>
  <span class="s3">}</span>

  <span class="s2">if </span><span class="s3">(</span><span class="s1">xLTy</span><span class="s3">) {</span>
    <span class="s1">d </span><span class="s3">= </span><span class="s1">xd</span><span class="s3">;</span>
    <span class="s1">xd </span><span class="s3">= </span><span class="s1">yd</span><span class="s3">;</span>
    <span class="s1">yd </span><span class="s3">= </span><span class="s1">d</span><span class="s3">;</span>
    <span class="s1">y</span><span class="s3">.</span><span class="s1">s </span><span class="s3">= -</span><span class="s1">y</span><span class="s3">.</span><span class="s1">s</span><span class="s3">;</span>
  <span class="s3">}</span>

  <span class="s1">len </span><span class="s3">= </span><span class="s1">xd</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span>

  <span class="s0">// Append zeros to `xd` if shorter.</span>
  <span class="s0">// Don't add zeros to `yd` if shorter as subtraction only needs to start at `yd` length.</span>
  <span class="s2">for </span><span class="s3">(</span><span class="s1">i </span><span class="s3">= </span><span class="s1">yd</span><span class="s3">.</span><span class="s1">length </span><span class="s3">- </span><span class="s1">len</span><span class="s3">; </span><span class="s1">i </span><span class="s3">&gt; </span><span class="s4">0</span><span class="s3">; --</span><span class="s1">i</span><span class="s3">) </span><span class="s1">xd</span><span class="s3">[</span><span class="s1">len</span><span class="s3">++] = </span><span class="s4">0</span><span class="s3">;</span>

  <span class="s0">// Subtract yd from xd.</span>
  <span class="s2">for </span><span class="s3">(</span><span class="s1">i </span><span class="s3">= </span><span class="s1">yd</span><span class="s3">.</span><span class="s1">length</span><span class="s3">; </span><span class="s1">i </span><span class="s3">&gt; </span><span class="s1">k</span><span class="s3">;) {</span>

    <span class="s2">if </span><span class="s3">(</span><span class="s1">xd</span><span class="s3">[--</span><span class="s1">i</span><span class="s3">] &lt; </span><span class="s1">yd</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]) {</span>
      <span class="s2">for </span><span class="s3">(</span><span class="s1">j </span><span class="s3">= </span><span class="s1">i</span><span class="s3">; </span><span class="s1">j </span><span class="s3">&amp;&amp; </span><span class="s1">xd</span><span class="s3">[--</span><span class="s1">j</span><span class="s3">] === </span><span class="s4">0</span><span class="s3">;) </span><span class="s1">xd</span><span class="s3">[</span><span class="s1">j</span><span class="s3">] = </span><span class="s1">BASE </span><span class="s3">- </span><span class="s4">1</span><span class="s3">;</span>
      <span class="s3">--</span><span class="s1">xd</span><span class="s3">[</span><span class="s1">j</span><span class="s3">];</span>
      <span class="s1">xd</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] += </span><span class="s1">BASE</span><span class="s3">;</span>
    <span class="s3">}</span>

    <span class="s1">xd</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] -= </span><span class="s1">yd</span><span class="s3">[</span><span class="s1">i</span><span class="s3">];</span>
  <span class="s3">}</span>

  <span class="s0">// Remove trailing zeros.</span>
  <span class="s2">for </span><span class="s3">(; </span><span class="s1">xd</span><span class="s3">[--</span><span class="s1">len</span><span class="s3">] === </span><span class="s4">0</span><span class="s3">;) </span><span class="s1">xd</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">();</span>

  <span class="s0">// Remove leading zeros and adjust exponent accordingly.</span>
  <span class="s2">for </span><span class="s3">(; </span><span class="s1">xd</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] === </span><span class="s4">0</span><span class="s3">; </span><span class="s1">xd</span><span class="s3">.</span><span class="s1">shift</span><span class="s3">()) --</span><span class="s1">e</span><span class="s3">;</span>

  <span class="s0">// Zero?</span>
  <span class="s2">if </span><span class="s3">(!</span><span class="s1">xd</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]) </span><span class="s2">return new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">rm </span><span class="s3">=== </span><span class="s4">3 </span><span class="s3">? -</span><span class="s4">0 </span><span class="s3">: </span><span class="s4">0</span><span class="s3">);</span>

  <span class="s1">y</span><span class="s3">.</span><span class="s1">d </span><span class="s3">= </span><span class="s1">xd</span><span class="s3">;</span>
  <span class="s1">y</span><span class="s3">.</span><span class="s1">e </span><span class="s3">= </span><span class="s1">getBase10Exponent</span><span class="s3">(</span><span class="s1">xd</span><span class="s3">, </span><span class="s1">e</span><span class="s3">);</span>

  <span class="s2">return </span><span class="s1">external </span><span class="s3">? </span><span class="s1">finalise</span><span class="s3">(</span><span class="s1">y</span><span class="s3">, </span><span class="s1">pr</span><span class="s3">, </span><span class="s1">rm</span><span class="s3">) : </span><span class="s1">y</span><span class="s3">;</span>
<span class="s3">};</span>


<span class="s0">/* 
 *   n % 0 =  N 
 *   n % N =  N 
 *   n % I =  n 
 *   0 % n =  0 
 *  -0 % n = -0 
 *   0 % 0 =  N 
 *   0 % N =  N 
 *   0 % I =  0 
 *   N % n =  N 
 *   N % 0 =  N 
 *   N % N =  N 
 *   N % I =  N 
 *   I % n =  N 
 *   I % 0 =  N 
 *   I % N =  N 
 *   I % I =  N 
 * 
 * Return a new Decimal whose value is the value of this Decimal modulo `y`, rounded to 
 * `precision` significant digits using rounding mode `rounding`. 
 * 
 * The result depends on the modulo mode. 
 * 
 */</span>
<span class="s1">P</span><span class="s3">.</span><span class="s1">modulo </span><span class="s3">= </span><span class="s1">P</span><span class="s3">.</span><span class="s1">mod </span><span class="s3">= </span><span class="s2">function </span><span class="s3">(</span><span class="s1">y</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">q</span><span class="s3">,</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s2">this</span><span class="s3">,</span>
    <span class="s1">Ctor </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">constructor</span><span class="s3">;</span>

  <span class="s1">y </span><span class="s3">= </span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">y</span><span class="s3">);</span>

  <span class="s0">// Return NaN if x is Â±Infinity or NaN, or y is NaN or Â±0.</span>
  <span class="s2">if </span><span class="s3">(!</span><span class="s1">x</span><span class="s3">.</span><span class="s1">d </span><span class="s3">|| !</span><span class="s1">y</span><span class="s3">.</span><span class="s1">s </span><span class="s3">|| </span><span class="s1">y</span><span class="s3">.</span><span class="s1">d </span><span class="s3">&amp;&amp; !</span><span class="s1">y</span><span class="s3">.</span><span class="s1">d</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]) </span><span class="s2">return new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">NaN</span><span class="s3">);</span>

  <span class="s0">// Return x if y is Â±Infinity or x is Â±0.</span>
  <span class="s2">if </span><span class="s3">(!</span><span class="s1">y</span><span class="s3">.</span><span class="s1">d </span><span class="s3">|| </span><span class="s1">x</span><span class="s3">.</span><span class="s1">d </span><span class="s3">&amp;&amp; !</span><span class="s1">x</span><span class="s3">.</span><span class="s1">d</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]) {</span>
    <span class="s2">return </span><span class="s1">finalise</span><span class="s3">(</span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">x</span><span class="s3">), </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">precision</span><span class="s3">, </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">rounding</span><span class="s3">);</span>
  <span class="s3">}</span>

  <span class="s0">// Prevent rounding of intermediate calculations.</span>
  <span class="s1">external </span><span class="s3">= </span><span class="s2">false</span><span class="s3">;</span>

  <span class="s2">if </span><span class="s3">(</span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">modulo </span><span class="s3">== </span><span class="s4">9</span><span class="s3">) {</span>

    <span class="s0">// Euclidian division: q = sign(y) * floor(x / abs(y))</span>
    <span class="s0">// result = x - q * y    where  0 &lt;= result &lt; abs(y)</span>
    <span class="s1">q </span><span class="s3">= </span><span class="s1">divide</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">.</span><span class="s1">abs</span><span class="s3">(), </span><span class="s4">0</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">1</span><span class="s3">);</span>
    <span class="s1">q</span><span class="s3">.</span><span class="s1">s </span><span class="s3">*= </span><span class="s1">y</span><span class="s3">.</span><span class="s1">s</span><span class="s3">;</span>
  <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
    <span class="s1">q </span><span class="s3">= </span><span class="s1">divide</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">modulo</span><span class="s3">, </span><span class="s4">1</span><span class="s3">);</span>
  <span class="s3">}</span>

  <span class="s1">q </span><span class="s3">= </span><span class="s1">q</span><span class="s3">.</span><span class="s1">times</span><span class="s3">(</span><span class="s1">y</span><span class="s3">);</span>

  <span class="s1">external </span><span class="s3">= </span><span class="s2">true</span><span class="s3">;</span>

  <span class="s2">return </span><span class="s1">x</span><span class="s3">.</span><span class="s1">minus</span><span class="s3">(</span><span class="s1">q</span><span class="s3">);</span>
<span class="s3">};</span>


<span class="s0">/* 
 * Return a new Decimal whose value is the natural exponential of the value of this Decimal, 
 * i.e. the base e raised to the power the value of this Decimal, rounded to `precision` 
 * significant digits using rounding mode `rounding`. 
 * 
 */</span>
<span class="s1">P</span><span class="s3">.</span><span class="s1">naturalExponential </span><span class="s3">= </span><span class="s1">P</span><span class="s3">.</span><span class="s1">exp </span><span class="s3">= </span><span class="s2">function </span><span class="s3">() {</span>
  <span class="s2">return </span><span class="s1">naturalExponential</span><span class="s3">(</span><span class="s2">this</span><span class="s3">);</span>
<span class="s3">};</span>


<span class="s0">/* 
 * Return a new Decimal whose value is the natural logarithm of the value of this Decimal, 
 * rounded to `precision` significant digits using rounding mode `rounding`. 
 * 
 */</span>
<span class="s1">P</span><span class="s3">.</span><span class="s1">naturalLogarithm </span><span class="s3">= </span><span class="s1">P</span><span class="s3">.</span><span class="s1">ln </span><span class="s3">= </span><span class="s2">function </span><span class="s3">() {</span>
  <span class="s2">return </span><span class="s1">naturalLogarithm</span><span class="s3">(</span><span class="s2">this</span><span class="s3">);</span>
<span class="s3">};</span>


<span class="s0">/* 
 * Return a new Decimal whose value is the value of this Decimal negated, i.e. as if multiplied by 
 * -1. 
 * 
 */</span>
<span class="s1">P</span><span class="s3">.</span><span class="s1">negated </span><span class="s3">= </span><span class="s1">P</span><span class="s3">.</span><span class="s1">neg </span><span class="s3">= </span><span class="s2">function </span><span class="s3">() {</span>
  <span class="s2">var </span><span class="s1">x </span><span class="s3">= </span><span class="s2">new this</span><span class="s3">.</span><span class="s1">constructor</span><span class="s3">(</span><span class="s2">this</span><span class="s3">);</span>
  <span class="s1">x</span><span class="s3">.</span><span class="s1">s </span><span class="s3">= -</span><span class="s1">x</span><span class="s3">.</span><span class="s1">s</span><span class="s3">;</span>
  <span class="s2">return </span><span class="s1">finalise</span><span class="s3">(</span><span class="s1">x</span><span class="s3">);</span>
<span class="s3">};</span>


<span class="s0">/* 
 *  n + 0 = n 
 *  n + N = N 
 *  n + I = I 
 *  0 + n = n 
 *  0 + 0 = 0 
 *  0 + N = N 
 *  0 + I = I 
 *  N + n = N 
 *  N + 0 = N 
 *  N + N = N 
 *  N + I = N 
 *  I + n = I 
 *  I + 0 = I 
 *  I + N = N 
 *  I + I = I 
 * 
 * Return a new Decimal whose value is the value of this Decimal plus `y`, rounded to `precision` 
 * significant digits using rounding mode `rounding`. 
 * 
 */</span>
<span class="s1">P</span><span class="s3">.</span><span class="s1">plus </span><span class="s3">= </span><span class="s1">P</span><span class="s3">.</span><span class="s1">add </span><span class="s3">= </span><span class="s2">function </span><span class="s3">(</span><span class="s1">y</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">carry</span><span class="s3">, </span><span class="s1">d</span><span class="s3">, </span><span class="s1">e</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">len</span><span class="s3">, </span><span class="s1">pr</span><span class="s3">, </span><span class="s1">rm</span><span class="s3">, </span><span class="s1">xd</span><span class="s3">, </span><span class="s1">yd</span><span class="s3">,</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s2">this</span><span class="s3">,</span>
    <span class="s1">Ctor </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">constructor</span><span class="s3">;</span>

  <span class="s1">y </span><span class="s3">= </span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">y</span><span class="s3">);</span>

  <span class="s0">// If either is not finite...</span>
  <span class="s2">if </span><span class="s3">(!</span><span class="s1">x</span><span class="s3">.</span><span class="s1">d </span><span class="s3">|| !</span><span class="s1">y</span><span class="s3">.</span><span class="s1">d</span><span class="s3">) {</span>

    <span class="s0">// Return NaN if either is NaN.</span>
    <span class="s2">if </span><span class="s3">(!</span><span class="s1">x</span><span class="s3">.</span><span class="s1">s </span><span class="s3">|| !</span><span class="s1">y</span><span class="s3">.</span><span class="s1">s</span><span class="s3">) </span><span class="s1">y </span><span class="s3">= </span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">NaN</span><span class="s3">);</span>

    <span class="s0">// Return x if y is finite and x is Â±Infinity.</span>
    <span class="s0">// Return x if both are Â±Infinity with the same sign.</span>
    <span class="s0">// Return NaN if both are Â±Infinity with different signs.</span>
    <span class="s0">// Return y if x is finite and y is Â±Infinity.</span>
    <span class="s2">else if </span><span class="s3">(!</span><span class="s1">x</span><span class="s3">.</span><span class="s1">d</span><span class="s3">) </span><span class="s1">y </span><span class="s3">= </span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">y</span><span class="s3">.</span><span class="s1">d </span><span class="s3">|| </span><span class="s1">x</span><span class="s3">.</span><span class="s1">s </span><span class="s3">=== </span><span class="s1">y</span><span class="s3">.</span><span class="s1">s </span><span class="s3">? </span><span class="s1">x </span><span class="s3">: </span><span class="s1">NaN</span><span class="s3">);</span>

    <span class="s2">return </span><span class="s1">y</span><span class="s3">;</span>
  <span class="s3">}</span>

   <span class="s0">// If signs differ...</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">s </span><span class="s3">!= </span><span class="s1">y</span><span class="s3">.</span><span class="s1">s</span><span class="s3">) {</span>
    <span class="s1">y</span><span class="s3">.</span><span class="s1">s </span><span class="s3">= -</span><span class="s1">y</span><span class="s3">.</span><span class="s1">s</span><span class="s3">;</span>
    <span class="s2">return </span><span class="s1">x</span><span class="s3">.</span><span class="s1">minus</span><span class="s3">(</span><span class="s1">y</span><span class="s3">);</span>
  <span class="s3">}</span>

  <span class="s1">xd </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">d</span><span class="s3">;</span>
  <span class="s1">yd </span><span class="s3">= </span><span class="s1">y</span><span class="s3">.</span><span class="s1">d</span><span class="s3">;</span>
  <span class="s1">pr </span><span class="s3">= </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">precision</span><span class="s3">;</span>
  <span class="s1">rm </span><span class="s3">= </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">rounding</span><span class="s3">;</span>

  <span class="s0">// If either is zero...</span>
  <span class="s2">if </span><span class="s3">(!</span><span class="s1">xd</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] || !</span><span class="s1">yd</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]) {</span>

    <span class="s0">// Return x if y is zero.</span>
    <span class="s0">// Return y if y is non-zero.</span>
    <span class="s2">if </span><span class="s3">(!</span><span class="s1">yd</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]) </span><span class="s1">y </span><span class="s3">= </span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">x</span><span class="s3">);</span>

    <span class="s2">return </span><span class="s1">external </span><span class="s3">? </span><span class="s1">finalise</span><span class="s3">(</span><span class="s1">y</span><span class="s3">, </span><span class="s1">pr</span><span class="s3">, </span><span class="s1">rm</span><span class="s3">) : </span><span class="s1">y</span><span class="s3">;</span>
  <span class="s3">}</span>

  <span class="s0">// x and y are finite, non-zero numbers with the same sign.</span>

  <span class="s0">// Calculate base 1e7 exponents.</span>
  <span class="s1">k </span><span class="s3">= </span><span class="s1">mathfloor</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">e </span><span class="s3">/ </span><span class="s1">LOG_BASE</span><span class="s3">);</span>
  <span class="s1">e </span><span class="s3">= </span><span class="s1">mathfloor</span><span class="s3">(</span><span class="s1">y</span><span class="s3">.</span><span class="s1">e </span><span class="s3">/ </span><span class="s1">LOG_BASE</span><span class="s3">);</span>

  <span class="s1">xd </span><span class="s3">= </span><span class="s1">xd</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">();</span>
  <span class="s1">i </span><span class="s3">= </span><span class="s1">k </span><span class="s3">- </span><span class="s1">e</span><span class="s3">;</span>

  <span class="s0">// If base 1e7 exponents differ...</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">i</span><span class="s3">) {</span>

    <span class="s2">if </span><span class="s3">(</span><span class="s1">i </span><span class="s3">&lt; </span><span class="s4">0</span><span class="s3">) {</span>
      <span class="s1">d </span><span class="s3">= </span><span class="s1">xd</span><span class="s3">;</span>
      <span class="s1">i </span><span class="s3">= -</span><span class="s1">i</span><span class="s3">;</span>
      <span class="s1">len </span><span class="s3">= </span><span class="s1">yd</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span>
    <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
      <span class="s1">d </span><span class="s3">= </span><span class="s1">yd</span><span class="s3">;</span>
      <span class="s1">e </span><span class="s3">= </span><span class="s1">k</span><span class="s3">;</span>
      <span class="s1">len </span><span class="s3">= </span><span class="s1">xd</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span>
    <span class="s3">}</span>

    <span class="s0">// Limit number of zeros prepended to max(ceil(pr / LOG_BASE), len) + 1.</span>
    <span class="s1">k </span><span class="s3">= </span><span class="s1">Math</span><span class="s3">.</span><span class="s1">ceil</span><span class="s3">(</span><span class="s1">pr </span><span class="s3">/ </span><span class="s1">LOG_BASE</span><span class="s3">);</span>
    <span class="s1">len </span><span class="s3">= </span><span class="s1">k </span><span class="s3">&gt; </span><span class="s1">len </span><span class="s3">? </span><span class="s1">k </span><span class="s3">+ </span><span class="s4">1 </span><span class="s3">: </span><span class="s1">len </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">;</span>

    <span class="s2">if </span><span class="s3">(</span><span class="s1">i </span><span class="s3">&gt; </span><span class="s1">len</span><span class="s3">) {</span>
      <span class="s1">i </span><span class="s3">= </span><span class="s1">len</span><span class="s3">;</span>
      <span class="s1">d</span><span class="s3">.</span><span class="s1">length </span><span class="s3">= </span><span class="s4">1</span><span class="s3">;</span>
    <span class="s3">}</span>

    <span class="s0">// Prepend zeros to equalise exponents. Note: Faster to use reverse then do unshifts.</span>
    <span class="s1">d</span><span class="s3">.</span><span class="s1">reverse</span><span class="s3">();</span>
    <span class="s2">for </span><span class="s3">(; </span><span class="s1">i</span><span class="s3">--;) </span><span class="s1">d</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s4">0</span><span class="s3">);</span>
    <span class="s1">d</span><span class="s3">.</span><span class="s1">reverse</span><span class="s3">();</span>
  <span class="s3">}</span>

  <span class="s1">len </span><span class="s3">= </span><span class="s1">xd</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span>
  <span class="s1">i </span><span class="s3">= </span><span class="s1">yd</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span>

  <span class="s0">// If yd is longer than xd, swap xd and yd so xd points to the longer array.</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">len </span><span class="s3">- </span><span class="s1">i </span><span class="s3">&lt; </span><span class="s4">0</span><span class="s3">) {</span>
    <span class="s1">i </span><span class="s3">= </span><span class="s1">len</span><span class="s3">;</span>
    <span class="s1">d </span><span class="s3">= </span><span class="s1">yd</span><span class="s3">;</span>
    <span class="s1">yd </span><span class="s3">= </span><span class="s1">xd</span><span class="s3">;</span>
    <span class="s1">xd </span><span class="s3">= </span><span class="s1">d</span><span class="s3">;</span>
  <span class="s3">}</span>

  <span class="s0">// Only start adding at yd.length - 1 as the further digits of xd can be left as they are.</span>
  <span class="s2">for </span><span class="s3">(</span><span class="s1">carry </span><span class="s3">= </span><span class="s4">0</span><span class="s3">; </span><span class="s1">i</span><span class="s3">;) {</span>
    <span class="s1">carry </span><span class="s3">= (</span><span class="s1">xd</span><span class="s3">[--</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">xd</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] + </span><span class="s1">yd</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] + </span><span class="s1">carry</span><span class="s3">) / </span><span class="s1">BASE </span><span class="s3">| </span><span class="s4">0</span><span class="s3">;</span>
    <span class="s1">xd</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] %= </span><span class="s1">BASE</span><span class="s3">;</span>
  <span class="s3">}</span>

  <span class="s2">if </span><span class="s3">(</span><span class="s1">carry</span><span class="s3">) {</span>
    <span class="s1">xd</span><span class="s3">.</span><span class="s1">unshift</span><span class="s3">(</span><span class="s1">carry</span><span class="s3">);</span>
    <span class="s3">++</span><span class="s1">e</span><span class="s3">;</span>
  <span class="s3">}</span>

  <span class="s0">// Remove trailing zeros.</span>
  <span class="s0">// No need to check for zero, as +x + +y != 0 &amp;&amp; -x + -y != 0</span>
  <span class="s2">for </span><span class="s3">(</span><span class="s1">len </span><span class="s3">= </span><span class="s1">xd</span><span class="s3">.</span><span class="s1">length</span><span class="s3">; </span><span class="s1">xd</span><span class="s3">[--</span><span class="s1">len</span><span class="s3">] == </span><span class="s4">0</span><span class="s3">;) </span><span class="s1">xd</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">();</span>

  <span class="s1">y</span><span class="s3">.</span><span class="s1">d </span><span class="s3">= </span><span class="s1">xd</span><span class="s3">;</span>
  <span class="s1">y</span><span class="s3">.</span><span class="s1">e </span><span class="s3">= </span><span class="s1">getBase10Exponent</span><span class="s3">(</span><span class="s1">xd</span><span class="s3">, </span><span class="s1">e</span><span class="s3">);</span>

  <span class="s2">return </span><span class="s1">external </span><span class="s3">? </span><span class="s1">finalise</span><span class="s3">(</span><span class="s1">y</span><span class="s3">, </span><span class="s1">pr</span><span class="s3">, </span><span class="s1">rm</span><span class="s3">) : </span><span class="s1">y</span><span class="s3">;</span>
<span class="s3">};</span>


<span class="s0">/* 
 * Return the number of significant digits of the value of this Decimal. 
 * 
 * [z] {boolean|number} Whether to count integer-part trailing zeros: true, false, 1 or 0. 
 * 
 */</span>
<span class="s1">P</span><span class="s3">.</span><span class="s1">precision </span><span class="s3">= </span><span class="s1">P</span><span class="s3">.</span><span class="s1">sd </span><span class="s3">= </span><span class="s2">function </span><span class="s3">(</span><span class="s1">z</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">k</span><span class="s3">,</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s2">this</span><span class="s3">;</span>

  <span class="s2">if </span><span class="s3">(</span><span class="s1">z </span><span class="s3">!== </span><span class="s2">void </span><span class="s4">0 </span><span class="s3">&amp;&amp; </span><span class="s1">z </span><span class="s3">!== !!</span><span class="s1">z </span><span class="s3">&amp;&amp; </span><span class="s1">z </span><span class="s3">!== </span><span class="s4">1 </span><span class="s3">&amp;&amp; </span><span class="s1">z </span><span class="s3">!== </span><span class="s4">0</span><span class="s3">) </span><span class="s2">throw </span><span class="s1">Error</span><span class="s3">(</span><span class="s1">invalidArgument </span><span class="s3">+ </span><span class="s1">z</span><span class="s3">);</span>

  <span class="s2">if </span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">d</span><span class="s3">) {</span>
    <span class="s1">k </span><span class="s3">= </span><span class="s1">getPrecision</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">d</span><span class="s3">);</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">z </span><span class="s3">&amp;&amp; </span><span class="s1">x</span><span class="s3">.</span><span class="s1">e </span><span class="s3">+ </span><span class="s4">1 </span><span class="s3">&gt; </span><span class="s1">k</span><span class="s3">) </span><span class="s1">k </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">e </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">;</span>
  <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
    <span class="s1">k </span><span class="s3">= </span><span class="s1">NaN</span><span class="s3">;</span>
  <span class="s3">}</span>

  <span class="s2">return </span><span class="s1">k</span><span class="s3">;</span>
<span class="s3">};</span>


<span class="s0">/* 
 * Return a new Decimal whose value is the value of this Decimal rounded to a whole number using 
 * rounding mode `rounding`. 
 * 
 */</span>
<span class="s1">P</span><span class="s3">.</span><span class="s1">round </span><span class="s3">= </span><span class="s2">function </span><span class="s3">() {</span>
  <span class="s2">var </span><span class="s1">x </span><span class="s3">= </span><span class="s2">this</span><span class="s3">,</span>
    <span class="s1">Ctor </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">constructor</span><span class="s3">;</span>

  <span class="s2">return </span><span class="s1">finalise</span><span class="s3">(</span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">x</span><span class="s3">), </span><span class="s1">x</span><span class="s3">.</span><span class="s1">e </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">, </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">rounding</span><span class="s3">);</span>
<span class="s3">};</span>


<span class="s0">/* 
 * Return a new Decimal whose value is the sine of the value in radians of this Decimal. 
 * 
 * Domain: [-Infinity, Infinity] 
 * Range: [-1, 1] 
 * 
 * sin(x) = x - x^3/3! + x^5/5! - ... 
 * 
 * sin(0)         = 0 
 * sin(-0)        = -0 
 * sin(Infinity)  = NaN 
 * sin(-Infinity) = NaN 
 * sin(NaN)       = NaN 
 * 
 */</span>
<span class="s1">P</span><span class="s3">.</span><span class="s1">sine </span><span class="s3">= </span><span class="s1">P</span><span class="s3">.</span><span class="s1">sin </span><span class="s3">= </span><span class="s2">function </span><span class="s3">() {</span>
  <span class="s2">var </span><span class="s1">pr</span><span class="s3">, </span><span class="s1">rm</span><span class="s3">,</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s2">this</span><span class="s3">,</span>
    <span class="s1">Ctor </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">constructor</span><span class="s3">;</span>

  <span class="s2">if </span><span class="s3">(!</span><span class="s1">x</span><span class="s3">.</span><span class="s1">isFinite</span><span class="s3">()) </span><span class="s2">return new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">NaN</span><span class="s3">);</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">isZero</span><span class="s3">()) </span><span class="s2">return new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">x</span><span class="s3">);</span>

  <span class="s1">pr </span><span class="s3">= </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">precision</span><span class="s3">;</span>
  <span class="s1">rm </span><span class="s3">= </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">rounding</span><span class="s3">;</span>
  <span class="s1">Ctor</span><span class="s3">.</span><span class="s1">precision </span><span class="s3">= </span><span class="s1">pr </span><span class="s3">+ </span><span class="s1">Math</span><span class="s3">.</span><span class="s1">max</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">e</span><span class="s3">, </span><span class="s1">x</span><span class="s3">.</span><span class="s1">sd</span><span class="s3">()) + </span><span class="s1">LOG_BASE</span><span class="s3">;</span>
  <span class="s1">Ctor</span><span class="s3">.</span><span class="s1">rounding </span><span class="s3">= </span><span class="s4">1</span><span class="s3">;</span>

  <span class="s1">x </span><span class="s3">= </span><span class="s1">sine</span><span class="s3">(</span><span class="s1">Ctor</span><span class="s3">, </span><span class="s1">toLessThanHalfPi</span><span class="s3">(</span><span class="s1">Ctor</span><span class="s3">, </span><span class="s1">x</span><span class="s3">));</span>

  <span class="s1">Ctor</span><span class="s3">.</span><span class="s1">precision </span><span class="s3">= </span><span class="s1">pr</span><span class="s3">;</span>
  <span class="s1">Ctor</span><span class="s3">.</span><span class="s1">rounding </span><span class="s3">= </span><span class="s1">rm</span><span class="s3">;</span>

  <span class="s2">return </span><span class="s1">finalise</span><span class="s3">(</span><span class="s1">quadrant </span><span class="s3">&gt; </span><span class="s4">2 </span><span class="s3">? </span><span class="s1">x</span><span class="s3">.</span><span class="s1">neg</span><span class="s3">() : </span><span class="s1">x</span><span class="s3">, </span><span class="s1">pr</span><span class="s3">, </span><span class="s1">rm</span><span class="s3">, </span><span class="s2">true</span><span class="s3">);</span>
<span class="s3">};</span>


<span class="s0">/* 
 * Return a new Decimal whose value is the square root of this Decimal, rounded to `precision` 
 * significant digits using rounding mode `rounding`. 
 * 
 *  sqrt(-n) =  N 
 *  sqrt(N)  =  N 
 *  sqrt(-I) =  N 
 *  sqrt(I)  =  I 
 *  sqrt(0)  =  0 
 *  sqrt(-0) = -0 
 * 
 */</span>
<span class="s1">P</span><span class="s3">.</span><span class="s1">squareRoot </span><span class="s3">= </span><span class="s1">P</span><span class="s3">.</span><span class="s1">sqrt </span><span class="s3">= </span><span class="s2">function </span><span class="s3">() {</span>
  <span class="s2">var </span><span class="s1">m</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">sd</span><span class="s3">, </span><span class="s1">r</span><span class="s3">, </span><span class="s1">rep</span><span class="s3">, </span><span class="s1">t</span><span class="s3">,</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s2">this</span><span class="s3">,</span>
    <span class="s1">d </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">d</span><span class="s3">,</span>
    <span class="s1">e </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">e</span><span class="s3">,</span>
    <span class="s1">s </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">s</span><span class="s3">,</span>
    <span class="s1">Ctor </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">constructor</span><span class="s3">;</span>

  <span class="s0">// Negative/NaN/Infinity/zero?</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">s </span><span class="s3">!== </span><span class="s4">1 </span><span class="s3">|| !</span><span class="s1">d </span><span class="s3">|| !</span><span class="s1">d</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]) {</span>
    <span class="s2">return new </span><span class="s1">Ctor</span><span class="s3">(!</span><span class="s1">s </span><span class="s3">|| </span><span class="s1">s </span><span class="s3">&lt; </span><span class="s4">0 </span><span class="s3">&amp;&amp; (!</span><span class="s1">d </span><span class="s3">|| </span><span class="s1">d</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]) ? </span><span class="s1">NaN </span><span class="s3">: </span><span class="s1">d </span><span class="s3">? </span><span class="s1">x </span><span class="s3">: </span><span class="s4">1 </span><span class="s3">/ </span><span class="s4">0</span><span class="s3">);</span>
  <span class="s3">}</span>

  <span class="s1">external </span><span class="s3">= </span><span class="s2">false</span><span class="s3">;</span>

  <span class="s0">// Initial estimate.</span>
  <span class="s1">s </span><span class="s3">= </span><span class="s1">Math</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(+</span><span class="s1">x</span><span class="s3">);</span>

  <span class="s0">// Math.sqrt underflow/overflow?</span>
  <span class="s0">// Pass x to Math.sqrt as integer, then adjust the exponent of the result.</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">s </span><span class="s3">== </span><span class="s4">0 </span><span class="s3">|| </span><span class="s1">s </span><span class="s3">== </span><span class="s4">1 </span><span class="s3">/ </span><span class="s4">0</span><span class="s3">) {</span>
    <span class="s1">n </span><span class="s3">= </span><span class="s1">digitsToString</span><span class="s3">(</span><span class="s1">d</span><span class="s3">);</span>

    <span class="s2">if </span><span class="s3">((</span><span class="s1">n</span><span class="s3">.</span><span class="s1">length </span><span class="s3">+ </span><span class="s1">e</span><span class="s3">) % </span><span class="s4">2 </span><span class="s3">== </span><span class="s4">0</span><span class="s3">) </span><span class="s1">n </span><span class="s3">+= </span><span class="s5">'0'</span><span class="s3">;</span>
    <span class="s1">s </span><span class="s3">= </span><span class="s1">Math</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">n</span><span class="s3">);</span>
    <span class="s1">e </span><span class="s3">= </span><span class="s1">mathfloor</span><span class="s3">((</span><span class="s1">e </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">) / </span><span class="s4">2</span><span class="s3">) - (</span><span class="s1">e </span><span class="s3">&lt; </span><span class="s4">0 </span><span class="s3">|| </span><span class="s1">e </span><span class="s3">% </span><span class="s4">2</span><span class="s3">);</span>

    <span class="s2">if </span><span class="s3">(</span><span class="s1">s </span><span class="s3">== </span><span class="s4">1 </span><span class="s3">/ </span><span class="s4">0</span><span class="s3">) {</span>
      <span class="s1">n </span><span class="s3">= </span><span class="s5">'5e' </span><span class="s3">+ </span><span class="s1">e</span><span class="s3">;</span>
    <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
      <span class="s1">n </span><span class="s3">= </span><span class="s1">s</span><span class="s3">.</span><span class="s1">toExponential</span><span class="s3">();</span>
      <span class="s1">n </span><span class="s3">= </span><span class="s1">n</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span><span class="s4">0</span><span class="s3">, </span><span class="s1">n</span><span class="s3">.</span><span class="s1">indexOf</span><span class="s3">(</span><span class="s5">'e'</span><span class="s3">) + </span><span class="s4">1</span><span class="s3">) + </span><span class="s1">e</span><span class="s3">;</span>
    <span class="s3">}</span>

    <span class="s1">r </span><span class="s3">= </span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">n</span><span class="s3">);</span>
  <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
    <span class="s1">r </span><span class="s3">= </span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">s</span><span class="s3">.</span><span class="s1">toString</span><span class="s3">());</span>
  <span class="s3">}</span>

  <span class="s1">sd </span><span class="s3">= (</span><span class="s1">e </span><span class="s3">= </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">precision</span><span class="s3">) + </span><span class="s4">3</span><span class="s3">;</span>

  <span class="s0">// Newton-Raphson iteration.</span>
  <span class="s2">for </span><span class="s3">(;;) {</span>
    <span class="s1">t </span><span class="s3">= </span><span class="s1">r</span><span class="s3">;</span>
    <span class="s1">r </span><span class="s3">= </span><span class="s1">t</span><span class="s3">.</span><span class="s1">plus</span><span class="s3">(</span><span class="s1">divide</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">t</span><span class="s3">, </span><span class="s1">sd </span><span class="s3">+ </span><span class="s4">2</span><span class="s3">, </span><span class="s4">1</span><span class="s3">)).</span><span class="s1">times</span><span class="s3">(</span><span class="s4">0.5</span><span class="s3">);</span>

    <span class="s0">// TODO? Replace with for-loop and checkRoundingDigits.</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">digitsToString</span><span class="s3">(</span><span class="s1">t</span><span class="s3">.</span><span class="s1">d</span><span class="s3">).</span><span class="s1">slice</span><span class="s3">(</span><span class="s4">0</span><span class="s3">, </span><span class="s1">sd</span><span class="s3">) === (</span><span class="s1">n </span><span class="s3">= </span><span class="s1">digitsToString</span><span class="s3">(</span><span class="s1">r</span><span class="s3">.</span><span class="s1">d</span><span class="s3">)).</span><span class="s1">slice</span><span class="s3">(</span><span class="s4">0</span><span class="s3">, </span><span class="s1">sd</span><span class="s3">)) {</span>
      <span class="s1">n </span><span class="s3">= </span><span class="s1">n</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span><span class="s1">sd </span><span class="s3">- </span><span class="s4">3</span><span class="s3">, </span><span class="s1">sd </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">);</span>

      <span class="s0">// The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or</span>
      <span class="s0">// 4999, i.e. approaching a rounding boundary, continue the iteration.</span>
      <span class="s2">if </span><span class="s3">(</span><span class="s1">n </span><span class="s3">== </span><span class="s5">'9999' </span><span class="s3">|| !</span><span class="s1">rep </span><span class="s3">&amp;&amp; </span><span class="s1">n </span><span class="s3">== </span><span class="s5">'4999'</span><span class="s3">) {</span>

        <span class="s0">// On the first iteration only, check to see if rounding up gives the exact result as the</span>
        <span class="s0">// nines may infinitely repeat.</span>
        <span class="s2">if </span><span class="s3">(!</span><span class="s1">rep</span><span class="s3">) {</span>
          <span class="s1">finalise</span><span class="s3">(</span><span class="s1">t</span><span class="s3">, </span><span class="s1">e </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">, </span><span class="s4">0</span><span class="s3">);</span>

          <span class="s2">if </span><span class="s3">(</span><span class="s1">t</span><span class="s3">.</span><span class="s1">times</span><span class="s3">(</span><span class="s1">t</span><span class="s3">).</span><span class="s1">eq</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)) {</span>
            <span class="s1">r </span><span class="s3">= </span><span class="s1">t</span><span class="s3">;</span>
            <span class="s2">break</span><span class="s3">;</span>
          <span class="s3">}</span>
        <span class="s3">}</span>

        <span class="s1">sd </span><span class="s3">+= </span><span class="s4">4</span><span class="s3">;</span>
        <span class="s1">rep </span><span class="s3">= </span><span class="s4">1</span><span class="s3">;</span>
      <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>

        <span class="s0">// If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.</span>
        <span class="s0">// If not, then there are further digits and m will be truthy.</span>
        <span class="s2">if </span><span class="s3">(!+</span><span class="s1">n </span><span class="s3">|| !+</span><span class="s1">n</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span><span class="s4">1</span><span class="s3">) &amp;&amp; </span><span class="s1">n</span><span class="s3">.</span><span class="s1">charAt</span><span class="s3">(</span><span class="s4">0</span><span class="s3">) == </span><span class="s5">'5'</span><span class="s3">) {</span>

          <span class="s0">// Truncate to the first rounding digit.</span>
          <span class="s1">finalise</span><span class="s3">(</span><span class="s1">r</span><span class="s3">, </span><span class="s1">e </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">);</span>
          <span class="s1">m </span><span class="s3">= !</span><span class="s1">r</span><span class="s3">.</span><span class="s1">times</span><span class="s3">(</span><span class="s1">r</span><span class="s3">).</span><span class="s1">eq</span><span class="s3">(</span><span class="s1">x</span><span class="s3">);</span>
        <span class="s3">}</span>

        <span class="s2">break</span><span class="s3">;</span>
      <span class="s3">}</span>
    <span class="s3">}</span>
  <span class="s3">}</span>

  <span class="s1">external </span><span class="s3">= </span><span class="s2">true</span><span class="s3">;</span>

  <span class="s2">return </span><span class="s1">finalise</span><span class="s3">(</span><span class="s1">r</span><span class="s3">, </span><span class="s1">e</span><span class="s3">, </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">rounding</span><span class="s3">, </span><span class="s1">m</span><span class="s3">);</span>
<span class="s3">};</span>


<span class="s0">/* 
 * Return a new Decimal whose value is the tangent of the value in radians of this Decimal. 
 * 
 * Domain: [-Infinity, Infinity] 
 * Range: [-Infinity, Infinity] 
 * 
 * tan(0)         = 0 
 * tan(-0)        = -0 
 * tan(Infinity)  = NaN 
 * tan(-Infinity) = NaN 
 * tan(NaN)       = NaN 
 * 
 */</span>
<span class="s1">P</span><span class="s3">.</span><span class="s1">tangent </span><span class="s3">= </span><span class="s1">P</span><span class="s3">.</span><span class="s1">tan </span><span class="s3">= </span><span class="s2">function </span><span class="s3">() {</span>
  <span class="s2">var </span><span class="s1">pr</span><span class="s3">, </span><span class="s1">rm</span><span class="s3">,</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s2">this</span><span class="s3">,</span>
    <span class="s1">Ctor </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">constructor</span><span class="s3">;</span>

  <span class="s2">if </span><span class="s3">(!</span><span class="s1">x</span><span class="s3">.</span><span class="s1">isFinite</span><span class="s3">()) </span><span class="s2">return new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">NaN</span><span class="s3">);</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">isZero</span><span class="s3">()) </span><span class="s2">return new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">x</span><span class="s3">);</span>

  <span class="s1">pr </span><span class="s3">= </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">precision</span><span class="s3">;</span>
  <span class="s1">rm </span><span class="s3">= </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">rounding</span><span class="s3">;</span>
  <span class="s1">Ctor</span><span class="s3">.</span><span class="s1">precision </span><span class="s3">= </span><span class="s1">pr </span><span class="s3">+ </span><span class="s4">10</span><span class="s3">;</span>
  <span class="s1">Ctor</span><span class="s3">.</span><span class="s1">rounding </span><span class="s3">= </span><span class="s4">1</span><span class="s3">;</span>

  <span class="s1">x </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">sin</span><span class="s3">();</span>
  <span class="s1">x</span><span class="s3">.</span><span class="s1">s </span><span class="s3">= </span><span class="s4">1</span><span class="s3">;</span>
  <span class="s1">x </span><span class="s3">= </span><span class="s1">divide</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s4">1</span><span class="s3">).</span><span class="s1">minus</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">times</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)).</span><span class="s1">sqrt</span><span class="s3">(), </span><span class="s1">pr </span><span class="s3">+ </span><span class="s4">10</span><span class="s3">, </span><span class="s4">0</span><span class="s3">);</span>

  <span class="s1">Ctor</span><span class="s3">.</span><span class="s1">precision </span><span class="s3">= </span><span class="s1">pr</span><span class="s3">;</span>
  <span class="s1">Ctor</span><span class="s3">.</span><span class="s1">rounding </span><span class="s3">= </span><span class="s1">rm</span><span class="s3">;</span>

  <span class="s2">return </span><span class="s1">finalise</span><span class="s3">(</span><span class="s1">quadrant </span><span class="s3">== </span><span class="s4">2 </span><span class="s3">|| </span><span class="s1">quadrant </span><span class="s3">== </span><span class="s4">4 </span><span class="s3">? </span><span class="s1">x</span><span class="s3">.</span><span class="s1">neg</span><span class="s3">() : </span><span class="s1">x</span><span class="s3">, </span><span class="s1">pr</span><span class="s3">, </span><span class="s1">rm</span><span class="s3">, </span><span class="s2">true</span><span class="s3">);</span>
<span class="s3">};</span>


<span class="s0">/* 
 *  n * 0 = 0 
 *  n * N = N 
 *  n * I = I 
 *  0 * n = 0 
 *  0 * 0 = 0 
 *  0 * N = N 
 *  0 * I = N 
 *  N * n = N 
 *  N * 0 = N 
 *  N * N = N 
 *  N * I = N 
 *  I * n = I 
 *  I * 0 = N 
 *  I * N = N 
 *  I * I = I 
 * 
 * Return a new Decimal whose value is this Decimal times `y`, rounded to `precision` significant 
 * digits using rounding mode `rounding`. 
 * 
 */</span>
<span class="s1">P</span><span class="s3">.</span><span class="s1">times </span><span class="s3">= </span><span class="s1">P</span><span class="s3">.</span><span class="s1">mul </span><span class="s3">= </span><span class="s2">function </span><span class="s3">(</span><span class="s1">y</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">carry</span><span class="s3">, </span><span class="s1">e</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">r</span><span class="s3">, </span><span class="s1">rL</span><span class="s3">, </span><span class="s1">t</span><span class="s3">, </span><span class="s1">xdL</span><span class="s3">, </span><span class="s1">ydL</span><span class="s3">,</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s2">this</span><span class="s3">,</span>
    <span class="s1">Ctor </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">constructor</span><span class="s3">,</span>
    <span class="s1">xd </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">d</span><span class="s3">,</span>
    <span class="s1">yd </span><span class="s3">= (</span><span class="s1">y </span><span class="s3">= </span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">y</span><span class="s3">)).</span><span class="s1">d</span><span class="s3">;</span>

  <span class="s1">y</span><span class="s3">.</span><span class="s1">s </span><span class="s3">*= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">s</span><span class="s3">;</span>

   <span class="s0">// If either is NaN, Â±Infinity or Â±0...</span>
  <span class="s2">if </span><span class="s3">(!</span><span class="s1">xd </span><span class="s3">|| !</span><span class="s1">xd</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] || !</span><span class="s1">yd </span><span class="s3">|| !</span><span class="s1">yd</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]) {</span>

    <span class="s2">return new </span><span class="s1">Ctor</span><span class="s3">(!</span><span class="s1">y</span><span class="s3">.</span><span class="s1">s </span><span class="s3">|| </span><span class="s1">xd </span><span class="s3">&amp;&amp; !</span><span class="s1">xd</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] &amp;&amp; !</span><span class="s1">yd </span><span class="s3">|| </span><span class="s1">yd </span><span class="s3">&amp;&amp; !</span><span class="s1">yd</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] &amp;&amp; !</span><span class="s1">xd</span>

      <span class="s0">// Return NaN if either is NaN.</span>
      <span class="s0">// Return NaN if x is Â±0 and y is Â±Infinity, or y is Â±0 and x is Â±Infinity.</span>
      <span class="s3">? </span><span class="s1">NaN</span>

      <span class="s0">// Return Â±Infinity if either is Â±Infinity.</span>
      <span class="s0">// Return Â±0 if either is Â±0.</span>
      <span class="s3">: !</span><span class="s1">xd </span><span class="s3">|| !</span><span class="s1">yd </span><span class="s3">? </span><span class="s1">y</span><span class="s3">.</span><span class="s1">s </span><span class="s3">/ </span><span class="s4">0 </span><span class="s3">: </span><span class="s1">y</span><span class="s3">.</span><span class="s1">s </span><span class="s3">* </span><span class="s4">0</span><span class="s3">);</span>
  <span class="s3">}</span>

  <span class="s1">e </span><span class="s3">= </span><span class="s1">mathfloor</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">e </span><span class="s3">/ </span><span class="s1">LOG_BASE</span><span class="s3">) + </span><span class="s1">mathfloor</span><span class="s3">(</span><span class="s1">y</span><span class="s3">.</span><span class="s1">e </span><span class="s3">/ </span><span class="s1">LOG_BASE</span><span class="s3">);</span>
  <span class="s1">xdL </span><span class="s3">= </span><span class="s1">xd</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span>
  <span class="s1">ydL </span><span class="s3">= </span><span class="s1">yd</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span>

  <span class="s0">// Ensure xd points to the longer array.</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">xdL </span><span class="s3">&lt; </span><span class="s1">ydL</span><span class="s3">) {</span>
    <span class="s1">r </span><span class="s3">= </span><span class="s1">xd</span><span class="s3">;</span>
    <span class="s1">xd </span><span class="s3">= </span><span class="s1">yd</span><span class="s3">;</span>
    <span class="s1">yd </span><span class="s3">= </span><span class="s1">r</span><span class="s3">;</span>
    <span class="s1">rL </span><span class="s3">= </span><span class="s1">xdL</span><span class="s3">;</span>
    <span class="s1">xdL </span><span class="s3">= </span><span class="s1">ydL</span><span class="s3">;</span>
    <span class="s1">ydL </span><span class="s3">= </span><span class="s1">rL</span><span class="s3">;</span>
  <span class="s3">}</span>

  <span class="s0">// Initialise the result array with zeros.</span>
  <span class="s1">r </span><span class="s3">= [];</span>
  <span class="s1">rL </span><span class="s3">= </span><span class="s1">xdL </span><span class="s3">+ </span><span class="s1">ydL</span><span class="s3">;</span>
  <span class="s2">for </span><span class="s3">(</span><span class="s1">i </span><span class="s3">= </span><span class="s1">rL</span><span class="s3">; </span><span class="s1">i</span><span class="s3">--;) </span><span class="s1">r</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s4">0</span><span class="s3">);</span>

  <span class="s0">// Multiply!</span>
  <span class="s2">for </span><span class="s3">(</span><span class="s1">i </span><span class="s3">= </span><span class="s1">ydL</span><span class="s3">; --</span><span class="s1">i </span><span class="s3">&gt;= </span><span class="s4">0</span><span class="s3">;) {</span>
    <span class="s1">carry </span><span class="s3">= </span><span class="s4">0</span><span class="s3">;</span>
    <span class="s2">for </span><span class="s3">(</span><span class="s1">k </span><span class="s3">= </span><span class="s1">xdL </span><span class="s3">+ </span><span class="s1">i</span><span class="s3">; </span><span class="s1">k </span><span class="s3">&gt; </span><span class="s1">i</span><span class="s3">;) {</span>
      <span class="s1">t </span><span class="s3">= </span><span class="s1">r</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] + </span><span class="s1">yd</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] * </span><span class="s1">xd</span><span class="s3">[</span><span class="s1">k </span><span class="s3">- </span><span class="s1">i </span><span class="s3">- </span><span class="s4">1</span><span class="s3">] + </span><span class="s1">carry</span><span class="s3">;</span>
      <span class="s1">r</span><span class="s3">[</span><span class="s1">k</span><span class="s3">--] = </span><span class="s1">t </span><span class="s3">% </span><span class="s1">BASE </span><span class="s3">| </span><span class="s4">0</span><span class="s3">;</span>
      <span class="s1">carry </span><span class="s3">= </span><span class="s1">t </span><span class="s3">/ </span><span class="s1">BASE </span><span class="s3">| </span><span class="s4">0</span><span class="s3">;</span>
    <span class="s3">}</span>

    <span class="s1">r</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] = (</span><span class="s1">r</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] + </span><span class="s1">carry</span><span class="s3">) % </span><span class="s1">BASE </span><span class="s3">| </span><span class="s4">0</span><span class="s3">;</span>
  <span class="s3">}</span>

  <span class="s0">// Remove trailing zeros.</span>
  <span class="s2">for </span><span class="s3">(; !</span><span class="s1">r</span><span class="s3">[--</span><span class="s1">rL</span><span class="s3">];) </span><span class="s1">r</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">();</span>

  <span class="s2">if </span><span class="s3">(</span><span class="s1">carry</span><span class="s3">) ++</span><span class="s1">e</span><span class="s3">;</span>
  <span class="s2">else </span><span class="s1">r</span><span class="s3">.</span><span class="s1">shift</span><span class="s3">();</span>

  <span class="s1">y</span><span class="s3">.</span><span class="s1">d </span><span class="s3">= </span><span class="s1">r</span><span class="s3">;</span>
  <span class="s1">y</span><span class="s3">.</span><span class="s1">e </span><span class="s3">= </span><span class="s1">getBase10Exponent</span><span class="s3">(</span><span class="s1">r</span><span class="s3">, </span><span class="s1">e</span><span class="s3">);</span>

  <span class="s2">return </span><span class="s1">external </span><span class="s3">? </span><span class="s1">finalise</span><span class="s3">(</span><span class="s1">y</span><span class="s3">, </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">precision</span><span class="s3">, </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">rounding</span><span class="s3">) : </span><span class="s1">y</span><span class="s3">;</span>
<span class="s3">};</span>


<span class="s0">/* 
 * Return a string representing the value of this Decimal in base 2, round to `sd` significant 
 * digits using rounding mode `rm`. 
 * 
 * If the optional `sd` argument is present then return binary exponential notation. 
 * 
 * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive. 
 * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive. 
 * 
 */</span>
<span class="s1">P</span><span class="s3">.</span><span class="s1">toBinary </span><span class="s3">= </span><span class="s2">function </span><span class="s3">(</span><span class="s1">sd</span><span class="s3">, </span><span class="s1">rm</span><span class="s3">) {</span>
  <span class="s2">return </span><span class="s1">toStringBinary</span><span class="s3">(</span><span class="s2">this</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s1">sd</span><span class="s3">, </span><span class="s1">rm</span><span class="s3">);</span>
<span class="s3">};</span>


<span class="s0">/* 
 * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `dp` 
 * decimal places using rounding mode `rm` or `rounding` if `rm` is omitted. 
 * 
 * If `dp` is omitted, return a new Decimal whose value is the value of this Decimal. 
 * 
 * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive. 
 * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive. 
 * 
 */</span>
<span class="s1">P</span><span class="s3">.</span><span class="s1">toDecimalPlaces </span><span class="s3">= </span><span class="s1">P</span><span class="s3">.</span><span class="s1">toDP </span><span class="s3">= </span><span class="s2">function </span><span class="s3">(</span><span class="s1">dp</span><span class="s3">, </span><span class="s1">rm</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">x </span><span class="s3">= </span><span class="s2">this</span><span class="s3">,</span>
    <span class="s1">Ctor </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">constructor</span><span class="s3">;</span>

  <span class="s1">x </span><span class="s3">= </span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">x</span><span class="s3">);</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">dp </span><span class="s3">=== </span><span class="s2">void </span><span class="s4">0</span><span class="s3">) </span><span class="s2">return </span><span class="s1">x</span><span class="s3">;</span>

  <span class="s1">checkInt32</span><span class="s3">(</span><span class="s1">dp</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s1">MAX_DIGITS</span><span class="s3">);</span>

  <span class="s2">if </span><span class="s3">(</span><span class="s1">rm </span><span class="s3">=== </span><span class="s2">void </span><span class="s4">0</span><span class="s3">) </span><span class="s1">rm </span><span class="s3">= </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">rounding</span><span class="s3">;</span>
  <span class="s2">else </span><span class="s1">checkInt32</span><span class="s3">(</span><span class="s1">rm</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">8</span><span class="s3">);</span>

  <span class="s2">return </span><span class="s1">finalise</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">dp </span><span class="s3">+ </span><span class="s1">x</span><span class="s3">.</span><span class="s1">e </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">, </span><span class="s1">rm</span><span class="s3">);</span>
<span class="s3">};</span>


<span class="s0">/* 
 * Return a string representing the value of this Decimal in exponential notation rounded to 
 * `dp` fixed decimal places using rounding mode `rounding`. 
 * 
 * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive. 
 * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive. 
 * 
 */</span>
<span class="s1">P</span><span class="s3">.</span><span class="s1">toExponential </span><span class="s3">= </span><span class="s2">function </span><span class="s3">(</span><span class="s1">dp</span><span class="s3">, </span><span class="s1">rm</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">str</span><span class="s3">,</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s2">this</span><span class="s3">,</span>
    <span class="s1">Ctor </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">constructor</span><span class="s3">;</span>

  <span class="s2">if </span><span class="s3">(</span><span class="s1">dp </span><span class="s3">=== </span><span class="s2">void </span><span class="s4">0</span><span class="s3">) {</span>
    <span class="s1">str </span><span class="s3">= </span><span class="s1">finiteToString</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s2">true</span><span class="s3">);</span>
  <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
    <span class="s1">checkInt32</span><span class="s3">(</span><span class="s1">dp</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s1">MAX_DIGITS</span><span class="s3">);</span>

    <span class="s2">if </span><span class="s3">(</span><span class="s1">rm </span><span class="s3">=== </span><span class="s2">void </span><span class="s4">0</span><span class="s3">) </span><span class="s1">rm </span><span class="s3">= </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">rounding</span><span class="s3">;</span>
    <span class="s2">else </span><span class="s1">checkInt32</span><span class="s3">(</span><span class="s1">rm</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">8</span><span class="s3">);</span>

    <span class="s1">x </span><span class="s3">= </span><span class="s1">finalise</span><span class="s3">(</span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">x</span><span class="s3">), </span><span class="s1">dp </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">, </span><span class="s1">rm</span><span class="s3">);</span>
    <span class="s1">str </span><span class="s3">= </span><span class="s1">finiteToString</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s2">true</span><span class="s3">, </span><span class="s1">dp </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">);</span>
  <span class="s3">}</span>

  <span class="s2">return </span><span class="s1">x</span><span class="s3">.</span><span class="s1">isNeg</span><span class="s3">() &amp;&amp; !</span><span class="s1">x</span><span class="s3">.</span><span class="s1">isZero</span><span class="s3">() ? </span><span class="s5">'-' </span><span class="s3">+ </span><span class="s1">str </span><span class="s3">: </span><span class="s1">str</span><span class="s3">;</span>
<span class="s3">};</span>


<span class="s0">/* 
 * Return a string representing the value of this Decimal in normal (fixed-point) notation to 
 * `dp` fixed decimal places and rounded using rounding mode `rm` or `rounding` if `rm` is 
 * omitted. 
 * 
 * As with JavaScript numbers, (-0).toFixed(0) is '0', but e.g. (-0.00001).toFixed(0) is '-0'. 
 * 
 * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive. 
 * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive. 
 * 
 * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'. 
 * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'. 
 * (-0).toFixed(3) is '0.000'. 
 * (-0.5).toFixed(0) is '-0'. 
 * 
 */</span>
<span class="s1">P</span><span class="s3">.</span><span class="s1">toFixed </span><span class="s3">= </span><span class="s2">function </span><span class="s3">(</span><span class="s1">dp</span><span class="s3">, </span><span class="s1">rm</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">str</span><span class="s3">, </span><span class="s1">y</span><span class="s3">,</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s2">this</span><span class="s3">,</span>
    <span class="s1">Ctor </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">constructor</span><span class="s3">;</span>

  <span class="s2">if </span><span class="s3">(</span><span class="s1">dp </span><span class="s3">=== </span><span class="s2">void </span><span class="s4">0</span><span class="s3">) {</span>
    <span class="s1">str </span><span class="s3">= </span><span class="s1">finiteToString</span><span class="s3">(</span><span class="s1">x</span><span class="s3">);</span>
  <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
    <span class="s1">checkInt32</span><span class="s3">(</span><span class="s1">dp</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s1">MAX_DIGITS</span><span class="s3">);</span>

    <span class="s2">if </span><span class="s3">(</span><span class="s1">rm </span><span class="s3">=== </span><span class="s2">void </span><span class="s4">0</span><span class="s3">) </span><span class="s1">rm </span><span class="s3">= </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">rounding</span><span class="s3">;</span>
    <span class="s2">else </span><span class="s1">checkInt32</span><span class="s3">(</span><span class="s1">rm</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">8</span><span class="s3">);</span>

    <span class="s1">y </span><span class="s3">= </span><span class="s1">finalise</span><span class="s3">(</span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">x</span><span class="s3">), </span><span class="s1">dp </span><span class="s3">+ </span><span class="s1">x</span><span class="s3">.</span><span class="s1">e </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">, </span><span class="s1">rm</span><span class="s3">);</span>
    <span class="s1">str </span><span class="s3">= </span><span class="s1">finiteToString</span><span class="s3">(</span><span class="s1">y</span><span class="s3">, </span><span class="s2">false</span><span class="s3">, </span><span class="s1">dp </span><span class="s3">+ </span><span class="s1">y</span><span class="s3">.</span><span class="s1">e </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">);</span>
  <span class="s3">}</span>

  <span class="s0">// To determine whether to add the minus sign look at the value before it was rounded,</span>
  <span class="s0">// i.e. look at `x` rather than `y`.</span>
  <span class="s2">return </span><span class="s1">x</span><span class="s3">.</span><span class="s1">isNeg</span><span class="s3">() &amp;&amp; !</span><span class="s1">x</span><span class="s3">.</span><span class="s1">isZero</span><span class="s3">() ? </span><span class="s5">'-' </span><span class="s3">+ </span><span class="s1">str </span><span class="s3">: </span><span class="s1">str</span><span class="s3">;</span>
<span class="s3">};</span>


<span class="s0">/* 
 * Return an array representing the value of this Decimal as a simple fraction with an integer 
 * numerator and an integer denominator. 
 * 
 * The denominator will be a positive non-zero value less than or equal to the specified maximum 
 * denominator. If a maximum denominator is not specified, the denominator will be the lowest 
 * value necessary to represent the number exactly. 
 * 
 * [maxD] {number|string|bigint|Decimal} Maximum denominator. Integer &gt;= 1 and &lt; Infinity. 
 * 
 */</span>
<span class="s1">P</span><span class="s3">.</span><span class="s1">toFraction </span><span class="s3">= </span><span class="s2">function </span><span class="s3">(</span><span class="s1">maxD</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">d</span><span class="s3">, </span><span class="s1">d0</span><span class="s3">, </span><span class="s1">d1</span><span class="s3">, </span><span class="s1">d2</span><span class="s3">, </span><span class="s1">e</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">n0</span><span class="s3">, </span><span class="s1">n1</span><span class="s3">, </span><span class="s1">pr</span><span class="s3">, </span><span class="s1">q</span><span class="s3">, </span><span class="s1">r</span><span class="s3">,</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s2">this</span><span class="s3">,</span>
    <span class="s1">xd </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">d</span><span class="s3">,</span>
    <span class="s1">Ctor </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">constructor</span><span class="s3">;</span>

  <span class="s2">if </span><span class="s3">(!</span><span class="s1">xd</span><span class="s3">) </span><span class="s2">return new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">x</span><span class="s3">);</span>

  <span class="s1">n1 </span><span class="s3">= </span><span class="s1">d0 </span><span class="s3">= </span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s4">1</span><span class="s3">);</span>
  <span class="s1">d1 </span><span class="s3">= </span><span class="s1">n0 </span><span class="s3">= </span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s4">0</span><span class="s3">);</span>

  <span class="s1">d </span><span class="s3">= </span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">d1</span><span class="s3">);</span>
  <span class="s1">e </span><span class="s3">= </span><span class="s1">d</span><span class="s3">.</span><span class="s1">e </span><span class="s3">= </span><span class="s1">getPrecision</span><span class="s3">(</span><span class="s1">xd</span><span class="s3">) - </span><span class="s1">x</span><span class="s3">.</span><span class="s1">e </span><span class="s3">- </span><span class="s4">1</span><span class="s3">;</span>
  <span class="s1">k </span><span class="s3">= </span><span class="s1">e </span><span class="s3">% </span><span class="s1">LOG_BASE</span><span class="s3">;</span>
  <span class="s1">d</span><span class="s3">.</span><span class="s1">d</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] = </span><span class="s1">mathpow</span><span class="s3">(</span><span class="s4">10</span><span class="s3">, </span><span class="s1">k </span><span class="s3">&lt; </span><span class="s4">0 </span><span class="s3">? </span><span class="s1">LOG_BASE </span><span class="s3">+ </span><span class="s1">k </span><span class="s3">: </span><span class="s1">k</span><span class="s3">);</span>

  <span class="s2">if </span><span class="s3">(</span><span class="s1">maxD </span><span class="s3">== </span><span class="s2">null</span><span class="s3">) {</span>

    <span class="s0">// d is 10**e, the minimum max-denominator needed.</span>
    <span class="s1">maxD </span><span class="s3">= </span><span class="s1">e </span><span class="s3">&gt; </span><span class="s4">0 </span><span class="s3">? </span><span class="s1">d </span><span class="s3">: </span><span class="s1">n1</span><span class="s3">;</span>
  <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
    <span class="s1">n </span><span class="s3">= </span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">maxD</span><span class="s3">);</span>
    <span class="s2">if </span><span class="s3">(!</span><span class="s1">n</span><span class="s3">.</span><span class="s1">isInt</span><span class="s3">() || </span><span class="s1">n</span><span class="s3">.</span><span class="s1">lt</span><span class="s3">(</span><span class="s1">n1</span><span class="s3">)) </span><span class="s2">throw </span><span class="s1">Error</span><span class="s3">(</span><span class="s1">invalidArgument </span><span class="s3">+ </span><span class="s1">n</span><span class="s3">);</span>
    <span class="s1">maxD </span><span class="s3">= </span><span class="s1">n</span><span class="s3">.</span><span class="s1">gt</span><span class="s3">(</span><span class="s1">d</span><span class="s3">) ? (</span><span class="s1">e </span><span class="s3">&gt; </span><span class="s4">0 </span><span class="s3">? </span><span class="s1">d </span><span class="s3">: </span><span class="s1">n1</span><span class="s3">) : </span><span class="s1">n</span><span class="s3">;</span>
  <span class="s3">}</span>

  <span class="s1">external </span><span class="s3">= </span><span class="s2">false</span><span class="s3">;</span>
  <span class="s1">n </span><span class="s3">= </span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">digitsToString</span><span class="s3">(</span><span class="s1">xd</span><span class="s3">));</span>
  <span class="s1">pr </span><span class="s3">= </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">precision</span><span class="s3">;</span>
  <span class="s1">Ctor</span><span class="s3">.</span><span class="s1">precision </span><span class="s3">= </span><span class="s1">e </span><span class="s3">= </span><span class="s1">xd</span><span class="s3">.</span><span class="s1">length </span><span class="s3">* </span><span class="s1">LOG_BASE </span><span class="s3">* </span><span class="s4">2</span><span class="s3">;</span>

  <span class="s2">for </span><span class="s3">(;;)  {</span>
    <span class="s1">q </span><span class="s3">= </span><span class="s1">divide</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">d</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">);</span>
    <span class="s1">d2 </span><span class="s3">= </span><span class="s1">d0</span><span class="s3">.</span><span class="s1">plus</span><span class="s3">(</span><span class="s1">q</span><span class="s3">.</span><span class="s1">times</span><span class="s3">(</span><span class="s1">d1</span><span class="s3">));</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">d2</span><span class="s3">.</span><span class="s1">cmp</span><span class="s3">(</span><span class="s1">maxD</span><span class="s3">) == </span><span class="s4">1</span><span class="s3">) </span><span class="s2">break</span><span class="s3">;</span>
    <span class="s1">d0 </span><span class="s3">= </span><span class="s1">d1</span><span class="s3">;</span>
    <span class="s1">d1 </span><span class="s3">= </span><span class="s1">d2</span><span class="s3">;</span>
    <span class="s1">d2 </span><span class="s3">= </span><span class="s1">n1</span><span class="s3">;</span>
    <span class="s1">n1 </span><span class="s3">= </span><span class="s1">n0</span><span class="s3">.</span><span class="s1">plus</span><span class="s3">(</span><span class="s1">q</span><span class="s3">.</span><span class="s1">times</span><span class="s3">(</span><span class="s1">d2</span><span class="s3">));</span>
    <span class="s1">n0 </span><span class="s3">= </span><span class="s1">d2</span><span class="s3">;</span>
    <span class="s1">d2 </span><span class="s3">= </span><span class="s1">d</span><span class="s3">;</span>
    <span class="s1">d </span><span class="s3">= </span><span class="s1">n</span><span class="s3">.</span><span class="s1">minus</span><span class="s3">(</span><span class="s1">q</span><span class="s3">.</span><span class="s1">times</span><span class="s3">(</span><span class="s1">d2</span><span class="s3">));</span>
    <span class="s1">n </span><span class="s3">= </span><span class="s1">d2</span><span class="s3">;</span>
  <span class="s3">}</span>

  <span class="s1">d2 </span><span class="s3">= </span><span class="s1">divide</span><span class="s3">(</span><span class="s1">maxD</span><span class="s3">.</span><span class="s1">minus</span><span class="s3">(</span><span class="s1">d0</span><span class="s3">), </span><span class="s1">d1</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">);</span>
  <span class="s1">n0 </span><span class="s3">= </span><span class="s1">n0</span><span class="s3">.</span><span class="s1">plus</span><span class="s3">(</span><span class="s1">d2</span><span class="s3">.</span><span class="s1">times</span><span class="s3">(</span><span class="s1">n1</span><span class="s3">));</span>
  <span class="s1">d0 </span><span class="s3">= </span><span class="s1">d0</span><span class="s3">.</span><span class="s1">plus</span><span class="s3">(</span><span class="s1">d2</span><span class="s3">.</span><span class="s1">times</span><span class="s3">(</span><span class="s1">d1</span><span class="s3">));</span>
  <span class="s1">n0</span><span class="s3">.</span><span class="s1">s </span><span class="s3">= </span><span class="s1">n1</span><span class="s3">.</span><span class="s1">s </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">s</span><span class="s3">;</span>

  <span class="s0">// Determine which fraction is closer to x, n0/d0 or n1/d1?</span>
  <span class="s1">r </span><span class="s3">= </span><span class="s1">divide</span><span class="s3">(</span><span class="s1">n1</span><span class="s3">, </span><span class="s1">d1</span><span class="s3">, </span><span class="s1">e</span><span class="s3">, </span><span class="s4">1</span><span class="s3">).</span><span class="s1">minus</span><span class="s3">(</span><span class="s1">x</span><span class="s3">).</span><span class="s1">abs</span><span class="s3">().</span><span class="s1">cmp</span><span class="s3">(</span><span class="s1">divide</span><span class="s3">(</span><span class="s1">n0</span><span class="s3">, </span><span class="s1">d0</span><span class="s3">, </span><span class="s1">e</span><span class="s3">, </span><span class="s4">1</span><span class="s3">).</span><span class="s1">minus</span><span class="s3">(</span><span class="s1">x</span><span class="s3">).</span><span class="s1">abs</span><span class="s3">()) &lt; </span><span class="s4">1</span>
      <span class="s3">? [</span><span class="s1">n1</span><span class="s3">, </span><span class="s1">d1</span><span class="s3">] : [</span><span class="s1">n0</span><span class="s3">, </span><span class="s1">d0</span><span class="s3">];</span>

  <span class="s1">Ctor</span><span class="s3">.</span><span class="s1">precision </span><span class="s3">= </span><span class="s1">pr</span><span class="s3">;</span>
  <span class="s1">external </span><span class="s3">= </span><span class="s2">true</span><span class="s3">;</span>

  <span class="s2">return </span><span class="s1">r</span><span class="s3">;</span>
<span class="s3">};</span>


<span class="s0">/* 
 * Return a string representing the value of this Decimal in base 16, round to `sd` significant 
 * digits using rounding mode `rm`. 
 * 
 * If the optional `sd` argument is present then return binary exponential notation. 
 * 
 * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive. 
 * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive. 
 * 
 */</span>
<span class="s1">P</span><span class="s3">.</span><span class="s1">toHexadecimal </span><span class="s3">= </span><span class="s1">P</span><span class="s3">.</span><span class="s1">toHex </span><span class="s3">= </span><span class="s2">function </span><span class="s3">(</span><span class="s1">sd</span><span class="s3">, </span><span class="s1">rm</span><span class="s3">) {</span>
  <span class="s2">return </span><span class="s1">toStringBinary</span><span class="s3">(</span><span class="s2">this</span><span class="s3">, </span><span class="s4">16</span><span class="s3">, </span><span class="s1">sd</span><span class="s3">, </span><span class="s1">rm</span><span class="s3">);</span>
<span class="s3">};</span>


<span class="s0">/* 
 * Returns a new Decimal whose value is the nearest multiple of `y` in the direction of rounding 
 * mode `rm`, or `Decimal.rounding` if `rm` is omitted, to the value of this Decimal. 
 * 
 * The return value will always have the same sign as this Decimal, unless either this Decimal 
 * or `y` is NaN, in which case the return value will be also be NaN. 
 * 
 * The return value is not affected by the value of `precision`. 
 * 
 * y {number|string|bigint|Decimal} The magnitude to round to a multiple of. 
 * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive. 
 * 
 * 'toNearest() rounding mode not an integer: {rm}' 
 * 'toNearest() rounding mode out of range: {rm}' 
 * 
 */</span>
<span class="s1">P</span><span class="s3">.</span><span class="s1">toNearest </span><span class="s3">= </span><span class="s2">function </span><span class="s3">(</span><span class="s1">y</span><span class="s3">, </span><span class="s1">rm</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">x </span><span class="s3">= </span><span class="s2">this</span><span class="s3">,</span>
    <span class="s1">Ctor </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">constructor</span><span class="s3">;</span>

  <span class="s1">x </span><span class="s3">= </span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">x</span><span class="s3">);</span>

  <span class="s2">if </span><span class="s3">(</span><span class="s1">y </span><span class="s3">== </span><span class="s2">null</span><span class="s3">) {</span>

    <span class="s0">// If x is not finite, return x.</span>
    <span class="s2">if </span><span class="s3">(!</span><span class="s1">x</span><span class="s3">.</span><span class="s1">d</span><span class="s3">) </span><span class="s2">return </span><span class="s1">x</span><span class="s3">;</span>

    <span class="s1">y </span><span class="s3">= </span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s4">1</span><span class="s3">);</span>
    <span class="s1">rm </span><span class="s3">= </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">rounding</span><span class="s3">;</span>
  <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">y</span><span class="s3">);</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">rm </span><span class="s3">=== </span><span class="s2">void </span><span class="s4">0</span><span class="s3">) {</span>
      <span class="s1">rm </span><span class="s3">= </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">rounding</span><span class="s3">;</span>
    <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
      <span class="s1">checkInt32</span><span class="s3">(</span><span class="s1">rm</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">8</span><span class="s3">);</span>
    <span class="s3">}</span>

    <span class="s0">// If x is not finite, return x if y is not NaN, else NaN.</span>
    <span class="s2">if </span><span class="s3">(!</span><span class="s1">x</span><span class="s3">.</span><span class="s1">d</span><span class="s3">) </span><span class="s2">return </span><span class="s1">y</span><span class="s3">.</span><span class="s1">s </span><span class="s3">? </span><span class="s1">x </span><span class="s3">: </span><span class="s1">y</span><span class="s3">;</span>

    <span class="s0">// If y is not finite, return Infinity with the sign of x if y is Infinity, else NaN.</span>
    <span class="s2">if </span><span class="s3">(!</span><span class="s1">y</span><span class="s3">.</span><span class="s1">d</span><span class="s3">) {</span>
      <span class="s2">if </span><span class="s3">(</span><span class="s1">y</span><span class="s3">.</span><span class="s1">s</span><span class="s3">) </span><span class="s1">y</span><span class="s3">.</span><span class="s1">s </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">s</span><span class="s3">;</span>
      <span class="s2">return </span><span class="s1">y</span><span class="s3">;</span>
    <span class="s3">}</span>
  <span class="s3">}</span>

  <span class="s0">// If y is not zero, calculate the nearest multiple of y to x.</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">y</span><span class="s3">.</span><span class="s1">d</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]) {</span>
    <span class="s1">external </span><span class="s3">= </span><span class="s2">false</span><span class="s3">;</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s1">divide</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s1">rm</span><span class="s3">, </span><span class="s4">1</span><span class="s3">).</span><span class="s1">times</span><span class="s3">(</span><span class="s1">y</span><span class="s3">);</span>
    <span class="s1">external </span><span class="s3">= </span><span class="s2">true</span><span class="s3">;</span>
    <span class="s1">finalise</span><span class="s3">(</span><span class="s1">x</span><span class="s3">);</span>

  <span class="s0">// If y is zero, return zero with the sign of x.</span>
  <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
    <span class="s1">y</span><span class="s3">.</span><span class="s1">s </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">s</span><span class="s3">;</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s1">y</span><span class="s3">;</span>
  <span class="s3">}</span>

  <span class="s2">return </span><span class="s1">x</span><span class="s3">;</span>
<span class="s3">};</span>


<span class="s0">/* 
 * Return the value of this Decimal converted to a number primitive. 
 * Zero keeps its sign. 
 * 
 */</span>
<span class="s1">P</span><span class="s3">.</span><span class="s1">toNumber </span><span class="s3">= </span><span class="s2">function </span><span class="s3">() {</span>
  <span class="s2">return </span><span class="s3">+</span><span class="s2">this</span><span class="s3">;</span>
<span class="s3">};</span>


<span class="s0">/* 
 * Return a string representing the value of this Decimal in base 8, round to `sd` significant 
 * digits using rounding mode `rm`. 
 * 
 * If the optional `sd` argument is present then return binary exponential notation. 
 * 
 * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive. 
 * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive. 
 * 
 */</span>
<span class="s1">P</span><span class="s3">.</span><span class="s1">toOctal </span><span class="s3">= </span><span class="s2">function </span><span class="s3">(</span><span class="s1">sd</span><span class="s3">, </span><span class="s1">rm</span><span class="s3">) {</span>
  <span class="s2">return </span><span class="s1">toStringBinary</span><span class="s3">(</span><span class="s2">this</span><span class="s3">, </span><span class="s4">8</span><span class="s3">, </span><span class="s1">sd</span><span class="s3">, </span><span class="s1">rm</span><span class="s3">);</span>
<span class="s3">};</span>


<span class="s0">/* 
 * Return a new Decimal whose value is the value of this Decimal raised to the power `y`, rounded 
 * to `precision` significant digits using rounding mode `rounding`. 
 * 
 * ECMAScript compliant. 
 * 
 *   pow(x, NaN)                           = NaN 
 *   pow(x, Â±0)                            = 1 
 
 *   pow(NaN, non-zero)                    = NaN 
 *   pow(abs(x) &gt; 1, +Infinity)            = +Infinity 
 *   pow(abs(x) &gt; 1, -Infinity)            = +0 
 *   pow(abs(x) == 1, Â±Infinity)           = NaN 
 *   pow(abs(x) &lt; 1, +Infinity)            = +0 
 *   pow(abs(x) &lt; 1, -Infinity)            = +Infinity 
 *   pow(+Infinity, y &gt; 0)                 = +Infinity 
 *   pow(+Infinity, y &lt; 0)                 = +0 
 *   pow(-Infinity, odd integer &gt; 0)       = -Infinity 
 *   pow(-Infinity, even integer &gt; 0)      = +Infinity 
 *   pow(-Infinity, odd integer &lt; 0)       = -0 
 *   pow(-Infinity, even integer &lt; 0)      = +0 
 *   pow(+0, y &gt; 0)                        = +0 
 *   pow(+0, y &lt; 0)                        = +Infinity 
 *   pow(-0, odd integer &gt; 0)              = -0 
 *   pow(-0, even integer &gt; 0)             = +0 
 *   pow(-0, odd integer &lt; 0)              = -Infinity 
 *   pow(-0, even integer &lt; 0)             = +Infinity 
 *   pow(finite x &lt; 0, finite non-integer) = NaN 
 * 
 * For non-integer or very large exponents pow(x, y) is calculated using 
 * 
 *   x^y = exp(y*ln(x)) 
 * 
 * Assuming the first 15 rounding digits are each equally likely to be any digit 0-9, the 
 * probability of an incorrectly rounded result 
 * P([49]9{14} | [50]0{14}) = 2 * 0.2 * 10^-14 = 4e-15 = 1/2.5e+14 
 * i.e. 1 in 250,000,000,000,000 
 * 
 * If a result is incorrectly rounded the maximum error will be 1 ulp (unit in last place). 
 * 
 * y {number|string|bigint|Decimal} The power to which to raise this Decimal. 
 * 
 */</span>
<span class="s1">P</span><span class="s3">.</span><span class="s1">toPower </span><span class="s3">= </span><span class="s1">P</span><span class="s3">.</span><span class="s1">pow </span><span class="s3">= </span><span class="s2">function </span><span class="s3">(</span><span class="s1">y</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">e</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">pr</span><span class="s3">, </span><span class="s1">r</span><span class="s3">, </span><span class="s1">rm</span><span class="s3">, </span><span class="s1">s</span><span class="s3">,</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s2">this</span><span class="s3">,</span>
    <span class="s1">Ctor </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">constructor</span><span class="s3">,</span>
    <span class="s1">yn </span><span class="s3">= +(</span><span class="s1">y </span><span class="s3">= </span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">y</span><span class="s3">));</span>

  <span class="s0">// Either Â±Infinity, NaN or Â±0?</span>
  <span class="s2">if </span><span class="s3">(!</span><span class="s1">x</span><span class="s3">.</span><span class="s1">d </span><span class="s3">|| !</span><span class="s1">y</span><span class="s3">.</span><span class="s1">d </span><span class="s3">|| !</span><span class="s1">x</span><span class="s3">.</span><span class="s1">d</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] || !</span><span class="s1">y</span><span class="s3">.</span><span class="s1">d</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]) </span><span class="s2">return new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">mathpow</span><span class="s3">(+</span><span class="s1">x</span><span class="s3">, </span><span class="s1">yn</span><span class="s3">));</span>

  <span class="s1">x </span><span class="s3">= </span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">x</span><span class="s3">);</span>

  <span class="s2">if </span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">eq</span><span class="s3">(</span><span class="s4">1</span><span class="s3">)) </span><span class="s2">return </span><span class="s1">x</span><span class="s3">;</span>

  <span class="s1">pr </span><span class="s3">= </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">precision</span><span class="s3">;</span>
  <span class="s1">rm </span><span class="s3">= </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">rounding</span><span class="s3">;</span>

  <span class="s2">if </span><span class="s3">(</span><span class="s1">y</span><span class="s3">.</span><span class="s1">eq</span><span class="s3">(</span><span class="s4">1</span><span class="s3">)) </span><span class="s2">return </span><span class="s1">finalise</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">pr</span><span class="s3">, </span><span class="s1">rm</span><span class="s3">);</span>

  <span class="s0">// y exponent</span>
  <span class="s1">e </span><span class="s3">= </span><span class="s1">mathfloor</span><span class="s3">(</span><span class="s1">y</span><span class="s3">.</span><span class="s1">e </span><span class="s3">/ </span><span class="s1">LOG_BASE</span><span class="s3">);</span>

  <span class="s0">// If y is a small integer use the 'exponentiation by squaring' algorithm.</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">e </span><span class="s3">&gt;= </span><span class="s1">y</span><span class="s3">.</span><span class="s1">d</span><span class="s3">.</span><span class="s1">length </span><span class="s3">- </span><span class="s4">1 </span><span class="s3">&amp;&amp; (</span><span class="s1">k </span><span class="s3">= </span><span class="s1">yn </span><span class="s3">&lt; </span><span class="s4">0 </span><span class="s3">? -</span><span class="s1">yn </span><span class="s3">: </span><span class="s1">yn</span><span class="s3">) &lt;= </span><span class="s1">MAX_SAFE_INTEGER</span><span class="s3">) {</span>
    <span class="s1">r </span><span class="s3">= </span><span class="s1">intPow</span><span class="s3">(</span><span class="s1">Ctor</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">pr</span><span class="s3">);</span>
    <span class="s2">return </span><span class="s1">y</span><span class="s3">.</span><span class="s1">s </span><span class="s3">&lt; </span><span class="s4">0 </span><span class="s3">? </span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s4">1</span><span class="s3">).</span><span class="s1">div</span><span class="s3">(</span><span class="s1">r</span><span class="s3">) : </span><span class="s1">finalise</span><span class="s3">(</span><span class="s1">r</span><span class="s3">, </span><span class="s1">pr</span><span class="s3">, </span><span class="s1">rm</span><span class="s3">);</span>
  <span class="s3">}</span>

  <span class="s1">s </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">s</span><span class="s3">;</span>

  <span class="s0">// if x is negative</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">s </span><span class="s3">&lt; </span><span class="s4">0</span><span class="s3">) {</span>

    <span class="s0">// if y is not an integer</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">e </span><span class="s3">&lt; </span><span class="s1">y</span><span class="s3">.</span><span class="s1">d</span><span class="s3">.</span><span class="s1">length </span><span class="s3">- </span><span class="s4">1</span><span class="s3">) </span><span class="s2">return new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">NaN</span><span class="s3">);</span>

    <span class="s0">// Result is positive if x is negative and the last digit of integer y is even.</span>
    <span class="s2">if </span><span class="s3">((</span><span class="s1">y</span><span class="s3">.</span><span class="s1">d</span><span class="s3">[</span><span class="s1">e</span><span class="s3">] &amp; </span><span class="s4">1</span><span class="s3">) == </span><span class="s4">0</span><span class="s3">) </span><span class="s1">s </span><span class="s3">= </span><span class="s4">1</span><span class="s3">;</span>

    <span class="s0">// if x.eq(-1)</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">e </span><span class="s3">== </span><span class="s4">0 </span><span class="s3">&amp;&amp; </span><span class="s1">x</span><span class="s3">.</span><span class="s1">d</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] == </span><span class="s4">1 </span><span class="s3">&amp;&amp; </span><span class="s1">x</span><span class="s3">.</span><span class="s1">d</span><span class="s3">.</span><span class="s1">length </span><span class="s3">== </span><span class="s4">1</span><span class="s3">) {</span>
      <span class="s1">x</span><span class="s3">.</span><span class="s1">s </span><span class="s3">= </span><span class="s1">s</span><span class="s3">;</span>
      <span class="s2">return </span><span class="s1">x</span><span class="s3">;</span>
    <span class="s3">}</span>
  <span class="s3">}</span>

  <span class="s0">// Estimate result exponent.</span>
  <span class="s0">// x^y = 10^e,  where e = y * log10(x)</span>
  <span class="s0">// log10(x) = log10(x_significand) + x_exponent</span>
  <span class="s0">// log10(x_significand) = ln(x_significand) / ln(10)</span>
  <span class="s1">k </span><span class="s3">= </span><span class="s1">mathpow</span><span class="s3">(+</span><span class="s1">x</span><span class="s3">, </span><span class="s1">yn</span><span class="s3">);</span>
  <span class="s1">e </span><span class="s3">= </span><span class="s1">k </span><span class="s3">== </span><span class="s4">0 </span><span class="s3">|| !</span><span class="s1">isFinite</span><span class="s3">(</span><span class="s1">k</span><span class="s3">)</span>
    <span class="s3">? </span><span class="s1">mathfloor</span><span class="s3">(</span><span class="s1">yn </span><span class="s3">* (</span><span class="s1">Math</span><span class="s3">.</span><span class="s1">log</span><span class="s3">(</span><span class="s5">'0.' </span><span class="s3">+ </span><span class="s1">digitsToString</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">d</span><span class="s3">)) / </span><span class="s1">Math</span><span class="s3">.</span><span class="s1">LN10 </span><span class="s3">+ </span><span class="s1">x</span><span class="s3">.</span><span class="s1">e </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">))</span>
    <span class="s3">: </span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">k </span><span class="s3">+ </span><span class="s5">''</span><span class="s3">).</span><span class="s1">e</span><span class="s3">;</span>

  <span class="s0">// Exponent estimate may be incorrect e.g. x: 0.999999999999999999, y: 2.29, e: 0, r.e: -1.</span>

  <span class="s0">// Overflow/underflow?</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">e </span><span class="s3">&gt; </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">maxE </span><span class="s3">+ </span><span class="s4">1 </span><span class="s3">|| </span><span class="s1">e </span><span class="s3">&lt; </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">minE </span><span class="s3">- </span><span class="s4">1</span><span class="s3">) </span><span class="s2">return new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">e </span><span class="s3">&gt; </span><span class="s4">0 </span><span class="s3">? </span><span class="s1">s </span><span class="s3">/ </span><span class="s4">0 </span><span class="s3">: </span><span class="s4">0</span><span class="s3">);</span>

  <span class="s1">external </span><span class="s3">= </span><span class="s2">false</span><span class="s3">;</span>
  <span class="s1">Ctor</span><span class="s3">.</span><span class="s1">rounding </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">s </span><span class="s3">= </span><span class="s4">1</span><span class="s3">;</span>

  <span class="s0">// Estimate the extra guard digits needed to ensure five correct rounding digits from</span>
  <span class="s0">// naturalLogarithm(x). Example of failure without these extra digits (precision: 10):</span>
  <span class="s0">// new Decimal(2.32456).pow('2087987436534566.46411')</span>
  <span class="s0">// should be 1.162377823e+764914905173815, but is 1.162355823e+764914905173815</span>
  <span class="s1">k </span><span class="s3">= </span><span class="s1">Math</span><span class="s3">.</span><span class="s1">min</span><span class="s3">(</span><span class="s4">12</span><span class="s3">, (</span><span class="s1">e </span><span class="s3">+ </span><span class="s5">''</span><span class="s3">).</span><span class="s1">length</span><span class="s3">);</span>

  <span class="s0">// r = x^y = exp(y*ln(x))</span>
  <span class="s1">r </span><span class="s3">= </span><span class="s1">naturalExponential</span><span class="s3">(</span><span class="s1">y</span><span class="s3">.</span><span class="s1">times</span><span class="s3">(</span><span class="s1">naturalLogarithm</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">pr </span><span class="s3">+ </span><span class="s1">k</span><span class="s3">)), </span><span class="s1">pr</span><span class="s3">);</span>

  <span class="s0">// r may be Infinity, e.g. (0.9999999999999999).pow(-1e+40)</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">r</span><span class="s3">.</span><span class="s1">d</span><span class="s3">) {</span>

    <span class="s0">// Truncate to the required precision plus five rounding digits.</span>
    <span class="s1">r </span><span class="s3">= </span><span class="s1">finalise</span><span class="s3">(</span><span class="s1">r</span><span class="s3">, </span><span class="s1">pr </span><span class="s3">+ </span><span class="s4">5</span><span class="s3">, </span><span class="s4">1</span><span class="s3">);</span>

    <span class="s0">// If the rounding digits are [49]9999 or [50]0000 increase the precision by 10 and recalculate</span>
    <span class="s0">// the result.</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">checkRoundingDigits</span><span class="s3">(</span><span class="s1">r</span><span class="s3">.</span><span class="s1">d</span><span class="s3">, </span><span class="s1">pr</span><span class="s3">, </span><span class="s1">rm</span><span class="s3">)) {</span>
      <span class="s1">e </span><span class="s3">= </span><span class="s1">pr </span><span class="s3">+ </span><span class="s4">10</span><span class="s3">;</span>

      <span class="s0">// Truncate to the increased precision plus five rounding digits.</span>
      <span class="s1">r </span><span class="s3">= </span><span class="s1">finalise</span><span class="s3">(</span><span class="s1">naturalExponential</span><span class="s3">(</span><span class="s1">y</span><span class="s3">.</span><span class="s1">times</span><span class="s3">(</span><span class="s1">naturalLogarithm</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">e </span><span class="s3">+ </span><span class="s1">k</span><span class="s3">)), </span><span class="s1">e</span><span class="s3">), </span><span class="s1">e </span><span class="s3">+ </span><span class="s4">5</span><span class="s3">, </span><span class="s4">1</span><span class="s3">);</span>

      <span class="s0">// Check for 14 nines from the 2nd rounding digit (the first rounding digit may be 4 or 9).</span>
      <span class="s2">if </span><span class="s3">(+</span><span class="s1">digitsToString</span><span class="s3">(</span><span class="s1">r</span><span class="s3">.</span><span class="s1">d</span><span class="s3">).</span><span class="s1">slice</span><span class="s3">(</span><span class="s1">pr </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">, </span><span class="s1">pr </span><span class="s3">+ </span><span class="s4">15</span><span class="s3">) + </span><span class="s4">1 </span><span class="s3">== </span><span class="s4">1e14</span><span class="s3">) {</span>
        <span class="s1">r </span><span class="s3">= </span><span class="s1">finalise</span><span class="s3">(</span><span class="s1">r</span><span class="s3">, </span><span class="s1">pr </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">, </span><span class="s4">0</span><span class="s3">);</span>
      <span class="s3">}</span>
    <span class="s3">}</span>
  <span class="s3">}</span>

  <span class="s1">r</span><span class="s3">.</span><span class="s1">s </span><span class="s3">= </span><span class="s1">s</span><span class="s3">;</span>
  <span class="s1">external </span><span class="s3">= </span><span class="s2">true</span><span class="s3">;</span>
  <span class="s1">Ctor</span><span class="s3">.</span><span class="s1">rounding </span><span class="s3">= </span><span class="s1">rm</span><span class="s3">;</span>

  <span class="s2">return </span><span class="s1">finalise</span><span class="s3">(</span><span class="s1">r</span><span class="s3">, </span><span class="s1">pr</span><span class="s3">, </span><span class="s1">rm</span><span class="s3">);</span>
<span class="s3">};</span>


<span class="s0">/* 
 * Return a string representing the value of this Decimal rounded to `sd` significant digits 
 * using rounding mode `rounding`. 
 * 
 * Return exponential notation if `sd` is less than the number of digits necessary to represent 
 * the integer part of the value in normal notation. 
 * 
 * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive. 
 * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive. 
 * 
 */</span>
<span class="s1">P</span><span class="s3">.</span><span class="s1">toPrecision </span><span class="s3">= </span><span class="s2">function </span><span class="s3">(</span><span class="s1">sd</span><span class="s3">, </span><span class="s1">rm</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">str</span><span class="s3">,</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s2">this</span><span class="s3">,</span>
    <span class="s1">Ctor </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">constructor</span><span class="s3">;</span>

  <span class="s2">if </span><span class="s3">(</span><span class="s1">sd </span><span class="s3">=== </span><span class="s2">void </span><span class="s4">0</span><span class="s3">) {</span>
    <span class="s1">str </span><span class="s3">= </span><span class="s1">finiteToString</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">x</span><span class="s3">.</span><span class="s1">e </span><span class="s3">&lt;= </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">toExpNeg </span><span class="s3">|| </span><span class="s1">x</span><span class="s3">.</span><span class="s1">e </span><span class="s3">&gt;= </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">toExpPos</span><span class="s3">);</span>
  <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
    <span class="s1">checkInt32</span><span class="s3">(</span><span class="s1">sd</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s1">MAX_DIGITS</span><span class="s3">);</span>

    <span class="s2">if </span><span class="s3">(</span><span class="s1">rm </span><span class="s3">=== </span><span class="s2">void </span><span class="s4">0</span><span class="s3">) </span><span class="s1">rm </span><span class="s3">= </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">rounding</span><span class="s3">;</span>
    <span class="s2">else </span><span class="s1">checkInt32</span><span class="s3">(</span><span class="s1">rm</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">8</span><span class="s3">);</span>

    <span class="s1">x </span><span class="s3">= </span><span class="s1">finalise</span><span class="s3">(</span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">x</span><span class="s3">), </span><span class="s1">sd</span><span class="s3">, </span><span class="s1">rm</span><span class="s3">);</span>
    <span class="s1">str </span><span class="s3">= </span><span class="s1">finiteToString</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">sd </span><span class="s3">&lt;= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">e </span><span class="s3">|| </span><span class="s1">x</span><span class="s3">.</span><span class="s1">e </span><span class="s3">&lt;= </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">toExpNeg</span><span class="s3">, </span><span class="s1">sd</span><span class="s3">);</span>
  <span class="s3">}</span>

  <span class="s2">return </span><span class="s1">x</span><span class="s3">.</span><span class="s1">isNeg</span><span class="s3">() &amp;&amp; !</span><span class="s1">x</span><span class="s3">.</span><span class="s1">isZero</span><span class="s3">() ? </span><span class="s5">'-' </span><span class="s3">+ </span><span class="s1">str </span><span class="s3">: </span><span class="s1">str</span><span class="s3">;</span>
<span class="s3">};</span>


<span class="s0">/* 
 * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `sd` 
 * significant digits using rounding mode `rm`, or to `precision` and `rounding` respectively if 
 * omitted. 
 * 
 * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive. 
 * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive. 
 * 
 * 'toSD() digits out of range: {sd}' 
 * 'toSD() digits not an integer: {sd}' 
 * 'toSD() rounding mode not an integer: {rm}' 
 * 'toSD() rounding mode out of range: {rm}' 
 * 
 */</span>
<span class="s1">P</span><span class="s3">.</span><span class="s1">toSignificantDigits </span><span class="s3">= </span><span class="s1">P</span><span class="s3">.</span><span class="s1">toSD </span><span class="s3">= </span><span class="s2">function </span><span class="s3">(</span><span class="s1">sd</span><span class="s3">, </span><span class="s1">rm</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">x </span><span class="s3">= </span><span class="s2">this</span><span class="s3">,</span>
    <span class="s1">Ctor </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">constructor</span><span class="s3">;</span>

  <span class="s2">if </span><span class="s3">(</span><span class="s1">sd </span><span class="s3">=== </span><span class="s2">void </span><span class="s4">0</span><span class="s3">) {</span>
    <span class="s1">sd </span><span class="s3">= </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">precision</span><span class="s3">;</span>
    <span class="s1">rm </span><span class="s3">= </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">rounding</span><span class="s3">;</span>
  <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
    <span class="s1">checkInt32</span><span class="s3">(</span><span class="s1">sd</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s1">MAX_DIGITS</span><span class="s3">);</span>

    <span class="s2">if </span><span class="s3">(</span><span class="s1">rm </span><span class="s3">=== </span><span class="s2">void </span><span class="s4">0</span><span class="s3">) </span><span class="s1">rm </span><span class="s3">= </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">rounding</span><span class="s3">;</span>
    <span class="s2">else </span><span class="s1">checkInt32</span><span class="s3">(</span><span class="s1">rm</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">8</span><span class="s3">);</span>
  <span class="s3">}</span>

  <span class="s2">return </span><span class="s1">finalise</span><span class="s3">(</span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">x</span><span class="s3">), </span><span class="s1">sd</span><span class="s3">, </span><span class="s1">rm</span><span class="s3">);</span>
<span class="s3">};</span>


<span class="s0">/* 
 * Return a string representing the value of this Decimal. 
 * 
 * Return exponential notation if this Decimal has a positive exponent equal to or greater than 
 * `toExpPos`, or a negative exponent equal to or less than `toExpNeg`. 
 * 
 */</span>
<span class="s1">P</span><span class="s3">.</span><span class="s1">toString </span><span class="s3">= </span><span class="s2">function </span><span class="s3">() {</span>
  <span class="s2">var </span><span class="s1">x </span><span class="s3">= </span><span class="s2">this</span><span class="s3">,</span>
    <span class="s1">Ctor </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">constructor</span><span class="s3">,</span>
    <span class="s1">str </span><span class="s3">= </span><span class="s1">finiteToString</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">x</span><span class="s3">.</span><span class="s1">e </span><span class="s3">&lt;= </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">toExpNeg </span><span class="s3">|| </span><span class="s1">x</span><span class="s3">.</span><span class="s1">e </span><span class="s3">&gt;= </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">toExpPos</span><span class="s3">);</span>

  <span class="s2">return </span><span class="s1">x</span><span class="s3">.</span><span class="s1">isNeg</span><span class="s3">() &amp;&amp; !</span><span class="s1">x</span><span class="s3">.</span><span class="s1">isZero</span><span class="s3">() ? </span><span class="s5">'-' </span><span class="s3">+ </span><span class="s1">str </span><span class="s3">: </span><span class="s1">str</span><span class="s3">;</span>
<span class="s3">};</span>


<span class="s0">/* 
 * Return a new Decimal whose value is the value of this Decimal truncated to a whole number. 
 * 
 */</span>
<span class="s1">P</span><span class="s3">.</span><span class="s1">truncated </span><span class="s3">= </span><span class="s1">P</span><span class="s3">.</span><span class="s1">trunc </span><span class="s3">= </span><span class="s2">function </span><span class="s3">() {</span>
  <span class="s2">return </span><span class="s1">finalise</span><span class="s3">(</span><span class="s2">new this</span><span class="s3">.</span><span class="s1">constructor</span><span class="s3">(</span><span class="s2">this</span><span class="s3">), </span><span class="s2">this</span><span class="s3">.</span><span class="s1">e </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">);</span>
<span class="s3">};</span>


<span class="s0">/* 
 * Return a string representing the value of this Decimal. 
 * Unlike `toString`, negative zero will include the minus sign. 
 * 
 */</span>
<span class="s1">P</span><span class="s3">.</span><span class="s1">valueOf </span><span class="s3">= </span><span class="s1">P</span><span class="s3">.</span><span class="s1">toJSON </span><span class="s3">= </span><span class="s2">function </span><span class="s3">() {</span>
  <span class="s2">var </span><span class="s1">x </span><span class="s3">= </span><span class="s2">this</span><span class="s3">,</span>
    <span class="s1">Ctor </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">constructor</span><span class="s3">,</span>
    <span class="s1">str </span><span class="s3">= </span><span class="s1">finiteToString</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">x</span><span class="s3">.</span><span class="s1">e </span><span class="s3">&lt;= </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">toExpNeg </span><span class="s3">|| </span><span class="s1">x</span><span class="s3">.</span><span class="s1">e </span><span class="s3">&gt;= </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">toExpPos</span><span class="s3">);</span>

  <span class="s2">return </span><span class="s1">x</span><span class="s3">.</span><span class="s1">isNeg</span><span class="s3">() ? </span><span class="s5">'-' </span><span class="s3">+ </span><span class="s1">str </span><span class="s3">: </span><span class="s1">str</span><span class="s3">;</span>
<span class="s3">};</span>


<span class="s0">// Helper functions for Decimal.prototype (P) and/or Decimal methods, and their callers.</span>


<span class="s0">/* 
 *  digitsToString           P.cubeRoot, P.logarithm, P.squareRoot, P.toFraction, P.toPower, 
 *                           finiteToString, naturalExponential, naturalLogarithm 
 *  checkInt32               P.toDecimalPlaces, P.toExponential, P.toFixed, P.toNearest, 
 *                           P.toPrecision, P.toSignificantDigits, toStringBinary, random 
 *  checkRoundingDigits      P.logarithm, P.toPower, naturalExponential, naturalLogarithm 
 *  convertBase              toStringBinary, parseOther 
 *  cos                      P.cos 
 *  divide                   P.atanh, P.cubeRoot, P.dividedBy, P.dividedToIntegerBy, 
 *                           P.logarithm, P.modulo, P.squareRoot, P.tan, P.tanh, P.toFraction, 
 *                           P.toNearest, toStringBinary, naturalExponential, naturalLogarithm, 
 *                           taylorSeries, atan2, parseOther 
 *  finalise                 P.absoluteValue, P.atan, P.atanh, P.ceil, P.cos, P.cosh, 
 *                           P.cubeRoot, P.dividedToIntegerBy, P.floor, P.logarithm, P.minus, 
 *                           P.modulo, P.negated, P.plus, P.round, P.sin, P.sinh, P.squareRoot, 
 *                           P.tan, P.times, P.toDecimalPlaces, P.toExponential, P.toFixed, 
 *                           P.toNearest, P.toPower, P.toPrecision, P.toSignificantDigits, 
 *                           P.truncated, divide, getLn10, getPi, naturalExponential, 
 *                           naturalLogarithm, ceil, floor, round, trunc 
 *  finiteToString           P.toExponential, P.toFixed, P.toPrecision, P.toString, P.valueOf, 
 *                           toStringBinary 
 *  getBase10Exponent        P.minus, P.plus, P.times, parseOther 
 *  getLn10                  P.logarithm, naturalLogarithm 
 *  getPi                    P.acos, P.asin, P.atan, toLessThanHalfPi, atan2 
 *  getPrecision             P.precision, P.toFraction 
 *  getZeroString            digitsToString, finiteToString 
 *  intPow                   P.toPower, parseOther 
 *  isOdd                    toLessThanHalfPi 
 *  maxOrMin                 max, min 
 *  naturalExponential       P.naturalExponential, P.toPower 
 *  naturalLogarithm         P.acosh, P.asinh, P.atanh, P.logarithm, P.naturalLogarithm, 
 *                           P.toPower, naturalExponential 
 *  nonFiniteToString        finiteToString, toStringBinary 
 *  parseDecimal             Decimal 
 *  parseOther               Decimal 
 *  sin                      P.sin 
 *  taylorSeries             P.cosh, P.sinh, cos, sin 
 *  toLessThanHalfPi         P.cos, P.sin 
 *  toStringBinary           P.toBinary, P.toHexadecimal, P.toOctal 
 *  truncate                 intPow 
 * 
 *  Throws:                  P.logarithm, P.precision, P.toFraction, checkInt32, getLn10, getPi, 
 *                           naturalLogarithm, config, parseOther, random, Decimal 
 */</span>


<span class="s2">function </span><span class="s1">digitsToString</span><span class="s3">(</span><span class="s1">d</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">i</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">ws</span><span class="s3">,</span>
    <span class="s1">indexOfLastWord </span><span class="s3">= </span><span class="s1">d</span><span class="s3">.</span><span class="s1">length </span><span class="s3">- </span><span class="s4">1</span><span class="s3">,</span>
    <span class="s1">str </span><span class="s3">= </span><span class="s5">''</span><span class="s3">,</span>
    <span class="s1">w </span><span class="s3">= </span><span class="s1">d</span><span class="s3">[</span><span class="s4">0</span><span class="s3">];</span>

  <span class="s2">if </span><span class="s3">(</span><span class="s1">indexOfLastWord </span><span class="s3">&gt; </span><span class="s4">0</span><span class="s3">) {</span>
    <span class="s1">str </span><span class="s3">+= </span><span class="s1">w</span><span class="s3">;</span>
    <span class="s2">for </span><span class="s3">(</span><span class="s1">i </span><span class="s3">= </span><span class="s4">1</span><span class="s3">; </span><span class="s1">i </span><span class="s3">&lt; </span><span class="s1">indexOfLastWord</span><span class="s3">; </span><span class="s1">i</span><span class="s3">++) {</span>
      <span class="s1">ws </span><span class="s3">= </span><span class="s1">d</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] + </span><span class="s5">''</span><span class="s3">;</span>
      <span class="s1">k </span><span class="s3">= </span><span class="s1">LOG_BASE </span><span class="s3">- </span><span class="s1">ws</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span>
      <span class="s2">if </span><span class="s3">(</span><span class="s1">k</span><span class="s3">) </span><span class="s1">str </span><span class="s3">+= </span><span class="s1">getZeroString</span><span class="s3">(</span><span class="s1">k</span><span class="s3">);</span>
      <span class="s1">str </span><span class="s3">+= </span><span class="s1">ws</span><span class="s3">;</span>
    <span class="s3">}</span>

    <span class="s1">w </span><span class="s3">= </span><span class="s1">d</span><span class="s3">[</span><span class="s1">i</span><span class="s3">];</span>
    <span class="s1">ws </span><span class="s3">= </span><span class="s1">w </span><span class="s3">+ </span><span class="s5">''</span><span class="s3">;</span>
    <span class="s1">k </span><span class="s3">= </span><span class="s1">LOG_BASE </span><span class="s3">- </span><span class="s1">ws</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">k</span><span class="s3">) </span><span class="s1">str </span><span class="s3">+= </span><span class="s1">getZeroString</span><span class="s3">(</span><span class="s1">k</span><span class="s3">);</span>
  <span class="s3">} </span><span class="s2">else if </span><span class="s3">(</span><span class="s1">w </span><span class="s3">=== </span><span class="s4">0</span><span class="s3">) {</span>
    <span class="s2">return </span><span class="s5">'0'</span><span class="s3">;</span>
  <span class="s3">}</span>

  <span class="s0">// Remove trailing zeros of last w.</span>
  <span class="s2">for </span><span class="s3">(; </span><span class="s1">w </span><span class="s3">% </span><span class="s4">10 </span><span class="s3">=== </span><span class="s4">0</span><span class="s3">;) </span><span class="s1">w </span><span class="s3">/= </span><span class="s4">10</span><span class="s3">;</span>

  <span class="s2">return </span><span class="s1">str </span><span class="s3">+ </span><span class="s1">w</span><span class="s3">;</span>
<span class="s3">}</span>


<span class="s2">function </span><span class="s1">checkInt32</span><span class="s3">(</span><span class="s1">i</span><span class="s3">, </span><span class="s1">min</span><span class="s3">, </span><span class="s1">max</span><span class="s3">) {</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">i </span><span class="s3">!== ~~</span><span class="s1">i </span><span class="s3">|| </span><span class="s1">i </span><span class="s3">&lt; </span><span class="s1">min </span><span class="s3">|| </span><span class="s1">i </span><span class="s3">&gt; </span><span class="s1">max</span><span class="s3">) {</span>
    <span class="s2">throw </span><span class="s1">Error</span><span class="s3">(</span><span class="s1">invalidArgument </span><span class="s3">+ </span><span class="s1">i</span><span class="s3">);</span>
  <span class="s3">}</span>
<span class="s3">}</span>


<span class="s0">/* 
 * Check 5 rounding digits if `repeating` is null, 4 otherwise. 
 * `repeating == null` if caller is `log` or `pow`, 
 * `repeating != null` if caller is `naturalLogarithm` or `naturalExponential`. 
 */</span>
<span class="s2">function </span><span class="s1">checkRoundingDigits</span><span class="s3">(</span><span class="s1">d</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">rm</span><span class="s3">, </span><span class="s1">repeating</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">di</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">r</span><span class="s3">, </span><span class="s1">rd</span><span class="s3">;</span>

  <span class="s0">// Get the length of the first word of the array d.</span>
  <span class="s2">for </span><span class="s3">(</span><span class="s1">k </span><span class="s3">= </span><span class="s1">d</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]; </span><span class="s1">k </span><span class="s3">&gt;= </span><span class="s4">10</span><span class="s3">; </span><span class="s1">k </span><span class="s3">/= </span><span class="s4">10</span><span class="s3">) --</span><span class="s1">i</span><span class="s3">;</span>

  <span class="s0">// Is the rounding digit in the first word of d?</span>
  <span class="s2">if </span><span class="s3">(--</span><span class="s1">i </span><span class="s3">&lt; </span><span class="s4">0</span><span class="s3">) {</span>
    <span class="s1">i </span><span class="s3">+= </span><span class="s1">LOG_BASE</span><span class="s3">;</span>
    <span class="s1">di </span><span class="s3">= </span><span class="s4">0</span><span class="s3">;</span>
  <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
    <span class="s1">di </span><span class="s3">= </span><span class="s1">Math</span><span class="s3">.</span><span class="s1">ceil</span><span class="s3">((</span><span class="s1">i </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">) / </span><span class="s1">LOG_BASE</span><span class="s3">);</span>
    <span class="s1">i </span><span class="s3">%= </span><span class="s1">LOG_BASE</span><span class="s3">;</span>
  <span class="s3">}</span>

  <span class="s0">// i is the index (0 - 6) of the rounding digit.</span>
  <span class="s0">// E.g. if within the word 3487563 the first rounding digit is 5,</span>
  <span class="s0">// then i = 4, k = 1000, rd = 3487563 % 1000 = 563</span>
  <span class="s1">k </span><span class="s3">= </span><span class="s1">mathpow</span><span class="s3">(</span><span class="s4">10</span><span class="s3">, </span><span class="s1">LOG_BASE </span><span class="s3">- </span><span class="s1">i</span><span class="s3">);</span>
  <span class="s1">rd </span><span class="s3">= </span><span class="s1">d</span><span class="s3">[</span><span class="s1">di</span><span class="s3">] % </span><span class="s1">k </span><span class="s3">| </span><span class="s4">0</span><span class="s3">;</span>

  <span class="s2">if </span><span class="s3">(</span><span class="s1">repeating </span><span class="s3">== </span><span class="s2">null</span><span class="s3">) {</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">i </span><span class="s3">&lt; </span><span class="s4">3</span><span class="s3">) {</span>
      <span class="s2">if </span><span class="s3">(</span><span class="s1">i </span><span class="s3">== </span><span class="s4">0</span><span class="s3">) </span><span class="s1">rd </span><span class="s3">= </span><span class="s1">rd </span><span class="s3">/ </span><span class="s4">100 </span><span class="s3">| </span><span class="s4">0</span><span class="s3">;</span>
      <span class="s2">else if </span><span class="s3">(</span><span class="s1">i </span><span class="s3">== </span><span class="s4">1</span><span class="s3">) </span><span class="s1">rd </span><span class="s3">= </span><span class="s1">rd </span><span class="s3">/ </span><span class="s4">10 </span><span class="s3">| </span><span class="s4">0</span><span class="s3">;</span>
      <span class="s1">r </span><span class="s3">= </span><span class="s1">rm </span><span class="s3">&lt; </span><span class="s4">4 </span><span class="s3">&amp;&amp; </span><span class="s1">rd </span><span class="s3">== </span><span class="s4">99999 </span><span class="s3">|| </span><span class="s1">rm </span><span class="s3">&gt; </span><span class="s4">3 </span><span class="s3">&amp;&amp; </span><span class="s1">rd </span><span class="s3">== </span><span class="s4">49999 </span><span class="s3">|| </span><span class="s1">rd </span><span class="s3">== </span><span class="s4">50000 </span><span class="s3">|| </span><span class="s1">rd </span><span class="s3">== </span><span class="s4">0</span><span class="s3">;</span>
    <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
      <span class="s1">r </span><span class="s3">= (</span><span class="s1">rm </span><span class="s3">&lt; </span><span class="s4">4 </span><span class="s3">&amp;&amp; </span><span class="s1">rd </span><span class="s3">+ </span><span class="s4">1 </span><span class="s3">== </span><span class="s1">k </span><span class="s3">|| </span><span class="s1">rm </span><span class="s3">&gt; </span><span class="s4">3 </span><span class="s3">&amp;&amp; </span><span class="s1">rd </span><span class="s3">+ </span><span class="s4">1 </span><span class="s3">== </span><span class="s1">k </span><span class="s3">/ </span><span class="s4">2</span><span class="s3">) &amp;&amp;</span>
        <span class="s3">(</span><span class="s1">d</span><span class="s3">[</span><span class="s1">di </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">] / </span><span class="s1">k </span><span class="s3">/ </span><span class="s4">100 </span><span class="s3">| </span><span class="s4">0</span><span class="s3">) == </span><span class="s1">mathpow</span><span class="s3">(</span><span class="s4">10</span><span class="s3">, </span><span class="s1">i </span><span class="s3">- </span><span class="s4">2</span><span class="s3">) - </span><span class="s4">1 </span><span class="s3">||</span>
          <span class="s3">(</span><span class="s1">rd </span><span class="s3">== </span><span class="s1">k </span><span class="s3">/ </span><span class="s4">2 </span><span class="s3">|| </span><span class="s1">rd </span><span class="s3">== </span><span class="s4">0</span><span class="s3">) &amp;&amp; (</span><span class="s1">d</span><span class="s3">[</span><span class="s1">di </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">] / </span><span class="s1">k </span><span class="s3">/ </span><span class="s4">100 </span><span class="s3">| </span><span class="s4">0</span><span class="s3">) == </span><span class="s4">0</span><span class="s3">;</span>
    <span class="s3">}</span>
  <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">i </span><span class="s3">&lt; </span><span class="s4">4</span><span class="s3">) {</span>
      <span class="s2">if </span><span class="s3">(</span><span class="s1">i </span><span class="s3">== </span><span class="s4">0</span><span class="s3">) </span><span class="s1">rd </span><span class="s3">= </span><span class="s1">rd </span><span class="s3">/ </span><span class="s4">1000 </span><span class="s3">| </span><span class="s4">0</span><span class="s3">;</span>
      <span class="s2">else if </span><span class="s3">(</span><span class="s1">i </span><span class="s3">== </span><span class="s4">1</span><span class="s3">) </span><span class="s1">rd </span><span class="s3">= </span><span class="s1">rd </span><span class="s3">/ </span><span class="s4">100 </span><span class="s3">| </span><span class="s4">0</span><span class="s3">;</span>
      <span class="s2">else if </span><span class="s3">(</span><span class="s1">i </span><span class="s3">== </span><span class="s4">2</span><span class="s3">) </span><span class="s1">rd </span><span class="s3">= </span><span class="s1">rd </span><span class="s3">/ </span><span class="s4">10 </span><span class="s3">| </span><span class="s4">0</span><span class="s3">;</span>
      <span class="s1">r </span><span class="s3">= (</span><span class="s1">repeating </span><span class="s3">|| </span><span class="s1">rm </span><span class="s3">&lt; </span><span class="s4">4</span><span class="s3">) &amp;&amp; </span><span class="s1">rd </span><span class="s3">== </span><span class="s4">9999 </span><span class="s3">|| !</span><span class="s1">repeating </span><span class="s3">&amp;&amp; </span><span class="s1">rm </span><span class="s3">&gt; </span><span class="s4">3 </span><span class="s3">&amp;&amp; </span><span class="s1">rd </span><span class="s3">== </span><span class="s4">4999</span><span class="s3">;</span>
    <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
      <span class="s1">r </span><span class="s3">= ((</span><span class="s1">repeating </span><span class="s3">|| </span><span class="s1">rm </span><span class="s3">&lt; </span><span class="s4">4</span><span class="s3">) &amp;&amp; </span><span class="s1">rd </span><span class="s3">+ </span><span class="s4">1 </span><span class="s3">== </span><span class="s1">k </span><span class="s3">||</span>
      <span class="s3">(!</span><span class="s1">repeating </span><span class="s3">&amp;&amp; </span><span class="s1">rm </span><span class="s3">&gt; </span><span class="s4">3</span><span class="s3">) &amp;&amp; </span><span class="s1">rd </span><span class="s3">+ </span><span class="s4">1 </span><span class="s3">== </span><span class="s1">k </span><span class="s3">/ </span><span class="s4">2</span><span class="s3">) &amp;&amp;</span>
        <span class="s3">(</span><span class="s1">d</span><span class="s3">[</span><span class="s1">di </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">] / </span><span class="s1">k </span><span class="s3">/ </span><span class="s4">1000 </span><span class="s3">| </span><span class="s4">0</span><span class="s3">) == </span><span class="s1">mathpow</span><span class="s3">(</span><span class="s4">10</span><span class="s3">, </span><span class="s1">i </span><span class="s3">- </span><span class="s4">3</span><span class="s3">) - </span><span class="s4">1</span><span class="s3">;</span>
    <span class="s3">}</span>
  <span class="s3">}</span>

  <span class="s2">return </span><span class="s1">r</span><span class="s3">;</span>
<span class="s3">}</span>


<span class="s0">// Convert string of `baseIn` to an array of numbers of `baseOut`.</span>
<span class="s0">// Eg. convertBase('255', 10, 16) returns [15, 15].</span>
<span class="s0">// Eg. convertBase('ff', 16, 10) returns [2, 5, 5].</span>
<span class="s2">function </span><span class="s1">convertBase</span><span class="s3">(</span><span class="s1">str</span><span class="s3">, </span><span class="s1">baseIn</span><span class="s3">, </span><span class="s1">baseOut</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">j</span><span class="s3">,</span>
    <span class="s1">arr </span><span class="s3">= [</span><span class="s4">0</span><span class="s3">],</span>
    <span class="s1">arrL</span><span class="s3">,</span>
    <span class="s1">i </span><span class="s3">= </span><span class="s4">0</span><span class="s3">,</span>
    <span class="s1">strL </span><span class="s3">= </span><span class="s1">str</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span>

  <span class="s2">for </span><span class="s3">(; </span><span class="s1">i </span><span class="s3">&lt; </span><span class="s1">strL</span><span class="s3">;) {</span>
    <span class="s2">for </span><span class="s3">(</span><span class="s1">arrL </span><span class="s3">= </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">length</span><span class="s3">; </span><span class="s1">arrL</span><span class="s3">--;) </span><span class="s1">arr</span><span class="s3">[</span><span class="s1">arrL</span><span class="s3">] *= </span><span class="s1">baseIn</span><span class="s3">;</span>
    <span class="s1">arr</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] += </span><span class="s1">NUMERALS</span><span class="s3">.</span><span class="s1">indexOf</span><span class="s3">(</span><span class="s1">str</span><span class="s3">.</span><span class="s1">charAt</span><span class="s3">(</span><span class="s1">i</span><span class="s3">++));</span>
    <span class="s2">for </span><span class="s3">(</span><span class="s1">j </span><span class="s3">= </span><span class="s4">0</span><span class="s3">; </span><span class="s1">j </span><span class="s3">&lt; </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">length</span><span class="s3">; </span><span class="s1">j</span><span class="s3">++) {</span>
      <span class="s2">if </span><span class="s3">(</span><span class="s1">arr</span><span class="s3">[</span><span class="s1">j</span><span class="s3">] &gt; </span><span class="s1">baseOut </span><span class="s3">- </span><span class="s4">1</span><span class="s3">) {</span>
        <span class="s2">if </span><span class="s3">(</span><span class="s1">arr</span><span class="s3">[</span><span class="s1">j </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">] === </span><span class="s2">void </span><span class="s4">0</span><span class="s3">) </span><span class="s1">arr</span><span class="s3">[</span><span class="s1">j </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">] = </span><span class="s4">0</span><span class="s3">;</span>
        <span class="s1">arr</span><span class="s3">[</span><span class="s1">j </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">] += </span><span class="s1">arr</span><span class="s3">[</span><span class="s1">j</span><span class="s3">] / </span><span class="s1">baseOut </span><span class="s3">| </span><span class="s4">0</span><span class="s3">;</span>
        <span class="s1">arr</span><span class="s3">[</span><span class="s1">j</span><span class="s3">] %= </span><span class="s1">baseOut</span><span class="s3">;</span>
      <span class="s3">}</span>
    <span class="s3">}</span>
  <span class="s3">}</span>

  <span class="s2">return </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">reverse</span><span class="s3">();</span>
<span class="s3">}</span>


<span class="s0">/* 
 * cos(x) = 1 - x^2/2! + x^4/4! - ... 
 * |x| &lt; pi/2 
 * 
 */</span>
<span class="s2">function </span><span class="s1">cosine</span><span class="s3">(</span><span class="s1">Ctor</span><span class="s3">, </span><span class="s1">x</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">k</span><span class="s3">, </span><span class="s1">len</span><span class="s3">, </span><span class="s1">y</span><span class="s3">;</span>

  <span class="s2">if </span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">isZero</span><span class="s3">()) </span><span class="s2">return </span><span class="s1">x</span><span class="s3">;</span>

  <span class="s0">// Argument reduction: cos(4x) = 8*(cos^4(x) - cos^2(x)) + 1</span>
  <span class="s0">// i.e. cos(x) = 8*(cos^4(x/4) - cos^2(x/4)) + 1</span>

  <span class="s0">// Estimate the optimum number of times to use the argument reduction.</span>
  <span class="s1">len </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">d</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">len </span><span class="s3">&lt; </span><span class="s4">32</span><span class="s3">) {</span>
    <span class="s1">k </span><span class="s3">= </span><span class="s1">Math</span><span class="s3">.</span><span class="s1">ceil</span><span class="s3">(</span><span class="s1">len </span><span class="s3">/ </span><span class="s4">3</span><span class="s3">);</span>
    <span class="s1">y </span><span class="s3">= (</span><span class="s4">1 </span><span class="s3">/ </span><span class="s1">tinyPow</span><span class="s3">(</span><span class="s4">4</span><span class="s3">, </span><span class="s1">k</span><span class="s3">)).</span><span class="s1">toString</span><span class="s3">();</span>
  <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
    <span class="s1">k </span><span class="s3">= </span><span class="s4">16</span><span class="s3">;</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s5">'2.3283064365386962890625e-10'</span><span class="s3">;</span>
  <span class="s3">}</span>

  <span class="s1">Ctor</span><span class="s3">.</span><span class="s1">precision </span><span class="s3">+= </span><span class="s1">k</span><span class="s3">;</span>

  <span class="s1">x </span><span class="s3">= </span><span class="s1">taylorSeries</span><span class="s3">(</span><span class="s1">Ctor</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s1">x</span><span class="s3">.</span><span class="s1">times</span><span class="s3">(</span><span class="s1">y</span><span class="s3">), </span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s4">1</span><span class="s3">));</span>

  <span class="s0">// Reverse argument reduction</span>
  <span class="s2">for </span><span class="s3">(</span><span class="s2">var </span><span class="s1">i </span><span class="s3">= </span><span class="s1">k</span><span class="s3">; </span><span class="s1">i</span><span class="s3">--;) {</span>
    <span class="s2">var </span><span class="s1">cos2x </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">times</span><span class="s3">(</span><span class="s1">x</span><span class="s3">);</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s1">cos2x</span><span class="s3">.</span><span class="s1">times</span><span class="s3">(</span><span class="s1">cos2x</span><span class="s3">).</span><span class="s1">minus</span><span class="s3">(</span><span class="s1">cos2x</span><span class="s3">).</span><span class="s1">times</span><span class="s3">(</span><span class="s4">8</span><span class="s3">).</span><span class="s1">plus</span><span class="s3">(</span><span class="s4">1</span><span class="s3">);</span>
  <span class="s3">}</span>

  <span class="s1">Ctor</span><span class="s3">.</span><span class="s1">precision </span><span class="s3">-= </span><span class="s1">k</span><span class="s3">;</span>

  <span class="s2">return </span><span class="s1">x</span><span class="s3">;</span>
<span class="s3">}</span>


<span class="s0">/* 
 * Perform division in the specified base. 
 */</span>
<span class="s2">var </span><span class="s1">divide </span><span class="s3">= (</span><span class="s2">function </span><span class="s3">() {</span>

  <span class="s0">// Assumes non-zero x and k, and hence non-zero result.</span>
  <span class="s2">function </span><span class="s1">multiplyInteger</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">base</span><span class="s3">) {</span>
    <span class="s2">var </span><span class="s1">temp</span><span class="s3">,</span>
      <span class="s1">carry </span><span class="s3">= </span><span class="s4">0</span><span class="s3">,</span>
      <span class="s1">i </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span>

    <span class="s2">for </span><span class="s3">(</span><span class="s1">x </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(); </span><span class="s1">i</span><span class="s3">--;) {</span>
      <span class="s1">temp </span><span class="s3">= </span><span class="s1">x</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] * </span><span class="s1">k </span><span class="s3">+ </span><span class="s1">carry</span><span class="s3">;</span>
      <span class="s1">x</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">temp </span><span class="s3">% </span><span class="s1">base </span><span class="s3">| </span><span class="s4">0</span><span class="s3">;</span>
      <span class="s1">carry </span><span class="s3">= </span><span class="s1">temp </span><span class="s3">/ </span><span class="s1">base </span><span class="s3">| </span><span class="s4">0</span><span class="s3">;</span>
    <span class="s3">}</span>

    <span class="s2">if </span><span class="s3">(</span><span class="s1">carry</span><span class="s3">) </span><span class="s1">x</span><span class="s3">.</span><span class="s1">unshift</span><span class="s3">(</span><span class="s1">carry</span><span class="s3">);</span>

    <span class="s2">return </span><span class="s1">x</span><span class="s3">;</span>
  <span class="s3">}</span>

  <span class="s2">function </span><span class="s1">compare</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">aL</span><span class="s3">, </span><span class="s1">bL</span><span class="s3">) {</span>
    <span class="s2">var </span><span class="s1">i</span><span class="s3">, </span><span class="s1">r</span><span class="s3">;</span>

    <span class="s2">if </span><span class="s3">(</span><span class="s1">aL </span><span class="s3">!= </span><span class="s1">bL</span><span class="s3">) {</span>
      <span class="s1">r </span><span class="s3">= </span><span class="s1">aL </span><span class="s3">&gt; </span><span class="s1">bL </span><span class="s3">? </span><span class="s4">1 </span><span class="s3">: -</span><span class="s4">1</span><span class="s3">;</span>
    <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
      <span class="s2">for </span><span class="s3">(</span><span class="s1">i </span><span class="s3">= </span><span class="s1">r </span><span class="s3">= </span><span class="s4">0</span><span class="s3">; </span><span class="s1">i </span><span class="s3">&lt; </span><span class="s1">aL</span><span class="s3">; </span><span class="s1">i</span><span class="s3">++) {</span>
        <span class="s2">if </span><span class="s3">(</span><span class="s1">a</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] != </span><span class="s1">b</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]) {</span>
          <span class="s1">r </span><span class="s3">= </span><span class="s1">a</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] &gt; </span><span class="s1">b</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] ? </span><span class="s4">1 </span><span class="s3">: -</span><span class="s4">1</span><span class="s3">;</span>
          <span class="s2">break</span><span class="s3">;</span>
        <span class="s3">}</span>
      <span class="s3">}</span>
    <span class="s3">}</span>

    <span class="s2">return </span><span class="s1">r</span><span class="s3">;</span>
  <span class="s3">}</span>

  <span class="s2">function </span><span class="s1">subtract</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">aL</span><span class="s3">, </span><span class="s1">base</span><span class="s3">) {</span>
    <span class="s2">var </span><span class="s1">i </span><span class="s3">= </span><span class="s4">0</span><span class="s3">;</span>

    <span class="s0">// Subtract b from a.</span>
    <span class="s2">for </span><span class="s3">(; </span><span class="s1">aL</span><span class="s3">--;) {</span>
      <span class="s1">a</span><span class="s3">[</span><span class="s1">aL</span><span class="s3">] -= </span><span class="s1">i</span><span class="s3">;</span>
      <span class="s1">i </span><span class="s3">= </span><span class="s1">a</span><span class="s3">[</span><span class="s1">aL</span><span class="s3">] &lt; </span><span class="s1">b</span><span class="s3">[</span><span class="s1">aL</span><span class="s3">] ? </span><span class="s4">1 </span><span class="s3">: </span><span class="s4">0</span><span class="s3">;</span>
      <span class="s1">a</span><span class="s3">[</span><span class="s1">aL</span><span class="s3">] = </span><span class="s1">i </span><span class="s3">* </span><span class="s1">base </span><span class="s3">+ </span><span class="s1">a</span><span class="s3">[</span><span class="s1">aL</span><span class="s3">] - </span><span class="s1">b</span><span class="s3">[</span><span class="s1">aL</span><span class="s3">];</span>
    <span class="s3">}</span>

    <span class="s0">// Remove leading zeros.</span>
    <span class="s2">for </span><span class="s3">(; !</span><span class="s1">a</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] &amp;&amp; </span><span class="s1">a</span><span class="s3">.</span><span class="s1">length </span><span class="s3">&gt; </span><span class="s4">1</span><span class="s3">;) </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shift</span><span class="s3">();</span>
  <span class="s3">}</span>

  <span class="s2">return function </span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">pr</span><span class="s3">, </span><span class="s1">rm</span><span class="s3">, </span><span class="s1">dp</span><span class="s3">, </span><span class="s1">base</span><span class="s3">) {</span>
    <span class="s2">var </span><span class="s1">cmp</span><span class="s3">, </span><span class="s1">e</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">logBase</span><span class="s3">, </span><span class="s1">more</span><span class="s3">, </span><span class="s1">prod</span><span class="s3">, </span><span class="s1">prodL</span><span class="s3">, </span><span class="s1">q</span><span class="s3">, </span><span class="s1">qd</span><span class="s3">, </span><span class="s1">rem</span><span class="s3">, </span><span class="s1">remL</span><span class="s3">, </span><span class="s1">rem0</span><span class="s3">, </span><span class="s1">sd</span><span class="s3">, </span><span class="s1">t</span><span class="s3">, </span><span class="s1">xi</span><span class="s3">, </span><span class="s1">xL</span><span class="s3">, </span><span class="s1">yd0</span><span class="s3">,</span>
      <span class="s1">yL</span><span class="s3">, </span><span class="s1">yz</span><span class="s3">,</span>
      <span class="s1">Ctor </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">constructor</span><span class="s3">,</span>
      <span class="s1">sign </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">s </span><span class="s3">== </span><span class="s1">y</span><span class="s3">.</span><span class="s1">s </span><span class="s3">? </span><span class="s4">1 </span><span class="s3">: -</span><span class="s4">1</span><span class="s3">,</span>
      <span class="s1">xd </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">d</span><span class="s3">,</span>
      <span class="s1">yd </span><span class="s3">= </span><span class="s1">y</span><span class="s3">.</span><span class="s1">d</span><span class="s3">;</span>

    <span class="s0">// Either NaN, Infinity or 0?</span>
    <span class="s2">if </span><span class="s3">(!</span><span class="s1">xd </span><span class="s3">|| !</span><span class="s1">xd</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] || !</span><span class="s1">yd </span><span class="s3">|| !</span><span class="s1">yd</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]) {</span>

      <span class="s2">return new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s0">// Return NaN if either NaN, or both Infinity or 0.</span>
        <span class="s3">!</span><span class="s1">x</span><span class="s3">.</span><span class="s1">s </span><span class="s3">|| !</span><span class="s1">y</span><span class="s3">.</span><span class="s1">s </span><span class="s3">|| (</span><span class="s1">xd </span><span class="s3">? </span><span class="s1">yd </span><span class="s3">&amp;&amp; </span><span class="s1">xd</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] == </span><span class="s1">yd</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] : !</span><span class="s1">yd</span><span class="s3">) ? </span><span class="s1">NaN </span><span class="s3">:</span>

        <span class="s0">// Return Â±0 if x is 0 or y is Â±Infinity, or return Â±Infinity as y is 0.</span>
        <span class="s1">xd </span><span class="s3">&amp;&amp; </span><span class="s1">xd</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] == </span><span class="s4">0 </span><span class="s3">|| !</span><span class="s1">yd </span><span class="s3">? </span><span class="s1">sign </span><span class="s3">* </span><span class="s4">0 </span><span class="s3">: </span><span class="s1">sign </span><span class="s3">/ </span><span class="s4">0</span><span class="s3">);</span>
    <span class="s3">}</span>

    <span class="s2">if </span><span class="s3">(</span><span class="s1">base</span><span class="s3">) {</span>
      <span class="s1">logBase </span><span class="s3">= </span><span class="s4">1</span><span class="s3">;</span>
      <span class="s1">e </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">e </span><span class="s3">- </span><span class="s1">y</span><span class="s3">.</span><span class="s1">e</span><span class="s3">;</span>
    <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
      <span class="s1">base </span><span class="s3">= </span><span class="s1">BASE</span><span class="s3">;</span>
      <span class="s1">logBase </span><span class="s3">= </span><span class="s1">LOG_BASE</span><span class="s3">;</span>
      <span class="s1">e </span><span class="s3">= </span><span class="s1">mathfloor</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">e </span><span class="s3">/ </span><span class="s1">logBase</span><span class="s3">) - </span><span class="s1">mathfloor</span><span class="s3">(</span><span class="s1">y</span><span class="s3">.</span><span class="s1">e </span><span class="s3">/ </span><span class="s1">logBase</span><span class="s3">);</span>
    <span class="s3">}</span>

    <span class="s1">yL </span><span class="s3">= </span><span class="s1">yd</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span>
    <span class="s1">xL </span><span class="s3">= </span><span class="s1">xd</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span>
    <span class="s1">q </span><span class="s3">= </span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">sign</span><span class="s3">);</span>
    <span class="s1">qd </span><span class="s3">= </span><span class="s1">q</span><span class="s3">.</span><span class="s1">d </span><span class="s3">= [];</span>

    <span class="s0">// Result exponent may be one less than e.</span>
    <span class="s0">// The digit array of a Decimal from toStringBinary may have trailing zeros.</span>
    <span class="s2">for </span><span class="s3">(</span><span class="s1">i </span><span class="s3">= </span><span class="s4">0</span><span class="s3">; </span><span class="s1">yd</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] == (</span><span class="s1">xd</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] || </span><span class="s4">0</span><span class="s3">); </span><span class="s1">i</span><span class="s3">++);</span>

    <span class="s2">if </span><span class="s3">(</span><span class="s1">yd</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] &gt; (</span><span class="s1">xd</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] || </span><span class="s4">0</span><span class="s3">)) </span><span class="s1">e</span><span class="s3">--;</span>

    <span class="s2">if </span><span class="s3">(</span><span class="s1">pr </span><span class="s3">== </span><span class="s2">null</span><span class="s3">) {</span>
      <span class="s1">sd </span><span class="s3">= </span><span class="s1">pr </span><span class="s3">= </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">precision</span><span class="s3">;</span>
      <span class="s1">rm </span><span class="s3">= </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">rounding</span><span class="s3">;</span>
    <span class="s3">} </span><span class="s2">else if </span><span class="s3">(</span><span class="s1">dp</span><span class="s3">) {</span>
      <span class="s1">sd </span><span class="s3">= </span><span class="s1">pr </span><span class="s3">+ (</span><span class="s1">x</span><span class="s3">.</span><span class="s1">e </span><span class="s3">- </span><span class="s1">y</span><span class="s3">.</span><span class="s1">e</span><span class="s3">) + </span><span class="s4">1</span><span class="s3">;</span>
    <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
      <span class="s1">sd </span><span class="s3">= </span><span class="s1">pr</span><span class="s3">;</span>
    <span class="s3">}</span>

    <span class="s2">if </span><span class="s3">(</span><span class="s1">sd </span><span class="s3">&lt; </span><span class="s4">0</span><span class="s3">) {</span>
      <span class="s1">qd</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s4">1</span><span class="s3">);</span>
      <span class="s1">more </span><span class="s3">= </span><span class="s2">true</span><span class="s3">;</span>
    <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>

      <span class="s0">// Convert precision in number of base 10 digits to base 1e7 digits.</span>
      <span class="s1">sd </span><span class="s3">= </span><span class="s1">sd </span><span class="s3">/ </span><span class="s1">logBase </span><span class="s3">+ </span><span class="s4">2 </span><span class="s3">| </span><span class="s4">0</span><span class="s3">;</span>
      <span class="s1">i </span><span class="s3">= </span><span class="s4">0</span><span class="s3">;</span>

      <span class="s0">// divisor &lt; 1e7</span>
      <span class="s2">if </span><span class="s3">(</span><span class="s1">yL </span><span class="s3">== </span><span class="s4">1</span><span class="s3">) {</span>
        <span class="s1">k </span><span class="s3">= </span><span class="s4">0</span><span class="s3">;</span>
        <span class="s1">yd </span><span class="s3">= </span><span class="s1">yd</span><span class="s3">[</span><span class="s4">0</span><span class="s3">];</span>
        <span class="s1">sd</span><span class="s3">++;</span>

        <span class="s0">// k is the carry.</span>
        <span class="s2">for </span><span class="s3">(; (</span><span class="s1">i </span><span class="s3">&lt; </span><span class="s1">xL </span><span class="s3">|| </span><span class="s1">k</span><span class="s3">) &amp;&amp; </span><span class="s1">sd</span><span class="s3">--; </span><span class="s1">i</span><span class="s3">++) {</span>
          <span class="s1">t </span><span class="s3">= </span><span class="s1">k </span><span class="s3">* </span><span class="s1">base </span><span class="s3">+ (</span><span class="s1">xd</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] || </span><span class="s4">0</span><span class="s3">);</span>
          <span class="s1">qd</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">t </span><span class="s3">/ </span><span class="s1">yd </span><span class="s3">| </span><span class="s4">0</span><span class="s3">;</span>
          <span class="s1">k </span><span class="s3">= </span><span class="s1">t </span><span class="s3">% </span><span class="s1">yd </span><span class="s3">| </span><span class="s4">0</span><span class="s3">;</span>
        <span class="s3">}</span>

        <span class="s1">more </span><span class="s3">= </span><span class="s1">k </span><span class="s3">|| </span><span class="s1">i </span><span class="s3">&lt; </span><span class="s1">xL</span><span class="s3">;</span>

      <span class="s0">// divisor &gt;= 1e7</span>
      <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>

        <span class="s0">// Normalise xd and yd so highest order digit of yd is &gt;= base/2</span>
        <span class="s1">k </span><span class="s3">= </span><span class="s1">base </span><span class="s3">/ (</span><span class="s1">yd</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] + </span><span class="s4">1</span><span class="s3">) | </span><span class="s4">0</span><span class="s3">;</span>

        <span class="s2">if </span><span class="s3">(</span><span class="s1">k </span><span class="s3">&gt; </span><span class="s4">1</span><span class="s3">) {</span>
          <span class="s1">yd </span><span class="s3">= </span><span class="s1">multiplyInteger</span><span class="s3">(</span><span class="s1">yd</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">base</span><span class="s3">);</span>
          <span class="s1">xd </span><span class="s3">= </span><span class="s1">multiplyInteger</span><span class="s3">(</span><span class="s1">xd</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">base</span><span class="s3">);</span>
          <span class="s1">yL </span><span class="s3">= </span><span class="s1">yd</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span>
          <span class="s1">xL </span><span class="s3">= </span><span class="s1">xd</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span>
        <span class="s3">}</span>

        <span class="s1">xi </span><span class="s3">= </span><span class="s1">yL</span><span class="s3">;</span>
        <span class="s1">rem </span><span class="s3">= </span><span class="s1">xd</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span><span class="s4">0</span><span class="s3">, </span><span class="s1">yL</span><span class="s3">);</span>
        <span class="s1">remL </span><span class="s3">= </span><span class="s1">rem</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span>

        <span class="s0">// Add zeros to make remainder as long as divisor.</span>
        <span class="s2">for </span><span class="s3">(; </span><span class="s1">remL </span><span class="s3">&lt; </span><span class="s1">yL</span><span class="s3">;) </span><span class="s1">rem</span><span class="s3">[</span><span class="s1">remL</span><span class="s3">++] = </span><span class="s4">0</span><span class="s3">;</span>

        <span class="s1">yz </span><span class="s3">= </span><span class="s1">yd</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">();</span>
        <span class="s1">yz</span><span class="s3">.</span><span class="s1">unshift</span><span class="s3">(</span><span class="s4">0</span><span class="s3">);</span>
        <span class="s1">yd0 </span><span class="s3">= </span><span class="s1">yd</span><span class="s3">[</span><span class="s4">0</span><span class="s3">];</span>

        <span class="s2">if </span><span class="s3">(</span><span class="s1">yd</span><span class="s3">[</span><span class="s4">1</span><span class="s3">] &gt;= </span><span class="s1">base </span><span class="s3">/ </span><span class="s4">2</span><span class="s3">) ++</span><span class="s1">yd0</span><span class="s3">;</span>

        <span class="s2">do </span><span class="s3">{</span>
          <span class="s1">k </span><span class="s3">= </span><span class="s4">0</span><span class="s3">;</span>

          <span class="s0">// Compare divisor and remainder.</span>
          <span class="s1">cmp </span><span class="s3">= </span><span class="s1">compare</span><span class="s3">(</span><span class="s1">yd</span><span class="s3">, </span><span class="s1">rem</span><span class="s3">, </span><span class="s1">yL</span><span class="s3">, </span><span class="s1">remL</span><span class="s3">);</span>

          <span class="s0">// If divisor &lt; remainder.</span>
          <span class="s2">if </span><span class="s3">(</span><span class="s1">cmp </span><span class="s3">&lt; </span><span class="s4">0</span><span class="s3">) {</span>

            <span class="s0">// Calculate trial digit, k.</span>
            <span class="s1">rem0 </span><span class="s3">= </span><span class="s1">rem</span><span class="s3">[</span><span class="s4">0</span><span class="s3">];</span>
            <span class="s2">if </span><span class="s3">(</span><span class="s1">yL </span><span class="s3">!= </span><span class="s1">remL</span><span class="s3">) </span><span class="s1">rem0 </span><span class="s3">= </span><span class="s1">rem0 </span><span class="s3">* </span><span class="s1">base </span><span class="s3">+ (</span><span class="s1">rem</span><span class="s3">[</span><span class="s4">1</span><span class="s3">] || </span><span class="s4">0</span><span class="s3">);</span>

            <span class="s0">// k will be how many times the divisor goes into the current remainder.</span>
            <span class="s1">k </span><span class="s3">= </span><span class="s1">rem0 </span><span class="s3">/ </span><span class="s1">yd0 </span><span class="s3">| </span><span class="s4">0</span><span class="s3">;</span>

            <span class="s0">//  Algorithm:</span>
            <span class="s0">//  1. product = divisor * trial digit (k)</span>
            <span class="s0">//  2. if product &gt; remainder: product -= divisor, k--</span>
            <span class="s0">//  3. remainder -= product</span>
            <span class="s0">//  4. if product was &lt; remainder at 2:</span>
            <span class="s0">//    5. compare new remainder and divisor</span>
            <span class="s0">//    6. If remainder &gt; divisor: remainder -= divisor, k++</span>

            <span class="s2">if </span><span class="s3">(</span><span class="s1">k </span><span class="s3">&gt; </span><span class="s4">1</span><span class="s3">) {</span>
              <span class="s2">if </span><span class="s3">(</span><span class="s1">k </span><span class="s3">&gt;= </span><span class="s1">base</span><span class="s3">) </span><span class="s1">k </span><span class="s3">= </span><span class="s1">base </span><span class="s3">- </span><span class="s4">1</span><span class="s3">;</span>

              <span class="s0">// product = divisor * trial digit.</span>
              <span class="s1">prod </span><span class="s3">= </span><span class="s1">multiplyInteger</span><span class="s3">(</span><span class="s1">yd</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">base</span><span class="s3">);</span>
              <span class="s1">prodL </span><span class="s3">= </span><span class="s1">prod</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span>
              <span class="s1">remL </span><span class="s3">= </span><span class="s1">rem</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span>

              <span class="s0">// Compare product and remainder.</span>
              <span class="s1">cmp </span><span class="s3">= </span><span class="s1">compare</span><span class="s3">(</span><span class="s1">prod</span><span class="s3">, </span><span class="s1">rem</span><span class="s3">, </span><span class="s1">prodL</span><span class="s3">, </span><span class="s1">remL</span><span class="s3">);</span>

              <span class="s0">// product &gt; remainder.</span>
              <span class="s2">if </span><span class="s3">(</span><span class="s1">cmp </span><span class="s3">== </span><span class="s4">1</span><span class="s3">) {</span>
                <span class="s1">k</span><span class="s3">--;</span>

                <span class="s0">// Subtract divisor from product.</span>
                <span class="s1">subtract</span><span class="s3">(</span><span class="s1">prod</span><span class="s3">, </span><span class="s1">yL </span><span class="s3">&lt; </span><span class="s1">prodL </span><span class="s3">? </span><span class="s1">yz </span><span class="s3">: </span><span class="s1">yd</span><span class="s3">, </span><span class="s1">prodL</span><span class="s3">, </span><span class="s1">base</span><span class="s3">);</span>
              <span class="s3">}</span>
            <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>

              <span class="s0">// cmp is -1.</span>
              <span class="s0">// If k is 0, there is no need to compare yd and rem again below, so change cmp to 1</span>
              <span class="s0">// to avoid it. If k is 1 there is a need to compare yd and rem again below.</span>
              <span class="s2">if </span><span class="s3">(</span><span class="s1">k </span><span class="s3">== </span><span class="s4">0</span><span class="s3">) </span><span class="s1">cmp </span><span class="s3">= </span><span class="s1">k </span><span class="s3">= </span><span class="s4">1</span><span class="s3">;</span>
              <span class="s1">prod </span><span class="s3">= </span><span class="s1">yd</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">();</span>
            <span class="s3">}</span>

            <span class="s1">prodL </span><span class="s3">= </span><span class="s1">prod</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span>
            <span class="s2">if </span><span class="s3">(</span><span class="s1">prodL </span><span class="s3">&lt; </span><span class="s1">remL</span><span class="s3">) </span><span class="s1">prod</span><span class="s3">.</span><span class="s1">unshift</span><span class="s3">(</span><span class="s4">0</span><span class="s3">);</span>

            <span class="s0">// Subtract product from remainder.</span>
            <span class="s1">subtract</span><span class="s3">(</span><span class="s1">rem</span><span class="s3">, </span><span class="s1">prod</span><span class="s3">, </span><span class="s1">remL</span><span class="s3">, </span><span class="s1">base</span><span class="s3">);</span>

            <span class="s0">// If product was &lt; previous remainder.</span>
            <span class="s2">if </span><span class="s3">(</span><span class="s1">cmp </span><span class="s3">== -</span><span class="s4">1</span><span class="s3">) {</span>
              <span class="s1">remL </span><span class="s3">= </span><span class="s1">rem</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span>

              <span class="s0">// Compare divisor and new remainder.</span>
              <span class="s1">cmp </span><span class="s3">= </span><span class="s1">compare</span><span class="s3">(</span><span class="s1">yd</span><span class="s3">, </span><span class="s1">rem</span><span class="s3">, </span><span class="s1">yL</span><span class="s3">, </span><span class="s1">remL</span><span class="s3">);</span>

              <span class="s0">// If divisor &lt; new remainder, subtract divisor from remainder.</span>
              <span class="s2">if </span><span class="s3">(</span><span class="s1">cmp </span><span class="s3">&lt; </span><span class="s4">1</span><span class="s3">) {</span>
                <span class="s1">k</span><span class="s3">++;</span>

                <span class="s0">// Subtract divisor from remainder.</span>
                <span class="s1">subtract</span><span class="s3">(</span><span class="s1">rem</span><span class="s3">, </span><span class="s1">yL </span><span class="s3">&lt; </span><span class="s1">remL </span><span class="s3">? </span><span class="s1">yz </span><span class="s3">: </span><span class="s1">yd</span><span class="s3">, </span><span class="s1">remL</span><span class="s3">, </span><span class="s1">base</span><span class="s3">);</span>
              <span class="s3">}</span>
            <span class="s3">}</span>

            <span class="s1">remL </span><span class="s3">= </span><span class="s1">rem</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span>
          <span class="s3">} </span><span class="s2">else if </span><span class="s3">(</span><span class="s1">cmp </span><span class="s3">=== </span><span class="s4">0</span><span class="s3">) {</span>
            <span class="s1">k</span><span class="s3">++;</span>
            <span class="s1">rem </span><span class="s3">= [</span><span class="s4">0</span><span class="s3">];</span>
          <span class="s3">}    </span><span class="s0">// if cmp === 1, k will be 0</span>

          <span class="s0">// Add the next digit, k, to the result array.</span>
          <span class="s1">qd</span><span class="s3">[</span><span class="s1">i</span><span class="s3">++] = </span><span class="s1">k</span><span class="s3">;</span>

          <span class="s0">// Update the remainder.</span>
          <span class="s2">if </span><span class="s3">(</span><span class="s1">cmp </span><span class="s3">&amp;&amp; </span><span class="s1">rem</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]) {</span>
            <span class="s1">rem</span><span class="s3">[</span><span class="s1">remL</span><span class="s3">++] = </span><span class="s1">xd</span><span class="s3">[</span><span class="s1">xi</span><span class="s3">] || </span><span class="s4">0</span><span class="s3">;</span>
          <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
            <span class="s1">rem </span><span class="s3">= [</span><span class="s1">xd</span><span class="s3">[</span><span class="s1">xi</span><span class="s3">]];</span>
            <span class="s1">remL </span><span class="s3">= </span><span class="s4">1</span><span class="s3">;</span>
          <span class="s3">}</span>

        <span class="s3">} </span><span class="s2">while </span><span class="s3">((</span><span class="s1">xi</span><span class="s3">++ &lt; </span><span class="s1">xL </span><span class="s3">|| </span><span class="s1">rem</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] !== </span><span class="s2">void </span><span class="s4">0</span><span class="s3">) &amp;&amp; </span><span class="s1">sd</span><span class="s3">--);</span>

        <span class="s1">more </span><span class="s3">= </span><span class="s1">rem</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] !== </span><span class="s2">void </span><span class="s4">0</span><span class="s3">;</span>
      <span class="s3">}</span>

      <span class="s0">// Leading zero?</span>
      <span class="s2">if </span><span class="s3">(!</span><span class="s1">qd</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]) </span><span class="s1">qd</span><span class="s3">.</span><span class="s1">shift</span><span class="s3">();</span>
    <span class="s3">}</span>

    <span class="s0">// logBase is 1 when divide is being used for base conversion.</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">logBase </span><span class="s3">== </span><span class="s4">1</span><span class="s3">) {</span>
      <span class="s1">q</span><span class="s3">.</span><span class="s1">e </span><span class="s3">= </span><span class="s1">e</span><span class="s3">;</span>
      <span class="s1">inexact </span><span class="s3">= </span><span class="s1">more</span><span class="s3">;</span>
    <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>

      <span class="s0">// To calculate q.e, first get the number of digits of qd[0].</span>
      <span class="s2">for </span><span class="s3">(</span><span class="s1">i </span><span class="s3">= </span><span class="s4">1</span><span class="s3">, </span><span class="s1">k </span><span class="s3">= </span><span class="s1">qd</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]; </span><span class="s1">k </span><span class="s3">&gt;= </span><span class="s4">10</span><span class="s3">; </span><span class="s1">k </span><span class="s3">/= </span><span class="s4">10</span><span class="s3">) </span><span class="s1">i</span><span class="s3">++;</span>
      <span class="s1">q</span><span class="s3">.</span><span class="s1">e </span><span class="s3">= </span><span class="s1">i </span><span class="s3">+ </span><span class="s1">e </span><span class="s3">* </span><span class="s1">logBase </span><span class="s3">- </span><span class="s4">1</span><span class="s3">;</span>

      <span class="s1">finalise</span><span class="s3">(</span><span class="s1">q</span><span class="s3">, </span><span class="s1">dp </span><span class="s3">? </span><span class="s1">pr </span><span class="s3">+ </span><span class="s1">q</span><span class="s3">.</span><span class="s1">e </span><span class="s3">+ </span><span class="s4">1 </span><span class="s3">: </span><span class="s1">pr</span><span class="s3">, </span><span class="s1">rm</span><span class="s3">, </span><span class="s1">more</span><span class="s3">);</span>
    <span class="s3">}</span>

    <span class="s2">return </span><span class="s1">q</span><span class="s3">;</span>
  <span class="s3">};</span>
<span class="s3">})();</span>


<span class="s0">/* 
 * Round `x` to `sd` significant digits using rounding mode `rm`. 
 * Check for over/under-flow. 
 */</span>
 <span class="s2">function </span><span class="s1">finalise</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">sd</span><span class="s3">, </span><span class="s1">rm</span><span class="s3">, </span><span class="s1">isTruncated</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">digits</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">j</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">rd</span><span class="s3">, </span><span class="s1">roundUp</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">xd</span><span class="s3">, </span><span class="s1">xdi</span><span class="s3">,</span>
    <span class="s1">Ctor </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">constructor</span><span class="s3">;</span>

  <span class="s0">// Don't round if sd is null or undefined.</span>
  <span class="s1">out</span><span class="s3">: </span><span class="s2">if </span><span class="s3">(</span><span class="s1">sd </span><span class="s3">!= </span><span class="s2">null</span><span class="s3">) {</span>
    <span class="s1">xd </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">d</span><span class="s3">;</span>

    <span class="s0">// Infinity/NaN.</span>
    <span class="s2">if </span><span class="s3">(!</span><span class="s1">xd</span><span class="s3">) </span><span class="s2">return </span><span class="s1">x</span><span class="s3">;</span>

    <span class="s0">// rd: the rounding digit, i.e. the digit after the digit that may be rounded up.</span>
    <span class="s0">// w: the word of xd containing rd, a base 1e7 number.</span>
    <span class="s0">// xdi: the index of w within xd.</span>
    <span class="s0">// digits: the number of digits of w.</span>
    <span class="s0">// i: what would be the index of rd within w if all the numbers were 7 digits long (i.e. if</span>
    <span class="s0">// they had leading zeros)</span>
    <span class="s0">// j: if &gt; 0, the actual index of rd within w (if &lt; 0, rd is a leading zero).</span>

    <span class="s0">// Get the length of the first word of the digits array xd.</span>
    <span class="s2">for </span><span class="s3">(</span><span class="s1">digits </span><span class="s3">= </span><span class="s4">1</span><span class="s3">, </span><span class="s1">k </span><span class="s3">= </span><span class="s1">xd</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]; </span><span class="s1">k </span><span class="s3">&gt;= </span><span class="s4">10</span><span class="s3">; </span><span class="s1">k </span><span class="s3">/= </span><span class="s4">10</span><span class="s3">) </span><span class="s1">digits</span><span class="s3">++;</span>
    <span class="s1">i </span><span class="s3">= </span><span class="s1">sd </span><span class="s3">- </span><span class="s1">digits</span><span class="s3">;</span>

    <span class="s0">// Is the rounding digit in the first word of xd?</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">i </span><span class="s3">&lt; </span><span class="s4">0</span><span class="s3">) {</span>
      <span class="s1">i </span><span class="s3">+= </span><span class="s1">LOG_BASE</span><span class="s3">;</span>
      <span class="s1">j </span><span class="s3">= </span><span class="s1">sd</span><span class="s3">;</span>
      <span class="s1">w </span><span class="s3">= </span><span class="s1">xd</span><span class="s3">[</span><span class="s1">xdi </span><span class="s3">= </span><span class="s4">0</span><span class="s3">];</span>

      <span class="s0">// Get the rounding digit at index j of w.</span>
      <span class="s1">rd </span><span class="s3">= </span><span class="s1">w </span><span class="s3">/ </span><span class="s1">mathpow</span><span class="s3">(</span><span class="s4">10</span><span class="s3">, </span><span class="s1">digits </span><span class="s3">- </span><span class="s1">j </span><span class="s3">- </span><span class="s4">1</span><span class="s3">) % </span><span class="s4">10 </span><span class="s3">| </span><span class="s4">0</span><span class="s3">;</span>
    <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
      <span class="s1">xdi </span><span class="s3">= </span><span class="s1">Math</span><span class="s3">.</span><span class="s1">ceil</span><span class="s3">((</span><span class="s1">i </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">) / </span><span class="s1">LOG_BASE</span><span class="s3">);</span>
      <span class="s1">k </span><span class="s3">= </span><span class="s1">xd</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span>
      <span class="s2">if </span><span class="s3">(</span><span class="s1">xdi </span><span class="s3">&gt;= </span><span class="s1">k</span><span class="s3">) {</span>
        <span class="s2">if </span><span class="s3">(</span><span class="s1">isTruncated</span><span class="s3">) {</span>

          <span class="s0">// Needed by `naturalExponential`, `naturalLogarithm` and `squareRoot`.</span>
          <span class="s2">for </span><span class="s3">(; </span><span class="s1">k</span><span class="s3">++ &lt;= </span><span class="s1">xdi</span><span class="s3">;) </span><span class="s1">xd</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s4">0</span><span class="s3">);</span>
          <span class="s1">w </span><span class="s3">= </span><span class="s1">rd </span><span class="s3">= </span><span class="s4">0</span><span class="s3">;</span>
          <span class="s1">digits </span><span class="s3">= </span><span class="s4">1</span><span class="s3">;</span>
          <span class="s1">i </span><span class="s3">%= </span><span class="s1">LOG_BASE</span><span class="s3">;</span>
          <span class="s1">j </span><span class="s3">= </span><span class="s1">i </span><span class="s3">- </span><span class="s1">LOG_BASE </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">;</span>
        <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
          <span class="s2">break </span><span class="s1">out</span><span class="s3">;</span>
        <span class="s3">}</span>
      <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
        <span class="s1">w </span><span class="s3">= </span><span class="s1">k </span><span class="s3">= </span><span class="s1">xd</span><span class="s3">[</span><span class="s1">xdi</span><span class="s3">];</span>

        <span class="s0">// Get the number of digits of w.</span>
        <span class="s2">for </span><span class="s3">(</span><span class="s1">digits </span><span class="s3">= </span><span class="s4">1</span><span class="s3">; </span><span class="s1">k </span><span class="s3">&gt;= </span><span class="s4">10</span><span class="s3">; </span><span class="s1">k </span><span class="s3">/= </span><span class="s4">10</span><span class="s3">) </span><span class="s1">digits</span><span class="s3">++;</span>

        <span class="s0">// Get the index of rd within w.</span>
        <span class="s1">i </span><span class="s3">%= </span><span class="s1">LOG_BASE</span><span class="s3">;</span>

        <span class="s0">// Get the index of rd within w, adjusted for leading zeros.</span>
        <span class="s0">// The number of leading zeros of w is given by LOG_BASE - digits.</span>
        <span class="s1">j </span><span class="s3">= </span><span class="s1">i </span><span class="s3">- </span><span class="s1">LOG_BASE </span><span class="s3">+ </span><span class="s1">digits</span><span class="s3">;</span>

        <span class="s0">// Get the rounding digit at index j of w.</span>
        <span class="s1">rd </span><span class="s3">= </span><span class="s1">j </span><span class="s3">&lt; </span><span class="s4">0 </span><span class="s3">? </span><span class="s4">0 </span><span class="s3">: </span><span class="s1">w </span><span class="s3">/ </span><span class="s1">mathpow</span><span class="s3">(</span><span class="s4">10</span><span class="s3">, </span><span class="s1">digits </span><span class="s3">- </span><span class="s1">j </span><span class="s3">- </span><span class="s4">1</span><span class="s3">) % </span><span class="s4">10 </span><span class="s3">| </span><span class="s4">0</span><span class="s3">;</span>
      <span class="s3">}</span>
    <span class="s3">}</span>

    <span class="s0">// Are there any non-zero digits after the rounding digit?</span>
    <span class="s1">isTruncated </span><span class="s3">= </span><span class="s1">isTruncated </span><span class="s3">|| </span><span class="s1">sd </span><span class="s3">&lt; </span><span class="s4">0 </span><span class="s3">||</span>
      <span class="s1">xd</span><span class="s3">[</span><span class="s1">xdi </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">] !== </span><span class="s2">void </span><span class="s4">0 </span><span class="s3">|| (</span><span class="s1">j </span><span class="s3">&lt; </span><span class="s4">0 </span><span class="s3">? </span><span class="s1">w </span><span class="s3">: </span><span class="s1">w </span><span class="s3">% </span><span class="s1">mathpow</span><span class="s3">(</span><span class="s4">10</span><span class="s3">, </span><span class="s1">digits </span><span class="s3">- </span><span class="s1">j </span><span class="s3">- </span><span class="s4">1</span><span class="s3">));</span>

    <span class="s0">// The expression `w % mathpow(10, digits - j - 1)` returns all the digits of w to the right</span>
    <span class="s0">// of the digit at (left-to-right) index j, e.g. if w is 908714 and j is 2, the expression</span>
    <span class="s0">// will give 714.</span>

    <span class="s1">roundUp </span><span class="s3">= </span><span class="s1">rm </span><span class="s3">&lt; </span><span class="s4">4</span>
      <span class="s3">? (</span><span class="s1">rd </span><span class="s3">|| </span><span class="s1">isTruncated</span><span class="s3">) &amp;&amp; (</span><span class="s1">rm </span><span class="s3">== </span><span class="s4">0 </span><span class="s3">|| </span><span class="s1">rm </span><span class="s3">== (</span><span class="s1">x</span><span class="s3">.</span><span class="s1">s </span><span class="s3">&lt; </span><span class="s4">0 </span><span class="s3">? </span><span class="s4">3 </span><span class="s3">: </span><span class="s4">2</span><span class="s3">))</span>
      <span class="s3">: </span><span class="s1">rd </span><span class="s3">&gt; </span><span class="s4">5 </span><span class="s3">|| </span><span class="s1">rd </span><span class="s3">== </span><span class="s4">5 </span><span class="s3">&amp;&amp; (</span><span class="s1">rm </span><span class="s3">== </span><span class="s4">4 </span><span class="s3">|| </span><span class="s1">isTruncated </span><span class="s3">|| </span><span class="s1">rm </span><span class="s3">== </span><span class="s4">6 </span><span class="s3">&amp;&amp;</span>

        <span class="s0">// Check whether the digit to the left of the rounding digit is odd.</span>
        <span class="s3">((</span><span class="s1">i </span><span class="s3">&gt; </span><span class="s4">0 </span><span class="s3">? </span><span class="s1">j </span><span class="s3">&gt; </span><span class="s4">0 </span><span class="s3">? </span><span class="s1">w </span><span class="s3">/ </span><span class="s1">mathpow</span><span class="s3">(</span><span class="s4">10</span><span class="s3">, </span><span class="s1">digits </span><span class="s3">- </span><span class="s1">j</span><span class="s3">) : </span><span class="s4">0 </span><span class="s3">: </span><span class="s1">xd</span><span class="s3">[</span><span class="s1">xdi </span><span class="s3">- </span><span class="s4">1</span><span class="s3">]) % </span><span class="s4">10</span><span class="s3">) &amp; </span><span class="s4">1 </span><span class="s3">||</span>
          <span class="s1">rm </span><span class="s3">== (</span><span class="s1">x</span><span class="s3">.</span><span class="s1">s </span><span class="s3">&lt; </span><span class="s4">0 </span><span class="s3">? </span><span class="s4">8 </span><span class="s3">: </span><span class="s4">7</span><span class="s3">));</span>

    <span class="s2">if </span><span class="s3">(</span><span class="s1">sd </span><span class="s3">&lt; </span><span class="s4">1 </span><span class="s3">|| !</span><span class="s1">xd</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]) {</span>
      <span class="s1">xd</span><span class="s3">.</span><span class="s1">length </span><span class="s3">= </span><span class="s4">0</span><span class="s3">;</span>
      <span class="s2">if </span><span class="s3">(</span><span class="s1">roundUp</span><span class="s3">) {</span>

        <span class="s0">// Convert sd to decimal places.</span>
        <span class="s1">sd </span><span class="s3">-= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">e </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">;</span>

        <span class="s0">// 1, 0.1, 0.01, 0.001, 0.0001 etc.</span>
        <span class="s1">xd</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] = </span><span class="s1">mathpow</span><span class="s3">(</span><span class="s4">10</span><span class="s3">, (</span><span class="s1">LOG_BASE </span><span class="s3">- </span><span class="s1">sd </span><span class="s3">% </span><span class="s1">LOG_BASE</span><span class="s3">) % </span><span class="s1">LOG_BASE</span><span class="s3">);</span>
        <span class="s1">x</span><span class="s3">.</span><span class="s1">e </span><span class="s3">= -</span><span class="s1">sd </span><span class="s3">|| </span><span class="s4">0</span><span class="s3">;</span>
      <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>

        <span class="s0">// Zero.</span>
        <span class="s1">xd</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] = </span><span class="s1">x</span><span class="s3">.</span><span class="s1">e </span><span class="s3">= </span><span class="s4">0</span><span class="s3">;</span>
      <span class="s3">}</span>

      <span class="s2">return </span><span class="s1">x</span><span class="s3">;</span>
    <span class="s3">}</span>

    <span class="s0">// Remove excess digits.</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">i </span><span class="s3">== </span><span class="s4">0</span><span class="s3">) {</span>
      <span class="s1">xd</span><span class="s3">.</span><span class="s1">length </span><span class="s3">= </span><span class="s1">xdi</span><span class="s3">;</span>
      <span class="s1">k </span><span class="s3">= </span><span class="s4">1</span><span class="s3">;</span>
      <span class="s1">xdi</span><span class="s3">--;</span>
    <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
      <span class="s1">xd</span><span class="s3">.</span><span class="s1">length </span><span class="s3">= </span><span class="s1">xdi </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">;</span>
      <span class="s1">k </span><span class="s3">= </span><span class="s1">mathpow</span><span class="s3">(</span><span class="s4">10</span><span class="s3">, </span><span class="s1">LOG_BASE </span><span class="s3">- </span><span class="s1">i</span><span class="s3">);</span>

      <span class="s0">// E.g. 56700 becomes 56000 if 7 is the rounding digit.</span>
      <span class="s0">// j &gt; 0 means i &gt; number of leading zeros of w.</span>
      <span class="s1">xd</span><span class="s3">[</span><span class="s1">xdi</span><span class="s3">] = </span><span class="s1">j </span><span class="s3">&gt; </span><span class="s4">0 </span><span class="s3">? (</span><span class="s1">w </span><span class="s3">/ </span><span class="s1">mathpow</span><span class="s3">(</span><span class="s4">10</span><span class="s3">, </span><span class="s1">digits </span><span class="s3">- </span><span class="s1">j</span><span class="s3">) % </span><span class="s1">mathpow</span><span class="s3">(</span><span class="s4">10</span><span class="s3">, </span><span class="s1">j</span><span class="s3">) | </span><span class="s4">0</span><span class="s3">) * </span><span class="s1">k </span><span class="s3">: </span><span class="s4">0</span><span class="s3">;</span>
    <span class="s3">}</span>

    <span class="s2">if </span><span class="s3">(</span><span class="s1">roundUp</span><span class="s3">) {</span>
      <span class="s2">for </span><span class="s3">(;;) {</span>

        <span class="s0">// Is the digit to be rounded up in the first word of xd?</span>
        <span class="s2">if </span><span class="s3">(</span><span class="s1">xdi </span><span class="s3">== </span><span class="s4">0</span><span class="s3">) {</span>

          <span class="s0">// i will be the length of xd[0] before k is added.</span>
          <span class="s2">for </span><span class="s3">(</span><span class="s1">i </span><span class="s3">= </span><span class="s4">1</span><span class="s3">, </span><span class="s1">j </span><span class="s3">= </span><span class="s1">xd</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]; </span><span class="s1">j </span><span class="s3">&gt;= </span><span class="s4">10</span><span class="s3">; </span><span class="s1">j </span><span class="s3">/= </span><span class="s4">10</span><span class="s3">) </span><span class="s1">i</span><span class="s3">++;</span>
          <span class="s1">j </span><span class="s3">= </span><span class="s1">xd</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] += </span><span class="s1">k</span><span class="s3">;</span>
          <span class="s2">for </span><span class="s3">(</span><span class="s1">k </span><span class="s3">= </span><span class="s4">1</span><span class="s3">; </span><span class="s1">j </span><span class="s3">&gt;= </span><span class="s4">10</span><span class="s3">; </span><span class="s1">j </span><span class="s3">/= </span><span class="s4">10</span><span class="s3">) </span><span class="s1">k</span><span class="s3">++;</span>

          <span class="s0">// if i != k the length has increased.</span>
          <span class="s2">if </span><span class="s3">(</span><span class="s1">i </span><span class="s3">!= </span><span class="s1">k</span><span class="s3">) {</span>
            <span class="s1">x</span><span class="s3">.</span><span class="s1">e</span><span class="s3">++;</span>
            <span class="s2">if </span><span class="s3">(</span><span class="s1">xd</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] == </span><span class="s1">BASE</span><span class="s3">) </span><span class="s1">xd</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] = </span><span class="s4">1</span><span class="s3">;</span>
          <span class="s3">}</span>

          <span class="s2">break</span><span class="s3">;</span>
        <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
          <span class="s1">xd</span><span class="s3">[</span><span class="s1">xdi</span><span class="s3">] += </span><span class="s1">k</span><span class="s3">;</span>
          <span class="s2">if </span><span class="s3">(</span><span class="s1">xd</span><span class="s3">[</span><span class="s1">xdi</span><span class="s3">] != </span><span class="s1">BASE</span><span class="s3">) </span><span class="s2">break</span><span class="s3">;</span>
          <span class="s1">xd</span><span class="s3">[</span><span class="s1">xdi</span><span class="s3">--] = </span><span class="s4">0</span><span class="s3">;</span>
          <span class="s1">k </span><span class="s3">= </span><span class="s4">1</span><span class="s3">;</span>
        <span class="s3">}</span>
      <span class="s3">}</span>
    <span class="s3">}</span>

    <span class="s0">// Remove trailing zeros.</span>
    <span class="s2">for </span><span class="s3">(</span><span class="s1">i </span><span class="s3">= </span><span class="s1">xd</span><span class="s3">.</span><span class="s1">length</span><span class="s3">; </span><span class="s1">xd</span><span class="s3">[--</span><span class="s1">i</span><span class="s3">] === </span><span class="s4">0</span><span class="s3">;) </span><span class="s1">xd</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">();</span>
  <span class="s3">}</span>

  <span class="s2">if </span><span class="s3">(</span><span class="s1">external</span><span class="s3">) {</span>

    <span class="s0">// Overflow?</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">e </span><span class="s3">&gt; </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">maxE</span><span class="s3">) {</span>

      <span class="s0">// Infinity.</span>
      <span class="s1">x</span><span class="s3">.</span><span class="s1">d </span><span class="s3">= </span><span class="s2">null</span><span class="s3">;</span>
      <span class="s1">x</span><span class="s3">.</span><span class="s1">e </span><span class="s3">= </span><span class="s1">NaN</span><span class="s3">;</span>

    <span class="s0">// Underflow?</span>
    <span class="s3">} </span><span class="s2">else if </span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">e </span><span class="s3">&lt; </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">minE</span><span class="s3">) {</span>

      <span class="s0">// Zero.</span>
      <span class="s1">x</span><span class="s3">.</span><span class="s1">e </span><span class="s3">= </span><span class="s4">0</span><span class="s3">;</span>
      <span class="s1">x</span><span class="s3">.</span><span class="s1">d </span><span class="s3">= [</span><span class="s4">0</span><span class="s3">];</span>
      <span class="s0">// Ctor.underflow = true;</span>
    <span class="s3">} </span><span class="s0">// else Ctor.underflow = false;</span>
  <span class="s3">}</span>

  <span class="s2">return </span><span class="s1">x</span><span class="s3">;</span>
<span class="s3">}</span>


<span class="s2">function </span><span class="s1">finiteToString</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">isExp</span><span class="s3">, </span><span class="s1">sd</span><span class="s3">) {</span>
  <span class="s2">if </span><span class="s3">(!</span><span class="s1">x</span><span class="s3">.</span><span class="s1">isFinite</span><span class="s3">()) </span><span class="s2">return </span><span class="s1">nonFiniteToString</span><span class="s3">(</span><span class="s1">x</span><span class="s3">);</span>
  <span class="s2">var </span><span class="s1">k</span><span class="s3">,</span>
    <span class="s1">e </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">e</span><span class="s3">,</span>
    <span class="s1">str </span><span class="s3">= </span><span class="s1">digitsToString</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">d</span><span class="s3">),</span>
    <span class="s1">len </span><span class="s3">= </span><span class="s1">str</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span>

  <span class="s2">if </span><span class="s3">(</span><span class="s1">isExp</span><span class="s3">) {</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">sd </span><span class="s3">&amp;&amp; (</span><span class="s1">k </span><span class="s3">= </span><span class="s1">sd </span><span class="s3">- </span><span class="s1">len</span><span class="s3">) &gt; </span><span class="s4">0</span><span class="s3">) {</span>
      <span class="s1">str </span><span class="s3">= </span><span class="s1">str</span><span class="s3">.</span><span class="s1">charAt</span><span class="s3">(</span><span class="s4">0</span><span class="s3">) + </span><span class="s5">'.' </span><span class="s3">+ </span><span class="s1">str</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span><span class="s4">1</span><span class="s3">) + </span><span class="s1">getZeroString</span><span class="s3">(</span><span class="s1">k</span><span class="s3">);</span>
    <span class="s3">} </span><span class="s2">else if </span><span class="s3">(</span><span class="s1">len </span><span class="s3">&gt; </span><span class="s4">1</span><span class="s3">) {</span>
      <span class="s1">str </span><span class="s3">= </span><span class="s1">str</span><span class="s3">.</span><span class="s1">charAt</span><span class="s3">(</span><span class="s4">0</span><span class="s3">) + </span><span class="s5">'.' </span><span class="s3">+ </span><span class="s1">str</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span><span class="s4">1</span><span class="s3">);</span>
    <span class="s3">}</span>

    <span class="s1">str </span><span class="s3">= </span><span class="s1">str </span><span class="s3">+ (</span><span class="s1">x</span><span class="s3">.</span><span class="s1">e </span><span class="s3">&lt; </span><span class="s4">0 </span><span class="s3">? </span><span class="s5">'e' </span><span class="s3">: </span><span class="s5">'e+'</span><span class="s3">) + </span><span class="s1">x</span><span class="s3">.</span><span class="s1">e</span><span class="s3">;</span>
  <span class="s3">} </span><span class="s2">else if </span><span class="s3">(</span><span class="s1">e </span><span class="s3">&lt; </span><span class="s4">0</span><span class="s3">) {</span>
    <span class="s1">str </span><span class="s3">= </span><span class="s5">'0.' </span><span class="s3">+ </span><span class="s1">getZeroString</span><span class="s3">(-</span><span class="s1">e </span><span class="s3">- </span><span class="s4">1</span><span class="s3">) + </span><span class="s1">str</span><span class="s3">;</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">sd </span><span class="s3">&amp;&amp; (</span><span class="s1">k </span><span class="s3">= </span><span class="s1">sd </span><span class="s3">- </span><span class="s1">len</span><span class="s3">) &gt; </span><span class="s4">0</span><span class="s3">) </span><span class="s1">str </span><span class="s3">+= </span><span class="s1">getZeroString</span><span class="s3">(</span><span class="s1">k</span><span class="s3">);</span>
  <span class="s3">} </span><span class="s2">else if </span><span class="s3">(</span><span class="s1">e </span><span class="s3">&gt;= </span><span class="s1">len</span><span class="s3">) {</span>
    <span class="s1">str </span><span class="s3">+= </span><span class="s1">getZeroString</span><span class="s3">(</span><span class="s1">e </span><span class="s3">+ </span><span class="s4">1 </span><span class="s3">- </span><span class="s1">len</span><span class="s3">);</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">sd </span><span class="s3">&amp;&amp; (</span><span class="s1">k </span><span class="s3">= </span><span class="s1">sd </span><span class="s3">- </span><span class="s1">e </span><span class="s3">- </span><span class="s4">1</span><span class="s3">) &gt; </span><span class="s4">0</span><span class="s3">) </span><span class="s1">str </span><span class="s3">= </span><span class="s1">str </span><span class="s3">+ </span><span class="s5">'.' </span><span class="s3">+ </span><span class="s1">getZeroString</span><span class="s3">(</span><span class="s1">k</span><span class="s3">);</span>
  <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
    <span class="s2">if </span><span class="s3">((</span><span class="s1">k </span><span class="s3">= </span><span class="s1">e </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">) &lt; </span><span class="s1">len</span><span class="s3">) </span><span class="s1">str </span><span class="s3">= </span><span class="s1">str</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span><span class="s4">0</span><span class="s3">, </span><span class="s1">k</span><span class="s3">) + </span><span class="s5">'.' </span><span class="s3">+ </span><span class="s1">str</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span><span class="s1">k</span><span class="s3">);</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">sd </span><span class="s3">&amp;&amp; (</span><span class="s1">k </span><span class="s3">= </span><span class="s1">sd </span><span class="s3">- </span><span class="s1">len</span><span class="s3">) &gt; </span><span class="s4">0</span><span class="s3">) {</span>
      <span class="s2">if </span><span class="s3">(</span><span class="s1">e </span><span class="s3">+ </span><span class="s4">1 </span><span class="s3">=== </span><span class="s1">len</span><span class="s3">) </span><span class="s1">str </span><span class="s3">+= </span><span class="s5">'.'</span><span class="s3">;</span>
      <span class="s1">str </span><span class="s3">+= </span><span class="s1">getZeroString</span><span class="s3">(</span><span class="s1">k</span><span class="s3">);</span>
    <span class="s3">}</span>
  <span class="s3">}</span>

  <span class="s2">return </span><span class="s1">str</span><span class="s3">;</span>
<span class="s3">}</span>


<span class="s0">// Calculate the base 10 exponent from the base 1e7 exponent.</span>
<span class="s2">function </span><span class="s1">getBase10Exponent</span><span class="s3">(</span><span class="s1">digits</span><span class="s3">, </span><span class="s1">e</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">w </span><span class="s3">= </span><span class="s1">digits</span><span class="s3">[</span><span class="s4">0</span><span class="s3">];</span>

  <span class="s0">// Add the number of digits of the first word of the digits array.</span>
  <span class="s2">for </span><span class="s3">( </span><span class="s1">e </span><span class="s3">*= </span><span class="s1">LOG_BASE</span><span class="s3">; </span><span class="s1">w </span><span class="s3">&gt;= </span><span class="s4">10</span><span class="s3">; </span><span class="s1">w </span><span class="s3">/= </span><span class="s4">10</span><span class="s3">) </span><span class="s1">e</span><span class="s3">++;</span>
  <span class="s2">return </span><span class="s1">e</span><span class="s3">;</span>
<span class="s3">}</span>


<span class="s2">function </span><span class="s1">getLn10</span><span class="s3">(</span><span class="s1">Ctor</span><span class="s3">, </span><span class="s1">sd</span><span class="s3">, </span><span class="s1">pr</span><span class="s3">) {</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">sd </span><span class="s3">&gt; </span><span class="s1">LN10_PRECISION</span><span class="s3">) {</span>

    <span class="s0">// Reset global state in case the exception is caught.</span>
    <span class="s1">external </span><span class="s3">= </span><span class="s2">true</span><span class="s3">;</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">pr</span><span class="s3">) </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">precision </span><span class="s3">= </span><span class="s1">pr</span><span class="s3">;</span>
    <span class="s2">throw </span><span class="s1">Error</span><span class="s3">(</span><span class="s1">precisionLimitExceeded</span><span class="s3">);</span>
  <span class="s3">}</span>
  <span class="s2">return </span><span class="s1">finalise</span><span class="s3">(</span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">LN10</span><span class="s3">), </span><span class="s1">sd</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s2">true</span><span class="s3">);</span>
<span class="s3">}</span>


<span class="s2">function </span><span class="s1">getPi</span><span class="s3">(</span><span class="s1">Ctor</span><span class="s3">, </span><span class="s1">sd</span><span class="s3">, </span><span class="s1">rm</span><span class="s3">) {</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">sd </span><span class="s3">&gt; </span><span class="s1">PI_PRECISION</span><span class="s3">) </span><span class="s2">throw </span><span class="s1">Error</span><span class="s3">(</span><span class="s1">precisionLimitExceeded</span><span class="s3">);</span>
  <span class="s2">return </span><span class="s1">finalise</span><span class="s3">(</span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">PI</span><span class="s3">), </span><span class="s1">sd</span><span class="s3">, </span><span class="s1">rm</span><span class="s3">, </span><span class="s2">true</span><span class="s3">);</span>
<span class="s3">}</span>


<span class="s2">function </span><span class="s1">getPrecision</span><span class="s3">(</span><span class="s1">digits</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">w </span><span class="s3">= </span><span class="s1">digits</span><span class="s3">.</span><span class="s1">length </span><span class="s3">- </span><span class="s4">1</span><span class="s3">,</span>
    <span class="s1">len </span><span class="s3">= </span><span class="s1">w </span><span class="s3">* </span><span class="s1">LOG_BASE </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">;</span>

  <span class="s1">w </span><span class="s3">= </span><span class="s1">digits</span><span class="s3">[</span><span class="s1">w</span><span class="s3">];</span>

  <span class="s0">// If non-zero...</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">w</span><span class="s3">) {</span>

    <span class="s0">// Subtract the number of trailing zeros of the last word.</span>
    <span class="s2">for </span><span class="s3">(; </span><span class="s1">w </span><span class="s3">% </span><span class="s4">10 </span><span class="s3">== </span><span class="s4">0</span><span class="s3">; </span><span class="s1">w </span><span class="s3">/= </span><span class="s4">10</span><span class="s3">) </span><span class="s1">len</span><span class="s3">--;</span>

    <span class="s0">// Add the number of digits of the first word.</span>
    <span class="s2">for </span><span class="s3">(</span><span class="s1">w </span><span class="s3">= </span><span class="s1">digits</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]; </span><span class="s1">w </span><span class="s3">&gt;= </span><span class="s4">10</span><span class="s3">; </span><span class="s1">w </span><span class="s3">/= </span><span class="s4">10</span><span class="s3">) </span><span class="s1">len</span><span class="s3">++;</span>
  <span class="s3">}</span>

  <span class="s2">return </span><span class="s1">len</span><span class="s3">;</span>
<span class="s3">}</span>


<span class="s2">function </span><span class="s1">getZeroString</span><span class="s3">(</span><span class="s1">k</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">zs </span><span class="s3">= </span><span class="s5">''</span><span class="s3">;</span>
  <span class="s2">for </span><span class="s3">(; </span><span class="s1">k</span><span class="s3">--;) </span><span class="s1">zs </span><span class="s3">+= </span><span class="s5">'0'</span><span class="s3">;</span>
  <span class="s2">return </span><span class="s1">zs</span><span class="s3">;</span>
<span class="s3">}</span>


<span class="s0">/* 
 * Return a new Decimal whose value is the value of Decimal `x` to the power `n`, where `n` is an 
 * integer of type number. 
 * 
 * Implements 'exponentiation by squaring'. Called by `pow` and `parseOther`. 
 * 
 */</span>
<span class="s2">function </span><span class="s1">intPow</span><span class="s3">(</span><span class="s1">Ctor</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">pr</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">isTruncated</span><span class="s3">,</span>
    <span class="s1">r </span><span class="s3">= </span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s4">1</span><span class="s3">),</span>

    <span class="s0">// Max n of 9007199254740991 takes 53 loop iterations.</span>
    <span class="s0">// Maximum digits array length; leaves [28, 34] guard digits.</span>
    <span class="s1">k </span><span class="s3">= </span><span class="s1">Math</span><span class="s3">.</span><span class="s1">ceil</span><span class="s3">(</span><span class="s1">pr </span><span class="s3">/ </span><span class="s1">LOG_BASE </span><span class="s3">+ </span><span class="s4">4</span><span class="s3">);</span>

  <span class="s1">external </span><span class="s3">= </span><span class="s2">false</span><span class="s3">;</span>

  <span class="s2">for </span><span class="s3">(;;) {</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">n </span><span class="s3">% </span><span class="s4">2</span><span class="s3">) {</span>
      <span class="s1">r </span><span class="s3">= </span><span class="s1">r</span><span class="s3">.</span><span class="s1">times</span><span class="s3">(</span><span class="s1">x</span><span class="s3">);</span>
      <span class="s2">if </span><span class="s3">(</span><span class="s1">truncate</span><span class="s3">(</span><span class="s1">r</span><span class="s3">.</span><span class="s1">d</span><span class="s3">, </span><span class="s1">k</span><span class="s3">)) </span><span class="s1">isTruncated </span><span class="s3">= </span><span class="s2">true</span><span class="s3">;</span>
    <span class="s3">}</span>

    <span class="s1">n </span><span class="s3">= </span><span class="s1">mathfloor</span><span class="s3">(</span><span class="s1">n </span><span class="s3">/ </span><span class="s4">2</span><span class="s3">);</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">n </span><span class="s3">=== </span><span class="s4">0</span><span class="s3">) {</span>

      <span class="s0">// To ensure correct rounding when r.d is truncated, increment the last word if it is zero.</span>
      <span class="s1">n </span><span class="s3">= </span><span class="s1">r</span><span class="s3">.</span><span class="s1">d</span><span class="s3">.</span><span class="s1">length </span><span class="s3">- </span><span class="s4">1</span><span class="s3">;</span>
      <span class="s2">if </span><span class="s3">(</span><span class="s1">isTruncated </span><span class="s3">&amp;&amp; </span><span class="s1">r</span><span class="s3">.</span><span class="s1">d</span><span class="s3">[</span><span class="s1">n</span><span class="s3">] === </span><span class="s4">0</span><span class="s3">) ++</span><span class="s1">r</span><span class="s3">.</span><span class="s1">d</span><span class="s3">[</span><span class="s1">n</span><span class="s3">];</span>
      <span class="s2">break</span><span class="s3">;</span>
    <span class="s3">}</span>

    <span class="s1">x </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">times</span><span class="s3">(</span><span class="s1">x</span><span class="s3">);</span>
    <span class="s1">truncate</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">d</span><span class="s3">, </span><span class="s1">k</span><span class="s3">);</span>
  <span class="s3">}</span>

  <span class="s1">external </span><span class="s3">= </span><span class="s2">true</span><span class="s3">;</span>

  <span class="s2">return </span><span class="s1">r</span><span class="s3">;</span>
<span class="s3">}</span>


<span class="s2">function </span><span class="s1">isOdd</span><span class="s3">(</span><span class="s1">n</span><span class="s3">) {</span>
  <span class="s2">return </span><span class="s1">n</span><span class="s3">.</span><span class="s1">d</span><span class="s3">[</span><span class="s1">n</span><span class="s3">.</span><span class="s1">d</span><span class="s3">.</span><span class="s1">length </span><span class="s3">- </span><span class="s4">1</span><span class="s3">] &amp; </span><span class="s4">1</span><span class="s3">;</span>
<span class="s3">}</span>


<span class="s0">/* 
 * Handle `max` (`n` is -1) and `min` (`n` is 1). 
 */</span>
<span class="s2">function </span><span class="s1">maxOrMin</span><span class="s3">(</span><span class="s1">Ctor</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">n</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">k</span><span class="s3">, </span><span class="s1">y</span><span class="s3">,</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">args</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]),</span>
    <span class="s1">i </span><span class="s3">= </span><span class="s4">0</span><span class="s3">;</span>

  <span class="s2">for </span><span class="s3">(; ++</span><span class="s1">i </span><span class="s3">&lt; </span><span class="s1">args</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;) {</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">args</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]);</span>

    <span class="s0">// NaN?</span>
    <span class="s2">if </span><span class="s3">(!</span><span class="s1">y</span><span class="s3">.</span><span class="s1">s</span><span class="s3">) {</span>
      <span class="s1">x </span><span class="s3">= </span><span class="s1">y</span><span class="s3">;</span>
      <span class="s2">break</span><span class="s3">;</span>
    <span class="s3">}</span>

    <span class="s1">k </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">cmp</span><span class="s3">(</span><span class="s1">y</span><span class="s3">);</span>

    <span class="s2">if </span><span class="s3">(</span><span class="s1">k </span><span class="s3">=== </span><span class="s1">n </span><span class="s3">|| </span><span class="s1">k </span><span class="s3">=== </span><span class="s4">0 </span><span class="s3">&amp;&amp; </span><span class="s1">x</span><span class="s3">.</span><span class="s1">s </span><span class="s3">=== </span><span class="s1">n</span><span class="s3">) {</span>
      <span class="s1">x </span><span class="s3">= </span><span class="s1">y</span><span class="s3">;</span>
    <span class="s3">}</span>
  <span class="s3">}</span>

  <span class="s2">return </span><span class="s1">x</span><span class="s3">;</span>
<span class="s3">}</span>


<span class="s0">/* 
 * Return a new Decimal whose value is the natural exponential of `x` rounded to `sd` significant 
 * digits. 
 * 
 * Taylor/Maclaurin series. 
 * 
 * exp(x) = x^0/0! + x^1/1! + x^2/2! + x^3/3! + ... 
 * 
 * Argument reduction: 
 *   Repeat x = x / 32, k += 5, until |x| &lt; 0.1 
 *   exp(x) = exp(x / 2^k)^(2^k) 
 * 
 * Previously, the argument was initially reduced by 
 * exp(x) = exp(r) * 10^k  where r = x - k * ln10, k = floor(x / ln10) 
 * to first put r in the range [0, ln10], before dividing by 32 until |x| &lt; 0.1, but this was 
 * found to be slower than just dividing repeatedly by 32 as above. 
 * 
 * Max integer argument: exp('20723265836946413') = 6.3e+9000000000000000 
 * Min integer argument: exp('-20723265836946411') = 1.2e-9000000000000000 
 * (Math object integer min/max: Math.exp(709) = 8.2e+307, Math.exp(-745) = 5e-324) 
 * 
 *  exp(Infinity)  = Infinity 
 *  exp(-Infinity) = 0 
 *  exp(NaN)       = NaN 
 *  exp(Â±0)        = 1 
 * 
 *  exp(x) is non-terminating for any finite, non-zero x. 
 * 
 *  The result will always be correctly rounded. 
 * 
 */</span>
<span class="s2">function </span><span class="s1">naturalExponential</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">sd</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">denominator</span><span class="s3">, </span><span class="s1">guard</span><span class="s3">, </span><span class="s1">j</span><span class="s3">, </span><span class="s1">pow</span><span class="s3">, </span><span class="s1">sum</span><span class="s3">, </span><span class="s1">t</span><span class="s3">, </span><span class="s1">wpr</span><span class="s3">,</span>
    <span class="s1">rep </span><span class="s3">= </span><span class="s4">0</span><span class="s3">,</span>
    <span class="s1">i </span><span class="s3">= </span><span class="s4">0</span><span class="s3">,</span>
    <span class="s1">k </span><span class="s3">= </span><span class="s4">0</span><span class="s3">,</span>
    <span class="s1">Ctor </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">constructor</span><span class="s3">,</span>
    <span class="s1">rm </span><span class="s3">= </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">rounding</span><span class="s3">,</span>
    <span class="s1">pr </span><span class="s3">= </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">precision</span><span class="s3">;</span>

  <span class="s0">// 0/NaN/Infinity?</span>
  <span class="s2">if </span><span class="s3">(!</span><span class="s1">x</span><span class="s3">.</span><span class="s1">d </span><span class="s3">|| !</span><span class="s1">x</span><span class="s3">.</span><span class="s1">d</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] || </span><span class="s1">x</span><span class="s3">.</span><span class="s1">e </span><span class="s3">&gt; </span><span class="s4">17</span><span class="s3">) {</span>

    <span class="s2">return new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">d</span>
      <span class="s3">? !</span><span class="s1">x</span><span class="s3">.</span><span class="s1">d</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] ? </span><span class="s4">1 </span><span class="s3">: </span><span class="s1">x</span><span class="s3">.</span><span class="s1">s </span><span class="s3">&lt; </span><span class="s4">0 </span><span class="s3">? </span><span class="s4">0 </span><span class="s3">: </span><span class="s4">1 </span><span class="s3">/ </span><span class="s4">0</span>
      <span class="s3">: </span><span class="s1">x</span><span class="s3">.</span><span class="s1">s </span><span class="s3">? </span><span class="s1">x</span><span class="s3">.</span><span class="s1">s </span><span class="s3">&lt; </span><span class="s4">0 </span><span class="s3">? </span><span class="s4">0 </span><span class="s3">: </span><span class="s1">x </span><span class="s3">: </span><span class="s4">0 </span><span class="s3">/ </span><span class="s4">0</span><span class="s3">);</span>
  <span class="s3">}</span>

  <span class="s2">if </span><span class="s3">(</span><span class="s1">sd </span><span class="s3">== </span><span class="s2">null</span><span class="s3">) {</span>
    <span class="s1">external </span><span class="s3">= </span><span class="s2">false</span><span class="s3">;</span>
    <span class="s1">wpr </span><span class="s3">= </span><span class="s1">pr</span><span class="s3">;</span>
  <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
    <span class="s1">wpr </span><span class="s3">= </span><span class="s1">sd</span><span class="s3">;</span>
  <span class="s3">}</span>

  <span class="s1">t </span><span class="s3">= </span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s4">0.03125</span><span class="s3">);</span>

  <span class="s0">// while abs(x) &gt;= 0.1</span>
  <span class="s2">while </span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">e </span><span class="s3">&gt; -</span><span class="s4">2</span><span class="s3">) {</span>

    <span class="s0">// x = x / 2^5</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">times</span><span class="s3">(</span><span class="s1">t</span><span class="s3">);</span>
    <span class="s1">k </span><span class="s3">+= </span><span class="s4">5</span><span class="s3">;</span>
  <span class="s3">}</span>

  <span class="s0">// Use 2 * log10(2^k) + 5 (empirically derived) to estimate the increase in precision</span>
  <span class="s0">// necessary to ensure the first 4 rounding digits are correct.</span>
  <span class="s1">guard </span><span class="s3">= </span><span class="s1">Math</span><span class="s3">.</span><span class="s1">log</span><span class="s3">(</span><span class="s1">mathpow</span><span class="s3">(</span><span class="s4">2</span><span class="s3">, </span><span class="s1">k</span><span class="s3">)) / </span><span class="s1">Math</span><span class="s3">.</span><span class="s1">LN10 </span><span class="s3">* </span><span class="s4">2 </span><span class="s3">+ </span><span class="s4">5 </span><span class="s3">| </span><span class="s4">0</span><span class="s3">;</span>
  <span class="s1">wpr </span><span class="s3">+= </span><span class="s1">guard</span><span class="s3">;</span>
  <span class="s1">denominator </span><span class="s3">= </span><span class="s1">pow </span><span class="s3">= </span><span class="s1">sum </span><span class="s3">= </span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s4">1</span><span class="s3">);</span>
  <span class="s1">Ctor</span><span class="s3">.</span><span class="s1">precision </span><span class="s3">= </span><span class="s1">wpr</span><span class="s3">;</span>

  <span class="s2">for </span><span class="s3">(;;) {</span>
    <span class="s1">pow </span><span class="s3">= </span><span class="s1">finalise</span><span class="s3">(</span><span class="s1">pow</span><span class="s3">.</span><span class="s1">times</span><span class="s3">(</span><span class="s1">x</span><span class="s3">), </span><span class="s1">wpr</span><span class="s3">, </span><span class="s4">1</span><span class="s3">);</span>
    <span class="s1">denominator </span><span class="s3">= </span><span class="s1">denominator</span><span class="s3">.</span><span class="s1">times</span><span class="s3">(++</span><span class="s1">i</span><span class="s3">);</span>
    <span class="s1">t </span><span class="s3">= </span><span class="s1">sum</span><span class="s3">.</span><span class="s1">plus</span><span class="s3">(</span><span class="s1">divide</span><span class="s3">(</span><span class="s1">pow</span><span class="s3">, </span><span class="s1">denominator</span><span class="s3">, </span><span class="s1">wpr</span><span class="s3">, </span><span class="s4">1</span><span class="s3">));</span>

    <span class="s2">if </span><span class="s3">(</span><span class="s1">digitsToString</span><span class="s3">(</span><span class="s1">t</span><span class="s3">.</span><span class="s1">d</span><span class="s3">).</span><span class="s1">slice</span><span class="s3">(</span><span class="s4">0</span><span class="s3">, </span><span class="s1">wpr</span><span class="s3">) === </span><span class="s1">digitsToString</span><span class="s3">(</span><span class="s1">sum</span><span class="s3">.</span><span class="s1">d</span><span class="s3">).</span><span class="s1">slice</span><span class="s3">(</span><span class="s4">0</span><span class="s3">, </span><span class="s1">wpr</span><span class="s3">)) {</span>
      <span class="s1">j </span><span class="s3">= </span><span class="s1">k</span><span class="s3">;</span>
      <span class="s2">while </span><span class="s3">(</span><span class="s1">j</span><span class="s3">--) </span><span class="s1">sum </span><span class="s3">= </span><span class="s1">finalise</span><span class="s3">(</span><span class="s1">sum</span><span class="s3">.</span><span class="s1">times</span><span class="s3">(</span><span class="s1">sum</span><span class="s3">), </span><span class="s1">wpr</span><span class="s3">, </span><span class="s4">1</span><span class="s3">);</span>

      <span class="s0">// Check to see if the first 4 rounding digits are [49]999.</span>
      <span class="s0">// If so, repeat the summation with a higher precision, otherwise</span>
      <span class="s0">// e.g. with precision: 18, rounding: 1</span>
      <span class="s0">// exp(18.404272462595034083567793919843761) = 98372560.1229999999 (should be 98372560.123)</span>
      <span class="s0">// `wpr - guard` is the index of first rounding digit.</span>
      <span class="s2">if </span><span class="s3">(</span><span class="s1">sd </span><span class="s3">== </span><span class="s2">null</span><span class="s3">) {</span>

        <span class="s2">if </span><span class="s3">(</span><span class="s1">rep </span><span class="s3">&lt; </span><span class="s4">3 </span><span class="s3">&amp;&amp; </span><span class="s1">checkRoundingDigits</span><span class="s3">(</span><span class="s1">sum</span><span class="s3">.</span><span class="s1">d</span><span class="s3">, </span><span class="s1">wpr </span><span class="s3">- </span><span class="s1">guard</span><span class="s3">, </span><span class="s1">rm</span><span class="s3">, </span><span class="s1">rep</span><span class="s3">)) {</span>
          <span class="s1">Ctor</span><span class="s3">.</span><span class="s1">precision </span><span class="s3">= </span><span class="s1">wpr </span><span class="s3">+= </span><span class="s4">10</span><span class="s3">;</span>
          <span class="s1">denominator </span><span class="s3">= </span><span class="s1">pow </span><span class="s3">= </span><span class="s1">t </span><span class="s3">= </span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s4">1</span><span class="s3">);</span>
          <span class="s1">i </span><span class="s3">= </span><span class="s4">0</span><span class="s3">;</span>
          <span class="s1">rep</span><span class="s3">++;</span>
        <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
          <span class="s2">return </span><span class="s1">finalise</span><span class="s3">(</span><span class="s1">sum</span><span class="s3">, </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">precision </span><span class="s3">= </span><span class="s1">pr</span><span class="s3">, </span><span class="s1">rm</span><span class="s3">, </span><span class="s1">external </span><span class="s3">= </span><span class="s2">true</span><span class="s3">);</span>
        <span class="s3">}</span>
      <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
        <span class="s1">Ctor</span><span class="s3">.</span><span class="s1">precision </span><span class="s3">= </span><span class="s1">pr</span><span class="s3">;</span>
        <span class="s2">return </span><span class="s1">sum</span><span class="s3">;</span>
      <span class="s3">}</span>
    <span class="s3">}</span>

    <span class="s1">sum </span><span class="s3">= </span><span class="s1">t</span><span class="s3">;</span>
  <span class="s3">}</span>
<span class="s3">}</span>


<span class="s0">/* 
 * Return a new Decimal whose value is the natural logarithm of `x` rounded to `sd` significant 
 * digits. 
 * 
 *  ln(-n)        = NaN 
 *  ln(0)         = -Infinity 
 *  ln(-0)        = -Infinity 
 *  ln(1)         = 0 
 *  ln(Infinity)  = Infinity 
 *  ln(-Infinity) = NaN 
 *  ln(NaN)       = NaN 
 * 
 *  ln(n) (n != 1) is non-terminating. 
 * 
 */</span>
<span class="s2">function </span><span class="s1">naturalLogarithm</span><span class="s3">(</span><span class="s1">y</span><span class="s3">, </span><span class="s1">sd</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">c</span><span class="s3">, </span><span class="s1">c0</span><span class="s3">, </span><span class="s1">denominator</span><span class="s3">, </span><span class="s1">e</span><span class="s3">, </span><span class="s1">numerator</span><span class="s3">, </span><span class="s1">rep</span><span class="s3">, </span><span class="s1">sum</span><span class="s3">, </span><span class="s1">t</span><span class="s3">, </span><span class="s1">wpr</span><span class="s3">, </span><span class="s1">x1</span><span class="s3">, </span><span class="s1">x2</span><span class="s3">,</span>
    <span class="s1">n </span><span class="s3">= </span><span class="s4">1</span><span class="s3">,</span>
    <span class="s1">guard </span><span class="s3">= </span><span class="s4">10</span><span class="s3">,</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s1">y</span><span class="s3">,</span>
    <span class="s1">xd </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">d</span><span class="s3">,</span>
    <span class="s1">Ctor </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">constructor</span><span class="s3">,</span>
    <span class="s1">rm </span><span class="s3">= </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">rounding</span><span class="s3">,</span>
    <span class="s1">pr </span><span class="s3">= </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">precision</span><span class="s3">;</span>

  <span class="s0">// Is x negative or Infinity, NaN, 0 or 1?</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">s </span><span class="s3">&lt; </span><span class="s4">0 </span><span class="s3">|| !</span><span class="s1">xd </span><span class="s3">|| !</span><span class="s1">xd</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] || !</span><span class="s1">x</span><span class="s3">.</span><span class="s1">e </span><span class="s3">&amp;&amp; </span><span class="s1">xd</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] == </span><span class="s4">1 </span><span class="s3">&amp;&amp; </span><span class="s1">xd</span><span class="s3">.</span><span class="s1">length </span><span class="s3">== </span><span class="s4">1</span><span class="s3">) {</span>
    <span class="s2">return new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">xd </span><span class="s3">&amp;&amp; !</span><span class="s1">xd</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] ? -</span><span class="s4">1 </span><span class="s3">/ </span><span class="s4">0 </span><span class="s3">: </span><span class="s1">x</span><span class="s3">.</span><span class="s1">s </span><span class="s3">!= </span><span class="s4">1 </span><span class="s3">? </span><span class="s1">NaN </span><span class="s3">: </span><span class="s1">xd </span><span class="s3">? </span><span class="s4">0 </span><span class="s3">: </span><span class="s1">x</span><span class="s3">);</span>
  <span class="s3">}</span>

  <span class="s2">if </span><span class="s3">(</span><span class="s1">sd </span><span class="s3">== </span><span class="s2">null</span><span class="s3">) {</span>
    <span class="s1">external </span><span class="s3">= </span><span class="s2">false</span><span class="s3">;</span>
    <span class="s1">wpr </span><span class="s3">= </span><span class="s1">pr</span><span class="s3">;</span>
  <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
    <span class="s1">wpr </span><span class="s3">= </span><span class="s1">sd</span><span class="s3">;</span>
  <span class="s3">}</span>

  <span class="s1">Ctor</span><span class="s3">.</span><span class="s1">precision </span><span class="s3">= </span><span class="s1">wpr </span><span class="s3">+= </span><span class="s1">guard</span><span class="s3">;</span>
  <span class="s1">c </span><span class="s3">= </span><span class="s1">digitsToString</span><span class="s3">(</span><span class="s1">xd</span><span class="s3">);</span>
  <span class="s1">c0 </span><span class="s3">= </span><span class="s1">c</span><span class="s3">.</span><span class="s1">charAt</span><span class="s3">(</span><span class="s4">0</span><span class="s3">);</span>

  <span class="s2">if </span><span class="s3">(</span><span class="s1">Math</span><span class="s3">.</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">e </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">e</span><span class="s3">) &lt; </span><span class="s4">1.5e15</span><span class="s3">) {</span>

    <span class="s0">// Argument reduction.</span>
    <span class="s0">// The series converges faster the closer the argument is to 1, so using</span>
    <span class="s0">// ln(a^b) = b * ln(a),   ln(a) = ln(a^b) / b</span>
    <span class="s0">// multiply the argument by itself until the leading digits of the significand are 7, 8, 9,</span>
    <span class="s0">// 10, 11, 12 or 13, recording the number of multiplications so the sum of the series can</span>
    <span class="s0">// later be divided by this number, then separate out the power of 10 using</span>
    <span class="s0">// ln(a*10^b) = ln(a) + b*ln(10).</span>

    <span class="s0">// max n is 21 (gives 0.9, 1.0 or 1.1) (9e15 / 21 = 4.2e14).</span>
    <span class="s0">//while (c0 &lt; 9 &amp;&amp; c0 != 1 || c0 == 1 &amp;&amp; c.charAt(1) &gt; 1) {</span>
    <span class="s0">// max n is 6 (gives 0.7 - 1.3)</span>
    <span class="s2">while </span><span class="s3">(</span><span class="s1">c0 </span><span class="s3">&lt; </span><span class="s4">7 </span><span class="s3">&amp;&amp; </span><span class="s1">c0 </span><span class="s3">!= </span><span class="s4">1 </span><span class="s3">|| </span><span class="s1">c0 </span><span class="s3">== </span><span class="s4">1 </span><span class="s3">&amp;&amp; </span><span class="s1">c</span><span class="s3">.</span><span class="s1">charAt</span><span class="s3">(</span><span class="s4">1</span><span class="s3">) &gt; </span><span class="s4">3</span><span class="s3">) {</span>
      <span class="s1">x </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">times</span><span class="s3">(</span><span class="s1">y</span><span class="s3">);</span>
      <span class="s1">c </span><span class="s3">= </span><span class="s1">digitsToString</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">d</span><span class="s3">);</span>
      <span class="s1">c0 </span><span class="s3">= </span><span class="s1">c</span><span class="s3">.</span><span class="s1">charAt</span><span class="s3">(</span><span class="s4">0</span><span class="s3">);</span>
      <span class="s1">n</span><span class="s3">++;</span>
    <span class="s3">}</span>

    <span class="s1">e </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">e</span><span class="s3">;</span>

    <span class="s2">if </span><span class="s3">(</span><span class="s1">c0 </span><span class="s3">&gt; </span><span class="s4">1</span><span class="s3">) {</span>
      <span class="s1">x </span><span class="s3">= </span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s5">'0.' </span><span class="s3">+ </span><span class="s1">c</span><span class="s3">);</span>
      <span class="s1">e</span><span class="s3">++;</span>
    <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
      <span class="s1">x </span><span class="s3">= </span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">c0 </span><span class="s3">+ </span><span class="s5">'.' </span><span class="s3">+ </span><span class="s1">c</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span><span class="s4">1</span><span class="s3">));</span>
    <span class="s3">}</span>
  <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>

    <span class="s0">// The argument reduction method above may result in overflow if the argument y is a massive</span>
    <span class="s0">// number with exponent &gt;= 1500000000000000 (9e15 / 6 = 1.5e15), so instead recall this</span>
    <span class="s0">// function using ln(x*10^e) = ln(x) + e*ln(10).</span>
    <span class="s1">t </span><span class="s3">= </span><span class="s1">getLn10</span><span class="s3">(</span><span class="s1">Ctor</span><span class="s3">, </span><span class="s1">wpr </span><span class="s3">+ </span><span class="s4">2</span><span class="s3">, </span><span class="s1">pr</span><span class="s3">).</span><span class="s1">times</span><span class="s3">(</span><span class="s1">e </span><span class="s3">+ </span><span class="s5">''</span><span class="s3">);</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s1">naturalLogarithm</span><span class="s3">(</span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">c0 </span><span class="s3">+ </span><span class="s5">'.' </span><span class="s3">+ </span><span class="s1">c</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span><span class="s4">1</span><span class="s3">)), </span><span class="s1">wpr </span><span class="s3">- </span><span class="s1">guard</span><span class="s3">).</span><span class="s1">plus</span><span class="s3">(</span><span class="s1">t</span><span class="s3">);</span>
    <span class="s1">Ctor</span><span class="s3">.</span><span class="s1">precision </span><span class="s3">= </span><span class="s1">pr</span><span class="s3">;</span>

    <span class="s2">return </span><span class="s1">sd </span><span class="s3">== </span><span class="s2">null </span><span class="s3">? </span><span class="s1">finalise</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">pr</span><span class="s3">, </span><span class="s1">rm</span><span class="s3">, </span><span class="s1">external </span><span class="s3">= </span><span class="s2">true</span><span class="s3">) : </span><span class="s1">x</span><span class="s3">;</span>
  <span class="s3">}</span>

  <span class="s0">// x1 is x reduced to a value near 1.</span>
  <span class="s1">x1 </span><span class="s3">= </span><span class="s1">x</span><span class="s3">;</span>

  <span class="s0">// Taylor series.</span>
  <span class="s0">// ln(y) = ln((1 + x)/(1 - x)) = 2(x + x^3/3 + x^5/5 + x^7/7 + ...)</span>
  <span class="s0">// where x = (y - 1)/(y + 1)    (|x| &lt; 1)</span>
  <span class="s1">sum </span><span class="s3">= </span><span class="s1">numerator </span><span class="s3">= </span><span class="s1">x </span><span class="s3">= </span><span class="s1">divide</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">minus</span><span class="s3">(</span><span class="s4">1</span><span class="s3">), </span><span class="s1">x</span><span class="s3">.</span><span class="s1">plus</span><span class="s3">(</span><span class="s4">1</span><span class="s3">), </span><span class="s1">wpr</span><span class="s3">, </span><span class="s4">1</span><span class="s3">);</span>
  <span class="s1">x2 </span><span class="s3">= </span><span class="s1">finalise</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">times</span><span class="s3">(</span><span class="s1">x</span><span class="s3">), </span><span class="s1">wpr</span><span class="s3">, </span><span class="s4">1</span><span class="s3">);</span>
  <span class="s1">denominator </span><span class="s3">= </span><span class="s4">3</span><span class="s3">;</span>

  <span class="s2">for </span><span class="s3">(;;) {</span>
    <span class="s1">numerator </span><span class="s3">= </span><span class="s1">finalise</span><span class="s3">(</span><span class="s1">numerator</span><span class="s3">.</span><span class="s1">times</span><span class="s3">(</span><span class="s1">x2</span><span class="s3">), </span><span class="s1">wpr</span><span class="s3">, </span><span class="s4">1</span><span class="s3">);</span>
    <span class="s1">t </span><span class="s3">= </span><span class="s1">sum</span><span class="s3">.</span><span class="s1">plus</span><span class="s3">(</span><span class="s1">divide</span><span class="s3">(</span><span class="s1">numerator</span><span class="s3">, </span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">denominator</span><span class="s3">), </span><span class="s1">wpr</span><span class="s3">, </span><span class="s4">1</span><span class="s3">));</span>

    <span class="s2">if </span><span class="s3">(</span><span class="s1">digitsToString</span><span class="s3">(</span><span class="s1">t</span><span class="s3">.</span><span class="s1">d</span><span class="s3">).</span><span class="s1">slice</span><span class="s3">(</span><span class="s4">0</span><span class="s3">, </span><span class="s1">wpr</span><span class="s3">) === </span><span class="s1">digitsToString</span><span class="s3">(</span><span class="s1">sum</span><span class="s3">.</span><span class="s1">d</span><span class="s3">).</span><span class="s1">slice</span><span class="s3">(</span><span class="s4">0</span><span class="s3">, </span><span class="s1">wpr</span><span class="s3">)) {</span>
      <span class="s1">sum </span><span class="s3">= </span><span class="s1">sum</span><span class="s3">.</span><span class="s1">times</span><span class="s3">(</span><span class="s4">2</span><span class="s3">);</span>

      <span class="s0">// Reverse the argument reduction. Check that e is not 0 because, besides preventing an</span>
      <span class="s0">// unnecessary calculation, -0 + 0 = +0 and to ensure correct rounding -0 needs to stay -0.</span>
      <span class="s2">if </span><span class="s3">(</span><span class="s1">e </span><span class="s3">!== </span><span class="s4">0</span><span class="s3">) </span><span class="s1">sum </span><span class="s3">= </span><span class="s1">sum</span><span class="s3">.</span><span class="s1">plus</span><span class="s3">(</span><span class="s1">getLn10</span><span class="s3">(</span><span class="s1">Ctor</span><span class="s3">, </span><span class="s1">wpr </span><span class="s3">+ </span><span class="s4">2</span><span class="s3">, </span><span class="s1">pr</span><span class="s3">).</span><span class="s1">times</span><span class="s3">(</span><span class="s1">e </span><span class="s3">+ </span><span class="s5">''</span><span class="s3">));</span>
      <span class="s1">sum </span><span class="s3">= </span><span class="s1">divide</span><span class="s3">(</span><span class="s1">sum</span><span class="s3">, </span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">n</span><span class="s3">), </span><span class="s1">wpr</span><span class="s3">, </span><span class="s4">1</span><span class="s3">);</span>

      <span class="s0">// Is rm &gt; 3 and the first 4 rounding digits 4999, or rm &lt; 4 (or the summation has</span>
      <span class="s0">// been repeated previously) and the first 4 rounding digits 9999?</span>
      <span class="s0">// If so, restart the summation with a higher precision, otherwise</span>
      <span class="s0">// e.g. with precision: 12, rounding: 1</span>
      <span class="s0">// ln(135520028.6126091714265381533) = 18.7246299999 when it should be 18.72463.</span>
      <span class="s0">// `wpr - guard` is the index of first rounding digit.</span>
      <span class="s2">if </span><span class="s3">(</span><span class="s1">sd </span><span class="s3">== </span><span class="s2">null</span><span class="s3">) {</span>
        <span class="s2">if </span><span class="s3">(</span><span class="s1">checkRoundingDigits</span><span class="s3">(</span><span class="s1">sum</span><span class="s3">.</span><span class="s1">d</span><span class="s3">, </span><span class="s1">wpr </span><span class="s3">- </span><span class="s1">guard</span><span class="s3">, </span><span class="s1">rm</span><span class="s3">, </span><span class="s1">rep</span><span class="s3">)) {</span>
          <span class="s1">Ctor</span><span class="s3">.</span><span class="s1">precision </span><span class="s3">= </span><span class="s1">wpr </span><span class="s3">+= </span><span class="s1">guard</span><span class="s3">;</span>
          <span class="s1">t </span><span class="s3">= </span><span class="s1">numerator </span><span class="s3">= </span><span class="s1">x </span><span class="s3">= </span><span class="s1">divide</span><span class="s3">(</span><span class="s1">x1</span><span class="s3">.</span><span class="s1">minus</span><span class="s3">(</span><span class="s4">1</span><span class="s3">), </span><span class="s1">x1</span><span class="s3">.</span><span class="s1">plus</span><span class="s3">(</span><span class="s4">1</span><span class="s3">), </span><span class="s1">wpr</span><span class="s3">, </span><span class="s4">1</span><span class="s3">);</span>
          <span class="s1">x2 </span><span class="s3">= </span><span class="s1">finalise</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">times</span><span class="s3">(</span><span class="s1">x</span><span class="s3">), </span><span class="s1">wpr</span><span class="s3">, </span><span class="s4">1</span><span class="s3">);</span>
          <span class="s1">denominator </span><span class="s3">= </span><span class="s1">rep </span><span class="s3">= </span><span class="s4">1</span><span class="s3">;</span>
        <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
          <span class="s2">return </span><span class="s1">finalise</span><span class="s3">(</span><span class="s1">sum</span><span class="s3">, </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">precision </span><span class="s3">= </span><span class="s1">pr</span><span class="s3">, </span><span class="s1">rm</span><span class="s3">, </span><span class="s1">external </span><span class="s3">= </span><span class="s2">true</span><span class="s3">);</span>
        <span class="s3">}</span>
      <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
        <span class="s1">Ctor</span><span class="s3">.</span><span class="s1">precision </span><span class="s3">= </span><span class="s1">pr</span><span class="s3">;</span>
        <span class="s2">return </span><span class="s1">sum</span><span class="s3">;</span>
      <span class="s3">}</span>
    <span class="s3">}</span>

    <span class="s1">sum </span><span class="s3">= </span><span class="s1">t</span><span class="s3">;</span>
    <span class="s1">denominator </span><span class="s3">+= </span><span class="s4">2</span><span class="s3">;</span>
  <span class="s3">}</span>
<span class="s3">}</span>


<span class="s0">// Â±Infinity, NaN.</span>
<span class="s2">function </span><span class="s1">nonFiniteToString</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) {</span>
  <span class="s0">// Unsigned.</span>
  <span class="s2">return </span><span class="s1">String</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">s </span><span class="s3">* </span><span class="s1">x</span><span class="s3">.</span><span class="s1">s </span><span class="s3">/ </span><span class="s4">0</span><span class="s3">);</span>
<span class="s3">}</span>


<span class="s0">/* 
 * Parse the value of a new Decimal `x` from string `str`. 
 */</span>
<span class="s2">function </span><span class="s1">parseDecimal</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">str</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">e</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">len</span><span class="s3">;</span>

  <span class="s0">// TODO BigInt str: no need to check for decimal point, exponential form or leading zeros.</span>
  <span class="s0">// Decimal point?</span>
  <span class="s2">if </span><span class="s3">((</span><span class="s1">e </span><span class="s3">= </span><span class="s1">str</span><span class="s3">.</span><span class="s1">indexOf</span><span class="s3">(</span><span class="s5">'.'</span><span class="s3">)) &gt; -</span><span class="s4">1</span><span class="s3">) </span><span class="s1">str </span><span class="s3">= </span><span class="s1">str</span><span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span><span class="s5">'.'</span><span class="s3">, </span><span class="s5">''</span><span class="s3">);</span>

  <span class="s0">// Exponential form?</span>
  <span class="s2">if </span><span class="s3">((</span><span class="s1">i </span><span class="s3">= </span><span class="s1">str</span><span class="s3">.</span><span class="s1">search</span><span class="s3">(</span><span class="s6">/e/i</span><span class="s3">)) &gt; </span><span class="s4">0</span><span class="s3">) {</span>

    <span class="s0">// Determine exponent.</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">e </span><span class="s3">&lt; </span><span class="s4">0</span><span class="s3">) </span><span class="s1">e </span><span class="s3">= </span><span class="s1">i</span><span class="s3">;</span>
    <span class="s1">e </span><span class="s3">+= +</span><span class="s1">str</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span><span class="s1">i </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">);</span>
    <span class="s1">str </span><span class="s3">= </span><span class="s1">str</span><span class="s3">.</span><span class="s1">substring</span><span class="s3">(</span><span class="s4">0</span><span class="s3">, </span><span class="s1">i</span><span class="s3">);</span>
  <span class="s3">} </span><span class="s2">else if </span><span class="s3">(</span><span class="s1">e </span><span class="s3">&lt; </span><span class="s4">0</span><span class="s3">) {</span>

    <span class="s0">// Integer.</span>
    <span class="s1">e </span><span class="s3">= </span><span class="s1">str</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span>
  <span class="s3">}</span>

  <span class="s0">// Determine leading zeros.</span>
  <span class="s2">for </span><span class="s3">(</span><span class="s1">i </span><span class="s3">= </span><span class="s4">0</span><span class="s3">; </span><span class="s1">str</span><span class="s3">.</span><span class="s1">charCodeAt</span><span class="s3">(</span><span class="s1">i</span><span class="s3">) === </span><span class="s4">48</span><span class="s3">; </span><span class="s1">i</span><span class="s3">++);</span>

  <span class="s0">// Determine trailing zeros.</span>
  <span class="s2">for </span><span class="s3">(</span><span class="s1">len </span><span class="s3">= </span><span class="s1">str</span><span class="s3">.</span><span class="s1">length</span><span class="s3">; </span><span class="s1">str</span><span class="s3">.</span><span class="s1">charCodeAt</span><span class="s3">(</span><span class="s1">len </span><span class="s3">- </span><span class="s4">1</span><span class="s3">) === </span><span class="s4">48</span><span class="s3">; --</span><span class="s1">len</span><span class="s3">);</span>
  <span class="s1">str </span><span class="s3">= </span><span class="s1">str</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span><span class="s1">i</span><span class="s3">, </span><span class="s1">len</span><span class="s3">);</span>

  <span class="s2">if </span><span class="s3">(</span><span class="s1">str</span><span class="s3">) {</span>
    <span class="s1">len </span><span class="s3">-= </span><span class="s1">i</span><span class="s3">;</span>
    <span class="s1">x</span><span class="s3">.</span><span class="s1">e </span><span class="s3">= </span><span class="s1">e </span><span class="s3">= </span><span class="s1">e </span><span class="s3">- </span><span class="s1">i </span><span class="s3">- </span><span class="s4">1</span><span class="s3">;</span>
    <span class="s1">x</span><span class="s3">.</span><span class="s1">d </span><span class="s3">= [];</span>

    <span class="s0">// Transform base</span>

    <span class="s0">// e is the base 10 exponent.</span>
    <span class="s0">// i is where to slice str to get the first word of the digits array.</span>
    <span class="s1">i </span><span class="s3">= (</span><span class="s1">e </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">) % </span><span class="s1">LOG_BASE</span><span class="s3">;</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">e </span><span class="s3">&lt; </span><span class="s4">0</span><span class="s3">) </span><span class="s1">i </span><span class="s3">+= </span><span class="s1">LOG_BASE</span><span class="s3">;</span>

    <span class="s2">if </span><span class="s3">(</span><span class="s1">i </span><span class="s3">&lt; </span><span class="s1">len</span><span class="s3">) {</span>
      <span class="s2">if </span><span class="s3">(</span><span class="s1">i</span><span class="s3">) </span><span class="s1">x</span><span class="s3">.</span><span class="s1">d</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(+</span><span class="s1">str</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span><span class="s4">0</span><span class="s3">, </span><span class="s1">i</span><span class="s3">));</span>
      <span class="s2">for </span><span class="s3">(</span><span class="s1">len </span><span class="s3">-= </span><span class="s1">LOG_BASE</span><span class="s3">; </span><span class="s1">i </span><span class="s3">&lt; </span><span class="s1">len</span><span class="s3">;) </span><span class="s1">x</span><span class="s3">.</span><span class="s1">d</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(+</span><span class="s1">str</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span><span class="s1">i</span><span class="s3">, </span><span class="s1">i </span><span class="s3">+= </span><span class="s1">LOG_BASE</span><span class="s3">));</span>
      <span class="s1">str </span><span class="s3">= </span><span class="s1">str</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span><span class="s1">i</span><span class="s3">);</span>
      <span class="s1">i </span><span class="s3">= </span><span class="s1">LOG_BASE </span><span class="s3">- </span><span class="s1">str</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span>
    <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
      <span class="s1">i </span><span class="s3">-= </span><span class="s1">len</span><span class="s3">;</span>
    <span class="s3">}</span>

    <span class="s2">for </span><span class="s3">(; </span><span class="s1">i</span><span class="s3">--;) </span><span class="s1">str </span><span class="s3">+= </span><span class="s5">'0'</span><span class="s3">;</span>
    <span class="s1">x</span><span class="s3">.</span><span class="s1">d</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(+</span><span class="s1">str</span><span class="s3">);</span>

    <span class="s2">if </span><span class="s3">(</span><span class="s1">external</span><span class="s3">) {</span>

      <span class="s0">// Overflow?</span>
      <span class="s2">if </span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">e </span><span class="s3">&gt; </span><span class="s1">x</span><span class="s3">.</span><span class="s1">constructor</span><span class="s3">.</span><span class="s1">maxE</span><span class="s3">) {</span>

        <span class="s0">// Infinity.</span>
        <span class="s1">x</span><span class="s3">.</span><span class="s1">d </span><span class="s3">= </span><span class="s2">null</span><span class="s3">;</span>
        <span class="s1">x</span><span class="s3">.</span><span class="s1">e </span><span class="s3">= </span><span class="s1">NaN</span><span class="s3">;</span>

      <span class="s0">// Underflow?</span>
      <span class="s3">} </span><span class="s2">else if </span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">e </span><span class="s3">&lt; </span><span class="s1">x</span><span class="s3">.</span><span class="s1">constructor</span><span class="s3">.</span><span class="s1">minE</span><span class="s3">) {</span>

        <span class="s0">// Zero.</span>
        <span class="s1">x</span><span class="s3">.</span><span class="s1">e </span><span class="s3">= </span><span class="s4">0</span><span class="s3">;</span>
        <span class="s1">x</span><span class="s3">.</span><span class="s1">d </span><span class="s3">= [</span><span class="s4">0</span><span class="s3">];</span>
        <span class="s0">// x.constructor.underflow = true;</span>
      <span class="s3">} </span><span class="s0">// else x.constructor.underflow = false;</span>
    <span class="s3">}</span>
  <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>

    <span class="s0">// Zero.</span>
    <span class="s1">x</span><span class="s3">.</span><span class="s1">e </span><span class="s3">= </span><span class="s4">0</span><span class="s3">;</span>
    <span class="s1">x</span><span class="s3">.</span><span class="s1">d </span><span class="s3">= [</span><span class="s4">0</span><span class="s3">];</span>
  <span class="s3">}</span>

  <span class="s2">return </span><span class="s1">x</span><span class="s3">;</span>
<span class="s3">}</span>


<span class="s0">/* 
 * Parse the value of a new Decimal `x` from a string `str`, which is not a decimal value. 
 */</span>
<span class="s2">function </span><span class="s1">parseOther</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">str</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">base</span><span class="s3">, </span><span class="s1">Ctor</span><span class="s3">, </span><span class="s1">divisor</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">isFloat</span><span class="s3">, </span><span class="s1">len</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">xd</span><span class="s3">, </span><span class="s1">xe</span><span class="s3">;</span>

  <span class="s2">if </span><span class="s3">(</span><span class="s1">str</span><span class="s3">.</span><span class="s1">indexOf</span><span class="s3">(</span><span class="s5">'_'</span><span class="s3">) &gt; -</span><span class="s4">1</span><span class="s3">) {</span>
    <span class="s1">str </span><span class="s3">= </span><span class="s1">str</span><span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span><span class="s6">/(\d)_(?=\d)/g</span><span class="s3">, </span><span class="s5">'$1'</span><span class="s3">);</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">isDecimal</span><span class="s3">.</span><span class="s1">test</span><span class="s3">(</span><span class="s1">str</span><span class="s3">)) </span><span class="s2">return </span><span class="s1">parseDecimal</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">str</span><span class="s3">);</span>
  <span class="s3">} </span><span class="s2">else if </span><span class="s3">(</span><span class="s1">str </span><span class="s3">=== </span><span class="s5">'Infinity' </span><span class="s3">|| </span><span class="s1">str </span><span class="s3">=== </span><span class="s5">'NaN'</span><span class="s3">) {</span>
    <span class="s2">if </span><span class="s3">(!+</span><span class="s1">str</span><span class="s3">) </span><span class="s1">x</span><span class="s3">.</span><span class="s1">s </span><span class="s3">= </span><span class="s1">NaN</span><span class="s3">;</span>
    <span class="s1">x</span><span class="s3">.</span><span class="s1">e </span><span class="s3">= </span><span class="s1">NaN</span><span class="s3">;</span>
    <span class="s1">x</span><span class="s3">.</span><span class="s1">d </span><span class="s3">= </span><span class="s2">null</span><span class="s3">;</span>
    <span class="s2">return </span><span class="s1">x</span><span class="s3">;</span>
  <span class="s3">}</span>

  <span class="s2">if </span><span class="s3">(</span><span class="s1">isHex</span><span class="s3">.</span><span class="s1">test</span><span class="s3">(</span><span class="s1">str</span><span class="s3">))  {</span>
    <span class="s1">base </span><span class="s3">= </span><span class="s4">16</span><span class="s3">;</span>
    <span class="s1">str </span><span class="s3">= </span><span class="s1">str</span><span class="s3">.</span><span class="s1">toLowerCase</span><span class="s3">();</span>
  <span class="s3">} </span><span class="s2">else if </span><span class="s3">(</span><span class="s1">isBinary</span><span class="s3">.</span><span class="s1">test</span><span class="s3">(</span><span class="s1">str</span><span class="s3">))  {</span>
    <span class="s1">base </span><span class="s3">= </span><span class="s4">2</span><span class="s3">;</span>
  <span class="s3">} </span><span class="s2">else if </span><span class="s3">(</span><span class="s1">isOctal</span><span class="s3">.</span><span class="s1">test</span><span class="s3">(</span><span class="s1">str</span><span class="s3">))  {</span>
    <span class="s1">base </span><span class="s3">= </span><span class="s4">8</span><span class="s3">;</span>
  <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
    <span class="s2">throw </span><span class="s1">Error</span><span class="s3">(</span><span class="s1">invalidArgument </span><span class="s3">+ </span><span class="s1">str</span><span class="s3">);</span>
  <span class="s3">}</span>

  <span class="s0">// Is there a binary exponent part?</span>
  <span class="s1">i </span><span class="s3">= </span><span class="s1">str</span><span class="s3">.</span><span class="s1">search</span><span class="s3">(</span><span class="s6">/p/i</span><span class="s3">);</span>

  <span class="s2">if </span><span class="s3">(</span><span class="s1">i </span><span class="s3">&gt; </span><span class="s4">0</span><span class="s3">) {</span>
    <span class="s1">p </span><span class="s3">= +</span><span class="s1">str</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span><span class="s1">i </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">);</span>
    <span class="s1">str </span><span class="s3">= </span><span class="s1">str</span><span class="s3">.</span><span class="s1">substring</span><span class="s3">(</span><span class="s4">2</span><span class="s3">, </span><span class="s1">i</span><span class="s3">);</span>
  <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
    <span class="s1">str </span><span class="s3">= </span><span class="s1">str</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span><span class="s4">2</span><span class="s3">);</span>
  <span class="s3">}</span>

  <span class="s0">// Convert `str` as an integer then divide the result by `base` raised to a power such that the</span>
  <span class="s0">// fraction part will be restored.</span>
  <span class="s1">i </span><span class="s3">= </span><span class="s1">str</span><span class="s3">.</span><span class="s1">indexOf</span><span class="s3">(</span><span class="s5">'.'</span><span class="s3">);</span>
  <span class="s1">isFloat </span><span class="s3">= </span><span class="s1">i </span><span class="s3">&gt;= </span><span class="s4">0</span><span class="s3">;</span>
  <span class="s1">Ctor </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">constructor</span><span class="s3">;</span>

  <span class="s2">if </span><span class="s3">(</span><span class="s1">isFloat</span><span class="s3">) {</span>
    <span class="s1">str </span><span class="s3">= </span><span class="s1">str</span><span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span><span class="s5">'.'</span><span class="s3">, </span><span class="s5">''</span><span class="s3">);</span>
    <span class="s1">len </span><span class="s3">= </span><span class="s1">str</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span>
    <span class="s1">i </span><span class="s3">= </span><span class="s1">len </span><span class="s3">- </span><span class="s1">i</span><span class="s3">;</span>

    <span class="s0">// log[10](16) = 1.2041... , log[10](88) = 1.9444....</span>
    <span class="s1">divisor </span><span class="s3">= </span><span class="s1">intPow</span><span class="s3">(</span><span class="s1">Ctor</span><span class="s3">, </span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">base</span><span class="s3">), </span><span class="s1">i</span><span class="s3">, </span><span class="s1">i </span><span class="s3">* </span><span class="s4">2</span><span class="s3">);</span>
  <span class="s3">}</span>

  <span class="s1">xd </span><span class="s3">= </span><span class="s1">convertBase</span><span class="s3">(</span><span class="s1">str</span><span class="s3">, </span><span class="s1">base</span><span class="s3">, </span><span class="s1">BASE</span><span class="s3">);</span>
  <span class="s1">xe </span><span class="s3">= </span><span class="s1">xd</span><span class="s3">.</span><span class="s1">length </span><span class="s3">- </span><span class="s4">1</span><span class="s3">;</span>

  <span class="s0">// Remove trailing zeros.</span>
  <span class="s2">for </span><span class="s3">(</span><span class="s1">i </span><span class="s3">= </span><span class="s1">xe</span><span class="s3">; </span><span class="s1">xd</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] === </span><span class="s4">0</span><span class="s3">; --</span><span class="s1">i</span><span class="s3">) </span><span class="s1">xd</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">();</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">i </span><span class="s3">&lt; </span><span class="s4">0</span><span class="s3">) </span><span class="s2">return new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">s </span><span class="s3">* </span><span class="s4">0</span><span class="s3">);</span>
  <span class="s1">x</span><span class="s3">.</span><span class="s1">e </span><span class="s3">= </span><span class="s1">getBase10Exponent</span><span class="s3">(</span><span class="s1">xd</span><span class="s3">, </span><span class="s1">xe</span><span class="s3">);</span>
  <span class="s1">x</span><span class="s3">.</span><span class="s1">d </span><span class="s3">= </span><span class="s1">xd</span><span class="s3">;</span>
  <span class="s1">external </span><span class="s3">= </span><span class="s2">false</span><span class="s3">;</span>

  <span class="s0">// At what precision to perform the division to ensure exact conversion?</span>
  <span class="s0">// maxDecimalIntegerPartDigitCount = ceil(log[10](b) * otherBaseIntegerPartDigitCount)</span>
  <span class="s0">// log[10](2) = 0.30103, log[10](8) = 0.90309, log[10](16) = 1.20412</span>
  <span class="s0">// E.g. ceil(1.2 * 3) = 4, so up to 4 decimal digits are needed to represent 3 hex int digits.</span>
  <span class="s0">// maxDecimalFractionPartDigitCount = {Hex:4|Oct:3|Bin:1} * otherBaseFractionPartDigitCount</span>
  <span class="s0">// Therefore using 4 * the number of digits of str will always be enough.</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">isFloat</span><span class="s3">) </span><span class="s1">x </span><span class="s3">= </span><span class="s1">divide</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">divisor</span><span class="s3">, </span><span class="s1">len </span><span class="s3">* </span><span class="s4">4</span><span class="s3">);</span>

  <span class="s0">// Multiply by the binary exponent part if present.</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">p</span><span class="s3">) </span><span class="s1">x </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">times</span><span class="s3">(</span><span class="s1">Math</span><span class="s3">.</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">p</span><span class="s3">) &lt; </span><span class="s4">54 </span><span class="s3">? </span><span class="s1">mathpow</span><span class="s3">(</span><span class="s4">2</span><span class="s3">, </span><span class="s1">p</span><span class="s3">) : </span><span class="s1">Decimal</span><span class="s3">.</span><span class="s1">pow</span><span class="s3">(</span><span class="s4">2</span><span class="s3">, </span><span class="s1">p</span><span class="s3">));</span>
  <span class="s1">external </span><span class="s3">= </span><span class="s2">true</span><span class="s3">;</span>

  <span class="s2">return </span><span class="s1">x</span><span class="s3">;</span>
<span class="s3">}</span>


<span class="s0">/* 
 * sin(x) = x - x^3/3! + x^5/5! - ... 
 * |x| &lt; pi/2 
 * 
 */</span>
<span class="s2">function </span><span class="s1">sine</span><span class="s3">(</span><span class="s1">Ctor</span><span class="s3">, </span><span class="s1">x</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">k</span><span class="s3">,</span>
    <span class="s1">len </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">d</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span>

  <span class="s2">if </span><span class="s3">(</span><span class="s1">len </span><span class="s3">&lt; </span><span class="s4">3</span><span class="s3">) {</span>
    <span class="s2">return </span><span class="s1">x</span><span class="s3">.</span><span class="s1">isZero</span><span class="s3">() ? </span><span class="s1">x </span><span class="s3">: </span><span class="s1">taylorSeries</span><span class="s3">(</span><span class="s1">Ctor</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">x</span><span class="s3">);</span>
  <span class="s3">}</span>

  <span class="s0">// Argument reduction: sin(5x) = 16*sin^5(x) - 20*sin^3(x) + 5*sin(x)</span>
  <span class="s0">// i.e. sin(x) = 16*sin^5(x/5) - 20*sin^3(x/5) + 5*sin(x/5)</span>
  <span class="s0">// and  sin(x) = sin(x/5)(5 + sin^2(x/5)(16sin^2(x/5) - 20))</span>

  <span class="s0">// Estimate the optimum number of times to use the argument reduction.</span>
  <span class="s1">k </span><span class="s3">= </span><span class="s4">1.4 </span><span class="s3">* </span><span class="s1">Math</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">len</span><span class="s3">);</span>
  <span class="s1">k </span><span class="s3">= </span><span class="s1">k </span><span class="s3">&gt; </span><span class="s4">16 </span><span class="s3">? </span><span class="s4">16 </span><span class="s3">: </span><span class="s1">k </span><span class="s3">| </span><span class="s4">0</span><span class="s3">;</span>

  <span class="s1">x </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">times</span><span class="s3">(</span><span class="s4">1 </span><span class="s3">/ </span><span class="s1">tinyPow</span><span class="s3">(</span><span class="s4">5</span><span class="s3">, </span><span class="s1">k</span><span class="s3">));</span>
  <span class="s1">x </span><span class="s3">= </span><span class="s1">taylorSeries</span><span class="s3">(</span><span class="s1">Ctor</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">x</span><span class="s3">);</span>

  <span class="s0">// Reverse argument reduction</span>
  <span class="s2">var </span><span class="s1">sin2_x</span><span class="s3">,</span>
    <span class="s1">d5 </span><span class="s3">= </span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s4">5</span><span class="s3">),</span>
    <span class="s1">d16 </span><span class="s3">= </span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s4">16</span><span class="s3">),</span>
    <span class="s1">d20 </span><span class="s3">= </span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s4">20</span><span class="s3">);</span>
  <span class="s2">for </span><span class="s3">(; </span><span class="s1">k</span><span class="s3">--;) {</span>
    <span class="s1">sin2_x </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">times</span><span class="s3">(</span><span class="s1">x</span><span class="s3">);</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">times</span><span class="s3">(</span><span class="s1">d5</span><span class="s3">.</span><span class="s1">plus</span><span class="s3">(</span><span class="s1">sin2_x</span><span class="s3">.</span><span class="s1">times</span><span class="s3">(</span><span class="s1">d16</span><span class="s3">.</span><span class="s1">times</span><span class="s3">(</span><span class="s1">sin2_x</span><span class="s3">).</span><span class="s1">minus</span><span class="s3">(</span><span class="s1">d20</span><span class="s3">))));</span>
  <span class="s3">}</span>

  <span class="s2">return </span><span class="s1">x</span><span class="s3">;</span>
<span class="s3">}</span>


<span class="s0">// Calculate Taylor series for `cos`, `cosh`, `sin` and `sinh`.</span>
<span class="s2">function </span><span class="s1">taylorSeries</span><span class="s3">(</span><span class="s1">Ctor</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">isHyperbolic</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">j</span><span class="s3">, </span><span class="s1">t</span><span class="s3">, </span><span class="s1">u</span><span class="s3">, </span><span class="s1">x2</span><span class="s3">,</span>
    <span class="s1">i </span><span class="s3">= </span><span class="s4">1</span><span class="s3">,</span>
    <span class="s1">pr </span><span class="s3">= </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">precision</span><span class="s3">,</span>
    <span class="s1">k </span><span class="s3">= </span><span class="s1">Math</span><span class="s3">.</span><span class="s1">ceil</span><span class="s3">(</span><span class="s1">pr </span><span class="s3">/ </span><span class="s1">LOG_BASE</span><span class="s3">);</span>

  <span class="s1">external </span><span class="s3">= </span><span class="s2">false</span><span class="s3">;</span>
  <span class="s1">x2 </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">times</span><span class="s3">(</span><span class="s1">x</span><span class="s3">);</span>
  <span class="s1">u </span><span class="s3">= </span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">y</span><span class="s3">);</span>

  <span class="s2">for </span><span class="s3">(;;) {</span>
    <span class="s1">t </span><span class="s3">= </span><span class="s1">divide</span><span class="s3">(</span><span class="s1">u</span><span class="s3">.</span><span class="s1">times</span><span class="s3">(</span><span class="s1">x2</span><span class="s3">), </span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">n</span><span class="s3">++ * </span><span class="s1">n</span><span class="s3">++), </span><span class="s1">pr</span><span class="s3">, </span><span class="s4">1</span><span class="s3">);</span>
    <span class="s1">u </span><span class="s3">= </span><span class="s1">isHyperbolic </span><span class="s3">? </span><span class="s1">y</span><span class="s3">.</span><span class="s1">plus</span><span class="s3">(</span><span class="s1">t</span><span class="s3">) : </span><span class="s1">y</span><span class="s3">.</span><span class="s1">minus</span><span class="s3">(</span><span class="s1">t</span><span class="s3">);</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">divide</span><span class="s3">(</span><span class="s1">t</span><span class="s3">.</span><span class="s1">times</span><span class="s3">(</span><span class="s1">x2</span><span class="s3">), </span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">n</span><span class="s3">++ * </span><span class="s1">n</span><span class="s3">++), </span><span class="s1">pr</span><span class="s3">, </span><span class="s4">1</span><span class="s3">);</span>
    <span class="s1">t </span><span class="s3">= </span><span class="s1">u</span><span class="s3">.</span><span class="s1">plus</span><span class="s3">(</span><span class="s1">y</span><span class="s3">);</span>

    <span class="s2">if </span><span class="s3">(</span><span class="s1">t</span><span class="s3">.</span><span class="s1">d</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] !== </span><span class="s2">void </span><span class="s4">0</span><span class="s3">) {</span>
      <span class="s2">for </span><span class="s3">(</span><span class="s1">j </span><span class="s3">= </span><span class="s1">k</span><span class="s3">; </span><span class="s1">t</span><span class="s3">.</span><span class="s1">d</span><span class="s3">[</span><span class="s1">j</span><span class="s3">] === </span><span class="s1">u</span><span class="s3">.</span><span class="s1">d</span><span class="s3">[</span><span class="s1">j</span><span class="s3">] &amp;&amp; </span><span class="s1">j</span><span class="s3">--;);</span>
      <span class="s2">if </span><span class="s3">(</span><span class="s1">j </span><span class="s3">== -</span><span class="s4">1</span><span class="s3">) </span><span class="s2">break</span><span class="s3">;</span>
    <span class="s3">}</span>

    <span class="s1">j </span><span class="s3">= </span><span class="s1">u</span><span class="s3">;</span>
    <span class="s1">u </span><span class="s3">= </span><span class="s1">y</span><span class="s3">;</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">t</span><span class="s3">;</span>
    <span class="s1">t </span><span class="s3">= </span><span class="s1">j</span><span class="s3">;</span>
    <span class="s1">i</span><span class="s3">++;</span>
  <span class="s3">}</span>

  <span class="s1">external </span><span class="s3">= </span><span class="s2">true</span><span class="s3">;</span>
  <span class="s1">t</span><span class="s3">.</span><span class="s1">d</span><span class="s3">.</span><span class="s1">length </span><span class="s3">= </span><span class="s1">k </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">;</span>

  <span class="s2">return </span><span class="s1">t</span><span class="s3">;</span>
<span class="s3">}</span>


<span class="s0">// Exponent e must be positive and non-zero.</span>
<span class="s2">function </span><span class="s1">tinyPow</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">e</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">n </span><span class="s3">= </span><span class="s1">b</span><span class="s3">;</span>
  <span class="s2">while </span><span class="s3">(--</span><span class="s1">e</span><span class="s3">) </span><span class="s1">n </span><span class="s3">*= </span><span class="s1">b</span><span class="s3">;</span>
  <span class="s2">return </span><span class="s1">n</span><span class="s3">;</span>
<span class="s3">}</span>


<span class="s0">// Return the absolute value of `x` reduced to less than or equal to half pi.</span>
<span class="s2">function </span><span class="s1">toLessThanHalfPi</span><span class="s3">(</span><span class="s1">Ctor</span><span class="s3">, </span><span class="s1">x</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">t</span><span class="s3">,</span>
    <span class="s1">isNeg </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">s </span><span class="s3">&lt; </span><span class="s4">0</span><span class="s3">,</span>
    <span class="s1">pi </span><span class="s3">= </span><span class="s1">getPi</span><span class="s3">(</span><span class="s1">Ctor</span><span class="s3">, </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">precision</span><span class="s3">, </span><span class="s4">1</span><span class="s3">),</span>
    <span class="s1">halfPi </span><span class="s3">= </span><span class="s1">pi</span><span class="s3">.</span><span class="s1">times</span><span class="s3">(</span><span class="s4">0.5</span><span class="s3">);</span>

  <span class="s1">x </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">abs</span><span class="s3">();</span>

  <span class="s2">if </span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">lte</span><span class="s3">(</span><span class="s1">halfPi</span><span class="s3">)) {</span>
    <span class="s1">quadrant </span><span class="s3">= </span><span class="s1">isNeg </span><span class="s3">? </span><span class="s4">4 </span><span class="s3">: </span><span class="s4">1</span><span class="s3">;</span>
    <span class="s2">return </span><span class="s1">x</span><span class="s3">;</span>
  <span class="s3">}</span>

  <span class="s1">t </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">divToInt</span><span class="s3">(</span><span class="s1">pi</span><span class="s3">);</span>

  <span class="s2">if </span><span class="s3">(</span><span class="s1">t</span><span class="s3">.</span><span class="s1">isZero</span><span class="s3">()) {</span>
    <span class="s1">quadrant </span><span class="s3">= </span><span class="s1">isNeg </span><span class="s3">? </span><span class="s4">3 </span><span class="s3">: </span><span class="s4">2</span><span class="s3">;</span>
  <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">minus</span><span class="s3">(</span><span class="s1">t</span><span class="s3">.</span><span class="s1">times</span><span class="s3">(</span><span class="s1">pi</span><span class="s3">));</span>

    <span class="s0">// 0 &lt;= x &lt; pi</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">lte</span><span class="s3">(</span><span class="s1">halfPi</span><span class="s3">)) {</span>
      <span class="s1">quadrant </span><span class="s3">= </span><span class="s1">isOdd</span><span class="s3">(</span><span class="s1">t</span><span class="s3">) ? (</span><span class="s1">isNeg </span><span class="s3">? </span><span class="s4">2 </span><span class="s3">: </span><span class="s4">3</span><span class="s3">) : (</span><span class="s1">isNeg </span><span class="s3">? </span><span class="s4">4 </span><span class="s3">: </span><span class="s4">1</span><span class="s3">);</span>
      <span class="s2">return </span><span class="s1">x</span><span class="s3">;</span>
    <span class="s3">}</span>

    <span class="s1">quadrant </span><span class="s3">= </span><span class="s1">isOdd</span><span class="s3">(</span><span class="s1">t</span><span class="s3">) ? (</span><span class="s1">isNeg </span><span class="s3">? </span><span class="s4">1 </span><span class="s3">: </span><span class="s4">4</span><span class="s3">) : (</span><span class="s1">isNeg </span><span class="s3">? </span><span class="s4">3 </span><span class="s3">: </span><span class="s4">2</span><span class="s3">);</span>
  <span class="s3">}</span>

  <span class="s2">return </span><span class="s1">x</span><span class="s3">.</span><span class="s1">minus</span><span class="s3">(</span><span class="s1">pi</span><span class="s3">).</span><span class="s1">abs</span><span class="s3">();</span>
<span class="s3">}</span>


<span class="s0">/* 
 * Return the value of Decimal `x` as a string in base `baseOut`. 
 * 
 * If the optional `sd` argument is present include a binary exponent suffix. 
 */</span>
<span class="s2">function </span><span class="s1">toStringBinary</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">baseOut</span><span class="s3">, </span><span class="s1">sd</span><span class="s3">, </span><span class="s1">rm</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">base</span><span class="s3">, </span><span class="s1">e</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">len</span><span class="s3">, </span><span class="s1">roundUp</span><span class="s3">, </span><span class="s1">str</span><span class="s3">, </span><span class="s1">xd</span><span class="s3">, </span><span class="s1">y</span><span class="s3">,</span>
    <span class="s1">Ctor </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">constructor</span><span class="s3">,</span>
    <span class="s1">isExp </span><span class="s3">= </span><span class="s1">sd </span><span class="s3">!== </span><span class="s2">void </span><span class="s4">0</span><span class="s3">;</span>

  <span class="s2">if </span><span class="s3">(</span><span class="s1">isExp</span><span class="s3">) {</span>
    <span class="s1">checkInt32</span><span class="s3">(</span><span class="s1">sd</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s1">MAX_DIGITS</span><span class="s3">);</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">rm </span><span class="s3">=== </span><span class="s2">void </span><span class="s4">0</span><span class="s3">) </span><span class="s1">rm </span><span class="s3">= </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">rounding</span><span class="s3">;</span>
    <span class="s2">else </span><span class="s1">checkInt32</span><span class="s3">(</span><span class="s1">rm</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">8</span><span class="s3">);</span>
  <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
    <span class="s1">sd </span><span class="s3">= </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">precision</span><span class="s3">;</span>
    <span class="s1">rm </span><span class="s3">= </span><span class="s1">Ctor</span><span class="s3">.</span><span class="s1">rounding</span><span class="s3">;</span>
  <span class="s3">}</span>

  <span class="s2">if </span><span class="s3">(!</span><span class="s1">x</span><span class="s3">.</span><span class="s1">isFinite</span><span class="s3">()) {</span>
    <span class="s1">str </span><span class="s3">= </span><span class="s1">nonFiniteToString</span><span class="s3">(</span><span class="s1">x</span><span class="s3">);</span>
  <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
    <span class="s1">str </span><span class="s3">= </span><span class="s1">finiteToString</span><span class="s3">(</span><span class="s1">x</span><span class="s3">);</span>
    <span class="s1">i </span><span class="s3">= </span><span class="s1">str</span><span class="s3">.</span><span class="s1">indexOf</span><span class="s3">(</span><span class="s5">'.'</span><span class="s3">);</span>

    <span class="s0">// Use exponential notation according to `toExpPos` and `toExpNeg`? No, but if required:</span>
    <span class="s0">// maxBinaryExponent = floor((decimalExponent + 1) * log[2](10))</span>
    <span class="s0">// minBinaryExponent = floor(decimalExponent * log[2](10))</span>
    <span class="s0">// log[2](10) = 3.321928094887362347870319429489390175864</span>

    <span class="s2">if </span><span class="s3">(</span><span class="s1">isExp</span><span class="s3">) {</span>
      <span class="s1">base </span><span class="s3">= </span><span class="s4">2</span><span class="s3">;</span>
      <span class="s2">if </span><span class="s3">(</span><span class="s1">baseOut </span><span class="s3">== </span><span class="s4">16</span><span class="s3">) {</span>
        <span class="s1">sd </span><span class="s3">= </span><span class="s1">sd </span><span class="s3">* </span><span class="s4">4 </span><span class="s3">- </span><span class="s4">3</span><span class="s3">;</span>
      <span class="s3">} </span><span class="s2">else if </span><span class="s3">(</span><span class="s1">baseOut </span><span class="s3">== </span><span class="s4">8</span><span class="s3">) {</span>
        <span class="s1">sd </span><span class="s3">= </span><span class="s1">sd </span><span class="s3">* </span><span class="s4">3 </span><span class="s3">- </span><span class="s4">2</span><span class="s3">;</span>
      <span class="s3">}</span>
    <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
      <span class="s1">base </span><span class="s3">= </span><span class="s1">baseOut</span><span class="s3">;</span>
    <span class="s3">}</span>

    <span class="s0">// Convert the number as an integer then divide the result by its base raised to a power such</span>
    <span class="s0">// that the fraction part will be restored.</span>

    <span class="s0">// Non-integer.</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">i </span><span class="s3">&gt;= </span><span class="s4">0</span><span class="s3">) {</span>
      <span class="s1">str </span><span class="s3">= </span><span class="s1">str</span><span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span><span class="s5">'.'</span><span class="s3">, </span><span class="s5">''</span><span class="s3">);</span>
      <span class="s1">y </span><span class="s3">= </span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s4">1</span><span class="s3">);</span>
      <span class="s1">y</span><span class="s3">.</span><span class="s1">e </span><span class="s3">= </span><span class="s1">str</span><span class="s3">.</span><span class="s1">length </span><span class="s3">- </span><span class="s1">i</span><span class="s3">;</span>
      <span class="s1">y</span><span class="s3">.</span><span class="s1">d </span><span class="s3">= </span><span class="s1">convertBase</span><span class="s3">(</span><span class="s1">finiteToString</span><span class="s3">(</span><span class="s1">y</span><span class="s3">), </span><span class="s4">10</span><span class="s3">, </span><span class="s1">base</span><span class="s3">);</span>
      <span class="s1">y</span><span class="s3">.</span><span class="s1">e </span><span class="s3">= </span><span class="s1">y</span><span class="s3">.</span><span class="s1">d</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span>
    <span class="s3">}</span>

    <span class="s1">xd </span><span class="s3">= </span><span class="s1">convertBase</span><span class="s3">(</span><span class="s1">str</span><span class="s3">, </span><span class="s4">10</span><span class="s3">, </span><span class="s1">base</span><span class="s3">);</span>
    <span class="s1">e </span><span class="s3">= </span><span class="s1">len </span><span class="s3">= </span><span class="s1">xd</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span>

    <span class="s0">// Remove trailing zeros.</span>
    <span class="s2">for </span><span class="s3">(; </span><span class="s1">xd</span><span class="s3">[--</span><span class="s1">len</span><span class="s3">] == </span><span class="s4">0</span><span class="s3">;) </span><span class="s1">xd</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">();</span>

    <span class="s2">if </span><span class="s3">(!</span><span class="s1">xd</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]) {</span>
      <span class="s1">str </span><span class="s3">= </span><span class="s1">isExp </span><span class="s3">? </span><span class="s5">'0p+0' </span><span class="s3">: </span><span class="s5">'0'</span><span class="s3">;</span>
    <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
      <span class="s2">if </span><span class="s3">(</span><span class="s1">i </span><span class="s3">&lt; </span><span class="s4">0</span><span class="s3">) {</span>
        <span class="s1">e</span><span class="s3">--;</span>
      <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
        <span class="s1">x </span><span class="s3">= </span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">(</span><span class="s1">x</span><span class="s3">);</span>
        <span class="s1">x</span><span class="s3">.</span><span class="s1">d </span><span class="s3">= </span><span class="s1">xd</span><span class="s3">;</span>
        <span class="s1">x</span><span class="s3">.</span><span class="s1">e </span><span class="s3">= </span><span class="s1">e</span><span class="s3">;</span>
        <span class="s1">x </span><span class="s3">= </span><span class="s1">divide</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">sd</span><span class="s3">, </span><span class="s1">rm</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s1">base</span><span class="s3">);</span>
        <span class="s1">xd </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">d</span><span class="s3">;</span>
        <span class="s1">e </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">e</span><span class="s3">;</span>
        <span class="s1">roundUp </span><span class="s3">= </span><span class="s1">inexact</span><span class="s3">;</span>
      <span class="s3">}</span>

      <span class="s0">// The rounding digit, i.e. the digit after the digit that may be rounded up.</span>
      <span class="s1">i </span><span class="s3">= </span><span class="s1">xd</span><span class="s3">[</span><span class="s1">sd</span><span class="s3">];</span>
      <span class="s1">k </span><span class="s3">= </span><span class="s1">base </span><span class="s3">/ </span><span class="s4">2</span><span class="s3">;</span>
      <span class="s1">roundUp </span><span class="s3">= </span><span class="s1">roundUp </span><span class="s3">|| </span><span class="s1">xd</span><span class="s3">[</span><span class="s1">sd </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">] !== </span><span class="s2">void </span><span class="s4">0</span><span class="s3">;</span>

      <span class="s1">roundUp </span><span class="s3">= </span><span class="s1">rm </span><span class="s3">&lt; </span><span class="s4">4</span>
        <span class="s3">? (</span><span class="s1">i </span><span class="s3">!== </span><span class="s2">void </span><span class="s4">0 </span><span class="s3">|| </span><span class="s1">roundUp</span><span class="s3">) &amp;&amp; (</span><span class="s1">rm </span><span class="s3">=== </span><span class="s4">0 </span><span class="s3">|| </span><span class="s1">rm </span><span class="s3">=== (</span><span class="s1">x</span><span class="s3">.</span><span class="s1">s </span><span class="s3">&lt; </span><span class="s4">0 </span><span class="s3">? </span><span class="s4">3 </span><span class="s3">: </span><span class="s4">2</span><span class="s3">))</span>
        <span class="s3">: </span><span class="s1">i </span><span class="s3">&gt; </span><span class="s1">k </span><span class="s3">|| </span><span class="s1">i </span><span class="s3">=== </span><span class="s1">k </span><span class="s3">&amp;&amp; (</span><span class="s1">rm </span><span class="s3">=== </span><span class="s4">4 </span><span class="s3">|| </span><span class="s1">roundUp </span><span class="s3">|| </span><span class="s1">rm </span><span class="s3">=== </span><span class="s4">6 </span><span class="s3">&amp;&amp; </span><span class="s1">xd</span><span class="s3">[</span><span class="s1">sd </span><span class="s3">- </span><span class="s4">1</span><span class="s3">] &amp; </span><span class="s4">1 </span><span class="s3">||</span>
          <span class="s1">rm </span><span class="s3">=== (</span><span class="s1">x</span><span class="s3">.</span><span class="s1">s </span><span class="s3">&lt; </span><span class="s4">0 </span><span class="s3">? </span><span class="s4">8 </span><span class="s3">: </span><span class="s4">7</span><span class="s3">));</span>

      <span class="s1">xd</span><span class="s3">.</span><span class="s1">length </span><span class="s3">= </span><span class="s1">sd</span><span class="s3">;</span>

      <span class="s2">if </span><span class="s3">(</span><span class="s1">roundUp</span><span class="s3">) {</span>

        <span class="s0">// Rounding up may mean the previous digit has to be rounded up and so on.</span>
        <span class="s2">for </span><span class="s3">(; ++</span><span class="s1">xd</span><span class="s3">[--</span><span class="s1">sd</span><span class="s3">] &gt; </span><span class="s1">base </span><span class="s3">- </span><span class="s4">1</span><span class="s3">;) {</span>
          <span class="s1">xd</span><span class="s3">[</span><span class="s1">sd</span><span class="s3">] = </span><span class="s4">0</span><span class="s3">;</span>
          <span class="s2">if </span><span class="s3">(!</span><span class="s1">sd</span><span class="s3">) {</span>
            <span class="s3">++</span><span class="s1">e</span><span class="s3">;</span>
            <span class="s1">xd</span><span class="s3">.</span><span class="s1">unshift</span><span class="s3">(</span><span class="s4">1</span><span class="s3">);</span>
          <span class="s3">}</span>
        <span class="s3">}</span>
      <span class="s3">}</span>

      <span class="s0">// Determine trailing zeros.</span>
      <span class="s2">for </span><span class="s3">(</span><span class="s1">len </span><span class="s3">= </span><span class="s1">xd</span><span class="s3">.</span><span class="s1">length</span><span class="s3">; !</span><span class="s1">xd</span><span class="s3">[</span><span class="s1">len </span><span class="s3">- </span><span class="s4">1</span><span class="s3">]; --</span><span class="s1">len</span><span class="s3">);</span>

      <span class="s0">// E.g. [4, 11, 15] becomes 4bf.</span>
      <span class="s2">for </span><span class="s3">(</span><span class="s1">i </span><span class="s3">= </span><span class="s4">0</span><span class="s3">, </span><span class="s1">str </span><span class="s3">= </span><span class="s5">''</span><span class="s3">; </span><span class="s1">i </span><span class="s3">&lt; </span><span class="s1">len</span><span class="s3">; </span><span class="s1">i</span><span class="s3">++) </span><span class="s1">str </span><span class="s3">+= </span><span class="s1">NUMERALS</span><span class="s3">.</span><span class="s1">charAt</span><span class="s3">(</span><span class="s1">xd</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]);</span>

      <span class="s0">// Add binary exponent suffix?</span>
      <span class="s2">if </span><span class="s3">(</span><span class="s1">isExp</span><span class="s3">) {</span>
        <span class="s2">if </span><span class="s3">(</span><span class="s1">len </span><span class="s3">&gt; </span><span class="s4">1</span><span class="s3">) {</span>
          <span class="s2">if </span><span class="s3">(</span><span class="s1">baseOut </span><span class="s3">== </span><span class="s4">16 </span><span class="s3">|| </span><span class="s1">baseOut </span><span class="s3">== </span><span class="s4">8</span><span class="s3">) {</span>
            <span class="s1">i </span><span class="s3">= </span><span class="s1">baseOut </span><span class="s3">== </span><span class="s4">16 </span><span class="s3">? </span><span class="s4">4 </span><span class="s3">: </span><span class="s4">3</span><span class="s3">;</span>
            <span class="s2">for </span><span class="s3">(--</span><span class="s1">len</span><span class="s3">; </span><span class="s1">len </span><span class="s3">% </span><span class="s1">i</span><span class="s3">; </span><span class="s1">len</span><span class="s3">++) </span><span class="s1">str </span><span class="s3">+= </span><span class="s5">'0'</span><span class="s3">;</span>
            <span class="s1">xd </span><span class="s3">= </span><span class="s1">convertBase</span><span class="s3">(</span><span class="s1">str</span><span class="s3">, </span><span class="s1">base</span><span class="s3">, </span><span class="s1">baseOut</span><span class="s3">);</span>
            <span class="s2">for </span><span class="s3">(</span><span class="s1">len </span><span class="s3">= </span><span class="s1">xd</span><span class="s3">.</span><span class="s1">length</span><span class="s3">; !</span><span class="s1">xd</span><span class="s3">[</span><span class="s1">len </span><span class="s3">- </span><span class="s4">1</span><span class="s3">]; --</span><span class="s1">len</span><span class="s3">);</span>

            <span class="s0">// xd[0] will always be be 1</span>
            <span class="s2">for </span><span class="s3">(</span><span class="s1">i </span><span class="s3">= </span><span class="s4">1</span><span class="s3">, </span><span class="s1">str </span><span class="s3">= </span><span class="s5">'1.'</span><span class="s3">; </span><span class="s1">i </span><span class="s3">&lt; </span><span class="s1">len</span><span class="s3">; </span><span class="s1">i</span><span class="s3">++) </span><span class="s1">str </span><span class="s3">+= </span><span class="s1">NUMERALS</span><span class="s3">.</span><span class="s1">charAt</span><span class="s3">(</span><span class="s1">xd</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]);</span>
          <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
            <span class="s1">str </span><span class="s3">= </span><span class="s1">str</span><span class="s3">.</span><span class="s1">charAt</span><span class="s3">(</span><span class="s4">0</span><span class="s3">) + </span><span class="s5">'.' </span><span class="s3">+ </span><span class="s1">str</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span><span class="s4">1</span><span class="s3">);</span>
          <span class="s3">}</span>
        <span class="s3">}</span>

        <span class="s1">str </span><span class="s3">=  </span><span class="s1">str </span><span class="s3">+ (</span><span class="s1">e </span><span class="s3">&lt; </span><span class="s4">0 </span><span class="s3">? </span><span class="s5">'p' </span><span class="s3">: </span><span class="s5">'p+'</span><span class="s3">) + </span><span class="s1">e</span><span class="s3">;</span>
      <span class="s3">} </span><span class="s2">else if </span><span class="s3">(</span><span class="s1">e </span><span class="s3">&lt; </span><span class="s4">0</span><span class="s3">) {</span>
        <span class="s2">for </span><span class="s3">(; ++</span><span class="s1">e</span><span class="s3">;) </span><span class="s1">str </span><span class="s3">= </span><span class="s5">'0' </span><span class="s3">+ </span><span class="s1">str</span><span class="s3">;</span>
        <span class="s1">str </span><span class="s3">= </span><span class="s5">'0.' </span><span class="s3">+ </span><span class="s1">str</span><span class="s3">;</span>
      <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
        <span class="s2">if </span><span class="s3">(++</span><span class="s1">e </span><span class="s3">&gt; </span><span class="s1">len</span><span class="s3">) </span><span class="s2">for </span><span class="s3">(</span><span class="s1">e </span><span class="s3">-= </span><span class="s1">len</span><span class="s3">; </span><span class="s1">e</span><span class="s3">-- ;) </span><span class="s1">str </span><span class="s3">+= </span><span class="s5">'0'</span><span class="s3">;</span>
        <span class="s2">else if </span><span class="s3">(</span><span class="s1">e </span><span class="s3">&lt; </span><span class="s1">len</span><span class="s3">) </span><span class="s1">str </span><span class="s3">= </span><span class="s1">str</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span><span class="s4">0</span><span class="s3">, </span><span class="s1">e</span><span class="s3">) + </span><span class="s5">'.' </span><span class="s3">+ </span><span class="s1">str</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span><span class="s1">e</span><span class="s3">);</span>
      <span class="s3">}</span>
    <span class="s3">}</span>

    <span class="s1">str </span><span class="s3">= (</span><span class="s1">baseOut </span><span class="s3">== </span><span class="s4">16 </span><span class="s3">? </span><span class="s5">'0x' </span><span class="s3">: </span><span class="s1">baseOut </span><span class="s3">== </span><span class="s4">2 </span><span class="s3">? </span><span class="s5">'0b' </span><span class="s3">: </span><span class="s1">baseOut </span><span class="s3">== </span><span class="s4">8 </span><span class="s3">? </span><span class="s5">'0o' </span><span class="s3">: </span><span class="s5">''</span><span class="s3">) + </span><span class="s1">str</span><span class="s3">;</span>
  <span class="s3">}</span>

  <span class="s2">return </span><span class="s1">x</span><span class="s3">.</span><span class="s1">s </span><span class="s3">&lt; </span><span class="s4">0 </span><span class="s3">? </span><span class="s5">'-' </span><span class="s3">+ </span><span class="s1">str </span><span class="s3">: </span><span class="s1">str</span><span class="s3">;</span>
<span class="s3">}</span>


<span class="s0">// Does not strip trailing zeros.</span>
<span class="s2">function </span><span class="s1">truncate</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">, </span><span class="s1">len</span><span class="s3">) {</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">arr</span><span class="s3">.</span><span class="s1">length </span><span class="s3">&gt; </span><span class="s1">len</span><span class="s3">) {</span>
    <span class="s1">arr</span><span class="s3">.</span><span class="s1">length </span><span class="s3">= </span><span class="s1">len</span><span class="s3">;</span>
    <span class="s2">return true</span><span class="s3">;</span>
  <span class="s3">}</span>
<span class="s3">}</span>


<span class="s0">// Decimal methods</span>


<span class="s0">/* 
 *  abs 
 *  acos 
 *  acosh 
 *  add 
 *  asin 
 *  asinh 
 *  atan 
 *  atanh 
 *  atan2 
 *  cbrt 
 *  ceil 
 *  clamp 
 *  clone 
 *  config 
 *  cos 
 *  cosh 
 *  div 
 *  exp 
 *  floor 
 *  hypot 
 *  ln 
 *  log 
 *  log2 
 *  log10 
 *  max 
 *  min 
 *  mod 
 *  mul 
 *  pow 
 *  random 
 *  round 
 *  set 
 *  sign 
 *  sin 
 *  sinh 
 *  sqrt 
 *  sub 
 *  sum 
 *  tan 
 *  tanh 
 *  trunc 
 */</span>


<span class="s0">/* 
 * Return a new Decimal whose value is the absolute value of `x`. 
 * 
 * x {number|string|bigint|Decimal} 
 * 
 */</span>
<span class="s2">function </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) {</span>
  <span class="s2">return new this</span><span class="s3">(</span><span class="s1">x</span><span class="s3">).</span><span class="s1">abs</span><span class="s3">();</span>
<span class="s3">}</span>


<span class="s0">/* 
 * Return a new Decimal whose value is the arccosine in radians of `x`. 
 * 
 * x {number|string|bigint|Decimal} 
 * 
 */</span>
<span class="s2">function </span><span class="s1">acos</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) {</span>
  <span class="s2">return new this</span><span class="s3">(</span><span class="s1">x</span><span class="s3">).</span><span class="s1">acos</span><span class="s3">();</span>
<span class="s3">}</span>


<span class="s0">/* 
 * Return a new Decimal whose value is the inverse of the hyperbolic cosine of `x`, rounded to 
 * `precision` significant digits using rounding mode `rounding`. 
 * 
 * x {number|string|bigint|Decimal} A value in radians. 
 * 
 */</span>
<span class="s2">function </span><span class="s1">acosh</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) {</span>
  <span class="s2">return new this</span><span class="s3">(</span><span class="s1">x</span><span class="s3">).</span><span class="s1">acosh</span><span class="s3">();</span>
<span class="s3">}</span>


<span class="s0">/* 
 * Return a new Decimal whose value is the sum of `x` and `y`, rounded to `precision` significant 
 * digits using rounding mode `rounding`. 
 * 
 * x {number|string|bigint|Decimal} 
 * y {number|string|bigint|Decimal} 
 * 
 */</span>
<span class="s2">function </span><span class="s1">add</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">) {</span>
  <span class="s2">return new this</span><span class="s3">(</span><span class="s1">x</span><span class="s3">).</span><span class="s1">plus</span><span class="s3">(</span><span class="s1">y</span><span class="s3">);</span>
<span class="s3">}</span>


<span class="s0">/* 
 * Return a new Decimal whose value is the arcsine in radians of `x`, rounded to `precision` 
 * significant digits using rounding mode `rounding`. 
 * 
 * x {number|string|bigint|Decimal} 
 * 
 */</span>
<span class="s2">function </span><span class="s1">asin</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) {</span>
  <span class="s2">return new this</span><span class="s3">(</span><span class="s1">x</span><span class="s3">).</span><span class="s1">asin</span><span class="s3">();</span>
<span class="s3">}</span>


<span class="s0">/* 
 * Return a new Decimal whose value is the inverse of the hyperbolic sine of `x`, rounded to 
 * `precision` significant digits using rounding mode `rounding`. 
 * 
 * x {number|string|bigint|Decimal} A value in radians. 
 * 
 */</span>
<span class="s2">function </span><span class="s1">asinh</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) {</span>
  <span class="s2">return new this</span><span class="s3">(</span><span class="s1">x</span><span class="s3">).</span><span class="s1">asinh</span><span class="s3">();</span>
<span class="s3">}</span>


<span class="s0">/* 
 * Return a new Decimal whose value is the arctangent in radians of `x`, rounded to `precision` 
 * significant digits using rounding mode `rounding`. 
 * 
 * x {number|string|bigint|Decimal} 
 * 
 */</span>
<span class="s2">function </span><span class="s1">atan</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) {</span>
  <span class="s2">return new this</span><span class="s3">(</span><span class="s1">x</span><span class="s3">).</span><span class="s1">atan</span><span class="s3">();</span>
<span class="s3">}</span>


<span class="s0">/* 
 * Return a new Decimal whose value is the inverse of the hyperbolic tangent of `x`, rounded to 
 * `precision` significant digits using rounding mode `rounding`. 
 * 
 * x {number|string|bigint|Decimal} A value in radians. 
 * 
 */</span>
<span class="s2">function </span><span class="s1">atanh</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) {</span>
  <span class="s2">return new this</span><span class="s3">(</span><span class="s1">x</span><span class="s3">).</span><span class="s1">atanh</span><span class="s3">();</span>
<span class="s3">}</span>


<span class="s0">/* 
 * Return a new Decimal whose value is the arctangent in radians of `y/x` in the range -pi to pi 
 * (inclusive), rounded to `precision` significant digits using rounding mode `rounding`. 
 * 
 * Domain: [-Infinity, Infinity] 
 * Range: [-pi, pi] 
 * 
 * y {number|string|bigint|Decimal} The y-coordinate. 
 * x {number|string|bigint|Decimal} The x-coordinate. 
 * 
 * atan2(Â±0, -0)               = Â±pi 
 * atan2(Â±0, +0)               = Â±0 
 * atan2(Â±0, -x)               = Â±pi for x &gt; 0 
 * atan2(Â±0, x)                = Â±0 for x &gt; 0 
 * atan2(-y, Â±0)               = -pi/2 for y &gt; 0 
 * atan2(y, Â±0)                = pi/2 for y &gt; 0 
 * atan2(Â±y, -Infinity)        = Â±pi for finite y &gt; 0 
 * atan2(Â±y, +Infinity)        = Â±0 for finite y &gt; 0 
 * atan2(Â±Infinity, x)         = Â±pi/2 for finite x 
 * atan2(Â±Infinity, -Infinity) = Â±3*pi/4 
 * atan2(Â±Infinity, +Infinity) = Â±pi/4 
 * atan2(NaN, x) = NaN 
 * atan2(y, NaN) = NaN 
 * 
 */</span>
<span class="s2">function </span><span class="s1">atan2</span><span class="s3">(</span><span class="s1">y</span><span class="s3">, </span><span class="s1">x</span><span class="s3">) {</span>
  <span class="s1">y </span><span class="s3">= </span><span class="s2">new this</span><span class="s3">(</span><span class="s1">y</span><span class="s3">);</span>
  <span class="s1">x </span><span class="s3">= </span><span class="s2">new this</span><span class="s3">(</span><span class="s1">x</span><span class="s3">);</span>
  <span class="s2">var </span><span class="s1">r</span><span class="s3">,</span>
    <span class="s1">pr </span><span class="s3">= </span><span class="s2">this</span><span class="s3">.</span><span class="s1">precision</span><span class="s3">,</span>
    <span class="s1">rm </span><span class="s3">= </span><span class="s2">this</span><span class="s3">.</span><span class="s1">rounding</span><span class="s3">,</span>
    <span class="s1">wpr </span><span class="s3">= </span><span class="s1">pr </span><span class="s3">+ </span><span class="s4">4</span><span class="s3">;</span>

  <span class="s0">// Either NaN</span>
  <span class="s2">if </span><span class="s3">(!</span><span class="s1">y</span><span class="s3">.</span><span class="s1">s </span><span class="s3">|| !</span><span class="s1">x</span><span class="s3">.</span><span class="s1">s</span><span class="s3">) {</span>
    <span class="s1">r </span><span class="s3">= </span><span class="s2">new this</span><span class="s3">(</span><span class="s1">NaN</span><span class="s3">);</span>

  <span class="s0">// Both Â±Infinity</span>
  <span class="s3">} </span><span class="s2">else if </span><span class="s3">(!</span><span class="s1">y</span><span class="s3">.</span><span class="s1">d </span><span class="s3">&amp;&amp; !</span><span class="s1">x</span><span class="s3">.</span><span class="s1">d</span><span class="s3">) {</span>
    <span class="s1">r </span><span class="s3">= </span><span class="s1">getPi</span><span class="s3">(</span><span class="s2">this</span><span class="s3">, </span><span class="s1">wpr</span><span class="s3">, </span><span class="s4">1</span><span class="s3">).</span><span class="s1">times</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">s </span><span class="s3">&gt; </span><span class="s4">0 </span><span class="s3">? </span><span class="s4">0.25 </span><span class="s3">: </span><span class="s4">0.75</span><span class="s3">);</span>
    <span class="s1">r</span><span class="s3">.</span><span class="s1">s </span><span class="s3">= </span><span class="s1">y</span><span class="s3">.</span><span class="s1">s</span><span class="s3">;</span>

  <span class="s0">// x is Â±Infinity or y is Â±0</span>
  <span class="s3">} </span><span class="s2">else if </span><span class="s3">(!</span><span class="s1">x</span><span class="s3">.</span><span class="s1">d </span><span class="s3">|| </span><span class="s1">y</span><span class="s3">.</span><span class="s1">isZero</span><span class="s3">()) {</span>
    <span class="s1">r </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">s </span><span class="s3">&lt; </span><span class="s4">0 </span><span class="s3">? </span><span class="s1">getPi</span><span class="s3">(</span><span class="s2">this</span><span class="s3">, </span><span class="s1">pr</span><span class="s3">, </span><span class="s1">rm</span><span class="s3">) : </span><span class="s2">new this</span><span class="s3">(</span><span class="s4">0</span><span class="s3">);</span>
    <span class="s1">r</span><span class="s3">.</span><span class="s1">s </span><span class="s3">= </span><span class="s1">y</span><span class="s3">.</span><span class="s1">s</span><span class="s3">;</span>

  <span class="s0">// y is Â±Infinity or x is Â±0</span>
  <span class="s3">} </span><span class="s2">else if </span><span class="s3">(!</span><span class="s1">y</span><span class="s3">.</span><span class="s1">d </span><span class="s3">|| </span><span class="s1">x</span><span class="s3">.</span><span class="s1">isZero</span><span class="s3">()) {</span>
    <span class="s1">r </span><span class="s3">= </span><span class="s1">getPi</span><span class="s3">(</span><span class="s2">this</span><span class="s3">, </span><span class="s1">wpr</span><span class="s3">, </span><span class="s4">1</span><span class="s3">).</span><span class="s1">times</span><span class="s3">(</span><span class="s4">0.5</span><span class="s3">);</span>
    <span class="s1">r</span><span class="s3">.</span><span class="s1">s </span><span class="s3">= </span><span class="s1">y</span><span class="s3">.</span><span class="s1">s</span><span class="s3">;</span>

  <span class="s0">// Both non-zero and finite</span>
  <span class="s3">} </span><span class="s2">else if </span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">s </span><span class="s3">&lt; </span><span class="s4">0</span><span class="s3">) {</span>
    <span class="s2">this</span><span class="s3">.</span><span class="s1">precision </span><span class="s3">= </span><span class="s1">wpr</span><span class="s3">;</span>
    <span class="s2">this</span><span class="s3">.</span><span class="s1">rounding </span><span class="s3">= </span><span class="s4">1</span><span class="s3">;</span>
    <span class="s1">r </span><span class="s3">= </span><span class="s2">this</span><span class="s3">.</span><span class="s1">atan</span><span class="s3">(</span><span class="s1">divide</span><span class="s3">(</span><span class="s1">y</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">wpr</span><span class="s3">, </span><span class="s4">1</span><span class="s3">));</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s1">getPi</span><span class="s3">(</span><span class="s2">this</span><span class="s3">, </span><span class="s1">wpr</span><span class="s3">, </span><span class="s4">1</span><span class="s3">);</span>
    <span class="s2">this</span><span class="s3">.</span><span class="s1">precision </span><span class="s3">= </span><span class="s1">pr</span><span class="s3">;</span>
    <span class="s2">this</span><span class="s3">.</span><span class="s1">rounding </span><span class="s3">= </span><span class="s1">rm</span><span class="s3">;</span>
    <span class="s1">r </span><span class="s3">= </span><span class="s1">y</span><span class="s3">.</span><span class="s1">s </span><span class="s3">&lt; </span><span class="s4">0 </span><span class="s3">? </span><span class="s1">r</span><span class="s3">.</span><span class="s1">minus</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) : </span><span class="s1">r</span><span class="s3">.</span><span class="s1">plus</span><span class="s3">(</span><span class="s1">x</span><span class="s3">);</span>
  <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
    <span class="s1">r </span><span class="s3">= </span><span class="s2">this</span><span class="s3">.</span><span class="s1">atan</span><span class="s3">(</span><span class="s1">divide</span><span class="s3">(</span><span class="s1">y</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">wpr</span><span class="s3">, </span><span class="s4">1</span><span class="s3">));</span>
  <span class="s3">}</span>

  <span class="s2">return </span><span class="s1">r</span><span class="s3">;</span>
<span class="s3">}</span>


<span class="s0">/* 
 * Return a new Decimal whose value is the cube root of `x`, rounded to `precision` significant 
 * digits using rounding mode `rounding`. 
 * 
 * x {number|string|bigint|Decimal} 
 * 
 */</span>
<span class="s2">function </span><span class="s1">cbrt</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) {</span>
  <span class="s2">return new this</span><span class="s3">(</span><span class="s1">x</span><span class="s3">).</span><span class="s1">cbrt</span><span class="s3">();</span>
<span class="s3">}</span>


<span class="s0">/* 
 * Return a new Decimal whose value is `x` rounded to an integer using `ROUND_CEIL`. 
 * 
 * x {number|string|bigint|Decimal} 
 * 
 */</span>
<span class="s2">function </span><span class="s1">ceil</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) {</span>
  <span class="s2">return </span><span class="s1">finalise</span><span class="s3">(</span><span class="s1">x </span><span class="s3">= </span><span class="s2">new this</span><span class="s3">(</span><span class="s1">x</span><span class="s3">), </span><span class="s1">x</span><span class="s3">.</span><span class="s1">e </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">);</span>
<span class="s3">}</span>


<span class="s0">/* 
 * Return a new Decimal whose value is `x` clamped to the range delineated by `min` and `max`. 
 * 
 * x {number|string|bigint|Decimal} 
 * min {number|string|bigint|Decimal} 
 * max {number|string|bigint|Decimal} 
 * 
 */</span>
<span class="s2">function </span><span class="s1">clamp</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">min</span><span class="s3">, </span><span class="s1">max</span><span class="s3">) {</span>
  <span class="s2">return new this</span><span class="s3">(</span><span class="s1">x</span><span class="s3">).</span><span class="s1">clamp</span><span class="s3">(</span><span class="s1">min</span><span class="s3">, </span><span class="s1">max</span><span class="s3">);</span>
<span class="s3">}</span>


<span class="s0">/* 
 * Configure global settings for a Decimal constructor. 
 * 
 * `obj` is an object with one or more of the following properties, 
 * 
 *   precision  {number} 
 *   rounding   {number} 
 *   toExpNeg   {number} 
 *   toExpPos   {number} 
 *   maxE       {number} 
 *   minE       {number} 
 *   modulo     {number} 
 *   crypto     {boolean|number} 
 *   defaults   {true} 
 * 
 * E.g. Decimal.config({ precision: 20, rounding: 4 }) 
 * 
 */</span>
<span class="s2">function </span><span class="s1">config</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">) {</span>
  <span class="s2">if </span><span class="s3">(!</span><span class="s1">obj </span><span class="s3">|| </span><span class="s2">typeof </span><span class="s1">obj </span><span class="s3">!== </span><span class="s5">'object'</span><span class="s3">) </span><span class="s2">throw </span><span class="s1">Error</span><span class="s3">(</span><span class="s1">decimalError </span><span class="s3">+ </span><span class="s5">'Object expected'</span><span class="s3">);</span>
  <span class="s2">var </span><span class="s1">i</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">v</span><span class="s3">,</span>
    <span class="s1">useDefaults </span><span class="s3">= </span><span class="s1">obj</span><span class="s3">.</span><span class="s1">defaults </span><span class="s3">=== </span><span class="s2">true</span><span class="s3">,</span>
    <span class="s1">ps </span><span class="s3">= [</span>
      <span class="s5">'precision'</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s1">MAX_DIGITS</span><span class="s3">,</span>
      <span class="s5">'rounding'</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">8</span><span class="s3">,</span>
      <span class="s5">'toExpNeg'</span><span class="s3">, -</span><span class="s1">EXP_LIMIT</span><span class="s3">, </span><span class="s4">0</span><span class="s3">,</span>
      <span class="s5">'toExpPos'</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s1">EXP_LIMIT</span><span class="s3">,</span>
      <span class="s5">'maxE'</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s1">EXP_LIMIT</span><span class="s3">,</span>
      <span class="s5">'minE'</span><span class="s3">, -</span><span class="s1">EXP_LIMIT</span><span class="s3">, </span><span class="s4">0</span><span class="s3">,</span>
      <span class="s5">'modulo'</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">9</span>
    <span class="s3">];</span>

  <span class="s2">for </span><span class="s3">(</span><span class="s1">i </span><span class="s3">= </span><span class="s4">0</span><span class="s3">; </span><span class="s1">i </span><span class="s3">&lt; </span><span class="s1">ps</span><span class="s3">.</span><span class="s1">length</span><span class="s3">; </span><span class="s1">i </span><span class="s3">+= </span><span class="s4">3</span><span class="s3">) {</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">p </span><span class="s3">= </span><span class="s1">ps</span><span class="s3">[</span><span class="s1">i</span><span class="s3">], </span><span class="s1">useDefaults</span><span class="s3">) </span><span class="s2">this</span><span class="s3">[</span><span class="s1">p</span><span class="s3">] = </span><span class="s1">DEFAULTS</span><span class="s3">[</span><span class="s1">p</span><span class="s3">];</span>
    <span class="s2">if </span><span class="s3">((</span><span class="s1">v </span><span class="s3">= </span><span class="s1">obj</span><span class="s3">[</span><span class="s1">p</span><span class="s3">]) !== </span><span class="s2">void </span><span class="s4">0</span><span class="s3">) {</span>
      <span class="s2">if </span><span class="s3">(</span><span class="s1">mathfloor</span><span class="s3">(</span><span class="s1">v</span><span class="s3">) === </span><span class="s1">v </span><span class="s3">&amp;&amp; </span><span class="s1">v </span><span class="s3">&gt;= </span><span class="s1">ps</span><span class="s3">[</span><span class="s1">i </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">] &amp;&amp; </span><span class="s1">v </span><span class="s3">&lt;= </span><span class="s1">ps</span><span class="s3">[</span><span class="s1">i </span><span class="s3">+ </span><span class="s4">2</span><span class="s3">]) </span><span class="s2">this</span><span class="s3">[</span><span class="s1">p</span><span class="s3">] = </span><span class="s1">v</span><span class="s3">;</span>
      <span class="s2">else throw </span><span class="s1">Error</span><span class="s3">(</span><span class="s1">invalidArgument </span><span class="s3">+ </span><span class="s1">p </span><span class="s3">+ </span><span class="s5">': ' </span><span class="s3">+ </span><span class="s1">v</span><span class="s3">);</span>
    <span class="s3">}</span>
  <span class="s3">}</span>

  <span class="s2">if </span><span class="s3">(</span><span class="s1">p </span><span class="s3">= </span><span class="s5">'crypto'</span><span class="s3">, </span><span class="s1">useDefaults</span><span class="s3">) </span><span class="s2">this</span><span class="s3">[</span><span class="s1">p</span><span class="s3">] = </span><span class="s1">DEFAULTS</span><span class="s3">[</span><span class="s1">p</span><span class="s3">];</span>
  <span class="s2">if </span><span class="s3">((</span><span class="s1">v </span><span class="s3">= </span><span class="s1">obj</span><span class="s3">[</span><span class="s1">p</span><span class="s3">]) !== </span><span class="s2">void </span><span class="s4">0</span><span class="s3">) {</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">v </span><span class="s3">=== </span><span class="s2">true </span><span class="s3">|| </span><span class="s1">v </span><span class="s3">=== </span><span class="s2">false </span><span class="s3">|| </span><span class="s1">v </span><span class="s3">=== </span><span class="s4">0 </span><span class="s3">|| </span><span class="s1">v </span><span class="s3">=== </span><span class="s4">1</span><span class="s3">) {</span>
      <span class="s2">if </span><span class="s3">(</span><span class="s1">v</span><span class="s3">) {</span>
        <span class="s2">if </span><span class="s3">(</span><span class="s2">typeof </span><span class="s1">crypto </span><span class="s3">!= </span><span class="s5">'undefined' </span><span class="s3">&amp;&amp; </span><span class="s1">crypto </span><span class="s3">&amp;&amp;</span>
          <span class="s3">(</span><span class="s1">crypto</span><span class="s3">.</span><span class="s1">getRandomValues </span><span class="s3">|| </span><span class="s1">crypto</span><span class="s3">.</span><span class="s1">randomBytes</span><span class="s3">)) {</span>
          <span class="s2">this</span><span class="s3">[</span><span class="s1">p</span><span class="s3">] = </span><span class="s2">true</span><span class="s3">;</span>
        <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
          <span class="s2">throw </span><span class="s1">Error</span><span class="s3">(</span><span class="s1">cryptoUnavailable</span><span class="s3">);</span>
        <span class="s3">}</span>
      <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
        <span class="s2">this</span><span class="s3">[</span><span class="s1">p</span><span class="s3">] = </span><span class="s2">false</span><span class="s3">;</span>
      <span class="s3">}</span>
    <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
      <span class="s2">throw </span><span class="s1">Error</span><span class="s3">(</span><span class="s1">invalidArgument </span><span class="s3">+ </span><span class="s1">p </span><span class="s3">+ </span><span class="s5">': ' </span><span class="s3">+ </span><span class="s1">v</span><span class="s3">);</span>
    <span class="s3">}</span>
  <span class="s3">}</span>

  <span class="s2">return this</span><span class="s3">;</span>
<span class="s3">}</span>


<span class="s0">/* 
 * Return a new Decimal whose value is the cosine of `x`, rounded to `precision` significant 
 * digits using rounding mode `rounding`. 
 * 
 * x {number|string|bigint|Decimal} A value in radians. 
 * 
 */</span>
<span class="s2">function </span><span class="s1">cos</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) {</span>
  <span class="s2">return new this</span><span class="s3">(</span><span class="s1">x</span><span class="s3">).</span><span class="s1">cos</span><span class="s3">();</span>
<span class="s3">}</span>


<span class="s0">/* 
 * Return a new Decimal whose value is the hyperbolic cosine of `x`, rounded to precision 
 * significant digits using rounding mode `rounding`. 
 * 
 * x {number|string|bigint|Decimal} A value in radians. 
 * 
 */</span>
<span class="s2">function </span><span class="s1">cosh</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) {</span>
  <span class="s2">return new this</span><span class="s3">(</span><span class="s1">x</span><span class="s3">).</span><span class="s1">cosh</span><span class="s3">();</span>
<span class="s3">}</span>


<span class="s0">/* 
 * Create and return a Decimal constructor with the same configuration properties as this Decimal 
 * constructor. 
 * 
 */</span>
<span class="s2">function </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">i</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">ps</span><span class="s3">;</span>

  <span class="s0">/* 
   * The Decimal constructor and exported function. 
   * Return a new Decimal instance. 
   * 
   * v {number|string|bigint|Decimal} A numeric value. 
   * 
   */</span>
  <span class="s2">function </span><span class="s1">Decimal</span><span class="s3">(</span><span class="s1">v</span><span class="s3">) {</span>
    <span class="s2">var </span><span class="s1">e</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">t</span><span class="s3">,</span>
      <span class="s1">x </span><span class="s3">= </span><span class="s2">this</span><span class="s3">;</span>

    <span class="s0">// Decimal called without new.</span>
    <span class="s2">if </span><span class="s3">(!(</span><span class="s1">x </span><span class="s2">instanceof </span><span class="s1">Decimal</span><span class="s3">)) </span><span class="s2">return new </span><span class="s1">Decimal</span><span class="s3">(</span><span class="s1">v</span><span class="s3">);</span>

    <span class="s0">// Retain a reference to this Decimal constructor, and shadow Decimal.prototype.constructor</span>
    <span class="s0">// which points to Object.</span>
    <span class="s1">x</span><span class="s3">.</span><span class="s1">constructor </span><span class="s3">= </span><span class="s1">Decimal</span><span class="s3">;</span>

    <span class="s2">if </span><span class="s3">(</span><span class="s1">isDecimalInstance</span><span class="s3">(</span><span class="s1">v</span><span class="s3">)) {</span>
      <span class="s1">x</span><span class="s3">.</span><span class="s1">s </span><span class="s3">= </span><span class="s1">v</span><span class="s3">.</span><span class="s1">s</span><span class="s3">;</span>

      <span class="s2">if </span><span class="s3">(</span><span class="s1">external</span><span class="s3">) {</span>
        <span class="s2">if </span><span class="s3">(!</span><span class="s1">v</span><span class="s3">.</span><span class="s1">d </span><span class="s3">|| </span><span class="s1">v</span><span class="s3">.</span><span class="s1">e </span><span class="s3">&gt; </span><span class="s1">Decimal</span><span class="s3">.</span><span class="s1">maxE</span><span class="s3">) {</span>

          <span class="s0">// Infinity.</span>
          <span class="s1">x</span><span class="s3">.</span><span class="s1">e </span><span class="s3">= </span><span class="s1">NaN</span><span class="s3">;</span>
          <span class="s1">x</span><span class="s3">.</span><span class="s1">d </span><span class="s3">= </span><span class="s2">null</span><span class="s3">;</span>
        <span class="s3">} </span><span class="s2">else if </span><span class="s3">(</span><span class="s1">v</span><span class="s3">.</span><span class="s1">e </span><span class="s3">&lt; </span><span class="s1">Decimal</span><span class="s3">.</span><span class="s1">minE</span><span class="s3">) {</span>

          <span class="s0">// Zero.</span>
          <span class="s1">x</span><span class="s3">.</span><span class="s1">e </span><span class="s3">= </span><span class="s4">0</span><span class="s3">;</span>
          <span class="s1">x</span><span class="s3">.</span><span class="s1">d </span><span class="s3">= [</span><span class="s4">0</span><span class="s3">];</span>
        <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
          <span class="s1">x</span><span class="s3">.</span><span class="s1">e </span><span class="s3">= </span><span class="s1">v</span><span class="s3">.</span><span class="s1">e</span><span class="s3">;</span>
          <span class="s1">x</span><span class="s3">.</span><span class="s1">d </span><span class="s3">= </span><span class="s1">v</span><span class="s3">.</span><span class="s1">d</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">();</span>
        <span class="s3">}</span>
      <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
        <span class="s1">x</span><span class="s3">.</span><span class="s1">e </span><span class="s3">= </span><span class="s1">v</span><span class="s3">.</span><span class="s1">e</span><span class="s3">;</span>
        <span class="s1">x</span><span class="s3">.</span><span class="s1">d </span><span class="s3">= </span><span class="s1">v</span><span class="s3">.</span><span class="s1">d </span><span class="s3">? </span><span class="s1">v</span><span class="s3">.</span><span class="s1">d</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">() : </span><span class="s1">v</span><span class="s3">.</span><span class="s1">d</span><span class="s3">;</span>
      <span class="s3">}</span>

      <span class="s2">return</span><span class="s3">;</span>
    <span class="s3">}</span>

    <span class="s1">t </span><span class="s3">= </span><span class="s2">typeof </span><span class="s1">v</span><span class="s3">;</span>

    <span class="s2">if </span><span class="s3">(</span><span class="s1">t </span><span class="s3">=== </span><span class="s5">'number'</span><span class="s3">) {</span>
      <span class="s2">if </span><span class="s3">(</span><span class="s1">v </span><span class="s3">=== </span><span class="s4">0</span><span class="s3">) {</span>
        <span class="s1">x</span><span class="s3">.</span><span class="s1">s </span><span class="s3">= </span><span class="s4">1 </span><span class="s3">/ </span><span class="s1">v </span><span class="s3">&lt; </span><span class="s4">0 </span><span class="s3">? -</span><span class="s4">1 </span><span class="s3">: </span><span class="s4">1</span><span class="s3">;</span>
        <span class="s1">x</span><span class="s3">.</span><span class="s1">e </span><span class="s3">= </span><span class="s4">0</span><span class="s3">;</span>
        <span class="s1">x</span><span class="s3">.</span><span class="s1">d </span><span class="s3">= [</span><span class="s4">0</span><span class="s3">];</span>
        <span class="s2">return</span><span class="s3">;</span>
      <span class="s3">}</span>

      <span class="s2">if </span><span class="s3">(</span><span class="s1">v </span><span class="s3">&lt; </span><span class="s4">0</span><span class="s3">) {</span>
        <span class="s1">v </span><span class="s3">= -</span><span class="s1">v</span><span class="s3">;</span>
        <span class="s1">x</span><span class="s3">.</span><span class="s1">s </span><span class="s3">= -</span><span class="s4">1</span><span class="s3">;</span>
      <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
        <span class="s1">x</span><span class="s3">.</span><span class="s1">s </span><span class="s3">= </span><span class="s4">1</span><span class="s3">;</span>
      <span class="s3">}</span>

      <span class="s0">// Fast path for small integers.</span>
      <span class="s2">if </span><span class="s3">(</span><span class="s1">v </span><span class="s3">=== ~~</span><span class="s1">v </span><span class="s3">&amp;&amp; </span><span class="s1">v </span><span class="s3">&lt; </span><span class="s4">1e7</span><span class="s3">) {</span>
        <span class="s2">for </span><span class="s3">(</span><span class="s1">e </span><span class="s3">= </span><span class="s4">0</span><span class="s3">, </span><span class="s1">i </span><span class="s3">= </span><span class="s1">v</span><span class="s3">; </span><span class="s1">i </span><span class="s3">&gt;= </span><span class="s4">10</span><span class="s3">; </span><span class="s1">i </span><span class="s3">/= </span><span class="s4">10</span><span class="s3">) </span><span class="s1">e</span><span class="s3">++;</span>

        <span class="s2">if </span><span class="s3">(</span><span class="s1">external</span><span class="s3">) {</span>
          <span class="s2">if </span><span class="s3">(</span><span class="s1">e </span><span class="s3">&gt; </span><span class="s1">Decimal</span><span class="s3">.</span><span class="s1">maxE</span><span class="s3">) {</span>
            <span class="s1">x</span><span class="s3">.</span><span class="s1">e </span><span class="s3">= </span><span class="s1">NaN</span><span class="s3">;</span>
            <span class="s1">x</span><span class="s3">.</span><span class="s1">d </span><span class="s3">= </span><span class="s2">null</span><span class="s3">;</span>
          <span class="s3">} </span><span class="s2">else if </span><span class="s3">(</span><span class="s1">e </span><span class="s3">&lt; </span><span class="s1">Decimal</span><span class="s3">.</span><span class="s1">minE</span><span class="s3">) {</span>
            <span class="s1">x</span><span class="s3">.</span><span class="s1">e </span><span class="s3">= </span><span class="s4">0</span><span class="s3">;</span>
            <span class="s1">x</span><span class="s3">.</span><span class="s1">d </span><span class="s3">= [</span><span class="s4">0</span><span class="s3">];</span>
          <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
            <span class="s1">x</span><span class="s3">.</span><span class="s1">e </span><span class="s3">= </span><span class="s1">e</span><span class="s3">;</span>
            <span class="s1">x</span><span class="s3">.</span><span class="s1">d </span><span class="s3">= [</span><span class="s1">v</span><span class="s3">];</span>
          <span class="s3">}</span>
        <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
          <span class="s1">x</span><span class="s3">.</span><span class="s1">e </span><span class="s3">= </span><span class="s1">e</span><span class="s3">;</span>
          <span class="s1">x</span><span class="s3">.</span><span class="s1">d </span><span class="s3">= [</span><span class="s1">v</span><span class="s3">];</span>
        <span class="s3">}</span>

        <span class="s2">return</span><span class="s3">;</span>
      <span class="s3">}</span>

      <span class="s0">// Infinity or NaN?</span>
      <span class="s2">if </span><span class="s3">(</span><span class="s1">v </span><span class="s3">* </span><span class="s4">0 </span><span class="s3">!== </span><span class="s4">0</span><span class="s3">) {</span>
        <span class="s2">if </span><span class="s3">(!</span><span class="s1">v</span><span class="s3">) </span><span class="s1">x</span><span class="s3">.</span><span class="s1">s </span><span class="s3">= </span><span class="s1">NaN</span><span class="s3">;</span>
        <span class="s1">x</span><span class="s3">.</span><span class="s1">e </span><span class="s3">= </span><span class="s1">NaN</span><span class="s3">;</span>
        <span class="s1">x</span><span class="s3">.</span><span class="s1">d </span><span class="s3">= </span><span class="s2">null</span><span class="s3">;</span>
        <span class="s2">return</span><span class="s3">;</span>
      <span class="s3">}</span>

      <span class="s2">return </span><span class="s1">parseDecimal</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">v</span><span class="s3">.</span><span class="s1">toString</span><span class="s3">());</span>
    <span class="s3">}</span>

    <span class="s2">if </span><span class="s3">(</span><span class="s1">t </span><span class="s3">=== </span><span class="s5">'string'</span><span class="s3">) {</span>
      <span class="s2">if </span><span class="s3">((</span><span class="s1">i </span><span class="s3">= </span><span class="s1">v</span><span class="s3">.</span><span class="s1">charCodeAt</span><span class="s3">(</span><span class="s4">0</span><span class="s3">)) === </span><span class="s4">45</span><span class="s3">) {  </span><span class="s0">// minus sign</span>
        <span class="s1">v </span><span class="s3">= </span><span class="s1">v</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span><span class="s4">1</span><span class="s3">);</span>
        <span class="s1">x</span><span class="s3">.</span><span class="s1">s </span><span class="s3">= -</span><span class="s4">1</span><span class="s3">;</span>
      <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
        <span class="s2">if </span><span class="s3">(</span><span class="s1">i </span><span class="s3">=== </span><span class="s4">43</span><span class="s3">) </span><span class="s1">v </span><span class="s3">= </span><span class="s1">v</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span><span class="s4">1</span><span class="s3">);  </span><span class="s0">// plus sign</span>
        <span class="s1">x</span><span class="s3">.</span><span class="s1">s </span><span class="s3">= </span><span class="s4">1</span><span class="s3">;</span>
      <span class="s3">}</span>

      <span class="s2">return </span><span class="s1">isDecimal</span><span class="s3">.</span><span class="s1">test</span><span class="s3">(</span><span class="s1">v</span><span class="s3">) ? </span><span class="s1">parseDecimal</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">v</span><span class="s3">) : </span><span class="s1">parseOther</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">v</span><span class="s3">);</span>
    <span class="s3">}</span>

    <span class="s2">if </span><span class="s3">(</span><span class="s1">t </span><span class="s3">=== </span><span class="s5">'bigint'</span><span class="s3">) {</span>
      <span class="s2">if </span><span class="s3">(</span><span class="s1">v </span><span class="s3">&lt; </span><span class="s4">0</span><span class="s3">) {</span>
        <span class="s1">v </span><span class="s3">= -</span><span class="s1">v</span><span class="s3">;</span>
        <span class="s1">x</span><span class="s3">.</span><span class="s1">s </span><span class="s3">= -</span><span class="s4">1</span><span class="s3">;</span>
      <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
        <span class="s1">x</span><span class="s3">.</span><span class="s1">s </span><span class="s3">= </span><span class="s4">1</span><span class="s3">;</span>
      <span class="s3">}</span>

      <span class="s2">return </span><span class="s1">parseDecimal</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">v</span><span class="s3">.</span><span class="s1">toString</span><span class="s3">());</span>
    <span class="s3">}</span>

    <span class="s2">throw </span><span class="s1">Error</span><span class="s3">(</span><span class="s1">invalidArgument </span><span class="s3">+ </span><span class="s1">v</span><span class="s3">);</span>
  <span class="s3">}</span>

  <span class="s1">Decimal</span><span class="s3">.</span><span class="s1">prototype </span><span class="s3">= </span><span class="s1">P</span><span class="s3">;</span>

  <span class="s1">Decimal</span><span class="s3">.</span><span class="s1">ROUND_UP </span><span class="s3">= </span><span class="s4">0</span><span class="s3">;</span>
  <span class="s1">Decimal</span><span class="s3">.</span><span class="s1">ROUND_DOWN </span><span class="s3">= </span><span class="s4">1</span><span class="s3">;</span>
  <span class="s1">Decimal</span><span class="s3">.</span><span class="s1">ROUND_CEIL </span><span class="s3">= </span><span class="s4">2</span><span class="s3">;</span>
  <span class="s1">Decimal</span><span class="s3">.</span><span class="s1">ROUND_FLOOR </span><span class="s3">= </span><span class="s4">3</span><span class="s3">;</span>
  <span class="s1">Decimal</span><span class="s3">.</span><span class="s1">ROUND_HALF_UP </span><span class="s3">= </span><span class="s4">4</span><span class="s3">;</span>
  <span class="s1">Decimal</span><span class="s3">.</span><span class="s1">ROUND_HALF_DOWN </span><span class="s3">= </span><span class="s4">5</span><span class="s3">;</span>
  <span class="s1">Decimal</span><span class="s3">.</span><span class="s1">ROUND_HALF_EVEN </span><span class="s3">= </span><span class="s4">6</span><span class="s3">;</span>
  <span class="s1">Decimal</span><span class="s3">.</span><span class="s1">ROUND_HALF_CEIL </span><span class="s3">= </span><span class="s4">7</span><span class="s3">;</span>
  <span class="s1">Decimal</span><span class="s3">.</span><span class="s1">ROUND_HALF_FLOOR </span><span class="s3">= </span><span class="s4">8</span><span class="s3">;</span>
  <span class="s1">Decimal</span><span class="s3">.</span><span class="s1">EUCLID </span><span class="s3">= </span><span class="s4">9</span><span class="s3">;</span>

  <span class="s1">Decimal</span><span class="s3">.</span><span class="s1">config </span><span class="s3">= </span><span class="s1">Decimal</span><span class="s3">.</span><span class="s1">set </span><span class="s3">= </span><span class="s1">config</span><span class="s3">;</span>
  <span class="s1">Decimal</span><span class="s3">.</span><span class="s1">clone </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">;</span>
  <span class="s1">Decimal</span><span class="s3">.</span><span class="s1">isDecimal </span><span class="s3">= </span><span class="s1">isDecimalInstance</span><span class="s3">;</span>

  <span class="s1">Decimal</span><span class="s3">.</span><span class="s1">abs </span><span class="s3">= </span><span class="s1">abs</span><span class="s3">;</span>
  <span class="s1">Decimal</span><span class="s3">.</span><span class="s1">acos </span><span class="s3">= </span><span class="s1">acos</span><span class="s3">;</span>
  <span class="s1">Decimal</span><span class="s3">.</span><span class="s1">acosh </span><span class="s3">= </span><span class="s1">acosh</span><span class="s3">;        </span><span class="s0">// ES6</span>
  <span class="s1">Decimal</span><span class="s3">.</span><span class="s1">add </span><span class="s3">= </span><span class="s1">add</span><span class="s3">;</span>
  <span class="s1">Decimal</span><span class="s3">.</span><span class="s1">asin </span><span class="s3">= </span><span class="s1">asin</span><span class="s3">;</span>
  <span class="s1">Decimal</span><span class="s3">.</span><span class="s1">asinh </span><span class="s3">= </span><span class="s1">asinh</span><span class="s3">;        </span><span class="s0">// ES6</span>
  <span class="s1">Decimal</span><span class="s3">.</span><span class="s1">atan </span><span class="s3">= </span><span class="s1">atan</span><span class="s3">;</span>
  <span class="s1">Decimal</span><span class="s3">.</span><span class="s1">atanh </span><span class="s3">= </span><span class="s1">atanh</span><span class="s3">;        </span><span class="s0">// ES6</span>
  <span class="s1">Decimal</span><span class="s3">.</span><span class="s1">atan2 </span><span class="s3">= </span><span class="s1">atan2</span><span class="s3">;</span>
  <span class="s1">Decimal</span><span class="s3">.</span><span class="s1">cbrt </span><span class="s3">= </span><span class="s1">cbrt</span><span class="s3">;          </span><span class="s0">// ES6</span>
  <span class="s1">Decimal</span><span class="s3">.</span><span class="s1">ceil </span><span class="s3">= </span><span class="s1">ceil</span><span class="s3">;</span>
  <span class="s1">Decimal</span><span class="s3">.</span><span class="s1">clamp </span><span class="s3">= </span><span class="s1">clamp</span><span class="s3">;</span>
  <span class="s1">Decimal</span><span class="s3">.</span><span class="s1">cos </span><span class="s3">= </span><span class="s1">cos</span><span class="s3">;</span>
  <span class="s1">Decimal</span><span class="s3">.</span><span class="s1">cosh </span><span class="s3">= </span><span class="s1">cosh</span><span class="s3">;          </span><span class="s0">// ES6</span>
  <span class="s1">Decimal</span><span class="s3">.</span><span class="s1">div </span><span class="s3">= </span><span class="s1">div</span><span class="s3">;</span>
  <span class="s1">Decimal</span><span class="s3">.</span><span class="s1">exp </span><span class="s3">= </span><span class="s1">exp</span><span class="s3">;</span>
  <span class="s1">Decimal</span><span class="s3">.</span><span class="s1">floor </span><span class="s3">= </span><span class="s1">floor</span><span class="s3">;</span>
  <span class="s1">Decimal</span><span class="s3">.</span><span class="s1">hypot </span><span class="s3">= </span><span class="s1">hypot</span><span class="s3">;        </span><span class="s0">// ES6</span>
  <span class="s1">Decimal</span><span class="s3">.</span><span class="s1">ln </span><span class="s3">= </span><span class="s1">ln</span><span class="s3">;</span>
  <span class="s1">Decimal</span><span class="s3">.</span><span class="s1">log </span><span class="s3">= </span><span class="s1">log</span><span class="s3">;</span>
  <span class="s1">Decimal</span><span class="s3">.</span><span class="s1">log10 </span><span class="s3">= </span><span class="s1">log10</span><span class="s3">;        </span><span class="s0">// ES6</span>
  <span class="s1">Decimal</span><span class="s3">.</span><span class="s1">log2 </span><span class="s3">= </span><span class="s1">log2</span><span class="s3">;          </span><span class="s0">// ES6</span>
  <span class="s1">Decimal</span><span class="s3">.</span><span class="s1">max </span><span class="s3">= </span><span class="s1">max</span><span class="s3">;</span>
  <span class="s1">Decimal</span><span class="s3">.</span><span class="s1">min </span><span class="s3">= </span><span class="s1">min</span><span class="s3">;</span>
  <span class="s1">Decimal</span><span class="s3">.</span><span class="s1">mod </span><span class="s3">= </span><span class="s1">mod</span><span class="s3">;</span>
  <span class="s1">Decimal</span><span class="s3">.</span><span class="s1">mul </span><span class="s3">= </span><span class="s1">mul</span><span class="s3">;</span>
  <span class="s1">Decimal</span><span class="s3">.</span><span class="s1">pow </span><span class="s3">= </span><span class="s1">pow</span><span class="s3">;</span>
  <span class="s1">Decimal</span><span class="s3">.</span><span class="s1">random </span><span class="s3">= </span><span class="s1">random</span><span class="s3">;</span>
  <span class="s1">Decimal</span><span class="s3">.</span><span class="s1">round </span><span class="s3">= </span><span class="s1">round</span><span class="s3">;</span>
  <span class="s1">Decimal</span><span class="s3">.</span><span class="s1">sign </span><span class="s3">= </span><span class="s1">sign</span><span class="s3">;          </span><span class="s0">// ES6</span>
  <span class="s1">Decimal</span><span class="s3">.</span><span class="s1">sin </span><span class="s3">= </span><span class="s1">sin</span><span class="s3">;</span>
  <span class="s1">Decimal</span><span class="s3">.</span><span class="s1">sinh </span><span class="s3">= </span><span class="s1">sinh</span><span class="s3">;          </span><span class="s0">// ES6</span>
  <span class="s1">Decimal</span><span class="s3">.</span><span class="s1">sqrt </span><span class="s3">= </span><span class="s1">sqrt</span><span class="s3">;</span>
  <span class="s1">Decimal</span><span class="s3">.</span><span class="s1">sub </span><span class="s3">= </span><span class="s1">sub</span><span class="s3">;</span>
  <span class="s1">Decimal</span><span class="s3">.</span><span class="s1">sum </span><span class="s3">= </span><span class="s1">sum</span><span class="s3">;</span>
  <span class="s1">Decimal</span><span class="s3">.</span><span class="s1">tan </span><span class="s3">= </span><span class="s1">tan</span><span class="s3">;</span>
  <span class="s1">Decimal</span><span class="s3">.</span><span class="s1">tanh </span><span class="s3">= </span><span class="s1">tanh</span><span class="s3">;          </span><span class="s0">// ES6</span>
  <span class="s1">Decimal</span><span class="s3">.</span><span class="s1">trunc </span><span class="s3">= </span><span class="s1">trunc</span><span class="s3">;        </span><span class="s0">// ES6</span>

  <span class="s2">if </span><span class="s3">(</span><span class="s1">obj </span><span class="s3">=== </span><span class="s2">void </span><span class="s4">0</span><span class="s3">) </span><span class="s1">obj </span><span class="s3">= {};</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">obj</span><span class="s3">) {</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">obj</span><span class="s3">.</span><span class="s1">defaults </span><span class="s3">!== </span><span class="s2">true</span><span class="s3">) {</span>
      <span class="s1">ps </span><span class="s3">= [</span><span class="s5">'precision'</span><span class="s3">, </span><span class="s5">'rounding'</span><span class="s3">, </span><span class="s5">'toExpNeg'</span><span class="s3">, </span><span class="s5">'toExpPos'</span><span class="s3">, </span><span class="s5">'maxE'</span><span class="s3">, </span><span class="s5">'minE'</span><span class="s3">, </span><span class="s5">'modulo'</span><span class="s3">, </span><span class="s5">'crypto'</span><span class="s3">];</span>
      <span class="s2">for </span><span class="s3">(</span><span class="s1">i </span><span class="s3">= </span><span class="s4">0</span><span class="s3">; </span><span class="s1">i </span><span class="s3">&lt; </span><span class="s1">ps</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;) </span><span class="s2">if </span><span class="s3">(!</span><span class="s1">obj</span><span class="s3">.</span><span class="s1">hasOwnProperty</span><span class="s3">(</span><span class="s1">p </span><span class="s3">= </span><span class="s1">ps</span><span class="s3">[</span><span class="s1">i</span><span class="s3">++])) </span><span class="s1">obj</span><span class="s3">[</span><span class="s1">p</span><span class="s3">] = </span><span class="s2">this</span><span class="s3">[</span><span class="s1">p</span><span class="s3">];</span>
    <span class="s3">}</span>
  <span class="s3">}</span>

  <span class="s1">Decimal</span><span class="s3">.</span><span class="s1">config</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">);</span>

  <span class="s2">return </span><span class="s1">Decimal</span><span class="s3">;</span>
<span class="s3">}</span>


<span class="s0">/* 
 * Return a new Decimal whose value is `x` divided by `y`, rounded to `precision` significant 
 * digits using rounding mode `rounding`. 
 * 
 * x {number|string|bigint|Decimal} 
 * y {number|string|bigint|Decimal} 
 * 
 */</span>
<span class="s2">function </span><span class="s1">div</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">) {</span>
  <span class="s2">return new this</span><span class="s3">(</span><span class="s1">x</span><span class="s3">).</span><span class="s1">div</span><span class="s3">(</span><span class="s1">y</span><span class="s3">);</span>
<span class="s3">}</span>


<span class="s0">/* 
 * Return a new Decimal whose value is the natural exponential of `x`, rounded to `precision` 
 * significant digits using rounding mode `rounding`. 
 * 
 * x {number|string|bigint|Decimal} The power to which to raise the base of the natural log. 
 * 
 */</span>
<span class="s2">function </span><span class="s1">exp</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) {</span>
  <span class="s2">return new this</span><span class="s3">(</span><span class="s1">x</span><span class="s3">).</span><span class="s1">exp</span><span class="s3">();</span>
<span class="s3">}</span>


<span class="s0">/* 
 * Return a new Decimal whose value is `x` round to an integer using `ROUND_FLOOR`. 
 * 
 * x {number|string|bigint|Decimal} 
 * 
 */</span>
<span class="s2">function </span><span class="s1">floor</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) {</span>
  <span class="s2">return </span><span class="s1">finalise</span><span class="s3">(</span><span class="s1">x </span><span class="s3">= </span><span class="s2">new this</span><span class="s3">(</span><span class="s1">x</span><span class="s3">), </span><span class="s1">x</span><span class="s3">.</span><span class="s1">e </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">, </span><span class="s4">3</span><span class="s3">);</span>
<span class="s3">}</span>


<span class="s0">/* 
 * Return a new Decimal whose value is the square root of the sum of the squares of the arguments, 
 * rounded to `precision` significant digits using rounding mode `rounding`. 
 * 
 * hypot(a, b, ...) = sqrt(a^2 + b^2 + ...) 
 * 
 * arguments {number|string|bigint|Decimal} 
 * 
 */</span>
<span class="s2">function </span><span class="s1">hypot</span><span class="s3">() {</span>
  <span class="s2">var </span><span class="s1">i</span><span class="s3">, </span><span class="s1">n</span><span class="s3">,</span>
    <span class="s1">t </span><span class="s3">= </span><span class="s2">new this</span><span class="s3">(</span><span class="s4">0</span><span class="s3">);</span>

  <span class="s1">external </span><span class="s3">= </span><span class="s2">false</span><span class="s3">;</span>

  <span class="s2">for </span><span class="s3">(</span><span class="s1">i </span><span class="s3">= </span><span class="s4">0</span><span class="s3">; </span><span class="s1">i </span><span class="s3">&lt; </span><span class="s1">arguments</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;) {</span>
    <span class="s1">n </span><span class="s3">= </span><span class="s2">new this</span><span class="s3">(</span><span class="s1">arguments</span><span class="s3">[</span><span class="s1">i</span><span class="s3">++]);</span>
    <span class="s2">if </span><span class="s3">(!</span><span class="s1">n</span><span class="s3">.</span><span class="s1">d</span><span class="s3">) {</span>
      <span class="s2">if </span><span class="s3">(</span><span class="s1">n</span><span class="s3">.</span><span class="s1">s</span><span class="s3">) {</span>
        <span class="s1">external </span><span class="s3">= </span><span class="s2">true</span><span class="s3">;</span>
        <span class="s2">return new this</span><span class="s3">(</span><span class="s4">1 </span><span class="s3">/ </span><span class="s4">0</span><span class="s3">);</span>
      <span class="s3">}</span>
      <span class="s1">t </span><span class="s3">= </span><span class="s1">n</span><span class="s3">;</span>
    <span class="s3">} </span><span class="s2">else if </span><span class="s3">(</span><span class="s1">t</span><span class="s3">.</span><span class="s1">d</span><span class="s3">) {</span>
      <span class="s1">t </span><span class="s3">= </span><span class="s1">t</span><span class="s3">.</span><span class="s1">plus</span><span class="s3">(</span><span class="s1">n</span><span class="s3">.</span><span class="s1">times</span><span class="s3">(</span><span class="s1">n</span><span class="s3">));</span>
    <span class="s3">}</span>
  <span class="s3">}</span>

  <span class="s1">external </span><span class="s3">= </span><span class="s2">true</span><span class="s3">;</span>

  <span class="s2">return </span><span class="s1">t</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">();</span>
<span class="s3">}</span>


<span class="s0">/* 
 * Return true if object is a Decimal instance (where Decimal is any Decimal constructor), 
 * otherwise return false. 
 * 
 */</span>
<span class="s2">function </span><span class="s1">isDecimalInstance</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">) {</span>
  <span class="s2">return </span><span class="s1">obj </span><span class="s2">instanceof </span><span class="s1">Decimal </span><span class="s3">|| </span><span class="s1">obj </span><span class="s3">&amp;&amp; </span><span class="s1">obj</span><span class="s3">.</span><span class="s1">toStringTag </span><span class="s3">=== </span><span class="s1">tag </span><span class="s3">|| </span><span class="s2">false</span><span class="s3">;</span>
<span class="s3">}</span>


<span class="s0">/* 
 * Return a new Decimal whose value is the natural logarithm of `x`, rounded to `precision` 
 * significant digits using rounding mode `rounding`. 
 * 
 * x {number|string|bigint|Decimal} 
 * 
 */</span>
<span class="s2">function </span><span class="s1">ln</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) {</span>
  <span class="s2">return new this</span><span class="s3">(</span><span class="s1">x</span><span class="s3">).</span><span class="s1">ln</span><span class="s3">();</span>
<span class="s3">}</span>


<span class="s0">/* 
 * Return a new Decimal whose value is the log of `x` to the base `y`, or to base 10 if no base 
 * is specified, rounded to `precision` significant digits using rounding mode `rounding`. 
 * 
 * log[y](x) 
 * 
 * x {number|string|bigint|Decimal} The argument of the logarithm. 
 * y {number|string|bigint|Decimal} The base of the logarithm. 
 * 
 */</span>
<span class="s2">function </span><span class="s1">log</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">) {</span>
  <span class="s2">return new this</span><span class="s3">(</span><span class="s1">x</span><span class="s3">).</span><span class="s1">log</span><span class="s3">(</span><span class="s1">y</span><span class="s3">);</span>
<span class="s3">}</span>


<span class="s0">/* 
 * Return a new Decimal whose value is the base 2 logarithm of `x`, rounded to `precision` 
 * significant digits using rounding mode `rounding`. 
 * 
 * x {number|string|bigint|Decimal} 
 * 
 */</span>
<span class="s2">function </span><span class="s1">log2</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) {</span>
  <span class="s2">return new this</span><span class="s3">(</span><span class="s1">x</span><span class="s3">).</span><span class="s1">log</span><span class="s3">(</span><span class="s4">2</span><span class="s3">);</span>
<span class="s3">}</span>


<span class="s0">/* 
 * Return a new Decimal whose value is the base 10 logarithm of `x`, rounded to `precision` 
 * significant digits using rounding mode `rounding`. 
 * 
 * x {number|string|bigint|Decimal} 
 * 
 */</span>
<span class="s2">function </span><span class="s1">log10</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) {</span>
  <span class="s2">return new this</span><span class="s3">(</span><span class="s1">x</span><span class="s3">).</span><span class="s1">log</span><span class="s3">(</span><span class="s4">10</span><span class="s3">);</span>
<span class="s3">}</span>


<span class="s0">/* 
 * Return a new Decimal whose value is the maximum of the arguments. 
 * 
 * arguments {number|string|bigint|Decimal} 
 * 
 */</span>
<span class="s2">function </span><span class="s1">max</span><span class="s3">() {</span>
  <span class="s2">return </span><span class="s1">maxOrMin</span><span class="s3">(</span><span class="s2">this</span><span class="s3">, </span><span class="s1">arguments</span><span class="s3">, -</span><span class="s4">1</span><span class="s3">);</span>
<span class="s3">}</span>


<span class="s0">/* 
 * Return a new Decimal whose value is the minimum of the arguments. 
 * 
 * arguments {number|string|bigint|Decimal} 
 * 
 */</span>
<span class="s2">function </span><span class="s1">min</span><span class="s3">() {</span>
  <span class="s2">return </span><span class="s1">maxOrMin</span><span class="s3">(</span><span class="s2">this</span><span class="s3">, </span><span class="s1">arguments</span><span class="s3">, </span><span class="s4">1</span><span class="s3">);</span>
<span class="s3">}</span>


<span class="s0">/* 
 * Return a new Decimal whose value is `x` modulo `y`, rounded to `precision` significant digits 
 * using rounding mode `rounding`. 
 * 
 * x {number|string|bigint|Decimal} 
 * y {number|string|bigint|Decimal} 
 * 
 */</span>
<span class="s2">function </span><span class="s1">mod</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">) {</span>
  <span class="s2">return new this</span><span class="s3">(</span><span class="s1">x</span><span class="s3">).</span><span class="s1">mod</span><span class="s3">(</span><span class="s1">y</span><span class="s3">);</span>
<span class="s3">}</span>


<span class="s0">/* 
 * Return a new Decimal whose value is `x` multiplied by `y`, rounded to `precision` significant 
 * digits using rounding mode `rounding`. 
 * 
 * x {number|string|bigint|Decimal} 
 * y {number|string|bigint|Decimal} 
 * 
 */</span>
<span class="s2">function </span><span class="s1">mul</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">) {</span>
  <span class="s2">return new this</span><span class="s3">(</span><span class="s1">x</span><span class="s3">).</span><span class="s1">mul</span><span class="s3">(</span><span class="s1">y</span><span class="s3">);</span>
<span class="s3">}</span>


<span class="s0">/* 
 * Return a new Decimal whose value is `x` raised to the power `y`, rounded to precision 
 * significant digits using rounding mode `rounding`. 
 * 
 * x {number|string|bigint|Decimal} The base. 
 * y {number|string|bigint|Decimal} The exponent. 
 * 
 */</span>
<span class="s2">function </span><span class="s1">pow</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">) {</span>
  <span class="s2">return new this</span><span class="s3">(</span><span class="s1">x</span><span class="s3">).</span><span class="s1">pow</span><span class="s3">(</span><span class="s1">y</span><span class="s3">);</span>
<span class="s3">}</span>


<span class="s0">/* 
 * Returns a new Decimal with a random value equal to or greater than 0 and less than 1, and with 
 * `sd`, or `Decimal.precision` if `sd` is omitted, significant digits (or less if trailing zeros 
 * are produced). 
 * 
 * [sd] {number} Significant digits. Integer, 0 to MAX_DIGITS inclusive. 
 * 
 */</span>
<span class="s2">function </span><span class="s1">random</span><span class="s3">(</span><span class="s1">sd</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">d</span><span class="s3">, </span><span class="s1">e</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">n</span><span class="s3">,</span>
    <span class="s1">i </span><span class="s3">= </span><span class="s4">0</span><span class="s3">,</span>
    <span class="s1">r </span><span class="s3">= </span><span class="s2">new this</span><span class="s3">(</span><span class="s4">1</span><span class="s3">),</span>
    <span class="s1">rd </span><span class="s3">= [];</span>

  <span class="s2">if </span><span class="s3">(</span><span class="s1">sd </span><span class="s3">=== </span><span class="s2">void </span><span class="s4">0</span><span class="s3">) </span><span class="s1">sd </span><span class="s3">= </span><span class="s2">this</span><span class="s3">.</span><span class="s1">precision</span><span class="s3">;</span>
  <span class="s2">else </span><span class="s1">checkInt32</span><span class="s3">(</span><span class="s1">sd</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s1">MAX_DIGITS</span><span class="s3">);</span>

  <span class="s1">k </span><span class="s3">= </span><span class="s1">Math</span><span class="s3">.</span><span class="s1">ceil</span><span class="s3">(</span><span class="s1">sd </span><span class="s3">/ </span><span class="s1">LOG_BASE</span><span class="s3">);</span>

  <span class="s2">if </span><span class="s3">(!</span><span class="s2">this</span><span class="s3">.</span><span class="s1">crypto</span><span class="s3">) {</span>
    <span class="s2">for </span><span class="s3">(; </span><span class="s1">i </span><span class="s3">&lt; </span><span class="s1">k</span><span class="s3">;) </span><span class="s1">rd</span><span class="s3">[</span><span class="s1">i</span><span class="s3">++] = </span><span class="s1">Math</span><span class="s3">.</span><span class="s1">random</span><span class="s3">() * </span><span class="s4">1e7 </span><span class="s3">| </span><span class="s4">0</span><span class="s3">;</span>

  <span class="s0">// Browsers supporting crypto.getRandomValues.</span>
  <span class="s3">} </span><span class="s2">else if </span><span class="s3">(</span><span class="s1">crypto</span><span class="s3">.</span><span class="s1">getRandomValues</span><span class="s3">) {</span>
    <span class="s1">d </span><span class="s3">= </span><span class="s1">crypto</span><span class="s3">.</span><span class="s1">getRandomValues</span><span class="s3">(</span><span class="s2">new </span><span class="s1">Uint32Array</span><span class="s3">(</span><span class="s1">k</span><span class="s3">));</span>

    <span class="s2">for </span><span class="s3">(; </span><span class="s1">i </span><span class="s3">&lt; </span><span class="s1">k</span><span class="s3">;) {</span>
      <span class="s1">n </span><span class="s3">= </span><span class="s1">d</span><span class="s3">[</span><span class="s1">i</span><span class="s3">];</span>

      <span class="s0">// 0 &lt;= n &lt; 4294967296</span>
      <span class="s0">// Probability n &gt;= 4.29e9, is 4967296 / 4294967296 = 0.00116 (1 in 865).</span>
      <span class="s2">if </span><span class="s3">(</span><span class="s1">n </span><span class="s3">&gt;= </span><span class="s4">4.29e9</span><span class="s3">) {</span>
        <span class="s1">d</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">crypto</span><span class="s3">.</span><span class="s1">getRandomValues</span><span class="s3">(</span><span class="s2">new </span><span class="s1">Uint32Array</span><span class="s3">(</span><span class="s4">1</span><span class="s3">))[</span><span class="s4">0</span><span class="s3">];</span>
      <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>

        <span class="s0">// 0 &lt;= n &lt;= 4289999999</span>
        <span class="s0">// 0 &lt;= (n % 1e7) &lt;= 9999999</span>
        <span class="s1">rd</span><span class="s3">[</span><span class="s1">i</span><span class="s3">++] = </span><span class="s1">n </span><span class="s3">% </span><span class="s4">1e7</span><span class="s3">;</span>
      <span class="s3">}</span>
    <span class="s3">}</span>

  <span class="s0">// Node.js supporting crypto.randomBytes.</span>
  <span class="s3">} </span><span class="s2">else if </span><span class="s3">(</span><span class="s1">crypto</span><span class="s3">.</span><span class="s1">randomBytes</span><span class="s3">) {</span>

    <span class="s0">// buffer</span>
    <span class="s1">d </span><span class="s3">= </span><span class="s1">crypto</span><span class="s3">.</span><span class="s1">randomBytes</span><span class="s3">(</span><span class="s1">k </span><span class="s3">*= </span><span class="s4">4</span><span class="s3">);</span>

    <span class="s2">for </span><span class="s3">(; </span><span class="s1">i </span><span class="s3">&lt; </span><span class="s1">k</span><span class="s3">;) {</span>

      <span class="s0">// 0 &lt;= n &lt; 2147483648</span>
      <span class="s1">n </span><span class="s3">= </span><span class="s1">d</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] + (</span><span class="s1">d</span><span class="s3">[</span><span class="s1">i </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">] &lt;&lt; </span><span class="s4">8</span><span class="s3">) + (</span><span class="s1">d</span><span class="s3">[</span><span class="s1">i </span><span class="s3">+ </span><span class="s4">2</span><span class="s3">] &lt;&lt; </span><span class="s4">16</span><span class="s3">) + ((</span><span class="s1">d</span><span class="s3">[</span><span class="s1">i </span><span class="s3">+ </span><span class="s4">3</span><span class="s3">] &amp; </span><span class="s4">0x7f</span><span class="s3">) &lt;&lt; </span><span class="s4">24</span><span class="s3">);</span>

      <span class="s0">// Probability n &gt;= 2.14e9, is 7483648 / 2147483648 = 0.0035 (1 in 286).</span>
      <span class="s2">if </span><span class="s3">(</span><span class="s1">n </span><span class="s3">&gt;= </span><span class="s4">2.14e9</span><span class="s3">) {</span>
        <span class="s1">crypto</span><span class="s3">.</span><span class="s1">randomBytes</span><span class="s3">(</span><span class="s4">4</span><span class="s3">).</span><span class="s1">copy</span><span class="s3">(</span><span class="s1">d</span><span class="s3">, </span><span class="s1">i</span><span class="s3">);</span>
      <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>

        <span class="s0">// 0 &lt;= n &lt;= 2139999999</span>
        <span class="s0">// 0 &lt;= (n % 1e7) &lt;= 9999999</span>
        <span class="s1">rd</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">n </span><span class="s3">% </span><span class="s4">1e7</span><span class="s3">);</span>
        <span class="s1">i </span><span class="s3">+= </span><span class="s4">4</span><span class="s3">;</span>
      <span class="s3">}</span>
    <span class="s3">}</span>

    <span class="s1">i </span><span class="s3">= </span><span class="s1">k </span><span class="s3">/ </span><span class="s4">4</span><span class="s3">;</span>
  <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
    <span class="s2">throw </span><span class="s1">Error</span><span class="s3">(</span><span class="s1">cryptoUnavailable</span><span class="s3">);</span>
  <span class="s3">}</span>

  <span class="s1">k </span><span class="s3">= </span><span class="s1">rd</span><span class="s3">[--</span><span class="s1">i</span><span class="s3">];</span>
  <span class="s1">sd </span><span class="s3">%= </span><span class="s1">LOG_BASE</span><span class="s3">;</span>

  <span class="s0">// Convert trailing digits to zeros according to sd.</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">k </span><span class="s3">&amp;&amp; </span><span class="s1">sd</span><span class="s3">) {</span>
    <span class="s1">n </span><span class="s3">= </span><span class="s1">mathpow</span><span class="s3">(</span><span class="s4">10</span><span class="s3">, </span><span class="s1">LOG_BASE </span><span class="s3">- </span><span class="s1">sd</span><span class="s3">);</span>
    <span class="s1">rd</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = (</span><span class="s1">k </span><span class="s3">/ </span><span class="s1">n </span><span class="s3">| </span><span class="s4">0</span><span class="s3">) * </span><span class="s1">n</span><span class="s3">;</span>
  <span class="s3">}</span>

  <span class="s0">// Remove trailing words which are zero.</span>
  <span class="s2">for </span><span class="s3">(; </span><span class="s1">rd</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] === </span><span class="s4">0</span><span class="s3">; </span><span class="s1">i</span><span class="s3">--) </span><span class="s1">rd</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">();</span>

  <span class="s0">// Zero?</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">i </span><span class="s3">&lt; </span><span class="s4">0</span><span class="s3">) {</span>
    <span class="s1">e </span><span class="s3">= </span><span class="s4">0</span><span class="s3">;</span>
    <span class="s1">rd </span><span class="s3">= [</span><span class="s4">0</span><span class="s3">];</span>
  <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
    <span class="s1">e </span><span class="s3">= -</span><span class="s4">1</span><span class="s3">;</span>

    <span class="s0">// Remove leading words which are zero and adjust exponent accordingly.</span>
    <span class="s2">for </span><span class="s3">(; </span><span class="s1">rd</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] === </span><span class="s4">0</span><span class="s3">; </span><span class="s1">e </span><span class="s3">-= </span><span class="s1">LOG_BASE</span><span class="s3">) </span><span class="s1">rd</span><span class="s3">.</span><span class="s1">shift</span><span class="s3">();</span>

    <span class="s0">// Count the digits of the first word of rd to determine leading zeros.</span>
    <span class="s2">for </span><span class="s3">(</span><span class="s1">k </span><span class="s3">= </span><span class="s4">1</span><span class="s3">, </span><span class="s1">n </span><span class="s3">= </span><span class="s1">rd</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]; </span><span class="s1">n </span><span class="s3">&gt;= </span><span class="s4">10</span><span class="s3">; </span><span class="s1">n </span><span class="s3">/= </span><span class="s4">10</span><span class="s3">) </span><span class="s1">k</span><span class="s3">++;</span>

    <span class="s0">// Adjust the exponent for leading zeros of the first word of rd.</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">k </span><span class="s3">&lt; </span><span class="s1">LOG_BASE</span><span class="s3">) </span><span class="s1">e </span><span class="s3">-= </span><span class="s1">LOG_BASE </span><span class="s3">- </span><span class="s1">k</span><span class="s3">;</span>
  <span class="s3">}</span>

  <span class="s1">r</span><span class="s3">.</span><span class="s1">e </span><span class="s3">= </span><span class="s1">e</span><span class="s3">;</span>
  <span class="s1">r</span><span class="s3">.</span><span class="s1">d </span><span class="s3">= </span><span class="s1">rd</span><span class="s3">;</span>

  <span class="s2">return </span><span class="s1">r</span><span class="s3">;</span>
<span class="s3">}</span>


<span class="s0">/* 
 * Return a new Decimal whose value is `x` rounded to an integer using rounding mode `rounding`. 
 * 
 * To emulate `Math.round`, set rounding to 7 (ROUND_HALF_CEIL). 
 * 
 * x {number|string|bigint|Decimal} 
 * 
 */</span>
<span class="s2">function </span><span class="s1">round</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) {</span>
  <span class="s2">return </span><span class="s1">finalise</span><span class="s3">(</span><span class="s1">x </span><span class="s3">= </span><span class="s2">new this</span><span class="s3">(</span><span class="s1">x</span><span class="s3">), </span><span class="s1">x</span><span class="s3">.</span><span class="s1">e </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">, </span><span class="s2">this</span><span class="s3">.</span><span class="s1">rounding</span><span class="s3">);</span>
<span class="s3">}</span>


<span class="s0">/* 
 * Return 
 *   1    if x &gt; 0, 
 *  -1    if x &lt; 0, 
 *   0    if x is 0, 
 *  -0    if x is -0, 
 *   NaN  otherwise 
 * 
 * x {number|string|bigint|Decimal} 
 * 
 */</span>
<span class="s2">function </span><span class="s1">sign</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) {</span>
  <span class="s1">x </span><span class="s3">= </span><span class="s2">new this</span><span class="s3">(</span><span class="s1">x</span><span class="s3">);</span>
  <span class="s2">return </span><span class="s1">x</span><span class="s3">.</span><span class="s1">d </span><span class="s3">? (</span><span class="s1">x</span><span class="s3">.</span><span class="s1">d</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] ? </span><span class="s1">x</span><span class="s3">.</span><span class="s1">s </span><span class="s3">: </span><span class="s4">0 </span><span class="s3">* </span><span class="s1">x</span><span class="s3">.</span><span class="s1">s</span><span class="s3">) : </span><span class="s1">x</span><span class="s3">.</span><span class="s1">s </span><span class="s3">|| </span><span class="s1">NaN</span><span class="s3">;</span>
<span class="s3">}</span>


<span class="s0">/* 
 * Return a new Decimal whose value is the sine of `x`, rounded to `precision` significant digits 
 * using rounding mode `rounding`. 
 * 
 * x {number|string|bigint|Decimal} A value in radians. 
 * 
 */</span>
<span class="s2">function </span><span class="s1">sin</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) {</span>
  <span class="s2">return new this</span><span class="s3">(</span><span class="s1">x</span><span class="s3">).</span><span class="s1">sin</span><span class="s3">();</span>
<span class="s3">}</span>


<span class="s0">/* 
 * Return a new Decimal whose value is the hyperbolic sine of `x`, rounded to `precision` 
 * significant digits using rounding mode `rounding`. 
 * 
 * x {number|string|bigint|Decimal} A value in radians. 
 * 
 */</span>
<span class="s2">function </span><span class="s1">sinh</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) {</span>
  <span class="s2">return new this</span><span class="s3">(</span><span class="s1">x</span><span class="s3">).</span><span class="s1">sinh</span><span class="s3">();</span>
<span class="s3">}</span>


<span class="s0">/* 
 * Return a new Decimal whose value is the square root of `x`, rounded to `precision` significant 
 * digits using rounding mode `rounding`. 
 * 
 * x {number|string|bigint|Decimal} 
 * 
 */</span>
<span class="s2">function </span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) {</span>
  <span class="s2">return new this</span><span class="s3">(</span><span class="s1">x</span><span class="s3">).</span><span class="s1">sqrt</span><span class="s3">();</span>
<span class="s3">}</span>


<span class="s0">/* 
 * Return a new Decimal whose value is `x` minus `y`, rounded to `precision` significant digits 
 * using rounding mode `rounding`. 
 * 
 * x {number|string|bigint|Decimal} 
 * y {number|string|bigint|Decimal} 
 * 
 */</span>
<span class="s2">function </span><span class="s1">sub</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">) {</span>
  <span class="s2">return new this</span><span class="s3">(</span><span class="s1">x</span><span class="s3">).</span><span class="s1">sub</span><span class="s3">(</span><span class="s1">y</span><span class="s3">);</span>
<span class="s3">}</span>


<span class="s0">/* 
 * Return a new Decimal whose value is the sum of the arguments, rounded to `precision` 
 * significant digits using rounding mode `rounding`. 
 * 
 * Only the result is rounded, not the intermediate calculations. 
 * 
 * arguments {number|string|bigint|Decimal} 
 * 
 */</span>
<span class="s2">function </span><span class="s1">sum</span><span class="s3">() {</span>
  <span class="s2">var </span><span class="s1">i </span><span class="s3">= </span><span class="s4">0</span><span class="s3">,</span>
    <span class="s1">args </span><span class="s3">= </span><span class="s1">arguments</span><span class="s3">,</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s2">new this</span><span class="s3">(</span><span class="s1">args</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]);</span>

  <span class="s1">external </span><span class="s3">= </span><span class="s2">false</span><span class="s3">;</span>
  <span class="s2">for </span><span class="s3">(; </span><span class="s1">x</span><span class="s3">.</span><span class="s1">s </span><span class="s3">&amp;&amp; ++</span><span class="s1">i </span><span class="s3">&lt; </span><span class="s1">args</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;) </span><span class="s1">x </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">plus</span><span class="s3">(</span><span class="s1">args</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]);</span>
  <span class="s1">external </span><span class="s3">= </span><span class="s2">true</span><span class="s3">;</span>

  <span class="s2">return </span><span class="s1">finalise</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s2">this</span><span class="s3">.</span><span class="s1">precision</span><span class="s3">, </span><span class="s2">this</span><span class="s3">.</span><span class="s1">rounding</span><span class="s3">);</span>
<span class="s3">}</span>


<span class="s0">/* 
 * Return a new Decimal whose value is the tangent of `x`, rounded to `precision` significant 
 * digits using rounding mode `rounding`. 
 * 
 * x {number|string|bigint|Decimal} A value in radians. 
 * 
 */</span>
<span class="s2">function </span><span class="s1">tan</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) {</span>
  <span class="s2">return new this</span><span class="s3">(</span><span class="s1">x</span><span class="s3">).</span><span class="s1">tan</span><span class="s3">();</span>
<span class="s3">}</span>


<span class="s0">/* 
 * Return a new Decimal whose value is the hyperbolic tangent of `x`, rounded to `precision` 
 * significant digits using rounding mode `rounding`. 
 * 
 * x {number|string|bigint|Decimal} A value in radians. 
 * 
 */</span>
<span class="s2">function </span><span class="s1">tanh</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) {</span>
  <span class="s2">return new this</span><span class="s3">(</span><span class="s1">x</span><span class="s3">).</span><span class="s1">tanh</span><span class="s3">();</span>
<span class="s3">}</span>


<span class="s0">/* 
 * Return a new Decimal whose value is `x` truncated to an integer. 
 * 
 * x {number|string|bigint|Decimal} 
 * 
 */</span>
<span class="s2">function </span><span class="s1">trunc</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) {</span>
  <span class="s2">return </span><span class="s1">finalise</span><span class="s3">(</span><span class="s1">x </span><span class="s3">= </span><span class="s2">new this</span><span class="s3">(</span><span class="s1">x</span><span class="s3">), </span><span class="s1">x</span><span class="s3">.</span><span class="s1">e </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">);</span>
<span class="s3">}</span>


<span class="s1">P</span><span class="s3">[</span><span class="s1">Symbol</span><span class="s3">.</span><span class="s1">for</span><span class="s3">(</span><span class="s5">'nodejs.util.inspect.custom'</span><span class="s3">)] = </span><span class="s1">P</span><span class="s3">.</span><span class="s1">toString</span><span class="s3">;</span>
<span class="s1">P</span><span class="s3">[</span><span class="s1">Symbol</span><span class="s3">.</span><span class="s1">toStringTag</span><span class="s3">] = </span><span class="s5">'Decimal'</span><span class="s3">;</span>

<span class="s0">// Create and configure initial Decimal constructor.</span>
<span class="s2">export var </span><span class="s1">Decimal </span><span class="s3">= </span><span class="s1">P</span><span class="s3">.</span><span class="s1">constructor </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">DEFAULTS</span><span class="s3">);</span>

<span class="s0">// Create the internal constants from their string values.</span>
<span class="s1">LN10 </span><span class="s3">= </span><span class="s2">new </span><span class="s1">Decimal</span><span class="s3">(</span><span class="s1">LN10</span><span class="s3">);</span>
<span class="s1">PI </span><span class="s3">= </span><span class="s2">new </span><span class="s1">Decimal</span><span class="s3">(</span><span class="s1">PI</span><span class="s3">);</span>

<span class="s2">export default </span><span class="s1">Decimal</span><span class="s3">;</span>
</pre>
</body>
</html>