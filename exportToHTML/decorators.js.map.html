<html>
<head>
<title>decorators.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
decorators.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_core&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;_helperReplaceSupers&quot;</span><span class="s0">,</span><span class="s1">&quot;_helperSkipTransparentExpressionWrappers&quot;</span><span class="s0">,</span><span class="s1">&quot;_fields&quot;</span><span class="s0">,</span><span class="s1">&quot;_misc&quot;</span><span class="s0">,</span><span class="s1">&quot;hasOwnDecorators&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;_node$decorators&quot;</span><span class="s0">,</span><span class="s1">&quot;decorators&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;hasDecorators&quot;</span><span class="s0">,</span><span class="s1">&quot;body&quot;</span><span class="s0">,</span><span class="s1">&quot;some&quot;</span><span class="s0">,</span><span class="s1">&quot;incrementId&quot;</span><span class="s0">,</span><span class="s1">&quot;id&quot;</span><span class="s0">,</span><span class="s1">&quot;idx&quot;</span><span class="s0">,</span><span class="s1">&quot;unshift&quot;</span><span class="s0">,</span><span class="s1">&quot;current&quot;</span><span class="s0">,</span><span class="s1">&quot;createPrivateUidGeneratorForClass&quot;</span><span class="s0">,</span><span class="s1">&quot;classPath&quot;</span><span class="s0">,</span><span class="s1">&quot;currentPrivateId&quot;</span><span class="s0">,</span><span class="s1">&quot;privateNames&quot;</span><span class="s0">,</span><span class="s1">&quot;Set&quot;</span><span class="s0">,</span><span class="s1">&quot;traverse&quot;</span><span class="s0">,</span><span class="s1">&quot;PrivateName&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;add&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;reifiedId&quot;</span><span class="s0">,</span><span class="s1">&quot;String&quot;</span><span class="s0">,</span><span class="s1">&quot;fromCharCode&quot;</span><span class="s0">,</span><span class="s1">&quot;has&quot;</span><span class="s0">,</span><span class="s1">&quot;t&quot;</span><span class="s0">,</span><span class="s1">&quot;privateName&quot;</span><span class="s0">,</span><span class="s1">&quot;identifier&quot;</span><span class="s0">,</span><span class="s1">&quot;createLazyPrivateUidGeneratorForClass&quot;</span><span class="s0">,</span><span class="s1">&quot;generator&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceClassWithVar&quot;</span><span class="s0">,</span><span class="s1">&quot;className&quot;</span><span class="s0">,</span><span class="s1">&quot;scope&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;varId&quot;</span><span class="s0">,</span><span class="s1">&quot;generateUidIdentifierBasedOnNode&quot;</span><span class="s0">,</span><span class="s1">&quot;classId&quot;</span><span class="s0">,</span><span class="s1">&quot;rename&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceWith&quot;</span><span class="s0">,</span><span class="s1">&quot;cloneNode&quot;</span><span class="s0">,</span><span class="s1">&quot;generateLetUidIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;parent&quot;</span><span class="s0">,</span><span class="s1">&quot;newClassExpr&quot;</span><span class="s0">,</span><span class="s1">&quot;classExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;superClass&quot;</span><span class="s0">,</span><span class="s1">&quot;newPath&quot;</span><span class="s0">,</span><span class="s1">&quot;sequenceExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;generateClassProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;isStatic&quot;</span><span class="s0">,</span><span class="s1">&quot;classPrivateProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;classProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;assignIdForAnonymousClass&quot;</span><span class="s0">,</span><span class="s1">&quot;generateUidIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;addProxyAccessorsFor&quot;</span><span class="s0">,</span><span class="s1">&quot;element&quot;</span><span class="s0">,</span><span class="s1">&quot;getterKey&quot;</span><span class="s0">,</span><span class="s1">&quot;setterKey&quot;</span><span class="s0">,</span><span class="s1">&quot;targetKey&quot;</span><span class="s0">,</span><span class="s1">&quot;isComputed&quot;</span><span class="s0">,</span><span class="s1">&quot;version&quot;</span><span class="s0">,</span><span class="s1">&quot;thisArg&quot;</span><span class="s0">,</span><span class="s1">&quot;thisExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;getterBody&quot;</span><span class="s0">,</span><span class="s1">&quot;blockStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;returnStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;memberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;setterBody&quot;</span><span class="s0">,</span><span class="s1">&quot;expressionStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;assignmentExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;getter&quot;</span><span class="s0">,</span><span class="s1">&quot;setter&quot;</span><span class="s0">,</span><span class="s1">&quot;classPrivateMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;classMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;insertAfter&quot;</span><span class="s0">,</span><span class="s1">&quot;extractProxyAccessorsFor&quot;</span><span class="s0">,</span><span class="s1">&quot;template&quot;</span><span class="s0">,</span><span class="s1">&quot;expression&quot;</span><span class="s0">,</span><span class="s1">&quot;ast&quot;</span><span class="s0">,</span><span class="s1">&quot;getComputedKeyLastElement&quot;</span><span class="s0">,</span><span class="s1">&quot;skipTransparentExprWrappers&quot;</span><span class="s0">,</span><span class="s1">&quot;isSequenceExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;expressions&quot;</span><span class="s0">,</span><span class="s1">&quot;getComputedKeyMemoiser&quot;</span><span class="s0">,</span><span class="s1">&quot;isConstantExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;hasUid&quot;</span><span class="s0">,</span><span class="s1">&quot;isAssignmentExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;left&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;toString&quot;</span><span class="s0">,</span><span class="s1">&quot;prependExpressionsToComputedKey&quot;</span><span class="s0">,</span><span class="s1">&quot;fieldPath&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;maybeSequenceExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;appendExpressionsToComputedKey&quot;</span><span class="s0">,</span><span class="s1">&quot;completion&quot;</span><span class="s0">,</span><span class="s1">&quot;scopeParent&quot;</span><span class="s0">,</span><span class="s1">&quot;maybeAssignment&quot;</span><span class="s0">,</span><span class="s1">&quot;memoiseComputedKey&quot;</span><span class="s0">,</span><span class="s1">&quot;generateUid&quot;</span><span class="s0">,</span><span class="s1">&quot;expressionSequence&quot;</span><span class="s0">,</span><span class="s1">&quot;completionParent&quot;</span><span class="s0">,</span><span class="s1">&quot;parentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;pushContainer&quot;</span><span class="s0">,</span><span class="s1">&quot;prependExpressionsToFieldInitializer&quot;</span><span class="s0">,</span><span class="s1">&quot;initializer&quot;</span><span class="s0">,</span><span class="s1">&quot;unaryExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;prependExpressionsToStaticBlock&quot;</span><span class="s0">,</span><span class="s1">&quot;blockPath&quot;</span><span class="s0">,</span><span class="s1">&quot;unshiftContainer&quot;</span><span class="s0">,</span><span class="s1">&quot;prependExpressionsToConstructor&quot;</span><span class="s0">,</span><span class="s1">&quot;constructorPath&quot;</span><span class="s0">,</span><span class="s1">&quot;isProtoInitCallExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;protoInitCall&quot;</span><span class="s0">,</span><span class="s1">&quot;isCallExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;callee&quot;</span><span class="s0">,</span><span class="s1">&quot;optimizeSuperCallAndExpressions&quot;</span><span class="s0">,</span><span class="s1">&quot;protoInitLocal&quot;</span><span class="s0">,</span><span class="s1">&quot;mergedSuperCall&quot;</span><span class="s0">,</span><span class="s1">&quot;callExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;splice&quot;</span><span class="s0">,</span><span class="s1">&quot;isThisExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;insertExpressionsAfterSuperCallAndOptimize&quot;</span><span class="s0">,</span><span class="s1">&quot;CallExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;exit&quot;</span><span class="s0">,</span><span class="s1">&quot;isSuper&quot;</span><span class="s0">,</span><span class="s1">&quot;newNodes&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;expr&quot;</span><span class="s0">,</span><span class="s1">&quot;isCompletionRecord&quot;</span><span class="s0">,</span><span class="s1">&quot;skip&quot;</span><span class="s0">,</span><span class="s1">&quot;ClassMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;kind&quot;</span><span class="s0">,</span><span class="s1">&quot;createConstructorFromExpressions&quot;</span><span class="s0">,</span><span class="s1">&quot;isDerivedClass&quot;</span><span class="s0">,</span><span class="s1">&quot;super&quot;</span><span class="s0">,</span><span class="s1">&quot;spreadElement&quot;</span><span class="s0">,</span><span class="s1">&quot;restElement&quot;</span><span class="s0">,</span><span class="s1">&quot;createStaticBlockFromExpressions&quot;</span><span class="s0">,</span><span class="s1">&quot;staticBlock&quot;</span><span class="s0">,</span><span class="s1">&quot;FIELD&quot;</span><span class="s0">,</span><span class="s1">&quot;ACCESSOR&quot;</span><span class="s0">,</span><span class="s1">&quot;METHOD&quot;</span><span class="s0">,</span><span class="s1">&quot;GETTER&quot;</span><span class="s0">,</span><span class="s1">&quot;SETTER&quot;</span><span class="s0">,</span><span class="s1">&quot;STATIC_OLD_VERSION&quot;</span><span class="s0">,</span><span class="s1">&quot;STATIC&quot;</span><span class="s0">,</span><span class="s1">&quot;DECORATORS_HAVE_THIS&quot;</span><span class="s0">,</span><span class="s1">&quot;getElementKind&quot;</span><span class="s0">,</span><span class="s1">&quot;toSortedDecoratorInfo&quot;</span><span class="s0">,</span><span class="s1">&quot;info&quot;</span><span class="s0">,</span><span class="s1">&quot;filter&quot;</span><span class="s0">,</span><span class="s1">&quot;el&quot;</span><span class="s0">,</span><span class="s1">&quot;generateDecorationList&quot;</span><span class="s0">,</span><span class="s1">&quot;decoratorsThis&quot;</span><span class="s0">,</span><span class="s1">&quot;decsCount&quot;</span><span class="s0">,</span><span class="s1">&quot;haveOneThis&quot;</span><span class="s0">,</span><span class="s1">&quot;Boolean&quot;</span><span class="s0">,</span><span class="s1">&quot;decs&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;numericLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;haveThis&quot;</span><span class="s0">,</span><span class="s1">&quot;generateDecorationExprs&quot;</span><span class="s0">,</span><span class="s1">&quot;decorationInfo&quot;</span><span class="s0">,</span><span class="s1">&quot;arrayExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;flag&quot;</span><span class="s0">,</span><span class="s1">&quot;decoratorsHaveThis&quot;</span><span class="s0">,</span><span class="s1">&quot;decoratorsArray&quot;</span><span class="s0">,</span><span class="s1">&quot;privateMethods&quot;</span><span class="s0">,</span><span class="s1">&quot;extractElementLocalAssignments&quot;</span><span class="s0">,</span><span class="s1">&quot;localIds&quot;</span><span class="s0">,</span><span class="s1">&quot;locals&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;isArray&quot;</span><span class="s0">,</span><span class="s1">&quot;addCallAccessorsFor&quot;</span><span class="s0">,</span><span class="s1">&quot;getId&quot;</span><span class="s0">,</span><span class="s1">&quot;setId&quot;</span><span class="s0">,</span><span class="s1">&quot;movePrivateAccessor&quot;</span><span class="s0">,</span><span class="s1">&quot;methodLocalVar&quot;</span><span class="s0">,</span><span class="s1">&quot;params&quot;</span><span class="s0">,</span><span class="s1">&quot;block&quot;</span><span class="s0">,</span><span class="s1">&quot;isClassDecoratableElementPath&quot;</span><span class="s0">,</span><span class="s1">&quot;staticBlockToIIFE&quot;</span><span class="s0">,</span><span class="s1">&quot;arrowFunctionExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;staticBlockToFunctionClosure&quot;</span><span class="s0">,</span><span class="s1">&quot;functionExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;fieldInitializerToClosure&quot;</span><span class="s0">,</span><span class="s1">&quot;exprs&quot;</span><span class="s0">,</span><span class="s1">&quot;createFunctionExpressionFromPrivateMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;isGenerator&quot;</span><span class="s0">,</span><span class="s1">&quot;async&quot;</span><span class="s0">,</span><span class="s1">&quot;isAsync&quot;</span><span class="s0">,</span><span class="s1">&quot;createSetFunctionNameCall&quot;</span><span class="s0">,</span><span class="s1">&quot;state&quot;</span><span class="s0">,</span><span class="s1">&quot;addHelper&quot;</span><span class="s0">,</span><span class="s1">&quot;createToPropertyKeyCall&quot;</span><span class="s0">,</span><span class="s1">&quot;propertyKey&quot;</span><span class="s0">,</span><span class="s1">&quot;createPrivateBrandCheckClosure&quot;</span><span class="s0">,</span><span class="s1">&quot;brandName&quot;</span><span class="s0">,</span><span class="s1">&quot;binaryExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;usesPrivateField&quot;</span><span class="s0">,</span><span class="s1">&quot;traverseFast&quot;</span><span class="s0">,</span><span class="s1">&quot;isPrivateName&quot;</span><span class="s0">,</span><span class="s1">&quot;_unused&quot;</span><span class="s0">,</span><span class="s1">&quot;convertToComputedKey&quot;</span><span class="s0">,</span><span class="s1">&quot;computed&quot;</span><span class="s0">,</span><span class="s1">&quot;stringLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;hasInstancePrivateAccess&quot;</span><span class="s0">,</span><span class="s1">&quot;containsInstancePrivateAccess&quot;</span><span class="s0">,</span><span class="s1">&quot;privateNameVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;privateNameVisitorFactory&quot;</span><span class="s0">,</span><span class="s1">&quot;privateNamesMap&quot;</span><span class="s0">,</span><span class="s1">&quot;stop&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;checkPrivateMethodUpdateError&quot;</span><span class="s0">,</span><span class="s1">&quot;decoratedPrivateMethods&quot;</span><span class="s0">,</span><span class="s1">&quot;parentParentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;buildCodeFrameError&quot;</span><span class="s0">,</span><span class="s1">&quot;transformClass&quot;</span><span class="s0">,</span><span class="s1">&quot;constantSuper&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreFunctionLength&quot;</span><span class="s0">,</span><span class="s1">&quot;propertyVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;_path$node$id&quot;</span><span class="s0">,</span><span class="s1">&quot;classDecorators&quot;</span><span class="s0">,</span><span class="s1">&quot;hasElementDecorators&quot;</span><span class="s0">,</span><span class="s1">&quot;hasComputedKeysSideEffects&quot;</span><span class="s0">,</span><span class="s1">&quot;elemDecsUseFnContext&quot;</span><span class="s0">,</span><span class="s1">&quot;generateClassPrivateUid&quot;</span><span class="s0">,</span><span class="s1">&quot;classAssignments&quot;</span><span class="s0">,</span><span class="s1">&quot;memoiseExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;hint&quot;</span><span class="s0">,</span><span class="s1">&quot;assignments&quot;</span><span class="s0">,</span><span class="s1">&quot;localEvaluatedId&quot;</span><span class="s0">,</span><span class="s1">&quot;staticInitLocal&quot;</span><span class="s0">,</span><span class="s1">&quot;classIdName&quot;</span><span class="s0">,</span><span class="s1">&quot;setClassName&quot;</span><span class="s0">,</span><span class="s1">&quot;usesFunctionContextOrYieldAwait&quot;</span><span class="s0">,</span><span class="s1">&quot;decorator&quot;</span><span class="s0">,</span><span class="s1">&quot;isYieldExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isAwaitExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isMetaProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;meta&quot;</span><span class="s0">,</span><span class="s1">&quot;_unused2&quot;</span><span class="s0">,</span><span class="s1">&quot;instancePrivateNames&quot;</span><span class="s0">,</span><span class="s1">&quot;elementNode&quot;</span><span class="s0">,</span><span class="s1">&quot;static&quot;</span><span class="s0">,</span><span class="s1">&quot;isDecorated&quot;</span><span class="s0">,</span><span class="s1">&quot;ClassProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;ClassPrivateProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;ClassAccessorProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;newId&quot;</span><span class="s0">,</span><span class="s1">&quot;newField&quot;</span><span class="s0">,</span><span class="s1">&quot;keyPath&quot;</span><span class="s0">,</span><span class="s1">&quot;elementDecoratorInfo&quot;</span><span class="s0">,</span><span class="s1">&quot;classInitLocal&quot;</span><span class="s0">,</span><span class="s1">&quot;classIdLocal&quot;</span><span class="s0">,</span><span class="s1">&quot;decoratorReceiverId&quot;</span><span class="s0">,</span><span class="s1">&quot;handleDecorators&quot;</span><span class="s0">,</span><span class="s1">&quot;hasSideEffects&quot;</span><span class="s0">,</span><span class="s1">&quot;usesFnContext&quot;</span><span class="s0">,</span><span class="s1">&quot;object&quot;</span><span class="s0">,</span><span class="s1">&quot;isMemberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;willExtractSomeElemDecs&quot;</span><span class="s0">,</span><span class="s1">&quot;needsDeclaraionForClassBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;classDecorationsFlag&quot;</span><span class="s0">,</span><span class="s1">&quot;classDecorations&quot;</span><span class="s0">,</span><span class="s1">&quot;classDecorationsId&quot;</span><span class="s0">,</span><span class="s1">&quot;computedKeyAssignments&quot;</span><span class="s0">,</span><span class="s1">&quot;isClassDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;classDecsUsePrivateName&quot;</span><span class="s0">,</span><span class="s1">&quot;isClassProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;lastInstancePrivateName&quot;</span><span class="s0">,</span><span class="s1">&quot;needsInstancePrivateBrandCheck&quot;</span><span class="s0">,</span><span class="s1">&quot;fieldInitializerExpressions&quot;</span><span class="s0">,</span><span class="s1">&quot;staticFieldInitializerExpressions&quot;</span><span class="s0">,</span><span class="s1">&quot;isStaticBlock&quot;</span><span class="s0">,</span><span class="s1">&quot;isPrivate&quot;</span><span class="s0">,</span><span class="s1">&quot;isClassPrivateProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;isClassMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;nameExpr&quot;</span><span class="s0">,</span><span class="s1">&quot;newFieldInitId&quot;</span><span class="s0">,</span><span class="s1">&quot;newValue&quot;</span><span class="s0">,</span><span class="s1">&quot;initId&quot;</span><span class="s0">,</span><span class="s1">&quot;valuePath&quot;</span><span class="s0">,</span><span class="s1">&quot;args&quot;</span><span class="s0">,</span><span class="s1">&quot;callId&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceSupers&quot;</span><span class="s0">,</span><span class="s1">&quot;ReplaceSupers&quot;</span><span class="s0">,</span><span class="s1">&quot;methodPath&quot;</span><span class="s0">,</span><span class="s1">&quot;objectRef&quot;</span><span class="s0">,</span><span class="s1">&quot;superRef&quot;</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">,</span><span class="s1">&quot;refToPreserve&quot;</span><span class="s0">,</span><span class="s1">&quot;replace&quot;</span><span class="s0">,</span><span class="s1">&quot;remove&quot;</span><span class="s0">,</span><span class="s1">&quot;getNextSibling&quot;</span><span class="s0">,</span><span class="s1">&quot;initExtraId&quot;</span><span class="s0">,</span><span class="s1">&quot;initExtraCall&quot;</span><span class="s0">,</span><span class="s1">&quot;elements&quot;</span><span class="s0">,</span><span class="s1">&quot;lastComputedElement&quot;</span><span class="s0">,</span><span class="s1">&quot;sortedElementDecoratorInfo&quot;</span><span class="s0">,</span><span class="s1">&quot;elementDecorations&quot;</span><span class="s0">,</span><span class="s1">&quot;elementLocals&quot;</span><span class="s0">,</span><span class="s1">&quot;classLocals&quot;</span><span class="s0">,</span><span class="s1">&quot;classInitInjected&quot;</span><span class="s0">,</span><span class="s1">&quot;classInitCall&quot;</span><span class="s0">,</span><span class="s1">&quot;originalClassPath&quot;</span><span class="s0">,</span><span class="s1">&quot;originalClass&quot;</span><span class="s0">,</span><span class="s1">&quot;staticClosures&quot;</span><span class="s0">,</span><span class="s1">&quot;statics&quot;</span><span class="s0">,</span><span class="s1">&quot;forEach&quot;</span><span class="s0">,</span><span class="s1">&quot;staticBlockClosureId&quot;</span><span class="s0">,</span><span class="s1">&quot;fieldValueClosureId&quot;</span><span class="s0">,</span><span class="s1">&quot;isClassPrivateMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;privateMethodDelegateId&quot;</span><span class="s0">,</span><span class="s1">&quot;p&quot;</span><span class="s0">,</span><span class="s1">&quot;isRestElement&quot;</span><span class="s0">,</span><span class="s1">&quot;staticsClass&quot;</span><span class="s0">,</span><span class="s1">&quot;toExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;constructorBody&quot;</span><span class="s0">,</span><span class="s1">&quot;newExpr&quot;</span><span class="s0">,</span><span class="s1">&quot;newExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;arguments&quot;</span><span class="s0">,</span><span class="s1">&quot;maybeGenerateMemoised&quot;</span><span class="s0">,</span><span class="s1">&quot;applyDecoratorWrapper&quot;</span><span class="s0">,</span><span class="s1">&quot;applyDecsBody&quot;</span><span class="s0">,</span><span class="s1">&quot;firstPublicElement&quot;</span><span class="s0">,</span><span class="s1">&quot;createLocalsAssignment&quot;</span><span class="s0">,</span><span class="s1">&quot;insertBefore&quot;</span><span class="s0">,</span><span class="s1">&quot;classBindingInfo&quot;</span><span class="s0">,</span><span class="s1">&quot;getBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;constantViolations&quot;</span><span class="s0">,</span><span class="s1">&quot;variableDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;variableDeclarator&quot;</span><span class="s0">,</span><span class="s1">&quot;classOuterBindingDelegateLocal&quot;</span><span class="s0">,</span><span class="s1">&quot;classOuterBindingLocal&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceWithMultiple&quot;</span><span class="s0">,</span><span class="s1">&quot;size&quot;</span><span class="s0">,</span><span class="s1">&quot;crawl&quot;</span><span class="s0">,</span><span class="s1">&quot;maybePrivateBrandName&quot;</span><span class="s0">,</span><span class="s1">&quot;lhs&quot;</span><span class="s0">,</span><span class="s1">&quot;rhs&quot;</span><span class="s0">,</span><span class="s1">&quot;availableHelper&quot;</span><span class="s0">,</span><span class="s1">&quot;arrayPattern&quot;</span><span class="s0">,</span><span class="s1">&quot;objectPattern&quot;</span><span class="s0">,</span><span class="s1">&quot;objectProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;isProtoKey&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldTransformElement&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldTransformClass&quot;</span><span class="s0">,</span><span class="s1">&quot;NamedEvaluationVisitoryFactory&quot;</span><span class="s0">,</span><span class="s1">&quot;isAnonymous&quot;</span><span class="s0">,</span><span class="s1">&quot;visitor&quot;</span><span class="s0">,</span><span class="s1">&quot;handleComputedProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;propertyPath&quot;</span><span class="s0">,</span><span class="s1">&quot;keyValue&quot;</span><span class="s0">,</span><span class="s1">&quot;ref&quot;</span><span class="s0">,</span><span class="s1">&quot;VariableDeclarator&quot;</span><span class="s0">,</span><span class="s1">&quot;AssignmentExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;operator&quot;</span><span class="s0">,</span><span class="s1">&quot;AssignmentPattern&quot;</span><span class="s0">,</span><span class="s1">&quot;ObjectExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isObjectProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;isDecoratedAnonymousClassExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isClassExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;_default&quot;</span><span class="s0">,</span><span class="s1">&quot;assertVersion&quot;</span><span class="s0">,</span><span class="s1">&quot;assumption&quot;</span><span class="s0">,</span><span class="s1">&quot;loose&quot;</span><span class="s0">,</span><span class="s1">&quot;inherits&quot;</span><span class="s0">,</span><span class="s1">&quot;_assumption&quot;</span><span class="s0">,</span><span class="s1">&quot;_assumption2&quot;</span><span class="s0">,</span><span class="s1">&quot;VISITED&quot;</span><span class="s0">,</span><span class="s1">&quot;WeakSet&quot;</span><span class="s0">,</span><span class="s1">&quot;namedEvaluationVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;visitClass&quot;</span><span class="s0">,</span><span class="s1">&quot;_node$id&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;assign&quot;</span><span class="s0">,</span><span class="s1">&quot;ExportDefaultDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;declaration&quot;</span><span class="s0">,</span><span class="s1">&quot;_path$splitExportDecl&quot;</span><span class="s0">,</span><span class="s1">&quot;splitExportDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;NodePath&quot;</span><span class="s0">,</span><span class="s1">&quot;prototype&quot;</span><span class="s0">,</span><span class="s1">&quot;updatedVarDeclarationPath&quot;</span><span class="s0">,</span><span class="s1">&quot;ExportNamedDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;_path$splitExportDecl2&quot;</span><span class="s0">,</span><span class="s1">&quot;Class&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../src/decorators.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { NodePath, Scope, Visitor } from </span><span class="s3">\&quot;</span><span class="s1">@babel/core</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { types as t, template } from </span><span class="s3">\&quot;</span><span class="s1">@babel/core</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import ReplaceSupers from </span><span class="s3">\&quot;</span><span class="s1">@babel/helper-replace-supers</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { PluginAPI, PluginObject, PluginPass } from </span><span class="s3">\&quot;</span><span class="s1">@babel/core</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { skipTransparentExprWrappers } from </span><span class="s3">\&quot;</span><span class="s1">@babel/helper-skip-transparent-expression-wrappers</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">privateNameVisitorFactory,</span><span class="s3">\n  </span><span class="s1">type PrivateNameVisitorState,</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">./fields.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { memoiseComputedKey } from </span><span class="s3">\&quot;</span><span class="s1">./misc.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">export function hasOwnDecorators(node: t.Class | t.ClassBody[</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">][number]) {</span><span class="s3">\n  </span><span class="s1">// @ts-expect-error: 'decorators' not in TSIndexSignature</span><span class="s3">\n  </span><span class="s1">return !!node.decorators?.length;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function hasDecorators(node: t.Class) {</span><span class="s3">\n  </span><span class="s1">return hasOwnDecorators(node) || node.body.body.some(hasOwnDecorators);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// We inline this package</span><span class="s3">\n</span><span class="s1">// eslint-disable-next-line import/no-extraneous-dependencies</span><span class="s3">\n</span><span class="s1">import * as charCodes from </span><span class="s3">\&quot;</span><span class="s1">charcodes</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">interface Options {</span><span class="s3">\n  </span><span class="s1">/** @deprecated use `constantSuper` assumption instead. Only supported in 2021-12 version. */</span><span class="s3">\n  </span><span class="s1">loose?: boolean;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type ClassDecoratableElement =</span><span class="s3">\n  </span><span class="s1">| t.ClassMethod</span><span class="s3">\n  </span><span class="s1">| t.ClassPrivateMethod</span><span class="s3">\n  </span><span class="s1">| t.ClassProperty</span><span class="s3">\n  </span><span class="s1">| t.ClassPrivateProperty</span><span class="s3">\n  </span><span class="s1">| t.ClassAccessorProperty;</span><span class="s3">\n\n</span><span class="s1">type ClassElement =</span><span class="s3">\n  </span><span class="s1">| ClassDecoratableElement</span><span class="s3">\n  </span><span class="s1">| t.TSDeclareMethod</span><span class="s3">\n  </span><span class="s1">| t.TSIndexSignature</span><span class="s3">\n  </span><span class="s1">| t.StaticBlock;</span><span class="s3">\n\n</span><span class="s1">type ClassElementCanHaveComputedKeys =</span><span class="s3">\n  </span><span class="s1">| t.ClassMethod</span><span class="s3">\n  </span><span class="s1">| t.ClassProperty</span><span class="s3">\n  </span><span class="s1">| t.ClassAccessorProperty;</span><span class="s3">\n\n</span><span class="s1">// TODO(Babel 8): Only keep 2023-11</span><span class="s3">\n</span><span class="s1">export type DecoratorVersionKind =</span><span class="s3">\n  </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">2023-11</span><span class="s3">\&quot;\n  </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">2023-05</span><span class="s3">\&quot;\n  </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">2023-01</span><span class="s3">\&quot;\n  </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">2022-03</span><span class="s3">\&quot;\n  </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">2021-12</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">function incrementId(id: number[], idx = id.length - 1): void {</span><span class="s3">\n  </span><span class="s1">// If index is -1, id needs an additional character, unshift A</span><span class="s3">\n  </span><span class="s1">if (idx === -1) {</span><span class="s3">\n    </span><span class="s1">id.unshift(charCodes.uppercaseA);</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const current = id[idx];</span><span class="s3">\n\n  </span><span class="s1">if (current === charCodes.uppercaseZ) {</span><span class="s3">\n    </span><span class="s1">// if current is Z, skip to a</span><span class="s3">\n    </span><span class="s1">id[idx] = charCodes.lowercaseA;</span><span class="s3">\n  </span><span class="s1">} else if (current === charCodes.lowercaseZ) {</span><span class="s3">\n    </span><span class="s1">// if current is z, reset to A and carry the 1</span><span class="s3">\n    </span><span class="s1">id[idx] = charCodes.uppercaseA;</span><span class="s3">\n    </span><span class="s1">incrementId(id, idx - 1);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">// else, increment by one</span><span class="s3">\n    </span><span class="s1">id[idx] = current + 1;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Generates a new private name that is unique to the given class. This can be</span><span class="s3">\n </span><span class="s1">* used to create extra class fields and methods for the implementation, while</span><span class="s3">\n </span><span class="s1">* keeping the length of those names as small as possible. This is important for</span><span class="s3">\n </span><span class="s1">* minification purposes (though private names can generally be minified,</span><span class="s3">\n </span><span class="s1">* transpilations and polyfills cannot yet).</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function createPrivateUidGeneratorForClass(</span><span class="s3">\n  </span><span class="s1">classPath: NodePath&lt;t.ClassDeclaration | t.ClassExpression&gt;,</span><span class="s3">\n</span><span class="s1">): () =&gt; t.PrivateName {</span><span class="s3">\n  </span><span class="s1">const currentPrivateId: number[] = [];</span><span class="s3">\n  </span><span class="s1">const privateNames = new Set&lt;string&gt;();</span><span class="s3">\n\n  </span><span class="s1">classPath.traverse({</span><span class="s3">\n    </span><span class="s1">PrivateName(path) {</span><span class="s3">\n      </span><span class="s1">privateNames.add(path.node.id.name);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">return (): t.PrivateName =&gt; {</span><span class="s3">\n    </span><span class="s1">let reifiedId;</span><span class="s3">\n    </span><span class="s1">do {</span><span class="s3">\n      </span><span class="s1">incrementId(currentPrivateId);</span><span class="s3">\n      </span><span class="s1">reifiedId = String.fromCharCode(...currentPrivateId);</span><span class="s3">\n    </span><span class="s1">} while (privateNames.has(reifiedId));</span><span class="s3">\n\n    </span><span class="s1">return t.privateName(t.identifier(reifiedId));</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Wraps the above generator function so that it's run lazily the first time</span><span class="s3">\n </span><span class="s1">* it's actually required. Several types of decoration do not require this, so it</span><span class="s3">\n </span><span class="s1">* saves iterating the class elements an additional time and allocating the space</span><span class="s3">\n </span><span class="s1">* for the Sets of element names.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function createLazyPrivateUidGeneratorForClass(</span><span class="s3">\n  </span><span class="s1">classPath: NodePath&lt;t.ClassDeclaration | t.ClassExpression&gt;,</span><span class="s3">\n</span><span class="s1">): () =&gt; t.PrivateName {</span><span class="s3">\n  </span><span class="s1">let generator: () =&gt; t.PrivateName;</span><span class="s3">\n\n  </span><span class="s1">return (): t.PrivateName =&gt; {</span><span class="s3">\n    </span><span class="s1">if (!generator) {</span><span class="s3">\n      </span><span class="s1">generator = createPrivateUidGeneratorForClass(classPath);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return generator();</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Takes a class definition and the desired class name if anonymous and</span><span class="s3">\n </span><span class="s1">* replaces it with an equivalent class declaration (path) which is then</span><span class="s3">\n </span><span class="s1">* assigned to a local variable (id). This allows us to reassign the local variable with the</span><span class="s3">\n </span><span class="s1">* decorated version of the class. The class definition retains its original</span><span class="s3">\n </span><span class="s1">* name so that `toString` is not affected, other references to the class</span><span class="s3">\n </span><span class="s1">* are renamed instead.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function replaceClassWithVar(</span><span class="s3">\n  </span><span class="s1">path: NodePath&lt;t.ClassDeclaration | t.ClassExpression&gt;,</span><span class="s3">\n  </span><span class="s1">className: string | t.Identifier | t.StringLiteral | undefined,</span><span class="s3">\n</span><span class="s1">): {</span><span class="s3">\n  </span><span class="s1">id: t.Identifier;</span><span class="s3">\n  </span><span class="s1">path: NodePath&lt;t.ClassDeclaration | t.ClassExpression&gt;;</span><span class="s3">\n</span><span class="s1">} {</span><span class="s3">\n  </span><span class="s1">const id = path.node.id;</span><span class="s3">\n  </span><span class="s1">const scope = path.scope;</span><span class="s3">\n  </span><span class="s1">if (path.type === </span><span class="s3">\&quot;</span><span class="s1">ClassDeclaration</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">const className = id.name;</span><span class="s3">\n    </span><span class="s1">const varId = scope.generateUidIdentifierBasedOnNode(id);</span><span class="s3">\n    </span><span class="s1">const classId = t.identifier(className);</span><span class="s3">\n\n    </span><span class="s1">scope.rename(className, varId.name);</span><span class="s3">\n\n    </span><span class="s1">path.get(</span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">).replaceWith(classId);</span><span class="s3">\n\n    </span><span class="s1">return { id: t.cloneNode(varId), path };</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">let varId: t.Identifier;</span><span class="s3">\n\n    </span><span class="s1">if (id) {</span><span class="s3">\n      </span><span class="s1">className = id.name;</span><span class="s3">\n      </span><span class="s1">varId = generateLetUidIdentifier(scope.parent, className);</span><span class="s3">\n      </span><span class="s1">scope.rename(className, varId.name);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">varId = generateLetUidIdentifier(</span><span class="s3">\n        </span><span class="s1">scope.parent,</span><span class="s3">\n        </span><span class="s1">typeof className === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">? className : </span><span class="s3">\&quot;</span><span class="s1">decorated_class</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const newClassExpr = t.classExpression(</span><span class="s3">\n      </span><span class="s1">typeof className === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">? t.identifier(className) : null,</span><span class="s3">\n      </span><span class="s1">path.node.superClass,</span><span class="s3">\n      </span><span class="s1">path.node.body,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n\n    </span><span class="s1">const [newPath] = path.replaceWith(</span><span class="s3">\n      </span><span class="s1">t.sequenceExpression([newClassExpr, varId]),</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">id: t.cloneNode(varId),</span><span class="s3">\n      </span><span class="s1">path: newPath.get(</span><span class="s3">\&quot;</span><span class="s1">expressions.0</span><span class="s3">\&quot;</span><span class="s1">) as NodePath&lt;t.ClassExpression&gt;,</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function generateClassProperty(</span><span class="s3">\n  </span><span class="s1">key: t.PrivateName | t.Identifier,</span><span class="s3">\n  </span><span class="s1">value: t.Expression | undefined,</span><span class="s3">\n  </span><span class="s1">isStatic: boolean,</span><span class="s3">\n</span><span class="s1">): t.ClassPrivateProperty | t.ClassProperty {</span><span class="s3">\n  </span><span class="s1">if (key.type === </span><span class="s3">\&quot;</span><span class="s1">PrivateName</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return t.classPrivateProperty(key, value, undefined, isStatic);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return t.classProperty(key, value, undefined, undefined, isStatic);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function assignIdForAnonymousClass(</span><span class="s3">\n  </span><span class="s1">path: NodePath&lt;t.Class&gt;,</span><span class="s3">\n  </span><span class="s1">className: string | t.Identifier | t.StringLiteral | undefined,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">if (!path.node.id) {</span><span class="s3">\n    </span><span class="s1">path.node.id =</span><span class="s3">\n      </span><span class="s1">typeof className === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;\n        </span><span class="s1">? t.identifier(className)</span><span class="s3">\n        </span><span class="s1">: path.scope.generateUidIdentifier(</span><span class="s3">\&quot;</span><span class="s1">Class</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function addProxyAccessorsFor(</span><span class="s3">\n  </span><span class="s1">className: t.Identifier,</span><span class="s3">\n  </span><span class="s1">element: NodePath&lt;ClassDecoratableElement&gt;,</span><span class="s3">\n  </span><span class="s1">getterKey: t.PrivateName | t.Expression,</span><span class="s3">\n  </span><span class="s1">setterKey: t.PrivateName | t.Expression,</span><span class="s3">\n  </span><span class="s1">targetKey: t.PrivateName,</span><span class="s3">\n  </span><span class="s1">isComputed: boolean,</span><span class="s3">\n  </span><span class="s1">isStatic: boolean,</span><span class="s3">\n  </span><span class="s1">version: DecoratorVersionKind,</span><span class="s3">\n</span><span class="s1">): void {</span><span class="s3">\n  </span><span class="s1">const thisArg =</span><span class="s3">\n    </span><span class="s1">(version === </span><span class="s3">\&quot;</span><span class="s1">2023-11</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n      </span><span class="s1">(!process.env.BABEL_8_BREAKING &amp;&amp; version === </span><span class="s3">\&quot;</span><span class="s1">2023-05</span><span class="s3">\&quot;</span><span class="s1">)) &amp;&amp;</span><span class="s3">\n    </span><span class="s1">isStatic</span><span class="s3">\n      </span><span class="s1">? className</span><span class="s3">\n      </span><span class="s1">: t.thisExpression();</span><span class="s3">\n\n  </span><span class="s1">const getterBody = t.blockStatement([</span><span class="s3">\n    </span><span class="s1">t.returnStatement(</span><span class="s3">\n      </span><span class="s1">t.memberExpression(t.cloneNode(thisArg), t.cloneNode(targetKey)),</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">]);</span><span class="s3">\n\n  </span><span class="s1">const setterBody = t.blockStatement([</span><span class="s3">\n    </span><span class="s1">t.expressionStatement(</span><span class="s3">\n      </span><span class="s1">t.assignmentExpression(</span><span class="s3">\n        \&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">t.memberExpression(t.cloneNode(thisArg), t.cloneNode(targetKey)),</span><span class="s3">\n        </span><span class="s1">t.identifier(</span><span class="s3">\&quot;</span><span class="s1">v</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">]);</span><span class="s3">\n\n  </span><span class="s1">let getter: t.ClassMethod | t.ClassPrivateMethod,</span><span class="s3">\n    </span><span class="s1">setter: t.ClassMethod | t.ClassPrivateMethod;</span><span class="s3">\n\n  </span><span class="s1">if (getterKey.type === </span><span class="s3">\&quot;</span><span class="s1">PrivateName</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">getter = t.classPrivateMethod(</span><span class="s3">\&quot;</span><span class="s1">get</span><span class="s3">\&quot;</span><span class="s1">, getterKey, [], getterBody, isStatic);</span><span class="s3">\n    </span><span class="s1">setter = t.classPrivateMethod(</span><span class="s3">\n      \&quot;</span><span class="s1">set</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">setterKey as t.PrivateName,</span><span class="s3">\n      </span><span class="s1">[t.identifier(</span><span class="s3">\&quot;</span><span class="s1">v</span><span class="s3">\&quot;</span><span class="s1">)],</span><span class="s3">\n      </span><span class="s1">setterBody,</span><span class="s3">\n      </span><span class="s1">isStatic,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">getter = t.classMethod(</span><span class="s3">\n      \&quot;</span><span class="s1">get</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">getterKey,</span><span class="s3">\n      </span><span class="s1">[],</span><span class="s3">\n      </span><span class="s1">getterBody,</span><span class="s3">\n      </span><span class="s1">isComputed,</span><span class="s3">\n      </span><span class="s1">isStatic,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">setter = t.classMethod(</span><span class="s3">\n      \&quot;</span><span class="s1">set</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">setterKey as t.Expression,</span><span class="s3">\n      </span><span class="s1">[t.identifier(</span><span class="s3">\&quot;</span><span class="s1">v</span><span class="s3">\&quot;</span><span class="s1">)],</span><span class="s3">\n      </span><span class="s1">setterBody,</span><span class="s3">\n      </span><span class="s1">isComputed,</span><span class="s3">\n      </span><span class="s1">isStatic,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">element.insertAfter(setter);</span><span class="s3">\n  </span><span class="s1">element.insertAfter(getter);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function extractProxyAccessorsFor(</span><span class="s3">\n  </span><span class="s1">targetKey: t.PrivateName,</span><span class="s3">\n  </span><span class="s1">version: DecoratorVersionKind,</span><span class="s3">\n</span><span class="s1">): (t.FunctionExpression | t.ArrowFunctionExpression)[] {</span><span class="s3">\n  </span><span class="s1">if (version !== </span><span class="s3">\&quot;</span><span class="s1">2023-11</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; version !== </span><span class="s3">\&quot;</span><span class="s1">2023-05</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; version !== </span><span class="s3">\&quot;</span><span class="s1">2023-01</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return [</span><span class="s3">\n      </span><span class="s1">template.expression.ast`</span><span class="s3">\n        </span><span class="s1">function () {</span><span class="s3">\n          </span><span class="s1">return this.${t.cloneNode(targetKey)};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">` as t.FunctionExpression,</span><span class="s3">\n      </span><span class="s1">template.expression.ast`</span><span class="s3">\n        </span><span class="s1">function (value) {</span><span class="s3">\n          </span><span class="s1">this.${t.cloneNode(targetKey)} = value;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">` as t.FunctionExpression,</span><span class="s3">\n    </span><span class="s1">];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return [</span><span class="s3">\n    </span><span class="s1">template.expression.ast`</span><span class="s3">\n      </span><span class="s1">o =&gt; o.${t.cloneNode(targetKey)}</span><span class="s3">\n    </span><span class="s1">` as t.ArrowFunctionExpression,</span><span class="s3">\n    </span><span class="s1">template.expression.ast`</span><span class="s3">\n      </span><span class="s1">(o, v) =&gt; o.${t.cloneNode(targetKey)} = v</span><span class="s3">\n    </span><span class="s1">` as t.ArrowFunctionExpression,</span><span class="s3">\n  </span><span class="s1">];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Get the last element for the given computed key path.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This function unwraps transparent wrappers and gets the last item when</span><span class="s3">\n </span><span class="s1">* the key is a SequenceExpression.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {NodePath&lt;t.Expression&gt;} path The key of a computed class element</span><span class="s3">\n </span><span class="s1">* @returns {NodePath&lt;t.Expression&gt;} The simple completion result</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function getComputedKeyLastElement(</span><span class="s3">\n  </span><span class="s1">path: NodePath&lt;t.Expression&gt;,</span><span class="s3">\n</span><span class="s1">): NodePath&lt;t.Expression&gt; {</span><span class="s3">\n  </span><span class="s1">path = skipTransparentExprWrappers(path);</span><span class="s3">\n  </span><span class="s1">if (path.isSequenceExpression()) {</span><span class="s3">\n    </span><span class="s1">const expressions = path.get(</span><span class="s3">\&quot;</span><span class="s1">expressions</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">return getComputedKeyLastElement(expressions[expressions.length - 1]);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return path;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Get a memoiser of the computed key path.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This function does not mutate AST. If the computed key is not a constant</span><span class="s3">\n </span><span class="s1">* expression, this function must be called after the key has been memoised.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {NodePath&lt;t.Expression&gt;} path The key of a computed class element.</span><span class="s3">\n </span><span class="s1">* @returns {t.Expression} A clone of key if key is a constant expression,</span><span class="s3">\n </span><span class="s1">* otherwise a memoiser identifier.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function getComputedKeyMemoiser(path: NodePath&lt;t.Expression&gt;): t.Expression {</span><span class="s3">\n  </span><span class="s1">const element = getComputedKeyLastElement(path);</span><span class="s3">\n  </span><span class="s1">if (element.isConstantExpression()) {</span><span class="s3">\n    </span><span class="s1">return t.cloneNode(path.node);</span><span class="s3">\n  </span><span class="s1">} else if (element.isIdentifier() &amp;&amp; path.scope.hasUid(element.node.name)) {</span><span class="s3">\n    </span><span class="s1">return t.cloneNode(path.node);</span><span class="s3">\n  </span><span class="s1">} else if (</span><span class="s3">\n    </span><span class="s1">element.isAssignmentExpression() &amp;&amp;</span><span class="s3">\n    </span><span class="s1">element.get(</span><span class="s3">\&quot;</span><span class="s1">left</span><span class="s3">\&quot;</span><span class="s1">).isIdentifier()</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return t.cloneNode(element.node.left as t.Identifier);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">`Internal Error: the computed key ${path.toString()} has not yet been memoised.`,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Prepend expressions to the computed key of the given field path.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* If the computed key is a sequence expression, this function will unwrap</span><span class="s3">\n </span><span class="s1">* the sequence expression for optimal output size.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {t.Expression[]} expressions</span><span class="s3">\n </span><span class="s1">* @param {(NodePath&lt;</span><span class="s3">\n </span><span class="s1">*     t.ClassMethod | t.ClassProperty | t.ClassAccessorProperty</span><span class="s3">\n </span><span class="s1">*   &gt;)} fieldPath</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function prependExpressionsToComputedKey(</span><span class="s3">\n  </span><span class="s1">expressions: t.Expression[],</span><span class="s3">\n  </span><span class="s1">fieldPath: NodePath&lt;</span><span class="s3">\n    </span><span class="s1">t.ClassMethod | t.ClassProperty | t.ClassAccessorProperty</span><span class="s3">\n  </span><span class="s1">&gt;,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const key = fieldPath.get(</span><span class="s3">\&quot;</span><span class="s1">key</span><span class="s3">\&quot;</span><span class="s1">) as NodePath&lt;t.Expression&gt;;</span><span class="s3">\n  </span><span class="s1">if (key.isSequenceExpression()) {</span><span class="s3">\n    </span><span class="s1">expressions.push(...key.node.expressions);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">expressions.push(key.node);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">key.replaceWith(maybeSequenceExpression(expressions));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Append expressions to the computed key of the given field path.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* If the computed key is a constant expression or uid reference, it</span><span class="s3">\n </span><span class="s1">* will prepend expressions before the comptued key. Otherwise it will</span><span class="s3">\n </span><span class="s1">* memoise the computed key to preserve its completion result.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {t.Expression[]} expressions</span><span class="s3">\n </span><span class="s1">* @param {(NodePath&lt;</span><span class="s3">\n </span><span class="s1">*     t.ClassMethod | t.ClassProperty | t.ClassAccessorProperty</span><span class="s3">\n </span><span class="s1">*   &gt;)} fieldPath</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function appendExpressionsToComputedKey(</span><span class="s3">\n  </span><span class="s1">expressions: t.Expression[],</span><span class="s3">\n  </span><span class="s1">fieldPath: NodePath&lt;</span><span class="s3">\n    </span><span class="s1">t.ClassMethod | t.ClassProperty | t.ClassAccessorProperty</span><span class="s3">\n  </span><span class="s1">&gt;,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const key = fieldPath.get(</span><span class="s3">\&quot;</span><span class="s1">key</span><span class="s3">\&quot;</span><span class="s1">) as NodePath&lt;t.Expression&gt;;</span><span class="s3">\n  </span><span class="s1">const completion = getComputedKeyLastElement(key);</span><span class="s3">\n  </span><span class="s1">if (completion.isConstantExpression()) {</span><span class="s3">\n    </span><span class="s1">prependExpressionsToComputedKey(expressions, fieldPath);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">const scopeParent = key.scope.parent;</span><span class="s3">\n    </span><span class="s1">const maybeAssignment = memoiseComputedKey(</span><span class="s3">\n      </span><span class="s1">completion.node,</span><span class="s3">\n      </span><span class="s1">scopeParent,</span><span class="s3">\n      </span><span class="s1">scopeParent.generateUid(</span><span class="s3">\&quot;</span><span class="s1">computedKey</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">if (!maybeAssignment) {</span><span class="s3">\n      </span><span class="s1">// If the memoiseComputedKey returns undefined, the key is already a uid reference,</span><span class="s3">\n      </span><span class="s1">// treat it as a constant expression and prepend expressions before it</span><span class="s3">\n      </span><span class="s1">prependExpressionsToComputedKey(expressions, fieldPath);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">const expressionSequence = [</span><span class="s3">\n        </span><span class="s1">...expressions,</span><span class="s3">\n        </span><span class="s1">// preserve the completion result</span><span class="s3">\n        </span><span class="s1">t.cloneNode(maybeAssignment.left),</span><span class="s3">\n      </span><span class="s1">];</span><span class="s3">\n      </span><span class="s1">const completionParent = completion.parentPath;</span><span class="s3">\n      </span><span class="s1">if (completionParent.isSequenceExpression()) {</span><span class="s3">\n        </span><span class="s1">completionParent.pushContainer(</span><span class="s3">\&quot;</span><span class="s1">expressions</span><span class="s3">\&quot;</span><span class="s1">, expressionSequence);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">completion.replaceWith(</span><span class="s3">\n          </span><span class="s1">maybeSequenceExpression([</span><span class="s3">\n            </span><span class="s1">t.cloneNode(maybeAssignment),</span><span class="s3">\n            </span><span class="s1">...expressionSequence,</span><span class="s3">\n          </span><span class="s1">]),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Prepend expressions to the field initializer. If the initializer is not defined,</span><span class="s3">\n </span><span class="s1">* this function will wrap the last expression within a `void` unary expression.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {t.Expression[]} expressions</span><span class="s3">\n </span><span class="s1">* @param {(NodePath&lt;</span><span class="s3">\n </span><span class="s1">*     t.ClassProperty | t.ClassPrivateProperty | t.ClassAccessorProperty</span><span class="s3">\n </span><span class="s1">*   &gt;)} fieldPath</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function prependExpressionsToFieldInitializer(</span><span class="s3">\n  </span><span class="s1">expressions: t.Expression[],</span><span class="s3">\n  </span><span class="s1">fieldPath: NodePath&lt;</span><span class="s3">\n    </span><span class="s1">t.ClassProperty | t.ClassPrivateProperty | t.ClassAccessorProperty</span><span class="s3">\n  </span><span class="s1">&gt;,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const initializer = fieldPath.get(</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">if (initializer.node) {</span><span class="s3">\n    </span><span class="s1">expressions.push(initializer.node);</span><span class="s3">\n  </span><span class="s1">} else if (expressions.length &gt; 0) {</span><span class="s3">\n    </span><span class="s1">expressions[expressions.length - 1] = t.unaryExpression(</span><span class="s3">\n      \&quot;</span><span class="s1">void</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">expressions[expressions.length - 1],</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">initializer.replaceWith(maybeSequenceExpression(expressions));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function prependExpressionsToStaticBlock(</span><span class="s3">\n  </span><span class="s1">expressions: t.Expression[],</span><span class="s3">\n  </span><span class="s1">blockPath: NodePath&lt;t.StaticBlock&gt;,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">blockPath.unshiftContainer(</span><span class="s3">\n    \&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">t.expressionStatement(maybeSequenceExpression(expressions)),</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function prependExpressionsToConstructor(</span><span class="s3">\n  </span><span class="s1">expressions: t.Expression[],</span><span class="s3">\n  </span><span class="s1">constructorPath: NodePath&lt;t.ClassMethod&gt;,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">constructorPath.node.body.body.unshift(</span><span class="s3">\n    </span><span class="s1">t.expressionStatement(maybeSequenceExpression(expressions)),</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function isProtoInitCallExpression(</span><span class="s3">\n  </span><span class="s1">expression: t.Expression,</span><span class="s3">\n  </span><span class="s1">protoInitCall: t.Identifier,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">t.isCallExpression(expression) &amp;&amp;</span><span class="s3">\n    </span><span class="s1">t.isIdentifier(expression.callee, { name: protoInitCall.name })</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Optimize super call and its following expressions</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {t.Expression[]} expressions Mutated by this function. The first element must by a super call</span><span class="s3">\n </span><span class="s1">* @param {t.Identifier} protoInitLocal The generated protoInit id</span><span class="s3">\n </span><span class="s1">* @returns optimized expression</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function optimizeSuperCallAndExpressions(</span><span class="s3">\n  </span><span class="s1">expressions: t.Expression[],</span><span class="s3">\n  </span><span class="s1">protoInitLocal: t.Identifier,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">if (protoInitLocal) {</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">expressions.length &gt;= 2 &amp;&amp;</span><span class="s3">\n      </span><span class="s1">isProtoInitCallExpression(expressions[1], protoInitLocal)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">// Merge `super(), protoInit(this)` into `protoInit(super())`</span><span class="s3">\n      </span><span class="s1">const mergedSuperCall = t.callExpression(t.cloneNode(protoInitLocal), [</span><span class="s3">\n        </span><span class="s1">expressions[0],</span><span class="s3">\n      </span><span class="s1">]);</span><span class="s3">\n      </span><span class="s1">expressions.splice(0, 2, mergedSuperCall);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Merge `protoInit(super()), this` into `protoInit(super())`</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">expressions.length &gt;= 2 &amp;&amp;</span><span class="s3">\n      </span><span class="s1">t.isThisExpression(expressions[expressions.length - 1]) &amp;&amp;</span><span class="s3">\n      </span><span class="s1">isProtoInitCallExpression(</span><span class="s3">\n        </span><span class="s1">expressions[expressions.length - 2],</span><span class="s3">\n        </span><span class="s1">protoInitLocal,</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">expressions.splice(expressions.length - 1, 1);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return maybeSequenceExpression(expressions);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Insert expressions immediately after super() and optimize the output if possible.</span><span class="s3">\n </span><span class="s1">* This function will preserve the completion result using the trailing this expression.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {t.Expression[]} expressions</span><span class="s3">\n </span><span class="s1">* @param {NodePath&lt;t.ClassMethod&gt;} constructorPath</span><span class="s3">\n </span><span class="s1">* @param {t.Identifier} protoInitLocal The generated protoInit id</span><span class="s3">\n </span><span class="s1">* @returns</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function insertExpressionsAfterSuperCallAndOptimize(</span><span class="s3">\n  </span><span class="s1">expressions: t.Expression[],</span><span class="s3">\n  </span><span class="s1">constructorPath: NodePath&lt;t.ClassMethod&gt;,</span><span class="s3">\n  </span><span class="s1">protoInitLocal: t.Identifier,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">constructorPath.traverse({</span><span class="s3">\n    </span><span class="s1">CallExpression: {</span><span class="s3">\n      </span><span class="s1">exit(path) {</span><span class="s3">\n        </span><span class="s1">if (!path.get(</span><span class="s3">\&quot;</span><span class="s1">callee</span><span class="s3">\&quot;</span><span class="s1">).isSuper()) return;</span><span class="s3">\n        </span><span class="s1">const newNodes = [</span><span class="s3">\n          </span><span class="s1">path.node,</span><span class="s3">\n          </span><span class="s1">...expressions.map(expr =&gt; t.cloneNode(expr)),</span><span class="s3">\n        </span><span class="s1">];</span><span class="s3">\n        </span><span class="s1">// preserve completion result if super() is in an RHS or a return statement</span><span class="s3">\n        </span><span class="s1">if (path.isCompletionRecord()) {</span><span class="s3">\n          </span><span class="s1">newNodes.push(t.thisExpression());</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">path.replaceWith(</span><span class="s3">\n          </span><span class="s1">optimizeSuperCallAndExpressions(newNodes, protoInitLocal),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n\n        </span><span class="s1">path.skip();</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">ClassMethod(path) {</span><span class="s3">\n      </span><span class="s1">if (path.node.kind === </span><span class="s3">\&quot;</span><span class="s1">constructor</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">path.skip();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Build a class constructor node from the given expressions. If the class is</span><span class="s3">\n </span><span class="s1">* derived, the constructor will call super() first to ensure that `this`</span><span class="s3">\n </span><span class="s1">* in the expressions work as expected.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {t.Expression[]} expressions</span><span class="s3">\n </span><span class="s1">* @param {boolean} isDerivedClass</span><span class="s3">\n </span><span class="s1">* @returns The class constructor node</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function createConstructorFromExpressions(</span><span class="s3">\n  </span><span class="s1">expressions: t.Expression[],</span><span class="s3">\n  </span><span class="s1">isDerivedClass: boolean,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const body: t.Statement[] = [</span><span class="s3">\n    </span><span class="s1">t.expressionStatement(maybeSequenceExpression(expressions)),</span><span class="s3">\n  </span><span class="s1">];</span><span class="s3">\n  </span><span class="s1">if (isDerivedClass) {</span><span class="s3">\n    </span><span class="s1">body.unshift(</span><span class="s3">\n      </span><span class="s1">t.expressionStatement(</span><span class="s3">\n        </span><span class="s1">t.callExpression(t.super(), [t.spreadElement(t.identifier(</span><span class="s3">\&quot;</span><span class="s1">args</span><span class="s3">\&quot;</span><span class="s1">))]),</span><span class="s3">\n      </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return t.classMethod(</span><span class="s3">\n    \&quot;</span><span class="s1">constructor</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">t.identifier(</span><span class="s3">\&quot;</span><span class="s1">constructor</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">isDerivedClass ? [t.restElement(t.identifier(</span><span class="s3">\&quot;</span><span class="s1">args</span><span class="s3">\&quot;</span><span class="s1">))] : [],</span><span class="s3">\n    </span><span class="s1">t.blockStatement(body),</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createStaticBlockFromExpressions(expressions: t.Expression[]) {</span><span class="s3">\n  </span><span class="s1">return t.staticBlock([</span><span class="s3">\n    </span><span class="s1">t.expressionStatement(maybeSequenceExpression(expressions)),</span><span class="s3">\n  </span><span class="s1">]);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// 3 bits reserved to this (0-7)</span><span class="s3">\n</span><span class="s1">const FIELD = 0;</span><span class="s3">\n</span><span class="s1">const ACCESSOR = 1;</span><span class="s3">\n</span><span class="s1">const METHOD = 2;</span><span class="s3">\n</span><span class="s1">const GETTER = 3;</span><span class="s3">\n</span><span class="s1">const SETTER = 4;</span><span class="s3">\n\n</span><span class="s1">const STATIC_OLD_VERSION = 5; // Before 2023-05</span><span class="s3">\n</span><span class="s1">const STATIC = 8; // 1 &lt;&lt; 3</span><span class="s3">\n</span><span class="s1">const DECORATORS_HAVE_THIS = 16; // 1 &lt;&lt; 4</span><span class="s3">\n\n</span><span class="s1">function getElementKind(element: NodePath&lt;ClassDecoratableElement&gt;): number {</span><span class="s3">\n  </span><span class="s1">switch (element.node.type) {</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ClassProperty</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ClassPrivateProperty</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">return FIELD;</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ClassAccessorProperty</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">return ACCESSOR;</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ClassMethod</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ClassPrivateMethod</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">if (element.node.kind === </span><span class="s3">\&quot;</span><span class="s1">get</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">return GETTER;</span><span class="s3">\n      </span><span class="s1">} else if (element.node.kind === </span><span class="s3">\&quot;</span><span class="s1">set</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">return SETTER;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">return METHOD;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Information about the decorators applied to an element</span><span class="s3">\n</span><span class="s1">interface DecoratorInfo {</span><span class="s3">\n  </span><span class="s1">// An array of applied decorators or a memoised identifier</span><span class="s3">\n  </span><span class="s1">decoratorsArray: t.Identifier | t.ArrayExpression | t.Expression;</span><span class="s3">\n  </span><span class="s1">decoratorsHaveThis: boolean;</span><span class="s3">\n\n  </span><span class="s1">// The kind of the decorated value, matches the kind value passed to applyDecs</span><span class="s3">\n  </span><span class="s1">kind: number;</span><span class="s3">\n\n  </span><span class="s1">// whether or not the field is static</span><span class="s3">\n  </span><span class="s1">isStatic: boolean;</span><span class="s3">\n\n  </span><span class="s1">// The name of the decorator</span><span class="s3">\n  </span><span class="s1">name: t.StringLiteral | t.Expression;</span><span class="s3">\n\n  </span><span class="s1">privateMethods:</span><span class="s3">\n    </span><span class="s1">| (t.FunctionExpression | t.ArrowFunctionExpression)[]</span><span class="s3">\n    </span><span class="s1">| undefined;</span><span class="s3">\n\n  </span><span class="s1">// The names of local variables that will be used/returned from the decoration</span><span class="s3">\n  </span><span class="s1">locals: t.Identifier | t.Identifier[] | undefined;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Sort decoration info in the application order:</span><span class="s3">\n </span><span class="s1">* - static non-fields</span><span class="s3">\n </span><span class="s1">* - instance non-fields</span><span class="s3">\n </span><span class="s1">* - static fields</span><span class="s3">\n </span><span class="s1">* - instance fields</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {DecoratorInfo[]} info</span><span class="s3">\n </span><span class="s1">* @returns {DecoratorInfo[]} Sorted decoration info</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function toSortedDecoratorInfo(info: DecoratorInfo[]): DecoratorInfo[] {</span><span class="s3">\n  </span><span class="s1">return [</span><span class="s3">\n    </span><span class="s1">...info.filter(</span><span class="s3">\n      </span><span class="s1">el =&gt; el.isStatic &amp;&amp; el.kind &gt;= ACCESSOR &amp;&amp; el.kind &lt;= SETTER,</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">...info.filter(</span><span class="s3">\n      </span><span class="s1">el =&gt; !el.isStatic &amp;&amp; el.kind &gt;= ACCESSOR &amp;&amp; el.kind &lt;= SETTER,</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">...info.filter(el =&gt; el.isStatic &amp;&amp; el.kind === FIELD),</span><span class="s3">\n    </span><span class="s1">...info.filter(el =&gt; !el.isStatic &amp;&amp; el.kind === FIELD),</span><span class="s3">\n  </span><span class="s1">];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type GenerateDecorationListResult = {</span><span class="s3">\n  </span><span class="s1">// The zipped decorators array that will be passed to generateDecorationExprs</span><span class="s3">\n  </span><span class="s1">decs: t.Expression[];</span><span class="s3">\n  </span><span class="s1">// Whether there are non-empty decorator this values</span><span class="s3">\n  </span><span class="s1">haveThis: boolean;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Zip decorators and decorator this values into an array</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {t.Decorator[]} decorators</span><span class="s3">\n </span><span class="s1">* @param {((t.Expression | undefined)[])} decoratorsThis decorator this values</span><span class="s3">\n </span><span class="s1">* @param {DecoratorVersionKind} version</span><span class="s3">\n </span><span class="s1">* @returns {GenerateDecorationListResult}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function generateDecorationList(</span><span class="s3">\n  </span><span class="s1">decorators: t.Decorator[],</span><span class="s3">\n  </span><span class="s1">decoratorsThis: (t.Expression | undefined)[],</span><span class="s3">\n  </span><span class="s1">version: DecoratorVersionKind,</span><span class="s3">\n</span><span class="s1">): GenerateDecorationListResult {</span><span class="s3">\n  </span><span class="s1">const decsCount = decorators.length;</span><span class="s3">\n  </span><span class="s1">const haveOneThis = decoratorsThis.some(Boolean);</span><span class="s3">\n  </span><span class="s1">const decs: t.Expression[] = [];</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; decsCount; i++) {</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">(version === </span><span class="s3">\&quot;</span><span class="s1">2023-11</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n        </span><span class="s1">(!process.env.BABEL_8_BREAKING &amp;&amp; version === </span><span class="s3">\&quot;</span><span class="s1">2023-05</span><span class="s3">\&quot;</span><span class="s1">)) &amp;&amp;</span><span class="s3">\n      </span><span class="s1">haveOneThis</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">decs.push(</span><span class="s3">\n        </span><span class="s1">decoratorsThis[i] || t.unaryExpression(</span><span class="s3">\&quot;</span><span class="s1">void</span><span class="s3">\&quot;</span><span class="s1">, t.numericLiteral(0)),</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">decs.push(decorators[i].expression);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return { haveThis: haveOneThis, decs };</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function generateDecorationExprs(</span><span class="s3">\n  </span><span class="s1">decorationInfo: DecoratorInfo[],</span><span class="s3">\n  </span><span class="s1">version: DecoratorVersionKind,</span><span class="s3">\n</span><span class="s1">): t.ArrayExpression {</span><span class="s3">\n  </span><span class="s1">return t.arrayExpression(</span><span class="s3">\n    </span><span class="s1">decorationInfo.map(el =&gt; {</span><span class="s3">\n      </span><span class="s1">let flag = el.kind;</span><span class="s3">\n      </span><span class="s1">if (el.isStatic) {</span><span class="s3">\n        </span><span class="s1">flag +=</span><span class="s3">\n          </span><span class="s1">version === </span><span class="s3">\&quot;</span><span class="s1">2023-11</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n          </span><span class="s1">(!process.env.BABEL_8_BREAKING &amp;&amp; version === </span><span class="s3">\&quot;</span><span class="s1">2023-05</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">? STATIC</span><span class="s3">\n            </span><span class="s1">: STATIC_OLD_VERSION;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (el.decoratorsHaveThis) flag += DECORATORS_HAVE_THIS;</span><span class="s3">\n\n      </span><span class="s1">return t.arrayExpression([</span><span class="s3">\n        </span><span class="s1">el.decoratorsArray,</span><span class="s3">\n        </span><span class="s1">t.numericLiteral(flag),</span><span class="s3">\n        </span><span class="s1">el.name,</span><span class="s3">\n        </span><span class="s1">...(el.privateMethods || []),</span><span class="s3">\n      </span><span class="s1">]);</span><span class="s3">\n    </span><span class="s1">}),</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function extractElementLocalAssignments(decorationInfo: DecoratorInfo[]) {</span><span class="s3">\n  </span><span class="s1">const localIds: t.Identifier[] = [];</span><span class="s3">\n\n  </span><span class="s1">for (const el of decorationInfo) {</span><span class="s3">\n    </span><span class="s1">const { locals } = el;</span><span class="s3">\n\n    </span><span class="s1">if (Array.isArray(locals)) {</span><span class="s3">\n      </span><span class="s1">localIds.push(...locals);</span><span class="s3">\n    </span><span class="s1">} else if (locals !== undefined) {</span><span class="s3">\n      </span><span class="s1">localIds.push(locals);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return localIds;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function addCallAccessorsFor(</span><span class="s3">\n  </span><span class="s1">version: DecoratorVersionKind,</span><span class="s3">\n  </span><span class="s1">element: NodePath,</span><span class="s3">\n  </span><span class="s1">key: t.PrivateName,</span><span class="s3">\n  </span><span class="s1">getId: t.Identifier,</span><span class="s3">\n  </span><span class="s1">setId: t.Identifier,</span><span class="s3">\n  </span><span class="s1">isStatic: boolean,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">element.insertAfter(</span><span class="s3">\n    </span><span class="s1">t.classPrivateMethod(</span><span class="s3">\n      \&quot;</span><span class="s1">get</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">t.cloneNode(key),</span><span class="s3">\n      </span><span class="s1">[],</span><span class="s3">\n      </span><span class="s1">t.blockStatement([</span><span class="s3">\n        </span><span class="s1">t.returnStatement(</span><span class="s3">\n          </span><span class="s1">t.callExpression(</span><span class="s3">\n            </span><span class="s1">t.cloneNode(getId),</span><span class="s3">\n            </span><span class="s1">(process.env.BABEL_8_BREAKING || version === </span><span class="s3">\&quot;</span><span class="s1">2023-11</span><span class="s3">\&quot;</span><span class="s1">) &amp;&amp; isStatic</span><span class="s3">\n              </span><span class="s1">? []</span><span class="s3">\n              </span><span class="s1">: [t.thisExpression()],</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">]),</span><span class="s3">\n      </span><span class="s1">isStatic,</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n\n  </span><span class="s1">element.insertAfter(</span><span class="s3">\n    </span><span class="s1">t.classPrivateMethod(</span><span class="s3">\n      \&quot;</span><span class="s1">set</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">t.cloneNode(key),</span><span class="s3">\n      </span><span class="s1">[t.identifier(</span><span class="s3">\&quot;</span><span class="s1">v</span><span class="s3">\&quot;</span><span class="s1">)],</span><span class="s3">\n      </span><span class="s1">t.blockStatement([</span><span class="s3">\n        </span><span class="s1">t.expressionStatement(</span><span class="s3">\n          </span><span class="s1">t.callExpression(</span><span class="s3">\n            </span><span class="s1">t.cloneNode(setId),</span><span class="s3">\n            </span><span class="s1">(process.env.BABEL_8_BREAKING || version === </span><span class="s3">\&quot;</span><span class="s1">2023-11</span><span class="s3">\&quot;</span><span class="s1">) &amp;&amp; isStatic</span><span class="s3">\n              </span><span class="s1">? [t.identifier(</span><span class="s3">\&quot;</span><span class="s1">v</span><span class="s3">\&quot;</span><span class="s1">)]</span><span class="s3">\n              </span><span class="s1">: [t.thisExpression(), t.identifier(</span><span class="s3">\&quot;</span><span class="s1">v</span><span class="s3">\&quot;</span><span class="s1">)],</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">]),</span><span class="s3">\n      </span><span class="s1">isStatic,</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function movePrivateAccessor(</span><span class="s3">\n  </span><span class="s1">element: NodePath&lt;t.ClassPrivateMethod&gt;,</span><span class="s3">\n  </span><span class="s1">key: t.PrivateName,</span><span class="s3">\n  </span><span class="s1">methodLocalVar: t.Identifier,</span><span class="s3">\n  </span><span class="s1">isStatic: boolean,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">let params: (t.Identifier | t.RestElement)[];</span><span class="s3">\n  </span><span class="s1">let block: t.Statement[];</span><span class="s3">\n\n  </span><span class="s1">if (element.node.kind === </span><span class="s3">\&quot;</span><span class="s1">set</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">params = [t.identifier(</span><span class="s3">\&quot;</span><span class="s1">v</span><span class="s3">\&quot;</span><span class="s1">)];</span><span class="s3">\n    </span><span class="s1">block = [</span><span class="s3">\n      </span><span class="s1">t.expressionStatement(</span><span class="s3">\n        </span><span class="s1">t.callExpression(methodLocalVar, [</span><span class="s3">\n          </span><span class="s1">t.thisExpression(),</span><span class="s3">\n          </span><span class="s1">t.identifier(</span><span class="s3">\&quot;</span><span class="s1">v</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">]),</span><span class="s3">\n      </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">];</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">params = [];</span><span class="s3">\n    </span><span class="s1">block = [</span><span class="s3">\n      </span><span class="s1">t.returnStatement(t.callExpression(methodLocalVar, [t.thisExpression()])),</span><span class="s3">\n    </span><span class="s1">];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">element.replaceWith(</span><span class="s3">\n    </span><span class="s1">t.classPrivateMethod(</span><span class="s3">\n      </span><span class="s1">element.node.kind,</span><span class="s3">\n      </span><span class="s1">t.cloneNode(key),</span><span class="s3">\n      </span><span class="s1">params,</span><span class="s3">\n      </span><span class="s1">t.blockStatement(block),</span><span class="s3">\n      </span><span class="s1">isStatic,</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function isClassDecoratableElementPath(</span><span class="s3">\n  </span><span class="s1">path: NodePath&lt;ClassElement&gt;,</span><span class="s3">\n</span><span class="s1">): path is NodePath&lt;ClassDecoratableElement&gt; {</span><span class="s3">\n  </span><span class="s1">const { type } = path;</span><span class="s3">\n\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">type !== </span><span class="s3">\&quot;</span><span class="s1">TSDeclareMethod</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n    </span><span class="s1">type !== </span><span class="s3">\&quot;</span><span class="s1">TSIndexSignature</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n    </span><span class="s1">type !== </span><span class="s3">\&quot;</span><span class="s1">StaticBlock</span><span class="s3">\&quot;\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function staticBlockToIIFE(block: t.StaticBlock) {</span><span class="s3">\n  </span><span class="s1">return t.callExpression(</span><span class="s3">\n    </span><span class="s1">t.arrowFunctionExpression([], t.blockStatement(block.body)),</span><span class="s3">\n    </span><span class="s1">[],</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function staticBlockToFunctionClosure(block: t.StaticBlock) {</span><span class="s3">\n  </span><span class="s1">return t.functionExpression(null, [], t.blockStatement(block.body));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function fieldInitializerToClosure(value: t.Expression) {</span><span class="s3">\n  </span><span class="s1">return t.functionExpression(</span><span class="s3">\n    </span><span class="s1">null,</span><span class="s3">\n    </span><span class="s1">[],</span><span class="s3">\n    </span><span class="s1">t.blockStatement([t.returnStatement(value)]),</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function maybeSequenceExpression(exprs: t.Expression[]) {</span><span class="s3">\n  </span><span class="s1">if (exprs.length === 0) return t.unaryExpression(</span><span class="s3">\&quot;</span><span class="s1">void</span><span class="s3">\&quot;</span><span class="s1">, t.numericLiteral(0));</span><span class="s3">\n  </span><span class="s1">if (exprs.length === 1) return exprs[0];</span><span class="s3">\n  </span><span class="s1">return t.sequenceExpression(exprs);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Create FunctionExpression from a ClassPrivateMethod.</span><span class="s3">\n </span><span class="s1">* The returned FunctionExpression node takes ownership of the private method's body and params.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {t.ClassPrivateMethod} node</span><span class="s3">\n </span><span class="s1">* @returns</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function createFunctionExpressionFromPrivateMethod(node: t.ClassPrivateMethod) {</span><span class="s3">\n  </span><span class="s1">const { params, body, generator: isGenerator, async: isAsync } = node;</span><span class="s3">\n  </span><span class="s1">return t.functionExpression(</span><span class="s3">\n    </span><span class="s1">undefined,</span><span class="s3">\n    </span><span class="s1">// @ts-expect-error todo: Improve typings: TSParameterProperty is only allowed in constructor</span><span class="s3">\n    </span><span class="s1">params,</span><span class="s3">\n    </span><span class="s1">body,</span><span class="s3">\n    </span><span class="s1">isGenerator,</span><span class="s3">\n    </span><span class="s1">isAsync,</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createSetFunctionNameCall(</span><span class="s3">\n  </span><span class="s1">state: PluginPass,</span><span class="s3">\n  </span><span class="s1">className: t.Identifier | t.StringLiteral,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">return t.callExpression(state.addHelper(</span><span class="s3">\&quot;</span><span class="s1">setFunctionName</span><span class="s3">\&quot;</span><span class="s1">), [</span><span class="s3">\n    </span><span class="s1">t.thisExpression(),</span><span class="s3">\n    </span><span class="s1">className,</span><span class="s3">\n  </span><span class="s1">]);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createToPropertyKeyCall(state: PluginPass, propertyKey: t.Expression) {</span><span class="s3">\n  </span><span class="s1">return t.callExpression(state.addHelper(</span><span class="s3">\&quot;</span><span class="s1">toPropertyKey</span><span class="s3">\&quot;</span><span class="s1">), [propertyKey]);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createPrivateBrandCheckClosure(brandName: t.PrivateName) {</span><span class="s3">\n  </span><span class="s1">return t.arrowFunctionExpression(</span><span class="s3">\n    </span><span class="s1">[t.identifier(</span><span class="s3">\&quot;</span><span class="s1">_</span><span class="s3">\&quot;</span><span class="s1">)],</span><span class="s3">\n    </span><span class="s1">t.binaryExpression(</span><span class="s3">\&quot;</span><span class="s1">in</span><span class="s3">\&quot;</span><span class="s1">, t.cloneNode(brandName), t.identifier(</span><span class="s3">\&quot;</span><span class="s1">_</span><span class="s3">\&quot;</span><span class="s1">)),</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function usesPrivateField(expression: t.Node) {</span><span class="s3">\n  </span><span class="s1">if (process.env.BABEL_8_BREAKING) {</span><span class="s3">\n    </span><span class="s1">return t.traverseFast(expression, node =&gt; {</span><span class="s3">\n      </span><span class="s1">if (t.isPrivateName(node)) {</span><span class="s3">\n        </span><span class="s1">return t.traverseFast.stop;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">t.traverseFast(expression, node =&gt; {</span><span class="s3">\n        </span><span class="s1">if (t.isPrivateName(node)) {</span><span class="s3">\n          </span><span class="s1">// eslint-disable-next-line @typescript-eslint/only-throw-error</span><span class="s3">\n          </span><span class="s1">throw null;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">} catch {</span><span class="s3">\n      </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Convert a non-computed class element to its equivalent computed form.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This function is to provide a decorator evaluation storage from non-computed</span><span class="s3">\n </span><span class="s1">* class elements.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {(NodePath&lt;t.ClassProperty | t.ClassMethod&gt;)} path A non-computed class property or method</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function convertToComputedKey(path: NodePath&lt;t.ClassProperty | t.ClassMethod&gt;) {</span><span class="s3">\n  </span><span class="s1">const { node } = path;</span><span class="s3">\n  </span><span class="s1">node.computed = true;</span><span class="s3">\n  </span><span class="s1">if (t.isIdentifier(node.key)) {</span><span class="s3">\n    </span><span class="s1">node.key = t.stringLiteral(node.key.name);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function hasInstancePrivateAccess(path: NodePath, privateNames: string[]) {</span><span class="s3">\n  </span><span class="s1">let containsInstancePrivateAccess = false;</span><span class="s3">\n  </span><span class="s1">if (privateNames.length &gt; 0) {</span><span class="s3">\n    </span><span class="s1">const privateNameVisitor = privateNameVisitorFactory&lt;</span><span class="s3">\n      </span><span class="s1">PrivateNameVisitorState&lt;null&gt;,</span><span class="s3">\n      </span><span class="s1">null</span><span class="s3">\n    </span><span class="s1">&gt;({</span><span class="s3">\n      </span><span class="s1">PrivateName(path, state) {</span><span class="s3">\n        </span><span class="s1">if (state.privateNamesMap.has(path.node.id.name)) {</span><span class="s3">\n          </span><span class="s1">containsInstancePrivateAccess = true;</span><span class="s3">\n          </span><span class="s1">path.stop();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">const privateNamesMap = new Map&lt;string, null&gt;();</span><span class="s3">\n    </span><span class="s1">for (const name of privateNames) {</span><span class="s3">\n      </span><span class="s1">privateNamesMap.set(name, null);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">path.traverse(privateNameVisitor, {</span><span class="s3">\n      </span><span class="s1">privateNamesMap: privateNamesMap,</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return containsInstancePrivateAccess;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function checkPrivateMethodUpdateError(</span><span class="s3">\n  </span><span class="s1">path: NodePath&lt;t.Class&gt;,</span><span class="s3">\n  </span><span class="s1">decoratedPrivateMethods: Set&lt;string&gt;,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const privateNameVisitor = privateNameVisitorFactory&lt;</span><span class="s3">\n    </span><span class="s1">PrivateNameVisitorState&lt;null&gt;,</span><span class="s3">\n    </span><span class="s1">null</span><span class="s3">\n  </span><span class="s1">&gt;({</span><span class="s3">\n    </span><span class="s1">PrivateName(path, state) {</span><span class="s3">\n      </span><span class="s1">if (!state.privateNamesMap.has(path.node.id.name)) return;</span><span class="s3">\n\n      </span><span class="s1">const parentPath = path.parentPath;</span><span class="s3">\n      </span><span class="s1">const parentParentPath = parentPath.parentPath;</span><span class="s3">\n\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">// this.bar().#x = 123;</span><span class="s3">\n        </span><span class="s1">(parentParentPath.node.type === </span><span class="s3">\&quot;</span><span class="s1">AssignmentExpression</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n          </span><span class="s1">parentParentPath.node.left === parentPath.node) ||</span><span class="s3">\n        </span><span class="s1">// this.#x++;</span><span class="s3">\n        </span><span class="s1">parentParentPath.node.type === </span><span class="s3">\&quot;</span><span class="s1">UpdateExpression</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n        </span><span class="s1">// ([...this.#x] = foo);</span><span class="s3">\n        </span><span class="s1">parentParentPath.node.type === </span><span class="s3">\&quot;</span><span class="s1">RestElement</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n        </span><span class="s1">// ([this.#x] = foo);</span><span class="s3">\n        </span><span class="s1">parentParentPath.node.type === </span><span class="s3">\&quot;</span><span class="s1">ArrayPattern</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n        </span><span class="s1">// ({ a: this.#x } = bar);</span><span class="s3">\n        </span><span class="s1">(parentParentPath.node.type === </span><span class="s3">\&quot;</span><span class="s1">ObjectProperty</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n          </span><span class="s1">parentParentPath.node.value === parentPath.node &amp;&amp;</span><span class="s3">\n          </span><span class="s1">parentParentPath.parentPath.type === </span><span class="s3">\&quot;</span><span class="s1">ObjectPattern</span><span class="s3">\&quot;</span><span class="s1">) ||</span><span class="s3">\n        </span><span class="s1">// for (this.#x of []);</span><span class="s3">\n        </span><span class="s1">(parentParentPath.node.type === </span><span class="s3">\&quot;</span><span class="s1">ForOfStatement</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n          </span><span class="s1">parentParentPath.node.left === parentPath.node)</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">throw path.buildCodeFrameError(</span><span class="s3">\n          </span><span class="s1">`Decorated private methods are read-only, but </span><span class="s3">\&quot;</span><span class="s1">#${path.node.id.name}</span><span class="s3">\&quot; </span><span class="s1">is updated via this expression.`,</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">const privateNamesMap = new Map&lt;string, null&gt;();</span><span class="s3">\n  </span><span class="s1">for (const name of decoratedPrivateMethods) {</span><span class="s3">\n    </span><span class="s1">privateNamesMap.set(name, null);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">path.traverse(privateNameVisitor, {</span><span class="s3">\n    </span><span class="s1">privateNamesMap: privateNamesMap,</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Apply decorator and accessor transform</span><span class="s3">\n </span><span class="s1">* @param path The class path.</span><span class="s3">\n </span><span class="s1">* @param state The plugin pass.</span><span class="s3">\n </span><span class="s1">* @param constantSuper The constantSuper compiler assumption.</span><span class="s3">\n </span><span class="s1">* @param ignoreFunctionLength The ignoreFunctionLength compiler assumption.</span><span class="s3">\n </span><span class="s1">* @param className The class name.</span><span class="s3">\n </span><span class="s1">* - If className is a `string`, it will be a valid identifier name that can safely serve as a class id</span><span class="s3">\n </span><span class="s1">* - If className is an Identifier, it is the reference to the name derived from NamedEvaluation</span><span class="s3">\n </span><span class="s1">* - If className is a StringLiteral, it is derived from NamedEvaluation on literal computed keys</span><span class="s3">\n </span><span class="s1">* @param propertyVisitor The visitor that should be applied on property prior to the transform.</span><span class="s3">\n </span><span class="s1">* @param version The decorator version.</span><span class="s3">\n </span><span class="s1">* @returns The transformed class path or undefined if there are no decorators.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function transformClass(</span><span class="s3">\n  </span><span class="s1">path: NodePath&lt;t.Class&gt;,</span><span class="s3">\n  </span><span class="s1">state: PluginPass,</span><span class="s3">\n  </span><span class="s1">constantSuper: boolean,</span><span class="s3">\n  </span><span class="s1">ignoreFunctionLength: boolean,</span><span class="s3">\n  </span><span class="s1">className: string | t.Identifier | t.StringLiteral | undefined,</span><span class="s3">\n  </span><span class="s1">propertyVisitor: Visitor&lt;PluginPass&gt;,</span><span class="s3">\n  </span><span class="s1">version: DecoratorVersionKind,</span><span class="s3">\n</span><span class="s1">): NodePath | undefined {</span><span class="s3">\n  </span><span class="s1">const body = path.get(</span><span class="s3">\&quot;</span><span class="s1">body.body</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n  </span><span class="s1">const classDecorators = path.node.decorators;</span><span class="s3">\n  </span><span class="s1">let hasElementDecorators = false;</span><span class="s3">\n  </span><span class="s1">let hasComputedKeysSideEffects = false;</span><span class="s3">\n  </span><span class="s1">let elemDecsUseFnContext = false;</span><span class="s3">\n\n  </span><span class="s1">const generateClassPrivateUid = createLazyPrivateUidGeneratorForClass(path);</span><span class="s3">\n\n  </span><span class="s1">const classAssignments: t.AssignmentExpression[] = [];</span><span class="s3">\n  </span><span class="s1">const scopeParent: Scope = path.scope.parent;</span><span class="s3">\n  </span><span class="s1">const memoiseExpression = (</span><span class="s3">\n    </span><span class="s1">expression: t.Expression,</span><span class="s3">\n    </span><span class="s1">hint: string,</span><span class="s3">\n    </span><span class="s1">assignments: t.AssignmentExpression[],</span><span class="s3">\n  </span><span class="s1">) =&gt; {</span><span class="s3">\n    </span><span class="s1">const localEvaluatedId = generateLetUidIdentifier(scopeParent, hint);</span><span class="s3">\n    </span><span class="s1">assignments.push(t.assignmentExpression(</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">, localEvaluatedId, expression));</span><span class="s3">\n    </span><span class="s1">return t.cloneNode(localEvaluatedId);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">let protoInitLocal: t.Identifier;</span><span class="s3">\n  </span><span class="s1">let staticInitLocal: t.Identifier;</span><span class="s3">\n  </span><span class="s1">const classIdName = path.node.id?.name;</span><span class="s3">\n  </span><span class="s1">// Whether to generate a setFunctionName call to preserve the class name</span><span class="s3">\n  </span><span class="s1">const setClassName = typeof className === </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">? className : undefined;</span><span class="s3">\n  </span><span class="s1">// Check if the decorator does not reference function-specific</span><span class="s3">\n  </span><span class="s1">// context or the given identifier name or contains yield or await expression.</span><span class="s3">\n  </span><span class="s1">// `true` means </span><span class="s3">\&quot;</span><span class="s1">maybe</span><span class="s3">\&quot; </span><span class="s1">and `false` means </span><span class="s3">\&quot;</span><span class="s1">no</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\n  </span><span class="s1">const usesFunctionContextOrYieldAwait = (decorator: t.Decorator) =&gt; {</span><span class="s3">\n    </span><span class="s1">if (process.env.BABEL_8_BREAKING) {</span><span class="s3">\n      </span><span class="s1">return t.traverseFast(decorator, node =&gt; {</span><span class="s3">\n        </span><span class="s1">if (</span><span class="s3">\n          </span><span class="s1">t.isThisExpression(node) ||</span><span class="s3">\n          </span><span class="s1">t.isSuper(node) ||</span><span class="s3">\n          </span><span class="s1">t.isYieldExpression(node) ||</span><span class="s3">\n          </span><span class="s1">t.isAwaitExpression(node) ||</span><span class="s3">\n          </span><span class="s1">t.isIdentifier(node, { name: </span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot; </span><span class="s1">}) ||</span><span class="s3">\n          </span><span class="s1">(classIdName &amp;&amp; t.isIdentifier(node, { name: classIdName })) ||</span><span class="s3">\n          </span><span class="s1">(t.isMetaProperty(node) &amp;&amp; node.meta.name !== </span><span class="s3">\&quot;</span><span class="s1">import</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">return t.traverseFast.stop;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">t.traverseFast(decorator, node =&gt; {</span><span class="s3">\n          </span><span class="s1">if (</span><span class="s3">\n            </span><span class="s1">t.isThisExpression(node) ||</span><span class="s3">\n            </span><span class="s1">t.isSuper(node) ||</span><span class="s3">\n            </span><span class="s1">t.isYieldExpression(node) ||</span><span class="s3">\n            </span><span class="s1">t.isAwaitExpression(node) ||</span><span class="s3">\n            </span><span class="s1">t.isIdentifier(node, { name: </span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot; </span><span class="s1">}) ||</span><span class="s3">\n            </span><span class="s1">(classIdName &amp;&amp; t.isIdentifier(node, { name: classIdName })) ||</span><span class="s3">\n            </span><span class="s1">(t.isMetaProperty(node) &amp;&amp; node.meta.name !== </span><span class="s3">\&quot;</span><span class="s1">import</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">// eslint-disable-next-line @typescript-eslint/only-throw-error</span><span class="s3">\n            </span><span class="s1">throw null;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n      </span><span class="s1">} catch {</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">const instancePrivateNames: string[] = [];</span><span class="s3">\n  </span><span class="s1">// Iterate over the class to see if we need to decorate it, and also to</span><span class="s3">\n  </span><span class="s1">// transform simple auto accessors which are not decorated, and handle inferred</span><span class="s3">\n  </span><span class="s1">// class name when the initializer of the class field is a class expression</span><span class="s3">\n  </span><span class="s1">for (const element of body) {</span><span class="s3">\n    </span><span class="s1">if (!isClassDecoratableElementPath(element)) {</span><span class="s3">\n      </span><span class="s1">continue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const elementNode = element.node;</span><span class="s3">\n\n    </span><span class="s1">if (!elementNode.static &amp;&amp; t.isPrivateName(elementNode.key)) {</span><span class="s3">\n      </span><span class="s1">instancePrivateNames.push(elementNode.key.id.name);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (isDecorated(elementNode)) {</span><span class="s3">\n      </span><span class="s1">switch (elementNode.type) {</span><span class="s3">\n        </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ClassProperty</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n          </span><span class="s1">// @ts-expect-error todo: propertyVisitor.ClassProperty should be callable. Improve typings.</span><span class="s3">\n          </span><span class="s1">propertyVisitor.ClassProperty(</span><span class="s3">\n            </span><span class="s1">element as NodePath&lt;t.ClassProperty&gt;,</span><span class="s3">\n            </span><span class="s1">state,</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ClassPrivateProperty</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n          </span><span class="s1">// @ts-expect-error todo: propertyVisitor.ClassPrivateProperty should be callable. Improve typings.</span><span class="s3">\n          </span><span class="s1">propertyVisitor.ClassPrivateProperty(</span><span class="s3">\n            </span><span class="s1">element as NodePath&lt;t.ClassPrivateProperty&gt;,</span><span class="s3">\n            </span><span class="s1">state,</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ClassAccessorProperty</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n          </span><span class="s1">// @ts-expect-error todo: propertyVisitor.ClassAccessorProperty should be callable. Improve typings.</span><span class="s3">\n          </span><span class="s1">propertyVisitor.ClassAccessorProperty(</span><span class="s3">\n            </span><span class="s1">element as NodePath&lt;t.ClassAccessorProperty&gt;,</span><span class="s3">\n            </span><span class="s1">state,</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">if (version === </span><span class="s3">\&quot;</span><span class="s1">2023-11</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">/* fallthrough */</span><span class="s3">\n        </span><span class="s1">default:</span><span class="s3">\n          </span><span class="s1">if (elementNode.static) {</span><span class="s3">\n            </span><span class="s1">staticInitLocal ??= generateLetUidIdentifier(</span><span class="s3">\n              </span><span class="s1">scopeParent,</span><span class="s3">\n              \&quot;</span><span class="s1">initStatic</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">protoInitLocal ??= generateLetUidIdentifier(</span><span class="s3">\n              </span><span class="s1">scopeParent,</span><span class="s3">\n              \&quot;</span><span class="s1">initProto</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">hasElementDecorators = true;</span><span class="s3">\n      </span><span class="s1">elemDecsUseFnContext ||= elementNode.decorators.some(</span><span class="s3">\n        </span><span class="s1">usesFunctionContextOrYieldAwait,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">} else if (elementNode.type === </span><span class="s3">\&quot;</span><span class="s1">ClassAccessorProperty</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">// @ts-expect-error todo: propertyVisitor.ClassAccessorProperty should be callable. Improve typings.</span><span class="s3">\n      </span><span class="s1">propertyVisitor.ClassAccessorProperty(</span><span class="s3">\n        </span><span class="s1">element as NodePath&lt;t.ClassAccessorProperty&gt;,</span><span class="s3">\n        </span><span class="s1">state,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">const { key, value, static: isStatic, computed } = elementNode;</span><span class="s3">\n\n      </span><span class="s1">const newId = generateClassPrivateUid();</span><span class="s3">\n      </span><span class="s1">const newField = generateClassProperty(newId, value, isStatic);</span><span class="s3">\n      </span><span class="s1">const keyPath = element.get(</span><span class="s3">\&quot;</span><span class="s1">key</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">const [newPath] = element.replaceWith(newField);</span><span class="s3">\n\n      </span><span class="s1">let getterKey, setterKey;</span><span class="s3">\n      </span><span class="s1">if (computed &amp;&amp; !keyPath.isConstantExpression()) {</span><span class="s3">\n        </span><span class="s1">getterKey = memoiseComputedKey(</span><span class="s3">\n          </span><span class="s1">createToPropertyKeyCall(state, key as t.Expression),</span><span class="s3">\n          </span><span class="s1">scopeParent,</span><span class="s3">\n          </span><span class="s1">scopeParent.generateUid(</span><span class="s3">\&quot;</span><span class="s1">computedKey</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">)!;</span><span class="s3">\n        </span><span class="s1">setterKey = t.cloneNode(getterKey.left as t.Identifier);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">getterKey = t.cloneNode(key);</span><span class="s3">\n        </span><span class="s1">setterKey = t.cloneNode(key);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">assignIdForAnonymousClass(path, className);</span><span class="s3">\n\n      </span><span class="s1">addProxyAccessorsFor(</span><span class="s3">\n        </span><span class="s1">path.node.id,</span><span class="s3">\n        </span><span class="s1">newPath,</span><span class="s3">\n        </span><span class="s1">getterKey,</span><span class="s3">\n        </span><span class="s1">setterKey,</span><span class="s3">\n        </span><span class="s1">newId,</span><span class="s3">\n        </span><span class="s1">computed,</span><span class="s3">\n        </span><span class="s1">isStatic,</span><span class="s3">\n        </span><span class="s1">version,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\&quot;</span><span class="s1">computed</span><span class="s3">\&quot; </span><span class="s1">in element.node &amp;&amp; element.node.computed) {</span><span class="s3">\n      </span><span class="s1">hasComputedKeysSideEffects ||= !scopeParent.isStatic(element.node.key);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (!classDecorators &amp;&amp; !hasElementDecorators) {</span><span class="s3">\n    </span><span class="s1">if (!path.node.id &amp;&amp; typeof className === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">path.node.id = t.identifier(className);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (setClassName) {</span><span class="s3">\n      </span><span class="s1">path.node.body.body.unshift(</span><span class="s3">\n        </span><span class="s1">createStaticBlockFromExpressions([</span><span class="s3">\n          </span><span class="s1">createSetFunctionNameCall(state, setClassName),</span><span class="s3">\n        </span><span class="s1">]),</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// If nothing is decorated and no assignments inserted, return</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const elementDecoratorInfo: DecoratorInfo[] = [];</span><span class="s3">\n\n  </span><span class="s1">let constructorPath: NodePath&lt;t.ClassMethod&gt; | undefined;</span><span class="s3">\n  </span><span class="s1">const decoratedPrivateMethods = new Set&lt;string&gt;();</span><span class="s3">\n\n  </span><span class="s1">let classInitLocal: t.Identifier, classIdLocal: t.Identifier;</span><span class="s3">\n  </span><span class="s1">let decoratorReceiverId: t.Identifier | null = null;</span><span class="s3">\n\n  </span><span class="s1">// Memoise the this value `a.b` of decorator member expressions `@a.b.dec`,</span><span class="s3">\n  </span><span class="s1">type HandleDecoratorsResult = {</span><span class="s3">\n    </span><span class="s1">// whether the whole decorator list requires memoisation</span><span class="s3">\n    </span><span class="s1">hasSideEffects: boolean;</span><span class="s3">\n    </span><span class="s1">usesFnContext: boolean;</span><span class="s3">\n    </span><span class="s1">// the this value of each decorator if applicable</span><span class="s3">\n    </span><span class="s1">decoratorsThis: (t.Expression | undefined)[];</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">function handleDecorators(decorators: t.Decorator[]): HandleDecoratorsResult {</span><span class="s3">\n    </span><span class="s1">let hasSideEffects = false;</span><span class="s3">\n    </span><span class="s1">let usesFnContext = false;</span><span class="s3">\n    </span><span class="s1">const decoratorsThis: (t.Expression | null)[] = [];</span><span class="s3">\n    </span><span class="s1">for (const decorator of decorators) {</span><span class="s3">\n      </span><span class="s1">const { expression } = decorator;</span><span class="s3">\n      </span><span class="s1">let object;</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">(version === </span><span class="s3">\&quot;</span><span class="s1">2023-11</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n          </span><span class="s1">(!process.env.BABEL_8_BREAKING &amp;&amp; version === </span><span class="s3">\&quot;</span><span class="s1">2023-05</span><span class="s3">\&quot;</span><span class="s1">)) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">t.isMemberExpression(expression)</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">if (t.isSuper(expression.object)) {</span><span class="s3">\n          </span><span class="s1">object = t.thisExpression();</span><span class="s3">\n        </span><span class="s1">} else if (scopeParent.isStatic(expression.object)) {</span><span class="s3">\n          </span><span class="s1">object = t.cloneNode(expression.object);</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">decoratorReceiverId ??= generateLetUidIdentifier(scopeParent, </span><span class="s3">\&quot;</span><span class="s1">obj</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">object = t.assignmentExpression(</span><span class="s3">\n            \&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">t.cloneNode(decoratorReceiverId),</span><span class="s3">\n            </span><span class="s1">expression.object,</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">expression.object = t.cloneNode(decoratorReceiverId);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">decoratorsThis.push(object);</span><span class="s3">\n      </span><span class="s1">hasSideEffects ||= !scopeParent.isStatic(expression);</span><span class="s3">\n      </span><span class="s1">usesFnContext ||= usesFunctionContextOrYieldAwait(decorator);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return { hasSideEffects, usesFnContext, decoratorsThis };</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const willExtractSomeElemDecs =</span><span class="s3">\n    </span><span class="s1">hasComputedKeysSideEffects ||</span><span class="s3">\n    </span><span class="s1">(process.env.BABEL_8_BREAKING</span><span class="s3">\n      </span><span class="s1">? elemDecsUseFnContext</span><span class="s3">\n      </span><span class="s1">: elemDecsUseFnContext || version !== </span><span class="s3">\&quot;</span><span class="s1">2023-11</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n  </span><span class="s1">let needsDeclaraionForClassBinding = false;</span><span class="s3">\n  </span><span class="s1">let classDecorationsFlag = 0;</span><span class="s3">\n  </span><span class="s1">let classDecorations: t.Expression[] = [];</span><span class="s3">\n  </span><span class="s1">let classDecorationsId: t.Identifier;</span><span class="s3">\n  </span><span class="s1">let computedKeyAssignments: t.AssignmentExpression[] = [];</span><span class="s3">\n  </span><span class="s1">if (classDecorators) {</span><span class="s3">\n    </span><span class="s1">classInitLocal = generateLetUidIdentifier(scopeParent, </span><span class="s3">\&quot;</span><span class="s1">initClass</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">needsDeclaraionForClassBinding = path.isClassDeclaration();</span><span class="s3">\n    </span><span class="s1">({ id: classIdLocal, path } = replaceClassWithVar(path, className));</span><span class="s3">\n\n    </span><span class="s1">path.node.decorators = null;</span><span class="s3">\n\n    </span><span class="s1">const classDecsUsePrivateName = classDecorators.some(usesPrivateField);</span><span class="s3">\n    </span><span class="s1">const { hasSideEffects, usesFnContext, decoratorsThis } =</span><span class="s3">\n      </span><span class="s1">handleDecorators(classDecorators);</span><span class="s3">\n\n    </span><span class="s1">const { haveThis, decs } = generateDecorationList(</span><span class="s3">\n      </span><span class="s1">classDecorators,</span><span class="s3">\n      </span><span class="s1">decoratorsThis,</span><span class="s3">\n      </span><span class="s1">version,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">classDecorationsFlag = haveThis ? 1 : 0;</span><span class="s3">\n    </span><span class="s1">classDecorations = decs;</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">usesFnContext ||</span><span class="s3">\n      </span><span class="s1">(hasSideEffects &amp;&amp; willExtractSomeElemDecs) ||</span><span class="s3">\n      </span><span class="s1">classDecsUsePrivateName</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">classDecorationsId = memoiseExpression(</span><span class="s3">\n        </span><span class="s1">t.arrayExpression(classDecorations),</span><span class="s3">\n        \&quot;</span><span class="s1">classDecs</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">classAssignments,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (!hasElementDecorators) {</span><span class="s3">\n      </span><span class="s1">// Sync body paths as non-decorated computed accessors have been transpiled</span><span class="s3">\n      </span><span class="s1">// to getter-setter pairs.</span><span class="s3">\n      </span><span class="s1">for (const element of path.get(</span><span class="s3">\&quot;</span><span class="s1">body.body</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n        </span><span class="s1">const { node } = element;</span><span class="s3">\n        </span><span class="s1">const isComputed = </span><span class="s3">\&quot;</span><span class="s1">computed</span><span class="s3">\&quot; </span><span class="s1">in node &amp;&amp; node.computed;</span><span class="s3">\n        </span><span class="s1">if (isComputed) {</span><span class="s3">\n          </span><span class="s1">if (element.isClassProperty({ static: true })) {</span><span class="s3">\n            </span><span class="s1">if (!element.get(</span><span class="s3">\&quot;</span><span class="s1">key</span><span class="s3">\&quot;</span><span class="s1">).isConstantExpression()) {</span><span class="s3">\n              </span><span class="s1">const key = (node as t.ClassProperty).key;</span><span class="s3">\n              </span><span class="s1">const maybeAssignment = memoiseComputedKey(</span><span class="s3">\n                </span><span class="s1">key,</span><span class="s3">\n                </span><span class="s1">scopeParent,</span><span class="s3">\n                </span><span class="s1">scopeParent.generateUid(</span><span class="s3">\&quot;</span><span class="s1">computedKey</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n              </span><span class="s1">);</span><span class="s3">\n              </span><span class="s1">if (maybeAssignment != null) {</span><span class="s3">\n                </span><span class="s1">// If it is a static computed field within a decorated class, we move the computed key</span><span class="s3">\n                </span><span class="s1">// into `computedKeyAssignments` which will be then moved into the non-static class,</span><span class="s3">\n                </span><span class="s1">// to ensure that the evaluation order and private environment are correct</span><span class="s3">\n                </span><span class="s1">node.key = t.cloneNode(maybeAssignment.left);</span><span class="s3">\n                </span><span class="s1">computedKeyAssignments.push(maybeAssignment);</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">} else if (computedKeyAssignments.length &gt; 0) {</span><span class="s3">\n            </span><span class="s1">prependExpressionsToComputedKey(</span><span class="s3">\n              </span><span class="s1">computedKeyAssignments,</span><span class="s3">\n              </span><span class="s1">element as NodePath&lt;ClassElementCanHaveComputedKeys&gt;,</span><span class="s3">\n            </span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">computedKeyAssignments = [];</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">assignIdForAnonymousClass(path, className);</span><span class="s3">\n    </span><span class="s1">classIdLocal = t.cloneNode(path.node.id);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let lastInstancePrivateName: t.PrivateName;</span><span class="s3">\n  </span><span class="s1">let needsInstancePrivateBrandCheck = false;</span><span class="s3">\n\n  </span><span class="s1">let fieldInitializerExpressions = [];</span><span class="s3">\n  </span><span class="s1">let staticFieldInitializerExpressions: t.Expression[] = [];</span><span class="s3">\n\n  </span><span class="s1">if (hasElementDecorators) {</span><span class="s3">\n    </span><span class="s1">if (protoInitLocal) {</span><span class="s3">\n      </span><span class="s1">const protoInitCall = t.callExpression(t.cloneNode(protoInitLocal), [</span><span class="s3">\n        </span><span class="s1">t.thisExpression(),</span><span class="s3">\n      </span><span class="s1">]);</span><span class="s3">\n      </span><span class="s1">fieldInitializerExpressions.push(protoInitCall);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">for (const element of body) {</span><span class="s3">\n      </span><span class="s1">if (!isClassDecoratableElementPath(element)) {</span><span class="s3">\n        </span><span class="s1">if (</span><span class="s3">\n          </span><span class="s1">staticFieldInitializerExpressions.length &gt; 0 &amp;&amp;</span><span class="s3">\n          </span><span class="s1">element.isStaticBlock()</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">prependExpressionsToStaticBlock(</span><span class="s3">\n            </span><span class="s1">staticFieldInitializerExpressions,</span><span class="s3">\n            </span><span class="s1">element,</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">staticFieldInitializerExpressions = [];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">continue;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const { node } = element;</span><span class="s3">\n      </span><span class="s1">const decorators = node.decorators;</span><span class="s3">\n\n      </span><span class="s1">const hasDecorators = !!decorators?.length;</span><span class="s3">\n\n      </span><span class="s1">const isComputed = </span><span class="s3">\&quot;</span><span class="s1">computed</span><span class="s3">\&quot; </span><span class="s1">in node &amp;&amp; node.computed;</span><span class="s3">\n\n      </span><span class="s1">let name = </span><span class="s3">\&quot;</span><span class="s1">computedKey</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n      </span><span class="s1">if (node.key.type === </span><span class="s3">\&quot;</span><span class="s1">PrivateName</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">name = node.key.id.name;</span><span class="s3">\n      </span><span class="s1">} else if (!isComputed &amp;&amp; node.key.type === </span><span class="s3">\&quot;</span><span class="s1">Identifier</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">name = node.key.name;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">let decoratorsArray: t.Identifier | t.ArrayExpression | t.Expression;</span><span class="s3">\n      </span><span class="s1">let decoratorsHaveThis;</span><span class="s3">\n\n      </span><span class="s1">if (hasDecorators) {</span><span class="s3">\n        </span><span class="s1">const { hasSideEffects, usesFnContext, decoratorsThis } =</span><span class="s3">\n          </span><span class="s1">handleDecorators(decorators);</span><span class="s3">\n        </span><span class="s1">const { decs, haveThis } = generateDecorationList(</span><span class="s3">\n          </span><span class="s1">decorators,</span><span class="s3">\n          </span><span class="s1">decoratorsThis,</span><span class="s3">\n          </span><span class="s1">version,</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">decoratorsHaveThis = haveThis;</span><span class="s3">\n        </span><span class="s1">decoratorsArray = decs.length === 1 ? decs[0] : t.arrayExpression(decs);</span><span class="s3">\n        </span><span class="s1">if (usesFnContext || (hasSideEffects &amp;&amp; willExtractSomeElemDecs)) {</span><span class="s3">\n          </span><span class="s1">decoratorsArray = memoiseExpression(</span><span class="s3">\n            </span><span class="s1">decoratorsArray,</span><span class="s3">\n            </span><span class="s1">name + </span><span class="s3">\&quot;</span><span class="s1">Decs</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">computedKeyAssignments,</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (isComputed) {</span><span class="s3">\n        </span><span class="s1">if (!element.get(</span><span class="s3">\&quot;</span><span class="s1">key</span><span class="s3">\&quot;</span><span class="s1">).isConstantExpression()) {</span><span class="s3">\n          </span><span class="s1">const key = node.key as t.Expression;</span><span class="s3">\n          </span><span class="s1">const maybeAssignment = memoiseComputedKey(</span><span class="s3">\n            </span><span class="s1">hasDecorators ? createToPropertyKeyCall(state, key) : key,</span><span class="s3">\n            </span><span class="s1">scopeParent,</span><span class="s3">\n            </span><span class="s1">scopeParent.generateUid(</span><span class="s3">\&quot;</span><span class="s1">computedKey</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">if (maybeAssignment != null) {</span><span class="s3">\n            </span><span class="s1">// If it is a static computed field within a decorated class, we move the computed key</span><span class="s3">\n            </span><span class="s1">// into `computedKeyAssignments` which will be then moved into the non-static class,</span><span class="s3">\n            </span><span class="s1">// to ensure that the evaluation order and private environment are correct</span><span class="s3">\n            </span><span class="s1">if (classDecorators &amp;&amp; element.isClassProperty({ static: true })) {</span><span class="s3">\n              </span><span class="s1">node.key = t.cloneNode(maybeAssignment.left);</span><span class="s3">\n              </span><span class="s1">computedKeyAssignments.push(maybeAssignment);</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">node.key = maybeAssignment;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const { key, static: isStatic } = node;</span><span class="s3">\n\n      </span><span class="s1">const isPrivate = key.type === </span><span class="s3">\&quot;</span><span class="s1">PrivateName</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n      </span><span class="s1">const kind = getElementKind(element);</span><span class="s3">\n\n      </span><span class="s1">if (isPrivate &amp;&amp; !isStatic) {</span><span class="s3">\n        </span><span class="s1">if (hasDecorators) {</span><span class="s3">\n          </span><span class="s1">needsInstancePrivateBrandCheck = true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (t.isClassPrivateProperty(node) || !lastInstancePrivateName) {</span><span class="s3">\n          </span><span class="s1">lastInstancePrivateName = key;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (element.isClassMethod({ kind: </span><span class="s3">\&quot;</span><span class="s1">constructor</span><span class="s3">\&quot; </span><span class="s1">})) {</span><span class="s3">\n        </span><span class="s1">constructorPath = element;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">let locals: t.Identifier[];</span><span class="s3">\n      </span><span class="s1">if (hasDecorators) {</span><span class="s3">\n        </span><span class="s1">let privateMethods: Array&lt;</span><span class="s3">\n          </span><span class="s1">t.FunctionExpression | t.ArrowFunctionExpression</span><span class="s3">\n        </span><span class="s1">&gt;;</span><span class="s3">\n\n        </span><span class="s1">let nameExpr: t.Expression;</span><span class="s3">\n\n        </span><span class="s1">if (isComputed) {</span><span class="s3">\n          </span><span class="s1">nameExpr = getComputedKeyMemoiser(</span><span class="s3">\n            </span><span class="s1">element.get(</span><span class="s3">\&quot;</span><span class="s1">key</span><span class="s3">\&quot;</span><span class="s1">) as NodePath&lt;t.Expression&gt;,</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">} else if (key.type === </span><span class="s3">\&quot;</span><span class="s1">PrivateName</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">nameExpr = t.stringLiteral(key.id.name);</span><span class="s3">\n        </span><span class="s1">} else if (key.type === </span><span class="s3">\&quot;</span><span class="s1">Identifier</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">nameExpr = t.stringLiteral(key.name);</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">nameExpr = t.cloneNode(key as t.Expression);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (kind === ACCESSOR) {</span><span class="s3">\n          </span><span class="s1">const { value } = element.node as t.ClassAccessorProperty;</span><span class="s3">\n\n          </span><span class="s1">const params: t.Expression[] =</span><span class="s3">\n            </span><span class="s1">(process.env.BABEL_8_BREAKING || version === </span><span class="s3">\&quot;</span><span class="s1">2023-11</span><span class="s3">\&quot;</span><span class="s1">) &amp;&amp; isStatic</span><span class="s3">\n              </span><span class="s1">? []</span><span class="s3">\n              </span><span class="s1">: [t.thisExpression()];</span><span class="s3">\n\n          </span><span class="s1">if (value) {</span><span class="s3">\n            </span><span class="s1">params.push(t.cloneNode(value));</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">const newId = generateClassPrivateUid();</span><span class="s3">\n          </span><span class="s1">const newFieldInitId = generateLetUidIdentifier(</span><span class="s3">\n            </span><span class="s1">scopeParent,</span><span class="s3">\n            </span><span class="s1">`init_${name}`,</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">const newValue = t.callExpression(</span><span class="s3">\n            </span><span class="s1">t.cloneNode(newFieldInitId),</span><span class="s3">\n            </span><span class="s1">params,</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n\n          </span><span class="s1">const newField = generateClassProperty(newId, newValue, isStatic);</span><span class="s3">\n          </span><span class="s1">const [newPath] = element.replaceWith(newField);</span><span class="s3">\n\n          </span><span class="s1">if (isPrivate) {</span><span class="s3">\n            </span><span class="s1">privateMethods = extractProxyAccessorsFor(newId, version);</span><span class="s3">\n\n            </span><span class="s1">const getId = generateLetUidIdentifier(scopeParent, `get_${name}`);</span><span class="s3">\n            </span><span class="s1">const setId = generateLetUidIdentifier(scopeParent, `set_${name}`);</span><span class="s3">\n\n            </span><span class="s1">addCallAccessorsFor(version, newPath, key, getId, setId, isStatic);</span><span class="s3">\n\n            </span><span class="s1">locals = [newFieldInitId, getId, setId];</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">assignIdForAnonymousClass(path, className);</span><span class="s3">\n            </span><span class="s1">addProxyAccessorsFor(</span><span class="s3">\n              </span><span class="s1">path.node.id,</span><span class="s3">\n              </span><span class="s1">newPath,</span><span class="s3">\n              </span><span class="s1">t.cloneNode(key),</span><span class="s3">\n              </span><span class="s1">t.isAssignmentExpression(key)</span><span class="s3">\n                </span><span class="s1">? t.cloneNode(key.left as t.Identifier)</span><span class="s3">\n                </span><span class="s1">: t.cloneNode(key),</span><span class="s3">\n              </span><span class="s1">newId,</span><span class="s3">\n              </span><span class="s1">isComputed,</span><span class="s3">\n              </span><span class="s1">isStatic,</span><span class="s3">\n              </span><span class="s1">version,</span><span class="s3">\n            </span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">locals = [newFieldInitId];</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} else if (kind === FIELD) {</span><span class="s3">\n          </span><span class="s1">const initId = generateLetUidIdentifier(scopeParent, `init_${name}`);</span><span class="s3">\n          </span><span class="s1">const valuePath = (</span><span class="s3">\n            </span><span class="s1">element as NodePath&lt;t.ClassProperty | t.ClassPrivateProperty&gt;</span><span class="s3">\n          </span><span class="s1">).get(</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n          </span><span class="s1">const args: t.Expression[] =</span><span class="s3">\n            </span><span class="s1">(process.env.BABEL_8_BREAKING || version === </span><span class="s3">\&quot;</span><span class="s1">2023-11</span><span class="s3">\&quot;</span><span class="s1">) &amp;&amp; isStatic</span><span class="s3">\n              </span><span class="s1">? []</span><span class="s3">\n              </span><span class="s1">: [t.thisExpression()];</span><span class="s3">\n          </span><span class="s1">if (valuePath.node) args.push(valuePath.node);</span><span class="s3">\n\n          </span><span class="s1">valuePath.replaceWith(t.callExpression(t.cloneNode(initId), args));</span><span class="s3">\n\n          </span><span class="s1">locals = [initId];</span><span class="s3">\n\n          </span><span class="s1">if (isPrivate) {</span><span class="s3">\n            </span><span class="s1">privateMethods = extractProxyAccessorsFor(key, version);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} else if (isPrivate) {</span><span class="s3">\n          </span><span class="s1">const callId = generateLetUidIdentifier(scopeParent, `call_${name}`);</span><span class="s3">\n          </span><span class="s1">locals = [callId];</span><span class="s3">\n\n          </span><span class="s1">const replaceSupers = new ReplaceSupers({</span><span class="s3">\n            </span><span class="s1">constantSuper,</span><span class="s3">\n            </span><span class="s1">methodPath: element as NodePath&lt;t.ClassPrivateMethod&gt;,</span><span class="s3">\n            </span><span class="s1">objectRef: classIdLocal,</span><span class="s3">\n            </span><span class="s1">superRef: path.node.superClass,</span><span class="s3">\n            </span><span class="s1">file: state.file,</span><span class="s3">\n            </span><span class="s1">refToPreserve: classIdLocal,</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n\n          </span><span class="s1">replaceSupers.replace();</span><span class="s3">\n\n          </span><span class="s1">privateMethods = [</span><span class="s3">\n            </span><span class="s1">createFunctionExpressionFromPrivateMethod(</span><span class="s3">\n              </span><span class="s1">element.node as t.ClassPrivateMethod,</span><span class="s3">\n            </span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">];</span><span class="s3">\n\n          </span><span class="s1">if (kind === GETTER || kind === SETTER) {</span><span class="s3">\n            </span><span class="s1">movePrivateAccessor(</span><span class="s3">\n              </span><span class="s1">element as NodePath&lt;t.ClassPrivateMethod&gt;,</span><span class="s3">\n              </span><span class="s1">t.cloneNode(key),</span><span class="s3">\n              </span><span class="s1">t.cloneNode(callId),</span><span class="s3">\n              </span><span class="s1">isStatic,</span><span class="s3">\n            </span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">const node = element.node as t.ClassPrivateMethod;</span><span class="s3">\n\n            </span><span class="s1">// Unshift</span><span class="s3">\n            </span><span class="s1">path.node.body.body.unshift(</span><span class="s3">\n              </span><span class="s1">t.classPrivateProperty(key, t.cloneNode(callId), [], node.static),</span><span class="s3">\n            </span><span class="s1">);</span><span class="s3">\n\n            </span><span class="s1">decoratedPrivateMethods.add(key.id.name);</span><span class="s3">\n\n            </span><span class="s1">element.remove();</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">elementDecoratorInfo.push({</span><span class="s3">\n          </span><span class="s1">kind,</span><span class="s3">\n          </span><span class="s1">decoratorsArray,</span><span class="s3">\n          </span><span class="s1">decoratorsHaveThis,</span><span class="s3">\n          </span><span class="s1">name: nameExpr,</span><span class="s3">\n          </span><span class="s1">isStatic,</span><span class="s3">\n          </span><span class="s1">privateMethods,</span><span class="s3">\n          </span><span class="s1">locals,</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n\n        </span><span class="s1">if (element.node) {</span><span class="s3">\n          </span><span class="s1">element.node.decorators = null;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (isComputed &amp;&amp; computedKeyAssignments.length &gt; 0) {</span><span class="s3">\n        </span><span class="s1">if (classDecorators &amp;&amp; element.isClassProperty({ static: true })) {</span><span class="s3">\n          </span><span class="s1">// If the class is decorated, we don't insert computedKeyAssignments here</span><span class="s3">\n          </span><span class="s1">// because any non-static computed elements defined after it will be moved</span><span class="s3">\n          </span><span class="s1">// into the non-static class, so they will be evaluated before the key of</span><span class="s3">\n          </span><span class="s1">// this field. At this momemnt, its key must be either a constant expression</span><span class="s3">\n          </span><span class="s1">// or a uid reference which has been assigned _within_ the non-static class.</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">prependExpressionsToComputedKey(</span><span class="s3">\n            </span><span class="s1">computedKeyAssignments,</span><span class="s3">\n            </span><span class="s1">(kind === ACCESSOR</span><span class="s3">\n              </span><span class="s1">? element.getNextSibling() // the transpiled getter of the accessor property</span><span class="s3">\n              </span><span class="s1">: element) as NodePath&lt;ClassElementCanHaveComputedKeys&gt;,</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">computedKeyAssignments = [];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">fieldInitializerExpressions.length &gt; 0 &amp;&amp;</span><span class="s3">\n        </span><span class="s1">!isStatic &amp;&amp;</span><span class="s3">\n        </span><span class="s1">(kind === FIELD || kind === ACCESSOR)</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">prependExpressionsToFieldInitializer(</span><span class="s3">\n          </span><span class="s1">fieldInitializerExpressions,</span><span class="s3">\n          </span><span class="s1">element as NodePath&lt;t.ClassProperty | t.ClassPrivateProperty&gt;,</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">fieldInitializerExpressions = [];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">staticFieldInitializerExpressions.length &gt; 0 &amp;&amp;</span><span class="s3">\n        </span><span class="s1">isStatic &amp;&amp;</span><span class="s3">\n        </span><span class="s1">(kind === FIELD || kind === ACCESSOR)</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">prependExpressionsToFieldInitializer(</span><span class="s3">\n          </span><span class="s1">staticFieldInitializerExpressions,</span><span class="s3">\n          </span><span class="s1">element as NodePath&lt;t.ClassProperty | t.ClassPrivateProperty&gt;,</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">staticFieldInitializerExpressions = [];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (hasDecorators &amp;&amp; version === </span><span class="s3">\&quot;</span><span class="s1">2023-11</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">if (kind === FIELD || kind === ACCESSOR) {</span><span class="s3">\n          </span><span class="s1">const initExtraId = generateLetUidIdentifier(</span><span class="s3">\n            </span><span class="s1">scopeParent,</span><span class="s3">\n            </span><span class="s1">`init_extra_${name}`,</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">locals.push(initExtraId);</span><span class="s3">\n          </span><span class="s1">const initExtraCall = t.callExpression(</span><span class="s3">\n            </span><span class="s1">t.cloneNode(initExtraId),</span><span class="s3">\n            </span><span class="s1">isStatic ? [] : [t.thisExpression()],</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">if (!isStatic) {</span><span class="s3">\n            </span><span class="s1">fieldInitializerExpressions.push(initExtraCall);</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">staticFieldInitializerExpressions.push(initExtraCall);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (computedKeyAssignments.length &gt; 0) {</span><span class="s3">\n    </span><span class="s1">const elements = path.get(</span><span class="s3">\&quot;</span><span class="s1">body.body</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">let lastComputedElement: NodePath&lt;ClassElementCanHaveComputedKeys&gt;;</span><span class="s3">\n    </span><span class="s1">for (let i = elements.length - 1; i &gt;= 0; i--) {</span><span class="s3">\n      </span><span class="s1">const path = elements[i];</span><span class="s3">\n      </span><span class="s1">const node = path.node as ClassElementCanHaveComputedKeys;</span><span class="s3">\n      </span><span class="s1">if (node.computed) {</span><span class="s3">\n        </span><span class="s1">if (classDecorators &amp;&amp; t.isClassProperty(node, { static: true })) {</span><span class="s3">\n          </span><span class="s1">continue;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">lastComputedElement = path as NodePath&lt;ClassElementCanHaveComputedKeys&gt;;</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (lastComputedElement != null) {</span><span class="s3">\n      </span><span class="s1">appendExpressionsToComputedKey(</span><span class="s3">\n        </span><span class="s1">computedKeyAssignments,</span><span class="s3">\n        </span><span class="s1">lastComputedElement,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">computedKeyAssignments = [];</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// If there is no computed key, we will try to convert the first non-computed</span><span class="s3">\n      </span><span class="s1">// class element into a computed key and insert assignments there. This will</span><span class="s3">\n      </span><span class="s1">// be done after we handle the class elements split when the class is decorated.</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (fieldInitializerExpressions.length &gt; 0) {</span><span class="s3">\n    </span><span class="s1">const isDerivedClass = !!path.node.superClass;</span><span class="s3">\n    </span><span class="s1">if (constructorPath) {</span><span class="s3">\n      </span><span class="s1">if (isDerivedClass) {</span><span class="s3">\n        </span><span class="s1">insertExpressionsAfterSuperCallAndOptimize(</span><span class="s3">\n          </span><span class="s1">fieldInitializerExpressions,</span><span class="s3">\n          </span><span class="s1">constructorPath,</span><span class="s3">\n          </span><span class="s1">protoInitLocal,</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">prependExpressionsToConstructor(</span><span class="s3">\n          </span><span class="s1">fieldInitializerExpressions,</span><span class="s3">\n          </span><span class="s1">constructorPath,</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">path.node.body.body.unshift(</span><span class="s3">\n        </span><span class="s1">createConstructorFromExpressions(</span><span class="s3">\n          </span><span class="s1">fieldInitializerExpressions,</span><span class="s3">\n          </span><span class="s1">isDerivedClass,</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">fieldInitializerExpressions = [];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (staticFieldInitializerExpressions.length &gt; 0) {</span><span class="s3">\n    </span><span class="s1">path.node.body.body.push(</span><span class="s3">\n      </span><span class="s1">createStaticBlockFromExpressions(staticFieldInitializerExpressions),</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">staticFieldInitializerExpressions = [];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const sortedElementDecoratorInfo =</span><span class="s3">\n    </span><span class="s1">toSortedDecoratorInfo(elementDecoratorInfo);</span><span class="s3">\n\n  </span><span class="s1">const elementDecorations = generateDecorationExprs(</span><span class="s3">\n    </span><span class="s1">process.env.BABEL_8_BREAKING || version === </span><span class="s3">\&quot;</span><span class="s1">2023-11</span><span class="s3">\&quot;\n      </span><span class="s1">? elementDecoratorInfo</span><span class="s3">\n      </span><span class="s1">: sortedElementDecoratorInfo,</span><span class="s3">\n    </span><span class="s1">version,</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n\n  </span><span class="s1">const elementLocals: t.Identifier[] = extractElementLocalAssignments(</span><span class="s3">\n    </span><span class="s1">sortedElementDecoratorInfo,</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n\n  </span><span class="s1">if (protoInitLocal) {</span><span class="s3">\n    </span><span class="s1">elementLocals.push(protoInitLocal);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (staticInitLocal) {</span><span class="s3">\n    </span><span class="s1">elementLocals.push(staticInitLocal);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const classLocals: t.Identifier[] = [];</span><span class="s3">\n  </span><span class="s1">let classInitInjected = false;</span><span class="s3">\n  </span><span class="s1">const classInitCall =</span><span class="s3">\n    </span><span class="s1">classInitLocal &amp;&amp; t.callExpression(t.cloneNode(classInitLocal), []);</span><span class="s3">\n\n  </span><span class="s1">let originalClassPath = path;</span><span class="s3">\n  </span><span class="s1">const originalClass = path.node;</span><span class="s3">\n\n  </span><span class="s1">const staticClosures: t.AssignmentExpression[] = [];</span><span class="s3">\n  </span><span class="s1">if (classDecorators) {</span><span class="s3">\n    </span><span class="s1">classLocals.push(classIdLocal, classInitLocal);</span><span class="s3">\n    </span><span class="s1">const statics: (</span><span class="s3">\n      </span><span class="s1">| t.ClassProperty</span><span class="s3">\n      </span><span class="s1">| t.ClassPrivateProperty</span><span class="s3">\n      </span><span class="s1">| t.ClassPrivateMethod</span><span class="s3">\n    </span><span class="s1">)[] = [];</span><span class="s3">\n    </span><span class="s1">path.get(</span><span class="s3">\&quot;</span><span class="s1">body.body</span><span class="s3">\&quot;</span><span class="s1">).forEach(element =&gt; {</span><span class="s3">\n      </span><span class="s1">// Static blocks cannot be compiled to </span><span class="s3">\&quot;</span><span class="s1">instance blocks</span><span class="s3">\&quot;</span><span class="s1">, but we can inline</span><span class="s3">\n      </span><span class="s1">// them as IIFEs in the next property.</span><span class="s3">\n      </span><span class="s1">if (element.isStaticBlock()) {</span><span class="s3">\n        </span><span class="s1">if (hasInstancePrivateAccess(element, instancePrivateNames)) {</span><span class="s3">\n          </span><span class="s1">const staticBlockClosureId = memoiseExpression(</span><span class="s3">\n            </span><span class="s1">staticBlockToFunctionClosure(element.node),</span><span class="s3">\n            \&quot;</span><span class="s1">staticBlock</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">staticClosures,</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">staticFieldInitializerExpressions.push(</span><span class="s3">\n            </span><span class="s1">t.callExpression(</span><span class="s3">\n              </span><span class="s1">t.memberExpression(staticBlockClosureId, t.identifier(</span><span class="s3">\&quot;</span><span class="s1">call</span><span class="s3">\&quot;</span><span class="s1">)),</span><span class="s3">\n              </span><span class="s1">[t.thisExpression()],</span><span class="s3">\n            </span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">staticFieldInitializerExpressions.push(</span><span class="s3">\n            </span><span class="s1">staticBlockToIIFE(element.node),</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">element.remove();</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">(element.isClassProperty() || element.isClassPrivateProperty()) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">element.node.static</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">const valuePath = (</span><span class="s3">\n          </span><span class="s1">element as NodePath&lt;t.ClassProperty | t.ClassPrivateProperty&gt;</span><span class="s3">\n        </span><span class="s1">).get(</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">if (hasInstancePrivateAccess(valuePath, instancePrivateNames)) {</span><span class="s3">\n          </span><span class="s1">const fieldValueClosureId = memoiseExpression(</span><span class="s3">\n            </span><span class="s1">fieldInitializerToClosure(valuePath.node),</span><span class="s3">\n            \&quot;</span><span class="s1">fieldValue</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">staticClosures,</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">valuePath.replaceWith(</span><span class="s3">\n            </span><span class="s1">t.callExpression(</span><span class="s3">\n              </span><span class="s1">t.memberExpression(fieldValueClosureId, t.identifier(</span><span class="s3">\&quot;</span><span class="s1">call</span><span class="s3">\&quot;</span><span class="s1">)),</span><span class="s3">\n              </span><span class="s1">[t.thisExpression()],</span><span class="s3">\n            </span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (staticFieldInitializerExpressions.length &gt; 0) {</span><span class="s3">\n          </span><span class="s1">prependExpressionsToFieldInitializer(</span><span class="s3">\n            </span><span class="s1">staticFieldInitializerExpressions,</span><span class="s3">\n            </span><span class="s1">element,</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">staticFieldInitializerExpressions = [];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">element.node.static = false;</span><span class="s3">\n        </span><span class="s1">statics.push(element.node);</span><span class="s3">\n        </span><span class="s1">element.remove();</span><span class="s3">\n      </span><span class="s1">} else if (element.isClassPrivateMethod({ static: true })) {</span><span class="s3">\n        </span><span class="s1">// At this moment the element must not have decorators, so any private name</span><span class="s3">\n        </span><span class="s1">// within the element must come from either params or body</span><span class="s3">\n        </span><span class="s1">if (hasInstancePrivateAccess(element, instancePrivateNames)) {</span><span class="s3">\n          </span><span class="s1">const replaceSupers = new ReplaceSupers({</span><span class="s3">\n            </span><span class="s1">constantSuper,</span><span class="s3">\n            </span><span class="s1">methodPath: element,</span><span class="s3">\n            </span><span class="s1">objectRef: classIdLocal,</span><span class="s3">\n            </span><span class="s1">superRef: path.node.superClass,</span><span class="s3">\n            </span><span class="s1">file: state.file,</span><span class="s3">\n            </span><span class="s1">refToPreserve: classIdLocal,</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n\n          </span><span class="s1">replaceSupers.replace();</span><span class="s3">\n\n          </span><span class="s1">const privateMethodDelegateId = memoiseExpression(</span><span class="s3">\n            </span><span class="s1">createFunctionExpressionFromPrivateMethod(element.node),</span><span class="s3">\n            </span><span class="s1">element.get(</span><span class="s3">\&quot;</span><span class="s1">key.id</span><span class="s3">\&quot;</span><span class="s1">).node.name,</span><span class="s3">\n            </span><span class="s1">staticClosures,</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n\n          </span><span class="s1">if (ignoreFunctionLength) {</span><span class="s3">\n            </span><span class="s1">element.node.params = [t.restElement(t.identifier(</span><span class="s3">\&quot;</span><span class="s1">arg</span><span class="s3">\&quot;</span><span class="s1">))];</span><span class="s3">\n            </span><span class="s1">element.node.body = t.blockStatement([</span><span class="s3">\n              </span><span class="s1">t.returnStatement(</span><span class="s3">\n                </span><span class="s1">t.callExpression(</span><span class="s3">\n                  </span><span class="s1">t.memberExpression(</span><span class="s3">\n                    </span><span class="s1">privateMethodDelegateId,</span><span class="s3">\n                    </span><span class="s1">t.identifier(</span><span class="s3">\&quot;</span><span class="s1">apply</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n                  </span><span class="s1">),</span><span class="s3">\n                  </span><span class="s1">[t.thisExpression(), t.identifier(</span><span class="s3">\&quot;</span><span class="s1">arg</span><span class="s3">\&quot;</span><span class="s1">)],</span><span class="s3">\n                </span><span class="s1">),</span><span class="s3">\n              </span><span class="s1">),</span><span class="s3">\n            </span><span class="s1">]);</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">element.node.params = element.node.params.map((p, i) =&gt; {</span><span class="s3">\n              </span><span class="s1">if (t.isRestElement(p)) {</span><span class="s3">\n                </span><span class="s1">return t.restElement(t.identifier(</span><span class="s3">\&quot;</span><span class="s1">arg</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n              </span><span class="s1">} else {</span><span class="s3">\n                </span><span class="s1">return t.identifier(</span><span class="s3">\&quot;</span><span class="s1">_</span><span class="s3">\&quot; </span><span class="s1">+ i);</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">element.node.body = t.blockStatement([</span><span class="s3">\n              </span><span class="s1">t.returnStatement(</span><span class="s3">\n                </span><span class="s1">t.callExpression(</span><span class="s3">\n                  </span><span class="s1">t.memberExpression(</span><span class="s3">\n                    </span><span class="s1">privateMethodDelegateId,</span><span class="s3">\n                    </span><span class="s1">t.identifier(</span><span class="s3">\&quot;</span><span class="s1">apply</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n                  </span><span class="s1">),</span><span class="s3">\n                  </span><span class="s1">[t.thisExpression(), t.identifier(</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">)],</span><span class="s3">\n                </span><span class="s1">),</span><span class="s3">\n              </span><span class="s1">),</span><span class="s3">\n            </span><span class="s1">]);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">element.node.static = false;</span><span class="s3">\n        </span><span class="s1">statics.push(element.node);</span><span class="s3">\n        </span><span class="s1">element.remove();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n\n    </span><span class="s1">if (statics.length &gt; 0 || staticFieldInitializerExpressions.length &gt; 0) {</span><span class="s3">\n      </span><span class="s1">const staticsClass = template.expression.ast`</span><span class="s3">\n        </span><span class="s1">class extends ${state.addHelper(</span><span class="s3">\&quot;</span><span class="s1">identity</span><span class="s3">\&quot;</span><span class="s1">)} {}</span><span class="s3">\n      </span><span class="s1">` as t.ClassExpression;</span><span class="s3">\n      </span><span class="s1">staticsClass.body.body = [</span><span class="s3">\n        </span><span class="s1">// Insert the original class to a computed key of the wrapper so that</span><span class="s3">\n        </span><span class="s1">// 1) they share the same function context with the wrapper class</span><span class="s3">\n        </span><span class="s1">// 2) the memoisation of static computed field is evaluated before they</span><span class="s3">\n        </span><span class="s1">//    are referenced in the wrapper class keys</span><span class="s3">\n        </span><span class="s1">// Note that any static elements of the wrapper class can not be accessed</span><span class="s3">\n        </span><span class="s1">// in the user land, so we don't have to remove the temporary class field.</span><span class="s3">\n        </span><span class="s1">t.classProperty(</span><span class="s3">\n          </span><span class="s1">t.toExpression(originalClass),</span><span class="s3">\n          </span><span class="s1">undefined,</span><span class="s3">\n          </span><span class="s1">undefined,</span><span class="s3">\n          </span><span class="s1">undefined,</span><span class="s3">\n          </span><span class="s1">/* computed */ true,</span><span class="s3">\n          </span><span class="s1">/* static */ true,</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">...statics,</span><span class="s3">\n      </span><span class="s1">];</span><span class="s3">\n\n      </span><span class="s1">const constructorBody: t.Expression[] = [];</span><span class="s3">\n\n      </span><span class="s1">const newExpr = t.newExpression(staticsClass, []);</span><span class="s3">\n\n      </span><span class="s1">if (staticFieldInitializerExpressions.length &gt; 0) {</span><span class="s3">\n        </span><span class="s1">constructorBody.push(...staticFieldInitializerExpressions);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (classInitCall) {</span><span class="s3">\n        </span><span class="s1">classInitInjected = true;</span><span class="s3">\n        </span><span class="s1">constructorBody.push(classInitCall);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (constructorBody.length &gt; 0) {</span><span class="s3">\n        </span><span class="s1">constructorBody.unshift(</span><span class="s3">\n          </span><span class="s1">t.callExpression(t.super(), [t.cloneNode(classIdLocal)]),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n\n        </span><span class="s1">// set isDerivedClass to false as we have already prepended super call</span><span class="s3">\n        </span><span class="s1">staticsClass.body.body.push(</span><span class="s3">\n          </span><span class="s1">createConstructorFromExpressions(</span><span class="s3">\n            </span><span class="s1">constructorBody,</span><span class="s3">\n            </span><span class="s1">/* isDerivedClass */ false,</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">newExpr.arguments.push(t.cloneNode(classIdLocal));</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const [newPath] = path.replaceWith(newExpr);</span><span class="s3">\n\n      </span><span class="s1">// update originalClassPath according to the new AST</span><span class="s3">\n      </span><span class="s1">originalClassPath = (</span><span class="s3">\n        </span><span class="s1">newPath.get(</span><span class="s3">\&quot;</span><span class="s1">callee</span><span class="s3">\&quot;</span><span class="s1">).get(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">) as NodePath&lt;t.Class&gt;</span><span class="s3">\n      </span><span class="s1">).get(</span><span class="s3">\&quot;</span><span class="s1">body.0.key</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (!classInitInjected &amp;&amp; classInitCall) {</span><span class="s3">\n    </span><span class="s1">path.node.body.body.push(</span><span class="s3">\n      </span><span class="s1">t.staticBlock([t.expressionStatement(classInitCall)]),</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let { superClass } = originalClass;</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">superClass &amp;&amp;</span><span class="s3">\n    </span><span class="s1">(process.env.BABEL_8_BREAKING ||</span><span class="s3">\n      </span><span class="s1">version === </span><span class="s3">\&quot;</span><span class="s1">2023-11</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n      </span><span class="s1">version === </span><span class="s3">\&quot;</span><span class="s1">2023-05</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">const id = path.scope.maybeGenerateMemoised(superClass);</span><span class="s3">\n    </span><span class="s1">if (id) {</span><span class="s3">\n      </span><span class="s1">originalClass.superClass = t.assignmentExpression(</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">, id, superClass);</span><span class="s3">\n      </span><span class="s1">superClass = id;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const applyDecoratorWrapper = t.staticBlock([]);</span><span class="s3">\n  </span><span class="s1">originalClass.body.body.unshift(applyDecoratorWrapper);</span><span class="s3">\n  </span><span class="s1">const applyDecsBody = applyDecoratorWrapper.body;</span><span class="s3">\n  </span><span class="s1">if (computedKeyAssignments.length &gt; 0) {</span><span class="s3">\n    </span><span class="s1">const elements = originalClassPath.get(</span><span class="s3">\&quot;</span><span class="s1">body.body</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">let firstPublicElement: NodePath&lt;t.ClassProperty | t.ClassMethod&gt;;</span><span class="s3">\n    </span><span class="s1">for (const path of elements) {</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">(path.isClassProperty() || path.isClassMethod()) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">(path.node as t.ClassMethod).kind !== </span><span class="s3">\&quot;</span><span class="s1">constructor</span><span class="s3">\&quot;\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">firstPublicElement = path;</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (firstPublicElement != null) {</span><span class="s3">\n      </span><span class="s1">// Convert its key to a computed one to host the decorator evaluations.</span><span class="s3">\n      </span><span class="s1">convertToComputedKey(firstPublicElement);</span><span class="s3">\n      </span><span class="s1">prependExpressionsToComputedKey(</span><span class="s3">\n        </span><span class="s1">computedKeyAssignments,</span><span class="s3">\n        </span><span class="s1">firstPublicElement,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// When there is no public class elements, we inject a temporary computed</span><span class="s3">\n      </span><span class="s1">// field whose key will host the decorator evaluations. The field will be</span><span class="s3">\n      </span><span class="s1">// deleted immediately after it is defiend.</span><span class="s3">\n      </span><span class="s1">originalClass.body.body.unshift(</span><span class="s3">\n        </span><span class="s1">t.classProperty(</span><span class="s3">\n          </span><span class="s1">t.sequenceExpression([</span><span class="s3">\n            </span><span class="s1">...computedKeyAssignments,</span><span class="s3">\n            </span><span class="s1">t.stringLiteral(</span><span class="s3">\&quot;</span><span class="s1">_</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">]),</span><span class="s3">\n          </span><span class="s1">undefined,</span><span class="s3">\n          </span><span class="s1">undefined,</span><span class="s3">\n          </span><span class="s1">undefined,</span><span class="s3">\n          </span><span class="s1">/* computed */ true,</span><span class="s3">\n          </span><span class="s1">/* static */ true,</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">applyDecsBody.push(</span><span class="s3">\n        </span><span class="s1">t.expressionStatement(</span><span class="s3">\n          </span><span class="s1">t.unaryExpression(</span><span class="s3">\n            \&quot;</span><span class="s1">delete</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">t.memberExpression(t.thisExpression(), t.identifier(</span><span class="s3">\&quot;</span><span class="s1">_</span><span class="s3">\&quot;</span><span class="s1">)),</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">computedKeyAssignments = [];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">applyDecsBody.push(</span><span class="s3">\n    </span><span class="s1">t.expressionStatement(</span><span class="s3">\n      </span><span class="s1">createLocalsAssignment(</span><span class="s3">\n        </span><span class="s1">elementLocals,</span><span class="s3">\n        </span><span class="s1">classLocals,</span><span class="s3">\n        </span><span class="s1">elementDecorations,</span><span class="s3">\n        </span><span class="s1">classDecorationsId ?? t.arrayExpression(classDecorations),</span><span class="s3">\n        </span><span class="s1">t.numericLiteral(classDecorationsFlag),</span><span class="s3">\n        </span><span class="s1">needsInstancePrivateBrandCheck ? lastInstancePrivateName : null,</span><span class="s3">\n        </span><span class="s1">setClassName,</span><span class="s3">\n        </span><span class="s1">t.cloneNode(superClass),</span><span class="s3">\n        </span><span class="s1">state,</span><span class="s3">\n        </span><span class="s1">version,</span><span class="s3">\n      </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">if (staticInitLocal) {</span><span class="s3">\n    </span><span class="s1">applyDecsBody.push(</span><span class="s3">\n      </span><span class="s1">t.expressionStatement(</span><span class="s3">\n        </span><span class="s1">t.callExpression(t.cloneNode(staticInitLocal), [t.thisExpression()]),</span><span class="s3">\n      </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (staticClosures.length &gt; 0) {</span><span class="s3">\n    </span><span class="s1">applyDecsBody.push(</span><span class="s3">\n      </span><span class="s1">...staticClosures.map(expr =&gt; t.expressionStatement(expr)),</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// When path is a ClassExpression, path.insertBefore will convert `path`</span><span class="s3">\n  </span><span class="s1">// into a SequenceExpression</span><span class="s3">\n  </span><span class="s1">path.insertBefore(classAssignments.map(expr =&gt; t.expressionStatement(expr)));</span><span class="s3">\n\n  </span><span class="s1">if (needsDeclaraionForClassBinding) {</span><span class="s3">\n    </span><span class="s1">const classBindingInfo = scopeParent.getBinding(classIdLocal.name);</span><span class="s3">\n    </span><span class="s1">if (!classBindingInfo.constantViolations.length) {</span><span class="s3">\n      </span><span class="s1">// optimization: reuse the inner class binding if the outer class binding is not mutated</span><span class="s3">\n      </span><span class="s1">path.insertBefore(</span><span class="s3">\n        </span><span class="s1">t.variableDeclaration(</span><span class="s3">\&quot;</span><span class="s1">let</span><span class="s3">\&quot;</span><span class="s1">, [</span><span class="s3">\n          </span><span class="s1">t.variableDeclarator(t.cloneNode(classIdLocal)),</span><span class="s3">\n        </span><span class="s1">]),</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">const classOuterBindingDelegateLocal = scopeParent.generateUidIdentifier(</span><span class="s3">\n        \&quot;</span><span class="s1">t</span><span class="s3">\&quot; </span><span class="s1">+ classIdLocal.name,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">const classOuterBindingLocal = classIdLocal;</span><span class="s3">\n      </span><span class="s1">path.replaceWithMultiple([</span><span class="s3">\n        </span><span class="s1">t.variableDeclaration(</span><span class="s3">\&quot;</span><span class="s1">let</span><span class="s3">\&quot;</span><span class="s1">, [</span><span class="s3">\n          </span><span class="s1">t.variableDeclarator(t.cloneNode(classOuterBindingLocal)),</span><span class="s3">\n          </span><span class="s1">t.variableDeclarator(classOuterBindingDelegateLocal),</span><span class="s3">\n        </span><span class="s1">]),</span><span class="s3">\n        </span><span class="s1">t.blockStatement([</span><span class="s3">\n          </span><span class="s1">t.variableDeclaration(</span><span class="s3">\&quot;</span><span class="s1">let</span><span class="s3">\&quot;</span><span class="s1">, [</span><span class="s3">\n            </span><span class="s1">t.variableDeclarator(t.cloneNode(classIdLocal)),</span><span class="s3">\n          </span><span class="s1">]),</span><span class="s3">\n          </span><span class="s1">// needsDeclaraionForClassBinding is true ↔ node is a class declaration</span><span class="s3">\n          </span><span class="s1">path.node as t.ClassDeclaration,</span><span class="s3">\n          </span><span class="s1">t.expressionStatement(</span><span class="s3">\n            </span><span class="s1">t.assignmentExpression(</span><span class="s3">\n              \&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n              </span><span class="s1">t.cloneNode(classOuterBindingDelegateLocal),</span><span class="s3">\n              </span><span class="s1">t.cloneNode(classIdLocal),</span><span class="s3">\n            </span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">]),</span><span class="s3">\n        </span><span class="s1">t.expressionStatement(</span><span class="s3">\n          </span><span class="s1">t.assignmentExpression(</span><span class="s3">\n            \&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">t.cloneNode(classOuterBindingLocal),</span><span class="s3">\n            </span><span class="s1">t.cloneNode(classOuterBindingDelegateLocal),</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (decoratedPrivateMethods.size &gt; 0) {</span><span class="s3">\n    </span><span class="s1">checkPrivateMethodUpdateError(path, decoratedPrivateMethods);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Recrawl the scope to make sure new identifiers are properly synced</span><span class="s3">\n  </span><span class="s1">path.scope.crawl();</span><span class="s3">\n\n  </span><span class="s1">return path;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createLocalsAssignment(</span><span class="s3">\n  </span><span class="s1">elementLocals: t.Identifier[],</span><span class="s3">\n  </span><span class="s1">classLocals: t.Identifier[],</span><span class="s3">\n  </span><span class="s1">elementDecorations: t.ArrayExpression | t.Identifier,</span><span class="s3">\n  </span><span class="s1">classDecorations: t.ArrayExpression | t.Identifier,</span><span class="s3">\n  </span><span class="s1">classDecorationsFlag: t.NumericLiteral,</span><span class="s3">\n  </span><span class="s1">maybePrivateBrandName: t.PrivateName | null,</span><span class="s3">\n  </span><span class="s1">setClassName: t.Identifier | t.StringLiteral | undefined,</span><span class="s3">\n  </span><span class="s1">superClass: null | t.Expression,</span><span class="s3">\n  </span><span class="s1">state: PluginPass,</span><span class="s3">\n  </span><span class="s1">version: DecoratorVersionKind,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">let lhs, rhs;</span><span class="s3">\n  </span><span class="s1">const args: t.Expression[] = [</span><span class="s3">\n    </span><span class="s1">setClassName</span><span class="s3">\n      </span><span class="s1">? createSetFunctionNameCall(state, setClassName)</span><span class="s3">\n      </span><span class="s1">: t.thisExpression(),</span><span class="s3">\n    </span><span class="s1">classDecorations,</span><span class="s3">\n    </span><span class="s1">elementDecorations,</span><span class="s3">\n  </span><span class="s1">];</span><span class="s3">\n\n  </span><span class="s1">if (!process.env.BABEL_8_BREAKING) {</span><span class="s3">\n    </span><span class="s1">if (version !== </span><span class="s3">\&quot;</span><span class="s1">2023-11</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">args.splice(1, 2, elementDecorations, classDecorations);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">version === </span><span class="s3">\&quot;</span><span class="s1">2021-12</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n      </span><span class="s1">(version === </span><span class="s3">\&quot;</span><span class="s1">2022-03</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; !state.availableHelper(</span><span class="s3">\&quot;</span><span class="s1">applyDecs2203R</span><span class="s3">\&quot;</span><span class="s1">))</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">lhs = t.arrayPattern([...elementLocals, ...classLocals]);</span><span class="s3">\n      </span><span class="s1">rhs = t.callExpression(</span><span class="s3">\n        </span><span class="s1">state.addHelper(version === </span><span class="s3">\&quot;</span><span class="s1">2021-12</span><span class="s3">\&quot; </span><span class="s1">? </span><span class="s3">\&quot;</span><span class="s1">applyDecs</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">applyDecs2203</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">args,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">return t.assignmentExpression(</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">, lhs, rhs);</span><span class="s3">\n    </span><span class="s1">} else if (version === </span><span class="s3">\&quot;</span><span class="s1">2022-03</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">rhs = t.callExpression(state.addHelper(</span><span class="s3">\&quot;</span><span class="s1">applyDecs2203R</span><span class="s3">\&quot;</span><span class="s1">), args);</span><span class="s3">\n    </span><span class="s1">} else if (version === </span><span class="s3">\&quot;</span><span class="s1">2023-01</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">if (maybePrivateBrandName) {</span><span class="s3">\n        </span><span class="s1">args.push(createPrivateBrandCheckClosure(maybePrivateBrandName));</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">rhs = t.callExpression(state.addHelper(</span><span class="s3">\&quot;</span><span class="s1">applyDecs2301</span><span class="s3">\&quot;</span><span class="s1">), args);</span><span class="s3">\n    </span><span class="s1">} else if (version === </span><span class="s3">\&quot;</span><span class="s1">2023-05</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">maybePrivateBrandName ||</span><span class="s3">\n        </span><span class="s1">superClass ||</span><span class="s3">\n        </span><span class="s1">classDecorationsFlag.value !== 0</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">args.push(classDecorationsFlag);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (maybePrivateBrandName) {</span><span class="s3">\n        </span><span class="s1">args.push(createPrivateBrandCheckClosure(maybePrivateBrandName));</span><span class="s3">\n      </span><span class="s1">} else if (superClass) {</span><span class="s3">\n        </span><span class="s1">args.push(t.unaryExpression(</span><span class="s3">\&quot;</span><span class="s1">void</span><span class="s3">\&quot;</span><span class="s1">, t.numericLiteral(0)));</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (superClass) args.push(superClass);</span><span class="s3">\n      </span><span class="s1">rhs = t.callExpression(state.addHelper(</span><span class="s3">\&quot;</span><span class="s1">applyDecs2305</span><span class="s3">\&quot;</span><span class="s1">), args);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (process.env.BABEL_8_BREAKING || version === </span><span class="s3">\&quot;</span><span class="s1">2023-11</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">maybePrivateBrandName ||</span><span class="s3">\n      </span><span class="s1">superClass ||</span><span class="s3">\n      </span><span class="s1">classDecorationsFlag.value !== 0</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">args.push(classDecorationsFlag);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (maybePrivateBrandName) {</span><span class="s3">\n      </span><span class="s1">args.push(createPrivateBrandCheckClosure(maybePrivateBrandName));</span><span class="s3">\n    </span><span class="s1">} else if (superClass) {</span><span class="s3">\n      </span><span class="s1">args.push(t.unaryExpression(</span><span class="s3">\&quot;</span><span class="s1">void</span><span class="s3">\&quot;</span><span class="s1">, t.numericLiteral(0)));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (superClass) args.push(superClass);</span><span class="s3">\n    </span><span class="s1">rhs = t.callExpression(state.addHelper(</span><span class="s3">\&quot;</span><span class="s1">applyDecs2311</span><span class="s3">\&quot;</span><span class="s1">), args);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// optimize `{ c: [classLocals] } = applyDecsHelper(...)` to</span><span class="s3">\n  </span><span class="s1">// `[classLocals] = applyDecsHelper(...).c`</span><span class="s3">\n  </span><span class="s1">if (elementLocals.length &gt; 0) {</span><span class="s3">\n    </span><span class="s1">if (classLocals.length &gt; 0) {</span><span class="s3">\n      </span><span class="s1">lhs = t.objectPattern([</span><span class="s3">\n        </span><span class="s1">t.objectProperty(t.identifier(</span><span class="s3">\&quot;</span><span class="s1">e</span><span class="s3">\&quot;</span><span class="s1">), t.arrayPattern(elementLocals)),</span><span class="s3">\n        </span><span class="s1">t.objectProperty(t.identifier(</span><span class="s3">\&quot;</span><span class="s1">c</span><span class="s3">\&quot;</span><span class="s1">), t.arrayPattern(classLocals)),</span><span class="s3">\n      </span><span class="s1">]);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">lhs = t.arrayPattern(elementLocals);</span><span class="s3">\n      </span><span class="s1">// @ts-ignore(Babel 7 vs Babel 8) optional removed in Babel 8</span><span class="s3">\n      </span><span class="s1">rhs = t.memberExpression(rhs, t.identifier(</span><span class="s3">\&quot;</span><span class="s1">e</span><span class="s3">\&quot;</span><span class="s1">), false, false);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">// invariant: classLocals.length &gt; 0</span><span class="s3">\n    </span><span class="s1">lhs = t.arrayPattern(classLocals);</span><span class="s3">\n    </span><span class="s1">// @ts-ignore(Babel 7 vs Babel 8) optional removed in Babel 8</span><span class="s3">\n    </span><span class="s1">rhs = t.memberExpression(rhs, t.identifier(</span><span class="s3">\&quot;</span><span class="s1">c</span><span class="s3">\&quot;</span><span class="s1">), false, false);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return t.assignmentExpression(</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">, lhs, rhs);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function isProtoKey(</span><span class="s3">\n  </span><span class="s1">node: t.Identifier | t.StringLiteral | t.BigIntLiteral | t.NumericLiteral,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">return node.type === </span><span class="s3">\&quot;</span><span class="s1">Identifier</span><span class="s3">\&quot;\n    </span><span class="s1">? node.name === </span><span class="s3">\&quot;</span><span class="s1">__proto__</span><span class="s3">\&quot;\n    </span><span class="s1">: node.value === </span><span class="s3">\&quot;</span><span class="s1">__proto__</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function isDecorated(node: t.Class | ClassDecoratableElement) {</span><span class="s3">\n  </span><span class="s1">return node.decorators &amp;&amp; node.decorators.length &gt; 0;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function shouldTransformElement(node: ClassElement) {</span><span class="s3">\n  </span><span class="s1">switch (node.type) {</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ClassAccessorProperty</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ClassMethod</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ClassProperty</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ClassPrivateMethod</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ClassPrivateProperty</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">return isDecorated(node);</span><span class="s3">\n    </span><span class="s1">default:</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function shouldTransformClass(node: t.Class) {</span><span class="s3">\n  </span><span class="s1">return isDecorated(node) || node.body.body.some(shouldTransformElement);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Todo: unify name references logic with helper-function-name</span><span class="s3">\n</span><span class="s1">function NamedEvaluationVisitoryFactory(</span><span class="s3">\n  </span><span class="s1">isAnonymous: (path: NodePath) =&gt; boolean,</span><span class="s3">\n  </span><span class="s1">visitor: (</span><span class="s3">\n    </span><span class="s1">path: NodePath,</span><span class="s3">\n    </span><span class="s1">state: PluginPass,</span><span class="s3">\n    </span><span class="s1">name:</span><span class="s3">\n      </span><span class="s1">| string</span><span class="s3">\n      </span><span class="s1">| t.Identifier</span><span class="s3">\n      </span><span class="s1">| t.StringLiteral</span><span class="s3">\n      </span><span class="s1">| t.NumericLiteral</span><span class="s3">\n      </span><span class="s1">| t.BigIntLiteral,</span><span class="s3">\n  </span><span class="s1">) =&gt; void,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">function handleComputedProperty(</span><span class="s3">\n    </span><span class="s1">propertyPath: NodePath&lt;</span><span class="s3">\n      </span><span class="s1">t.ObjectProperty | t.ClassProperty | t.ClassAccessorProperty</span><span class="s3">\n    </span><span class="s1">&gt;,</span><span class="s3">\n    </span><span class="s1">key: t.Expression,</span><span class="s3">\n    </span><span class="s1">state: PluginPass,</span><span class="s3">\n  </span><span class="s1">): t.StringLiteral | t.Identifier {</span><span class="s3">\n    </span><span class="s1">switch (key.type) {</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">StringLiteral</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return t.stringLiteral(key.value);</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">NumericLiteral</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">BigIntLiteral</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">const keyValue = key.value + </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">propertyPath.get(</span><span class="s3">\&quot;</span><span class="s1">key</span><span class="s3">\&quot;</span><span class="s1">).replaceWith(t.stringLiteral(keyValue));</span><span class="s3">\n        </span><span class="s1">return t.stringLiteral(keyValue);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">default: {</span><span class="s3">\n        </span><span class="s1">const ref = propertyPath.scope.maybeGenerateMemoised(key);</span><span class="s3">\n        </span><span class="s1">propertyPath</span><span class="s3">\n          </span><span class="s1">.get(</span><span class="s3">\&quot;</span><span class="s1">key</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">.replaceWith(</span><span class="s3">\n            </span><span class="s1">t.assignmentExpression(</span><span class="s3">\n              \&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n              </span><span class="s1">ref,</span><span class="s3">\n              </span><span class="s1">createToPropertyKeyCall(state, key),</span><span class="s3">\n            </span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">return t.cloneNode(ref);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">VariableDeclarator(path, state) {</span><span class="s3">\n      </span><span class="s1">const id = path.node.id;</span><span class="s3">\n      </span><span class="s1">if (id.type === </span><span class="s3">\&quot;</span><span class="s1">Identifier</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">const initializer = skipTransparentExprWrappers(path.get(</span><span class="s3">\&quot;</span><span class="s1">init</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n        </span><span class="s1">if (isAnonymous(initializer)) {</span><span class="s3">\n          </span><span class="s1">const name = id.name;</span><span class="s3">\n          </span><span class="s1">visitor(initializer, state, name);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">AssignmentExpression(path, state) {</span><span class="s3">\n      </span><span class="s1">const id = path.node.left;</span><span class="s3">\n      </span><span class="s1">if (id.type === </span><span class="s3">\&quot;</span><span class="s1">Identifier</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">const initializer = skipTransparentExprWrappers(path.get(</span><span class="s3">\&quot;</span><span class="s1">right</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n        </span><span class="s1">if (isAnonymous(initializer)) {</span><span class="s3">\n          </span><span class="s1">switch (path.node.operator) {</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">&amp;&amp;=</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">||=</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">??=</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n              </span><span class="s1">visitor(initializer, state, id.name);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">AssignmentPattern(path, state) {</span><span class="s3">\n      </span><span class="s1">const id = path.node.left;</span><span class="s3">\n      </span><span class="s1">if (id.type === </span><span class="s3">\&quot;</span><span class="s1">Identifier</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">const initializer = skipTransparentExprWrappers(path.get(</span><span class="s3">\&quot;</span><span class="s1">right</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n        </span><span class="s1">if (isAnonymous(initializer)) {</span><span class="s3">\n          </span><span class="s1">const name = id.name;</span><span class="s3">\n          </span><span class="s1">visitor(initializer, state, name);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">// We listen on ObjectExpression so that we don't have to visit</span><span class="s3">\n    </span><span class="s1">// the object properties under object patterns</span><span class="s3">\n    </span><span class="s1">ObjectExpression(path, state) {</span><span class="s3">\n      </span><span class="s1">for (const propertyPath of path.get(</span><span class="s3">\&quot;</span><span class="s1">properties</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n        </span><span class="s1">if (!propertyPath.isObjectProperty()) continue;</span><span class="s3">\n        </span><span class="s1">const { node } = propertyPath;</span><span class="s3">\n        </span><span class="s1">const id = node.key;</span><span class="s3">\n        </span><span class="s1">const initializer = skipTransparentExprWrappers(</span><span class="s3">\n          </span><span class="s1">propertyPath.get(</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">) as NodePath&lt;t.Expression&gt;,</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">if (isAnonymous(initializer)) {</span><span class="s3">\n          </span><span class="s1">if (!node.computed) {</span><span class="s3">\n            </span><span class="s1">// 13.2.5.5 RS: PropertyDefinitionEvaluation</span><span class="s3">\n            </span><span class="s1">if (!isProtoKey(id as t.StringLiteral | t.Identifier)) {</span><span class="s3">\n              </span><span class="s1">if (id.type === </span><span class="s3">\&quot;</span><span class="s1">Identifier</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">visitor(initializer, state, id.name);</span><span class="s3">\n              </span><span class="s1">} else {</span><span class="s3">\n                </span><span class="s1">const className = t.stringLiteral(</span><span class="s3">\n                  </span><span class="s1">(id as t.StringLiteral | t.NumericLiteral | t.BigIntLiteral)</span><span class="s3">\n                    </span><span class="s1">.value + </span><span class="s3">\&quot;\&quot;</span><span class="s1">,</span><span class="s3">\n                </span><span class="s1">);</span><span class="s3">\n                </span><span class="s1">visitor(initializer, state, className);</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">const ref = handleComputedProperty(</span><span class="s3">\n              </span><span class="s1">propertyPath,</span><span class="s3">\n              </span><span class="s1">// The key of a computed object property must not be a private name</span><span class="s3">\n              </span><span class="s1">id as t.Expression,</span><span class="s3">\n              </span><span class="s1">state,</span><span class="s3">\n            </span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">visitor(initializer, state, ref);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">ClassPrivateProperty(path, state) {</span><span class="s3">\n      </span><span class="s1">const { node } = path;</span><span class="s3">\n      </span><span class="s1">const initializer = skipTransparentExprWrappers(path.get(</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n      </span><span class="s1">if (isAnonymous(initializer)) {</span><span class="s3">\n        </span><span class="s1">const className = t.stringLiteral(</span><span class="s3">\&quot;</span><span class="s1">#</span><span class="s3">\&quot; </span><span class="s1">+ node.key.id.name);</span><span class="s3">\n        </span><span class="s1">visitor(initializer, state, className);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">ClassAccessorProperty(path, state) {</span><span class="s3">\n      </span><span class="s1">const { node } = path;</span><span class="s3">\n      </span><span class="s1">const id = node.key;</span><span class="s3">\n      </span><span class="s1">const initializer = skipTransparentExprWrappers(path.get(</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n      </span><span class="s1">if (isAnonymous(initializer)) {</span><span class="s3">\n        </span><span class="s1">if (!node.computed) {</span><span class="s3">\n          </span><span class="s1">if (id.type === </span><span class="s3">\&quot;</span><span class="s1">Identifier</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">visitor(initializer, state, id.name);</span><span class="s3">\n          </span><span class="s1">} else if (id.type === </span><span class="s3">\&quot;</span><span class="s1">PrivateName</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">const className = t.stringLiteral(</span><span class="s3">\&quot;</span><span class="s1">#</span><span class="s3">\&quot; </span><span class="s1">+ id.id.name);</span><span class="s3">\n            </span><span class="s1">visitor(initializer, state, className);</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">const className = t.stringLiteral(</span><span class="s3">\n              </span><span class="s1">(id as t.StringLiteral | t.NumericLiteral | t.BigIntLiteral)</span><span class="s3">\n                </span><span class="s1">.value + </span><span class="s3">\&quot;\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">visitor(initializer, state, className);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">const ref = handleComputedProperty(</span><span class="s3">\n            </span><span class="s1">path,</span><span class="s3">\n            </span><span class="s1">// The key of a computed accessor property must not be a private name</span><span class="s3">\n            </span><span class="s1">id as t.Expression,</span><span class="s3">\n            </span><span class="s1">state,</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">visitor(initializer, state, ref);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">ClassProperty(path, state) {</span><span class="s3">\n      </span><span class="s1">const { node } = path;</span><span class="s3">\n      </span><span class="s1">const id = node.key;</span><span class="s3">\n      </span><span class="s1">const initializer = skipTransparentExprWrappers(path.get(</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n      </span><span class="s1">if (isAnonymous(initializer)) {</span><span class="s3">\n        </span><span class="s1">if (!node.computed) {</span><span class="s3">\n          </span><span class="s1">if (id.type === </span><span class="s3">\&quot;</span><span class="s1">Identifier</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">visitor(initializer, state, id.name);</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">const className = t.stringLiteral(</span><span class="s3">\n              </span><span class="s1">(id as t.StringLiteral | t.NumericLiteral | t.BigIntLiteral)</span><span class="s3">\n                </span><span class="s1">.value + </span><span class="s3">\&quot;\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">visitor(initializer, state, className);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">const ref = handleComputedProperty(path, id, state);</span><span class="s3">\n          </span><span class="s1">visitor(initializer, state, ref);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">} satisfies Visitor&lt;PluginPass&gt;;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function isDecoratedAnonymousClassExpression(path: NodePath) {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">path.isClassExpression({ id: null }) &amp;&amp; shouldTransformClass(path.node)</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function generateLetUidIdentifier(scope: Scope, name: string) {</span><span class="s3">\n  </span><span class="s1">const id = scope.generateUidIdentifier(name);</span><span class="s3">\n  </span><span class="s1">scope.push({ id, kind: </span><span class="s3">\&quot;</span><span class="s1">let</span><span class="s3">\&quot; </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">return t.cloneNode(id);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default function (</span><span class="s3">\n  </span><span class="s1">{ assertVersion, assumption }: PluginAPI,</span><span class="s3">\n  </span><span class="s1">{ loose }: Options,</span><span class="s3">\n  </span><span class="s1">version: DecoratorVersionKind,</span><span class="s3">\n  </span><span class="s1">inherits: PluginObject[</span><span class="s3">\&quot;</span><span class="s1">inherits</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n</span><span class="s1">): PluginObject {</span><span class="s3">\n  </span><span class="s1">if (process.env.BABEL_8_BREAKING) {</span><span class="s3">\n    </span><span class="s1">assertVersion(REQUIRED_VERSION(</span><span class="s3">\&quot;</span><span class="s1">^7.21.0</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">version === </span><span class="s3">\&quot;</span><span class="s1">2023-11</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n      </span><span class="s1">version === </span><span class="s3">\&quot;</span><span class="s1">2023-05</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n      </span><span class="s1">version === </span><span class="s3">\&quot;</span><span class="s1">2023-01</span><span class="s3">\&quot;\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">assertVersion(REQUIRED_VERSION(</span><span class="s3">\&quot;</span><span class="s1">^7.21.0</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n    </span><span class="s1">} else if (version === </span><span class="s3">\&quot;</span><span class="s1">2021-12</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">assertVersion(REQUIRED_VERSION(</span><span class="s3">\&quot;</span><span class="s1">^7.16.0</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">assertVersion(REQUIRED_VERSION(</span><span class="s3">\&quot;</span><span class="s1">^7.19.0</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const VISITED = new WeakSet&lt;NodePath&gt;();</span><span class="s3">\n  </span><span class="s1">const constantSuper = assumption(</span><span class="s3">\&quot;</span><span class="s1">constantSuper</span><span class="s3">\&quot;</span><span class="s1">) ?? loose;</span><span class="s3">\n  </span><span class="s1">const ignoreFunctionLength = assumption(</span><span class="s3">\&quot;</span><span class="s1">ignoreFunctionLength</span><span class="s3">\&quot;</span><span class="s1">) ?? loose;</span><span class="s3">\n\n  </span><span class="s1">const namedEvaluationVisitor: Visitor&lt;PluginPass&gt; =</span><span class="s3">\n    </span><span class="s1">NamedEvaluationVisitoryFactory(</span><span class="s3">\n      </span><span class="s1">isDecoratedAnonymousClassExpression,</span><span class="s3">\n      </span><span class="s1">visitClass,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n\n  </span><span class="s1">function visitClass(</span><span class="s3">\n    </span><span class="s1">path: NodePath&lt;t.Class&gt;,</span><span class="s3">\n    </span><span class="s1">state: PluginPass,</span><span class="s3">\n    </span><span class="s1">className: string | t.Identifier | t.StringLiteral | undefined,</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">if (VISITED.has(path)) return;</span><span class="s3">\n    </span><span class="s1">const { node } = path;</span><span class="s3">\n    </span><span class="s1">className ??= node.id?.name;</span><span class="s3">\n    </span><span class="s1">const newPath = transformClass(</span><span class="s3">\n      </span><span class="s1">path,</span><span class="s3">\n      </span><span class="s1">state,</span><span class="s3">\n      </span><span class="s1">constantSuper,</span><span class="s3">\n      </span><span class="s1">ignoreFunctionLength,</span><span class="s3">\n      </span><span class="s1">className,</span><span class="s3">\n      </span><span class="s1">namedEvaluationVisitor,</span><span class="s3">\n      </span><span class="s1">version,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">if (newPath) {</span><span class="s3">\n      </span><span class="s1">VISITED.add(newPath);</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">VISITED.add(path);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">name: </span><span class="s3">\&quot;</span><span class="s1">proposal-decorators</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">inherits: inherits,</span><span class="s3">\n\n    </span><span class="s1">visitor: {</span><span class="s3">\n      </span><span class="s1">ExportDefaultDeclaration(path, state) {</span><span class="s3">\n        </span><span class="s1">const { declaration } = path.node;</span><span class="s3">\n        </span><span class="s1">if (</span><span class="s3">\n          </span><span class="s1">declaration?.type === </span><span class="s3">\&quot;</span><span class="s1">ClassDeclaration</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n          </span><span class="s1">// When compiling class decorators we need to replace the class</span><span class="s3">\n          </span><span class="s1">// binding, so we must split it in two separate declarations.</span><span class="s3">\n          </span><span class="s1">isDecorated(declaration)</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">const isAnonymous = !declaration.id;</span><span class="s3">\n          </span><span class="s1">if (!process.env.BABEL_8_BREAKING &amp;&amp; !USE_ESM &amp;&amp; !IS_STANDALONE) {</span><span class="s3">\n            </span><span class="s1">// polyfill when being run by an older Babel version</span><span class="s3">\n            </span><span class="s1">path.splitExportDeclaration ??=</span><span class="s3">\n              </span><span class="s1">// eslint-disable-next-line no-restricted-globals</span><span class="s3">\n              </span><span class="s1">require(</span><span class="s3">\&quot;</span><span class="s1">@babel/traverse</span><span class="s3">\&quot;</span><span class="s1">).NodePath.prototype.splitExportDeclaration;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">const updatedVarDeclarationPath =</span><span class="s3">\n            </span><span class="s1">path.splitExportDeclaration() as NodePath&lt;t.ClassDeclaration&gt;;</span><span class="s3">\n          </span><span class="s1">if (isAnonymous) {</span><span class="s3">\n            </span><span class="s1">visitClass(</span><span class="s3">\n              </span><span class="s1">updatedVarDeclarationPath,</span><span class="s3">\n              </span><span class="s1">state,</span><span class="s3">\n              </span><span class="s1">t.stringLiteral(</span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n            </span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">ExportNamedDeclaration(path) {</span><span class="s3">\n        </span><span class="s1">const { declaration } = path.node;</span><span class="s3">\n        </span><span class="s1">if (</span><span class="s3">\n          </span><span class="s1">declaration?.type === </span><span class="s3">\&quot;</span><span class="s1">ClassDeclaration</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n          </span><span class="s1">// When compiling class decorators we need to replace the class</span><span class="s3">\n          </span><span class="s1">// binding, so we must split it in two separate declarations.</span><span class="s3">\n          </span><span class="s1">isDecorated(declaration)</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">if (!process.env.BABEL_8_BREAKING &amp;&amp; !USE_ESM &amp;&amp; !IS_STANDALONE) {</span><span class="s3">\n            </span><span class="s1">// polyfill when being run by an older Babel version</span><span class="s3">\n            </span><span class="s1">path.splitExportDeclaration ??=</span><span class="s3">\n              </span><span class="s1">// eslint-disable-next-line no-restricted-globals</span><span class="s3">\n              </span><span class="s1">require(</span><span class="s3">\&quot;</span><span class="s1">@babel/traverse</span><span class="s3">\&quot;</span><span class="s1">).NodePath.prototype.splitExportDeclaration;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">path.splitExportDeclaration();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n\n      </span><span class="s1">Class(path, state) {</span><span class="s3">\n        </span><span class="s1">visitClass(path, state, undefined);</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n\n      </span><span class="s1">...namedEvaluationVisitor,</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[]}</span></pre>
</body>
</html>