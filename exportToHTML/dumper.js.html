<html>
<head>
<title>dumper.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #6aab73;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #7a7e85;}
.s4 { color: #cf8e6d;}
.s5 { color: #2aacb8;}
.s6 { color: #42c3d4;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
dumper.js</font>
</center></td></tr></table>
<pre><span class="s0">'use strict'</span><span class="s1">;</span>

<span class="s3">/*eslint-disable no-use-before-define*/</span>

<span class="s4">var </span><span class="s2">common              </span><span class="s1">= </span><span class="s2">require</span><span class="s1">(</span><span class="s0">'./common'</span><span class="s1">);</span>
<span class="s4">var </span><span class="s2">YAMLException       </span><span class="s1">= </span><span class="s2">require</span><span class="s1">(</span><span class="s0">'./exception'</span><span class="s1">);</span>
<span class="s4">var </span><span class="s2">DEFAULT_FULL_SCHEMA </span><span class="s1">= </span><span class="s2">require</span><span class="s1">(</span><span class="s0">'./schema/default_full'</span><span class="s1">);</span>
<span class="s4">var </span><span class="s2">DEFAULT_SAFE_SCHEMA </span><span class="s1">= </span><span class="s2">require</span><span class="s1">(</span><span class="s0">'./schema/default_safe'</span><span class="s1">);</span>

<span class="s4">var </span><span class="s2">_toString       </span><span class="s1">= </span><span class="s2">Object</span><span class="s1">.</span><span class="s2">prototype</span><span class="s1">.</span><span class="s2">toString</span><span class="s1">;</span>
<span class="s4">var </span><span class="s2">_hasOwnProperty </span><span class="s1">= </span><span class="s2">Object</span><span class="s1">.</span><span class="s2">prototype</span><span class="s1">.</span><span class="s2">hasOwnProperty</span><span class="s1">;</span>

<span class="s4">var </span><span class="s2">CHAR_TAB                  </span><span class="s1">= </span><span class="s5">0x09</span><span class="s1">; </span><span class="s3">/* Tab */</span>
<span class="s4">var </span><span class="s2">CHAR_LINE_FEED            </span><span class="s1">= </span><span class="s5">0x0A</span><span class="s1">; </span><span class="s3">/* LF */</span>
<span class="s4">var </span><span class="s2">CHAR_CARRIAGE_RETURN      </span><span class="s1">= </span><span class="s5">0x0D</span><span class="s1">; </span><span class="s3">/* CR */</span>
<span class="s4">var </span><span class="s2">CHAR_SPACE                </span><span class="s1">= </span><span class="s5">0x20</span><span class="s1">; </span><span class="s3">/* Space */</span>
<span class="s4">var </span><span class="s2">CHAR_EXCLAMATION          </span><span class="s1">= </span><span class="s5">0x21</span><span class="s1">; </span><span class="s3">/* ! */</span>
<span class="s4">var </span><span class="s2">CHAR_DOUBLE_QUOTE         </span><span class="s1">= </span><span class="s5">0x22</span><span class="s1">; </span><span class="s3">/* &quot; */</span>
<span class="s4">var </span><span class="s2">CHAR_SHARP                </span><span class="s1">= </span><span class="s5">0x23</span><span class="s1">; </span><span class="s3">/* # */</span>
<span class="s4">var </span><span class="s2">CHAR_PERCENT              </span><span class="s1">= </span><span class="s5">0x25</span><span class="s1">; </span><span class="s3">/* % */</span>
<span class="s4">var </span><span class="s2">CHAR_AMPERSAND            </span><span class="s1">= </span><span class="s5">0x26</span><span class="s1">; </span><span class="s3">/* &amp; */</span>
<span class="s4">var </span><span class="s2">CHAR_SINGLE_QUOTE         </span><span class="s1">= </span><span class="s5">0x27</span><span class="s1">; </span><span class="s3">/* ' */</span>
<span class="s4">var </span><span class="s2">CHAR_ASTERISK             </span><span class="s1">= </span><span class="s5">0x2A</span><span class="s1">; </span><span class="s3">/* * */</span>
<span class="s4">var </span><span class="s2">CHAR_COMMA                </span><span class="s1">= </span><span class="s5">0x2C</span><span class="s1">; </span><span class="s3">/* , */</span>
<span class="s4">var </span><span class="s2">CHAR_MINUS                </span><span class="s1">= </span><span class="s5">0x2D</span><span class="s1">; </span><span class="s3">/* - */</span>
<span class="s4">var </span><span class="s2">CHAR_COLON                </span><span class="s1">= </span><span class="s5">0x3A</span><span class="s1">; </span><span class="s3">/* : */</span>
<span class="s4">var </span><span class="s2">CHAR_EQUALS               </span><span class="s1">= </span><span class="s5">0x3D</span><span class="s1">; </span><span class="s3">/* = */</span>
<span class="s4">var </span><span class="s2">CHAR_GREATER_THAN         </span><span class="s1">= </span><span class="s5">0x3E</span><span class="s1">; </span><span class="s3">/* &gt; */</span>
<span class="s4">var </span><span class="s2">CHAR_QUESTION             </span><span class="s1">= </span><span class="s5">0x3F</span><span class="s1">; </span><span class="s3">/* ? */</span>
<span class="s4">var </span><span class="s2">CHAR_COMMERCIAL_AT        </span><span class="s1">= </span><span class="s5">0x40</span><span class="s1">; </span><span class="s3">/* @ */</span>
<span class="s4">var </span><span class="s2">CHAR_LEFT_SQUARE_BRACKET  </span><span class="s1">= </span><span class="s5">0x5B</span><span class="s1">; </span><span class="s3">/* [ */</span>
<span class="s4">var </span><span class="s2">CHAR_RIGHT_SQUARE_BRACKET </span><span class="s1">= </span><span class="s5">0x5D</span><span class="s1">; </span><span class="s3">/* ] */</span>
<span class="s4">var </span><span class="s2">CHAR_GRAVE_ACCENT         </span><span class="s1">= </span><span class="s5">0x60</span><span class="s1">; </span><span class="s3">/* ` */</span>
<span class="s4">var </span><span class="s2">CHAR_LEFT_CURLY_BRACKET   </span><span class="s1">= </span><span class="s5">0x7B</span><span class="s1">; </span><span class="s3">/* { */</span>
<span class="s4">var </span><span class="s2">CHAR_VERTICAL_LINE        </span><span class="s1">= </span><span class="s5">0x7C</span><span class="s1">; </span><span class="s3">/* | */</span>
<span class="s4">var </span><span class="s2">CHAR_RIGHT_CURLY_BRACKET  </span><span class="s1">= </span><span class="s5">0x7D</span><span class="s1">; </span><span class="s3">/* } */</span>

<span class="s4">var </span><span class="s2">ESCAPE_SEQUENCES </span><span class="s1">= {};</span>

<span class="s2">ESCAPE_SEQUENCES</span><span class="s1">[</span><span class="s5">0x00</span><span class="s1">]   = </span><span class="s0">'</span><span class="s4">\\</span><span class="s0">0'</span><span class="s1">;</span>
<span class="s2">ESCAPE_SEQUENCES</span><span class="s1">[</span><span class="s5">0x07</span><span class="s1">]   = </span><span class="s0">'</span><span class="s4">\\</span><span class="s0">a'</span><span class="s1">;</span>
<span class="s2">ESCAPE_SEQUENCES</span><span class="s1">[</span><span class="s5">0x08</span><span class="s1">]   = </span><span class="s0">'</span><span class="s4">\\</span><span class="s0">b'</span><span class="s1">;</span>
<span class="s2">ESCAPE_SEQUENCES</span><span class="s1">[</span><span class="s5">0x09</span><span class="s1">]   = </span><span class="s0">'</span><span class="s4">\\</span><span class="s0">t'</span><span class="s1">;</span>
<span class="s2">ESCAPE_SEQUENCES</span><span class="s1">[</span><span class="s5">0x0A</span><span class="s1">]   = </span><span class="s0">'</span><span class="s4">\\</span><span class="s0">n'</span><span class="s1">;</span>
<span class="s2">ESCAPE_SEQUENCES</span><span class="s1">[</span><span class="s5">0x0B</span><span class="s1">]   = </span><span class="s0">'</span><span class="s4">\\</span><span class="s0">v'</span><span class="s1">;</span>
<span class="s2">ESCAPE_SEQUENCES</span><span class="s1">[</span><span class="s5">0x0C</span><span class="s1">]   = </span><span class="s0">'</span><span class="s4">\\</span><span class="s0">f'</span><span class="s1">;</span>
<span class="s2">ESCAPE_SEQUENCES</span><span class="s1">[</span><span class="s5">0x0D</span><span class="s1">]   = </span><span class="s0">'</span><span class="s4">\\</span><span class="s0">r'</span><span class="s1">;</span>
<span class="s2">ESCAPE_SEQUENCES</span><span class="s1">[</span><span class="s5">0x1B</span><span class="s1">]   = </span><span class="s0">'</span><span class="s4">\\</span><span class="s0">e'</span><span class="s1">;</span>
<span class="s2">ESCAPE_SEQUENCES</span><span class="s1">[</span><span class="s5">0x22</span><span class="s1">]   = </span><span class="s0">'</span><span class="s4">\\</span><span class="s0">&quot;'</span><span class="s1">;</span>
<span class="s2">ESCAPE_SEQUENCES</span><span class="s1">[</span><span class="s5">0x5C</span><span class="s1">]   = </span><span class="s0">'</span><span class="s4">\\\\</span><span class="s0">'</span><span class="s1">;</span>
<span class="s2">ESCAPE_SEQUENCES</span><span class="s1">[</span><span class="s5">0x85</span><span class="s1">]   = </span><span class="s0">'</span><span class="s4">\\</span><span class="s0">N'</span><span class="s1">;</span>
<span class="s2">ESCAPE_SEQUENCES</span><span class="s1">[</span><span class="s5">0xA0</span><span class="s1">]   = </span><span class="s0">'</span><span class="s4">\\</span><span class="s0">_'</span><span class="s1">;</span>
<span class="s2">ESCAPE_SEQUENCES</span><span class="s1">[</span><span class="s5">0x2028</span><span class="s1">] = </span><span class="s0">'</span><span class="s4">\\</span><span class="s0">L'</span><span class="s1">;</span>
<span class="s2">ESCAPE_SEQUENCES</span><span class="s1">[</span><span class="s5">0x2029</span><span class="s1">] = </span><span class="s0">'</span><span class="s4">\\</span><span class="s0">P'</span><span class="s1">;</span>

<span class="s4">var </span><span class="s2">DEPRECATED_BOOLEANS_SYNTAX </span><span class="s1">= [</span>
  <span class="s0">'y'</span><span class="s1">, </span><span class="s0">'Y'</span><span class="s1">, </span><span class="s0">'yes'</span><span class="s1">, </span><span class="s0">'Yes'</span><span class="s1">, </span><span class="s0">'YES'</span><span class="s1">, </span><span class="s0">'on'</span><span class="s1">, </span><span class="s0">'On'</span><span class="s1">, </span><span class="s0">'ON'</span><span class="s1">,</span>
  <span class="s0">'n'</span><span class="s1">, </span><span class="s0">'N'</span><span class="s1">, </span><span class="s0">'no'</span><span class="s1">, </span><span class="s0">'No'</span><span class="s1">, </span><span class="s0">'NO'</span><span class="s1">, </span><span class="s0">'off'</span><span class="s1">, </span><span class="s0">'Off'</span><span class="s1">, </span><span class="s0">'OFF'</span>
<span class="s1">];</span>

<span class="s4">function </span><span class="s2">compileStyleMap</span><span class="s1">(</span><span class="s2">schema</span><span class="s1">, </span><span class="s2">map</span><span class="s1">) {</span>
  <span class="s4">var </span><span class="s2">result</span><span class="s1">, </span><span class="s2">keys</span><span class="s1">, </span><span class="s2">index</span><span class="s1">, </span><span class="s2">length</span><span class="s1">, </span><span class="s2">tag</span><span class="s1">, </span><span class="s2">style</span><span class="s1">, </span><span class="s2">type</span><span class="s1">;</span>

  <span class="s4">if </span><span class="s1">(</span><span class="s2">map </span><span class="s1">=== </span><span class="s4">null</span><span class="s1">) </span><span class="s4">return </span><span class="s1">{};</span>

  <span class="s2">result </span><span class="s1">= {};</span>
  <span class="s2">keys </span><span class="s1">= </span><span class="s2">Object</span><span class="s1">.</span><span class="s2">keys</span><span class="s1">(</span><span class="s2">map</span><span class="s1">);</span>

  <span class="s4">for </span><span class="s1">(</span><span class="s2">index </span><span class="s1">= </span><span class="s5">0</span><span class="s1">, </span><span class="s2">length </span><span class="s1">= </span><span class="s2">keys</span><span class="s1">.</span><span class="s2">length</span><span class="s1">; </span><span class="s2">index </span><span class="s1">&lt; </span><span class="s2">length</span><span class="s1">; </span><span class="s2">index </span><span class="s1">+= </span><span class="s5">1</span><span class="s1">) {</span>
    <span class="s2">tag </span><span class="s1">= </span><span class="s2">keys</span><span class="s1">[</span><span class="s2">index</span><span class="s1">];</span>
    <span class="s2">style </span><span class="s1">= </span><span class="s2">String</span><span class="s1">(</span><span class="s2">map</span><span class="s1">[</span><span class="s2">tag</span><span class="s1">]);</span>

    <span class="s4">if </span><span class="s1">(</span><span class="s2">tag</span><span class="s1">.</span><span class="s2">slice</span><span class="s1">(</span><span class="s5">0</span><span class="s1">, </span><span class="s5">2</span><span class="s1">) === </span><span class="s0">'!!'</span><span class="s1">) {</span>
      <span class="s2">tag </span><span class="s1">= </span><span class="s0">'tag:yaml.org,2002:' </span><span class="s1">+ </span><span class="s2">tag</span><span class="s1">.</span><span class="s2">slice</span><span class="s1">(</span><span class="s5">2</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">type </span><span class="s1">= </span><span class="s2">schema</span><span class="s1">.</span><span class="s2">compiledTypeMap</span><span class="s1">[</span><span class="s0">'fallback'</span><span class="s1">][</span><span class="s2">tag</span><span class="s1">];</span>

    <span class="s4">if </span><span class="s1">(</span><span class="s2">type </span><span class="s1">&amp;&amp; </span><span class="s2">_hasOwnProperty</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s2">type</span><span class="s1">.</span><span class="s2">styleAliases</span><span class="s1">, </span><span class="s2">style</span><span class="s1">)) {</span>
      <span class="s2">style </span><span class="s1">= </span><span class="s2">type</span><span class="s1">.</span><span class="s2">styleAliases</span><span class="s1">[</span><span class="s2">style</span><span class="s1">];</span>
    <span class="s1">}</span>

    <span class="s2">result</span><span class="s1">[</span><span class="s2">tag</span><span class="s1">] = </span><span class="s2">style</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s4">return </span><span class="s2">result</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s4">function </span><span class="s2">encodeHex</span><span class="s1">(</span><span class="s2">character</span><span class="s1">) {</span>
  <span class="s4">var </span><span class="s2">string</span><span class="s1">, </span><span class="s2">handle</span><span class="s1">, </span><span class="s2">length</span><span class="s1">;</span>

  <span class="s2">string </span><span class="s1">= </span><span class="s2">character</span><span class="s1">.</span><span class="s2">toString</span><span class="s1">(</span><span class="s5">16</span><span class="s1">).</span><span class="s2">toUpperCase</span><span class="s1">();</span>

  <span class="s4">if </span><span class="s1">(</span><span class="s2">character </span><span class="s1">&lt;= </span><span class="s5">0xFF</span><span class="s1">) {</span>
    <span class="s2">handle </span><span class="s1">= </span><span class="s0">'x'</span><span class="s1">;</span>
    <span class="s2">length </span><span class="s1">= </span><span class="s5">2</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s4">else if </span><span class="s1">(</span><span class="s2">character </span><span class="s1">&lt;= </span><span class="s5">0xFFFF</span><span class="s1">) {</span>
    <span class="s2">handle </span><span class="s1">= </span><span class="s0">'u'</span><span class="s1">;</span>
    <span class="s2">length </span><span class="s1">= </span><span class="s5">4</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s4">else if </span><span class="s1">(</span><span class="s2">character </span><span class="s1">&lt;= </span><span class="s5">0xFFFFFFFF</span><span class="s1">) {</span>
    <span class="s2">handle </span><span class="s1">= </span><span class="s0">'U'</span><span class="s1">;</span>
    <span class="s2">length </span><span class="s1">= </span><span class="s5">8</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
    <span class="s4">throw new </span><span class="s2">YAMLException</span><span class="s1">(</span><span class="s0">'code point within a string may not be greater than 0xFFFFFFFF'</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s4">return </span><span class="s0">'</span><span class="s4">\\</span><span class="s0">' </span><span class="s1">+ </span><span class="s2">handle </span><span class="s1">+ </span><span class="s2">common</span><span class="s1">.</span><span class="s2">repeat</span><span class="s1">(</span><span class="s0">'0'</span><span class="s1">, </span><span class="s2">length </span><span class="s1">- </span><span class="s2">string</span><span class="s1">.</span><span class="s2">length</span><span class="s1">) + </span><span class="s2">string</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s4">function </span><span class="s2">State</span><span class="s1">(</span><span class="s2">options</span><span class="s1">) {</span>
  <span class="s4">this</span><span class="s1">.</span><span class="s2">schema        </span><span class="s1">= </span><span class="s2">options</span><span class="s1">[</span><span class="s0">'schema'</span><span class="s1">] || </span><span class="s2">DEFAULT_FULL_SCHEMA</span><span class="s1">;</span>
  <span class="s4">this</span><span class="s1">.</span><span class="s2">indent        </span><span class="s1">= </span><span class="s2">Math</span><span class="s1">.</span><span class="s2">max</span><span class="s1">(</span><span class="s5">1</span><span class="s1">, (</span><span class="s2">options</span><span class="s1">[</span><span class="s0">'indent'</span><span class="s1">] || </span><span class="s5">2</span><span class="s1">));</span>
  <span class="s4">this</span><span class="s1">.</span><span class="s2">noArrayIndent </span><span class="s1">= </span><span class="s2">options</span><span class="s1">[</span><span class="s0">'noArrayIndent'</span><span class="s1">] || </span><span class="s4">false</span><span class="s1">;</span>
  <span class="s4">this</span><span class="s1">.</span><span class="s2">skipInvalid   </span><span class="s1">= </span><span class="s2">options</span><span class="s1">[</span><span class="s0">'skipInvalid'</span><span class="s1">] || </span><span class="s4">false</span><span class="s1">;</span>
  <span class="s4">this</span><span class="s1">.</span><span class="s2">flowLevel     </span><span class="s1">= (</span><span class="s2">common</span><span class="s1">.</span><span class="s2">isNothing</span><span class="s1">(</span><span class="s2">options</span><span class="s1">[</span><span class="s0">'flowLevel'</span><span class="s1">]) ? -</span><span class="s5">1 </span><span class="s1">: </span><span class="s2">options</span><span class="s1">[</span><span class="s0">'flowLevel'</span><span class="s1">]);</span>
  <span class="s4">this</span><span class="s1">.</span><span class="s2">styleMap      </span><span class="s1">= </span><span class="s2">compileStyleMap</span><span class="s1">(</span><span class="s4">this</span><span class="s1">.</span><span class="s2">schema</span><span class="s1">, </span><span class="s2">options</span><span class="s1">[</span><span class="s0">'styles'</span><span class="s1">] || </span><span class="s4">null</span><span class="s1">);</span>
  <span class="s4">this</span><span class="s1">.</span><span class="s2">sortKeys      </span><span class="s1">= </span><span class="s2">options</span><span class="s1">[</span><span class="s0">'sortKeys'</span><span class="s1">] || </span><span class="s4">false</span><span class="s1">;</span>
  <span class="s4">this</span><span class="s1">.</span><span class="s2">lineWidth     </span><span class="s1">= </span><span class="s2">options</span><span class="s1">[</span><span class="s0">'lineWidth'</span><span class="s1">] || </span><span class="s5">80</span><span class="s1">;</span>
  <span class="s4">this</span><span class="s1">.</span><span class="s2">noRefs        </span><span class="s1">= </span><span class="s2">options</span><span class="s1">[</span><span class="s0">'noRefs'</span><span class="s1">] || </span><span class="s4">false</span><span class="s1">;</span>
  <span class="s4">this</span><span class="s1">.</span><span class="s2">noCompatMode  </span><span class="s1">= </span><span class="s2">options</span><span class="s1">[</span><span class="s0">'noCompatMode'</span><span class="s1">] || </span><span class="s4">false</span><span class="s1">;</span>
  <span class="s4">this</span><span class="s1">.</span><span class="s2">condenseFlow  </span><span class="s1">= </span><span class="s2">options</span><span class="s1">[</span><span class="s0">'condenseFlow'</span><span class="s1">] || </span><span class="s4">false</span><span class="s1">;</span>

  <span class="s4">this</span><span class="s1">.</span><span class="s2">implicitTypes </span><span class="s1">= </span><span class="s4">this</span><span class="s1">.</span><span class="s2">schema</span><span class="s1">.</span><span class="s2">compiledImplicit</span><span class="s1">;</span>
  <span class="s4">this</span><span class="s1">.</span><span class="s2">explicitTypes </span><span class="s1">= </span><span class="s4">this</span><span class="s1">.</span><span class="s2">schema</span><span class="s1">.</span><span class="s2">compiledExplicit</span><span class="s1">;</span>

  <span class="s4">this</span><span class="s1">.</span><span class="s2">tag </span><span class="s1">= </span><span class="s4">null</span><span class="s1">;</span>
  <span class="s4">this</span><span class="s1">.</span><span class="s2">result </span><span class="s1">= </span><span class="s0">''</span><span class="s1">;</span>

  <span class="s4">this</span><span class="s1">.</span><span class="s2">duplicates </span><span class="s1">= [];</span>
  <span class="s4">this</span><span class="s1">.</span><span class="s2">usedDuplicates </span><span class="s1">= </span><span class="s4">null</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">// Indents every line in a string. Empty lines (\n only) are not indented.</span>
<span class="s4">function </span><span class="s2">indentString</span><span class="s1">(</span><span class="s2">string</span><span class="s1">, </span><span class="s2">spaces</span><span class="s1">) {</span>
  <span class="s4">var </span><span class="s2">ind </span><span class="s1">= </span><span class="s2">common</span><span class="s1">.</span><span class="s2">repeat</span><span class="s1">(</span><span class="s0">' '</span><span class="s1">, </span><span class="s2">spaces</span><span class="s1">),</span>
      <span class="s2">position </span><span class="s1">= </span><span class="s5">0</span><span class="s1">,</span>
      <span class="s2">next </span><span class="s1">= -</span><span class="s5">1</span><span class="s1">,</span>
      <span class="s2">result </span><span class="s1">= </span><span class="s0">''</span><span class="s1">,</span>
      <span class="s2">line</span><span class="s1">,</span>
      <span class="s2">length </span><span class="s1">= </span><span class="s2">string</span><span class="s1">.</span><span class="s2">length</span><span class="s1">;</span>

  <span class="s4">while </span><span class="s1">(</span><span class="s2">position </span><span class="s1">&lt; </span><span class="s2">length</span><span class="s1">) {</span>
    <span class="s2">next </span><span class="s1">= </span><span class="s2">string</span><span class="s1">.</span><span class="s2">indexOf</span><span class="s1">(</span><span class="s0">'</span><span class="s4">\n</span><span class="s0">'</span><span class="s1">, </span><span class="s2">position</span><span class="s1">);</span>
    <span class="s4">if </span><span class="s1">(</span><span class="s2">next </span><span class="s1">=== -</span><span class="s5">1</span><span class="s1">) {</span>
      <span class="s2">line </span><span class="s1">= </span><span class="s2">string</span><span class="s1">.</span><span class="s2">slice</span><span class="s1">(</span><span class="s2">position</span><span class="s1">);</span>
      <span class="s2">position </span><span class="s1">= </span><span class="s2">length</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
      <span class="s2">line </span><span class="s1">= </span><span class="s2">string</span><span class="s1">.</span><span class="s2">slice</span><span class="s1">(</span><span class="s2">position</span><span class="s1">, </span><span class="s2">next </span><span class="s1">+ </span><span class="s5">1</span><span class="s1">);</span>
      <span class="s2">position </span><span class="s1">= </span><span class="s2">next </span><span class="s1">+ </span><span class="s5">1</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s4">if </span><span class="s1">(</span><span class="s2">line</span><span class="s1">.</span><span class="s2">length </span><span class="s1">&amp;&amp; </span><span class="s2">line </span><span class="s1">!== </span><span class="s0">'</span><span class="s4">\n</span><span class="s0">'</span><span class="s1">) </span><span class="s2">result </span><span class="s1">+= </span><span class="s2">ind</span><span class="s1">;</span>

    <span class="s2">result </span><span class="s1">+= </span><span class="s2">line</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s4">return </span><span class="s2">result</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s4">function </span><span class="s2">generateNextLine</span><span class="s1">(</span><span class="s2">state</span><span class="s1">, </span><span class="s2">level</span><span class="s1">) {</span>
  <span class="s4">return </span><span class="s0">'</span><span class="s4">\n</span><span class="s0">' </span><span class="s1">+ </span><span class="s2">common</span><span class="s1">.</span><span class="s2">repeat</span><span class="s1">(</span><span class="s0">' '</span><span class="s1">, </span><span class="s2">state</span><span class="s1">.</span><span class="s2">indent </span><span class="s1">* </span><span class="s2">level</span><span class="s1">);</span>
<span class="s1">}</span>

<span class="s4">function </span><span class="s2">testImplicitResolving</span><span class="s1">(</span><span class="s2">state</span><span class="s1">, </span><span class="s2">str</span><span class="s1">) {</span>
  <span class="s4">var </span><span class="s2">index</span><span class="s1">, </span><span class="s2">length</span><span class="s1">, </span><span class="s2">type</span><span class="s1">;</span>

  <span class="s4">for </span><span class="s1">(</span><span class="s2">index </span><span class="s1">= </span><span class="s5">0</span><span class="s1">, </span><span class="s2">length </span><span class="s1">= </span><span class="s2">state</span><span class="s1">.</span><span class="s2">implicitTypes</span><span class="s1">.</span><span class="s2">length</span><span class="s1">; </span><span class="s2">index </span><span class="s1">&lt; </span><span class="s2">length</span><span class="s1">; </span><span class="s2">index </span><span class="s1">+= </span><span class="s5">1</span><span class="s1">) {</span>
    <span class="s2">type </span><span class="s1">= </span><span class="s2">state</span><span class="s1">.</span><span class="s2">implicitTypes</span><span class="s1">[</span><span class="s2">index</span><span class="s1">];</span>

    <span class="s4">if </span><span class="s1">(</span><span class="s2">type</span><span class="s1">.</span><span class="s2">resolve</span><span class="s1">(</span><span class="s2">str</span><span class="s1">)) {</span>
      <span class="s4">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s4">return false</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">// [33] s-white ::= s-space | s-tab</span>
<span class="s4">function </span><span class="s2">isWhitespace</span><span class="s1">(</span><span class="s2">c</span><span class="s1">) {</span>
  <span class="s4">return </span><span class="s2">c </span><span class="s1">=== </span><span class="s2">CHAR_SPACE </span><span class="s1">|| </span><span class="s2">c </span><span class="s1">=== </span><span class="s2">CHAR_TAB</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">// Returns true if the character can be printed without escaping.</span>
<span class="s3">// From YAML 1.2: &quot;any allowed characters known to be non-printable</span>
<span class="s3">// should also be escaped. [However,] This isn’t mandatory&quot;</span>
<span class="s3">// Derived from nb-char - \t - #x85 - #xA0 - #x2028 - #x2029.</span>
<span class="s4">function </span><span class="s2">isPrintable</span><span class="s1">(</span><span class="s2">c</span><span class="s1">) {</span>
  <span class="s4">return  </span><span class="s1">(</span><span class="s5">0x00020 </span><span class="s1">&lt;= </span><span class="s2">c </span><span class="s1">&amp;&amp; </span><span class="s2">c </span><span class="s1">&lt;= </span><span class="s5">0x00007E</span><span class="s1">)</span>
      <span class="s1">|| ((</span><span class="s5">0x000A1 </span><span class="s1">&lt;= </span><span class="s2">c </span><span class="s1">&amp;&amp; </span><span class="s2">c </span><span class="s1">&lt;= </span><span class="s5">0x00D7FF</span><span class="s1">) &amp;&amp; </span><span class="s2">c </span><span class="s1">!== </span><span class="s5">0x2028 </span><span class="s1">&amp;&amp; </span><span class="s2">c </span><span class="s1">!== </span><span class="s5">0x2029</span><span class="s1">)</span>
      <span class="s1">|| ((</span><span class="s5">0x0E000 </span><span class="s1">&lt;= </span><span class="s2">c </span><span class="s1">&amp;&amp; </span><span class="s2">c </span><span class="s1">&lt;= </span><span class="s5">0x00FFFD</span><span class="s1">) &amp;&amp; </span><span class="s2">c </span><span class="s1">!== </span><span class="s5">0xFEFF </span><span class="s3">/* BOM */</span><span class="s1">)</span>
      <span class="s1">||  (</span><span class="s5">0x10000 </span><span class="s1">&lt;= </span><span class="s2">c </span><span class="s1">&amp;&amp; </span><span class="s2">c </span><span class="s1">&lt;= </span><span class="s5">0x10FFFF</span><span class="s1">);</span>
<span class="s1">}</span>

<span class="s3">// [34] ns-char ::= nb-char - s-white</span>
<span class="s3">// [27] nb-char ::= c-printable - b-char - c-byte-order-mark</span>
<span class="s3">// [26] b-char  ::= b-line-feed | b-carriage-return</span>
<span class="s3">// [24] b-line-feed       ::=     #xA    /* LF */</span>
<span class="s3">// [25] b-carriage-return ::=     #xD    /* CR */</span>
<span class="s3">// [3]  c-byte-order-mark ::=     #xFEFF</span>
<span class="s4">function </span><span class="s2">isNsChar</span><span class="s1">(</span><span class="s2">c</span><span class="s1">) {</span>
  <span class="s4">return </span><span class="s2">isPrintable</span><span class="s1">(</span><span class="s2">c</span><span class="s1">) &amp;&amp; !</span><span class="s2">isWhitespace</span><span class="s1">(</span><span class="s2">c</span><span class="s1">)</span>
    <span class="s3">// byte-order-mark</span>
    <span class="s1">&amp;&amp; </span><span class="s2">c </span><span class="s1">!== </span><span class="s5">0xFEFF</span>
    <span class="s3">// b-char</span>
    <span class="s1">&amp;&amp; </span><span class="s2">c </span><span class="s1">!== </span><span class="s2">CHAR_CARRIAGE_RETURN</span>
    <span class="s1">&amp;&amp; </span><span class="s2">c </span><span class="s1">!== </span><span class="s2">CHAR_LINE_FEED</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">// Simplified test for values allowed after the first character in plain style.</span>
<span class="s4">function </span><span class="s2">isPlainSafe</span><span class="s1">(</span><span class="s2">c</span><span class="s1">, </span><span class="s2">prev</span><span class="s1">) {</span>
  <span class="s3">// Uses a subset of nb-char - c-flow-indicator - &quot;:&quot; - &quot;#&quot;</span>
  <span class="s3">// where nb-char ::= c-printable - b-char - c-byte-order-mark.</span>
  <span class="s4">return </span><span class="s2">isPrintable</span><span class="s1">(</span><span class="s2">c</span><span class="s1">) &amp;&amp; </span><span class="s2">c </span><span class="s1">!== </span><span class="s5">0xFEFF</span>
    <span class="s3">// - c-flow-indicator</span>
    <span class="s1">&amp;&amp; </span><span class="s2">c </span><span class="s1">!== </span><span class="s2">CHAR_COMMA</span>
    <span class="s1">&amp;&amp; </span><span class="s2">c </span><span class="s1">!== </span><span class="s2">CHAR_LEFT_SQUARE_BRACKET</span>
    <span class="s1">&amp;&amp; </span><span class="s2">c </span><span class="s1">!== </span><span class="s2">CHAR_RIGHT_SQUARE_BRACKET</span>
    <span class="s1">&amp;&amp; </span><span class="s2">c </span><span class="s1">!== </span><span class="s2">CHAR_LEFT_CURLY_BRACKET</span>
    <span class="s1">&amp;&amp; </span><span class="s2">c </span><span class="s1">!== </span><span class="s2">CHAR_RIGHT_CURLY_BRACKET</span>
    <span class="s3">// - &quot;:&quot; - &quot;#&quot;</span>
    <span class="s3">// /* An ns-char preceding */ &quot;#&quot;</span>
    <span class="s1">&amp;&amp; </span><span class="s2">c </span><span class="s1">!== </span><span class="s2">CHAR_COLON</span>
    <span class="s1">&amp;&amp; ((</span><span class="s2">c </span><span class="s1">!== </span><span class="s2">CHAR_SHARP</span><span class="s1">) || (</span><span class="s2">prev </span><span class="s1">&amp;&amp; </span><span class="s2">isNsChar</span><span class="s1">(</span><span class="s2">prev</span><span class="s1">)));</span>
<span class="s1">}</span>

<span class="s3">// Simplified test for values allowed as the first character in plain style.</span>
<span class="s4">function </span><span class="s2">isPlainSafeFirst</span><span class="s1">(</span><span class="s2">c</span><span class="s1">) {</span>
  <span class="s3">// Uses a subset of ns-char - c-indicator</span>
  <span class="s3">// where ns-char = nb-char - s-white.</span>
  <span class="s4">return </span><span class="s2">isPrintable</span><span class="s1">(</span><span class="s2">c</span><span class="s1">) &amp;&amp; </span><span class="s2">c </span><span class="s1">!== </span><span class="s5">0xFEFF</span>
    <span class="s1">&amp;&amp; !</span><span class="s2">isWhitespace</span><span class="s1">(</span><span class="s2">c</span><span class="s1">) </span><span class="s3">// - s-white</span>
    <span class="s3">// - (c-indicator ::=</span>
    <span class="s3">// “-” | “?” | “:” | “,” | “[” | “]” | “{” | “}”</span>
    <span class="s1">&amp;&amp; </span><span class="s2">c </span><span class="s1">!== </span><span class="s2">CHAR_MINUS</span>
    <span class="s1">&amp;&amp; </span><span class="s2">c </span><span class="s1">!== </span><span class="s2">CHAR_QUESTION</span>
    <span class="s1">&amp;&amp; </span><span class="s2">c </span><span class="s1">!== </span><span class="s2">CHAR_COLON</span>
    <span class="s1">&amp;&amp; </span><span class="s2">c </span><span class="s1">!== </span><span class="s2">CHAR_COMMA</span>
    <span class="s1">&amp;&amp; </span><span class="s2">c </span><span class="s1">!== </span><span class="s2">CHAR_LEFT_SQUARE_BRACKET</span>
    <span class="s1">&amp;&amp; </span><span class="s2">c </span><span class="s1">!== </span><span class="s2">CHAR_RIGHT_SQUARE_BRACKET</span>
    <span class="s1">&amp;&amp; </span><span class="s2">c </span><span class="s1">!== </span><span class="s2">CHAR_LEFT_CURLY_BRACKET</span>
    <span class="s1">&amp;&amp; </span><span class="s2">c </span><span class="s1">!== </span><span class="s2">CHAR_RIGHT_CURLY_BRACKET</span>
    <span class="s3">// | “#” | “&amp;” | “*” | “!” | “|” | “=” | “&gt;” | “'” | “&quot;”</span>
    <span class="s1">&amp;&amp; </span><span class="s2">c </span><span class="s1">!== </span><span class="s2">CHAR_SHARP</span>
    <span class="s1">&amp;&amp; </span><span class="s2">c </span><span class="s1">!== </span><span class="s2">CHAR_AMPERSAND</span>
    <span class="s1">&amp;&amp; </span><span class="s2">c </span><span class="s1">!== </span><span class="s2">CHAR_ASTERISK</span>
    <span class="s1">&amp;&amp; </span><span class="s2">c </span><span class="s1">!== </span><span class="s2">CHAR_EXCLAMATION</span>
    <span class="s1">&amp;&amp; </span><span class="s2">c </span><span class="s1">!== </span><span class="s2">CHAR_VERTICAL_LINE</span>
    <span class="s1">&amp;&amp; </span><span class="s2">c </span><span class="s1">!== </span><span class="s2">CHAR_EQUALS</span>
    <span class="s1">&amp;&amp; </span><span class="s2">c </span><span class="s1">!== </span><span class="s2">CHAR_GREATER_THAN</span>
    <span class="s1">&amp;&amp; </span><span class="s2">c </span><span class="s1">!== </span><span class="s2">CHAR_SINGLE_QUOTE</span>
    <span class="s1">&amp;&amp; </span><span class="s2">c </span><span class="s1">!== </span><span class="s2">CHAR_DOUBLE_QUOTE</span>
    <span class="s3">// | “%” | “@” | “`”)</span>
    <span class="s1">&amp;&amp; </span><span class="s2">c </span><span class="s1">!== </span><span class="s2">CHAR_PERCENT</span>
    <span class="s1">&amp;&amp; </span><span class="s2">c </span><span class="s1">!== </span><span class="s2">CHAR_COMMERCIAL_AT</span>
    <span class="s1">&amp;&amp; </span><span class="s2">c </span><span class="s1">!== </span><span class="s2">CHAR_GRAVE_ACCENT</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">// Determines whether block indentation indicator is required.</span>
<span class="s4">function </span><span class="s2">needIndentIndicator</span><span class="s1">(</span><span class="s2">string</span><span class="s1">) {</span>
  <span class="s4">var </span><span class="s2">leadingSpaceRe </span><span class="s1">= </span><span class="s6">/^\n* /</span><span class="s1">;</span>
  <span class="s4">return </span><span class="s2">leadingSpaceRe</span><span class="s1">.</span><span class="s2">test</span><span class="s1">(</span><span class="s2">string</span><span class="s1">);</span>
<span class="s1">}</span>

<span class="s4">var </span><span class="s2">STYLE_PLAIN   </span><span class="s1">= </span><span class="s5">1</span><span class="s1">,</span>
    <span class="s2">STYLE_SINGLE  </span><span class="s1">= </span><span class="s5">2</span><span class="s1">,</span>
    <span class="s2">STYLE_LITERAL </span><span class="s1">= </span><span class="s5">3</span><span class="s1">,</span>
    <span class="s2">STYLE_FOLDED  </span><span class="s1">= </span><span class="s5">4</span><span class="s1">,</span>
    <span class="s2">STYLE_DOUBLE  </span><span class="s1">= </span><span class="s5">5</span><span class="s1">;</span>

<span class="s3">// Determines which scalar styles are possible and returns the preferred style.</span>
<span class="s3">// lineWidth = -1 =&gt; no limit.</span>
<span class="s3">// Pre-conditions: str.length &gt; 0.</span>
<span class="s3">// Post-conditions:</span>
<span class="s3">//    STYLE_PLAIN or STYLE_SINGLE =&gt; no \n are in the string.</span>
<span class="s3">//    STYLE_LITERAL =&gt; no lines are suitable for folding (or lineWidth is -1).</span>
<span class="s3">//    STYLE_FOLDED =&gt; a line &gt; lineWidth and can be folded (and lineWidth != -1).</span>
<span class="s4">function </span><span class="s2">chooseScalarStyle</span><span class="s1">(</span><span class="s2">string</span><span class="s1">, </span><span class="s2">singleLineOnly</span><span class="s1">, </span><span class="s2">indentPerLevel</span><span class="s1">, </span><span class="s2">lineWidth</span><span class="s1">, </span><span class="s2">testAmbiguousType</span><span class="s1">) {</span>
  <span class="s4">var </span><span class="s2">i</span><span class="s1">;</span>
  <span class="s4">var </span><span class="s2">char</span><span class="s1">, </span><span class="s2">prev_char</span><span class="s1">;</span>
  <span class="s4">var </span><span class="s2">hasLineBreak </span><span class="s1">= </span><span class="s4">false</span><span class="s1">;</span>
  <span class="s4">var </span><span class="s2">hasFoldableLine </span><span class="s1">= </span><span class="s4">false</span><span class="s1">; </span><span class="s3">// only checked if shouldTrackWidth</span>
  <span class="s4">var </span><span class="s2">shouldTrackWidth </span><span class="s1">= </span><span class="s2">lineWidth </span><span class="s1">!== -</span><span class="s5">1</span><span class="s1">;</span>
  <span class="s4">var </span><span class="s2">previousLineBreak </span><span class="s1">= -</span><span class="s5">1</span><span class="s1">; </span><span class="s3">// count the first line correctly</span>
  <span class="s4">var </span><span class="s2">plain </span><span class="s1">= </span><span class="s2">isPlainSafeFirst</span><span class="s1">(</span><span class="s2">string</span><span class="s1">.</span><span class="s2">charCodeAt</span><span class="s1">(</span><span class="s5">0</span><span class="s1">))</span>
          <span class="s1">&amp;&amp; !</span><span class="s2">isWhitespace</span><span class="s1">(</span><span class="s2">string</span><span class="s1">.</span><span class="s2">charCodeAt</span><span class="s1">(</span><span class="s2">string</span><span class="s1">.</span><span class="s2">length </span><span class="s1">- </span><span class="s5">1</span><span class="s1">));</span>

  <span class="s4">if </span><span class="s1">(</span><span class="s2">singleLineOnly</span><span class="s1">) {</span>
    <span class="s3">// Case: no block styles.</span>
    <span class="s3">// Check for disallowed characters to rule out plain and single.</span>
    <span class="s4">for </span><span class="s1">(</span><span class="s2">i </span><span class="s1">= </span><span class="s5">0</span><span class="s1">; </span><span class="s2">i </span><span class="s1">&lt; </span><span class="s2">string</span><span class="s1">.</span><span class="s2">length</span><span class="s1">; </span><span class="s2">i</span><span class="s1">++) {</span>
      <span class="s2">char </span><span class="s1">= </span><span class="s2">string</span><span class="s1">.</span><span class="s2">charCodeAt</span><span class="s1">(</span><span class="s2">i</span><span class="s1">);</span>
      <span class="s4">if </span><span class="s1">(!</span><span class="s2">isPrintable</span><span class="s1">(</span><span class="s2">char</span><span class="s1">)) {</span>
        <span class="s4">return </span><span class="s2">STYLE_DOUBLE</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s2">prev_char </span><span class="s1">= </span><span class="s2">i </span><span class="s1">&gt; </span><span class="s5">0 </span><span class="s1">? </span><span class="s2">string</span><span class="s1">.</span><span class="s2">charCodeAt</span><span class="s1">(</span><span class="s2">i </span><span class="s1">- </span><span class="s5">1</span><span class="s1">) : </span><span class="s4">null</span><span class="s1">;</span>
      <span class="s2">plain </span><span class="s1">= </span><span class="s2">plain </span><span class="s1">&amp;&amp; </span><span class="s2">isPlainSafe</span><span class="s1">(</span><span class="s2">char</span><span class="s1">, </span><span class="s2">prev_char</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
    <span class="s3">// Case: block styles permitted.</span>
    <span class="s4">for </span><span class="s1">(</span><span class="s2">i </span><span class="s1">= </span><span class="s5">0</span><span class="s1">; </span><span class="s2">i </span><span class="s1">&lt; </span><span class="s2">string</span><span class="s1">.</span><span class="s2">length</span><span class="s1">; </span><span class="s2">i</span><span class="s1">++) {</span>
      <span class="s2">char </span><span class="s1">= </span><span class="s2">string</span><span class="s1">.</span><span class="s2">charCodeAt</span><span class="s1">(</span><span class="s2">i</span><span class="s1">);</span>
      <span class="s4">if </span><span class="s1">(</span><span class="s2">char </span><span class="s1">=== </span><span class="s2">CHAR_LINE_FEED</span><span class="s1">) {</span>
        <span class="s2">hasLineBreak </span><span class="s1">= </span><span class="s4">true</span><span class="s1">;</span>
        <span class="s3">// Check if any line can be folded.</span>
        <span class="s4">if </span><span class="s1">(</span><span class="s2">shouldTrackWidth</span><span class="s1">) {</span>
          <span class="s2">hasFoldableLine </span><span class="s1">= </span><span class="s2">hasFoldableLine </span><span class="s1">||</span>
            <span class="s3">// Foldable line = too long, and not more-indented.</span>
            <span class="s1">(</span><span class="s2">i </span><span class="s1">- </span><span class="s2">previousLineBreak </span><span class="s1">- </span><span class="s5">1 </span><span class="s1">&gt; </span><span class="s2">lineWidth </span><span class="s1">&amp;&amp;</span>
             <span class="s2">string</span><span class="s1">[</span><span class="s2">previousLineBreak </span><span class="s1">+ </span><span class="s5">1</span><span class="s1">] !== </span><span class="s0">' '</span><span class="s1">);</span>
          <span class="s2">previousLineBreak </span><span class="s1">= </span><span class="s2">i</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s4">else if </span><span class="s1">(!</span><span class="s2">isPrintable</span><span class="s1">(</span><span class="s2">char</span><span class="s1">)) {</span>
        <span class="s4">return </span><span class="s2">STYLE_DOUBLE</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s2">prev_char </span><span class="s1">= </span><span class="s2">i </span><span class="s1">&gt; </span><span class="s5">0 </span><span class="s1">? </span><span class="s2">string</span><span class="s1">.</span><span class="s2">charCodeAt</span><span class="s1">(</span><span class="s2">i </span><span class="s1">- </span><span class="s5">1</span><span class="s1">) : </span><span class="s4">null</span><span class="s1">;</span>
      <span class="s2">plain </span><span class="s1">= </span><span class="s2">plain </span><span class="s1">&amp;&amp; </span><span class="s2">isPlainSafe</span><span class="s1">(</span><span class="s2">char</span><span class="s1">, </span><span class="s2">prev_char</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s3">// in case the end is missing a \n</span>
    <span class="s2">hasFoldableLine </span><span class="s1">= </span><span class="s2">hasFoldableLine </span><span class="s1">|| (</span><span class="s2">shouldTrackWidth </span><span class="s1">&amp;&amp;</span>
      <span class="s1">(</span><span class="s2">i </span><span class="s1">- </span><span class="s2">previousLineBreak </span><span class="s1">- </span><span class="s5">1 </span><span class="s1">&gt; </span><span class="s2">lineWidth </span><span class="s1">&amp;&amp;</span>
       <span class="s2">string</span><span class="s1">[</span><span class="s2">previousLineBreak </span><span class="s1">+ </span><span class="s5">1</span><span class="s1">] !== </span><span class="s0">' '</span><span class="s1">));</span>
  <span class="s1">}</span>
  <span class="s3">// Although every style can represent \n without escaping, prefer block styles</span>
  <span class="s3">// for multiline, since they're more readable and they don't add empty lines.</span>
  <span class="s3">// Also prefer folding a super-long line.</span>
  <span class="s4">if </span><span class="s1">(!</span><span class="s2">hasLineBreak </span><span class="s1">&amp;&amp; !</span><span class="s2">hasFoldableLine</span><span class="s1">) {</span>
    <span class="s3">// Strings interpretable as another type have to be quoted;</span>
    <span class="s3">// e.g. the string 'true' vs. the boolean true.</span>
    <span class="s4">return </span><span class="s2">plain </span><span class="s1">&amp;&amp; !</span><span class="s2">testAmbiguousType</span><span class="s1">(</span><span class="s2">string</span><span class="s1">)</span>
      <span class="s1">? </span><span class="s2">STYLE_PLAIN </span><span class="s1">: </span><span class="s2">STYLE_SINGLE</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">// Edge case: block indentation indicator can only have one digit.</span>
  <span class="s4">if </span><span class="s1">(</span><span class="s2">indentPerLevel </span><span class="s1">&gt; </span><span class="s5">9 </span><span class="s1">&amp;&amp; </span><span class="s2">needIndentIndicator</span><span class="s1">(</span><span class="s2">string</span><span class="s1">)) {</span>
    <span class="s4">return </span><span class="s2">STYLE_DOUBLE</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">// At this point we know block styles are valid.</span>
  <span class="s3">// Prefer literal style unless we want to fold.</span>
  <span class="s4">return </span><span class="s2">hasFoldableLine </span><span class="s1">? </span><span class="s2">STYLE_FOLDED </span><span class="s1">: </span><span class="s2">STYLE_LITERAL</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">// Note: line breaking/folding is implemented for only the folded style.</span>
<span class="s3">// NB. We drop the last trailing newline (if any) of a returned block scalar</span>
<span class="s3">//  since the dumper adds its own newline. This always works:</span>
<span class="s3">//    • No ending newline =&gt; unaffected; already using strip &quot;-&quot; chomping.</span>
<span class="s3">//    • Ending newline    =&gt; removed then restored.</span>
<span class="s3">//  Importantly, this keeps the &quot;+&quot; chomp indicator from gaining an extra line.</span>
<span class="s4">function </span><span class="s2">writeScalar</span><span class="s1">(</span><span class="s2">state</span><span class="s1">, </span><span class="s2">string</span><span class="s1">, </span><span class="s2">level</span><span class="s1">, </span><span class="s2">iskey</span><span class="s1">) {</span>
  <span class="s2">state</span><span class="s1">.</span><span class="s2">dump </span><span class="s1">= (</span><span class="s4">function </span><span class="s1">() {</span>
    <span class="s4">if </span><span class="s1">(</span><span class="s2">string</span><span class="s1">.</span><span class="s2">length </span><span class="s1">=== </span><span class="s5">0</span><span class="s1">) {</span>
      <span class="s4">return </span><span class="s0">&quot;''&quot;</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s4">if </span><span class="s1">(!</span><span class="s2">state</span><span class="s1">.</span><span class="s2">noCompatMode </span><span class="s1">&amp;&amp;</span>
        <span class="s2">DEPRECATED_BOOLEANS_SYNTAX</span><span class="s1">.</span><span class="s2">indexOf</span><span class="s1">(</span><span class="s2">string</span><span class="s1">) !== -</span><span class="s5">1</span><span class="s1">) {</span>
      <span class="s4">return </span><span class="s0">&quot;'&quot; </span><span class="s1">+ </span><span class="s2">string </span><span class="s1">+ </span><span class="s0">&quot;'&quot;</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s4">var </span><span class="s2">indent </span><span class="s1">= </span><span class="s2">state</span><span class="s1">.</span><span class="s2">indent </span><span class="s1">* </span><span class="s2">Math</span><span class="s1">.</span><span class="s2">max</span><span class="s1">(</span><span class="s5">1</span><span class="s1">, </span><span class="s2">level</span><span class="s1">); </span><span class="s3">// no 0-indent scalars</span>
    <span class="s3">// As indentation gets deeper, let the width decrease monotonically</span>
    <span class="s3">// to the lower bound min(state.lineWidth, 40).</span>
    <span class="s3">// Note that this implies</span>
    <span class="s3">//  state.lineWidth ≤ 40 + state.indent: width is fixed at the lower bound.</span>
    <span class="s3">//  state.lineWidth &gt; 40 + state.indent: width decreases until the lower bound.</span>
    <span class="s3">// This behaves better than a constant minimum width which disallows narrower options,</span>
    <span class="s3">// or an indent threshold which causes the width to suddenly increase.</span>
    <span class="s4">var </span><span class="s2">lineWidth </span><span class="s1">= </span><span class="s2">state</span><span class="s1">.</span><span class="s2">lineWidth </span><span class="s1">=== -</span><span class="s5">1</span>
      <span class="s1">? -</span><span class="s5">1 </span><span class="s1">: </span><span class="s2">Math</span><span class="s1">.</span><span class="s2">max</span><span class="s1">(</span><span class="s2">Math</span><span class="s1">.</span><span class="s2">min</span><span class="s1">(</span><span class="s2">state</span><span class="s1">.</span><span class="s2">lineWidth</span><span class="s1">, </span><span class="s5">40</span><span class="s1">), </span><span class="s2">state</span><span class="s1">.</span><span class="s2">lineWidth </span><span class="s1">- </span><span class="s2">indent</span><span class="s1">);</span>

    <span class="s3">// Without knowing if keys are implicit/explicit, assume implicit for safety.</span>
    <span class="s4">var </span><span class="s2">singleLineOnly </span><span class="s1">= </span><span class="s2">iskey</span>
      <span class="s3">// No block styles in flow mode.</span>
      <span class="s1">|| (</span><span class="s2">state</span><span class="s1">.</span><span class="s2">flowLevel </span><span class="s1">&gt; -</span><span class="s5">1 </span><span class="s1">&amp;&amp; </span><span class="s2">level </span><span class="s1">&gt;= </span><span class="s2">state</span><span class="s1">.</span><span class="s2">flowLevel</span><span class="s1">);</span>
    <span class="s4">function </span><span class="s2">testAmbiguity</span><span class="s1">(</span><span class="s2">string</span><span class="s1">) {</span>
      <span class="s4">return </span><span class="s2">testImplicitResolving</span><span class="s1">(</span><span class="s2">state</span><span class="s1">, </span><span class="s2">string</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s4">switch </span><span class="s1">(</span><span class="s2">chooseScalarStyle</span><span class="s1">(</span><span class="s2">string</span><span class="s1">, </span><span class="s2">singleLineOnly</span><span class="s1">, </span><span class="s2">state</span><span class="s1">.</span><span class="s2">indent</span><span class="s1">, </span><span class="s2">lineWidth</span><span class="s1">, </span><span class="s2">testAmbiguity</span><span class="s1">)) {</span>
      <span class="s4">case </span><span class="s2">STYLE_PLAIN</span><span class="s1">:</span>
        <span class="s4">return </span><span class="s2">string</span><span class="s1">;</span>
      <span class="s4">case </span><span class="s2">STYLE_SINGLE</span><span class="s1">:</span>
        <span class="s4">return </span><span class="s0">&quot;'&quot; </span><span class="s1">+ </span><span class="s2">string</span><span class="s1">.</span><span class="s2">replace</span><span class="s1">(</span><span class="s6">/'/g</span><span class="s1">, </span><span class="s0">&quot;''&quot;</span><span class="s1">) + </span><span class="s0">&quot;'&quot;</span><span class="s1">;</span>
      <span class="s4">case </span><span class="s2">STYLE_LITERAL</span><span class="s1">:</span>
        <span class="s4">return </span><span class="s0">'|' </span><span class="s1">+ </span><span class="s2">blockHeader</span><span class="s1">(</span><span class="s2">string</span><span class="s1">, </span><span class="s2">state</span><span class="s1">.</span><span class="s2">indent</span><span class="s1">)</span>
          <span class="s1">+ </span><span class="s2">dropEndingNewline</span><span class="s1">(</span><span class="s2">indentString</span><span class="s1">(</span><span class="s2">string</span><span class="s1">, </span><span class="s2">indent</span><span class="s1">));</span>
      <span class="s4">case </span><span class="s2">STYLE_FOLDED</span><span class="s1">:</span>
        <span class="s4">return </span><span class="s0">'&gt;' </span><span class="s1">+ </span><span class="s2">blockHeader</span><span class="s1">(</span><span class="s2">string</span><span class="s1">, </span><span class="s2">state</span><span class="s1">.</span><span class="s2">indent</span><span class="s1">)</span>
          <span class="s1">+ </span><span class="s2">dropEndingNewline</span><span class="s1">(</span><span class="s2">indentString</span><span class="s1">(</span><span class="s2">foldString</span><span class="s1">(</span><span class="s2">string</span><span class="s1">, </span><span class="s2">lineWidth</span><span class="s1">), </span><span class="s2">indent</span><span class="s1">));</span>
      <span class="s4">case </span><span class="s2">STYLE_DOUBLE</span><span class="s1">:</span>
        <span class="s4">return </span><span class="s0">'&quot;' </span><span class="s1">+ </span><span class="s2">escapeString</span><span class="s1">(</span><span class="s2">string</span><span class="s1">, </span><span class="s2">lineWidth</span><span class="s1">) + </span><span class="s0">'&quot;'</span><span class="s1">;</span>
      <span class="s4">default</span><span class="s1">:</span>
        <span class="s4">throw new </span><span class="s2">YAMLException</span><span class="s1">(</span><span class="s0">'impossible error: invalid scalar style'</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}());</span>
<span class="s1">}</span>

<span class="s3">// Pre-conditions: string is valid for a block scalar, 1 &lt;= indentPerLevel &lt;= 9.</span>
<span class="s4">function </span><span class="s2">blockHeader</span><span class="s1">(</span><span class="s2">string</span><span class="s1">, </span><span class="s2">indentPerLevel</span><span class="s1">) {</span>
  <span class="s4">var </span><span class="s2">indentIndicator </span><span class="s1">= </span><span class="s2">needIndentIndicator</span><span class="s1">(</span><span class="s2">string</span><span class="s1">) ? </span><span class="s2">String</span><span class="s1">(</span><span class="s2">indentPerLevel</span><span class="s1">) : </span><span class="s0">''</span><span class="s1">;</span>

  <span class="s3">// note the special case: the string '\n' counts as a &quot;trailing&quot; empty line.</span>
  <span class="s4">var </span><span class="s2">clip </span><span class="s1">=          </span><span class="s2">string</span><span class="s1">[</span><span class="s2">string</span><span class="s1">.</span><span class="s2">length </span><span class="s1">- </span><span class="s5">1</span><span class="s1">] === </span><span class="s0">'</span><span class="s4">\n</span><span class="s0">'</span><span class="s1">;</span>
  <span class="s4">var </span><span class="s2">keep </span><span class="s1">= </span><span class="s2">clip </span><span class="s1">&amp;&amp; (</span><span class="s2">string</span><span class="s1">[</span><span class="s2">string</span><span class="s1">.</span><span class="s2">length </span><span class="s1">- </span><span class="s5">2</span><span class="s1">] === </span><span class="s0">'</span><span class="s4">\n</span><span class="s0">' </span><span class="s1">|| </span><span class="s2">string </span><span class="s1">=== </span><span class="s0">'</span><span class="s4">\n</span><span class="s0">'</span><span class="s1">);</span>
  <span class="s4">var </span><span class="s2">chomp </span><span class="s1">= </span><span class="s2">keep </span><span class="s1">? </span><span class="s0">'+' </span><span class="s1">: (</span><span class="s2">clip </span><span class="s1">? </span><span class="s0">'' </span><span class="s1">: </span><span class="s0">'-'</span><span class="s1">);</span>

  <span class="s4">return </span><span class="s2">indentIndicator </span><span class="s1">+ </span><span class="s2">chomp </span><span class="s1">+ </span><span class="s0">'</span><span class="s4">\n</span><span class="s0">'</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">// (See the note for writeScalar.)</span>
<span class="s4">function </span><span class="s2">dropEndingNewline</span><span class="s1">(</span><span class="s2">string</span><span class="s1">) {</span>
  <span class="s4">return </span><span class="s2">string</span><span class="s1">[</span><span class="s2">string</span><span class="s1">.</span><span class="s2">length </span><span class="s1">- </span><span class="s5">1</span><span class="s1">] === </span><span class="s0">'</span><span class="s4">\n</span><span class="s0">' </span><span class="s1">? </span><span class="s2">string</span><span class="s1">.</span><span class="s2">slice</span><span class="s1">(</span><span class="s5">0</span><span class="s1">, -</span><span class="s5">1</span><span class="s1">) : </span><span class="s2">string</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">// Note: a long line without a suitable break point will exceed the width limit.</span>
<span class="s3">// Pre-conditions: every char in str isPrintable, str.length &gt; 0, width &gt; 0.</span>
<span class="s4">function </span><span class="s2">foldString</span><span class="s1">(</span><span class="s2">string</span><span class="s1">, </span><span class="s2">width</span><span class="s1">) {</span>
  <span class="s3">// In folded style, $k$ consecutive newlines output as $k+1$ newlines—</span>
  <span class="s3">// unless they're before or after a more-indented line, or at the very</span>
  <span class="s3">// beginning or end, in which case $k$ maps to $k$.</span>
  <span class="s3">// Therefore, parse each chunk as newline(s) followed by a content line.</span>
  <span class="s4">var </span><span class="s2">lineRe </span><span class="s1">= </span><span class="s6">/(\n+)([^\n]*)/g</span><span class="s1">;</span>

  <span class="s3">// first line (possibly an empty line)</span>
  <span class="s4">var </span><span class="s2">result </span><span class="s1">= (</span><span class="s4">function </span><span class="s1">() {</span>
    <span class="s4">var </span><span class="s2">nextLF </span><span class="s1">= </span><span class="s2">string</span><span class="s1">.</span><span class="s2">indexOf</span><span class="s1">(</span><span class="s0">'</span><span class="s4">\n</span><span class="s0">'</span><span class="s1">);</span>
    <span class="s2">nextLF </span><span class="s1">= </span><span class="s2">nextLF </span><span class="s1">!== -</span><span class="s5">1 </span><span class="s1">? </span><span class="s2">nextLF </span><span class="s1">: </span><span class="s2">string</span><span class="s1">.</span><span class="s2">length</span><span class="s1">;</span>
    <span class="s2">lineRe</span><span class="s1">.</span><span class="s2">lastIndex </span><span class="s1">= </span><span class="s2">nextLF</span><span class="s1">;</span>
    <span class="s4">return </span><span class="s2">foldLine</span><span class="s1">(</span><span class="s2">string</span><span class="s1">.</span><span class="s2">slice</span><span class="s1">(</span><span class="s5">0</span><span class="s1">, </span><span class="s2">nextLF</span><span class="s1">), </span><span class="s2">width</span><span class="s1">);</span>
  <span class="s1">}());</span>
  <span class="s3">// If we haven't reached the first content line yet, don't add an extra \n.</span>
  <span class="s4">var </span><span class="s2">prevMoreIndented </span><span class="s1">= </span><span class="s2">string</span><span class="s1">[</span><span class="s5">0</span><span class="s1">] === </span><span class="s0">'</span><span class="s4">\n</span><span class="s0">' </span><span class="s1">|| </span><span class="s2">string</span><span class="s1">[</span><span class="s5">0</span><span class="s1">] === </span><span class="s0">' '</span><span class="s1">;</span>
  <span class="s4">var </span><span class="s2">moreIndented</span><span class="s1">;</span>

  <span class="s3">// rest of the lines</span>
  <span class="s4">var </span><span class="s2">match</span><span class="s1">;</span>
  <span class="s4">while </span><span class="s1">((</span><span class="s2">match </span><span class="s1">= </span><span class="s2">lineRe</span><span class="s1">.</span><span class="s2">exec</span><span class="s1">(</span><span class="s2">string</span><span class="s1">))) {</span>
    <span class="s4">var </span><span class="s2">prefix </span><span class="s1">= </span><span class="s2">match</span><span class="s1">[</span><span class="s5">1</span><span class="s1">], </span><span class="s2">line </span><span class="s1">= </span><span class="s2">match</span><span class="s1">[</span><span class="s5">2</span><span class="s1">];</span>
    <span class="s2">moreIndented </span><span class="s1">= (</span><span class="s2">line</span><span class="s1">[</span><span class="s5">0</span><span class="s1">] === </span><span class="s0">' '</span><span class="s1">);</span>
    <span class="s2">result </span><span class="s1">+= </span><span class="s2">prefix</span>
      <span class="s1">+ (!</span><span class="s2">prevMoreIndented </span><span class="s1">&amp;&amp; !</span><span class="s2">moreIndented </span><span class="s1">&amp;&amp; </span><span class="s2">line </span><span class="s1">!== </span><span class="s0">''</span>
        <span class="s1">? </span><span class="s0">'</span><span class="s4">\n</span><span class="s0">' </span><span class="s1">: </span><span class="s0">''</span><span class="s1">)</span>
      <span class="s1">+ </span><span class="s2">foldLine</span><span class="s1">(</span><span class="s2">line</span><span class="s1">, </span><span class="s2">width</span><span class="s1">);</span>
    <span class="s2">prevMoreIndented </span><span class="s1">= </span><span class="s2">moreIndented</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s4">return </span><span class="s2">result</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">// Greedy line breaking.</span>
<span class="s3">// Picks the longest line under the limit each time,</span>
<span class="s3">// otherwise settles for the shortest line over the limit.</span>
<span class="s3">// NB. More-indented lines *cannot* be folded, as that would add an extra \n.</span>
<span class="s4">function </span><span class="s2">foldLine</span><span class="s1">(</span><span class="s2">line</span><span class="s1">, </span><span class="s2">width</span><span class="s1">) {</span>
  <span class="s4">if </span><span class="s1">(</span><span class="s2">line </span><span class="s1">=== </span><span class="s0">'' </span><span class="s1">|| </span><span class="s2">line</span><span class="s1">[</span><span class="s5">0</span><span class="s1">] === </span><span class="s0">' '</span><span class="s1">) </span><span class="s4">return </span><span class="s2">line</span><span class="s1">;</span>

  <span class="s3">// Since a more-indented line adds a \n, breaks can't be followed by a space.</span>
  <span class="s4">var </span><span class="s2">breakRe </span><span class="s1">= </span><span class="s6">/ [^ ]/g</span><span class="s1">; </span><span class="s3">// note: the match index will always be &lt;= length-2.</span>
  <span class="s4">var </span><span class="s2">match</span><span class="s1">;</span>
  <span class="s3">// start is an inclusive index. end, curr, and next are exclusive.</span>
  <span class="s4">var </span><span class="s2">start </span><span class="s1">= </span><span class="s5">0</span><span class="s1">, </span><span class="s2">end</span><span class="s1">, </span><span class="s2">curr </span><span class="s1">= </span><span class="s5">0</span><span class="s1">, </span><span class="s2">next </span><span class="s1">= </span><span class="s5">0</span><span class="s1">;</span>
  <span class="s4">var </span><span class="s2">result </span><span class="s1">= </span><span class="s0">''</span><span class="s1">;</span>

  <span class="s3">// Invariants: 0 &lt;= start &lt;= length-1.</span>
  <span class="s3">//   0 &lt;= curr &lt;= next &lt;= max(0, length-2). curr - start &lt;= width.</span>
  <span class="s3">// Inside the loop:</span>
  <span class="s3">//   A match implies length &gt;= 2, so curr and next are &lt;= length-2.</span>
  <span class="s4">while </span><span class="s1">((</span><span class="s2">match </span><span class="s1">= </span><span class="s2">breakRe</span><span class="s1">.</span><span class="s2">exec</span><span class="s1">(</span><span class="s2">line</span><span class="s1">))) {</span>
    <span class="s2">next </span><span class="s1">= </span><span class="s2">match</span><span class="s1">.</span><span class="s2">index</span><span class="s1">;</span>
    <span class="s3">// maintain invariant: curr - start &lt;= width</span>
    <span class="s4">if </span><span class="s1">(</span><span class="s2">next </span><span class="s1">- </span><span class="s2">start </span><span class="s1">&gt; </span><span class="s2">width</span><span class="s1">) {</span>
      <span class="s2">end </span><span class="s1">= (</span><span class="s2">curr </span><span class="s1">&gt; </span><span class="s2">start</span><span class="s1">) ? </span><span class="s2">curr </span><span class="s1">: </span><span class="s2">next</span><span class="s1">; </span><span class="s3">// derive end &lt;= length-2</span>
      <span class="s2">result </span><span class="s1">+= </span><span class="s0">'</span><span class="s4">\n</span><span class="s0">' </span><span class="s1">+ </span><span class="s2">line</span><span class="s1">.</span><span class="s2">slice</span><span class="s1">(</span><span class="s2">start</span><span class="s1">, </span><span class="s2">end</span><span class="s1">);</span>
      <span class="s3">// skip the space that was output as \n</span>
      <span class="s2">start </span><span class="s1">= </span><span class="s2">end </span><span class="s1">+ </span><span class="s5">1</span><span class="s1">;                    </span><span class="s3">// derive start &lt;= length-1</span>
    <span class="s1">}</span>
    <span class="s2">curr </span><span class="s1">= </span><span class="s2">next</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">// By the invariants, start &lt;= length-1, so there is something left over.</span>
  <span class="s3">// It is either the whole string or a part starting from non-whitespace.</span>
  <span class="s2">result </span><span class="s1">+= </span><span class="s0">'</span><span class="s4">\n</span><span class="s0">'</span><span class="s1">;</span>
  <span class="s3">// Insert a break if the remainder is too long and there is a break available.</span>
  <span class="s4">if </span><span class="s1">(</span><span class="s2">line</span><span class="s1">.</span><span class="s2">length </span><span class="s1">- </span><span class="s2">start </span><span class="s1">&gt; </span><span class="s2">width </span><span class="s1">&amp;&amp; </span><span class="s2">curr </span><span class="s1">&gt; </span><span class="s2">start</span><span class="s1">) {</span>
    <span class="s2">result </span><span class="s1">+= </span><span class="s2">line</span><span class="s1">.</span><span class="s2">slice</span><span class="s1">(</span><span class="s2">start</span><span class="s1">, </span><span class="s2">curr</span><span class="s1">) + </span><span class="s0">'</span><span class="s4">\n</span><span class="s0">' </span><span class="s1">+ </span><span class="s2">line</span><span class="s1">.</span><span class="s2">slice</span><span class="s1">(</span><span class="s2">curr </span><span class="s1">+ </span><span class="s5">1</span><span class="s1">);</span>
  <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
    <span class="s2">result </span><span class="s1">+= </span><span class="s2">line</span><span class="s1">.</span><span class="s2">slice</span><span class="s1">(</span><span class="s2">start</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s4">return </span><span class="s2">result</span><span class="s1">.</span><span class="s2">slice</span><span class="s1">(</span><span class="s5">1</span><span class="s1">); </span><span class="s3">// drop extra \n joiner</span>
<span class="s1">}</span>

<span class="s3">// Escapes a double-quoted string.</span>
<span class="s4">function </span><span class="s2">escapeString</span><span class="s1">(</span><span class="s2">string</span><span class="s1">) {</span>
  <span class="s4">var </span><span class="s2">result </span><span class="s1">= </span><span class="s0">''</span><span class="s1">;</span>
  <span class="s4">var </span><span class="s2">char</span><span class="s1">, </span><span class="s2">nextChar</span><span class="s1">;</span>
  <span class="s4">var </span><span class="s2">escapeSeq</span><span class="s1">;</span>

  <span class="s4">for </span><span class="s1">(</span><span class="s4">var </span><span class="s2">i </span><span class="s1">= </span><span class="s5">0</span><span class="s1">; </span><span class="s2">i </span><span class="s1">&lt; </span><span class="s2">string</span><span class="s1">.</span><span class="s2">length</span><span class="s1">; </span><span class="s2">i</span><span class="s1">++) {</span>
    <span class="s2">char </span><span class="s1">= </span><span class="s2">string</span><span class="s1">.</span><span class="s2">charCodeAt</span><span class="s1">(</span><span class="s2">i</span><span class="s1">);</span>
    <span class="s3">// Check for surrogate pairs (reference Unicode 3.0 section &quot;3.7 Surrogates&quot;).</span>
    <span class="s4">if </span><span class="s1">(</span><span class="s2">char </span><span class="s1">&gt;= </span><span class="s5">0xD800 </span><span class="s1">&amp;&amp; </span><span class="s2">char </span><span class="s1">&lt;= </span><span class="s5">0xDBFF</span><span class="s3">/* high surrogate */</span><span class="s1">) {</span>
      <span class="s2">nextChar </span><span class="s1">= </span><span class="s2">string</span><span class="s1">.</span><span class="s2">charCodeAt</span><span class="s1">(</span><span class="s2">i </span><span class="s1">+ </span><span class="s5">1</span><span class="s1">);</span>
      <span class="s4">if </span><span class="s1">(</span><span class="s2">nextChar </span><span class="s1">&gt;= </span><span class="s5">0xDC00 </span><span class="s1">&amp;&amp; </span><span class="s2">nextChar </span><span class="s1">&lt;= </span><span class="s5">0xDFFF</span><span class="s3">/* low surrogate */</span><span class="s1">) {</span>
        <span class="s3">// Combine the surrogate pair and store it escaped.</span>
        <span class="s2">result </span><span class="s1">+= </span><span class="s2">encodeHex</span><span class="s1">((</span><span class="s2">char </span><span class="s1">- </span><span class="s5">0xD800</span><span class="s1">) * </span><span class="s5">0x400 </span><span class="s1">+ </span><span class="s2">nextChar </span><span class="s1">- </span><span class="s5">0xDC00 </span><span class="s1">+ </span><span class="s5">0x10000</span><span class="s1">);</span>
        <span class="s3">// Advance index one extra since we already used that char here.</span>
        <span class="s2">i</span><span class="s1">++; </span><span class="s4">continue</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">escapeSeq </span><span class="s1">= </span><span class="s2">ESCAPE_SEQUENCES</span><span class="s1">[</span><span class="s2">char</span><span class="s1">];</span>
    <span class="s2">result </span><span class="s1">+= !</span><span class="s2">escapeSeq </span><span class="s1">&amp;&amp; </span><span class="s2">isPrintable</span><span class="s1">(</span><span class="s2">char</span><span class="s1">)</span>
      <span class="s1">? </span><span class="s2">string</span><span class="s1">[</span><span class="s2">i</span><span class="s1">]</span>
      <span class="s1">: </span><span class="s2">escapeSeq </span><span class="s1">|| </span><span class="s2">encodeHex</span><span class="s1">(</span><span class="s2">char</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s4">return </span><span class="s2">result</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s4">function </span><span class="s2">writeFlowSequence</span><span class="s1">(</span><span class="s2">state</span><span class="s1">, </span><span class="s2">level</span><span class="s1">, </span><span class="s2">object</span><span class="s1">) {</span>
  <span class="s4">var </span><span class="s2">_result </span><span class="s1">= </span><span class="s0">''</span><span class="s1">,</span>
      <span class="s2">_tag    </span><span class="s1">= </span><span class="s2">state</span><span class="s1">.</span><span class="s2">tag</span><span class="s1">,</span>
      <span class="s2">index</span><span class="s1">,</span>
      <span class="s2">length</span><span class="s1">;</span>

  <span class="s4">for </span><span class="s1">(</span><span class="s2">index </span><span class="s1">= </span><span class="s5">0</span><span class="s1">, </span><span class="s2">length </span><span class="s1">= </span><span class="s2">object</span><span class="s1">.</span><span class="s2">length</span><span class="s1">; </span><span class="s2">index </span><span class="s1">&lt; </span><span class="s2">length</span><span class="s1">; </span><span class="s2">index </span><span class="s1">+= </span><span class="s5">1</span><span class="s1">) {</span>
    <span class="s3">// Write only valid elements.</span>
    <span class="s4">if </span><span class="s1">(</span><span class="s2">writeNode</span><span class="s1">(</span><span class="s2">state</span><span class="s1">, </span><span class="s2">level</span><span class="s1">, </span><span class="s2">object</span><span class="s1">[</span><span class="s2">index</span><span class="s1">], </span><span class="s4">false</span><span class="s1">, </span><span class="s4">false</span><span class="s1">)) {</span>
      <span class="s4">if </span><span class="s1">(</span><span class="s2">index </span><span class="s1">!== </span><span class="s5">0</span><span class="s1">) </span><span class="s2">_result </span><span class="s1">+= </span><span class="s0">',' </span><span class="s1">+ (!</span><span class="s2">state</span><span class="s1">.</span><span class="s2">condenseFlow </span><span class="s1">? </span><span class="s0">' ' </span><span class="s1">: </span><span class="s0">''</span><span class="s1">);</span>
      <span class="s2">_result </span><span class="s1">+= </span><span class="s2">state</span><span class="s1">.</span><span class="s2">dump</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">state</span><span class="s1">.</span><span class="s2">tag </span><span class="s1">= </span><span class="s2">_tag</span><span class="s1">;</span>
  <span class="s2">state</span><span class="s1">.</span><span class="s2">dump </span><span class="s1">= </span><span class="s0">'[' </span><span class="s1">+ </span><span class="s2">_result </span><span class="s1">+ </span><span class="s0">']'</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s4">function </span><span class="s2">writeBlockSequence</span><span class="s1">(</span><span class="s2">state</span><span class="s1">, </span><span class="s2">level</span><span class="s1">, </span><span class="s2">object</span><span class="s1">, </span><span class="s2">compact</span><span class="s1">) {</span>
  <span class="s4">var </span><span class="s2">_result </span><span class="s1">= </span><span class="s0">''</span><span class="s1">,</span>
      <span class="s2">_tag    </span><span class="s1">= </span><span class="s2">state</span><span class="s1">.</span><span class="s2">tag</span><span class="s1">,</span>
      <span class="s2">index</span><span class="s1">,</span>
      <span class="s2">length</span><span class="s1">;</span>

  <span class="s4">for </span><span class="s1">(</span><span class="s2">index </span><span class="s1">= </span><span class="s5">0</span><span class="s1">, </span><span class="s2">length </span><span class="s1">= </span><span class="s2">object</span><span class="s1">.</span><span class="s2">length</span><span class="s1">; </span><span class="s2">index </span><span class="s1">&lt; </span><span class="s2">length</span><span class="s1">; </span><span class="s2">index </span><span class="s1">+= </span><span class="s5">1</span><span class="s1">) {</span>
    <span class="s3">// Write only valid elements.</span>
    <span class="s4">if </span><span class="s1">(</span><span class="s2">writeNode</span><span class="s1">(</span><span class="s2">state</span><span class="s1">, </span><span class="s2">level </span><span class="s1">+ </span><span class="s5">1</span><span class="s1">, </span><span class="s2">object</span><span class="s1">[</span><span class="s2">index</span><span class="s1">], </span><span class="s4">true</span><span class="s1">, </span><span class="s4">true</span><span class="s1">)) {</span>
      <span class="s4">if </span><span class="s1">(!</span><span class="s2">compact </span><span class="s1">|| </span><span class="s2">index </span><span class="s1">!== </span><span class="s5">0</span><span class="s1">) {</span>
        <span class="s2">_result </span><span class="s1">+= </span><span class="s2">generateNextLine</span><span class="s1">(</span><span class="s2">state</span><span class="s1">, </span><span class="s2">level</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s4">if </span><span class="s1">(</span><span class="s2">state</span><span class="s1">.</span><span class="s2">dump </span><span class="s1">&amp;&amp; </span><span class="s2">CHAR_LINE_FEED </span><span class="s1">=== </span><span class="s2">state</span><span class="s1">.</span><span class="s2">dump</span><span class="s1">.</span><span class="s2">charCodeAt</span><span class="s1">(</span><span class="s5">0</span><span class="s1">)) {</span>
        <span class="s2">_result </span><span class="s1">+= </span><span class="s0">'-'</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
        <span class="s2">_result </span><span class="s1">+= </span><span class="s0">'- '</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s2">_result </span><span class="s1">+= </span><span class="s2">state</span><span class="s1">.</span><span class="s2">dump</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">state</span><span class="s1">.</span><span class="s2">tag </span><span class="s1">= </span><span class="s2">_tag</span><span class="s1">;</span>
  <span class="s2">state</span><span class="s1">.</span><span class="s2">dump </span><span class="s1">= </span><span class="s2">_result </span><span class="s1">|| </span><span class="s0">'[]'</span><span class="s1">; </span><span class="s3">// Empty sequence if no valid values.</span>
<span class="s1">}</span>

<span class="s4">function </span><span class="s2">writeFlowMapping</span><span class="s1">(</span><span class="s2">state</span><span class="s1">, </span><span class="s2">level</span><span class="s1">, </span><span class="s2">object</span><span class="s1">) {</span>
  <span class="s4">var </span><span class="s2">_result       </span><span class="s1">= </span><span class="s0">''</span><span class="s1">,</span>
      <span class="s2">_tag          </span><span class="s1">= </span><span class="s2">state</span><span class="s1">.</span><span class="s2">tag</span><span class="s1">,</span>
      <span class="s2">objectKeyList </span><span class="s1">= </span><span class="s2">Object</span><span class="s1">.</span><span class="s2">keys</span><span class="s1">(</span><span class="s2">object</span><span class="s1">),</span>
      <span class="s2">index</span><span class="s1">,</span>
      <span class="s2">length</span><span class="s1">,</span>
      <span class="s2">objectKey</span><span class="s1">,</span>
      <span class="s2">objectValue</span><span class="s1">,</span>
      <span class="s2">pairBuffer</span><span class="s1">;</span>

  <span class="s4">for </span><span class="s1">(</span><span class="s2">index </span><span class="s1">= </span><span class="s5">0</span><span class="s1">, </span><span class="s2">length </span><span class="s1">= </span><span class="s2">objectKeyList</span><span class="s1">.</span><span class="s2">length</span><span class="s1">; </span><span class="s2">index </span><span class="s1">&lt; </span><span class="s2">length</span><span class="s1">; </span><span class="s2">index </span><span class="s1">+= </span><span class="s5">1</span><span class="s1">) {</span>

    <span class="s2">pairBuffer </span><span class="s1">= </span><span class="s0">''</span><span class="s1">;</span>
    <span class="s4">if </span><span class="s1">(</span><span class="s2">index </span><span class="s1">!== </span><span class="s5">0</span><span class="s1">) </span><span class="s2">pairBuffer </span><span class="s1">+= </span><span class="s0">', '</span><span class="s1">;</span>

    <span class="s4">if </span><span class="s1">(</span><span class="s2">state</span><span class="s1">.</span><span class="s2">condenseFlow</span><span class="s1">) </span><span class="s2">pairBuffer </span><span class="s1">+= </span><span class="s0">'&quot;'</span><span class="s1">;</span>

    <span class="s2">objectKey </span><span class="s1">= </span><span class="s2">objectKeyList</span><span class="s1">[</span><span class="s2">index</span><span class="s1">];</span>
    <span class="s2">objectValue </span><span class="s1">= </span><span class="s2">object</span><span class="s1">[</span><span class="s2">objectKey</span><span class="s1">];</span>

    <span class="s4">if </span><span class="s1">(!</span><span class="s2">writeNode</span><span class="s1">(</span><span class="s2">state</span><span class="s1">, </span><span class="s2">level</span><span class="s1">, </span><span class="s2">objectKey</span><span class="s1">, </span><span class="s4">false</span><span class="s1">, </span><span class="s4">false</span><span class="s1">)) {</span>
      <span class="s4">continue</span><span class="s1">; </span><span class="s3">// Skip this pair because of invalid key;</span>
    <span class="s1">}</span>

    <span class="s4">if </span><span class="s1">(</span><span class="s2">state</span><span class="s1">.</span><span class="s2">dump</span><span class="s1">.</span><span class="s2">length </span><span class="s1">&gt; </span><span class="s5">1024</span><span class="s1">) </span><span class="s2">pairBuffer </span><span class="s1">+= </span><span class="s0">'? '</span><span class="s1">;</span>

    <span class="s2">pairBuffer </span><span class="s1">+= </span><span class="s2">state</span><span class="s1">.</span><span class="s2">dump </span><span class="s1">+ (</span><span class="s2">state</span><span class="s1">.</span><span class="s2">condenseFlow </span><span class="s1">? </span><span class="s0">'&quot;' </span><span class="s1">: </span><span class="s0">''</span><span class="s1">) + </span><span class="s0">':' </span><span class="s1">+ (</span><span class="s2">state</span><span class="s1">.</span><span class="s2">condenseFlow </span><span class="s1">? </span><span class="s0">'' </span><span class="s1">: </span><span class="s0">' '</span><span class="s1">);</span>

    <span class="s4">if </span><span class="s1">(!</span><span class="s2">writeNode</span><span class="s1">(</span><span class="s2">state</span><span class="s1">, </span><span class="s2">level</span><span class="s1">, </span><span class="s2">objectValue</span><span class="s1">, </span><span class="s4">false</span><span class="s1">, </span><span class="s4">false</span><span class="s1">)) {</span>
      <span class="s4">continue</span><span class="s1">; </span><span class="s3">// Skip this pair because of invalid value.</span>
    <span class="s1">}</span>

    <span class="s2">pairBuffer </span><span class="s1">+= </span><span class="s2">state</span><span class="s1">.</span><span class="s2">dump</span><span class="s1">;</span>

    <span class="s3">// Both key and value are valid.</span>
    <span class="s2">_result </span><span class="s1">+= </span><span class="s2">pairBuffer</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">state</span><span class="s1">.</span><span class="s2">tag </span><span class="s1">= </span><span class="s2">_tag</span><span class="s1">;</span>
  <span class="s2">state</span><span class="s1">.</span><span class="s2">dump </span><span class="s1">= </span><span class="s0">'{' </span><span class="s1">+ </span><span class="s2">_result </span><span class="s1">+ </span><span class="s0">'}'</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s4">function </span><span class="s2">writeBlockMapping</span><span class="s1">(</span><span class="s2">state</span><span class="s1">, </span><span class="s2">level</span><span class="s1">, </span><span class="s2">object</span><span class="s1">, </span><span class="s2">compact</span><span class="s1">) {</span>
  <span class="s4">var </span><span class="s2">_result       </span><span class="s1">= </span><span class="s0">''</span><span class="s1">,</span>
      <span class="s2">_tag          </span><span class="s1">= </span><span class="s2">state</span><span class="s1">.</span><span class="s2">tag</span><span class="s1">,</span>
      <span class="s2">objectKeyList </span><span class="s1">= </span><span class="s2">Object</span><span class="s1">.</span><span class="s2">keys</span><span class="s1">(</span><span class="s2">object</span><span class="s1">),</span>
      <span class="s2">index</span><span class="s1">,</span>
      <span class="s2">length</span><span class="s1">,</span>
      <span class="s2">objectKey</span><span class="s1">,</span>
      <span class="s2">objectValue</span><span class="s1">,</span>
      <span class="s2">explicitPair</span><span class="s1">,</span>
      <span class="s2">pairBuffer</span><span class="s1">;</span>

  <span class="s3">// Allow sorting keys so that the output file is deterministic</span>
  <span class="s4">if </span><span class="s1">(</span><span class="s2">state</span><span class="s1">.</span><span class="s2">sortKeys </span><span class="s1">=== </span><span class="s4">true</span><span class="s1">) {</span>
    <span class="s3">// Default sorting</span>
    <span class="s2">objectKeyList</span><span class="s1">.</span><span class="s2">sort</span><span class="s1">();</span>
  <span class="s1">} </span><span class="s4">else if </span><span class="s1">(</span><span class="s4">typeof </span><span class="s2">state</span><span class="s1">.</span><span class="s2">sortKeys </span><span class="s1">=== </span><span class="s0">'function'</span><span class="s1">) {</span>
    <span class="s3">// Custom sort function</span>
    <span class="s2">objectKeyList</span><span class="s1">.</span><span class="s2">sort</span><span class="s1">(</span><span class="s2">state</span><span class="s1">.</span><span class="s2">sortKeys</span><span class="s1">);</span>
  <span class="s1">} </span><span class="s4">else if </span><span class="s1">(</span><span class="s2">state</span><span class="s1">.</span><span class="s2">sortKeys</span><span class="s1">) {</span>
    <span class="s3">// Something is wrong</span>
    <span class="s4">throw new </span><span class="s2">YAMLException</span><span class="s1">(</span><span class="s0">'sortKeys must be a boolean or a function'</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s4">for </span><span class="s1">(</span><span class="s2">index </span><span class="s1">= </span><span class="s5">0</span><span class="s1">, </span><span class="s2">length </span><span class="s1">= </span><span class="s2">objectKeyList</span><span class="s1">.</span><span class="s2">length</span><span class="s1">; </span><span class="s2">index </span><span class="s1">&lt; </span><span class="s2">length</span><span class="s1">; </span><span class="s2">index </span><span class="s1">+= </span><span class="s5">1</span><span class="s1">) {</span>
    <span class="s2">pairBuffer </span><span class="s1">= </span><span class="s0">''</span><span class="s1">;</span>

    <span class="s4">if </span><span class="s1">(!</span><span class="s2">compact </span><span class="s1">|| </span><span class="s2">index </span><span class="s1">!== </span><span class="s5">0</span><span class="s1">) {</span>
      <span class="s2">pairBuffer </span><span class="s1">+= </span><span class="s2">generateNextLine</span><span class="s1">(</span><span class="s2">state</span><span class="s1">, </span><span class="s2">level</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s2">objectKey </span><span class="s1">= </span><span class="s2">objectKeyList</span><span class="s1">[</span><span class="s2">index</span><span class="s1">];</span>
    <span class="s2">objectValue </span><span class="s1">= </span><span class="s2">object</span><span class="s1">[</span><span class="s2">objectKey</span><span class="s1">];</span>

    <span class="s4">if </span><span class="s1">(!</span><span class="s2">writeNode</span><span class="s1">(</span><span class="s2">state</span><span class="s1">, </span><span class="s2">level </span><span class="s1">+ </span><span class="s5">1</span><span class="s1">, </span><span class="s2">objectKey</span><span class="s1">, </span><span class="s4">true</span><span class="s1">, </span><span class="s4">true</span><span class="s1">, </span><span class="s4">true</span><span class="s1">)) {</span>
      <span class="s4">continue</span><span class="s1">; </span><span class="s3">// Skip this pair because of invalid key.</span>
    <span class="s1">}</span>

    <span class="s2">explicitPair </span><span class="s1">= (</span><span class="s2">state</span><span class="s1">.</span><span class="s2">tag </span><span class="s1">!== </span><span class="s4">null </span><span class="s1">&amp;&amp; </span><span class="s2">state</span><span class="s1">.</span><span class="s2">tag </span><span class="s1">!== </span><span class="s0">'?'</span><span class="s1">) ||</span>
                   <span class="s1">(</span><span class="s2">state</span><span class="s1">.</span><span class="s2">dump </span><span class="s1">&amp;&amp; </span><span class="s2">state</span><span class="s1">.</span><span class="s2">dump</span><span class="s1">.</span><span class="s2">length </span><span class="s1">&gt; </span><span class="s5">1024</span><span class="s1">);</span>

    <span class="s4">if </span><span class="s1">(</span><span class="s2">explicitPair</span><span class="s1">) {</span>
      <span class="s4">if </span><span class="s1">(</span><span class="s2">state</span><span class="s1">.</span><span class="s2">dump </span><span class="s1">&amp;&amp; </span><span class="s2">CHAR_LINE_FEED </span><span class="s1">=== </span><span class="s2">state</span><span class="s1">.</span><span class="s2">dump</span><span class="s1">.</span><span class="s2">charCodeAt</span><span class="s1">(</span><span class="s5">0</span><span class="s1">)) {</span>
        <span class="s2">pairBuffer </span><span class="s1">+= </span><span class="s0">'?'</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
        <span class="s2">pairBuffer </span><span class="s1">+= </span><span class="s0">'? '</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">pairBuffer </span><span class="s1">+= </span><span class="s2">state</span><span class="s1">.</span><span class="s2">dump</span><span class="s1">;</span>

    <span class="s4">if </span><span class="s1">(</span><span class="s2">explicitPair</span><span class="s1">) {</span>
      <span class="s2">pairBuffer </span><span class="s1">+= </span><span class="s2">generateNextLine</span><span class="s1">(</span><span class="s2">state</span><span class="s1">, </span><span class="s2">level</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s4">if </span><span class="s1">(!</span><span class="s2">writeNode</span><span class="s1">(</span><span class="s2">state</span><span class="s1">, </span><span class="s2">level </span><span class="s1">+ </span><span class="s5">1</span><span class="s1">, </span><span class="s2">objectValue</span><span class="s1">, </span><span class="s4">true</span><span class="s1">, </span><span class="s2">explicitPair</span><span class="s1">)) {</span>
      <span class="s4">continue</span><span class="s1">; </span><span class="s3">// Skip this pair because of invalid value.</span>
    <span class="s1">}</span>

    <span class="s4">if </span><span class="s1">(</span><span class="s2">state</span><span class="s1">.</span><span class="s2">dump </span><span class="s1">&amp;&amp; </span><span class="s2">CHAR_LINE_FEED </span><span class="s1">=== </span><span class="s2">state</span><span class="s1">.</span><span class="s2">dump</span><span class="s1">.</span><span class="s2">charCodeAt</span><span class="s1">(</span><span class="s5">0</span><span class="s1">)) {</span>
      <span class="s2">pairBuffer </span><span class="s1">+= </span><span class="s0">':'</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
      <span class="s2">pairBuffer </span><span class="s1">+= </span><span class="s0">': '</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">pairBuffer </span><span class="s1">+= </span><span class="s2">state</span><span class="s1">.</span><span class="s2">dump</span><span class="s1">;</span>

    <span class="s3">// Both key and value are valid.</span>
    <span class="s2">_result </span><span class="s1">+= </span><span class="s2">pairBuffer</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">state</span><span class="s1">.</span><span class="s2">tag </span><span class="s1">= </span><span class="s2">_tag</span><span class="s1">;</span>
  <span class="s2">state</span><span class="s1">.</span><span class="s2">dump </span><span class="s1">= </span><span class="s2">_result </span><span class="s1">|| </span><span class="s0">'{}'</span><span class="s1">; </span><span class="s3">// Empty mapping if no valid pairs.</span>
<span class="s1">}</span>

<span class="s4">function </span><span class="s2">detectType</span><span class="s1">(</span><span class="s2">state</span><span class="s1">, </span><span class="s2">object</span><span class="s1">, </span><span class="s2">explicit</span><span class="s1">) {</span>
  <span class="s4">var </span><span class="s2">_result</span><span class="s1">, </span><span class="s2">typeList</span><span class="s1">, </span><span class="s2">index</span><span class="s1">, </span><span class="s2">length</span><span class="s1">, </span><span class="s2">type</span><span class="s1">, </span><span class="s2">style</span><span class="s1">;</span>

  <span class="s2">typeList </span><span class="s1">= </span><span class="s2">explicit </span><span class="s1">? </span><span class="s2">state</span><span class="s1">.</span><span class="s2">explicitTypes </span><span class="s1">: </span><span class="s2">state</span><span class="s1">.</span><span class="s2">implicitTypes</span><span class="s1">;</span>

  <span class="s4">for </span><span class="s1">(</span><span class="s2">index </span><span class="s1">= </span><span class="s5">0</span><span class="s1">, </span><span class="s2">length </span><span class="s1">= </span><span class="s2">typeList</span><span class="s1">.</span><span class="s2">length</span><span class="s1">; </span><span class="s2">index </span><span class="s1">&lt; </span><span class="s2">length</span><span class="s1">; </span><span class="s2">index </span><span class="s1">+= </span><span class="s5">1</span><span class="s1">) {</span>
    <span class="s2">type </span><span class="s1">= </span><span class="s2">typeList</span><span class="s1">[</span><span class="s2">index</span><span class="s1">];</span>

    <span class="s4">if </span><span class="s1">((</span><span class="s2">type</span><span class="s1">.</span><span class="s2">instanceOf  </span><span class="s1">|| </span><span class="s2">type</span><span class="s1">.</span><span class="s2">predicate</span><span class="s1">) &amp;&amp;</span>
        <span class="s1">(!</span><span class="s2">type</span><span class="s1">.</span><span class="s2">instanceOf </span><span class="s1">|| ((</span><span class="s4">typeof </span><span class="s2">object </span><span class="s1">=== </span><span class="s0">'object'</span><span class="s1">) &amp;&amp; (</span><span class="s2">object </span><span class="s4">instanceof </span><span class="s2">type</span><span class="s1">.</span><span class="s2">instanceOf</span><span class="s1">))) &amp;&amp;</span>
        <span class="s1">(!</span><span class="s2">type</span><span class="s1">.</span><span class="s2">predicate  </span><span class="s1">|| </span><span class="s2">type</span><span class="s1">.</span><span class="s2">predicate</span><span class="s1">(</span><span class="s2">object</span><span class="s1">))) {</span>

      <span class="s2">state</span><span class="s1">.</span><span class="s2">tag </span><span class="s1">= </span><span class="s2">explicit </span><span class="s1">? </span><span class="s2">type</span><span class="s1">.</span><span class="s2">tag </span><span class="s1">: </span><span class="s0">'?'</span><span class="s1">;</span>

      <span class="s4">if </span><span class="s1">(</span><span class="s2">type</span><span class="s1">.</span><span class="s2">represent</span><span class="s1">) {</span>
        <span class="s2">style </span><span class="s1">= </span><span class="s2">state</span><span class="s1">.</span><span class="s2">styleMap</span><span class="s1">[</span><span class="s2">type</span><span class="s1">.</span><span class="s2">tag</span><span class="s1">] || </span><span class="s2">type</span><span class="s1">.</span><span class="s2">defaultStyle</span><span class="s1">;</span>

        <span class="s4">if </span><span class="s1">(</span><span class="s2">_toString</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s2">type</span><span class="s1">.</span><span class="s2">represent</span><span class="s1">) === </span><span class="s0">'[object Function]'</span><span class="s1">) {</span>
          <span class="s2">_result </span><span class="s1">= </span><span class="s2">type</span><span class="s1">.</span><span class="s2">represent</span><span class="s1">(</span><span class="s2">object</span><span class="s1">, </span><span class="s2">style</span><span class="s1">);</span>
        <span class="s1">} </span><span class="s4">else if </span><span class="s1">(</span><span class="s2">_hasOwnProperty</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s2">type</span><span class="s1">.</span><span class="s2">represent</span><span class="s1">, </span><span class="s2">style</span><span class="s1">)) {</span>
          <span class="s2">_result </span><span class="s1">= </span><span class="s2">type</span><span class="s1">.</span><span class="s2">represent</span><span class="s1">[</span><span class="s2">style</span><span class="s1">](</span><span class="s2">object</span><span class="s1">, </span><span class="s2">style</span><span class="s1">);</span>
        <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
          <span class="s4">throw new </span><span class="s2">YAMLException</span><span class="s1">(</span><span class="s0">'!&lt;' </span><span class="s1">+ </span><span class="s2">type</span><span class="s1">.</span><span class="s2">tag </span><span class="s1">+ </span><span class="s0">'&gt; tag resolver accepts not &quot;' </span><span class="s1">+ </span><span class="s2">style </span><span class="s1">+ </span><span class="s0">'&quot; style'</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s2">state</span><span class="s1">.</span><span class="s2">dump </span><span class="s1">= </span><span class="s2">_result</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s4">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s4">return false</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">// Serializes `object` and writes it to global `result`.</span>
<span class="s3">// Returns true on success, or false on invalid object.</span>
<span class="s3">//</span>
<span class="s4">function </span><span class="s2">writeNode</span><span class="s1">(</span><span class="s2">state</span><span class="s1">, </span><span class="s2">level</span><span class="s1">, </span><span class="s2">object</span><span class="s1">, </span><span class="s2">block</span><span class="s1">, </span><span class="s2">compact</span><span class="s1">, </span><span class="s2">iskey</span><span class="s1">) {</span>
  <span class="s2">state</span><span class="s1">.</span><span class="s2">tag </span><span class="s1">= </span><span class="s4">null</span><span class="s1">;</span>
  <span class="s2">state</span><span class="s1">.</span><span class="s2">dump </span><span class="s1">= </span><span class="s2">object</span><span class="s1">;</span>

  <span class="s4">if </span><span class="s1">(!</span><span class="s2">detectType</span><span class="s1">(</span><span class="s2">state</span><span class="s1">, </span><span class="s2">object</span><span class="s1">, </span><span class="s4">false</span><span class="s1">)) {</span>
    <span class="s2">detectType</span><span class="s1">(</span><span class="s2">state</span><span class="s1">, </span><span class="s2">object</span><span class="s1">, </span><span class="s4">true</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s4">var </span><span class="s2">type </span><span class="s1">= </span><span class="s2">_toString</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s2">state</span><span class="s1">.</span><span class="s2">dump</span><span class="s1">);</span>

  <span class="s4">if </span><span class="s1">(</span><span class="s2">block</span><span class="s1">) {</span>
    <span class="s2">block </span><span class="s1">= (</span><span class="s2">state</span><span class="s1">.</span><span class="s2">flowLevel </span><span class="s1">&lt; </span><span class="s5">0 </span><span class="s1">|| </span><span class="s2">state</span><span class="s1">.</span><span class="s2">flowLevel </span><span class="s1">&gt; </span><span class="s2">level</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s4">var </span><span class="s2">objectOrArray </span><span class="s1">= </span><span class="s2">type </span><span class="s1">=== </span><span class="s0">'[object Object]' </span><span class="s1">|| </span><span class="s2">type </span><span class="s1">=== </span><span class="s0">'[object Array]'</span><span class="s1">,</span>
      <span class="s2">duplicateIndex</span><span class="s1">,</span>
      <span class="s2">duplicate</span><span class="s1">;</span>

  <span class="s4">if </span><span class="s1">(</span><span class="s2">objectOrArray</span><span class="s1">) {</span>
    <span class="s2">duplicateIndex </span><span class="s1">= </span><span class="s2">state</span><span class="s1">.</span><span class="s2">duplicates</span><span class="s1">.</span><span class="s2">indexOf</span><span class="s1">(</span><span class="s2">object</span><span class="s1">);</span>
    <span class="s2">duplicate </span><span class="s1">= </span><span class="s2">duplicateIndex </span><span class="s1">!== -</span><span class="s5">1</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">((</span><span class="s2">state</span><span class="s1">.</span><span class="s2">tag </span><span class="s1">!== </span><span class="s4">null </span><span class="s1">&amp;&amp; </span><span class="s2">state</span><span class="s1">.</span><span class="s2">tag </span><span class="s1">!== </span><span class="s0">'?'</span><span class="s1">) || </span><span class="s2">duplicate </span><span class="s1">|| (</span><span class="s2">state</span><span class="s1">.</span><span class="s2">indent </span><span class="s1">!== </span><span class="s5">2 </span><span class="s1">&amp;&amp; </span><span class="s2">level </span><span class="s1">&gt; </span><span class="s5">0</span><span class="s1">)) {</span>
    <span class="s2">compact </span><span class="s1">= </span><span class="s4">false</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(</span><span class="s2">duplicate </span><span class="s1">&amp;&amp; </span><span class="s2">state</span><span class="s1">.</span><span class="s2">usedDuplicates</span><span class="s1">[</span><span class="s2">duplicateIndex</span><span class="s1">]) {</span>
    <span class="s2">state</span><span class="s1">.</span><span class="s2">dump </span><span class="s1">= </span><span class="s0">'*ref_' </span><span class="s1">+ </span><span class="s2">duplicateIndex</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
    <span class="s4">if </span><span class="s1">(</span><span class="s2">objectOrArray </span><span class="s1">&amp;&amp; </span><span class="s2">duplicate </span><span class="s1">&amp;&amp; !</span><span class="s2">state</span><span class="s1">.</span><span class="s2">usedDuplicates</span><span class="s1">[</span><span class="s2">duplicateIndex</span><span class="s1">]) {</span>
      <span class="s2">state</span><span class="s1">.</span><span class="s2">usedDuplicates</span><span class="s1">[</span><span class="s2">duplicateIndex</span><span class="s1">] = </span><span class="s4">true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s4">if </span><span class="s1">(</span><span class="s2">type </span><span class="s1">=== </span><span class="s0">'[object Object]'</span><span class="s1">) {</span>
      <span class="s4">if </span><span class="s1">(</span><span class="s2">block </span><span class="s1">&amp;&amp; (</span><span class="s2">Object</span><span class="s1">.</span><span class="s2">keys</span><span class="s1">(</span><span class="s2">state</span><span class="s1">.</span><span class="s2">dump</span><span class="s1">).</span><span class="s2">length </span><span class="s1">!== </span><span class="s5">0</span><span class="s1">)) {</span>
        <span class="s2">writeBlockMapping</span><span class="s1">(</span><span class="s2">state</span><span class="s1">, </span><span class="s2">level</span><span class="s1">, </span><span class="s2">state</span><span class="s1">.</span><span class="s2">dump</span><span class="s1">, </span><span class="s2">compact</span><span class="s1">);</span>
        <span class="s4">if </span><span class="s1">(</span><span class="s2">duplicate</span><span class="s1">) {</span>
          <span class="s2">state</span><span class="s1">.</span><span class="s2">dump </span><span class="s1">= </span><span class="s0">'&amp;ref_' </span><span class="s1">+ </span><span class="s2">duplicateIndex </span><span class="s1">+ </span><span class="s2">state</span><span class="s1">.</span><span class="s2">dump</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
        <span class="s2">writeFlowMapping</span><span class="s1">(</span><span class="s2">state</span><span class="s1">, </span><span class="s2">level</span><span class="s1">, </span><span class="s2">state</span><span class="s1">.</span><span class="s2">dump</span><span class="s1">);</span>
        <span class="s4">if </span><span class="s1">(</span><span class="s2">duplicate</span><span class="s1">) {</span>
          <span class="s2">state</span><span class="s1">.</span><span class="s2">dump </span><span class="s1">= </span><span class="s0">'&amp;ref_' </span><span class="s1">+ </span><span class="s2">duplicateIndex </span><span class="s1">+ </span><span class="s0">' ' </span><span class="s1">+ </span><span class="s2">state</span><span class="s1">.</span><span class="s2">dump</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s4">else if </span><span class="s1">(</span><span class="s2">type </span><span class="s1">=== </span><span class="s0">'[object Array]'</span><span class="s1">) {</span>
      <span class="s4">var </span><span class="s2">arrayLevel </span><span class="s1">= (</span><span class="s2">state</span><span class="s1">.</span><span class="s2">noArrayIndent </span><span class="s1">&amp;&amp; (</span><span class="s2">level </span><span class="s1">&gt; </span><span class="s5">0</span><span class="s1">)) ? </span><span class="s2">level </span><span class="s1">- </span><span class="s5">1 </span><span class="s1">: </span><span class="s2">level</span><span class="s1">;</span>
      <span class="s4">if </span><span class="s1">(</span><span class="s2">block </span><span class="s1">&amp;&amp; (</span><span class="s2">state</span><span class="s1">.</span><span class="s2">dump</span><span class="s1">.</span><span class="s2">length </span><span class="s1">!== </span><span class="s5">0</span><span class="s1">)) {</span>
        <span class="s2">writeBlockSequence</span><span class="s1">(</span><span class="s2">state</span><span class="s1">, </span><span class="s2">arrayLevel</span><span class="s1">, </span><span class="s2">state</span><span class="s1">.</span><span class="s2">dump</span><span class="s1">, </span><span class="s2">compact</span><span class="s1">);</span>
        <span class="s4">if </span><span class="s1">(</span><span class="s2">duplicate</span><span class="s1">) {</span>
          <span class="s2">state</span><span class="s1">.</span><span class="s2">dump </span><span class="s1">= </span><span class="s0">'&amp;ref_' </span><span class="s1">+ </span><span class="s2">duplicateIndex </span><span class="s1">+ </span><span class="s2">state</span><span class="s1">.</span><span class="s2">dump</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
        <span class="s2">writeFlowSequence</span><span class="s1">(</span><span class="s2">state</span><span class="s1">, </span><span class="s2">arrayLevel</span><span class="s1">, </span><span class="s2">state</span><span class="s1">.</span><span class="s2">dump</span><span class="s1">);</span>
        <span class="s4">if </span><span class="s1">(</span><span class="s2">duplicate</span><span class="s1">) {</span>
          <span class="s2">state</span><span class="s1">.</span><span class="s2">dump </span><span class="s1">= </span><span class="s0">'&amp;ref_' </span><span class="s1">+ </span><span class="s2">duplicateIndex </span><span class="s1">+ </span><span class="s0">' ' </span><span class="s1">+ </span><span class="s2">state</span><span class="s1">.</span><span class="s2">dump</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s4">else if </span><span class="s1">(</span><span class="s2">type </span><span class="s1">=== </span><span class="s0">'[object String]'</span><span class="s1">) {</span>
      <span class="s4">if </span><span class="s1">(</span><span class="s2">state</span><span class="s1">.</span><span class="s2">tag </span><span class="s1">!== </span><span class="s0">'?'</span><span class="s1">) {</span>
        <span class="s2">writeScalar</span><span class="s1">(</span><span class="s2">state</span><span class="s1">, </span><span class="s2">state</span><span class="s1">.</span><span class="s2">dump</span><span class="s1">, </span><span class="s2">level</span><span class="s1">, </span><span class="s2">iskey</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
      <span class="s4">if </span><span class="s1">(</span><span class="s2">state</span><span class="s1">.</span><span class="s2">skipInvalid</span><span class="s1">) </span><span class="s4">return false</span><span class="s1">;</span>
      <span class="s4">throw new </span><span class="s2">YAMLException</span><span class="s1">(</span><span class="s0">'unacceptable kind of an object to dump ' </span><span class="s1">+ </span><span class="s2">type</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s4">if </span><span class="s1">(</span><span class="s2">state</span><span class="s1">.</span><span class="s2">tag </span><span class="s1">!== </span><span class="s4">null </span><span class="s1">&amp;&amp; </span><span class="s2">state</span><span class="s1">.</span><span class="s2">tag </span><span class="s1">!== </span><span class="s0">'?'</span><span class="s1">) {</span>
      <span class="s2">state</span><span class="s1">.</span><span class="s2">dump </span><span class="s1">= </span><span class="s0">'!&lt;' </span><span class="s1">+ </span><span class="s2">state</span><span class="s1">.</span><span class="s2">tag </span><span class="s1">+ </span><span class="s0">'&gt; ' </span><span class="s1">+ </span><span class="s2">state</span><span class="s1">.</span><span class="s2">dump</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s4">return true</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s4">function </span><span class="s2">getDuplicateReferences</span><span class="s1">(</span><span class="s2">object</span><span class="s1">, </span><span class="s2">state</span><span class="s1">) {</span>
  <span class="s4">var </span><span class="s2">objects </span><span class="s1">= [],</span>
      <span class="s2">duplicatesIndexes </span><span class="s1">= [],</span>
      <span class="s2">index</span><span class="s1">,</span>
      <span class="s2">length</span><span class="s1">;</span>

  <span class="s2">inspectNode</span><span class="s1">(</span><span class="s2">object</span><span class="s1">, </span><span class="s2">objects</span><span class="s1">, </span><span class="s2">duplicatesIndexes</span><span class="s1">);</span>

  <span class="s4">for </span><span class="s1">(</span><span class="s2">index </span><span class="s1">= </span><span class="s5">0</span><span class="s1">, </span><span class="s2">length </span><span class="s1">= </span><span class="s2">duplicatesIndexes</span><span class="s1">.</span><span class="s2">length</span><span class="s1">; </span><span class="s2">index </span><span class="s1">&lt; </span><span class="s2">length</span><span class="s1">; </span><span class="s2">index </span><span class="s1">+= </span><span class="s5">1</span><span class="s1">) {</span>
    <span class="s2">state</span><span class="s1">.</span><span class="s2">duplicates</span><span class="s1">.</span><span class="s2">push</span><span class="s1">(</span><span class="s2">objects</span><span class="s1">[</span><span class="s2">duplicatesIndexes</span><span class="s1">[</span><span class="s2">index</span><span class="s1">]]);</span>
  <span class="s1">}</span>
  <span class="s2">state</span><span class="s1">.</span><span class="s2">usedDuplicates </span><span class="s1">= </span><span class="s4">new </span><span class="s2">Array</span><span class="s1">(</span><span class="s2">length</span><span class="s1">);</span>
<span class="s1">}</span>

<span class="s4">function </span><span class="s2">inspectNode</span><span class="s1">(</span><span class="s2">object</span><span class="s1">, </span><span class="s2">objects</span><span class="s1">, </span><span class="s2">duplicatesIndexes</span><span class="s1">) {</span>
  <span class="s4">var </span><span class="s2">objectKeyList</span><span class="s1">,</span>
      <span class="s2">index</span><span class="s1">,</span>
      <span class="s2">length</span><span class="s1">;</span>

  <span class="s4">if </span><span class="s1">(</span><span class="s2">object </span><span class="s1">!== </span><span class="s4">null </span><span class="s1">&amp;&amp; </span><span class="s4">typeof </span><span class="s2">object </span><span class="s1">=== </span><span class="s0">'object'</span><span class="s1">) {</span>
    <span class="s2">index </span><span class="s1">= </span><span class="s2">objects</span><span class="s1">.</span><span class="s2">indexOf</span><span class="s1">(</span><span class="s2">object</span><span class="s1">);</span>
    <span class="s4">if </span><span class="s1">(</span><span class="s2">index </span><span class="s1">!== -</span><span class="s5">1</span><span class="s1">) {</span>
      <span class="s4">if </span><span class="s1">(</span><span class="s2">duplicatesIndexes</span><span class="s1">.</span><span class="s2">indexOf</span><span class="s1">(</span><span class="s2">index</span><span class="s1">) === -</span><span class="s5">1</span><span class="s1">) {</span>
        <span class="s2">duplicatesIndexes</span><span class="s1">.</span><span class="s2">push</span><span class="s1">(</span><span class="s2">index</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
      <span class="s2">objects</span><span class="s1">.</span><span class="s2">push</span><span class="s1">(</span><span class="s2">object</span><span class="s1">);</span>

      <span class="s4">if </span><span class="s1">(</span><span class="s2">Array</span><span class="s1">.</span><span class="s2">isArray</span><span class="s1">(</span><span class="s2">object</span><span class="s1">)) {</span>
        <span class="s4">for </span><span class="s1">(</span><span class="s2">index </span><span class="s1">= </span><span class="s5">0</span><span class="s1">, </span><span class="s2">length </span><span class="s1">= </span><span class="s2">object</span><span class="s1">.</span><span class="s2">length</span><span class="s1">; </span><span class="s2">index </span><span class="s1">&lt; </span><span class="s2">length</span><span class="s1">; </span><span class="s2">index </span><span class="s1">+= </span><span class="s5">1</span><span class="s1">) {</span>
          <span class="s2">inspectNode</span><span class="s1">(</span><span class="s2">object</span><span class="s1">[</span><span class="s2">index</span><span class="s1">], </span><span class="s2">objects</span><span class="s1">, </span><span class="s2">duplicatesIndexes</span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
        <span class="s2">objectKeyList </span><span class="s1">= </span><span class="s2">Object</span><span class="s1">.</span><span class="s2">keys</span><span class="s1">(</span><span class="s2">object</span><span class="s1">);</span>

        <span class="s4">for </span><span class="s1">(</span><span class="s2">index </span><span class="s1">= </span><span class="s5">0</span><span class="s1">, </span><span class="s2">length </span><span class="s1">= </span><span class="s2">objectKeyList</span><span class="s1">.</span><span class="s2">length</span><span class="s1">; </span><span class="s2">index </span><span class="s1">&lt; </span><span class="s2">length</span><span class="s1">; </span><span class="s2">index </span><span class="s1">+= </span><span class="s5">1</span><span class="s1">) {</span>
          <span class="s2">inspectNode</span><span class="s1">(</span><span class="s2">object</span><span class="s1">[</span><span class="s2">objectKeyList</span><span class="s1">[</span><span class="s2">index</span><span class="s1">]], </span><span class="s2">objects</span><span class="s1">, </span><span class="s2">duplicatesIndexes</span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s4">function </span><span class="s2">dump</span><span class="s1">(</span><span class="s2">input</span><span class="s1">, </span><span class="s2">options</span><span class="s1">) {</span>
  <span class="s2">options </span><span class="s1">= </span><span class="s2">options </span><span class="s1">|| {};</span>

  <span class="s4">var </span><span class="s2">state </span><span class="s1">= </span><span class="s4">new </span><span class="s2">State</span><span class="s1">(</span><span class="s2">options</span><span class="s1">);</span>

  <span class="s4">if </span><span class="s1">(!</span><span class="s2">state</span><span class="s1">.</span><span class="s2">noRefs</span><span class="s1">) </span><span class="s2">getDuplicateReferences</span><span class="s1">(</span><span class="s2">input</span><span class="s1">, </span><span class="s2">state</span><span class="s1">);</span>

  <span class="s4">if </span><span class="s1">(</span><span class="s2">writeNode</span><span class="s1">(</span><span class="s2">state</span><span class="s1">, </span><span class="s5">0</span><span class="s1">, </span><span class="s2">input</span><span class="s1">, </span><span class="s4">true</span><span class="s1">, </span><span class="s4">true</span><span class="s1">)) </span><span class="s4">return </span><span class="s2">state</span><span class="s1">.</span><span class="s2">dump </span><span class="s1">+ </span><span class="s0">'</span><span class="s4">\n</span><span class="s0">'</span><span class="s1">;</span>

  <span class="s4">return </span><span class="s0">''</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s4">function </span><span class="s2">safeDump</span><span class="s1">(</span><span class="s2">input</span><span class="s1">, </span><span class="s2">options</span><span class="s1">) {</span>
  <span class="s4">return </span><span class="s2">dump</span><span class="s1">(</span><span class="s2">input</span><span class="s1">, </span><span class="s2">common</span><span class="s1">.</span><span class="s2">extend</span><span class="s1">({ </span><span class="s2">schema</span><span class="s1">: </span><span class="s2">DEFAULT_SAFE_SCHEMA </span><span class="s1">}, </span><span class="s2">options</span><span class="s1">));</span>
<span class="s1">}</span>

<span class="s2">module</span><span class="s1">.</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">dump     </span><span class="s1">= </span><span class="s2">dump</span><span class="s1">;</span>
<span class="s2">module</span><span class="s1">.</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">safeDump </span><span class="s1">= </span><span class="s2">safeDump</span><span class="s1">;</span>
</pre>
</body>
</html>