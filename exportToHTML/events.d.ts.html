<html>
<head>
<title>events.d.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #67a37c; font-style: italic;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #bcbec4;}
.s5 { color: #cf8e6d;}
.s6 { color: #7a7e85;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
events.d.ts</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* Much of the Node.js core API is built around an idiomatic asynchronous</span>
 <span class="s0">* event-driven architecture in which certain kinds of objects (called &quot;emitters&quot;)</span>
 <span class="s0">* emit named events that cause `Function` objects (&quot;listeners&quot;) to be called.</span>
 <span class="s0">*</span>
 <span class="s0">* For instance: a `net.Server` object emits an event each time a peer</span>
 <span class="s0">* connects to it; a `fs.ReadStream` emits an event when the file is opened;</span>
 <span class="s0">* a `stream` emits an event whenever data is available to be read.</span>
 <span class="s0">*</span>
 <span class="s0">* All objects that emit events are instances of the `EventEmitter` class. These</span>
 <span class="s0">* objects expose an `eventEmitter.on()` function that allows one or more</span>
 <span class="s0">* functions to be attached to named events emitted by the object. Typically,</span>
 <span class="s0">* event names are camel-cased strings but any valid JavaScript property key</span>
 <span class="s0">* can be used.</span>
 <span class="s0">*</span>
 <span class="s0">* When the `EventEmitter` object emits an event, all of the functions attached</span>
 <span class="s0">* to that specific event are called _synchronously_. Any values returned by the</span>
 <span class="s0">* called listeners are _ignored_ and discarded.</span>
 <span class="s0">*</span>
 <span class="s0">* The following example shows a simple `EventEmitter` instance with a single</span>
 <span class="s0">* listener. The `eventEmitter.on()` method is used to register listeners, while</span>
 <span class="s0">* the `eventEmitter.emit()` method is used to trigger the event.</span>
 <span class="s0">*</span>
 <span class="s0">* ```js</span>
 <span class="s0">* import { EventEmitter } from 'node:events';</span>
 <span class="s0">*</span>
 <span class="s0">* class MyEmitter extends EventEmitter {}</span>
 <span class="s0">*</span>
 <span class="s0">* const myEmitter = new MyEmitter();</span>
 <span class="s0">* myEmitter.on('event', () =&gt; {</span>
 <span class="s0">*   console.log('an event occurred!');</span>
 <span class="s0">* });</span>
 <span class="s0">* myEmitter.emit('event');</span>
 <span class="s0">* ```</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s0">[source](https://github.com/nodejs/node/blob/v22.x/lib/events.js)</span>
 <span class="s0">*/</span>
<span class="s2">declare module </span><span class="s3">&quot;events&quot; </span><span class="s4">{</span>
    <span class="s5">import </span><span class="s4">{ </span><span class="s2">AsyncResource</span><span class="s4">, </span><span class="s2">AsyncResourceOptions </span><span class="s4">} </span><span class="s2">from </span><span class="s3">&quot;node:async_hooks&quot;</span><span class="s4">;</span>
    <span class="s6">// NOTE: This class is in the docs but is **not actually exported** by Node.</span>
    <span class="s6">// If https://github.com/nodejs/node/issues/39903 gets resolved and Node</span>
    <span class="s6">// actually starts exporting the class, uncomment below.</span>
    <span class="s6">// import { EventListener, EventListenerObject } from '__dom-events';</span>
    <span class="s6">// /** The NodeEventTarget is a Node.js-specific extension to EventTarget that emulates a subset of the EventEmitter API. */</span>
    <span class="s6">// interface NodeEventTarget extends EventTarget {</span>
    <span class="s6">//     /**</span>
    <span class="s6">//      * Node.js-specific extension to the `EventTarget` class that emulates the equivalent `EventEmitter` API.</span>
    <span class="s6">//      * The only difference between `addListener()` and `addEventListener()` is that addListener() will return a reference to the EventTarget.</span>
    <span class="s6">//      */</span>
    <span class="s6">//     addListener(type: string, listener: EventListener | EventListenerObject, options?: { once: boolean }): this;</span>
    <span class="s6">//     /** Node.js-specific extension to the `EventTarget` class that returns an array of event `type` names for which event listeners are registered. */</span>
    <span class="s6">//     eventNames(): string[];</span>
    <span class="s6">//     /** Node.js-specific extension to the `EventTarget` class that returns the number of event listeners registered for the `type`. */</span>
    <span class="s6">//     listenerCount(type: string): number;</span>
    <span class="s6">//     /** Node.js-specific alias for `eventTarget.removeListener()`. */</span>
    <span class="s6">//     off(type: string, listener: EventListener | EventListenerObject): this;</span>
    <span class="s6">//     /** Node.js-specific alias for `eventTarget.addListener()`. */</span>
    <span class="s6">//     on(type: string, listener: EventListener | EventListenerObject, options?: { once: boolean }): this;</span>
    <span class="s6">//     /** Node.js-specific extension to the `EventTarget` class that adds a `once` listener for the given event `type`. This is equivalent to calling `on` with the `once` option set to `true`. */</span>
    <span class="s6">//     once(type: string, listener: EventListener | EventListenerObject): this;</span>
    <span class="s6">//     /**</span>
    <span class="s6">//      * Node.js-specific extension to the `EventTarget` class.</span>
    <span class="s6">//      * If `type` is specified, removes all registered listeners for `type`,</span>
    <span class="s6">//      * otherwise removes all registered listeners.</span>
    <span class="s6">//      */</span>
    <span class="s6">//     removeAllListeners(type: string): this;</span>
    <span class="s6">//     /**</span>
    <span class="s6">//      * Node.js-specific extension to the `EventTarget` class that removes the listener for the given `type`.</span>
    <span class="s6">//      * The only difference between `removeListener()` and `removeEventListener()` is that `removeListener()` will return a reference to the `EventTarget`.</span>
    <span class="s6">//      */</span>
    <span class="s6">//     removeListener(type: string, listener: EventListener | EventListenerObject): this;</span>
    <span class="s6">// }</span>
    <span class="s5">interface </span><span class="s2">EventEmitterOptions </span><span class="s4">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Enables automatic capturing of promise rejection.</span>
         <span class="s0">*/</span>
        <span class="s2">captureRejections</span><span class="s4">?: </span><span class="s2">boolean </span><span class="s4">| </span><span class="s2">undefined</span><span class="s4">;</span>
    <span class="s4">}</span>
    <span class="s5">interface </span><span class="s2">StaticEventEmitterOptions </span><span class="s4">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Can be used to cancel awaiting events.</span>
         <span class="s0">*/</span>
        <span class="s2">signal</span><span class="s4">?: </span><span class="s2">AbortSignal </span><span class="s4">| </span><span class="s2">undefined</span><span class="s4">;</span>
    <span class="s4">}</span>
    <span class="s5">interface </span><span class="s2">StaticEventEmitterIteratorOptions </span><span class="s5">extends </span><span class="s2">StaticEventEmitterOptions </span><span class="s4">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Names of events that will end the iteration.</span>
         <span class="s0">*/</span>
        <span class="s2">close</span><span class="s4">?: </span><span class="s2">string</span><span class="s4">[] | </span><span class="s2">undefined</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The high watermark. The emitter is paused every time the size of events being buffered is higher than it.</span>
         <span class="s0">* Supported only on emitters implementing `pause()` and `resume()` methods.</span>
         <span class="s0">* </span><span class="s1">@default </span><span class="s0">Number.MAX_SAFE_INTEGER</span>
         <span class="s0">*/</span>
        <span class="s2">highWaterMark</span><span class="s4">?: </span><span class="s2">number </span><span class="s4">| </span><span class="s2">undefined</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The low watermark. The emitter is resumed every time the size of events being buffered is lower than it.</span>
         <span class="s0">* Supported only on emitters implementing `pause()` and `resume()` methods.</span>
         <span class="s0">* </span><span class="s1">@default </span><span class="s0">1</span>
         <span class="s0">*/</span>
        <span class="s2">lowWaterMark</span><span class="s4">?: </span><span class="s2">number </span><span class="s4">| </span><span class="s2">undefined</span><span class="s4">;</span>
    <span class="s4">}</span>
    <span class="s5">interface </span><span class="s2">EventEmitter</span><span class="s4">&lt;</span><span class="s2">T </span><span class="s5">extends </span><span class="s2">EventMap</span><span class="s4">&lt;</span><span class="s2">T</span><span class="s4">&gt; = </span><span class="s2">DefaultEventMap</span><span class="s4">&gt; </span><span class="s5">extends </span><span class="s2">NodeJS</span><span class="s4">.</span><span class="s2">EventEmitter</span><span class="s4">&lt;</span><span class="s2">T</span><span class="s4">&gt; {}</span>
    <span class="s2">type EventMap</span><span class="s4">&lt;</span><span class="s2">T</span><span class="s4">&gt; = </span><span class="s2">Record</span><span class="s4">&lt;</span><span class="s2">keyof T</span><span class="s4">, </span><span class="s2">any</span><span class="s4">[]&gt; | </span><span class="s2">DefaultEventMap</span><span class="s4">;</span>
    <span class="s2">type DefaultEventMap </span><span class="s4">= [</span><span class="s2">never</span><span class="s4">];</span>
    <span class="s2">type AnyRest </span><span class="s4">= [</span><span class="s2">...args</span><span class="s4">: </span><span class="s2">any</span><span class="s4">[]];</span>
    <span class="s2">type Args</span><span class="s4">&lt;</span><span class="s2">K</span><span class="s4">, </span><span class="s2">T</span><span class="s4">&gt; = </span><span class="s2">T </span><span class="s5">extends </span><span class="s2">DefaultEventMap </span><span class="s4">? </span><span class="s2">AnyRest </span><span class="s4">: (</span>
        <span class="s2">K </span><span class="s5">extends </span><span class="s2">keyof T </span><span class="s4">? </span><span class="s2">T</span><span class="s4">[</span><span class="s2">K</span><span class="s4">] : </span><span class="s2">never</span>
    <span class="s4">);</span>
    <span class="s2">type Key</span><span class="s4">&lt;</span><span class="s2">K</span><span class="s4">, </span><span class="s2">T</span><span class="s4">&gt; = </span><span class="s2">T </span><span class="s5">extends </span><span class="s2">DefaultEventMap </span><span class="s4">? </span><span class="s2">string </span><span class="s4">| </span><span class="s2">symbol </span><span class="s4">: </span><span class="s2">K </span><span class="s4">| </span><span class="s2">keyof T</span><span class="s4">;</span>
    <span class="s2">type Key2</span><span class="s4">&lt;</span><span class="s2">K</span><span class="s4">, </span><span class="s2">T</span><span class="s4">&gt; = </span><span class="s2">T </span><span class="s5">extends </span><span class="s2">DefaultEventMap </span><span class="s4">? </span><span class="s2">string </span><span class="s4">| </span><span class="s2">symbol </span><span class="s4">: </span><span class="s2">K </span><span class="s4">&amp; </span><span class="s2">keyof T</span><span class="s4">;</span>
    <span class="s2">type Listener</span><span class="s4">&lt;</span><span class="s2">K</span><span class="s4">, </span><span class="s2">T</span><span class="s4">, </span><span class="s2">F</span><span class="s4">&gt; = </span><span class="s2">T </span><span class="s5">extends </span><span class="s2">DefaultEventMap </span><span class="s4">? </span><span class="s2">F </span><span class="s4">: (</span>
        <span class="s2">K </span><span class="s5">extends </span><span class="s2">keyof T </span><span class="s4">? (</span>
                <span class="s2">T</span><span class="s4">[</span><span class="s2">K</span><span class="s4">] </span><span class="s5">extends </span><span class="s2">unknown</span><span class="s4">[] ? (</span><span class="s2">...args</span><span class="s4">: </span><span class="s2">T</span><span class="s4">[</span><span class="s2">K</span><span class="s4">]) =&gt; </span><span class="s5">void </span><span class="s4">: </span><span class="s2">never</span>
            <span class="s4">)</span>
            <span class="s4">: </span><span class="s2">never</span>
    <span class="s4">);</span>
    <span class="s2">type Listener1</span><span class="s4">&lt;</span><span class="s2">K</span><span class="s4">, </span><span class="s2">T</span><span class="s4">&gt; = </span><span class="s2">Listener</span><span class="s4">&lt;</span><span class="s2">K</span><span class="s4">, </span><span class="s2">T</span><span class="s4">, (</span><span class="s2">...args</span><span class="s4">: </span><span class="s2">any</span><span class="s4">[]) =&gt; </span><span class="s5">void</span><span class="s4">&gt;;</span>
    <span class="s2">type Listener2</span><span class="s4">&lt;</span><span class="s2">K</span><span class="s4">, </span><span class="s2">T</span><span class="s4">&gt; = </span><span class="s2">Listener</span><span class="s4">&lt;</span><span class="s2">K</span><span class="s4">, </span><span class="s2">T</span><span class="s4">, </span><span class="s2">Function</span><span class="s4">&gt;;</span>

    <span class="s0">/**</span>
     <span class="s0">* The `EventEmitter` class is defined and exposed by the `node:events` module:</span>
     <span class="s0">*</span>
     <span class="s0">* ```js</span>
     <span class="s0">* import { EventEmitter } from 'node:events';</span>
     <span class="s0">* ```</span>
     <span class="s0">*</span>
     <span class="s0">* All `EventEmitter`s emit the event `'newListener'` when new listeners are</span>
     <span class="s0">* added and `'removeListener'` when existing listeners are removed.</span>
     <span class="s0">*</span>
     <span class="s0">* It supports the following option:</span>
     <span class="s0">* </span><span class="s1">@since </span><span class="s0">v0.1.26</span>
     <span class="s0">*/</span>
    <span class="s5">class </span><span class="s2">EventEmitter</span><span class="s4">&lt;</span><span class="s2">T </span><span class="s5">extends </span><span class="s2">EventMap</span><span class="s4">&lt;</span><span class="s2">T</span><span class="s4">&gt; = </span><span class="s2">DefaultEventMap</span><span class="s4">&gt; {</span>
        <span class="s2">constructor</span><span class="s4">(</span><span class="s2">options</span><span class="s4">?: </span><span class="s2">EventEmitterOptions</span><span class="s4">);</span>

        <span class="s4">[</span><span class="s2">EventEmitter</span><span class="s4">.</span><span class="s2">captureRejectionSymbol</span><span class="s4">]?&lt;</span><span class="s2">K</span><span class="s4">&gt;(</span><span class="s2">error</span><span class="s4">: </span><span class="s2">Error</span><span class="s4">, </span><span class="s2">event</span><span class="s4">: </span><span class="s2">Key</span><span class="s4">&lt;</span><span class="s2">K</span><span class="s4">, </span><span class="s2">T</span><span class="s4">&gt;, </span><span class="s2">...args</span><span class="s4">: </span><span class="s2">Args</span><span class="s4">&lt;</span><span class="s2">K</span><span class="s4">, </span><span class="s2">T</span><span class="s4">&gt;): </span><span class="s5">void</span><span class="s4">;</span>

        <span class="s0">/**</span>
         <span class="s0">* Creates a `Promise` that is fulfilled when the `EventEmitter` emits the given</span>
         <span class="s0">* event or that is rejected if the `EventEmitter` emits `'error'` while waiting.</span>
         <span class="s0">* The `Promise` will resolve with an array of all the arguments emitted to the</span>
         <span class="s0">* given event.</span>
         <span class="s0">*</span>
         <span class="s0">* This method is intentionally generic and works with the web platform [EventTarget](https://dom.spec.whatwg.org/#interface-eventtarget) interface, which has no special`'error'` event</span>
         <span class="s0">* semantics and does not listen to the `'error'` event.</span>
         <span class="s0">*</span>
         <span class="s0">* ```js</span>
         <span class="s0">* import { once, EventEmitter } from 'node:events';</span>
         <span class="s0">* import process from 'node:process';</span>
         <span class="s0">*</span>
         <span class="s0">* const ee = new EventEmitter();</span>
         <span class="s0">*</span>
         <span class="s0">* process.nextTick(() =&gt; {</span>
         <span class="s0">*   ee.emit('myevent', 42);</span>
         <span class="s0">* });</span>
         <span class="s0">*</span>
         <span class="s0">* const [value] = await once(ee, 'myevent');</span>
         <span class="s0">* console.log(value);</span>
         <span class="s0">*</span>
         <span class="s0">* const err = new Error('kaboom');</span>
         <span class="s0">* process.nextTick(() =&gt; {</span>
         <span class="s0">*   ee.emit('error', err);</span>
         <span class="s0">* });</span>
         <span class="s0">*</span>
         <span class="s0">* try {</span>
         <span class="s0">*   await once(ee, 'myevent');</span>
         <span class="s0">* } catch (err) {</span>
         <span class="s0">*   console.error('error happened', err);</span>
         <span class="s0">* }</span>
         <span class="s0">* ```</span>
         <span class="s0">*</span>
         <span class="s0">* The special handling of the `'error'` event is only used when `events.once()` is used to wait for another event. If `events.once()` is used to wait for the</span>
         <span class="s0">* '`error'` event itself, then it is treated as any other kind of event without</span>
         <span class="s0">* special handling:</span>
         <span class="s0">*</span>
         <span class="s0">* ```js</span>
         <span class="s0">* import { EventEmitter, once } from 'node:events';</span>
         <span class="s0">*</span>
         <span class="s0">* const ee = new EventEmitter();</span>
         <span class="s0">*</span>
         <span class="s0">* once(ee, 'error')</span>
         <span class="s0">*   .then(([err]) =&gt; console.log('ok', err.message))</span>
         <span class="s0">*   .catch((err) =&gt; console.error('error', err.message));</span>
         <span class="s0">*</span>
         <span class="s0">* ee.emit('error', new Error('boom'));</span>
         <span class="s0">*</span>
         <span class="s0">* // Prints: ok boom</span>
         <span class="s0">* ```</span>
         <span class="s0">*</span>
         <span class="s0">* An `AbortSignal` can be used to cancel waiting for the event:</span>
         <span class="s0">*</span>
         <span class="s0">* ```js</span>
         <span class="s0">* import { EventEmitter, once } from 'node:events';</span>
         <span class="s0">*</span>
         <span class="s0">* const ee = new EventEmitter();</span>
         <span class="s0">* const ac = new AbortController();</span>
         <span class="s0">*</span>
         <span class="s0">* async function foo(emitter, event, signal) {</span>
         <span class="s0">*   try {</span>
         <span class="s0">*     await once(emitter, event, { signal });</span>
         <span class="s0">*     console.log('event emitted!');</span>
         <span class="s0">*   } catch (error) {</span>
         <span class="s0">*     if (error.name === 'AbortError') {</span>
         <span class="s0">*       console.error('Waiting for the event was canceled!');</span>
         <span class="s0">*     } else {</span>
         <span class="s0">*       console.error('There was an error', error.message);</span>
         <span class="s0">*     }</span>
         <span class="s0">*   }</span>
         <span class="s0">* }</span>
         <span class="s0">*</span>
         <span class="s0">* foo(ee, 'foo', ac.signal);</span>
         <span class="s0">* ac.abort(); // Abort waiting for the event</span>
         <span class="s0">* ee.emit('foo'); // Prints: Waiting for the event was canceled!</span>
         <span class="s0">* ```</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v11.13.0, v10.16.0</span>
         <span class="s0">*/</span>
        <span class="s5">static </span><span class="s2">once</span><span class="s4">(</span>
            <span class="s2">emitter</span><span class="s4">: </span><span class="s2">NodeJS</span><span class="s4">.</span><span class="s2">EventEmitter</span><span class="s4">,</span>
            <span class="s2">eventName</span><span class="s4">: </span><span class="s2">string </span><span class="s4">| </span><span class="s2">symbol</span><span class="s4">,</span>
            <span class="s2">options</span><span class="s4">?: </span><span class="s2">StaticEventEmitterOptions</span><span class="s4">,</span>
        <span class="s4">): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s2">any</span><span class="s4">[]&gt;;</span>
        <span class="s5">static </span><span class="s2">once</span><span class="s4">(</span><span class="s2">emitter</span><span class="s4">: </span><span class="s2">EventTarget</span><span class="s4">, </span><span class="s2">eventName</span><span class="s4">: </span><span class="s2">string</span><span class="s4">, </span><span class="s2">options</span><span class="s4">?: </span><span class="s2">StaticEventEmitterOptions</span><span class="s4">): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s2">any</span><span class="s4">[]&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* ```js</span>
         <span class="s0">* import { on, EventEmitter } from 'node:events';</span>
         <span class="s0">* import process from 'node:process';</span>
         <span class="s0">*</span>
         <span class="s0">* const ee = new EventEmitter();</span>
         <span class="s0">*</span>
         <span class="s0">* // Emit later on</span>
         <span class="s0">* process.nextTick(() =&gt; {</span>
         <span class="s0">*   ee.emit('foo', 'bar');</span>
         <span class="s0">*   ee.emit('foo', 42);</span>
         <span class="s0">* });</span>
         <span class="s0">*</span>
         <span class="s0">* for await (const event of on(ee, 'foo')) {</span>
         <span class="s0">*   // The execution of this inner block is synchronous and it</span>
         <span class="s0">*   // processes one event at a time (even with await). Do not use</span>
         <span class="s0">*   // if concurrent execution is required.</span>
         <span class="s0">*   console.log(event); // prints ['bar'] [42]</span>
         <span class="s0">* }</span>
         <span class="s0">* // Unreachable here</span>
         <span class="s0">* ```</span>
         <span class="s0">*</span>
         <span class="s0">* Returns an `AsyncIterator` that iterates `eventName` events. It will throw</span>
         <span class="s0">* if the `EventEmitter` emits `'error'`. It removes all listeners when</span>
         <span class="s0">* exiting the loop. The `value` returned by each iteration is an array</span>
         <span class="s0">* composed of the emitted event arguments.</span>
         <span class="s0">*</span>
         <span class="s0">* An `AbortSignal` can be used to cancel waiting on events:</span>
         <span class="s0">*</span>
         <span class="s0">* ```js</span>
         <span class="s0">* import { on, EventEmitter } from 'node:events';</span>
         <span class="s0">* import process from 'node:process';</span>
         <span class="s0">*</span>
         <span class="s0">* const ac = new AbortController();</span>
         <span class="s0">*</span>
         <span class="s0">* (async () =&gt; {</span>
         <span class="s0">*   const ee = new EventEmitter();</span>
         <span class="s0">*</span>
         <span class="s0">*   // Emit later on</span>
         <span class="s0">*   process.nextTick(() =&gt; {</span>
         <span class="s0">*     ee.emit('foo', 'bar');</span>
         <span class="s0">*     ee.emit('foo', 42);</span>
         <span class="s0">*   });</span>
         <span class="s0">*</span>
         <span class="s0">*   for await (const event of on(ee, 'foo', { signal: ac.signal })) {</span>
         <span class="s0">*     // The execution of this inner block is synchronous and it</span>
         <span class="s0">*     // processes one event at a time (even with await). Do not use</span>
         <span class="s0">*     // if concurrent execution is required.</span>
         <span class="s0">*     console.log(event); // prints ['bar'] [42]</span>
         <span class="s0">*   }</span>
         <span class="s0">*   // Unreachable here</span>
         <span class="s0">* })();</span>
         <span class="s0">*</span>
         <span class="s0">* process.nextTick(() =&gt; ac.abort());</span>
         <span class="s0">* ```</span>
         <span class="s0">*</span>
         <span class="s0">* Use the `close` option to specify an array of event names that will end the iteration:</span>
         <span class="s0">*</span>
         <span class="s0">* ```js</span>
         <span class="s0">* import { on, EventEmitter } from 'node:events';</span>
         <span class="s0">* import process from 'node:process';</span>
         <span class="s0">*</span>
         <span class="s0">* const ee = new EventEmitter();</span>
         <span class="s0">*</span>
         <span class="s0">* // Emit later on</span>
         <span class="s0">* process.nextTick(() =&gt; {</span>
         <span class="s0">*   ee.emit('foo', 'bar');</span>
         <span class="s0">*   ee.emit('foo', 42);</span>
         <span class="s0">*   ee.emit('close');</span>
         <span class="s0">* });</span>
         <span class="s0">*</span>
         <span class="s0">* for await (const event of on(ee, 'foo', { close: ['close'] })) {</span>
         <span class="s0">*   console.log(event); // prints ['bar'] [42]</span>
         <span class="s0">* }</span>
         <span class="s0">* // the loop will exit after 'close' is emitted</span>
         <span class="s0">* console.log('done'); // prints 'done'</span>
         <span class="s0">* ```</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v13.6.0, v12.16.0</span>
         <span class="s0">* </span><span class="s1">@return </span><span class="s0">An `AsyncIterator` that iterates `eventName` events emitted by the `emitter`</span>
         <span class="s0">*/</span>
        <span class="s5">static </span><span class="s2">on</span><span class="s4">(</span>
            <span class="s2">emitter</span><span class="s4">: </span><span class="s2">NodeJS</span><span class="s4">.</span><span class="s2">EventEmitter</span><span class="s4">,</span>
            <span class="s2">eventName</span><span class="s4">: </span><span class="s2">string </span><span class="s4">| </span><span class="s2">symbol</span><span class="s4">,</span>
            <span class="s2">options</span><span class="s4">?: </span><span class="s2">StaticEventEmitterIteratorOptions</span><span class="s4">,</span>
        <span class="s4">): </span><span class="s2">NodeJS</span><span class="s4">.</span><span class="s2">AsyncIterator</span><span class="s4">&lt;</span><span class="s2">any</span><span class="s4">[]&gt;;</span>
        <span class="s5">static </span><span class="s2">on</span><span class="s4">(</span>
            <span class="s2">emitter</span><span class="s4">: </span><span class="s2">EventTarget</span><span class="s4">,</span>
            <span class="s2">eventName</span><span class="s4">: </span><span class="s2">string</span><span class="s4">,</span>
            <span class="s2">options</span><span class="s4">?: </span><span class="s2">StaticEventEmitterIteratorOptions</span><span class="s4">,</span>
        <span class="s4">): </span><span class="s2">NodeJS</span><span class="s4">.</span><span class="s2">AsyncIterator</span><span class="s4">&lt;</span><span class="s2">any</span><span class="s4">[]&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* A class method that returns the number of listeners for the given `eventName` registered on the given `emitter`.</span>
         <span class="s0">*</span>
         <span class="s0">* ```js</span>
         <span class="s0">* import { EventEmitter, listenerCount } from 'node:events';</span>
         <span class="s0">*</span>
         <span class="s0">* const myEmitter = new EventEmitter();</span>
         <span class="s0">* myEmitter.on('event', () =&gt; {});</span>
         <span class="s0">* myEmitter.on('event', () =&gt; {});</span>
         <span class="s0">* console.log(listenerCount(myEmitter, 'event'));</span>
         <span class="s0">* // Prints: 2</span>
         <span class="s0">* ```</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v0.9.12</span>
         <span class="s0">* </span><span class="s1">@deprecated </span><span class="s0">Since v3.2.0 - Use `listenerCount` instead.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">emitter The emitter to query</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">eventName The event name</span>
         <span class="s0">*/</span>
        <span class="s5">static </span><span class="s2">listenerCount</span><span class="s4">(</span><span class="s2">emitter</span><span class="s4">: </span><span class="s2">NodeJS</span><span class="s4">.</span><span class="s2">EventEmitter</span><span class="s4">, </span><span class="s2">eventName</span><span class="s4">: </span><span class="s2">string </span><span class="s4">| </span><span class="s2">symbol</span><span class="s4">): </span><span class="s2">number</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Returns a copy of the array of listeners for the event named `eventName`.</span>
         <span class="s0">*</span>
         <span class="s0">* For `EventEmitter`s this behaves exactly the same as calling `.listeners` on</span>
         <span class="s0">* the emitter.</span>
         <span class="s0">*</span>
         <span class="s0">* For `EventTarget`s this is the only way to get the event listeners for the</span>
         <span class="s0">* event target. This is useful for debugging and diagnostic purposes.</span>
         <span class="s0">*</span>
         <span class="s0">* ```js</span>
         <span class="s0">* import { getEventListeners, EventEmitter } from 'node:events';</span>
         <span class="s0">*</span>
         <span class="s0">* {</span>
         <span class="s0">*   const ee = new EventEmitter();</span>
         <span class="s0">*   const listener = () =&gt; console.log('Events are fun');</span>
         <span class="s0">*   ee.on('foo', listener);</span>
         <span class="s0">*   console.log(getEventListeners(ee, 'foo')); // [ [Function: listener] ]</span>
         <span class="s0">* }</span>
         <span class="s0">* {</span>
         <span class="s0">*   const et = new EventTarget();</span>
         <span class="s0">*   const listener = () =&gt; console.log('Events are fun');</span>
         <span class="s0">*   et.addEventListener('foo', listener);</span>
         <span class="s0">*   console.log(getEventListeners(et, 'foo')); // [ [Function: listener] ]</span>
         <span class="s0">* }</span>
         <span class="s0">* ```</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v15.2.0, v14.17.0</span>
         <span class="s0">*/</span>
        <span class="s5">static </span><span class="s2">getEventListeners</span><span class="s4">(</span><span class="s2">emitter</span><span class="s4">: </span><span class="s2">EventTarget </span><span class="s4">| </span><span class="s2">NodeJS</span><span class="s4">.</span><span class="s2">EventEmitter</span><span class="s4">, </span><span class="s2">name</span><span class="s4">: </span><span class="s2">string </span><span class="s4">| </span><span class="s2">symbol</span><span class="s4">): </span><span class="s2">Function</span><span class="s4">[];</span>
        <span class="s0">/**</span>
         <span class="s0">* Returns the currently set max amount of listeners.</span>
         <span class="s0">*</span>
         <span class="s0">* For `EventEmitter`s this behaves exactly the same as calling `.getMaxListeners` on</span>
         <span class="s0">* the emitter.</span>
         <span class="s0">*</span>
         <span class="s0">* For `EventTarget`s this is the only way to get the max event listeners for the</span>
         <span class="s0">* event target. If the number of event handlers on a single EventTarget exceeds</span>
         <span class="s0">* the max set, the EventTarget will print a warning.</span>
         <span class="s0">*</span>
         <span class="s0">* ```js</span>
         <span class="s0">* import { getMaxListeners, setMaxListeners, EventEmitter } from 'node:events';</span>
         <span class="s0">*</span>
         <span class="s0">* {</span>
         <span class="s0">*   const ee = new EventEmitter();</span>
         <span class="s0">*   console.log(getMaxListeners(ee)); // 10</span>
         <span class="s0">*   setMaxListeners(11, ee);</span>
         <span class="s0">*   console.log(getMaxListeners(ee)); // 11</span>
         <span class="s0">* }</span>
         <span class="s0">* {</span>
         <span class="s0">*   const et = new EventTarget();</span>
         <span class="s0">*   console.log(getMaxListeners(et)); // 10</span>
         <span class="s0">*   setMaxListeners(11, et);</span>
         <span class="s0">*   console.log(getMaxListeners(et)); // 11</span>
         <span class="s0">* }</span>
         <span class="s0">* ```</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v19.9.0</span>
         <span class="s0">*/</span>
        <span class="s5">static </span><span class="s2">getMaxListeners</span><span class="s4">(</span><span class="s2">emitter</span><span class="s4">: </span><span class="s2">EventTarget </span><span class="s4">| </span><span class="s2">NodeJS</span><span class="s4">.</span><span class="s2">EventEmitter</span><span class="s4">): </span><span class="s2">number</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* ```js</span>
         <span class="s0">* import { setMaxListeners, EventEmitter } from 'node:events';</span>
         <span class="s0">*</span>
         <span class="s0">* const target = new EventTarget();</span>
         <span class="s0">* const emitter = new EventEmitter();</span>
         <span class="s0">*</span>
         <span class="s0">* setMaxListeners(5, target, emitter);</span>
         <span class="s0">* ```</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v15.4.0</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">n A non-negative number. The maximum number of listeners per `EventTarget` event.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">eventTargets Zero or more {EventTarget} or {EventEmitter} instances. If none are specified, `n` is set as the default max for all newly created {EventTarget} and {EventEmitter}</span>
         <span class="s0">* objects.</span>
         <span class="s0">*/</span>
        <span class="s5">static </span><span class="s2">setMaxListeners</span><span class="s4">(</span><span class="s2">n</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">, </span><span class="s2">...eventTargets</span><span class="s4">: </span><span class="s2">Array</span><span class="s4">&lt;</span><span class="s2">EventTarget </span><span class="s4">| </span><span class="s2">NodeJS</span><span class="s4">.</span><span class="s2">EventEmitter</span><span class="s4">&gt;): </span><span class="s5">void</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Listens once to the `abort` event on the provided `signal`.</span>
         <span class="s0">*</span>
         <span class="s0">* Listening to the `abort` event on abort signals is unsafe and may</span>
         <span class="s0">* lead to resource leaks since another third party with the signal can</span>
         <span class="s0">* call `e.stopImmediatePropagation()`. Unfortunately Node.js cannot change</span>
         <span class="s0">* this since it would violate the web standard. Additionally, the original</span>
         <span class="s0">* API makes it easy to forget to remove listeners.</span>
         <span class="s0">*</span>
         <span class="s0">* This API allows safely using `AbortSignal`s in Node.js APIs by solving these</span>
         <span class="s0">* two issues by listening to the event such that `stopImmediatePropagation` does</span>
         <span class="s0">* not prevent the listener from running.</span>
         <span class="s0">*</span>
         <span class="s0">* Returns a disposable so that it may be unsubscribed from more easily.</span>
         <span class="s0">*</span>
         <span class="s0">* ```js</span>
         <span class="s0">* import { addAbortListener } from 'node:events';</span>
         <span class="s0">*</span>
         <span class="s0">* function example(signal) {</span>
         <span class="s0">*   let disposable;</span>
         <span class="s0">*   try {</span>
         <span class="s0">*     signal.addEventListener('abort', (e) =&gt; e.stopImmediatePropagation());</span>
         <span class="s0">*     disposable = addAbortListener(signal, (e) =&gt; {</span>
         <span class="s0">*       // Do something when signal is aborted.</span>
         <span class="s0">*     });</span>
         <span class="s0">*   } finally {</span>
         <span class="s0">*     disposable?.[Symbol.dispose]();</span>
         <span class="s0">*   }</span>
         <span class="s0">* }</span>
         <span class="s0">* ```</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v20.5.0</span>
         <span class="s0">* </span><span class="s1">@experimental</span>
         <span class="s0">* </span><span class="s1">@return </span><span class="s0">Disposable that removes the `abort` listener.</span>
         <span class="s0">*/</span>
        <span class="s5">static </span><span class="s2">addAbortListener</span><span class="s4">(</span><span class="s2">signal</span><span class="s4">: </span><span class="s2">AbortSignal</span><span class="s4">, </span><span class="s2">resource</span><span class="s4">: (</span><span class="s2">event</span><span class="s4">: </span><span class="s2">Event</span><span class="s4">) =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s2">Disposable</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* This symbol shall be used to install a listener for only monitoring `'error'` events. Listeners installed using this symbol are called before the regular `'error'` listeners are called.</span>
         <span class="s0">*</span>
         <span class="s0">* Installing a listener using this symbol does not change the behavior once an `'error'` event is emitted. Therefore, the process will still crash if no</span>
         <span class="s0">* regular `'error'` listener is installed.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v13.6.0, v12.17.0</span>
         <span class="s0">*/</span>
        <span class="s5">static </span><span class="s2">readonly errorMonitor</span><span class="s4">: </span><span class="s2">unique symbol</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Value: `Symbol.for('nodejs.rejection')`</span>
         <span class="s0">*</span>
         <span class="s0">* See how to write a custom `rejection handler`.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v13.4.0, v12.16.0</span>
         <span class="s0">*/</span>
        <span class="s5">static </span><span class="s2">readonly captureRejectionSymbol</span><span class="s4">: </span><span class="s2">unique symbol</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Value: [boolean](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)</span>
         <span class="s0">*</span>
         <span class="s0">* Change the default `captureRejections` option on all new `EventEmitter` objects.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v13.4.0, v12.16.0</span>
         <span class="s0">*/</span>
        <span class="s5">static </span><span class="s2">captureRejections</span><span class="s4">: </span><span class="s2">boolean</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* By default, a maximum of `10` listeners can be registered for any single</span>
         <span class="s0">* event. This limit can be changed for individual `EventEmitter` instances</span>
         <span class="s0">* using the `emitter.setMaxListeners(n)` method. To change the default</span>
         <span class="s0">* for _all_`EventEmitter` instances, the `events.defaultMaxListeners` property</span>
         <span class="s0">* can be used. If this value is not a positive number, a `RangeError` is thrown.</span>
         <span class="s0">*</span>
         <span class="s0">* Take caution when setting the `events.defaultMaxListeners` because the</span>
         <span class="s0">* change affects _all_ `EventEmitter` instances, including those created before</span>
         <span class="s0">* the change is made. However, calling `emitter.setMaxListeners(n)` still has</span>
         <span class="s0">* precedence over `events.defaultMaxListeners`.</span>
         <span class="s0">*</span>
         <span class="s0">* This is not a hard limit. The `EventEmitter` instance will allow</span>
         <span class="s0">* more listeners to be added but will output a trace warning to stderr indicating</span>
         <span class="s0">* that a &quot;possible EventEmitter memory leak&quot; has been detected. For any single</span>
         <span class="s0">* `EventEmitter`, the `emitter.getMaxListeners()` and `emitter.setMaxListeners()` methods can be used to</span>
         <span class="s0">* temporarily avoid this warning:</span>
         <span class="s0">*</span>
         <span class="s0">* ```js</span>
         <span class="s0">* import { EventEmitter } from 'node:events';</span>
         <span class="s0">* const emitter = new EventEmitter();</span>
         <span class="s0">* emitter.setMaxListeners(emitter.getMaxListeners() + 1);</span>
         <span class="s0">* emitter.once('event', () =&gt; {</span>
         <span class="s0">*   // do stuff</span>
         <span class="s0">*   emitter.setMaxListeners(Math.max(emitter.getMaxListeners() - 1, 0));</span>
         <span class="s0">* });</span>
         <span class="s0">* ```</span>
         <span class="s0">*</span>
         <span class="s0">* The `--trace-warnings` command-line flag can be used to display the</span>
         <span class="s0">* stack trace for such warnings.</span>
         <span class="s0">*</span>
         <span class="s0">* The emitted warning can be inspected with `process.on('warning')` and will</span>
         <span class="s0">* have the additional `emitter`, `type`, and `count` properties, referring to</span>
         <span class="s0">* the event emitter instance, the event's name and the number of attached</span>
         <span class="s0">* listeners, respectively.</span>
         <span class="s0">* Its `name` property is set to `'MaxListenersExceededWarning'`.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v0.11.2</span>
         <span class="s0">*/</span>
        <span class="s5">static </span><span class="s2">defaultMaxListeners</span><span class="s4">: </span><span class="s2">number</span><span class="s4">;</span>
    <span class="s4">}</span>
    <span class="s5">import </span><span class="s2">internal </span><span class="s4">= </span><span class="s2">require</span><span class="s4">(</span><span class="s3">&quot;node:events&quot;</span><span class="s4">);</span>
    <span class="s2">namespace EventEmitter </span><span class="s4">{</span>
        <span class="s6">// Should just be `export { EventEmitter }`, but that doesn't work in TypeScript 3.4</span>
        <span class="s5">export </span><span class="s4">{ </span><span class="s2">internal </span><span class="s4">as </span><span class="s2">EventEmitter </span><span class="s4">};</span>
        <span class="s5">export interface </span><span class="s2">Abortable </span><span class="s4">{</span>
            <span class="s0">/**</span>
             <span class="s0">* When provided the corresponding `AbortController` can be used to cancel an asynchronous action.</span>
             <span class="s0">*/</span>
            <span class="s2">signal</span><span class="s4">?: </span><span class="s2">AbortSignal </span><span class="s4">| </span><span class="s2">undefined</span><span class="s4">;</span>
        <span class="s4">}</span>

        <span class="s5">export interface </span><span class="s2">EventEmitterReferencingAsyncResource </span><span class="s5">extends </span><span class="s2">AsyncResource </span><span class="s4">{</span>
            <span class="s2">readonly eventEmitter</span><span class="s4">: </span><span class="s2">EventEmitterAsyncResource</span><span class="s4">;</span>
        <span class="s4">}</span>

        <span class="s5">export interface </span><span class="s2">EventEmitterAsyncResourceOptions </span><span class="s5">extends </span><span class="s2">AsyncResourceOptions</span><span class="s4">, </span><span class="s2">EventEmitterOptions </span><span class="s4">{</span>
            <span class="s0">/**</span>
             <span class="s0">* The type of async event, this is required when instantiating `EventEmitterAsyncResource`</span>
             <span class="s0">* directly rather than as a child class.</span>
             <span class="s0">* </span><span class="s1">@default </span><span class="s0">new.target.name if instantiated as a child class.</span>
             <span class="s0">*/</span>
            <span class="s2">name</span><span class="s4">?: </span><span class="s2">string</span><span class="s4">;</span>
        <span class="s4">}</span>

        <span class="s0">/**</span>
         <span class="s0">* Integrates `EventEmitter` with `AsyncResource` for `EventEmitter`s that</span>
         <span class="s0">* require manual async tracking. Specifically, all events emitted by instances</span>
         <span class="s0">* of `events.EventEmitterAsyncResource` will run within its `async context`.</span>
         <span class="s0">*</span>
         <span class="s0">* ```js</span>
         <span class="s0">* import { EventEmitterAsyncResource, EventEmitter } from 'node:events';</span>
         <span class="s0">* import { notStrictEqual, strictEqual } from 'node:assert';</span>
         <span class="s0">* import { executionAsyncId, triggerAsyncId } from 'node:async_hooks';</span>
         <span class="s0">*</span>
         <span class="s0">* // Async tracking tooling will identify this as 'Q'.</span>
         <span class="s0">* const ee1 = new EventEmitterAsyncResource({ name: 'Q' });</span>
         <span class="s0">*</span>
         <span class="s0">* // 'foo' listeners will run in the EventEmitters async context.</span>
         <span class="s0">* ee1.on('foo', () =&gt; {</span>
         <span class="s0">*   strictEqual(executionAsyncId(), ee1.asyncId);</span>
         <span class="s0">*   strictEqual(triggerAsyncId(), ee1.triggerAsyncId);</span>
         <span class="s0">* });</span>
         <span class="s0">*</span>
         <span class="s0">* const ee2 = new EventEmitter();</span>
         <span class="s0">*</span>
         <span class="s0">* // 'foo' listeners on ordinary EventEmitters that do not track async</span>
         <span class="s0">* // context, however, run in the same async context as the emit().</span>
         <span class="s0">* ee2.on('foo', () =&gt; {</span>
         <span class="s0">*   notStrictEqual(executionAsyncId(), ee2.asyncId);</span>
         <span class="s0">*   notStrictEqual(triggerAsyncId(), ee2.triggerAsyncId);</span>
         <span class="s0">* });</span>
         <span class="s0">*</span>
         <span class="s0">* Promise.resolve().then(() =&gt; {</span>
         <span class="s0">*   ee1.emit('foo');</span>
         <span class="s0">*   ee2.emit('foo');</span>
         <span class="s0">* });</span>
         <span class="s0">* ```</span>
         <span class="s0">*</span>
         <span class="s0">* The `EventEmitterAsyncResource` class has the same methods and takes the</span>
         <span class="s0">* same options as `EventEmitter` and `AsyncResource` themselves.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v17.4.0, v16.14.0</span>
         <span class="s0">*/</span>
        <span class="s5">export class </span><span class="s2">EventEmitterAsyncResource </span><span class="s5">extends </span><span class="s2">EventEmitter </span><span class="s4">{</span>
            <span class="s0">/**</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">options Only optional in child class.</span>
             <span class="s0">*/</span>
            <span class="s2">constructor</span><span class="s4">(</span><span class="s2">options</span><span class="s4">?: </span><span class="s2">EventEmitterAsyncResourceOptions</span><span class="s4">);</span>
            <span class="s0">/**</span>
             <span class="s0">* Call all `destroy` hooks. This should only ever be called once. An error will</span>
             <span class="s0">* be thrown if it is called more than once. This **must** be manually called. If</span>
             <span class="s0">* the resource is left to be collected by the GC then the `destroy` hooks will</span>
             <span class="s0">* never be called.</span>
             <span class="s0">*/</span>
            <span class="s2">emitDestroy</span><span class="s4">(): </span><span class="s5">void</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* The unique `asyncId` assigned to the resource.</span>
             <span class="s0">*/</span>
            <span class="s2">readonly asyncId</span><span class="s4">: </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* The same triggerAsyncId that is passed to the AsyncResource constructor.</span>
             <span class="s0">*/</span>
            <span class="s2">readonly triggerAsyncId</span><span class="s4">: </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* The returned `AsyncResource` object has an additional `eventEmitter` property</span>
             <span class="s0">* that provides a reference to this `EventEmitterAsyncResource`.</span>
             <span class="s0">*/</span>
            <span class="s2">readonly asyncResource</span><span class="s4">: </span><span class="s2">EventEmitterReferencingAsyncResource</span><span class="s4">;</span>
        <span class="s4">}</span>
    <span class="s4">}</span>
    <span class="s2">global </span><span class="s4">{</span>
        <span class="s2">namespace NodeJS </span><span class="s4">{</span>
            <span class="s5">interface </span><span class="s2">EventEmitter</span><span class="s4">&lt;</span><span class="s2">T </span><span class="s5">extends </span><span class="s2">EventMap</span><span class="s4">&lt;</span><span class="s2">T</span><span class="s4">&gt; = </span><span class="s2">DefaultEventMap</span><span class="s4">&gt; {</span>
                <span class="s4">[</span><span class="s2">EventEmitter</span><span class="s4">.</span><span class="s2">captureRejectionSymbol</span><span class="s4">]?&lt;</span><span class="s2">K</span><span class="s4">&gt;(</span><span class="s2">error</span><span class="s4">: </span><span class="s2">Error</span><span class="s4">, </span><span class="s2">event</span><span class="s4">: </span><span class="s2">Key</span><span class="s4">&lt;</span><span class="s2">K</span><span class="s4">, </span><span class="s2">T</span><span class="s4">&gt;, </span><span class="s2">...args</span><span class="s4">: </span><span class="s2">Args</span><span class="s4">&lt;</span><span class="s2">K</span><span class="s4">, </span><span class="s2">T</span><span class="s4">&gt;): </span><span class="s5">void</span><span class="s4">;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Alias for `emitter.on(eventName, listener)`.</span>
                 <span class="s0">* </span><span class="s1">@since </span><span class="s0">v0.1.26</span>
                 <span class="s0">*/</span>
                <span class="s2">addListener</span><span class="s4">&lt;</span><span class="s2">K</span><span class="s4">&gt;(</span><span class="s2">eventName</span><span class="s4">: </span><span class="s2">Key</span><span class="s4">&lt;</span><span class="s2">K</span><span class="s4">, </span><span class="s2">T</span><span class="s4">&gt;, </span><span class="s2">listener</span><span class="s4">: </span><span class="s2">Listener1</span><span class="s4">&lt;</span><span class="s2">K</span><span class="s4">, </span><span class="s2">T</span><span class="s4">&gt;): </span><span class="s5">this</span><span class="s4">;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Adds the `listener` function to the end of the listeners array for the event</span>
                 <span class="s0">* named `eventName`. No checks are made to see if the `listener` has already</span>
                 <span class="s0">* been added. Multiple calls passing the same combination of `eventName` and</span>
                 <span class="s0">* `listener` will result in the `listener` being added, and called, multiple times.</span>
                 <span class="s0">*</span>
                 <span class="s0">* ```js</span>
                 <span class="s0">* server.on('connection', (stream) =&gt; {</span>
                 <span class="s0">*   console.log('someone connected!');</span>
                 <span class="s0">* });</span>
                 <span class="s0">* ```</span>
                 <span class="s0">*</span>
                 <span class="s0">* Returns a reference to the `EventEmitter`, so that calls can be chained.</span>
                 <span class="s0">*</span>
                 <span class="s0">* By default, event listeners are invoked in the order they are added. The `emitter.prependListener()` method can be used as an alternative to add the</span>
                 <span class="s0">* event listener to the beginning of the listeners array.</span>
                 <span class="s0">*</span>
                 <span class="s0">* ```js</span>
                 <span class="s0">* import { EventEmitter } from 'node:events';</span>
                 <span class="s0">* const myEE = new EventEmitter();</span>
                 <span class="s0">* myEE.on('foo', () =&gt; console.log('a'));</span>
                 <span class="s0">* myEE.prependListener('foo', () =&gt; console.log('b'));</span>
                 <span class="s0">* myEE.emit('foo');</span>
                 <span class="s0">* // Prints:</span>
                 <span class="s0">* //   b</span>
                 <span class="s0">* //   a</span>
                 <span class="s0">* ```</span>
                 <span class="s0">* </span><span class="s1">@since </span><span class="s0">v0.1.101</span>
                 <span class="s0">* </span><span class="s1">@param </span><span class="s0">eventName The name of the event.</span>
                 <span class="s0">* </span><span class="s1">@param </span><span class="s0">listener The callback function</span>
                 <span class="s0">*/</span>
                <span class="s2">on</span><span class="s4">&lt;</span><span class="s2">K</span><span class="s4">&gt;(</span><span class="s2">eventName</span><span class="s4">: </span><span class="s2">Key</span><span class="s4">&lt;</span><span class="s2">K</span><span class="s4">, </span><span class="s2">T</span><span class="s4">&gt;, </span><span class="s2">listener</span><span class="s4">: </span><span class="s2">Listener1</span><span class="s4">&lt;</span><span class="s2">K</span><span class="s4">, </span><span class="s2">T</span><span class="s4">&gt;): </span><span class="s5">this</span><span class="s4">;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Adds a **one-time** `listener` function for the event named `eventName`. The</span>
                 <span class="s0">* next time `eventName` is triggered, this listener is removed and then invoked.</span>
                 <span class="s0">*</span>
                 <span class="s0">* ```js</span>
                 <span class="s0">* server.once('connection', (stream) =&gt; {</span>
                 <span class="s0">*   console.log('Ah, we have our first user!');</span>
                 <span class="s0">* });</span>
                 <span class="s0">* ```</span>
                 <span class="s0">*</span>
                 <span class="s0">* Returns a reference to the `EventEmitter`, so that calls can be chained.</span>
                 <span class="s0">*</span>
                 <span class="s0">* By default, event listeners are invoked in the order they are added. The `emitter.prependOnceListener()` method can be used as an alternative to add the</span>
                 <span class="s0">* event listener to the beginning of the listeners array.</span>
                 <span class="s0">*</span>
                 <span class="s0">* ```js</span>
                 <span class="s0">* import { EventEmitter } from 'node:events';</span>
                 <span class="s0">* const myEE = new EventEmitter();</span>
                 <span class="s0">* myEE.once('foo', () =&gt; console.log('a'));</span>
                 <span class="s0">* myEE.prependOnceListener('foo', () =&gt; console.log('b'));</span>
                 <span class="s0">* myEE.emit('foo');</span>
                 <span class="s0">* // Prints:</span>
                 <span class="s0">* //   b</span>
                 <span class="s0">* //   a</span>
                 <span class="s0">* ```</span>
                 <span class="s0">* </span><span class="s1">@since </span><span class="s0">v0.3.0</span>
                 <span class="s0">* </span><span class="s1">@param </span><span class="s0">eventName The name of the event.</span>
                 <span class="s0">* </span><span class="s1">@param </span><span class="s0">listener The callback function</span>
                 <span class="s0">*/</span>
                <span class="s2">once</span><span class="s4">&lt;</span><span class="s2">K</span><span class="s4">&gt;(</span><span class="s2">eventName</span><span class="s4">: </span><span class="s2">Key</span><span class="s4">&lt;</span><span class="s2">K</span><span class="s4">, </span><span class="s2">T</span><span class="s4">&gt;, </span><span class="s2">listener</span><span class="s4">: </span><span class="s2">Listener1</span><span class="s4">&lt;</span><span class="s2">K</span><span class="s4">, </span><span class="s2">T</span><span class="s4">&gt;): </span><span class="s5">this</span><span class="s4">;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Removes the specified `listener` from the listener array for the event named `eventName`.</span>
                 <span class="s0">*</span>
                 <span class="s0">* ```js</span>
                 <span class="s0">* const callback = (stream) =&gt; {</span>
                 <span class="s0">*   console.log('someone connected!');</span>
                 <span class="s0">* };</span>
                 <span class="s0">* server.on('connection', callback);</span>
                 <span class="s0">* // ...</span>
                 <span class="s0">* server.removeListener('connection', callback);</span>
                 <span class="s0">* ```</span>
                 <span class="s0">*</span>
                 <span class="s0">* `removeListener()` will remove, at most, one instance of a listener from the</span>
                 <span class="s0">* listener array. If any single listener has been added multiple times to the</span>
                 <span class="s0">* listener array for the specified `eventName`, then `removeListener()` must be</span>
                 <span class="s0">* called multiple times to remove each instance.</span>
                 <span class="s0">*</span>
                 <span class="s0">* Once an event is emitted, all listeners attached to it at the</span>
                 <span class="s0">* time of emitting are called in order. This implies that any `removeListener()` or `removeAllListeners()` calls _after_ emitting and _before_ the last listener finishes execution</span>
                 <span class="s0">* will not remove them from`emit()` in progress. Subsequent events behave as expected.</span>
                 <span class="s0">*</span>
                 <span class="s0">* ```js</span>
                 <span class="s0">* import { EventEmitter } from 'node:events';</span>
                 <span class="s0">* class MyEmitter extends EventEmitter {}</span>
                 <span class="s0">* const myEmitter = new MyEmitter();</span>
                 <span class="s0">*</span>
                 <span class="s0">* const callbackA = () =&gt; {</span>
                 <span class="s0">*   console.log('A');</span>
                 <span class="s0">*   myEmitter.removeListener('event', callbackB);</span>
                 <span class="s0">* };</span>
                 <span class="s0">*</span>
                 <span class="s0">* const callbackB = () =&gt; {</span>
                 <span class="s0">*   console.log('B');</span>
                 <span class="s0">* };</span>
                 <span class="s0">*</span>
                 <span class="s0">* myEmitter.on('event', callbackA);</span>
                 <span class="s0">*</span>
                 <span class="s0">* myEmitter.on('event', callbackB);</span>
                 <span class="s0">*</span>
                 <span class="s0">* // callbackA removes listener callbackB but it will still be called.</span>
                 <span class="s0">* // Internal listener array at time of emit [callbackA, callbackB]</span>
                 <span class="s0">* myEmitter.emit('event');</span>
                 <span class="s0">* // Prints:</span>
                 <span class="s0">* //   A</span>
                 <span class="s0">* //   B</span>
                 <span class="s0">*</span>
                 <span class="s0">* // callbackB is now removed.</span>
                 <span class="s0">* // Internal listener array [callbackA]</span>
                 <span class="s0">* myEmitter.emit('event');</span>
                 <span class="s0">* // Prints:</span>
                 <span class="s0">* //   A</span>
                 <span class="s0">* ```</span>
                 <span class="s0">*</span>
                 <span class="s0">* Because listeners are managed using an internal array, calling this will</span>
                 <span class="s0">* change the position indices of any listener registered _after_ the listener</span>
                 <span class="s0">* being removed. This will not impact the order in which listeners are called,</span>
                 <span class="s0">* but it means that any copies of the listener array as returned by</span>
                 <span class="s0">* the `emitter.listeners()` method will need to be recreated.</span>
                 <span class="s0">*</span>
                 <span class="s0">* When a single function has been added as a handler multiple times for a single</span>
                 <span class="s0">* event (as in the example below), `removeListener()` will remove the most</span>
                 <span class="s0">* recently added instance. In the example the `once('ping')` listener is removed:</span>
                 <span class="s0">*</span>
                 <span class="s0">* ```js</span>
                 <span class="s0">* import { EventEmitter } from 'node:events';</span>
                 <span class="s0">* const ee = new EventEmitter();</span>
                 <span class="s0">*</span>
                 <span class="s0">* function pong() {</span>
                 <span class="s0">*   console.log('pong');</span>
                 <span class="s0">* }</span>
                 <span class="s0">*</span>
                 <span class="s0">* ee.on('ping', pong);</span>
                 <span class="s0">* ee.once('ping', pong);</span>
                 <span class="s0">* ee.removeListener('ping', pong);</span>
                 <span class="s0">*</span>
                 <span class="s0">* ee.emit('ping');</span>
                 <span class="s0">* ee.emit('ping');</span>
                 <span class="s0">* ```</span>
                 <span class="s0">*</span>
                 <span class="s0">* Returns a reference to the `EventEmitter`, so that calls can be chained.</span>
                 <span class="s0">* </span><span class="s1">@since </span><span class="s0">v0.1.26</span>
                 <span class="s0">*/</span>
                <span class="s2">removeListener</span><span class="s4">&lt;</span><span class="s2">K</span><span class="s4">&gt;(</span><span class="s2">eventName</span><span class="s4">: </span><span class="s2">Key</span><span class="s4">&lt;</span><span class="s2">K</span><span class="s4">, </span><span class="s2">T</span><span class="s4">&gt;, </span><span class="s2">listener</span><span class="s4">: </span><span class="s2">Listener1</span><span class="s4">&lt;</span><span class="s2">K</span><span class="s4">, </span><span class="s2">T</span><span class="s4">&gt;): </span><span class="s5">this</span><span class="s4">;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Alias for `emitter.removeListener()`.</span>
                 <span class="s0">* </span><span class="s1">@since </span><span class="s0">v10.0.0</span>
                 <span class="s0">*/</span>
                <span class="s2">off</span><span class="s4">&lt;</span><span class="s2">K</span><span class="s4">&gt;(</span><span class="s2">eventName</span><span class="s4">: </span><span class="s2">Key</span><span class="s4">&lt;</span><span class="s2">K</span><span class="s4">, </span><span class="s2">T</span><span class="s4">&gt;, </span><span class="s2">listener</span><span class="s4">: </span><span class="s2">Listener1</span><span class="s4">&lt;</span><span class="s2">K</span><span class="s4">, </span><span class="s2">T</span><span class="s4">&gt;): </span><span class="s5">this</span><span class="s4">;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Removes all listeners, or those of the specified `eventName`.</span>
                 <span class="s0">*</span>
                 <span class="s0">* It is bad practice to remove listeners added elsewhere in the code,</span>
                 <span class="s0">* particularly when the `EventEmitter` instance was created by some other</span>
                 <span class="s0">* component or module (e.g. sockets or file streams).</span>
                 <span class="s0">*</span>
                 <span class="s0">* Returns a reference to the `EventEmitter`, so that calls can be chained.</span>
                 <span class="s0">* </span><span class="s1">@since </span><span class="s0">v0.1.26</span>
                 <span class="s0">*/</span>
                <span class="s2">removeAllListeners</span><span class="s4">(</span><span class="s2">eventName</span><span class="s4">?: </span><span class="s2">Key</span><span class="s4">&lt;</span><span class="s2">unknown</span><span class="s4">, </span><span class="s2">T</span><span class="s4">&gt;): </span><span class="s5">this</span><span class="s4">;</span>
                <span class="s0">/**</span>
                 <span class="s0">* By default `EventEmitter`s will print a warning if more than `10` listeners are</span>
                 <span class="s0">* added for a particular event. This is a useful default that helps finding</span>
                 <span class="s0">* memory leaks. The `emitter.setMaxListeners()` method allows the limit to be</span>
                 <span class="s0">* modified for this specific `EventEmitter` instance. The value can be set to `Infinity` (or `0`) to indicate an unlimited number of listeners.</span>
                 <span class="s0">*</span>
                 <span class="s0">* Returns a reference to the `EventEmitter`, so that calls can be chained.</span>
                 <span class="s0">* </span><span class="s1">@since </span><span class="s0">v0.3.5</span>
                 <span class="s0">*/</span>
                <span class="s2">setMaxListeners</span><span class="s4">(</span><span class="s2">n</span><span class="s4">: </span><span class="s2">number</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Returns the current max listener value for the `EventEmitter` which is either</span>
                 <span class="s0">* set by `emitter.setMaxListeners(n)` or defaults to {</span><span class="s1">@link </span><span class="s0">EventEmitter.defaultMaxListeners}.</span>
                 <span class="s0">* </span><span class="s1">@since </span><span class="s0">v1.0.0</span>
                 <span class="s0">*/</span>
                <span class="s2">getMaxListeners</span><span class="s4">(): </span><span class="s2">number</span><span class="s4">;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Returns a copy of the array of listeners for the event named `eventName`.</span>
                 <span class="s0">*</span>
                 <span class="s0">* ```js</span>
                 <span class="s0">* server.on('connection', (stream) =&gt; {</span>
                 <span class="s0">*   console.log('someone connected!');</span>
                 <span class="s0">* });</span>
                 <span class="s0">* console.log(util.inspect(server.listeners('connection')));</span>
                 <span class="s0">* // Prints: [ [Function] ]</span>
                 <span class="s0">* ```</span>
                 <span class="s0">* </span><span class="s1">@since </span><span class="s0">v0.1.26</span>
                 <span class="s0">*/</span>
                <span class="s2">listeners</span><span class="s4">&lt;</span><span class="s2">K</span><span class="s4">&gt;(</span><span class="s2">eventName</span><span class="s4">: </span><span class="s2">Key</span><span class="s4">&lt;</span><span class="s2">K</span><span class="s4">, </span><span class="s2">T</span><span class="s4">&gt;): </span><span class="s2">Array</span><span class="s4">&lt;</span><span class="s2">Listener2</span><span class="s4">&lt;</span><span class="s2">K</span><span class="s4">, </span><span class="s2">T</span><span class="s4">&gt;&gt;;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Returns a copy of the array of listeners for the event named `eventName`,</span>
                 <span class="s0">* including any wrappers (such as those created by `.once()`).</span>
                 <span class="s0">*</span>
                 <span class="s0">* ```js</span>
                 <span class="s0">* import { EventEmitter } from 'node:events';</span>
                 <span class="s0">* const emitter = new EventEmitter();</span>
                 <span class="s0">* emitter.once('log', () =&gt; console.log('log once'));</span>
                 <span class="s0">*</span>
                 <span class="s0">* // Returns a new Array with a function `onceWrapper` which has a property</span>
                 <span class="s0">* // `listener` which contains the original listener bound above</span>
                 <span class="s0">* const listeners = emitter.rawListeners('log');</span>
                 <span class="s0">* const logFnWrapper = listeners[0];</span>
                 <span class="s0">*</span>
                 <span class="s0">* // Logs &quot;log once&quot; to the console and does not unbind the `once` event</span>
                 <span class="s0">* logFnWrapper.listener();</span>
                 <span class="s0">*</span>
                 <span class="s0">* // Logs &quot;log once&quot; to the console and removes the listener</span>
                 <span class="s0">* logFnWrapper();</span>
                 <span class="s0">*</span>
                 <span class="s0">* emitter.on('log', () =&gt; console.log('log persistently'));</span>
                 <span class="s0">* // Will return a new Array with a single function bound by `.on()` above</span>
                 <span class="s0">* const newListeners = emitter.rawListeners('log');</span>
                 <span class="s0">*</span>
                 <span class="s0">* // Logs &quot;log persistently&quot; twice</span>
                 <span class="s0">* newListeners[0]();</span>
                 <span class="s0">* emitter.emit('log');</span>
                 <span class="s0">* ```</span>
                 <span class="s0">* </span><span class="s1">@since </span><span class="s0">v9.4.0</span>
                 <span class="s0">*/</span>
                <span class="s2">rawListeners</span><span class="s4">&lt;</span><span class="s2">K</span><span class="s4">&gt;(</span><span class="s2">eventName</span><span class="s4">: </span><span class="s2">Key</span><span class="s4">&lt;</span><span class="s2">K</span><span class="s4">, </span><span class="s2">T</span><span class="s4">&gt;): </span><span class="s2">Array</span><span class="s4">&lt;</span><span class="s2">Listener2</span><span class="s4">&lt;</span><span class="s2">K</span><span class="s4">, </span><span class="s2">T</span><span class="s4">&gt;&gt;;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Synchronously calls each of the listeners registered for the event named `eventName`, in the order they were registered, passing the supplied arguments</span>
                 <span class="s0">* to each.</span>
                 <span class="s0">*</span>
                 <span class="s0">* Returns `true` if the event had listeners, `false` otherwise.</span>
                 <span class="s0">*</span>
                 <span class="s0">* ```js</span>
                 <span class="s0">* import { EventEmitter } from 'node:events';</span>
                 <span class="s0">* const myEmitter = new EventEmitter();</span>
                 <span class="s0">*</span>
                 <span class="s0">* // First listener</span>
                 <span class="s0">* myEmitter.on('event', function firstListener() {</span>
                 <span class="s0">*   console.log('Helloooo! first listener');</span>
                 <span class="s0">* });</span>
                 <span class="s0">* // Second listener</span>
                 <span class="s0">* myEmitter.on('event', function secondListener(arg1, arg2) {</span>
                 <span class="s0">*   console.log(`event with parameters ${arg1}, ${arg2} in second listener`);</span>
                 <span class="s0">* });</span>
                 <span class="s0">* // Third listener</span>
                 <span class="s0">* myEmitter.on('event', function thirdListener(...args) {</span>
                 <span class="s0">*   const parameters = args.join(', ');</span>
                 <span class="s0">*   console.log(`event with parameters ${parameters} in third listener`);</span>
                 <span class="s0">* });</span>
                 <span class="s0">*</span>
                 <span class="s0">* console.log(myEmitter.listeners('event'));</span>
                 <span class="s0">*</span>
                 <span class="s0">* myEmitter.emit('event', 1, 2, 3, 4, 5);</span>
                 <span class="s0">*</span>
                 <span class="s0">* // Prints:</span>
                 <span class="s0">* // [</span>
                 <span class="s0">* //   [Function: firstListener],</span>
                 <span class="s0">* //   [Function: secondListener],</span>
                 <span class="s0">* //   [Function: thirdListener]</span>
                 <span class="s0">* // ]</span>
                 <span class="s0">* // Helloooo! first listener</span>
                 <span class="s0">* // event with parameters 1, 2 in second listener</span>
                 <span class="s0">* // event with parameters 1, 2, 3, 4, 5 in third listener</span>
                 <span class="s0">* ```</span>
                 <span class="s0">* </span><span class="s1">@since </span><span class="s0">v0.1.26</span>
                 <span class="s0">*/</span>
                <span class="s2">emit</span><span class="s4">&lt;</span><span class="s2">K</span><span class="s4">&gt;(</span><span class="s2">eventName</span><span class="s4">: </span><span class="s2">Key</span><span class="s4">&lt;</span><span class="s2">K</span><span class="s4">, </span><span class="s2">T</span><span class="s4">&gt;, </span><span class="s2">...args</span><span class="s4">: </span><span class="s2">Args</span><span class="s4">&lt;</span><span class="s2">K</span><span class="s4">, </span><span class="s2">T</span><span class="s4">&gt;): </span><span class="s2">boolean</span><span class="s4">;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Returns the number of listeners listening for the event named `eventName`.</span>
                 <span class="s0">* If `listener` is provided, it will return how many times the listener is found</span>
                 <span class="s0">* in the list of the listeners of the event.</span>
                 <span class="s0">* </span><span class="s1">@since </span><span class="s0">v3.2.0</span>
                 <span class="s0">* </span><span class="s1">@param </span><span class="s0">eventName The name of the event being listened for</span>
                 <span class="s0">* </span><span class="s1">@param </span><span class="s0">listener The event handler function</span>
                 <span class="s0">*/</span>
                <span class="s2">listenerCount</span><span class="s4">&lt;</span><span class="s2">K</span><span class="s4">&gt;(</span><span class="s2">eventName</span><span class="s4">: </span><span class="s2">Key</span><span class="s4">&lt;</span><span class="s2">K</span><span class="s4">, </span><span class="s2">T</span><span class="s4">&gt;, </span><span class="s2">listener</span><span class="s4">?: </span><span class="s2">Listener2</span><span class="s4">&lt;</span><span class="s2">K</span><span class="s4">, </span><span class="s2">T</span><span class="s4">&gt;): </span><span class="s2">number</span><span class="s4">;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Adds the `listener` function to the _beginning_ of the listeners array for the</span>
                 <span class="s0">* event named `eventName`. No checks are made to see if the `listener` has</span>
                 <span class="s0">* already been added. Multiple calls passing the same combination of `eventName`</span>
                 <span class="s0">* and `listener` will result in the `listener` being added, and called, multiple times.</span>
                 <span class="s0">*</span>
                 <span class="s0">* ```js</span>
                 <span class="s0">* server.prependListener('connection', (stream) =&gt; {</span>
                 <span class="s0">*   console.log('someone connected!');</span>
                 <span class="s0">* });</span>
                 <span class="s0">* ```</span>
                 <span class="s0">*</span>
                 <span class="s0">* Returns a reference to the `EventEmitter`, so that calls can be chained.</span>
                 <span class="s0">* </span><span class="s1">@since </span><span class="s0">v6.0.0</span>
                 <span class="s0">* </span><span class="s1">@param </span><span class="s0">eventName The name of the event.</span>
                 <span class="s0">* </span><span class="s1">@param </span><span class="s0">listener The callback function</span>
                 <span class="s0">*/</span>
                <span class="s2">prependListener</span><span class="s4">&lt;</span><span class="s2">K</span><span class="s4">&gt;(</span><span class="s2">eventName</span><span class="s4">: </span><span class="s2">Key</span><span class="s4">&lt;</span><span class="s2">K</span><span class="s4">, </span><span class="s2">T</span><span class="s4">&gt;, </span><span class="s2">listener</span><span class="s4">: </span><span class="s2">Listener1</span><span class="s4">&lt;</span><span class="s2">K</span><span class="s4">, </span><span class="s2">T</span><span class="s4">&gt;): </span><span class="s5">this</span><span class="s4">;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Adds a **one-time**`listener` function for the event named `eventName` to the _beginning_ of the listeners array. The next time `eventName` is triggered, this</span>
                 <span class="s0">* listener is removed, and then invoked.</span>
                 <span class="s0">*</span>
                 <span class="s0">* ```js</span>
                 <span class="s0">* server.prependOnceListener('connection', (stream) =&gt; {</span>
                 <span class="s0">*   console.log('Ah, we have our first user!');</span>
                 <span class="s0">* });</span>
                 <span class="s0">* ```</span>
                 <span class="s0">*</span>
                 <span class="s0">* Returns a reference to the `EventEmitter`, so that calls can be chained.</span>
                 <span class="s0">* </span><span class="s1">@since </span><span class="s0">v6.0.0</span>
                 <span class="s0">* </span><span class="s1">@param </span><span class="s0">eventName The name of the event.</span>
                 <span class="s0">* </span><span class="s1">@param </span><span class="s0">listener The callback function</span>
                 <span class="s0">*/</span>
                <span class="s2">prependOnceListener</span><span class="s4">&lt;</span><span class="s2">K</span><span class="s4">&gt;(</span><span class="s2">eventName</span><span class="s4">: </span><span class="s2">Key</span><span class="s4">&lt;</span><span class="s2">K</span><span class="s4">, </span><span class="s2">T</span><span class="s4">&gt;, </span><span class="s2">listener</span><span class="s4">: </span><span class="s2">Listener1</span><span class="s4">&lt;</span><span class="s2">K</span><span class="s4">, </span><span class="s2">T</span><span class="s4">&gt;): </span><span class="s5">this</span><span class="s4">;</span>
                <span class="s0">/**</span>
                 <span class="s0">* Returns an array listing the events for which the emitter has registered</span>
                 <span class="s0">* listeners. The values in the array are strings or `Symbol`s.</span>
                 <span class="s0">*</span>
                 <span class="s0">* ```js</span>
                 <span class="s0">* import { EventEmitter } from 'node:events';</span>
                 <span class="s0">*</span>
                 <span class="s0">* const myEE = new EventEmitter();</span>
                 <span class="s0">* myEE.on('foo', () =&gt; {});</span>
                 <span class="s0">* myEE.on('bar', () =&gt; {});</span>
                 <span class="s0">*</span>
                 <span class="s0">* const sym = Symbol('symbol');</span>
                 <span class="s0">* myEE.on(sym, () =&gt; {});</span>
                 <span class="s0">*</span>
                 <span class="s0">* console.log(myEE.eventNames());</span>
                 <span class="s0">* // Prints: [ 'foo', 'bar', Symbol(symbol) ]</span>
                 <span class="s0">* ```</span>
                 <span class="s0">* </span><span class="s1">@since </span><span class="s0">v6.0.0</span>
                 <span class="s0">*/</span>
                <span class="s2">eventNames</span><span class="s4">(): </span><span class="s2">Array</span><span class="s4">&lt;(</span><span class="s2">string </span><span class="s4">| </span><span class="s2">symbol</span><span class="s4">) &amp; </span><span class="s2">Key2</span><span class="s4">&lt;</span><span class="s2">unknown</span><span class="s4">, </span><span class="s2">T</span><span class="s4">&gt;&gt;;</span>
            <span class="s4">}</span>
        <span class="s4">}</span>
    <span class="s4">}</span>
    <span class="s5">export </span><span class="s4">= </span><span class="s2">EventEmitter</span><span class="s4">;</span>
<span class="s4">}</span>
<span class="s2">declare module </span><span class="s3">&quot;node:events&quot; </span><span class="s4">{</span>
    <span class="s5">import </span><span class="s2">events </span><span class="s4">= </span><span class="s2">require</span><span class="s4">(</span><span class="s3">&quot;events&quot;</span><span class="s4">);</span>
    <span class="s5">export </span><span class="s4">= </span><span class="s2">events</span><span class="s4">;</span>
<span class="s4">}</span>
</pre>
</body>
</html>