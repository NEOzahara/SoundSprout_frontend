<html>
<head>
<title>expandApplyAtRules.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #6aab73;}
.s3 { color: #bcbec4;}
.s4 { color: #5f826b; font-style: italic;}
.s5 { color: #67a37c; font-style: italic;}
.s6 { color: #7a7e85;}
.s7 { color: #2aacb8;}
.s8 { color: #42c3d4;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
expandApplyAtRules.js</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">postcss from </span><span class="s2">'postcss'</span>
<span class="s0">import </span><span class="s1">parser from </span><span class="s2">'postcss-selector-parser'</span>

<span class="s0">import </span><span class="s3">{ </span><span class="s1">resolveMatches </span><span class="s3">} </span><span class="s1">from </span><span class="s2">'./generateRules'</span>
<span class="s0">import </span><span class="s1">escapeClassName from </span><span class="s2">'../util/escapeClassName'</span>
<span class="s0">import </span><span class="s3">{ </span><span class="s1">applyImportantSelector </span><span class="s3">} </span><span class="s1">from </span><span class="s2">'../util/applyImportantSelector'</span>
<span class="s0">import </span><span class="s3">{ </span><span class="s1">movePseudos </span><span class="s3">} </span><span class="s1">from </span><span class="s2">'../util/pseudoElements'</span>

<span class="s4">/** </span><span class="s5">@typedef </span><span class="s4">{Map&lt;string, [any, import('postcss').Rule[]]&gt;} ApplyCache */</span>

<span class="s0">function </span><span class="s1">extractClasses</span><span class="s3">(</span><span class="s1">node</span><span class="s3">) {</span>
  <span class="s4">/** </span><span class="s5">@type </span><span class="s4">{Map&lt;string, Set&lt;string&gt;&gt;} */</span>
  <span class="s0">let </span><span class="s1">groups </span><span class="s3">= </span><span class="s0">new </span><span class="s1">Map</span><span class="s3">()</span>

  <span class="s0">let </span><span class="s1">container </span><span class="s3">= </span><span class="s1">postcss</span><span class="s3">.</span><span class="s1">root</span><span class="s3">({ </span><span class="s1">nodes</span><span class="s3">: [</span><span class="s1">node</span><span class="s3">.</span><span class="s1">clone</span><span class="s3">()] })</span>

  <span class="s1">container</span><span class="s3">.</span><span class="s1">walkRules</span><span class="s3">((</span><span class="s1">rule</span><span class="s3">) =&gt; {</span>
    <span class="s1">parser</span><span class="s3">((</span><span class="s1">selectors</span><span class="s3">) =&gt; {</span>
      <span class="s1">selectors</span><span class="s3">.</span><span class="s1">walkClasses</span><span class="s3">((</span><span class="s1">classSelector</span><span class="s3">) =&gt; {</span>
        <span class="s0">let </span><span class="s1">parentSelector </span><span class="s3">= </span><span class="s1">classSelector</span><span class="s3">.</span><span class="s1">parent</span><span class="s3">.</span><span class="s1">toString</span><span class="s3">()</span>

        <span class="s0">let </span><span class="s1">classes </span><span class="s3">= </span><span class="s1">groups</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">parentSelector</span><span class="s3">)</span>
        <span class="s0">if </span><span class="s3">(!</span><span class="s1">classes</span><span class="s3">) {</span>
          <span class="s1">groups</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">parentSelector</span><span class="s3">, (</span><span class="s1">classes </span><span class="s3">= </span><span class="s0">new </span><span class="s1">Set</span><span class="s3">()))</span>
        <span class="s3">}</span>

        <span class="s1">classes</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">classSelector</span><span class="s3">.</span><span class="s1">value</span><span class="s3">)</span>
      <span class="s3">})</span>
    <span class="s3">}).</span><span class="s1">processSync</span><span class="s3">(</span><span class="s1">rule</span><span class="s3">.</span><span class="s1">selector</span><span class="s3">)</span>
  <span class="s3">})</span>

  <span class="s0">let </span><span class="s1">normalizedGroups </span><span class="s3">= </span><span class="s1">Array</span><span class="s3">.</span><span class="s1">from</span><span class="s3">(</span><span class="s1">groups</span><span class="s3">.</span><span class="s1">values</span><span class="s3">(), (</span><span class="s1">classes</span><span class="s3">) =&gt; </span><span class="s1">Array</span><span class="s3">.</span><span class="s1">from</span><span class="s3">(</span><span class="s1">classes</span><span class="s3">))</span>
  <span class="s0">let </span><span class="s1">classes </span><span class="s3">= </span><span class="s1">normalizedGroups</span><span class="s3">.</span><span class="s1">flat</span><span class="s3">()</span>

  <span class="s0">return </span><span class="s1">Object</span><span class="s3">.</span><span class="s1">assign</span><span class="s3">(</span><span class="s1">classes</span><span class="s3">, { </span><span class="s1">groups</span><span class="s3">: </span><span class="s1">normalizedGroups </span><span class="s3">})</span>
<span class="s3">}</span>

<span class="s0">let </span><span class="s1">selectorExtractor </span><span class="s3">= </span><span class="s1">parser</span><span class="s3">()</span>

<span class="s4">/**</span>
 <span class="s4">* </span><span class="s5">@param </span><span class="s4">{string} ruleSelectors</span>
 <span class="s4">*/</span>
<span class="s0">function </span><span class="s1">extractSelectors</span><span class="s3">(</span><span class="s1">ruleSelectors</span><span class="s3">) {</span>
  <span class="s0">return </span><span class="s1">selectorExtractor</span><span class="s3">.</span><span class="s1">astSync</span><span class="s3">(</span><span class="s1">ruleSelectors</span><span class="s3">)</span>
<span class="s3">}</span>

<span class="s0">function </span><span class="s1">extractBaseCandidates</span><span class="s3">(</span><span class="s1">candidates</span><span class="s3">, </span><span class="s1">separator</span><span class="s3">) {</span>
  <span class="s0">let </span><span class="s1">baseClasses </span><span class="s3">= </span><span class="s0">new </span><span class="s1">Set</span><span class="s3">()</span>

  <span class="s0">for </span><span class="s3">(</span><span class="s0">let </span><span class="s1">candidate of candidates</span><span class="s3">) {</span>
    <span class="s1">baseClasses</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">candidate</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">separator</span><span class="s3">).</span><span class="s1">pop</span><span class="s3">())</span>
  <span class="s3">}</span>

  <span class="s0">return </span><span class="s1">Array</span><span class="s3">.</span><span class="s1">from</span><span class="s3">(</span><span class="s1">baseClasses</span><span class="s3">)</span>
<span class="s3">}</span>

<span class="s0">function </span><span class="s1">prefix</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">selector</span><span class="s3">) {</span>
  <span class="s0">let </span><span class="s1">prefix </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">tailwindConfig</span><span class="s3">.</span><span class="s1">prefix</span>
  <span class="s0">return typeof </span><span class="s1">prefix </span><span class="s3">=== </span><span class="s2">'function' </span><span class="s3">? </span><span class="s1">prefix</span><span class="s3">(</span><span class="s1">selector</span><span class="s3">) : </span><span class="s1">prefix </span><span class="s3">+ </span><span class="s1">selector</span>
<span class="s3">}</span>

<span class="s0">function</span><span class="s3">* </span><span class="s1">pathToRoot</span><span class="s3">(</span><span class="s1">node</span><span class="s3">) {</span>
  <span class="s0">yield </span><span class="s1">node</span>
  <span class="s0">while </span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">parent</span><span class="s3">) {</span>
    <span class="s0">yield </span><span class="s1">node</span><span class="s3">.</span><span class="s1">parent</span>
    <span class="s1">node </span><span class="s3">= </span><span class="s1">node</span><span class="s3">.</span><span class="s1">parent</span>
  <span class="s3">}</span>
<span class="s3">}</span>

<span class="s4">/**</span>
 <span class="s4">* Only clone the node itself and not its children</span>
 <span class="s4">*</span>
 <span class="s4">* </span><span class="s5">@param </span><span class="s4">{*} node</span>
 <span class="s4">* </span><span class="s5">@param </span><span class="s4">{*} overrides</span>
 <span class="s4">* </span><span class="s5">@returns</span>
 <span class="s4">*/</span>
<span class="s0">function </span><span class="s1">shallowClone</span><span class="s3">(</span><span class="s1">node</span><span class="s3">, </span><span class="s1">overrides </span><span class="s3">= {}) {</span>
  <span class="s0">let </span><span class="s1">children </span><span class="s3">= </span><span class="s1">node</span><span class="s3">.</span><span class="s1">nodes</span>
  <span class="s1">node</span><span class="s3">.</span><span class="s1">nodes </span><span class="s3">= []</span>

  <span class="s0">let </span><span class="s1">tmp </span><span class="s3">= </span><span class="s1">node</span><span class="s3">.</span><span class="s1">clone</span><span class="s3">(</span><span class="s1">overrides</span><span class="s3">)</span>

  <span class="s1">node</span><span class="s3">.</span><span class="s1">nodes </span><span class="s3">= </span><span class="s1">children</span>

  <span class="s0">return </span><span class="s1">tmp</span>
<span class="s3">}</span>

<span class="s4">/**</span>
 <span class="s4">* Clone just the nodes all the way to the top that are required to represent</span>
 <span class="s4">* this singular rule in the tree.</span>
 <span class="s4">*</span>
 <span class="s4">* For example, if we have CSS like this:</span>
 <span class="s4">* ```css</span>
 <span class="s4">* @media (min-width: 768px) {</span>
 <span class="s4">*   @supports (display: grid) {</span>
 <span class="s4">*     .foo {</span>
 <span class="s4">*       display: grid;</span>
 <span class="s4">*       grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));</span>
 <span class="s4">*     }</span>
 <span class="s4">*   }</span>
 <span class="s4">*</span>
 <span class="s4">*   @supports (backdrop-filter: blur(1px)) {</span>
 <span class="s4">*     .bar {</span>
 <span class="s4">*       backdrop-filter: blur(1px);</span>
 <span class="s4">*     }</span>
 <span class="s4">*   }</span>
 <span class="s4">*</span>
 <span class="s4">*   .baz {</span>
 <span class="s4">*     color: orange;</span>
 <span class="s4">*   }</span>
 <span class="s4">* }</span>
 <span class="s4">* ```</span>
 <span class="s4">*</span>
 <span class="s4">* And we're cloning `.bar` it'll return a cloned version of what's required for just that single node:</span>
 <span class="s4">*</span>
 <span class="s4">* ```css</span>
 <span class="s4">* @media (min-width: 768px) {</span>
 <span class="s4">*   @supports (backdrop-filter: blur(1px)) {</span>
 <span class="s4">*     .bar {</span>
 <span class="s4">*       backdrop-filter: blur(1px);</span>
 <span class="s4">*     }</span>
 <span class="s4">*   }</span>
 <span class="s4">* }</span>
 <span class="s4">* ```</span>
 <span class="s4">*</span>
 <span class="s4">* </span><span class="s5">@param </span><span class="s4">{import('postcss').Node} node</span>
 <span class="s4">*/</span>
<span class="s0">function </span><span class="s1">nestedClone</span><span class="s3">(</span><span class="s1">node</span><span class="s3">) {</span>
  <span class="s0">for </span><span class="s3">(</span><span class="s0">let </span><span class="s1">parent of pathToRoot</span><span class="s3">(</span><span class="s1">node</span><span class="s3">)) {</span>
    <span class="s0">if </span><span class="s3">(</span><span class="s1">node </span><span class="s3">=== </span><span class="s1">parent</span><span class="s3">) {</span>
      <span class="s0">continue</span>
    <span class="s3">}</span>

    <span class="s0">if </span><span class="s3">(</span><span class="s1">parent</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'root'</span><span class="s3">) {</span>
      <span class="s0">break</span>
    <span class="s3">}</span>

    <span class="s1">node </span><span class="s3">= </span><span class="s1">shallowClone</span><span class="s3">(</span><span class="s1">parent</span><span class="s3">, {</span>
      <span class="s1">nodes</span><span class="s3">: [</span><span class="s1">node</span><span class="s3">],</span>
    <span class="s3">})</span>
  <span class="s3">}</span>

  <span class="s0">return </span><span class="s1">node</span>
<span class="s3">}</span>

<span class="s4">/**</span>
 <span class="s4">* </span><span class="s5">@param </span><span class="s4">{import('postcss').Root} root</span>
 <span class="s4">*/</span>
<span class="s0">function </span><span class="s1">buildLocalApplyCache</span><span class="s3">(</span><span class="s1">root</span><span class="s3">, </span><span class="s1">context</span><span class="s3">) {</span>
  <span class="s4">/** </span><span class="s5">@type </span><span class="s4">{ApplyCache} */</span>
  <span class="s0">let </span><span class="s1">cache </span><span class="s3">= </span><span class="s0">new </span><span class="s1">Map</span><span class="s3">()</span>

  <span class="s1">root</span><span class="s3">.</span><span class="s1">walkRules</span><span class="s3">((</span><span class="s1">rule</span><span class="s3">) =&gt; {</span>
    <span class="s6">// Ignore rules generated by Tailwind</span>
    <span class="s0">for </span><span class="s3">(</span><span class="s0">let </span><span class="s1">node of pathToRoot</span><span class="s3">(</span><span class="s1">rule</span><span class="s3">)) {</span>
      <span class="s0">if </span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">raws</span><span class="s3">.</span><span class="s1">tailwind</span><span class="s3">?.</span><span class="s1">layer </span><span class="s3">!== </span><span class="s1">undefined</span><span class="s3">) {</span>
        <span class="s0">return</span>
      <span class="s3">}</span>
    <span class="s3">}</span>

    <span class="s6">// Clone what's required to represent this singular rule in the tree</span>
    <span class="s0">let </span><span class="s1">container </span><span class="s3">= </span><span class="s1">nestedClone</span><span class="s3">(</span><span class="s1">rule</span><span class="s3">)</span>
    <span class="s0">let </span><span class="s1">sort </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">offsets</span><span class="s3">.</span><span class="s1">create</span><span class="s3">(</span><span class="s2">'user'</span><span class="s3">)</span>

    <span class="s0">for </span><span class="s3">(</span><span class="s0">let </span><span class="s1">className of extractClasses</span><span class="s3">(</span><span class="s1">rule</span><span class="s3">)) {</span>
      <span class="s0">let </span><span class="s1">list </span><span class="s3">= </span><span class="s1">cache</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">className</span><span class="s3">) || []</span>
      <span class="s1">cache</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">className</span><span class="s3">, </span><span class="s1">list</span><span class="s3">)</span>

      <span class="s1">list</span><span class="s3">.</span><span class="s1">push</span><span class="s3">([</span>
        <span class="s3">{</span>
          <span class="s1">layer</span><span class="s3">: </span><span class="s2">'user'</span><span class="s3">,</span>
          <span class="s1">sort</span><span class="s3">,</span>
          <span class="s1">important</span><span class="s3">: </span><span class="s0">false</span><span class="s3">,</span>
        <span class="s3">},</span>
        <span class="s1">container</span><span class="s3">,</span>
      <span class="s3">])</span>
    <span class="s3">}</span>
  <span class="s3">})</span>

  <span class="s0">return </span><span class="s1">cache</span>
<span class="s3">}</span>

<span class="s4">/**</span>
 <span class="s4">* </span><span class="s5">@returns </span><span class="s4">{ApplyCache}</span>
 <span class="s4">*/</span>
<span class="s0">function </span><span class="s1">buildApplyCache</span><span class="s3">(</span><span class="s1">applyCandidates</span><span class="s3">, </span><span class="s1">context</span><span class="s3">) {</span>
  <span class="s0">for </span><span class="s3">(</span><span class="s0">let </span><span class="s1">candidate of applyCandidates</span><span class="s3">) {</span>
    <span class="s0">if </span><span class="s3">(</span><span class="s1">context</span><span class="s3">.</span><span class="s1">notClassCache</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s1">candidate</span><span class="s3">) || </span><span class="s1">context</span><span class="s3">.</span><span class="s1">applyClassCache</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s1">candidate</span><span class="s3">)) {</span>
      <span class="s0">continue</span>
    <span class="s3">}</span>

    <span class="s0">if </span><span class="s3">(</span><span class="s1">context</span><span class="s3">.</span><span class="s1">classCache</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s1">candidate</span><span class="s3">)) {</span>
      <span class="s1">context</span><span class="s3">.</span><span class="s1">applyClassCache</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span>
        <span class="s1">candidate</span><span class="s3">,</span>
        <span class="s1">context</span><span class="s3">.</span><span class="s1">classCache</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">candidate</span><span class="s3">).</span><span class="s1">map</span><span class="s3">(([</span><span class="s1">meta</span><span class="s3">, </span><span class="s1">rule</span><span class="s3">]) =&gt; [</span><span class="s1">meta</span><span class="s3">, </span><span class="s1">rule</span><span class="s3">.</span><span class="s1">clone</span><span class="s3">()])</span>
      <span class="s3">)</span>
      <span class="s0">continue</span>
    <span class="s3">}</span>

    <span class="s0">let </span><span class="s1">matches </span><span class="s3">= </span><span class="s1">Array</span><span class="s3">.</span><span class="s1">from</span><span class="s3">(</span><span class="s1">resolveMatches</span><span class="s3">(</span><span class="s1">candidate</span><span class="s3">, </span><span class="s1">context</span><span class="s3">))</span>

    <span class="s0">if </span><span class="s3">(</span><span class="s1">matches</span><span class="s3">.</span><span class="s1">length </span><span class="s3">=== </span><span class="s7">0</span><span class="s3">) {</span>
      <span class="s1">context</span><span class="s3">.</span><span class="s1">notClassCache</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">candidate</span><span class="s3">)</span>
      <span class="s0">continue</span>
    <span class="s3">}</span>

    <span class="s1">context</span><span class="s3">.</span><span class="s1">applyClassCache</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">candidate</span><span class="s3">, </span><span class="s1">matches</span><span class="s3">)</span>
  <span class="s3">}</span>

  <span class="s0">return </span><span class="s1">context</span><span class="s3">.</span><span class="s1">applyClassCache</span>
<span class="s3">}</span>

<span class="s4">/**</span>
 <span class="s4">* Build a cache only when it's first used</span>
 <span class="s4">*</span>
 <span class="s4">* </span><span class="s5">@param </span><span class="s4">{() =&gt; ApplyCache} buildCacheFn</span>
 <span class="s4">* </span><span class="s5">@returns </span><span class="s4">{ApplyCache}</span>
 <span class="s4">*/</span>
<span class="s0">function </span><span class="s1">lazyCache</span><span class="s3">(</span><span class="s1">buildCacheFn</span><span class="s3">) {</span>
  <span class="s0">let </span><span class="s1">cache </span><span class="s3">= </span><span class="s0">null</span>

  <span class="s0">return </span><span class="s3">{</span>
    <span class="s1">get</span><span class="s3">: (</span><span class="s1">name</span><span class="s3">) =&gt; {</span>
      <span class="s1">cache </span><span class="s3">= </span><span class="s1">cache </span><span class="s3">|| </span><span class="s1">buildCacheFn</span><span class="s3">()</span>

      <span class="s0">return </span><span class="s1">cache</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>
    <span class="s3">},</span>
    <span class="s1">has</span><span class="s3">: (</span><span class="s1">name</span><span class="s3">) =&gt; {</span>
      <span class="s1">cache </span><span class="s3">= </span><span class="s1">cache </span><span class="s3">|| </span><span class="s1">buildCacheFn</span><span class="s3">()</span>

      <span class="s0">return </span><span class="s1">cache</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>
    <span class="s3">},</span>
  <span class="s3">}</span>
<span class="s3">}</span>

<span class="s4">/**</span>
 <span class="s4">* Take a series of multiple caches and merge</span>
 <span class="s4">* them so they act like one large cache</span>
 <span class="s4">*</span>
 <span class="s4">* </span><span class="s5">@param </span><span class="s4">{ApplyCache[]} caches</span>
 <span class="s4">* </span><span class="s5">@returns </span><span class="s4">{ApplyCache}</span>
 <span class="s4">*/</span>
<span class="s0">function </span><span class="s1">combineCaches</span><span class="s3">(</span><span class="s1">caches</span><span class="s3">) {</span>
  <span class="s0">return </span><span class="s3">{</span>
    <span class="s1">get</span><span class="s3">: (</span><span class="s1">name</span><span class="s3">) =&gt; </span><span class="s1">caches</span><span class="s3">.</span><span class="s1">flatMap</span><span class="s3">((</span><span class="s1">cache</span><span class="s3">) =&gt; </span><span class="s1">cache</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">name</span><span class="s3">) || []),</span>
    <span class="s1">has</span><span class="s3">: (</span><span class="s1">name</span><span class="s3">) =&gt; </span><span class="s1">caches</span><span class="s3">.</span><span class="s1">some</span><span class="s3">((</span><span class="s1">cache</span><span class="s3">) =&gt; </span><span class="s1">cache</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)),</span>
  <span class="s3">}</span>
<span class="s3">}</span>

<span class="s0">function </span><span class="s1">extractApplyCandidates</span><span class="s3">(</span><span class="s1">params</span><span class="s3">) {</span>
  <span class="s0">let </span><span class="s1">candidates </span><span class="s3">= </span><span class="s1">params</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s8">/[\s\t\n]+/g</span><span class="s3">)</span>

  <span class="s0">if </span><span class="s3">(</span><span class="s1">candidates</span><span class="s3">[</span><span class="s1">candidates</span><span class="s3">.</span><span class="s1">length </span><span class="s3">- </span><span class="s7">1</span><span class="s3">] === </span><span class="s2">'!important'</span><span class="s3">) {</span>
    <span class="s0">return </span><span class="s3">[</span><span class="s1">candidates</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span><span class="s7">0</span><span class="s3">, -</span><span class="s7">1</span><span class="s3">), </span><span class="s0">true</span><span class="s3">]</span>
  <span class="s3">}</span>

  <span class="s0">return </span><span class="s3">[</span><span class="s1">candidates</span><span class="s3">, </span><span class="s0">false</span><span class="s3">]</span>
<span class="s3">}</span>

<span class="s0">function </span><span class="s1">processApply</span><span class="s3">(</span><span class="s1">root</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">localCache</span><span class="s3">) {</span>
  <span class="s0">let </span><span class="s1">applyCandidates </span><span class="s3">= </span><span class="s0">new </span><span class="s1">Set</span><span class="s3">()</span>

  <span class="s6">// Collect all @apply rules and candidates</span>
  <span class="s0">let </span><span class="s1">applies </span><span class="s3">= []</span>
  <span class="s1">root</span><span class="s3">.</span><span class="s1">walkAtRules</span><span class="s3">(</span><span class="s2">'apply'</span><span class="s3">, (</span><span class="s1">rule</span><span class="s3">) =&gt; {</span>
    <span class="s0">let </span><span class="s3">[</span><span class="s1">candidates</span><span class="s3">] = </span><span class="s1">extractApplyCandidates</span><span class="s3">(</span><span class="s1">rule</span><span class="s3">.</span><span class="s1">params</span><span class="s3">)</span>

    <span class="s0">for </span><span class="s3">(</span><span class="s0">let </span><span class="s1">util of candidates</span><span class="s3">) {</span>
      <span class="s1">applyCandidates</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">util</span><span class="s3">)</span>
    <span class="s3">}</span>

    <span class="s1">applies</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">rule</span><span class="s3">)</span>
  <span class="s3">})</span>

  <span class="s6">// Start the @apply process if we have rules with @apply in them</span>
  <span class="s0">if </span><span class="s3">(</span><span class="s1">applies</span><span class="s3">.</span><span class="s1">length </span><span class="s3">=== </span><span class="s7">0</span><span class="s3">) {</span>
    <span class="s0">return</span>
  <span class="s3">}</span>

  <span class="s6">// Fill up some caches!</span>
  <span class="s0">let </span><span class="s1">applyClassCache </span><span class="s3">= </span><span class="s1">combineCaches</span><span class="s3">([</span><span class="s1">localCache</span><span class="s3">, </span><span class="s1">buildApplyCache</span><span class="s3">(</span><span class="s1">applyCandidates</span><span class="s3">, </span><span class="s1">context</span><span class="s3">)])</span>

  <span class="s4">/**</span>
   <span class="s4">* When we have an apply like this:</span>
   <span class="s4">*</span>
   <span class="s4">* .abc {</span>
   <span class="s4">*    </span><span class="s5">@apply </span><span class="s4">hover:font-bold;</span>
   <span class="s4">* }</span>
   <span class="s4">*</span>
   <span class="s4">* What we essentially will do is resolve to this:</span>
   <span class="s4">*</span>
   <span class="s4">* .abc {</span>
   <span class="s4">*    </span><span class="s5">@apply </span><span class="s4">.hover\:font-bold:hover {</span>
   <span class="s4">*      font-weight: 500;</span>
   <span class="s4">*    }</span>
   <span class="s4">* }</span>
   <span class="s4">*</span>
   <span class="s4">* Notice that the to-be-applied class is `.hover\:font-bold:hover` and that the utility candidate was `hover:font-bold`.</span>
   <span class="s4">* What happens in this function is that we prepend a `.` and escape the candidate.</span>
   <span class="s4">* This will result in `.hover\:font-bold`</span>
   <span class="s4">* Which means that we can replace `.hover\:font-bold` with `.abc` in `.hover\:font-bold:hover` resulting in `.abc:hover`</span>
   <span class="s4">*</span>
   <span class="s4">* </span><span class="s5">@param </span><span class="s4">{string} selector</span>
   <span class="s4">* </span><span class="s5">@param </span><span class="s4">{string} utilitySelectors</span>
   <span class="s4">* </span><span class="s5">@param </span><span class="s4">{string} candidate</span>
   <span class="s4">*/</span>
  <span class="s0">function </span><span class="s1">replaceSelector</span><span class="s3">(</span><span class="s1">selector</span><span class="s3">, </span><span class="s1">utilitySelectors</span><span class="s3">, </span><span class="s1">candidate</span><span class="s3">) {</span>
    <span class="s0">let </span><span class="s1">selectorList </span><span class="s3">= </span><span class="s1">extractSelectors</span><span class="s3">(</span><span class="s1">selector</span><span class="s3">)</span>
    <span class="s0">let </span><span class="s1">utilitySelectorsList </span><span class="s3">= </span><span class="s1">extractSelectors</span><span class="s3">(</span><span class="s1">utilitySelectors</span><span class="s3">)</span>
    <span class="s0">let </span><span class="s1">candidateList </span><span class="s3">= </span><span class="s1">extractSelectors</span><span class="s3">(</span><span class="s2">`.</span><span class="s1">$</span><span class="s3">{</span><span class="s1">escapeClassName</span><span class="s3">(</span><span class="s1">candidate</span><span class="s3">)}</span><span class="s2">`</span><span class="s3">)</span>
    <span class="s0">let </span><span class="s1">candidateClass </span><span class="s3">= </span><span class="s1">candidateList</span><span class="s3">.</span><span class="s1">nodes</span><span class="s3">[</span><span class="s7">0</span><span class="s3">].</span><span class="s1">nodes</span><span class="s3">[</span><span class="s7">0</span><span class="s3">]</span>

    <span class="s1">selectorList</span><span class="s3">.</span><span class="s1">each</span><span class="s3">((</span><span class="s1">sel</span><span class="s3">) =&gt; {</span>
      <span class="s4">/** </span><span class="s5">@type </span><span class="s4">{Set&lt;import('postcss-selector-parser').Selector&gt;} */</span>
      <span class="s0">let </span><span class="s1">replaced </span><span class="s3">= </span><span class="s0">new </span><span class="s1">Set</span><span class="s3">()</span>

      <span class="s1">utilitySelectorsList</span><span class="s3">.</span><span class="s1">each</span><span class="s3">((</span><span class="s1">utilitySelector</span><span class="s3">) =&gt; {</span>
        <span class="s0">let </span><span class="s1">hasReplaced </span><span class="s3">= </span><span class="s0">false</span>
        <span class="s1">utilitySelector </span><span class="s3">= </span><span class="s1">utilitySelector</span><span class="s3">.</span><span class="s1">clone</span><span class="s3">()</span>

        <span class="s1">utilitySelector</span><span class="s3">.</span><span class="s1">walkClasses</span><span class="s3">((</span><span class="s1">node</span><span class="s3">) =&gt; {</span>
          <span class="s0">if </span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">value </span><span class="s3">!== </span><span class="s1">candidateClass</span><span class="s3">.</span><span class="s1">value</span><span class="s3">) {</span>
            <span class="s0">return</span>
          <span class="s3">}</span>

          <span class="s6">// Don't replace multiple instances of the same class</span>
          <span class="s6">// This is theoretically correct but only partially</span>
          <span class="s6">// We'd need to generate every possible permutation of the replacement</span>
          <span class="s6">// For example with `.foo + .foo { â€¦ }` and `section { @apply foo; }`</span>
          <span class="s6">// We'd need to generate all of these:</span>
          <span class="s6">// - `.foo + .foo`</span>
          <span class="s6">// - `.foo + section`</span>
          <span class="s6">// - `section + .foo`</span>
          <span class="s6">// - `section + section`</span>
          <span class="s0">if </span><span class="s3">(</span><span class="s1">hasReplaced</span><span class="s3">) {</span>
            <span class="s0">return</span>
          <span class="s3">}</span>

          <span class="s6">// Since you can only `@apply` class names this is sufficient</span>
          <span class="s6">// We want to replace the matched class name with the selector the user is using</span>
          <span class="s6">// Ex: Replace `.text-blue-500` with `.foo.bar:is(.something-cool)`</span>
          <span class="s1">node</span><span class="s3">.</span><span class="s1">replaceWith</span><span class="s3">(</span><span class="s1">...sel</span><span class="s3">.</span><span class="s1">nodes</span><span class="s3">.</span><span class="s1">map</span><span class="s3">((</span><span class="s1">node</span><span class="s3">) =&gt; </span><span class="s1">node</span><span class="s3">.</span><span class="s1">clone</span><span class="s3">()))</span>

          <span class="s6">// Record that we did something and we want to use this new selector</span>
          <span class="s1">replaced</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">utilitySelector</span><span class="s3">)</span>

          <span class="s1">hasReplaced </span><span class="s3">= </span><span class="s0">true</span>
        <span class="s3">})</span>
      <span class="s3">})</span>

      <span class="s6">// Sort tag names before class names (but only sort each group (separated by a combinator)</span>
      <span class="s6">// separately and not in total)</span>
      <span class="s6">// This happens when replacing `.bar` in `.foo.bar` with a tag like `section`</span>
      <span class="s0">for </span><span class="s3">(</span><span class="s0">let </span><span class="s1">sel of replaced</span><span class="s3">) {</span>
        <span class="s0">let </span><span class="s1">groups </span><span class="s3">= [[]]</span>
        <span class="s0">for </span><span class="s3">(</span><span class="s0">let </span><span class="s1">node of sel</span><span class="s3">.</span><span class="s1">nodes</span><span class="s3">) {</span>
          <span class="s0">if </span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'combinator'</span><span class="s3">) {</span>
            <span class="s1">groups</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">node</span><span class="s3">)</span>
            <span class="s1">groups</span><span class="s3">.</span><span class="s1">push</span><span class="s3">([])</span>
          <span class="s3">} </span><span class="s0">else </span><span class="s3">{</span>
            <span class="s0">let </span><span class="s1">last </span><span class="s3">= </span><span class="s1">groups</span><span class="s3">[</span><span class="s1">groups</span><span class="s3">.</span><span class="s1">length </span><span class="s3">- </span><span class="s7">1</span><span class="s3">]</span>
            <span class="s1">last</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">node</span><span class="s3">)</span>
          <span class="s3">}</span>
        <span class="s3">}</span>

        <span class="s1">sel</span><span class="s3">.</span><span class="s1">nodes </span><span class="s3">= []</span>

        <span class="s0">for </span><span class="s3">(</span><span class="s0">let </span><span class="s1">group of groups</span><span class="s3">) {</span>
          <span class="s0">if </span><span class="s3">(</span><span class="s1">Array</span><span class="s3">.</span><span class="s1">isArray</span><span class="s3">(</span><span class="s1">group</span><span class="s3">)) {</span>
            <span class="s1">group</span><span class="s3">.</span><span class="s1">sort</span><span class="s3">((</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">) =&gt; {</span>
              <span class="s0">if </span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'tag' </span><span class="s3">&amp;&amp; </span><span class="s1">b</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'class'</span><span class="s3">) {</span>
                <span class="s0">return </span><span class="s3">-</span><span class="s7">1</span>
              <span class="s3">} </span><span class="s0">else if </span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'class' </span><span class="s3">&amp;&amp; </span><span class="s1">b</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'tag'</span><span class="s3">) {</span>
                <span class="s0">return </span><span class="s7">1</span>
              <span class="s3">} </span><span class="s0">else if </span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'class' </span><span class="s3">&amp;&amp; </span><span class="s1">b</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'pseudo' </span><span class="s3">&amp;&amp; </span><span class="s1">b</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">startsWith</span><span class="s3">(</span><span class="s2">'::'</span><span class="s3">)) {</span>
                <span class="s0">return </span><span class="s3">-</span><span class="s7">1</span>
              <span class="s3">} </span><span class="s0">else if </span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'pseudo' </span><span class="s3">&amp;&amp; </span><span class="s1">a</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">startsWith</span><span class="s3">(</span><span class="s2">'::'</span><span class="s3">) &amp;&amp; </span><span class="s1">b</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'class'</span><span class="s3">) {</span>
                <span class="s0">return </span><span class="s7">1</span>
              <span class="s3">}</span>

              <span class="s0">return </span><span class="s7">0</span>
            <span class="s3">})</span>
          <span class="s3">}</span>

          <span class="s1">sel</span><span class="s3">.</span><span class="s1">nodes </span><span class="s3">= </span><span class="s1">sel</span><span class="s3">.</span><span class="s1">nodes</span><span class="s3">.</span><span class="s1">concat</span><span class="s3">(</span><span class="s1">group</span><span class="s3">)</span>
        <span class="s3">}</span>
      <span class="s3">}</span>

      <span class="s1">sel</span><span class="s3">.</span><span class="s1">replaceWith</span><span class="s3">(</span><span class="s1">...replaced</span><span class="s3">)</span>
    <span class="s3">})</span>

    <span class="s0">return </span><span class="s1">selectorList</span><span class="s3">.</span><span class="s1">toString</span><span class="s3">()</span>
  <span class="s3">}</span>

  <span class="s0">let </span><span class="s1">perParentApplies </span><span class="s3">= </span><span class="s0">new </span><span class="s1">Map</span><span class="s3">()</span>

  <span class="s6">// Collect all apply candidates and their rules</span>
  <span class="s0">for </span><span class="s3">(</span><span class="s0">let </span><span class="s1">apply of applies</span><span class="s3">) {</span>
    <span class="s0">let </span><span class="s3">[</span><span class="s1">candidates</span><span class="s3">] = </span><span class="s1">perParentApplies</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">apply</span><span class="s3">.</span><span class="s1">parent</span><span class="s3">) || [[], </span><span class="s1">apply</span><span class="s3">.</span><span class="s1">source</span><span class="s3">]</span>

    <span class="s1">perParentApplies</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">apply</span><span class="s3">.</span><span class="s1">parent</span><span class="s3">, [</span><span class="s1">candidates</span><span class="s3">, </span><span class="s1">apply</span><span class="s3">.</span><span class="s1">source</span><span class="s3">])</span>

    <span class="s0">let </span><span class="s3">[</span><span class="s1">applyCandidates</span><span class="s3">, </span><span class="s1">important</span><span class="s3">] = </span><span class="s1">extractApplyCandidates</span><span class="s3">(</span><span class="s1">apply</span><span class="s3">.</span><span class="s1">params</span><span class="s3">)</span>

    <span class="s0">if </span><span class="s3">(</span><span class="s1">apply</span><span class="s3">.</span><span class="s1">parent</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'atrule'</span><span class="s3">) {</span>
      <span class="s0">if </span><span class="s3">(</span><span class="s1">apply</span><span class="s3">.</span><span class="s1">parent</span><span class="s3">.</span><span class="s1">name </span><span class="s3">=== </span><span class="s2">'screen'</span><span class="s3">) {</span>
        <span class="s0">let </span><span class="s1">screenType </span><span class="s3">= </span><span class="s1">apply</span><span class="s3">.</span><span class="s1">parent</span><span class="s3">.</span><span class="s1">params</span>

        <span class="s0">throw </span><span class="s1">apply</span><span class="s3">.</span><span class="s1">error</span><span class="s3">(</span>
          <span class="s2">`@apply is not supported within nested at-rules like @screen. We suggest you write this as @apply </span><span class="s1">$</span><span class="s3">{</span><span class="s1">applyCandidates</span>
            <span class="s3">.</span><span class="s1">map</span><span class="s3">((</span><span class="s1">c</span><span class="s3">) =&gt; </span><span class="s2">`</span><span class="s1">$</span><span class="s3">{</span><span class="s1">screenType</span><span class="s3">}</span><span class="s2">:</span><span class="s1">$</span><span class="s3">{</span><span class="s1">c</span><span class="s3">}</span><span class="s2">`</span><span class="s3">)</span>
            <span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s2">' '</span><span class="s3">)} </span><span class="s2">instead.`</span>
        <span class="s3">)</span>
      <span class="s3">}</span>

      <span class="s0">throw </span><span class="s1">apply</span><span class="s3">.</span><span class="s1">error</span><span class="s3">(</span>
        <span class="s2">`@apply is not supported within nested at-rules like @</span><span class="s1">$</span><span class="s3">{</span><span class="s1">apply</span><span class="s3">.</span><span class="s1">parent</span><span class="s3">.</span><span class="s1">name</span><span class="s3">}</span><span class="s2">. You can fix this by un-nesting @</span><span class="s1">$</span><span class="s3">{</span><span class="s1">apply</span><span class="s3">.</span><span class="s1">parent</span><span class="s3">.</span><span class="s1">name</span><span class="s3">}</span><span class="s2">.`</span>
      <span class="s3">)</span>
    <span class="s3">}</span>

    <span class="s0">for </span><span class="s3">(</span><span class="s0">let </span><span class="s1">applyCandidate of applyCandidates</span><span class="s3">) {</span>
      <span class="s0">if </span><span class="s3">([</span><span class="s1">prefix</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s2">'group'</span><span class="s3">), </span><span class="s1">prefix</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s2">'peer'</span><span class="s3">)].</span><span class="s1">includes</span><span class="s3">(</span><span class="s1">applyCandidate</span><span class="s3">)) {</span>
        <span class="s6">// TODO: Link to specific documentation page with error code.</span>
        <span class="s0">throw </span><span class="s1">apply</span><span class="s3">.</span><span class="s1">error</span><span class="s3">(</span><span class="s2">`@apply should not be used with the '</span><span class="s1">$</span><span class="s3">{</span><span class="s1">applyCandidate</span><span class="s3">}</span><span class="s2">' utility`</span><span class="s3">)</span>
      <span class="s3">}</span>

      <span class="s0">if </span><span class="s3">(!</span><span class="s1">applyClassCache</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s1">applyCandidate</span><span class="s3">)) {</span>
        <span class="s0">throw </span><span class="s1">apply</span><span class="s3">.</span><span class="s1">error</span><span class="s3">(</span>
          <span class="s2">`The </span><span class="s0">\`</span><span class="s1">$</span><span class="s3">{</span><span class="s1">applyCandidate</span><span class="s3">}</span><span class="s0">\` </span><span class="s2">class does not exist. If </span><span class="s0">\`</span><span class="s1">$</span><span class="s3">{</span><span class="s1">applyCandidate</span><span class="s3">}</span><span class="s0">\` </span><span class="s2">is a custom class, make sure it is defined within a </span><span class="s0">\`</span><span class="s2">@layer</span><span class="s0">\` </span><span class="s2">directive.`</span>
        <span class="s3">)</span>
      <span class="s3">}</span>

      <span class="s0">let </span><span class="s1">rules </span><span class="s3">= </span><span class="s1">applyClassCache</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">applyCandidate</span><span class="s3">)</span>

      <span class="s6">// Verify that we can apply the class</span>
      <span class="s0">for </span><span class="s3">(</span><span class="s0">let </span><span class="s3">[, </span><span class="s1">rule</span><span class="s3">] </span><span class="s1">of rules</span><span class="s3">) {</span>
        <span class="s0">if </span><span class="s3">(</span><span class="s1">rule</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'atrule'</span><span class="s3">) {</span>
          <span class="s0">continue</span>
        <span class="s3">}</span>

        <span class="s1">rule</span><span class="s3">.</span><span class="s1">walkRules</span><span class="s3">(() =&gt; {</span>
          <span class="s0">throw </span><span class="s1">apply</span><span class="s3">.</span><span class="s1">error</span><span class="s3">(</span>
            <span class="s3">[</span>
              <span class="s2">`The </span><span class="s0">\`</span><span class="s1">$</span><span class="s3">{</span><span class="s1">applyCandidate</span><span class="s3">}</span><span class="s0">\` </span><span class="s2">class cannot be used with </span><span class="s0">\`</span><span class="s2">@apply</span><span class="s0">\` </span><span class="s2">because </span><span class="s0">\`</span><span class="s2">@apply</span><span class="s0">\` </span><span class="s2">does not currently support nested CSS.`</span><span class="s3">,</span>
              <span class="s2">'Rewrite the selector without nesting or configure the `tailwindcss/nesting` plugin:'</span><span class="s3">,</span>
              <span class="s2">'https://tailwindcss.com/docs/using-with-preprocessors#nesting'</span><span class="s3">,</span>
            <span class="s3">].</span><span class="s1">join</span><span class="s3">(</span><span class="s2">'</span><span class="s0">\n</span><span class="s2">'</span><span class="s3">)</span>
          <span class="s3">)</span>
        <span class="s3">})</span>
      <span class="s3">}</span>

      <span class="s1">candidates</span><span class="s3">.</span><span class="s1">push</span><span class="s3">([</span><span class="s1">applyCandidate</span><span class="s3">, </span><span class="s1">important</span><span class="s3">, </span><span class="s1">rules</span><span class="s3">])</span>
    <span class="s3">}</span>
  <span class="s3">}</span>

  <span class="s0">for </span><span class="s3">(</span><span class="s0">let </span><span class="s3">[</span><span class="s1">parent</span><span class="s3">, [</span><span class="s1">candidates</span><span class="s3">, </span><span class="s1">atApplySource</span><span class="s3">]] </span><span class="s1">of perParentApplies</span><span class="s3">) {</span>
    <span class="s0">let </span><span class="s1">siblings </span><span class="s3">= []</span>

    <span class="s0">for </span><span class="s3">(</span><span class="s0">let </span><span class="s3">[</span><span class="s1">applyCandidate</span><span class="s3">, </span><span class="s1">important</span><span class="s3">, </span><span class="s1">rules</span><span class="s3">] </span><span class="s1">of candidates</span><span class="s3">) {</span>
      <span class="s0">let </span><span class="s1">potentialApplyCandidates </span><span class="s3">= [</span>
        <span class="s1">applyCandidate</span><span class="s3">,</span>
        <span class="s1">...extractBaseCandidates</span><span class="s3">([</span><span class="s1">applyCandidate</span><span class="s3">], </span><span class="s1">context</span><span class="s3">.</span><span class="s1">tailwindConfig</span><span class="s3">.</span><span class="s1">separator</span><span class="s3">),</span>
      <span class="s3">]</span>

      <span class="s0">for </span><span class="s3">(</span><span class="s0">let </span><span class="s3">[</span><span class="s1">meta</span><span class="s3">, </span><span class="s1">node</span><span class="s3">] </span><span class="s1">of rules</span><span class="s3">) {</span>
        <span class="s0">let </span><span class="s1">parentClasses </span><span class="s3">= </span><span class="s1">extractClasses</span><span class="s3">(</span><span class="s1">parent</span><span class="s3">)</span>
        <span class="s0">let </span><span class="s1">nodeClasses </span><span class="s3">= </span><span class="s1">extractClasses</span><span class="s3">(</span><span class="s1">node</span><span class="s3">)</span>

        <span class="s6">// When we encounter a rule like `.dark .a, .b { â€¦ }` we only want to be left with `[.dark, .a]` if the base applyCandidate is `.a` or with `[.b]` if the base applyCandidate is `.b`</span>
        <span class="s6">// So we've split them into groups</span>
        <span class="s1">nodeClasses </span><span class="s3">= </span><span class="s1">nodeClasses</span><span class="s3">.</span><span class="s1">groups</span>
          <span class="s3">.</span><span class="s1">filter</span><span class="s3">((</span><span class="s1">classList</span><span class="s3">) =&gt;</span>
            <span class="s1">classList</span><span class="s3">.</span><span class="s1">some</span><span class="s3">((</span><span class="s1">className</span><span class="s3">) =&gt; </span><span class="s1">potentialApplyCandidates</span><span class="s3">.</span><span class="s1">includes</span><span class="s3">(</span><span class="s1">className</span><span class="s3">))</span>
          <span class="s3">)</span>
          <span class="s3">.</span><span class="s1">flat</span><span class="s3">()</span>

        <span class="s6">// Add base utility classes from the @apply node to the list of</span>
        <span class="s6">// classes to check whether it intersects and therefore results in a</span>
        <span class="s6">// circular dependency or not.</span>
        <span class="s6">//</span>
        <span class="s6">// E.g.:</span>
        <span class="s6">// .foo {</span>
        <span class="s6">//   @apply hover:a; // This applies &quot;a&quot; but with a modifier</span>
        <span class="s6">// }</span>
        <span class="s6">//</span>
        <span class="s6">// We only have to do that with base classes of the `node`, not of the `parent`</span>
        <span class="s6">// E.g.:</span>
        <span class="s6">// .hover\:foo {</span>
        <span class="s6">//   @apply bar;</span>
        <span class="s6">// }</span>
        <span class="s6">// .bar {</span>
        <span class="s6">//   @apply foo;</span>
        <span class="s6">// }</span>
        <span class="s6">//</span>
        <span class="s6">// This should not result in a circular dependency because we are</span>
        <span class="s6">// just applying `.foo` and the rule above is `.hover\:foo` which is</span>
        <span class="s6">// unrelated. However, if we were to apply `hover:foo` then we _did_</span>
        <span class="s6">// have to include this one.</span>
        <span class="s1">nodeClasses </span><span class="s3">= </span><span class="s1">nodeClasses</span><span class="s3">.</span><span class="s1">concat</span><span class="s3">(</span>
          <span class="s1">extractBaseCandidates</span><span class="s3">(</span><span class="s1">nodeClasses</span><span class="s3">, </span><span class="s1">context</span><span class="s3">.</span><span class="s1">tailwindConfig</span><span class="s3">.</span><span class="s1">separator</span><span class="s3">)</span>
        <span class="s3">)</span>

        <span class="s0">let </span><span class="s1">intersects </span><span class="s3">= </span><span class="s1">parentClasses</span><span class="s3">.</span><span class="s1">some</span><span class="s3">((</span><span class="s1">selector</span><span class="s3">) =&gt; </span><span class="s1">nodeClasses</span><span class="s3">.</span><span class="s1">includes</span><span class="s3">(</span><span class="s1">selector</span><span class="s3">))</span>
        <span class="s0">if </span><span class="s3">(</span><span class="s1">intersects</span><span class="s3">) {</span>
          <span class="s0">throw </span><span class="s1">node</span><span class="s3">.</span><span class="s1">error</span><span class="s3">(</span>
            <span class="s2">`You cannot </span><span class="s0">\`</span><span class="s2">@apply</span><span class="s0">\` </span><span class="s2">the </span><span class="s0">\`</span><span class="s1">$</span><span class="s3">{</span><span class="s1">applyCandidate</span><span class="s3">}</span><span class="s0">\` </span><span class="s2">utility here because it creates a circular dependency.`</span>
          <span class="s3">)</span>
        <span class="s3">}</span>

        <span class="s0">let </span><span class="s1">root </span><span class="s3">= </span><span class="s1">postcss</span><span class="s3">.</span><span class="s1">root</span><span class="s3">({ </span><span class="s1">nodes</span><span class="s3">: [</span><span class="s1">node</span><span class="s3">.</span><span class="s1">clone</span><span class="s3">()] })</span>

        <span class="s6">// Make sure every node in the entire tree points back at the @apply rule that generated it</span>
        <span class="s1">root</span><span class="s3">.</span><span class="s1">walk</span><span class="s3">((</span><span class="s1">node</span><span class="s3">) =&gt; {</span>
          <span class="s1">node</span><span class="s3">.</span><span class="s1">source </span><span class="s3">= </span><span class="s1">atApplySource</span>
        <span class="s3">})</span>

        <span class="s0">let </span><span class="s1">canRewriteSelector </span><span class="s3">=</span>
          <span class="s1">node</span><span class="s3">.</span><span class="s1">type </span><span class="s3">!== </span><span class="s2">'atrule' </span><span class="s3">|| (</span><span class="s1">node</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'atrule' </span><span class="s3">&amp;&amp; </span><span class="s1">node</span><span class="s3">.</span><span class="s1">name </span><span class="s3">!== </span><span class="s2">'keyframes'</span><span class="s3">)</span>

        <span class="s0">if </span><span class="s3">(</span><span class="s1">canRewriteSelector</span><span class="s3">) {</span>
          <span class="s1">root</span><span class="s3">.</span><span class="s1">walkRules</span><span class="s3">((</span><span class="s1">rule</span><span class="s3">) =&gt; {</span>
            <span class="s6">// Let's imagine you have the following structure:</span>
            <span class="s6">//</span>
            <span class="s6">// .foo {</span>
            <span class="s6">//   @apply bar;</span>
            <span class="s6">// }</span>
            <span class="s6">//</span>
            <span class="s6">// @supports (a: b) {</span>
            <span class="s6">//   .bar {</span>
            <span class="s6">//     color: blue</span>
            <span class="s6">//   }</span>
            <span class="s6">//</span>
            <span class="s6">//   .something-unrelated {}</span>
            <span class="s6">// }</span>
            <span class="s6">//</span>
            <span class="s6">// In this case we want to apply `.bar` but it happens to be in</span>
            <span class="s6">// an atrule node. We clone that node instead of the nested one</span>
            <span class="s6">// because we still want that @supports rule to be there once we</span>
            <span class="s6">// applied everything.</span>
            <span class="s6">//</span>
            <span class="s6">// However it happens to be that the `.something-unrelated` is</span>
            <span class="s6">// also in that same shared @supports atrule. This is not good,</span>
            <span class="s6">// and this should not be there. The good part is that this is</span>
            <span class="s6">// a clone already and it can be safely removed. The question is</span>
            <span class="s6">// how do we know we can remove it. Basically what we can do is</span>
            <span class="s6">// match it against the applyCandidate that you want to apply. If</span>
            <span class="s6">// it doesn't match the we can safely delete it.</span>
            <span class="s6">//</span>
            <span class="s6">// If we didn't do this, then the `replaceSelector` function</span>
            <span class="s6">// would have replaced this with something that didn't exist and</span>
            <span class="s6">// therefore it removed the selector altogether. In this specific</span>
            <span class="s6">// case it would result in `{}` instead of `.something-unrelated {}`</span>
            <span class="s0">if </span><span class="s3">(!</span><span class="s1">extractClasses</span><span class="s3">(</span><span class="s1">rule</span><span class="s3">).</span><span class="s1">some</span><span class="s3">((</span><span class="s1">candidate</span><span class="s3">) =&gt; </span><span class="s1">candidate </span><span class="s3">=== </span><span class="s1">applyCandidate</span><span class="s3">)) {</span>
              <span class="s1">rule</span><span class="s3">.</span><span class="s1">remove</span><span class="s3">()</span>
              <span class="s0">return</span>
            <span class="s3">}</span>

            <span class="s6">// Strip the important selector from the parent selector if at the beginning</span>
            <span class="s0">let </span><span class="s1">importantSelector </span><span class="s3">=</span>
              <span class="s0">typeof </span><span class="s1">context</span><span class="s3">.</span><span class="s1">tailwindConfig</span><span class="s3">.</span><span class="s1">important </span><span class="s3">=== </span><span class="s2">'string'</span>
                <span class="s3">? </span><span class="s1">context</span><span class="s3">.</span><span class="s1">tailwindConfig</span><span class="s3">.</span><span class="s1">important</span>
                <span class="s3">: </span><span class="s0">null</span>

            <span class="s6">// We only want to move the &quot;important&quot; selector if this is a Tailwind-generated utility</span>
            <span class="s6">// We do *not* want to do this for user CSS that happens to be structured the same</span>
            <span class="s0">let </span><span class="s1">isGenerated </span><span class="s3">= </span><span class="s1">parent</span><span class="s3">.</span><span class="s1">raws</span><span class="s3">.</span><span class="s1">tailwind </span><span class="s3">!== </span><span class="s1">undefined</span>

            <span class="s0">let </span><span class="s1">parentSelector </span><span class="s3">=</span>
              <span class="s1">isGenerated </span><span class="s3">&amp;&amp; </span><span class="s1">importantSelector </span><span class="s3">&amp;&amp; </span><span class="s1">parent</span><span class="s3">.</span><span class="s1">selector</span><span class="s3">.</span><span class="s1">indexOf</span><span class="s3">(</span><span class="s1">importantSelector</span><span class="s3">) === </span><span class="s7">0</span>
                <span class="s3">? </span><span class="s1">parent</span><span class="s3">.</span><span class="s1">selector</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span><span class="s1">importantSelector</span><span class="s3">.</span><span class="s1">length</span><span class="s3">)</span>
                <span class="s3">: </span><span class="s1">parent</span><span class="s3">.</span><span class="s1">selector</span>

            <span class="s6">// If the selector becomes empty after replacing the important selector</span>
            <span class="s6">// This means that it's the same as the parent selector and we don't want to replace it</span>
            <span class="s6">// Otherwise we'll crash</span>
            <span class="s0">if </span><span class="s3">(</span><span class="s1">parentSelector </span><span class="s3">=== </span><span class="s2">''</span><span class="s3">) {</span>
              <span class="s1">parentSelector </span><span class="s3">= </span><span class="s1">parent</span><span class="s3">.</span><span class="s1">selector</span>
            <span class="s3">}</span>

            <span class="s1">rule</span><span class="s3">.</span><span class="s1">selector </span><span class="s3">= </span><span class="s1">replaceSelector</span><span class="s3">(</span><span class="s1">parentSelector</span><span class="s3">, </span><span class="s1">rule</span><span class="s3">.</span><span class="s1">selector</span><span class="s3">, </span><span class="s1">applyCandidate</span><span class="s3">)</span>

            <span class="s6">// And then re-add it if it was removed</span>
            <span class="s0">if </span><span class="s3">(</span><span class="s1">importantSelector </span><span class="s3">&amp;&amp; </span><span class="s1">parentSelector </span><span class="s3">!== </span><span class="s1">parent</span><span class="s3">.</span><span class="s1">selector</span><span class="s3">) {</span>
              <span class="s1">rule</span><span class="s3">.</span><span class="s1">selector </span><span class="s3">= </span><span class="s1">applyImportantSelector</span><span class="s3">(</span><span class="s1">rule</span><span class="s3">.</span><span class="s1">selector</span><span class="s3">, </span><span class="s1">importantSelector</span><span class="s3">)</span>
            <span class="s3">}</span>

            <span class="s1">rule</span><span class="s3">.</span><span class="s1">walkDecls</span><span class="s3">((</span><span class="s1">d</span><span class="s3">) =&gt; {</span>
              <span class="s1">d</span><span class="s3">.</span><span class="s1">important </span><span class="s3">= </span><span class="s1">meta</span><span class="s3">.</span><span class="s1">important </span><span class="s3">|| </span><span class="s1">important</span>
            <span class="s3">})</span>

            <span class="s6">// Move pseudo elements to the end of the selector (if necessary)</span>
            <span class="s0">let </span><span class="s1">selector </span><span class="s3">= </span><span class="s1">parser</span><span class="s3">().</span><span class="s1">astSync</span><span class="s3">(</span><span class="s1">rule</span><span class="s3">.</span><span class="s1">selector</span><span class="s3">)</span>
            <span class="s1">selector</span><span class="s3">.</span><span class="s1">each</span><span class="s3">((</span><span class="s1">sel</span><span class="s3">) =&gt; </span><span class="s1">movePseudos</span><span class="s3">(</span><span class="s1">sel</span><span class="s3">))</span>
            <span class="s1">rule</span><span class="s3">.</span><span class="s1">selector </span><span class="s3">= </span><span class="s1">selector</span><span class="s3">.</span><span class="s1">toString</span><span class="s3">()</span>
          <span class="s3">})</span>
        <span class="s3">}</span>

        <span class="s6">// It could be that the node we were inserted was removed because the class didn't match</span>
        <span class="s6">// If that was the *only* rule in the parent, then we have nothing add so we skip it</span>
        <span class="s0">if </span><span class="s3">(!</span><span class="s1">root</span><span class="s3">.</span><span class="s1">nodes</span><span class="s3">[</span><span class="s7">0</span><span class="s3">]) {</span>
          <span class="s0">continue</span>
        <span class="s3">}</span>

        <span class="s6">// Insert it</span>
        <span class="s1">siblings</span><span class="s3">.</span><span class="s1">push</span><span class="s3">([</span><span class="s1">meta</span><span class="s3">.</span><span class="s1">sort</span><span class="s3">, </span><span class="s1">root</span><span class="s3">.</span><span class="s1">nodes</span><span class="s3">[</span><span class="s7">0</span><span class="s3">]])</span>
      <span class="s3">}</span>
    <span class="s3">}</span>

    <span class="s6">// Inject the rules, sorted, correctly</span>
    <span class="s0">let </span><span class="s1">nodes </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">offsets</span><span class="s3">.</span><span class="s1">sort</span><span class="s3">(</span><span class="s1">siblings</span><span class="s3">).</span><span class="s1">map</span><span class="s3">((</span><span class="s1">s</span><span class="s3">) =&gt; </span><span class="s1">s</span><span class="s3">[</span><span class="s7">1</span><span class="s3">])</span>

    <span class="s6">// `parent` refers to the node at `.abc` in: .abc { @apply mt-2 }</span>
    <span class="s1">parent</span><span class="s3">.</span><span class="s1">after</span><span class="s3">(</span><span class="s1">nodes</span><span class="s3">)</span>
  <span class="s3">}</span>

  <span class="s0">for </span><span class="s3">(</span><span class="s0">let </span><span class="s1">apply of applies</span><span class="s3">) {</span>
    <span class="s6">// If there are left-over declarations, just remove the @apply</span>
    <span class="s0">if </span><span class="s3">(</span><span class="s1">apply</span><span class="s3">.</span><span class="s1">parent</span><span class="s3">.</span><span class="s1">nodes</span><span class="s3">.</span><span class="s1">length </span><span class="s3">&gt; </span><span class="s7">1</span><span class="s3">) {</span>
      <span class="s1">apply</span><span class="s3">.</span><span class="s1">remove</span><span class="s3">()</span>
    <span class="s3">} </span><span class="s0">else </span><span class="s3">{</span>
      <span class="s6">// The node is empty, drop the full node</span>
      <span class="s1">apply</span><span class="s3">.</span><span class="s1">parent</span><span class="s3">.</span><span class="s1">remove</span><span class="s3">()</span>
    <span class="s3">}</span>
  <span class="s3">}</span>

  <span class="s6">// Do it again, in case we have other `@apply` rules</span>
  <span class="s1">processApply</span><span class="s3">(</span><span class="s1">root</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">localCache</span><span class="s3">)</span>
<span class="s3">}</span>

<span class="s0">export default function </span><span class="s1">expandApplyAtRules</span><span class="s3">(</span><span class="s1">context</span><span class="s3">) {</span>
  <span class="s0">return </span><span class="s3">(</span><span class="s1">root</span><span class="s3">) =&gt; {</span>
    <span class="s6">// Build a cache of the user's CSS so we can use it to resolve classes used by @apply</span>
    <span class="s0">let </span><span class="s1">localCache </span><span class="s3">= </span><span class="s1">lazyCache</span><span class="s3">(() =&gt; </span><span class="s1">buildLocalApplyCache</span><span class="s3">(</span><span class="s1">root</span><span class="s3">, </span><span class="s1">context</span><span class="s3">))</span>

    <span class="s1">processApply</span><span class="s3">(</span><span class="s1">root</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">localCache</span><span class="s3">)</span>
  <span class="s3">}</span>
<span class="s3">}</span>
</pre>
</body>
</html>