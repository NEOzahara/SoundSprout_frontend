<html>
<head>
<title>expressions.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
expressions.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_t&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;_index&quot;</span><span class="s0">,</span><span class="s1">&quot;isCallExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;isMemberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isNewExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isPattern&quot;</span><span class="s0">,</span><span class="s1">&quot;UnaryExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;operator&quot;</span><span class="s0">,</span><span class="s1">&quot;word&quot;</span><span class="s0">,</span><span class="s1">&quot;space&quot;</span><span class="s0">,</span><span class="s1">&quot;token&quot;</span><span class="s0">,</span><span class="s1">&quot;print&quot;</span><span class="s0">,</span><span class="s1">&quot;argument&quot;</span><span class="s0">,</span><span class="s1">&quot;DoExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;async&quot;</span><span class="s0">,</span><span class="s1">&quot;body&quot;</span><span class="s0">,</span><span class="s1">&quot;ParenthesizedExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;exit&quot;</span><span class="s0">,</span><span class="s1">&quot;enterDelimited&quot;</span><span class="s0">,</span><span class="s1">&quot;expression&quot;</span><span class="s0">,</span><span class="s1">&quot;rightParens&quot;</span><span class="s0">,</span><span class="s1">&quot;UpdateExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;prefix&quot;</span><span class="s0">,</span><span class="s1">&quot;ConditionalExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;test&quot;</span><span class="s0">,</span><span class="s1">&quot;consequent&quot;</span><span class="s0">,</span><span class="s1">&quot;alternate&quot;</span><span class="s0">,</span><span class="s1">&quot;NewExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;parent&quot;</span><span class="s0">,</span><span class="s1">&quot;callee&quot;</span><span class="s0">,</span><span class="s1">&quot;format&quot;</span><span class="s0">,</span><span class="s1">&quot;minified&quot;</span><span class="s0">,</span><span class="s1">&quot;arguments&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;optional&quot;</span><span class="s0">,</span><span class="s1">&quot;typeArguments&quot;</span><span class="s0">,</span><span class="s1">&quot;typeParameters&quot;</span><span class="s0">,</span><span class="s1">&quot;tokenMap&quot;</span><span class="s0">,</span><span class="s1">&quot;endMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;printList&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldPrintTrailingComma&quot;</span><span class="s0">,</span><span class="s1">&quot;SequenceExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;expressions&quot;</span><span class="s0">,</span><span class="s1">&quot;ThisExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;Super&quot;</span><span class="s0">,</span><span class="s1">&quot;_shouldPrintDecoratorsBeforeExport&quot;</span><span class="s0">,</span><span class="s1">&quot;decoratorsBeforeExport&quot;</span><span class="s0">,</span><span class="s1">&quot;start&quot;</span><span class="s0">,</span><span class="s1">&quot;declaration&quot;</span><span class="s0">,</span><span class="s1">&quot;Decorator&quot;</span><span class="s0">,</span><span class="s1">&quot;newline&quot;</span><span class="s0">,</span><span class="s1">&quot;OptionalMemberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;computed&quot;</span><span class="s0">,</span><span class="s1">&quot;property&quot;</span><span class="s0">,</span><span class="s1">&quot;object&quot;</span><span class="s0">,</span><span class="s1">&quot;TypeError&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;OptionalCallExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;CallExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;Import&quot;</span><span class="s0">,</span><span class="s1">&quot;AwaitExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;printTerminatorless&quot;</span><span class="s0">,</span><span class="s1">&quot;YieldExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;delegate&quot;</span><span class="s0">,</span><span class="s1">&quot;EmptyStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;semicolon&quot;</span><span class="s0">,</span><span class="s1">&quot;ExpressionStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;tokenContext&quot;</span><span class="s0">,</span><span class="s1">&quot;TokenContext&quot;</span><span class="s0">,</span><span class="s1">&quot;expressionStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;AssignmentPattern&quot;</span><span class="s0">,</span><span class="s1">&quot;left&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;typeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;right&quot;</span><span class="s0">,</span><span class="s1">&quot;AssignmentExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;_endsWithDiv&quot;</span><span class="s0">,</span><span class="s1">&quot;BindExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;MemberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;MetaProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;meta&quot;</span><span class="s0">,</span><span class="s1">&quot;PrivateName&quot;</span><span class="s0">,</span><span class="s1">&quot;id&quot;</span><span class="s0">,</span><span class="s1">&quot;V8IntrinsicIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;ModuleExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;indent&quot;</span><span class="s0">,</span><span class="s1">&quot;directives&quot;</span><span class="s0">,</span><span class="s1">&quot;dedent&quot;</span><span class="s0">,</span><span class="s1">&quot;rightBrace&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../src/generators/expressions.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type Printer from </span><span class="s3">\&quot;</span><span class="s1">../printer.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">isCallExpression,</span><span class="s3">\n  </span><span class="s1">isLiteral,</span><span class="s3">\n  </span><span class="s1">isMemberExpression,</span><span class="s3">\n  </span><span class="s1">isNewExpression,</span><span class="s3">\n  </span><span class="s1">isPattern,</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">@babel/types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type * as t from </span><span class="s3">\&quot;</span><span class="s1">@babel/types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { TokenContext } from </span><span class="s3">\&quot;</span><span class="s1">../node/index.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">export function UnaryExpression(this: Printer, node: t.UnaryExpression) {</span><span class="s3">\n  </span><span class="s1">const { operator } = node;</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">operator === </span><span class="s3">\&quot;</span><span class="s1">void</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n    </span><span class="s1">operator === </span><span class="s3">\&quot;</span><span class="s1">delete</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n    </span><span class="s1">operator === </span><span class="s3">\&quot;</span><span class="s1">typeof</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n    </span><span class="s1">// throwExpressions</span><span class="s3">\n    </span><span class="s1">operator === </span><span class="s3">\&quot;</span><span class="s1">throw</span><span class="s3">\&quot;\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">this.word(operator);</span><span class="s3">\n    </span><span class="s1">this.space();</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">this.token(operator);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">this.print(node.argument);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function DoExpression(this: Printer, node: t.DoExpression) {</span><span class="s3">\n  </span><span class="s1">if (node.async) {</span><span class="s3">\n    </span><span class="s1">this.word(</span><span class="s3">\&quot;</span><span class="s1">async</span><span class="s3">\&quot;</span><span class="s1">, true);</span><span class="s3">\n    </span><span class="s1">this.space();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">this.word(</span><span class="s3">\&quot;</span><span class="s1">do</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">this.space();</span><span class="s3">\n  </span><span class="s1">this.print(node.body);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function ParenthesizedExpression(</span><span class="s3">\n  </span><span class="s1">this: Printer,</span><span class="s3">\n  </span><span class="s1">node: t.ParenthesizedExpression,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">const exit = this.enterDelimited();</span><span class="s3">\n  </span><span class="s1">this.print(node.expression);</span><span class="s3">\n  </span><span class="s1">exit();</span><span class="s3">\n  </span><span class="s1">this.rightParens(node);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function UpdateExpression(this: Printer, node: t.UpdateExpression) {</span><span class="s3">\n  </span><span class="s1">if (node.prefix) {</span><span class="s3">\n    </span><span class="s1">this.token(node.operator);</span><span class="s3">\n    </span><span class="s1">this.print(node.argument);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">this.print(node.argument, true);</span><span class="s3">\n    </span><span class="s1">this.token(node.operator);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function ConditionalExpression(</span><span class="s3">\n  </span><span class="s1">this: Printer,</span><span class="s3">\n  </span><span class="s1">node: t.ConditionalExpression,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">this.print(node.test);</span><span class="s3">\n  </span><span class="s1">this.space();</span><span class="s3">\n  </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">this.space();</span><span class="s3">\n  </span><span class="s1">this.print(node.consequent);</span><span class="s3">\n  </span><span class="s1">this.space();</span><span class="s3">\n  </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">this.space();</span><span class="s3">\n  </span><span class="s1">this.print(node.alternate);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function NewExpression(</span><span class="s3">\n  </span><span class="s1">this: Printer,</span><span class="s3">\n  </span><span class="s1">node: t.NewExpression,</span><span class="s3">\n  </span><span class="s1">parent: t.Node,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">this.word(</span><span class="s3">\&quot;</span><span class="s1">new</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">this.space();</span><span class="s3">\n  </span><span class="s1">this.print(node.callee);</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">this.format.minified &amp;&amp;</span><span class="s3">\n    </span><span class="s1">node.arguments.length === 0 &amp;&amp;</span><span class="s3">\n    </span><span class="s1">// @ts-ignore(Babel 7 vs Babel 8) Removed in Babel 8</span><span class="s3">\n    </span><span class="s1">!node.optional &amp;&amp;</span><span class="s3">\n    </span><span class="s1">!isCallExpression(parent, { callee: node }) &amp;&amp;</span><span class="s3">\n    </span><span class="s1">!isMemberExpression(parent) &amp;&amp;</span><span class="s3">\n    </span><span class="s1">!isNewExpression(parent)</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">this.print(node.typeArguments);</span><span class="s3">\n  </span><span class="s1">if (!process.env.BABEL_8_BREAKING) {</span><span class="s3">\n    </span><span class="s1">// @ts-ignore(Babel 7 vs Babel 8) Removed in Babel 8</span><span class="s3">\n    </span><span class="s1">this.print(node.typeParameters); // Legacy TS AST</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// @ts-ignore(Babel 7 vs Babel 8) Removed in Babel 8</span><span class="s3">\n  </span><span class="s1">if (node.optional) {</span><span class="s3">\n    </span><span class="s1">// TODO: This can never happen</span><span class="s3">\n    </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">?.</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">node.arguments.length === 0 &amp;&amp;</span><span class="s3">\n    </span><span class="s1">this.tokenMap &amp;&amp;</span><span class="s3">\n    </span><span class="s1">!this.tokenMap.endMatches(node, </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">const exit = this.enterDelimited();</span><span class="s3">\n  </span><span class="s1">this.printList(node.arguments, this.shouldPrintTrailingComma(</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n  </span><span class="s1">exit();</span><span class="s3">\n  </span><span class="s1">this.rightParens(node);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function SequenceExpression(this: Printer, node: t.SequenceExpression) {</span><span class="s3">\n  </span><span class="s1">this.printList(node.expressions);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function ThisExpression(this: Printer) {</span><span class="s3">\n  </span><span class="s1">this.word(</span><span class="s3">\&quot;</span><span class="s1">this</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function Super(this: Printer) {</span><span class="s3">\n  </span><span class="s1">this.word(</span><span class="s3">\&quot;</span><span class="s1">super</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function _shouldPrintDecoratorsBeforeExport(</span><span class="s3">\n  </span><span class="s1">this: Printer,</span><span class="s3">\n  </span><span class="s1">node: t.ExportDeclaration &amp; { declaration: t.ClassDeclaration },</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">if (typeof this.format.decoratorsBeforeExport === </span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return this.format.decoratorsBeforeExport;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">typeof node.start === </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; node.start === node.declaration.start</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function Decorator(this: Printer, node: t.Decorator) {</span><span class="s3">\n  </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">@</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">this.print(node.expression);</span><span class="s3">\n  </span><span class="s1">this.newline();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function OptionalMemberExpression(</span><span class="s3">\n  </span><span class="s1">this: Printer,</span><span class="s3">\n  </span><span class="s1">node: t.OptionalMemberExpression,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">let { computed } = node;</span><span class="s3">\n  </span><span class="s1">const { optional, property } = node;</span><span class="s3">\n\n  </span><span class="s1">this.print(node.object);</span><span class="s3">\n\n  </span><span class="s1">if (!computed &amp;&amp; isMemberExpression(property)) {</span><span class="s3">\n    </span><span class="s1">throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">Got a MemberExpression for MemberExpression property</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts) maybe instead of typeof check specific literal types?</span><span class="s3">\n  </span><span class="s1">if (isLiteral(property) &amp;&amp; typeof property.value === </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">computed = true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (optional) {</span><span class="s3">\n    </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">?.</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (computed) {</span><span class="s3">\n    </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">this.print(property);</span><span class="s3">\n    </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">if (!optional) {</span><span class="s3">\n      </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.print(property);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function OptionalCallExpression(</span><span class="s3">\n  </span><span class="s1">this: Printer,</span><span class="s3">\n  </span><span class="s1">node: t.OptionalCallExpression,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">this.print(node.callee);</span><span class="s3">\n\n  </span><span class="s1">if (!process.env.BABEL_8_BREAKING) {</span><span class="s3">\n    </span><span class="s1">// @ts-ignore(Babel 7 vs Babel 8) Removed in Babel 8</span><span class="s3">\n    </span><span class="s1">this.print(node.typeParameters); // legacy TS AST</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (node.optional) {</span><span class="s3">\n    </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">?.</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">this.print(node.typeArguments);</span><span class="s3">\n\n  </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">const exit = this.enterDelimited();</span><span class="s3">\n  </span><span class="s1">this.printList(node.arguments);</span><span class="s3">\n  </span><span class="s1">exit();</span><span class="s3">\n  </span><span class="s1">this.rightParens(node);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function CallExpression(this: Printer, node: t.CallExpression) {</span><span class="s3">\n  </span><span class="s1">this.print(node.callee);</span><span class="s3">\n\n  </span><span class="s1">this.print(node.typeArguments);</span><span class="s3">\n  </span><span class="s1">if (!process.env.BABEL_8_BREAKING) {</span><span class="s3">\n    </span><span class="s1">// @ts-ignore(Babel 7 vs Babel 8) Removed in Babel 8</span><span class="s3">\n    </span><span class="s1">this.print(node.typeParameters); // legacy TS AST</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">const exit = this.enterDelimited();</span><span class="s3">\n  </span><span class="s1">this.printList(node.arguments, this.shouldPrintTrailingComma(</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n  </span><span class="s1">exit();</span><span class="s3">\n  </span><span class="s1">this.rightParens(node);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function Import(this: Printer) {</span><span class="s3">\n  </span><span class="s1">this.word(</span><span class="s3">\&quot;</span><span class="s1">import</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function AwaitExpression(this: Printer, node: t.AwaitExpression) {</span><span class="s3">\n  </span><span class="s1">this.word(</span><span class="s3">\&quot;</span><span class="s1">await</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n  </span><span class="s1">if (node.argument) {</span><span class="s3">\n    </span><span class="s1">this.space();</span><span class="s3">\n    </span><span class="s1">this.printTerminatorless(node.argument);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function YieldExpression(this: Printer, node: t.YieldExpression) {</span><span class="s3">\n  </span><span class="s1">this.word(</span><span class="s3">\&quot;</span><span class="s1">yield</span><span class="s3">\&quot;</span><span class="s1">, true);</span><span class="s3">\n\n  </span><span class="s1">if (node.delegate) {</span><span class="s3">\n    </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">if (node.argument) {</span><span class="s3">\n      </span><span class="s1">this.space();</span><span class="s3">\n      </span><span class="s1">// line terminators are allowed after yield*</span><span class="s3">\n      </span><span class="s1">this.print(node.argument);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">if (node.argument) {</span><span class="s3">\n      </span><span class="s1">this.space();</span><span class="s3">\n      </span><span class="s1">this.printTerminatorless(node.argument);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function EmptyStatement(this: Printer) {</span><span class="s3">\n  </span><span class="s1">this.semicolon(true /* force */);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function ExpressionStatement(</span><span class="s3">\n  </span><span class="s1">this: Printer,</span><span class="s3">\n  </span><span class="s1">node: t.ExpressionStatement,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">this.tokenContext |= TokenContext.expressionStatement;</span><span class="s3">\n  </span><span class="s1">this.print(node.expression);</span><span class="s3">\n  </span><span class="s1">this.semicolon();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function AssignmentPattern(this: Printer, node: t.AssignmentPattern) {</span><span class="s3">\n  </span><span class="s1">this.print(node.left);</span><span class="s3">\n  </span><span class="s1">if (node.left.type === </span><span class="s3">\&quot;</span><span class="s1">Identifier</span><span class="s3">\&quot; </span><span class="s1">|| isPattern(node.left)) {</span><span class="s3">\n    </span><span class="s1">if (node.left.optional) this.token(</span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">this.print(node.left.typeAnnotation);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">this.space();</span><span class="s3">\n  </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">this.space();</span><span class="s3">\n  </span><span class="s1">this.print(node.right);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function AssignmentExpression(</span><span class="s3">\n  </span><span class="s1">this: Printer,</span><span class="s3">\n  </span><span class="s1">node: t.AssignmentExpression | t.BinaryExpression | t.LogicalExpression,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">this.print(node.left);</span><span class="s3">\n\n  </span><span class="s1">this.space();</span><span class="s3">\n  </span><span class="s1">if (node.operator === </span><span class="s3">\&quot;</span><span class="s1">in</span><span class="s3">\&quot; </span><span class="s1">|| node.operator === </span><span class="s3">\&quot;</span><span class="s1">instanceof</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">this.word(node.operator);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">this.token(node.operator);</span><span class="s3">\n    </span><span class="s1">this._endsWithDiv = node.operator === </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">this.space();</span><span class="s3">\n\n  </span><span class="s1">this.print(node.right);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function BindExpression(this: Printer, node: t.BindExpression) {</span><span class="s3">\n  </span><span class="s1">this.print(node.object);</span><span class="s3">\n  </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">::</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">this.print(node.callee);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export {</span><span class="s3">\n  </span><span class="s1">AssignmentExpression as BinaryExpression,</span><span class="s3">\n  </span><span class="s1">AssignmentExpression as LogicalExpression,</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export function MemberExpression(this: Printer, node: t.MemberExpression) {</span><span class="s3">\n  </span><span class="s1">this.print(node.object);</span><span class="s3">\n\n  </span><span class="s1">if (!node.computed &amp;&amp; isMemberExpression(node.property)) {</span><span class="s3">\n    </span><span class="s1">throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">Got a MemberExpression for MemberExpression property</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let computed = node.computed;</span><span class="s3">\n  </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts) maybe use specific literal types</span><span class="s3">\n  </span><span class="s1">if (isLiteral(node.property) &amp;&amp; typeof node.property.value === </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">computed = true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (computed) {</span><span class="s3">\n    </span><span class="s1">const exit = this.enterDelimited();</span><span class="s3">\n    </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">this.print(node.property);</span><span class="s3">\n    </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">exit();</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">this.print(node.property);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function MetaProperty(this: Printer, node: t.MetaProperty) {</span><span class="s3">\n  </span><span class="s1">this.print(node.meta);</span><span class="s3">\n  </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">this.print(node.property);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function PrivateName(this: Printer, node: t.PrivateName) {</span><span class="s3">\n  </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">#</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">this.print(node.id);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function V8IntrinsicIdentifier(</span><span class="s3">\n  </span><span class="s1">this: Printer,</span><span class="s3">\n  </span><span class="s1">node: t.V8IntrinsicIdentifier,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">%</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">this.word(node.name);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function ModuleExpression(this: Printer, node: t.ModuleExpression) {</span><span class="s3">\n  </span><span class="s1">this.word(</span><span class="s3">\&quot;</span><span class="s1">module</span><span class="s3">\&quot;</span><span class="s1">, true);</span><span class="s3">\n  </span><span class="s1">this.space();</span><span class="s3">\n  </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">{</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">this.indent();</span><span class="s3">\n  </span><span class="s1">const { body } = node;</span><span class="s3">\n  </span><span class="s1">if (body.body.length || body.directives.length) {</span><span class="s3">\n    </span><span class="s1">this.newline();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">this.print(body);</span><span class="s3">\n  </span><span class="s1">this.dedent();</span><span class="s3">\n  </span><span class="s1">this.rightBrace(node);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[]}</span></pre>
</body>
</html>