<html>
<head>
<title>fields.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
fields.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_core&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;_traverse&quot;</span><span class="s0">,</span><span class="s1">&quot;_helperReplaceSupers&quot;</span><span class="s0">,</span><span class="s1">&quot;_helperMemberExpressionToFunctions&quot;</span><span class="s0">,</span><span class="s1">&quot;_helperOptimiseCallExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;_helperAnnotateAsPure&quot;</span><span class="s0">,</span><span class="s1">&quot;_helperSkipTransparentExpressionWrappers&quot;</span><span class="s0">,</span><span class="s1">&quot;ts&quot;</span><span class="s0">,</span><span class="s1">&quot;newHelpers&quot;</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">,</span><span class="s1">&quot;availableHelper&quot;</span><span class="s0">,</span><span class="s1">&quot;buildPrivateNamesMap&quot;</span><span class="s0">,</span><span class="s1">&quot;className&quot;</span><span class="s0">,</span><span class="s1">&quot;privateFieldsAsSymbolsOrProperties&quot;</span><span class="s0">,</span><span class="s1">&quot;props&quot;</span><span class="s0">,</span><span class="s1">&quot;privateNamesMap&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;classBrandId&quot;</span><span class="s0">,</span><span class="s1">&quot;prop&quot;</span><span class="s0">,</span><span class="s1">&quot;isPrivate&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;id&quot;</span><span class="s0">,</span><span class="s1">&quot;update&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;isMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;isProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;isStatic&quot;</span><span class="s0">,</span><span class="s1">&quot;static&quot;</span><span class="s0">,</span><span class="s1">&quot;initAdded&quot;</span><span class="s0">,</span><span class="s1">&quot;scope&quot;</span><span class="s0">,</span><span class="s1">&quot;generateUidIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;method&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;isClassPrivateMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;kind&quot;</span><span class="s0">,</span><span class="s1">&quot;body&quot;</span><span class="s0">,</span><span class="s1">&quot;$&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;t&quot;</span><span class="s0">,</span><span class="s1">&quot;isReturnStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;isCallExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;argument&quot;</span><span class="s0">,</span><span class="s1">&quot;arguments&quot;</span><span class="s0">,</span><span class="s1">&quot;isThisExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;callee&quot;</span><span class="s0">,</span><span class="s1">&quot;getId&quot;</span><span class="s0">,</span><span class="s1">&quot;cloneNode&quot;</span><span class="s0">,</span><span class="s1">&quot;getterDeclared&quot;</span><span class="s0">,</span><span class="s1">&quot;params&quot;</span><span class="s0">,</span><span class="s1">&quot;isExpressionStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;expression&quot;</span><span class="s0">,</span><span class="s1">&quot;setId&quot;</span><span class="s0">,</span><span class="s1">&quot;setterDeclared&quot;</span><span class="s0">,</span><span class="s1">&quot;methodId&quot;</span><span class="s0">,</span><span class="s1">&quot;buildPrivateNamesNodes&quot;</span><span class="s0">,</span><span class="s1">&quot;privateFieldsAsProperties&quot;</span><span class="s0">,</span><span class="s1">&quot;privateFieldsAsSymbols&quot;</span><span class="s0">,</span><span class="s1">&quot;state&quot;</span><span class="s0">,</span><span class="s1">&quot;initNodes&quot;</span><span class="s0">,</span><span class="s1">&quot;injectedIds&quot;</span><span class="s0">,</span><span class="s1">&quot;Set&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;isGetterOrSetter&quot;</span><span class="s0">,</span><span class="s1">&quot;init&quot;</span><span class="s0">,</span><span class="s1">&quot;callExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;addHelper&quot;</span><span class="s0">,</span><span class="s1">&quot;stringLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;identifier&quot;</span><span class="s0">,</span><span class="s1">&quot;has&quot;</span><span class="s0">,</span><span class="s1">&quot;add&quot;</span><span class="s0">,</span><span class="s1">&quot;newExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;annotateAsPure&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;template&quot;</span><span class="s0">,</span><span class="s1">&quot;statement&quot;</span><span class="s0">,</span><span class="s1">&quot;ast&quot;</span><span class="s0">,</span><span class="s1">&quot;privateNameVisitorFactory&quot;</span><span class="s0">,</span><span class="s1">&quot;visitor&quot;</span><span class="s0">,</span><span class="s1">&quot;nestedVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;visitors&quot;</span><span class="s0">,</span><span class="s1">&quot;environmentVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;assign&quot;</span><span class="s0">,</span><span class="s1">&quot;privateNameVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;Class&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;visiblePrivateNames&quot;</span><span class="s0">,</span><span class="s1">&quot;redeclared&quot;</span><span class="s0">,</span><span class="s1">&quot;delete&quot;</span><span class="s0">,</span><span class="s1">&quot;traverse&quot;</span><span class="s0">,</span><span class="s1">&quot;skipKey&quot;</span><span class="s0">,</span><span class="s1">&quot;PrivateName&quot;</span><span class="s0">,</span><span class="s1">&quot;noDocumentAll&quot;</span><span class="s0">,</span><span class="s1">&quot;parentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;isMemberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;property&quot;</span><span class="s0">,</span><span class="s1">&quot;isOptionalMemberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;includes&quot;</span><span class="s0">,</span><span class="s1">&quot;handle&quot;</span><span class="s0">,</span><span class="s1">&quot;unshadow&quot;</span><span class="s0">,</span><span class="s1">&quot;innerBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;_scope&quot;</span><span class="s0">,</span><span class="s1">&quot;hasBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;bindingIdentifierEquals&quot;</span><span class="s0">,</span><span class="s1">&quot;rename&quot;</span><span class="s0">,</span><span class="s1">&quot;parent&quot;</span><span class="s0">,</span><span class="s1">&quot;buildCheckInRHS&quot;</span><span class="s0">,</span><span class="s1">&quot;rhs&quot;</span><span class="s0">,</span><span class="s1">&quot;inRHSIsObject&quot;</span><span class="s0">,</span><span class="s1">&quot;privateInVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;BinaryExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;operator&quot;</span><span class="s0">,</span><span class="s1">&quot;left&quot;</span><span class="s0">,</span><span class="s1">&quot;right&quot;</span><span class="s0">,</span><span class="s1">&quot;isPrivateName&quot;</span><span class="s0">,</span><span class="s1">&quot;classRef&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceWith&quot;</span><span class="s0">,</span><span class="s1">&quot;readOnlyError&quot;</span><span class="s0">,</span><span class="s1">&quot;writeOnlyError&quot;</span><span class="s0">,</span><span class="s1">&quot;console&quot;</span><span class="s0">,</span><span class="s1">&quot;warn&quot;</span><span class="s0">,</span><span class="s1">&quot;buildUndefinedNode&quot;</span><span class="s0">,</span><span class="s1">&quot;buildStaticPrivateFieldAccess&quot;</span><span class="s0">,</span><span class="s1">&quot;expr&quot;</span><span class="s0">,</span><span class="s1">&quot;noUninitializedPrivateFieldAccess&quot;</span><span class="s0">,</span><span class="s1">&quot;memberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;autoInherits&quot;</span><span class="s0">,</span><span class="s1">&quot;fn&quot;</span><span class="s0">,</span><span class="s1">&quot;member&quot;</span><span class="s0">,</span><span class="s1">&quot;inherits&quot;</span><span class="s0">,</span><span class="s1">&quot;apply&quot;</span><span class="s0">,</span><span class="s1">&quot;privateNameHandlerSpec&quot;</span><span class="s0">,</span><span class="s1">&quot;memoise&quot;</span><span class="s0">,</span><span class="s1">&quot;count&quot;</span><span class="s0">,</span><span class="s1">&quot;object&quot;</span><span class="s0">,</span><span class="s1">&quot;memo&quot;</span><span class="s0">,</span><span class="s1">&quot;maybeGenerateMemoised&quot;</span><span class="s0">,</span><span class="s1">&quot;memoiser&quot;</span><span class="s0">,</span><span class="s1">&quot;receiver&quot;</span><span class="s0">,</span><span class="s1">&quot;privateName&quot;</span><span class="s0">,</span><span class="s1">&quot;cloneId&quot;</span><span class="s0">,</span><span class="s1">&quot;helperName&quot;</span><span class="s0">,</span><span class="s1">&quot;skipCheck&quot;</span><span class="s0">,</span><span class="s1">&quot;err&quot;</span><span class="s0">,</span><span class="s1">&quot;sequenceExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;boundGet&quot;</span><span class="s0">,</span><span class="s1">&quot;assignmentExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;destructureSet&quot;</span><span class="s0">,</span><span class="s1">&quot;helper&quot;</span><span class="s0">,</span><span class="s1">&quot;_unused&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;getCall&quot;</span><span class="s0">,</span><span class="s1">&quot;ref&quot;</span><span class="s0">,</span><span class="s1">&quot;pop&quot;</span><span class="s0">,</span><span class="s1">&quot;setCall&quot;</span><span class="s0">,</span><span class="s1">&quot;buildCodeFrameError&quot;</span><span class="s0">,</span><span class="s1">&quot;args&quot;</span><span class="s0">,</span><span class="s1">&quot;computed&quot;</span><span class="s0">,</span><span class="s1">&quot;arrayExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;call&quot;</span><span class="s0">,</span><span class="s1">&quot;optimiseCall&quot;</span><span class="s0">,</span><span class="s1">&quot;optionalCall&quot;</span><span class="s0">,</span><span class="s1">&quot;privateNameHandlerLoose&quot;</span><span class="s0">,</span><span class="s1">&quot;BASE&quot;</span><span class="s0">,</span><span class="s1">&quot;REF&quot;</span><span class="s0">,</span><span class="s1">&quot;PROP&quot;</span><span class="s0">,</span><span class="s1">&quot;simpleSet&quot;</span><span class="s0">,</span><span class="s1">&quot;optionalCallExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;transformPrivateNamesUsage&quot;</span><span class="s0">,</span><span class="s1">&quot;size&quot;</span><span class="s0">,</span><span class="s1">&quot;handler&quot;</span><span class="s0">,</span><span class="s1">&quot;memberExpressionToFunctions&quot;</span><span class="s0">,</span><span class="s1">&quot;buildPrivateFieldInitLoose&quot;</span><span class="s0">,</span><span class="s1">&quot;inheritPropComments&quot;</span><span class="s0">,</span><span class="s1">&quot;buildPrivateInstanceFieldInitSpec&quot;</span><span class="s0">,</span><span class="s1">&quot;inheritLoc&quot;</span><span class="s0">,</span><span class="s1">&quot;expressionStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;thisExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;buildPrivateStaticFieldInitSpec&quot;</span><span class="s0">,</span><span class="s1">&quot;variableDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;variableDeclarator&quot;</span><span class="s0">,</span><span class="s1">&quot;buildPrivateStaticFieldInitSpecOld&quot;</span><span class="s0">,</span><span class="s1">&quot;buildPrivateMethodInitLoose&quot;</span><span class="s0">,</span><span class="s1">&quot;buildPrivateInstanceMethodInitSpec&quot;</span><span class="s0">,</span><span class="s1">&quot;buildPrivateAccessorInitialization&quot;</span><span class="s0">,</span><span class="s1">&quot;buildPrivateInstanceMethodInitialization&quot;</span><span class="s0">,</span><span class="s1">&quot;buildPublicFieldInitLoose&quot;</span><span class="s0">,</span><span class="s1">&quot;isLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;buildPublicFieldInitSpec&quot;</span><span class="s0">,</span><span class="s1">&quot;buildPrivateStaticMethodInitLoose&quot;</span><span class="s0">,</span><span class="s1">&quot;buildPrivateMethodDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;generator&quot;</span><span class="s0">,</span><span class="s1">&quot;async&quot;</span><span class="s0">,</span><span class="s1">&quot;isGetter&quot;</span><span class="s0">,</span><span class="s1">&quot;isSetter&quot;</span><span class="s0">,</span><span class="s1">&quot;thisArg&quot;</span><span class="s0">,</span><span class="s1">&quot;thisRef&quot;</span><span class="s0">,</span><span class="s1">&quot;argumentsPath&quot;</span><span class="s0">,</span><span class="s1">&quot;thisContextVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;argumentsId&quot;</span><span class="s0">,</span><span class="s1">&quot;unshift&quot;</span><span class="s0">,</span><span class="s1">&quot;declId&quot;</span><span class="s0">,</span><span class="s1">&quot;functionDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;Identifier&quot;</span><span class="s0">,</span><span class="s1">&quot;UnaryExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;skipTransparentExprWrapperNodes&quot;</span><span class="s0">,</span><span class="s1">&quot;booleanLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;ThisExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;needsClassRef&quot;</span><span class="s0">,</span><span class="s1">&quot;MetaProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;meta&quot;</span><span class="s0">,</span><span class="s1">&quot;innerReferencesVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;ReferencedIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceThisContext&quot;</span><span class="s0">,</span><span class="s1">&quot;innerBindingRef&quot;</span><span class="s0">,</span><span class="s1">&quot;_state$thisRef&quot;</span><span class="s0">,</span><span class="s1">&quot;isNameOrLength&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;inheritLeadingComments&quot;</span><span class="s0">,</span><span class="s1">&quot;inheritInnerComments&quot;</span><span class="s0">,</span><span class="s1">&quot;original&quot;</span><span class="s0">,</span><span class="s1">&quot;start&quot;</span><span class="s0">,</span><span class="s1">&quot;end&quot;</span><span class="s0">,</span><span class="s1">&quot;loc&quot;</span><span class="s0">,</span><span class="s1">&quot;buildFieldsInitNodes&quot;</span><span class="s0">,</span><span class="s1">&quot;superRef&quot;</span><span class="s0">,</span><span class="s1">&quot;setPublicClassFields&quot;</span><span class="s0">,</span><span class="s1">&quot;constantSuper&quot;</span><span class="s0">,</span><span class="s1">&quot;classRefFlags&quot;</span><span class="s0">,</span><span class="s1">&quot;injectSuperRef&quot;</span><span class="s0">,</span><span class="s1">&quot;staticNodes&quot;</span><span class="s0">,</span><span class="s1">&quot;instanceNodes&quot;</span><span class="s0">,</span><span class="s1">&quot;lastInstanceNodeReturnsThis&quot;</span><span class="s0">,</span><span class="s1">&quot;pureStaticNodes&quot;</span><span class="s0">,</span><span class="s1">&quot;classBindingNode&quot;</span><span class="s0">,</span><span class="s1">&quot;getSuperRef&quot;</span><span class="s0">,</span><span class="s1">&quot;generateUidIdentifierBasedOnNode&quot;</span><span class="s0">,</span><span class="s1">&quot;classRefForInnerBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;isClassProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;assertFieldTransformed&quot;</span><span class="s0">,</span><span class="s1">&quot;isStaticBlock&quot;</span><span class="s0">,</span><span class="s1">&quot;isInstance&quot;</span><span class="s0">,</span><span class="s1">&quot;isPublic&quot;</span><span class="s0">,</span><span class="s1">&quot;isField&quot;</span><span class="s0">,</span><span class="s1">&quot;ReplaceSupers&quot;</span><span class="s0">,</span><span class="s1">&quot;methodPath&quot;</span><span class="s0">,</span><span class="s1">&quot;refToPreserve&quot;</span><span class="s0">,</span><span class="s1">&quot;getObjectRef&quot;</span><span class="s0">,</span><span class="s1">&quot;replace&quot;</span><span class="s0">,</span><span class="s1">&quot;replaced&quot;</span><span class="s0">,</span><span class="s1">&quot;blockBody&quot;</span><span class="s0">,</span><span class="s1">&quot;inheritsComments&quot;</span><span class="s0">,</span><span class="s1">&quot;filter&quot;</span><span class="s0">,</span><span class="s1">&quot;Boolean&quot;</span><span class="s0">,</span><span class="s1">&quot;wrapClass&quot;</span><span class="s0">,</span><span class="s1">&quot;leadingComments&quot;</span><span class="s0">,</span><span class="s1">&quot;remove&quot;</span><span class="s0">,</span><span class="s1">&quot;superClass&quot;</span><span class="s0">,</span><span class="s1">&quot;isClassExpression&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../src/fields.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { template, types as t } from </span><span class="s3">\&quot;</span><span class="s1">@babel/core</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { File, NodePath, Visitor, Scope } from </span><span class="s3">\&quot;</span><span class="s1">@babel/core</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { visitors } from </span><span class="s3">\&quot;</span><span class="s1">@babel/traverse</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import ReplaceSupers from </span><span class="s3">\&quot;</span><span class="s1">@babel/helper-replace-supers</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import memberExpressionToFunctions from </span><span class="s3">\&quot;</span><span class="s1">@babel/helper-member-expression-to-functions</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">Handler,</span><span class="s3">\n  </span><span class="s1">HandlerState,</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">@babel/helper-member-expression-to-functions</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import optimiseCall from </span><span class="s3">\&quot;</span><span class="s1">@babel/helper-optimise-call-expression</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import annotateAsPure from </span><span class="s3">\&quot;</span><span class="s1">@babel/helper-annotate-as-pure</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { skipTransparentExprWrapperNodes } from </span><span class="s3">\&quot;</span><span class="s1">@babel/helper-skip-transparent-expression-wrappers</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">import * as ts from </span><span class="s3">\&quot;</span><span class="s1">./typescript.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">interface PrivateNameMetadata {</span><span class="s3">\n  </span><span class="s1">id: t.Identifier;</span><span class="s3">\n  </span><span class="s1">static: boolean;</span><span class="s3">\n  </span><span class="s1">method: boolean;</span><span class="s3">\n  </span><span class="s1">getId?: t.Identifier;</span><span class="s3">\n  </span><span class="s1">setId?: t.Identifier;</span><span class="s3">\n  </span><span class="s1">methodId?: t.Identifier;</span><span class="s3">\n  </span><span class="s1">initAdded?: boolean;</span><span class="s3">\n  </span><span class="s1">getterDeclared?: boolean;</span><span class="s3">\n  </span><span class="s1">setterDeclared?: boolean;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type PrivateNamesMapGeneric&lt;V&gt; = Map&lt;string, V&gt;;</span><span class="s3">\n\n</span><span class="s1">type PrivateNamesMap = PrivateNamesMapGeneric&lt;PrivateNameMetadata&gt;;</span><span class="s3">\n\n</span><span class="s1">if (!process.env.BABEL_8_BREAKING) {</span><span class="s3">\n  </span><span class="s1">// eslint-disable-next-line no-var</span><span class="s3">\n  </span><span class="s1">var newHelpers = (file: File) =&gt; {</span><span class="s3">\n    </span><span class="s1">if (!process.env.IS_PUBLISH) {</span><span class="s3">\n      </span><span class="s1">const { comments } = file.ast;</span><span class="s3">\n      </span><span class="s1">// This is needed for the test in</span><span class="s3">\n      </span><span class="s1">// babel-plugin-transform-class-properties/test/fixtures/regression/old-helpers</span><span class="s3">\n      </span><span class="s1">if (comments?.some(c =&gt; c.value.includes(</span><span class="s3">\&quot;</span><span class="s1">@force-old-private-helpers</span><span class="s3">\&quot;</span><span class="s1">))) {</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return file.availableHelper(</span><span class="s3">\&quot;</span><span class="s1">classPrivateFieldGet2</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function buildPrivateNamesMap(</span><span class="s3">\n  </span><span class="s1">className: string,</span><span class="s3">\n  </span><span class="s1">privateFieldsAsSymbolsOrProperties: boolean,</span><span class="s3">\n  </span><span class="s1">props: PropPath[],</span><span class="s3">\n  </span><span class="s1">file: File,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const privateNamesMap: PrivateNamesMap = new Map();</span><span class="s3">\n  </span><span class="s1">let classBrandId: t.Identifier;</span><span class="s3">\n  </span><span class="s1">for (const prop of props) {</span><span class="s3">\n    </span><span class="s1">if (prop.isPrivate()) {</span><span class="s3">\n      </span><span class="s1">const { name } = prop.node.key.id;</span><span class="s3">\n      </span><span class="s1">let update: PrivateNameMetadata = privateNamesMap.get(name);</span><span class="s3">\n      </span><span class="s1">if (!update) {</span><span class="s3">\n        </span><span class="s1">const isMethod = !prop.isProperty();</span><span class="s3">\n        </span><span class="s1">const isStatic = prop.node.static;</span><span class="s3">\n        </span><span class="s1">let initAdded = false;</span><span class="s3">\n        </span><span class="s1">let id: t.Identifier;</span><span class="s3">\n        </span><span class="s1">if (</span><span class="s3">\n          </span><span class="s1">!privateFieldsAsSymbolsOrProperties &amp;&amp;</span><span class="s3">\n          </span><span class="s1">(process.env.BABEL_8_BREAKING || newHelpers(file)) &amp;&amp;</span><span class="s3">\n          </span><span class="s1">isMethod &amp;&amp;</span><span class="s3">\n          </span><span class="s1">!isStatic</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">initAdded = !!classBrandId;</span><span class="s3">\n          </span><span class="s1">classBrandId ??= prop.scope.generateUidIdentifier(</span><span class="s3">\n            </span><span class="s1">`${className}_brand`,</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">id = classBrandId;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">id = prop.scope.generateUidIdentifier(name);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">update = { id, static: isStatic, method: isMethod, initAdded };</span><span class="s3">\n        </span><span class="s1">privateNamesMap.set(name, update);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (prop.isClassPrivateMethod()) {</span><span class="s3">\n        </span><span class="s1">if (prop.node.kind === </span><span class="s3">\&quot;</span><span class="s1">get</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">const { body } = prop.node.body;</span><span class="s3">\n          </span><span class="s1">let $: t.Node;</span><span class="s3">\n          </span><span class="s1">if (</span><span class="s3">\n            </span><span class="s1">// If we have</span><span class="s3">\n            </span><span class="s1">//   get #foo() { return _some_fn(this); }</span><span class="s3">\n            </span><span class="s1">// we can use _some_fn directly.</span><span class="s3">\n            </span><span class="s1">body.length === 1 &amp;&amp;</span><span class="s3">\n            </span><span class="s1">t.isReturnStatement(($ = body[0])) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">t.isCallExpression(($ = $.argument)) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">$.arguments.length === 1 &amp;&amp;</span><span class="s3">\n            </span><span class="s1">t.isThisExpression($.arguments[0]) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">t.isIdentifier(($ = $.callee))</span><span class="s3">\n          </span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">update.getId = t.cloneNode($);</span><span class="s3">\n            </span><span class="s1">update.getterDeclared = true;</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">update.getId = prop.scope.generateUidIdentifier(`get_${name}`);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} else if (prop.node.kind === </span><span class="s3">\&quot;</span><span class="s1">set</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">const { params } = prop.node;</span><span class="s3">\n          </span><span class="s1">const { body } = prop.node.body;</span><span class="s3">\n          </span><span class="s1">let $: t.Node;</span><span class="s3">\n          </span><span class="s1">if (</span><span class="s3">\n            </span><span class="s1">// If we have</span><span class="s3">\n            </span><span class="s1">//   set #foo(val) { _some_fn(this, val); }</span><span class="s3">\n            </span><span class="s1">// we can use _some_fn directly.</span><span class="s3">\n            </span><span class="s1">body.length === 1 &amp;&amp;</span><span class="s3">\n            </span><span class="s1">t.isExpressionStatement(($ = body[0])) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">t.isCallExpression(($ = $.expression)) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">$.arguments.length === 2 &amp;&amp;</span><span class="s3">\n            </span><span class="s1">t.isThisExpression($.arguments[0]) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">t.isIdentifier($.arguments[1], {</span><span class="s3">\n              </span><span class="s1">name: (params[0] as t.Identifier).name,</span><span class="s3">\n            </span><span class="s1">}) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">t.isIdentifier(($ = $.callee))</span><span class="s3">\n          </span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">update.setId = t.cloneNode($);</span><span class="s3">\n            </span><span class="s1">update.setterDeclared = true;</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">update.setId = prop.scope.generateUidIdentifier(`set_${name}`);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} else if (prop.node.kind === </span><span class="s3">\&quot;</span><span class="s1">method</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">update.methodId = prop.scope.generateUidIdentifier(name);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">privateNamesMap.set(name, update);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return privateNamesMap;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function buildPrivateNamesNodes(</span><span class="s3">\n  </span><span class="s1">privateNamesMap: PrivateNamesMap,</span><span class="s3">\n  </span><span class="s1">privateFieldsAsProperties: boolean,</span><span class="s3">\n  </span><span class="s1">privateFieldsAsSymbols: boolean,</span><span class="s3">\n  </span><span class="s1">state: File,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const initNodes: t.Statement[] = [];</span><span class="s3">\n\n  </span><span class="s1">const injectedIds = new Set&lt;string&gt;();</span><span class="s3">\n\n  </span><span class="s1">for (const [name, value] of privateNamesMap) {</span><span class="s3">\n    </span><span class="s1">// - When the privateFieldsAsProperties assumption is enabled,</span><span class="s3">\n    </span><span class="s1">//   both static and instance fields are transpiled using a</span><span class="s3">\n    </span><span class="s1">//   secret non-enumerable property. Hence, we also need to generate that</span><span class="s3">\n    </span><span class="s1">//   key (using the classPrivateFieldLooseKey helper).</span><span class="s3">\n    </span><span class="s1">// - When the privateFieldsAsSymbols assumption is enabled,</span><span class="s3">\n    </span><span class="s1">//   both static and instance fields are transpiled using a</span><span class="s3">\n    </span><span class="s1">//   unique Symbol to define a non-enumerable property.</span><span class="s3">\n    </span><span class="s1">// - In spec mode, only instance fields need a </span><span class="s3">\&quot;</span><span class="s1">private name</span><span class="s3">\&quot; </span><span class="s1">initializer</span><span class="s3">\n    </span><span class="s1">//   because static fields are directly assigned to a variable in the</span><span class="s3">\n    </span><span class="s1">//   buildPrivateStaticFieldInitSpec function.</span><span class="s3">\n    </span><span class="s1">const { static: isStatic, method: isMethod, getId, setId } = value;</span><span class="s3">\n    </span><span class="s1">const isGetterOrSetter = getId || setId;</span><span class="s3">\n    </span><span class="s1">const id = t.cloneNode(value.id);</span><span class="s3">\n\n    </span><span class="s1">let init: t.Expression;</span><span class="s3">\n\n    </span><span class="s1">if (privateFieldsAsProperties) {</span><span class="s3">\n      </span><span class="s1">init = t.callExpression(state.addHelper(</span><span class="s3">\&quot;</span><span class="s1">classPrivateFieldLooseKey</span><span class="s3">\&quot;</span><span class="s1">), [</span><span class="s3">\n        </span><span class="s1">t.stringLiteral(name),</span><span class="s3">\n      </span><span class="s1">]);</span><span class="s3">\n    </span><span class="s1">} else if (privateFieldsAsSymbols) {</span><span class="s3">\n      </span><span class="s1">init = t.callExpression(t.identifier(</span><span class="s3">\&quot;</span><span class="s1">Symbol</span><span class="s3">\&quot;</span><span class="s1">), [t.stringLiteral(name)]);</span><span class="s3">\n    </span><span class="s1">} else if (!isStatic) {</span><span class="s3">\n      </span><span class="s1">if (injectedIds.has(id.name)) continue;</span><span class="s3">\n      </span><span class="s1">injectedIds.add(id.name);</span><span class="s3">\n\n      </span><span class="s1">init = t.newExpression(</span><span class="s3">\n        </span><span class="s1">t.identifier(</span><span class="s3">\n          </span><span class="s1">isMethod &amp;&amp;</span><span class="s3">\n            </span><span class="s1">(process.env.BABEL_8_BREAKING ||</span><span class="s3">\n              </span><span class="s1">!isGetterOrSetter ||</span><span class="s3">\n              </span><span class="s1">newHelpers(state))</span><span class="s3">\n            </span><span class="s1">? </span><span class="s3">\&quot;</span><span class="s1">WeakSet</span><span class="s3">\&quot;\n            </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">WeakMap</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">[],</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (init) {</span><span class="s3">\n      </span><span class="s1">if (!privateFieldsAsSymbols) {</span><span class="s3">\n        </span><span class="s1">annotateAsPure(init);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">initNodes.push(template.statement.ast`var ${id} = ${init}`);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return initNodes;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface PrivateNameVisitorState&lt;V&gt; {</span><span class="s3">\n  </span><span class="s1">privateNamesMap: PrivateNamesMapGeneric&lt;V&gt;;</span><span class="s3">\n  </span><span class="s1">redeclared?: string[];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Traverses the class scope, handling private name references. If an inner</span><span class="s3">\n</span><span class="s1">// class redeclares the same private name, it will hand off traversal to the</span><span class="s3">\n</span><span class="s1">// restricted visitor (which doesn't traverse the inner class's inner scope).</span><span class="s3">\n</span><span class="s1">export function privateNameVisitorFactory&lt;S, V&gt;(</span><span class="s3">\n  </span><span class="s1">visitor: Visitor&lt;PrivateNameVisitorState&lt;V &amp; PrivateNameMetadata&gt; &amp; S&gt;,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">// Traverses the outer portion of a class, without touching the class's inner</span><span class="s3">\n  </span><span class="s1">// scope, for private names.</span><span class="s3">\n  </span><span class="s1">const nestedVisitor = visitors.environmentVisitor({ ...visitor });</span><span class="s3">\n\n  </span><span class="s1">const privateNameVisitor: Visitor&lt;</span><span class="s3">\n    </span><span class="s1">PrivateNameVisitorState&lt;V &amp; PrivateNameMetadata&gt; &amp; S</span><span class="s3">\n  </span><span class="s1">&gt; = {</span><span class="s3">\n    </span><span class="s1">...visitor,</span><span class="s3">\n\n    </span><span class="s1">Class(path) {</span><span class="s3">\n      </span><span class="s1">const { privateNamesMap } = this;</span><span class="s3">\n      </span><span class="s1">const body = path.get(</span><span class="s3">\&quot;</span><span class="s1">body.body</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n      </span><span class="s1">const visiblePrivateNames = new Map(privateNamesMap);</span><span class="s3">\n      </span><span class="s1">const redeclared = [];</span><span class="s3">\n      </span><span class="s1">for (const prop of body) {</span><span class="s3">\n        </span><span class="s1">if (!prop.isPrivate()) continue;</span><span class="s3">\n        </span><span class="s1">const { name } = prop.node.key.id;</span><span class="s3">\n        </span><span class="s1">visiblePrivateNames.delete(name);</span><span class="s3">\n        </span><span class="s1">redeclared.push(name);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// If the class doesn't redeclare any private fields, we can continue with</span><span class="s3">\n      </span><span class="s1">// our overall traversal.</span><span class="s3">\n      </span><span class="s1">if (!redeclared.length) {</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// This class redeclares some private field. We need to process the outer</span><span class="s3">\n      </span><span class="s1">// environment with access to all the outer privates, then we can process</span><span class="s3">\n      </span><span class="s1">// the inner environment with only the still-visible outer privates.</span><span class="s3">\n      </span><span class="s1">path.get(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">).traverse(nestedVisitor, {</span><span class="s3">\n        </span><span class="s1">...this,</span><span class="s3">\n        </span><span class="s1">redeclared,</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">path.traverse(privateNameVisitor, {</span><span class="s3">\n        </span><span class="s1">...this,</span><span class="s3">\n        </span><span class="s1">privateNamesMap: visiblePrivateNames,</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n\n      </span><span class="s1">// We'll eventually hit this class node again with the overall Class</span><span class="s3">\n      </span><span class="s1">// Features visitor, which'll process the redeclared privates.</span><span class="s3">\n      </span><span class="s1">path.skipKey(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">return privateNameVisitor;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">interface PrivateNameState {</span><span class="s3">\n  </span><span class="s1">privateNamesMap: PrivateNamesMap;</span><span class="s3">\n  </span><span class="s1">classRef: t.Identifier;</span><span class="s3">\n  </span><span class="s1">file: File;</span><span class="s3">\n  </span><span class="s1">noDocumentAll: boolean;</span><span class="s3">\n  </span><span class="s1">noUninitializedPrivateFieldAccess: boolean;</span><span class="s3">\n  </span><span class="s1">innerBinding?: t.Identifier;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const privateNameVisitor = privateNameVisitorFactory&lt;</span><span class="s3">\n  </span><span class="s1">HandlerState&lt;PrivateNameState&gt; &amp; PrivateNameState,</span><span class="s3">\n  </span><span class="s1">PrivateNameMetadata</span><span class="s3">\n</span><span class="s1">&gt;({</span><span class="s3">\n  </span><span class="s1">PrivateName(path, { noDocumentAll }) {</span><span class="s3">\n    </span><span class="s1">const { privateNamesMap, redeclared } = this;</span><span class="s3">\n    </span><span class="s1">const { node, parentPath } = path;</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">!parentPath.isMemberExpression({ property: node }) &amp;&amp;</span><span class="s3">\n      </span><span class="s1">!parentPath.isOptionalMemberExpression({ property: node })</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const { name } = node.id;</span><span class="s3">\n    </span><span class="s1">if (!privateNamesMap.has(name)) return;</span><span class="s3">\n    </span><span class="s1">if (redeclared?.includes(name)) return;</span><span class="s3">\n\n    </span><span class="s1">this.handle(parentPath, noDocumentAll);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">// rename all bindings that shadows innerBinding</span><span class="s3">\n</span><span class="s1">function unshadow(</span><span class="s3">\n  </span><span class="s1">name: string,</span><span class="s3">\n  </span><span class="s1">scope: Scope,</span><span class="s3">\n  </span><span class="s1">innerBinding: t.Identifier | undefined,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">// in some cases, scope.getBinding(name) === undefined</span><span class="s3">\n  </span><span class="s1">// so we check hasBinding to avoid keeping looping</span><span class="s3">\n  </span><span class="s1">// see: https://github.com/babel/babel/pull/13656#discussion_r686030715</span><span class="s3">\n  </span><span class="s1">while (</span><span class="s3">\n    </span><span class="s1">scope?.hasBinding(name) &amp;&amp;</span><span class="s3">\n    </span><span class="s1">!scope.bindingIdentifierEquals(name, innerBinding)</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">scope.rename(name);</span><span class="s3">\n    </span><span class="s1">scope = scope.parent;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function buildCheckInRHS(</span><span class="s3">\n  </span><span class="s1">rhs: t.Expression,</span><span class="s3">\n  </span><span class="s1">file: File,</span><span class="s3">\n  </span><span class="s1">inRHSIsObject?: boolean,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">if (inRHSIsObject || !file.availableHelper?.(</span><span class="s3">\&quot;</span><span class="s1">checkInRHS</span><span class="s3">\&quot;</span><span class="s1">)) return rhs;</span><span class="s3">\n  </span><span class="s1">return t.callExpression(file.addHelper(</span><span class="s3">\&quot;</span><span class="s1">checkInRHS</span><span class="s3">\&quot;</span><span class="s1">), [rhs]);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const privateInVisitor = privateNameVisitorFactory&lt;</span><span class="s3">\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">classRef: t.Identifier;</span><span class="s3">\n    </span><span class="s1">file: File;</span><span class="s3">\n    </span><span class="s1">innerBinding?: t.Identifier;</span><span class="s3">\n    </span><span class="s1">privateFieldsAsProperties: boolean;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">PrivateNameMetadata</span><span class="s3">\n</span><span class="s1">&gt;({</span><span class="s3">\n  </span><span class="s1">BinaryExpression(path, { file }) {</span><span class="s3">\n    </span><span class="s1">const { operator, left, right } = path.node;</span><span class="s3">\n    </span><span class="s1">if (operator !== </span><span class="s3">\&quot;</span><span class="s1">in</span><span class="s3">\&quot;</span><span class="s1">) return;</span><span class="s3">\n    </span><span class="s1">if (!t.isPrivateName(left)) return;</span><span class="s3">\n\n    </span><span class="s1">const { privateFieldsAsProperties, privateNamesMap, redeclared } = this;</span><span class="s3">\n\n    </span><span class="s1">const { name } = left.id;</span><span class="s3">\n\n    </span><span class="s1">if (!privateNamesMap.has(name)) return;</span><span class="s3">\n    </span><span class="s1">if (redeclared?.includes(name)) return;</span><span class="s3">\n\n    </span><span class="s1">// if there are any local variable shadowing classRef, unshadow it</span><span class="s3">\n    </span><span class="s1">// see #12960</span><span class="s3">\n    </span><span class="s1">unshadow(this.classRef.name, path.scope, this.innerBinding);</span><span class="s3">\n\n    </span><span class="s1">if (privateFieldsAsProperties) {</span><span class="s3">\n      </span><span class="s1">const { id } = privateNamesMap.get(name);</span><span class="s3">\n      </span><span class="s1">path.replaceWith(template.expression.ast`</span><span class="s3">\n        </span><span class="s1">Object.prototype.hasOwnProperty.call(${buildCheckInRHS(</span><span class="s3">\n          </span><span class="s1">right,</span><span class="s3">\n          </span><span class="s1">file,</span><span class="s3">\n        </span><span class="s1">)}, ${t.cloneNode(id)})</span><span class="s3">\n      </span><span class="s1">`);</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const { id, static: isStatic } = privateNamesMap.get(name);</span><span class="s3">\n\n    </span><span class="s1">if (isStatic) {</span><span class="s3">\n      </span><span class="s1">path.replaceWith(</span><span class="s3">\n        </span><span class="s1">template.expression.ast`${buildCheckInRHS(</span><span class="s3">\n          </span><span class="s1">right,</span><span class="s3">\n          </span><span class="s1">file,</span><span class="s3">\n        </span><span class="s1">)} === ${t.cloneNode(this.classRef)}`,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">path.replaceWith(</span><span class="s3">\n      </span><span class="s1">template.expression.ast`${t.cloneNode(id)}.has(${buildCheckInRHS(</span><span class="s3">\n        </span><span class="s1">right,</span><span class="s3">\n        </span><span class="s1">file,</span><span class="s3">\n      </span><span class="s1">)})`,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">interface Receiver {</span><span class="s3">\n  </span><span class="s1">receiver(</span><span class="s3">\n    </span><span class="s1">this: HandlerState&lt;PrivateNameState&gt; &amp; PrivateNameState,</span><span class="s3">\n    </span><span class="s1">member: NodePath&lt;t.MemberExpression | t.OptionalMemberExpression&gt;,</span><span class="s3">\n  </span><span class="s1">): t.Expression;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function readOnlyError(file: File, name: string) {</span><span class="s3">\n  </span><span class="s1">return t.callExpression(file.addHelper(</span><span class="s3">\&quot;</span><span class="s1">readOnlyError</span><span class="s3">\&quot;</span><span class="s1">), [</span><span class="s3">\n    </span><span class="s1">t.stringLiteral(`#${name}`),</span><span class="s3">\n  </span><span class="s1">]);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function writeOnlyError(file: File, name: string) {</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">!process.env.BABEL_8_BREAKING &amp;&amp;</span><span class="s3">\n    </span><span class="s1">!file.availableHelper(</span><span class="s3">\&quot;</span><span class="s1">writeOnlyError</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">console.warn(</span><span class="s3">\n      </span><span class="s1">`@babel/helpers is outdated, update it to silence this warning.`,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">return t.buildUndefinedNode();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return t.callExpression(file.addHelper(</span><span class="s3">\&quot;</span><span class="s1">writeOnlyError</span><span class="s3">\&quot;</span><span class="s1">), [</span><span class="s3">\n    </span><span class="s1">t.stringLiteral(`#${name}`),</span><span class="s3">\n  </span><span class="s1">]);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function buildStaticPrivateFieldAccess&lt;N extends t.Expression&gt;(</span><span class="s3">\n  </span><span class="s1">expr: N,</span><span class="s3">\n  </span><span class="s1">noUninitializedPrivateFieldAccess: boolean,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">if (noUninitializedPrivateFieldAccess) return expr;</span><span class="s3">\n  </span><span class="s1">return t.memberExpression(expr, t.identifier(</span><span class="s3">\&quot;</span><span class="s1">_</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function autoInherits&lt;</span><span class="s3">\n  </span><span class="s1">Member extends { node: t.Node },</span><span class="s3">\n  </span><span class="s1">Result extends t.Node,</span><span class="s3">\n  </span><span class="s1">Fn extends (member: Member, ...args: unknown[]) =&gt; Result,</span><span class="s3">\n</span><span class="s1">&gt;(fn: Fn): Fn {</span><span class="s3">\n  </span><span class="s1">return function (this: ThisParameterType&lt;Fn&gt;, member) {</span><span class="s3">\n    </span><span class="s1">return t.inherits(fn.apply(this, arguments as any), member.node);</span><span class="s3">\n  </span><span class="s1">} as Fn;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const privateNameHandlerSpec: Handler&lt;PrivateNameState &amp; Receiver&gt; &amp; Receiver =</span><span class="s3">\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">memoise(member, count) {</span><span class="s3">\n      </span><span class="s1">const { scope } = member;</span><span class="s3">\n      </span><span class="s1">const { object } = member.node as { object: t.Expression };</span><span class="s3">\n\n      </span><span class="s1">const memo = scope.maybeGenerateMemoised(object);</span><span class="s3">\n      </span><span class="s1">if (!memo) {</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">this.memoiser.set(object, memo, count);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">receiver(member) {</span><span class="s3">\n      </span><span class="s1">const { object } = member.node as { object: t.Expression };</span><span class="s3">\n\n      </span><span class="s1">if (this.memoiser.has(object)) {</span><span class="s3">\n        </span><span class="s1">return t.cloneNode(this.memoiser.get(object));</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return t.cloneNode(object);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">get: autoInherits(function (member) {</span><span class="s3">\n      </span><span class="s1">const {</span><span class="s3">\n        </span><span class="s1">classRef,</span><span class="s3">\n        </span><span class="s1">privateNamesMap,</span><span class="s3">\n        </span><span class="s1">file,</span><span class="s3">\n        </span><span class="s1">innerBinding,</span><span class="s3">\n        </span><span class="s1">noUninitializedPrivateFieldAccess,</span><span class="s3">\n      </span><span class="s1">} = this;</span><span class="s3">\n      </span><span class="s1">const privateName = member.node.property as t.PrivateName;</span><span class="s3">\n      </span><span class="s1">const { name } = privateName.id;</span><span class="s3">\n      </span><span class="s1">const {</span><span class="s3">\n        </span><span class="s1">id,</span><span class="s3">\n        </span><span class="s1">static: isStatic,</span><span class="s3">\n        </span><span class="s1">method: isMethod,</span><span class="s3">\n        </span><span class="s1">methodId,</span><span class="s3">\n        </span><span class="s1">getId,</span><span class="s3">\n        </span><span class="s1">setId,</span><span class="s3">\n      </span><span class="s1">} = privateNamesMap.get(name);</span><span class="s3">\n      </span><span class="s1">const isGetterOrSetter = getId || setId;</span><span class="s3">\n\n      </span><span class="s1">const cloneId = (id: t.Identifier) =&gt;</span><span class="s3">\n        </span><span class="s1">t.inherits(t.cloneNode(id), privateName);</span><span class="s3">\n\n      </span><span class="s1">if (isStatic) {</span><span class="s3">\n        </span><span class="s1">// if there are any local variable shadowing classRef, unshadow it</span><span class="s3">\n        </span><span class="s1">// see #12960</span><span class="s3">\n        </span><span class="s1">unshadow(classRef.name, member.scope, innerBinding);</span><span class="s3">\n\n        </span><span class="s1">if (!process.env.BABEL_8_BREAKING &amp;&amp; !newHelpers(file)) {</span><span class="s3">\n          </span><span class="s1">// NOTE: This package has a peerDependency on @babel/core@^7.0.0, but these</span><span class="s3">\n          </span><span class="s1">// helpers have been introduced in @babel/helpers@7.1.0.</span><span class="s3">\n          </span><span class="s1">const helperName =</span><span class="s3">\n            </span><span class="s1">isMethod &amp;&amp; !isGetterOrSetter</span><span class="s3">\n              </span><span class="s1">? </span><span class="s3">\&quot;</span><span class="s1">classStaticPrivateMethodGet</span><span class="s3">\&quot;\n              </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">classStaticPrivateFieldSpecGet</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n          </span><span class="s1">return t.callExpression(file.addHelper(helperName), [</span><span class="s3">\n            </span><span class="s1">this.receiver(member),</span><span class="s3">\n            </span><span class="s1">t.cloneNode(classRef),</span><span class="s3">\n            </span><span class="s1">cloneId(id),</span><span class="s3">\n          </span><span class="s1">]);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">const receiver = this.receiver(member);</span><span class="s3">\n        </span><span class="s1">const skipCheck =</span><span class="s3">\n          </span><span class="s1">t.isIdentifier(receiver) &amp;&amp; receiver.name === classRef.name;</span><span class="s3">\n\n        </span><span class="s1">if (!isMethod) {</span><span class="s3">\n          </span><span class="s1">if (skipCheck) {</span><span class="s3">\n            </span><span class="s1">return buildStaticPrivateFieldAccess(</span><span class="s3">\n              </span><span class="s1">cloneId(id),</span><span class="s3">\n              </span><span class="s1">noUninitializedPrivateFieldAccess,</span><span class="s3">\n            </span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">return buildStaticPrivateFieldAccess(</span><span class="s3">\n            </span><span class="s1">t.callExpression(file.addHelper(</span><span class="s3">\&quot;</span><span class="s1">assertClassBrand</span><span class="s3">\&quot;</span><span class="s1">), [</span><span class="s3">\n              </span><span class="s1">t.cloneNode(classRef),</span><span class="s3">\n              </span><span class="s1">receiver,</span><span class="s3">\n              </span><span class="s1">cloneId(id),</span><span class="s3">\n            </span><span class="s1">]),</span><span class="s3">\n            </span><span class="s1">noUninitializedPrivateFieldAccess,</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (getId) {</span><span class="s3">\n          </span><span class="s1">if (skipCheck) {</span><span class="s3">\n            </span><span class="s1">return t.callExpression(cloneId(getId), [receiver]);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">return t.callExpression(file.addHelper(</span><span class="s3">\&quot;</span><span class="s1">classPrivateGetter</span><span class="s3">\&quot;</span><span class="s1">), [</span><span class="s3">\n            </span><span class="s1">t.cloneNode(classRef),</span><span class="s3">\n            </span><span class="s1">receiver,</span><span class="s3">\n            </span><span class="s1">cloneId(getId),</span><span class="s3">\n          </span><span class="s1">]);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (setId) {</span><span class="s3">\n          </span><span class="s1">const err = t.buildUndefinedNode(); // TODO: writeOnlyError(file, name)</span><span class="s3">\n          </span><span class="s1">if (skipCheck) return err;</span><span class="s3">\n          </span><span class="s1">return t.sequenceExpression([</span><span class="s3">\n            </span><span class="s1">t.callExpression(file.addHelper(</span><span class="s3">\&quot;</span><span class="s1">assertClassBrand</span><span class="s3">\&quot;</span><span class="s1">), [</span><span class="s3">\n              </span><span class="s1">t.cloneNode(classRef),</span><span class="s3">\n              </span><span class="s1">receiver,</span><span class="s3">\n            </span><span class="s1">]),</span><span class="s3">\n            </span><span class="s1">err,</span><span class="s3">\n          </span><span class="s1">]);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (skipCheck) return cloneId(id);</span><span class="s3">\n        </span><span class="s1">return t.callExpression(file.addHelper(</span><span class="s3">\&quot;</span><span class="s1">assertClassBrand</span><span class="s3">\&quot;</span><span class="s1">), [</span><span class="s3">\n          </span><span class="s1">t.cloneNode(classRef),</span><span class="s3">\n          </span><span class="s1">receiver,</span><span class="s3">\n          </span><span class="s1">cloneId(id),</span><span class="s3">\n        </span><span class="s1">]);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (isMethod) {</span><span class="s3">\n        </span><span class="s1">if (isGetterOrSetter) {</span><span class="s3">\n          </span><span class="s1">if (!getId) {</span><span class="s3">\n            </span><span class="s1">return t.sequenceExpression([</span><span class="s3">\n              </span><span class="s1">this.receiver(member),</span><span class="s3">\n              </span><span class="s1">writeOnlyError(file, name),</span><span class="s3">\n            </span><span class="s1">]);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">if (!process.env.BABEL_8_BREAKING &amp;&amp; !newHelpers(file)) {</span><span class="s3">\n            </span><span class="s1">return t.callExpression(file.addHelper(</span><span class="s3">\&quot;</span><span class="s1">classPrivateFieldGet</span><span class="s3">\&quot;</span><span class="s1">), [</span><span class="s3">\n              </span><span class="s1">this.receiver(member),</span><span class="s3">\n              </span><span class="s1">cloneId(id),</span><span class="s3">\n            </span><span class="s1">]);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">return t.callExpression(file.addHelper(</span><span class="s3">\&quot;</span><span class="s1">classPrivateGetter</span><span class="s3">\&quot;</span><span class="s1">), [</span><span class="s3">\n            </span><span class="s1">t.cloneNode(id),</span><span class="s3">\n            </span><span class="s1">this.receiver(member),</span><span class="s3">\n            </span><span class="s1">cloneId(getId),</span><span class="s3">\n          </span><span class="s1">]);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (!process.env.BABEL_8_BREAKING &amp;&amp; !newHelpers(file)) {</span><span class="s3">\n          </span><span class="s1">return t.callExpression(file.addHelper(</span><span class="s3">\&quot;</span><span class="s1">classPrivateMethodGet</span><span class="s3">\&quot;</span><span class="s1">), [</span><span class="s3">\n            </span><span class="s1">this.receiver(member),</span><span class="s3">\n            </span><span class="s1">t.cloneNode(id),</span><span class="s3">\n            </span><span class="s1">cloneId(methodId),</span><span class="s3">\n          </span><span class="s1">]);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return t.callExpression(file.addHelper(</span><span class="s3">\&quot;</span><span class="s1">assertClassBrand</span><span class="s3">\&quot;</span><span class="s1">), [</span><span class="s3">\n          </span><span class="s1">t.cloneNode(id),</span><span class="s3">\n          </span><span class="s1">this.receiver(member),</span><span class="s3">\n          </span><span class="s1">cloneId(methodId),</span><span class="s3">\n        </span><span class="s1">]);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (process.env.BABEL_8_BREAKING || newHelpers(file)) {</span><span class="s3">\n        </span><span class="s1">return t.callExpression(file.addHelper(</span><span class="s3">\&quot;</span><span class="s1">classPrivateFieldGet2</span><span class="s3">\&quot;</span><span class="s1">), [</span><span class="s3">\n          </span><span class="s1">cloneId(id),</span><span class="s3">\n          </span><span class="s1">this.receiver(member),</span><span class="s3">\n        </span><span class="s1">]);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return t.callExpression(file.addHelper(</span><span class="s3">\&quot;</span><span class="s1">classPrivateFieldGet</span><span class="s3">\&quot;</span><span class="s1">), [</span><span class="s3">\n        </span><span class="s1">this.receiver(member),</span><span class="s3">\n        </span><span class="s1">cloneId(id),</span><span class="s3">\n      </span><span class="s1">]);</span><span class="s3">\n    </span><span class="s1">}),</span><span class="s3">\n\n    </span><span class="s1">boundGet(member) {</span><span class="s3">\n      </span><span class="s1">this.memoise(member, 1);</span><span class="s3">\n\n      </span><span class="s1">return t.callExpression(</span><span class="s3">\n        </span><span class="s1">t.memberExpression(this.get(member), t.identifier(</span><span class="s3">\&quot;</span><span class="s1">bind</span><span class="s3">\&quot;</span><span class="s1">)),</span><span class="s3">\n        </span><span class="s1">[this.receiver(member)],</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">set: autoInherits(function (member, value) {</span><span class="s3">\n      </span><span class="s1">const {</span><span class="s3">\n        </span><span class="s1">classRef,</span><span class="s3">\n        </span><span class="s1">privateNamesMap,</span><span class="s3">\n        </span><span class="s1">file,</span><span class="s3">\n        </span><span class="s1">noUninitializedPrivateFieldAccess,</span><span class="s3">\n      </span><span class="s1">} = this;</span><span class="s3">\n      </span><span class="s1">const privateName = member.node.property as t.PrivateName;</span><span class="s3">\n      </span><span class="s1">const { name } = privateName.id;</span><span class="s3">\n      </span><span class="s1">const {</span><span class="s3">\n        </span><span class="s1">id,</span><span class="s3">\n        </span><span class="s1">static: isStatic,</span><span class="s3">\n        </span><span class="s1">method: isMethod,</span><span class="s3">\n        </span><span class="s1">setId,</span><span class="s3">\n        </span><span class="s1">getId,</span><span class="s3">\n      </span><span class="s1">} = privateNamesMap.get(name);</span><span class="s3">\n      </span><span class="s1">const isGetterOrSetter = getId || setId;</span><span class="s3">\n\n      </span><span class="s1">const cloneId = (id: t.Identifier) =&gt;</span><span class="s3">\n        </span><span class="s1">t.inherits(t.cloneNode(id), privateName);</span><span class="s3">\n\n      </span><span class="s1">if (isStatic) {</span><span class="s3">\n        </span><span class="s1">if (!process.env.BABEL_8_BREAKING &amp;&amp; !newHelpers(file)) {</span><span class="s3">\n          </span><span class="s1">const helperName =</span><span class="s3">\n            </span><span class="s1">isMethod &amp;&amp; !isGetterOrSetter</span><span class="s3">\n              </span><span class="s1">? </span><span class="s3">\&quot;</span><span class="s1">classStaticPrivateMethodSet</span><span class="s3">\&quot;\n              </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">classStaticPrivateFieldSpecSet</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n          </span><span class="s1">return t.callExpression(file.addHelper(helperName), [</span><span class="s3">\n            </span><span class="s1">this.receiver(member),</span><span class="s3">\n            </span><span class="s1">t.cloneNode(classRef),</span><span class="s3">\n            </span><span class="s1">cloneId(id),</span><span class="s3">\n            </span><span class="s1">value,</span><span class="s3">\n          </span><span class="s1">]);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">const receiver = this.receiver(member);</span><span class="s3">\n        </span><span class="s1">const skipCheck =</span><span class="s3">\n          </span><span class="s1">t.isIdentifier(receiver) &amp;&amp; receiver.name === classRef.name;</span><span class="s3">\n\n        </span><span class="s1">if (isMethod &amp;&amp; !setId) {</span><span class="s3">\n          </span><span class="s1">const err = readOnlyError(file, name);</span><span class="s3">\n          </span><span class="s1">if (skipCheck) return t.sequenceExpression([value, err]);</span><span class="s3">\n          </span><span class="s1">return t.sequenceExpression([</span><span class="s3">\n            </span><span class="s1">value,</span><span class="s3">\n            </span><span class="s1">t.callExpression(file.addHelper(</span><span class="s3">\&quot;</span><span class="s1">assertClassBrand</span><span class="s3">\&quot;</span><span class="s1">), [</span><span class="s3">\n              </span><span class="s1">t.cloneNode(classRef),</span><span class="s3">\n              </span><span class="s1">receiver,</span><span class="s3">\n            </span><span class="s1">]),</span><span class="s3">\n            </span><span class="s1">readOnlyError(file, name),</span><span class="s3">\n          </span><span class="s1">]);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (setId) {</span><span class="s3">\n          </span><span class="s1">if (skipCheck) {</span><span class="s3">\n            </span><span class="s1">return t.callExpression(t.cloneNode(setId), [receiver, value]);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">return t.callExpression(file.addHelper(</span><span class="s3">\&quot;</span><span class="s1">classPrivateSetter</span><span class="s3">\&quot;</span><span class="s1">), [</span><span class="s3">\n            </span><span class="s1">t.cloneNode(classRef),</span><span class="s3">\n            </span><span class="s1">cloneId(setId),</span><span class="s3">\n            </span><span class="s1">receiver,</span><span class="s3">\n            </span><span class="s1">value,</span><span class="s3">\n          </span><span class="s1">]);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return t.assignmentExpression(</span><span class="s3">\n          \&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n          </span><span class="s1">buildStaticPrivateFieldAccess(</span><span class="s3">\n            </span><span class="s1">cloneId(id),</span><span class="s3">\n            </span><span class="s1">noUninitializedPrivateFieldAccess,</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">skipCheck</span><span class="s3">\n            </span><span class="s1">? value</span><span class="s3">\n            </span><span class="s1">: t.callExpression(file.addHelper(</span><span class="s3">\&quot;</span><span class="s1">assertClassBrand</span><span class="s3">\&quot;</span><span class="s1">), [</span><span class="s3">\n                </span><span class="s1">t.cloneNode(classRef),</span><span class="s3">\n                </span><span class="s1">receiver,</span><span class="s3">\n                </span><span class="s1">value,</span><span class="s3">\n              </span><span class="s1">]),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (isMethod) {</span><span class="s3">\n        </span><span class="s1">if (setId) {</span><span class="s3">\n          </span><span class="s1">if (!process.env.BABEL_8_BREAKING &amp;&amp; !newHelpers(file)) {</span><span class="s3">\n            </span><span class="s1">return t.callExpression(file.addHelper(</span><span class="s3">\&quot;</span><span class="s1">classPrivateFieldSet</span><span class="s3">\&quot;</span><span class="s1">), [</span><span class="s3">\n              </span><span class="s1">this.receiver(member),</span><span class="s3">\n              </span><span class="s1">cloneId(id),</span><span class="s3">\n              </span><span class="s1">value,</span><span class="s3">\n            </span><span class="s1">]);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">return t.callExpression(file.addHelper(</span><span class="s3">\&quot;</span><span class="s1">classPrivateSetter</span><span class="s3">\&quot;</span><span class="s1">), [</span><span class="s3">\n            </span><span class="s1">t.cloneNode(id),</span><span class="s3">\n            </span><span class="s1">cloneId(setId),</span><span class="s3">\n            </span><span class="s1">this.receiver(member),</span><span class="s3">\n            </span><span class="s1">value,</span><span class="s3">\n          </span><span class="s1">]);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return t.sequenceExpression([</span><span class="s3">\n          </span><span class="s1">this.receiver(member),</span><span class="s3">\n          </span><span class="s1">value,</span><span class="s3">\n          </span><span class="s1">readOnlyError(file, name),</span><span class="s3">\n        </span><span class="s1">]);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (process.env.BABEL_8_BREAKING || newHelpers(file)) {</span><span class="s3">\n        </span><span class="s1">return t.callExpression(file.addHelper(</span><span class="s3">\&quot;</span><span class="s1">classPrivateFieldSet2</span><span class="s3">\&quot;</span><span class="s1">), [</span><span class="s3">\n          </span><span class="s1">cloneId(id),</span><span class="s3">\n          </span><span class="s1">this.receiver(member),</span><span class="s3">\n          </span><span class="s1">value,</span><span class="s3">\n        </span><span class="s1">]);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return t.callExpression(file.addHelper(</span><span class="s3">\&quot;</span><span class="s1">classPrivateFieldSet</span><span class="s3">\&quot;</span><span class="s1">), [</span><span class="s3">\n        </span><span class="s1">this.receiver(member),</span><span class="s3">\n        </span><span class="s1">cloneId(id),</span><span class="s3">\n        </span><span class="s1">value,</span><span class="s3">\n      </span><span class="s1">]);</span><span class="s3">\n    </span><span class="s1">}),</span><span class="s3">\n\n    </span><span class="s1">destructureSet(member) {</span><span class="s3">\n      </span><span class="s1">const {</span><span class="s3">\n        </span><span class="s1">classRef,</span><span class="s3">\n        </span><span class="s1">privateNamesMap,</span><span class="s3">\n        </span><span class="s1">file,</span><span class="s3">\n        </span><span class="s1">noUninitializedPrivateFieldAccess,</span><span class="s3">\n      </span><span class="s1">} = this;</span><span class="s3">\n      </span><span class="s1">const privateName = member.node.property as t.PrivateName;</span><span class="s3">\n      </span><span class="s1">const { name } = privateName.id;</span><span class="s3">\n      </span><span class="s1">const {</span><span class="s3">\n        </span><span class="s1">id,</span><span class="s3">\n        </span><span class="s1">static: isStatic,</span><span class="s3">\n        </span><span class="s1">method: isMethod,</span><span class="s3">\n        </span><span class="s1">setId,</span><span class="s3">\n      </span><span class="s1">} = privateNamesMap.get(name);</span><span class="s3">\n\n      </span><span class="s1">const cloneId = (id: t.Identifier) =&gt;</span><span class="s3">\n        </span><span class="s1">t.inherits(t.cloneNode(id), privateName);</span><span class="s3">\n\n      </span><span class="s1">if (!process.env.BABEL_8_BREAKING &amp;&amp; !newHelpers(file)) {</span><span class="s3">\n        </span><span class="s1">if (isStatic) {</span><span class="s3">\n          </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">// classStaticPrivateFieldDestructureSet was introduced in 7.13.10</span><span class="s3">\n            </span><span class="s1">// eslint-disable-next-line no-var</span><span class="s3">\n            </span><span class="s1">var helper = file.addHelper(</span><span class="s3">\n              \&quot;</span><span class="s1">classStaticPrivateFieldDestructureSet</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">} catch {</span><span class="s3">\n            </span><span class="s1">throw new Error(</span><span class="s3">\n              \&quot;</span><span class="s1">Babel can not transpile `[C.#p] = [0]` with @babel/helpers &lt; 7.13.10, </span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                \&quot;</span><span class="s1">please update @babel/helpers to the latest version.</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">return t.memberExpression(</span><span class="s3">\n            </span><span class="s1">t.callExpression(helper, [</span><span class="s3">\n              </span><span class="s1">this.receiver(member),</span><span class="s3">\n              </span><span class="s1">t.cloneNode(classRef),</span><span class="s3">\n              </span><span class="s1">cloneId(id),</span><span class="s3">\n            </span><span class="s1">]),</span><span class="s3">\n            </span><span class="s1">t.identifier(</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">return t.memberExpression(</span><span class="s3">\n          </span><span class="s1">t.callExpression(file.addHelper(</span><span class="s3">\&quot;</span><span class="s1">classPrivateFieldDestructureSet</span><span class="s3">\&quot;</span><span class="s1">), [</span><span class="s3">\n            </span><span class="s1">this.receiver(member),</span><span class="s3">\n            </span><span class="s1">cloneId(id),</span><span class="s3">\n          </span><span class="s1">]),</span><span class="s3">\n          </span><span class="s1">t.identifier(</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (isMethod &amp;&amp; !setId) {</span><span class="s3">\n        </span><span class="s1">return t.memberExpression(</span><span class="s3">\n          </span><span class="s1">t.sequenceExpression([</span><span class="s3">\n            </span><span class="s1">// @ts-ignore(Babel 7 vs Babel 8) member.node.object is not t.Super</span><span class="s3">\n            </span><span class="s1">member.node.object,</span><span class="s3">\n            </span><span class="s1">readOnlyError(file, name),</span><span class="s3">\n          </span><span class="s1">]),</span><span class="s3">\n          </span><span class="s1">t.identifier(</span><span class="s3">\&quot;</span><span class="s1">_</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (isStatic &amp;&amp; !isMethod) {</span><span class="s3">\n        </span><span class="s1">const getCall = this.get(member);</span><span class="s3">\n        </span><span class="s1">if (</span><span class="s3">\n          </span><span class="s1">!noUninitializedPrivateFieldAccess ||</span><span class="s3">\n          </span><span class="s1">!t.isCallExpression(getCall)</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">return getCall;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const ref = getCall.arguments.pop();</span><span class="s3">\n        </span><span class="s1">getCall.arguments.push(template.expression.ast`(_) =&gt; ${ref} = _`);</span><span class="s3">\n        </span><span class="s1">return t.memberExpression(</span><span class="s3">\n          </span><span class="s1">t.callExpression(file.addHelper(</span><span class="s3">\&quot;</span><span class="s1">toSetter</span><span class="s3">\&quot;</span><span class="s1">), [getCall]),</span><span class="s3">\n          </span><span class="s1">t.identifier(</span><span class="s3">\&quot;</span><span class="s1">_</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const setCall = this.set(member, t.identifier(</span><span class="s3">\&quot;</span><span class="s1">_</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">!t.isCallExpression(setCall) ||</span><span class="s3">\n        </span><span class="s1">!t.isIdentifier(setCall.arguments[setCall.arguments.length - 1], {</span><span class="s3">\n          </span><span class="s1">name: </span><span class="s3">\&quot;</span><span class="s1">_</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">throw member.buildCodeFrameError(</span><span class="s3">\n          \&quot;</span><span class="s1">Internal Babel error while compiling this code. This is a Babel bug. </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n            \&quot;</span><span class="s1">Please report it at https://github.com/babel/babel/issues.</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// someHelper(foo, bar, _) -&gt; someHelper, [foo, bar]</span><span class="s3">\n      </span><span class="s1">// aFn.call(foo, bar, _) -&gt; aFn, [bar], foo</span><span class="s3">\n      </span><span class="s1">let args: t.Expression[];</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">t.isMemberExpression(setCall.callee, { computed: false }) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">t.isIdentifier(setCall.callee.property) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">setCall.callee.property.name === </span><span class="s3">\&quot;</span><span class="s1">call</span><span class="s3">\&quot;\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">args = [</span><span class="s3">\n          </span><span class="s1">// @ts-ignore(Babel 7 vs Babel 8) member.node.object is not t.Super</span><span class="s3">\n          </span><span class="s1">setCall.callee.object,</span><span class="s3">\n          </span><span class="s1">t.arrayExpression(</span><span class="s3">\n            </span><span class="s1">// Remove '_'</span><span class="s3">\n            </span><span class="s1">(setCall.arguments as t.Expression[]).slice(1, -1),</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">setCall.arguments[0] as t.Expression,</span><span class="s3">\n        </span><span class="s1">];</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">args = [</span><span class="s3">\n          </span><span class="s1">setCall.callee as t.Expression,</span><span class="s3">\n          </span><span class="s1">t.arrayExpression(</span><span class="s3">\n            </span><span class="s1">// Remove '_'</span><span class="s3">\n            </span><span class="s1">(setCall.arguments as t.Expression[]).slice(0, -1),</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return t.memberExpression(</span><span class="s3">\n        </span><span class="s1">t.callExpression(file.addHelper(</span><span class="s3">\&quot;</span><span class="s1">toSetter</span><span class="s3">\&quot;</span><span class="s1">), args),</span><span class="s3">\n        </span><span class="s1">t.identifier(</span><span class="s3">\&quot;</span><span class="s1">_</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">call(member, args: (t.Expression | t.SpreadElement)[]) {</span><span class="s3">\n      </span><span class="s1">// The first access (the get) should do the memo assignment.</span><span class="s3">\n      </span><span class="s1">this.memoise(member, 1);</span><span class="s3">\n\n      </span><span class="s1">return optimiseCall(this.get(member), this.receiver(member), args, false);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">optionalCall(member, args: (t.Expression | t.SpreadElement)[]) {</span><span class="s3">\n      </span><span class="s1">this.memoise(member, 1);</span><span class="s3">\n\n      </span><span class="s1">return optimiseCall(this.get(member), this.receiver(member), args, true);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">delete() {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\n        \&quot;</span><span class="s1">Internal Babel error: deleting private elements is a parsing error.</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">const privateNameHandlerLoose: Handler&lt;PrivateNameState&gt; = {</span><span class="s3">\n  </span><span class="s1">get(member) {</span><span class="s3">\n    </span><span class="s1">const { privateNamesMap, file } = this;</span><span class="s3">\n    </span><span class="s1">const { object } = member.node;</span><span class="s3">\n    </span><span class="s1">const { name } = (member.node.property as t.PrivateName).id;</span><span class="s3">\n\n    </span><span class="s1">return template.expression`BASE(REF, PROP)[PROP]`({</span><span class="s3">\n      </span><span class="s1">BASE: file.addHelper(</span><span class="s3">\&quot;</span><span class="s1">classPrivateFieldLooseBase</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">REF: t.cloneNode(object),</span><span class="s3">\n      </span><span class="s1">PROP: t.cloneNode(privateNamesMap.get(name).id),</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">set() {</span><span class="s3">\n    </span><span class="s1">// noop</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">private name handler with loose = true don't need set()</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">boundGet(member) {</span><span class="s3">\n    </span><span class="s1">return t.callExpression(</span><span class="s3">\n      </span><span class="s1">t.memberExpression(this.get(member), t.identifier(</span><span class="s3">\&quot;</span><span class="s1">bind</span><span class="s3">\&quot;</span><span class="s1">)),</span><span class="s3">\n      </span><span class="s1">// eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion</span><span class="s3">\n      </span><span class="s1">[t.cloneNode(member.node.object as t.Expression)],</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">simpleSet(member) {</span><span class="s3">\n    </span><span class="s1">return this.get(member);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">destructureSet(member) {</span><span class="s3">\n    </span><span class="s1">return this.get(member);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">call(member, args) {</span><span class="s3">\n    </span><span class="s1">return t.callExpression(this.get(member), args);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">optionalCall(member, args) {</span><span class="s3">\n    </span><span class="s1">return t.optionalCallExpression(this.get(member), args, true);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">delete() {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      \&quot;</span><span class="s1">Internal Babel error: deleting private elements is a parsing error.</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export function transformPrivateNamesUsage(</span><span class="s3">\n  </span><span class="s1">ref: t.Identifier,</span><span class="s3">\n  </span><span class="s1">path: NodePath&lt;t.Class&gt;,</span><span class="s3">\n  </span><span class="s1">privateNamesMap: PrivateNamesMap,</span><span class="s3">\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">privateFieldsAsProperties,</span><span class="s3">\n    </span><span class="s1">noUninitializedPrivateFieldAccess,</span><span class="s3">\n    </span><span class="s1">noDocumentAll,</span><span class="s3">\n    </span><span class="s1">innerBinding,</span><span class="s3">\n  </span><span class="s1">}: {</span><span class="s3">\n    </span><span class="s1">privateFieldsAsProperties: boolean;</span><span class="s3">\n    </span><span class="s1">noUninitializedPrivateFieldAccess: boolean;</span><span class="s3">\n    </span><span class="s1">noDocumentAll: boolean;</span><span class="s3">\n    </span><span class="s1">innerBinding: t.Identifier;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">state: File,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">if (!privateNamesMap.size) return;</span><span class="s3">\n\n  </span><span class="s1">const body = path.get(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">const handler = privateFieldsAsProperties</span><span class="s3">\n    </span><span class="s1">? privateNameHandlerLoose</span><span class="s3">\n    </span><span class="s1">: privateNameHandlerSpec;</span><span class="s3">\n\n  </span><span class="s1">memberExpressionToFunctions&lt;PrivateNameState&gt;(body, privateNameVisitor, {</span><span class="s3">\n    </span><span class="s1">privateNamesMap,</span><span class="s3">\n    </span><span class="s1">classRef: ref,</span><span class="s3">\n    </span><span class="s1">file: state,</span><span class="s3">\n    </span><span class="s1">...handler,</span><span class="s3">\n    </span><span class="s1">noDocumentAll,</span><span class="s3">\n    </span><span class="s1">noUninitializedPrivateFieldAccess,</span><span class="s3">\n    </span><span class="s1">innerBinding,</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">body.traverse(privateInVisitor, {</span><span class="s3">\n    </span><span class="s1">privateNamesMap,</span><span class="s3">\n    </span><span class="s1">classRef: ref,</span><span class="s3">\n    </span><span class="s1">file: state,</span><span class="s3">\n    </span><span class="s1">privateFieldsAsProperties,</span><span class="s3">\n    </span><span class="s1">innerBinding,</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function buildPrivateFieldInitLoose(</span><span class="s3">\n  </span><span class="s1">ref: t.Expression,</span><span class="s3">\n  </span><span class="s1">prop: NodePath&lt;t.ClassPrivateProperty&gt;,</span><span class="s3">\n  </span><span class="s1">privateNamesMap: PrivateNamesMap,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const { id } = privateNamesMap.get(prop.node.key.id.name);</span><span class="s3">\n  </span><span class="s1">const value = prop.node.value || prop.scope.buildUndefinedNode();</span><span class="s3">\n\n  </span><span class="s1">return inheritPropComments(</span><span class="s3">\n    </span><span class="s1">template.statement.ast`</span><span class="s3">\n      </span><span class="s1">Object.defineProperty(${ref}, ${t.cloneNode(id)}, {</span><span class="s3">\n        </span><span class="s1">// configurable is false by default</span><span class="s3">\n        </span><span class="s1">// enumerable is false by default</span><span class="s3">\n        </span><span class="s1">writable: true,</span><span class="s3">\n        </span><span class="s1">value: ${value}</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">` as t.ExpressionStatement,</span><span class="s3">\n    </span><span class="s1">prop,</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function buildPrivateInstanceFieldInitSpec(</span><span class="s3">\n  </span><span class="s1">ref: t.Expression,</span><span class="s3">\n  </span><span class="s1">prop: NodePath&lt;t.ClassPrivateProperty&gt;,</span><span class="s3">\n  </span><span class="s1">privateNamesMap: PrivateNamesMap,</span><span class="s3">\n  </span><span class="s1">state: File,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const { id } = privateNamesMap.get(prop.node.key.id.name);</span><span class="s3">\n  </span><span class="s1">const value = prop.node.value || prop.scope.buildUndefinedNode();</span><span class="s3">\n\n  </span><span class="s1">if (!process.env.BABEL_8_BREAKING) {</span><span class="s3">\n    </span><span class="s1">if (!state.availableHelper(</span><span class="s3">\&quot;</span><span class="s1">classPrivateFieldInitSpec</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n      </span><span class="s1">return inheritPropComments(</span><span class="s3">\n        </span><span class="s1">template.statement.ast`${t.cloneNode(id)}.set(${ref}, {</span><span class="s3">\n          </span><span class="s1">// configurable is always false for private elements</span><span class="s3">\n          </span><span class="s1">// enumerable is always false for private elements</span><span class="s3">\n          </span><span class="s1">writable: true,</span><span class="s3">\n          </span><span class="s1">value: ${value},</span><span class="s3">\n        </span><span class="s1">})` as t.ExpressionStatement,</span><span class="s3">\n        </span><span class="s1">prop,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const helper = state.addHelper(</span><span class="s3">\&quot;</span><span class="s1">classPrivateFieldInitSpec</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">return inheritLoc(</span><span class="s3">\n    </span><span class="s1">inheritPropComments(</span><span class="s3">\n      </span><span class="s1">t.expressionStatement(</span><span class="s3">\n        </span><span class="s1">t.callExpression(helper, [</span><span class="s3">\n          </span><span class="s1">t.thisExpression(),</span><span class="s3">\n          </span><span class="s1">inheritLoc(t.cloneNode(id), prop.node.key),</span><span class="s3">\n          </span><span class="s1">process.env.BABEL_8_BREAKING || newHelpers(state)</span><span class="s3">\n            </span><span class="s1">? value</span><span class="s3">\n            </span><span class="s1">: template.expression.ast`{ writable: true, value: ${value} }`,</span><span class="s3">\n        </span><span class="s1">]),</span><span class="s3">\n      </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">prop,</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">prop.node,</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function buildPrivateStaticFieldInitSpec(</span><span class="s3">\n  </span><span class="s1">prop: NodePath&lt;t.ClassPrivateProperty&gt;,</span><span class="s3">\n  </span><span class="s1">privateNamesMap: PrivateNamesMap,</span><span class="s3">\n  </span><span class="s1">noUninitializedPrivateFieldAccess: boolean,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const privateName = privateNamesMap.get(prop.node.key.id.name);</span><span class="s3">\n\n  </span><span class="s1">const value = noUninitializedPrivateFieldAccess</span><span class="s3">\n    </span><span class="s1">? prop.node.value</span><span class="s3">\n    </span><span class="s1">: template.expression.ast`{</span><span class="s3">\n        </span><span class="s1">_: ${prop.node.value || t.buildUndefinedNode()}</span><span class="s3">\n      </span><span class="s1">}`;</span><span class="s3">\n\n  </span><span class="s1">return inheritPropComments(</span><span class="s3">\n    </span><span class="s1">t.variableDeclaration(</span><span class="s3">\&quot;</span><span class="s1">var</span><span class="s3">\&quot;</span><span class="s1">, [</span><span class="s3">\n      </span><span class="s1">t.variableDeclarator(t.cloneNode(privateName.id), value),</span><span class="s3">\n    </span><span class="s1">]),</span><span class="s3">\n    </span><span class="s1">prop,</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">if (!process.env.BABEL_8_BREAKING) {</span><span class="s3">\n  </span><span class="s1">// eslint-disable-next-line no-var</span><span class="s3">\n  </span><span class="s1">var buildPrivateStaticFieldInitSpecOld = function (</span><span class="s3">\n    </span><span class="s1">prop: NodePath&lt;t.ClassPrivateProperty&gt;,</span><span class="s3">\n    </span><span class="s1">privateNamesMap: PrivateNamesMap,</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">const privateName = privateNamesMap.get(prop.node.key.id.name);</span><span class="s3">\n    </span><span class="s1">const { id, getId, setId, initAdded } = privateName;</span><span class="s3">\n    </span><span class="s1">const isGetterOrSetter = getId || setId;</span><span class="s3">\n\n    </span><span class="s1">if (!prop.isProperty() &amp;&amp; (initAdded || !isGetterOrSetter)) return;</span><span class="s3">\n\n    </span><span class="s1">if (isGetterOrSetter) {</span><span class="s3">\n      </span><span class="s1">privateNamesMap.set(prop.node.key.id.name, {</span><span class="s3">\n        </span><span class="s1">...privateName,</span><span class="s3">\n        </span><span class="s1">initAdded: true,</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n\n      </span><span class="s1">return inheritPropComments(</span><span class="s3">\n        </span><span class="s1">template.statement.ast`</span><span class="s3">\n          </span><span class="s1">var ${t.cloneNode(id)} = {</span><span class="s3">\n            </span><span class="s1">// configurable is false by default</span><span class="s3">\n            </span><span class="s1">// enumerable is false by default</span><span class="s3">\n            </span><span class="s1">// writable is false by default</span><span class="s3">\n            </span><span class="s1">get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},</span><span class="s3">\n            </span><span class="s1">set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">`,</span><span class="s3">\n        </span><span class="s1">prop,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const value = prop.node.value || prop.scope.buildUndefinedNode();</span><span class="s3">\n    </span><span class="s1">return inheritPropComments(</span><span class="s3">\n      </span><span class="s1">template.statement.ast`</span><span class="s3">\n        </span><span class="s1">var ${t.cloneNode(id)} = {</span><span class="s3">\n          </span><span class="s1">// configurable is false by default</span><span class="s3">\n          </span><span class="s1">// enumerable is false by default</span><span class="s3">\n          </span><span class="s1">writable: true,</span><span class="s3">\n          </span><span class="s1">value: ${value}</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">`,</span><span class="s3">\n      </span><span class="s1">prop,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function buildPrivateMethodInitLoose(</span><span class="s3">\n  </span><span class="s1">ref: t.Expression,</span><span class="s3">\n  </span><span class="s1">prop: NodePath&lt;t.ClassPrivateMethod&gt;,</span><span class="s3">\n  </span><span class="s1">privateNamesMap: PrivateNamesMap,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const privateName = privateNamesMap.get(prop.node.key.id.name);</span><span class="s3">\n  </span><span class="s1">const { methodId, id, getId, setId, initAdded } = privateName;</span><span class="s3">\n  </span><span class="s1">if (initAdded) return;</span><span class="s3">\n\n  </span><span class="s1">if (methodId) {</span><span class="s3">\n    </span><span class="s1">return inheritPropComments(</span><span class="s3">\n      </span><span class="s1">template.statement.ast`</span><span class="s3">\n        </span><span class="s1">Object.defineProperty(${ref}, ${id}, {</span><span class="s3">\n          </span><span class="s1">// configurable is false by default</span><span class="s3">\n          </span><span class="s1">// enumerable is false by default</span><span class="s3">\n          </span><span class="s1">// writable is false by default</span><span class="s3">\n          </span><span class="s1">value: ${methodId.name}</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">` as t.ExpressionStatement,</span><span class="s3">\n      </span><span class="s1">prop,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const isGetterOrSetter = getId || setId;</span><span class="s3">\n  </span><span class="s1">if (isGetterOrSetter) {</span><span class="s3">\n    </span><span class="s1">privateNamesMap.set(prop.node.key.id.name, {</span><span class="s3">\n      </span><span class="s1">...privateName,</span><span class="s3">\n      </span><span class="s1">initAdded: true,</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n\n    </span><span class="s1">return inheritPropComments(</span><span class="s3">\n      </span><span class="s1">template.statement.ast`</span><span class="s3">\n        </span><span class="s1">Object.defineProperty(${ref}, ${id}, {</span><span class="s3">\n          </span><span class="s1">// configurable is false by default</span><span class="s3">\n          </span><span class="s1">// enumerable is false by default</span><span class="s3">\n          </span><span class="s1">// writable is false by default</span><span class="s3">\n          </span><span class="s1">get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},</span><span class="s3">\n          </span><span class="s1">set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">` as t.ExpressionStatement,</span><span class="s3">\n      </span><span class="s1">prop,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function buildPrivateInstanceMethodInitSpec(</span><span class="s3">\n  </span><span class="s1">ref: t.Expression,</span><span class="s3">\n  </span><span class="s1">prop: NodePath&lt;t.ClassPrivateMethod&gt;,</span><span class="s3">\n  </span><span class="s1">privateNamesMap: PrivateNamesMap,</span><span class="s3">\n  </span><span class="s1">state: File,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const privateName = privateNamesMap.get(prop.node.key.id.name);</span><span class="s3">\n\n  </span><span class="s1">if (privateName.initAdded) return;</span><span class="s3">\n\n  </span><span class="s1">if (!process.env.BABEL_8_BREAKING &amp;&amp; !newHelpers(state)) {</span><span class="s3">\n    </span><span class="s1">const isGetterOrSetter = privateName.getId || privateName.setId;</span><span class="s3">\n    </span><span class="s1">if (isGetterOrSetter) {</span><span class="s3">\n      </span><span class="s1">return buildPrivateAccessorInitialization(</span><span class="s3">\n        </span><span class="s1">ref,</span><span class="s3">\n        </span><span class="s1">prop,</span><span class="s3">\n        </span><span class="s1">privateNamesMap,</span><span class="s3">\n        </span><span class="s1">state,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return buildPrivateInstanceMethodInitialization(</span><span class="s3">\n    </span><span class="s1">ref,</span><span class="s3">\n    </span><span class="s1">prop,</span><span class="s3">\n    </span><span class="s1">privateNamesMap,</span><span class="s3">\n    </span><span class="s1">state,</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function buildPrivateAccessorInitialization(</span><span class="s3">\n  </span><span class="s1">ref: t.Expression,</span><span class="s3">\n  </span><span class="s1">prop: NodePath&lt;t.ClassPrivateMethod&gt;,</span><span class="s3">\n  </span><span class="s1">privateNamesMap: PrivateNamesMap,</span><span class="s3">\n  </span><span class="s1">state: File,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const privateName = privateNamesMap.get(prop.node.key.id.name);</span><span class="s3">\n  </span><span class="s1">const { id, getId, setId } = privateName;</span><span class="s3">\n\n  </span><span class="s1">privateNamesMap.set(prop.node.key.id.name, {</span><span class="s3">\n    </span><span class="s1">...privateName,</span><span class="s3">\n    </span><span class="s1">initAdded: true,</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">if (!process.env.BABEL_8_BREAKING) {</span><span class="s3">\n    </span><span class="s1">if (!state.availableHelper(</span><span class="s3">\&quot;</span><span class="s1">classPrivateFieldInitSpec</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n      </span><span class="s1">return inheritPropComments(</span><span class="s3">\n        </span><span class="s1">template.statement.ast`</span><span class="s3">\n          </span><span class="s1">${id}.set(${ref}, {</span><span class="s3">\n            </span><span class="s1">get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},</span><span class="s3">\n            </span><span class="s1">set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">` as t.ExpressionStatement,</span><span class="s3">\n        </span><span class="s1">prop,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const helper = state.addHelper(</span><span class="s3">\&quot;</span><span class="s1">classPrivateFieldInitSpec</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">return inheritLoc(</span><span class="s3">\n    </span><span class="s1">inheritPropComments(</span><span class="s3">\n      </span><span class="s1">template.statement.ast`${helper}(</span><span class="s3">\n      </span><span class="s1">${t.thisExpression()},</span><span class="s3">\n      </span><span class="s1">${t.cloneNode(id)},</span><span class="s3">\n      </span><span class="s1">{</span><span class="s3">\n        </span><span class="s1">get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},</span><span class="s3">\n        </span><span class="s1">set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">)` as t.ExpressionStatement,</span><span class="s3">\n      </span><span class="s1">prop,</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">prop.node,</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function buildPrivateInstanceMethodInitialization(</span><span class="s3">\n  </span><span class="s1">ref: t.Expression,</span><span class="s3">\n  </span><span class="s1">prop: NodePath&lt;t.ClassPrivateMethod&gt;,</span><span class="s3">\n  </span><span class="s1">privateNamesMap: PrivateNamesMap,</span><span class="s3">\n  </span><span class="s1">state: File,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const privateName = privateNamesMap.get(prop.node.key.id.name);</span><span class="s3">\n  </span><span class="s1">const { id } = privateName;</span><span class="s3">\n\n  </span><span class="s1">if (!process.env.BABEL_8_BREAKING) {</span><span class="s3">\n    </span><span class="s1">if (!state.availableHelper(</span><span class="s3">\&quot;</span><span class="s1">classPrivateMethodInitSpec</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n      </span><span class="s1">return inheritPropComments(</span><span class="s3">\n        </span><span class="s1">template.statement.ast`${id}.add(${ref})` as t.ExpressionStatement,</span><span class="s3">\n        </span><span class="s1">prop,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const helper = state.addHelper(</span><span class="s3">\&quot;</span><span class="s1">classPrivateMethodInitSpec</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">return inheritPropComments(</span><span class="s3">\n    </span><span class="s1">template.statement.ast`${helper}(</span><span class="s3">\n      </span><span class="s1">${t.thisExpression()},</span><span class="s3">\n      </span><span class="s1">${t.cloneNode(id)}</span><span class="s3">\n    </span><span class="s1">)` as t.ExpressionStatement,</span><span class="s3">\n    </span><span class="s1">prop,</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function buildPublicFieldInitLoose(</span><span class="s3">\n  </span><span class="s1">ref: t.Expression,</span><span class="s3">\n  </span><span class="s1">prop: NodePath&lt;t.ClassProperty&gt;,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const { key, computed } = prop.node;</span><span class="s3">\n  </span><span class="s1">const value = prop.node.value || prop.scope.buildUndefinedNode();</span><span class="s3">\n\n  </span><span class="s1">return inheritPropComments(</span><span class="s3">\n    </span><span class="s1">t.expressionStatement(</span><span class="s3">\n      </span><span class="s1">t.assignmentExpression(</span><span class="s3">\n        \&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">t.memberExpression(ref, key, computed || t.isLiteral(key)),</span><span class="s3">\n        </span><span class="s1">value,</span><span class="s3">\n      </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">prop,</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function buildPublicFieldInitSpec(</span><span class="s3">\n  </span><span class="s1">ref: t.Expression,</span><span class="s3">\n  </span><span class="s1">prop: NodePath&lt;t.ClassProperty&gt;,</span><span class="s3">\n  </span><span class="s1">state: File,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const { key, computed } = prop.node;</span><span class="s3">\n  </span><span class="s1">const value = prop.node.value || prop.scope.buildUndefinedNode();</span><span class="s3">\n\n  </span><span class="s1">return inheritPropComments(</span><span class="s3">\n    </span><span class="s1">t.expressionStatement(</span><span class="s3">\n      </span><span class="s1">t.callExpression(state.addHelper(</span><span class="s3">\&quot;</span><span class="s1">defineProperty</span><span class="s3">\&quot;</span><span class="s1">), [</span><span class="s3">\n        </span><span class="s1">ref,</span><span class="s3">\n        </span><span class="s1">computed || t.isLiteral(key)</span><span class="s3">\n          </span><span class="s1">? key</span><span class="s3">\n          </span><span class="s1">: t.stringLiteral((key as t.Identifier).name),</span><span class="s3">\n        </span><span class="s1">value,</span><span class="s3">\n      </span><span class="s1">]),</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">prop,</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function buildPrivateStaticMethodInitLoose(</span><span class="s3">\n  </span><span class="s1">ref: t.Expression,</span><span class="s3">\n  </span><span class="s1">prop: NodePath&lt;t.ClassPrivateMethod&gt;,</span><span class="s3">\n  </span><span class="s1">state: File,</span><span class="s3">\n  </span><span class="s1">privateNamesMap: PrivateNamesMap,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const privateName = privateNamesMap.get(prop.node.key.id.name);</span><span class="s3">\n  </span><span class="s1">const { id, methodId, getId, setId, initAdded } = privateName;</span><span class="s3">\n\n  </span><span class="s1">if (initAdded) return;</span><span class="s3">\n\n  </span><span class="s1">const isGetterOrSetter = getId || setId;</span><span class="s3">\n  </span><span class="s1">if (isGetterOrSetter) {</span><span class="s3">\n    </span><span class="s1">privateNamesMap.set(prop.node.key.id.name, {</span><span class="s3">\n      </span><span class="s1">...privateName,</span><span class="s3">\n      </span><span class="s1">initAdded: true,</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n\n    </span><span class="s1">return inheritPropComments(</span><span class="s3">\n      </span><span class="s1">template.statement.ast`</span><span class="s3">\n        </span><span class="s1">Object.defineProperty(${ref}, ${id}, {</span><span class="s3">\n          </span><span class="s1">// configurable is false by default</span><span class="s3">\n          </span><span class="s1">// enumerable is false by default</span><span class="s3">\n          </span><span class="s1">// writable is false by default</span><span class="s3">\n          </span><span class="s1">get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},</span><span class="s3">\n          </span><span class="s1">set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">`,</span><span class="s3">\n      </span><span class="s1">prop,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return inheritPropComments(</span><span class="s3">\n    </span><span class="s1">template.statement.ast`</span><span class="s3">\n      </span><span class="s1">Object.defineProperty(${ref}, ${id}, {</span><span class="s3">\n        </span><span class="s1">// configurable is false by default</span><span class="s3">\n        </span><span class="s1">// enumerable is false by default</span><span class="s3">\n        </span><span class="s1">// writable is false by default</span><span class="s3">\n        </span><span class="s1">value: ${methodId.name}</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">`,</span><span class="s3">\n    </span><span class="s1">prop,</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function buildPrivateMethodDeclaration(</span><span class="s3">\n  </span><span class="s1">file: File,</span><span class="s3">\n  </span><span class="s1">prop: NodePath&lt;t.ClassPrivateMethod&gt;,</span><span class="s3">\n  </span><span class="s1">privateNamesMap: PrivateNamesMap,</span><span class="s3">\n  </span><span class="s1">privateFieldsAsSymbolsOrProperties = false,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const privateName = privateNamesMap.get(prop.node.key.id.name);</span><span class="s3">\n  </span><span class="s1">const {</span><span class="s3">\n    </span><span class="s1">id,</span><span class="s3">\n    </span><span class="s1">methodId,</span><span class="s3">\n    </span><span class="s1">getId,</span><span class="s3">\n    </span><span class="s1">setId,</span><span class="s3">\n    </span><span class="s1">getterDeclared,</span><span class="s3">\n    </span><span class="s1">setterDeclared,</span><span class="s3">\n    </span><span class="s1">static: isStatic,</span><span class="s3">\n  </span><span class="s1">} = privateName;</span><span class="s3">\n  </span><span class="s1">const { params, body, generator, async } = prop.node;</span><span class="s3">\n  </span><span class="s1">const isGetter = getId &amp;&amp; params.length === 0;</span><span class="s3">\n  </span><span class="s1">const isSetter = setId &amp;&amp; params.length &gt; 0;</span><span class="s3">\n\n  </span><span class="s1">if ((isGetter &amp;&amp; getterDeclared) || (isSetter &amp;&amp; setterDeclared)) {</span><span class="s3">\n    </span><span class="s1">privateNamesMap.set(prop.node.key.id.name, {</span><span class="s3">\n      </span><span class="s1">...privateName,</span><span class="s3">\n      </span><span class="s1">initAdded: true,</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return null;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">(process.env.BABEL_8_BREAKING || newHelpers(file)) &amp;&amp;</span><span class="s3">\n    </span><span class="s1">(isGetter || isSetter) &amp;&amp;</span><span class="s3">\n    </span><span class="s1">!privateFieldsAsSymbolsOrProperties</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">const scope = prop.get(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">).scope;</span><span class="s3">\n    </span><span class="s1">const thisArg = scope.generateUidIdentifier(</span><span class="s3">\&quot;</span><span class="s1">this</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">const state: ReplaceThisState = {</span><span class="s3">\n      </span><span class="s1">thisRef: thisArg,</span><span class="s3">\n      </span><span class="s1">argumentsPath: [],</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">// eslint-disable-next-line @typescript-eslint/no-use-before-define</span><span class="s3">\n    </span><span class="s1">prop.traverse(thisContextVisitor, state);</span><span class="s3">\n    </span><span class="s1">if (state.argumentsPath.length) {</span><span class="s3">\n      </span><span class="s1">const argumentsId = scope.generateUidIdentifier(</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">scope.push({</span><span class="s3">\n        </span><span class="s1">id: argumentsId,</span><span class="s3">\n        </span><span class="s1">init: template.expression.ast`[].slice.call(arguments, 1)`,</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">for (const path of state.argumentsPath) {</span><span class="s3">\n        </span><span class="s1">path.replaceWith(t.cloneNode(argumentsId));</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">params.unshift(t.cloneNode(thisArg));</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let declId = methodId;</span><span class="s3">\n\n  </span><span class="s1">if (isGetter) {</span><span class="s3">\n    </span><span class="s1">privateNamesMap.set(prop.node.key.id.name, {</span><span class="s3">\n      </span><span class="s1">...privateName,</span><span class="s3">\n      </span><span class="s1">getterDeclared: true,</span><span class="s3">\n      </span><span class="s1">initAdded: true,</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">declId = getId;</span><span class="s3">\n  </span><span class="s1">} else if (isSetter) {</span><span class="s3">\n    </span><span class="s1">privateNamesMap.set(prop.node.key.id.name, {</span><span class="s3">\n      </span><span class="s1">...privateName,</span><span class="s3">\n      </span><span class="s1">setterDeclared: true,</span><span class="s3">\n      </span><span class="s1">initAdded: true,</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">declId = setId;</span><span class="s3">\n  </span><span class="s1">} else if (isStatic &amp;&amp; !privateFieldsAsSymbolsOrProperties) {</span><span class="s3">\n    </span><span class="s1">declId = id;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return inheritPropComments(</span><span class="s3">\n    </span><span class="s1">t.functionDeclaration(</span><span class="s3">\n      </span><span class="s1">t.cloneNode(declId),</span><span class="s3">\n      </span><span class="s1">// @ts-expect-error params for ClassMethod has TSParameterProperty</span><span class="s3">\n      </span><span class="s1">params,</span><span class="s3">\n      </span><span class="s1">body,</span><span class="s3">\n      </span><span class="s1">generator,</span><span class="s3">\n      </span><span class="s1">async,</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">prop,</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type ReplaceThisState = {</span><span class="s3">\n  </span><span class="s1">thisRef: t.Identifier;</span><span class="s3">\n  </span><span class="s1">needsClassRef?: boolean;</span><span class="s3">\n  </span><span class="s1">innerBinding?: t.Identifier | null;</span><span class="s3">\n  </span><span class="s1">argumentsPath?: NodePath&lt;t.Identifier&gt;[];</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">type ReplaceInnerBindingReferenceState = ReplaceThisState;</span><span class="s3">\n\n</span><span class="s1">const thisContextVisitor = visitors.environmentVisitor&lt;ReplaceThisState&gt;({</span><span class="s3">\n  </span><span class="s1">Identifier(path, state) {</span><span class="s3">\n    </span><span class="s1">if (state.argumentsPath &amp;&amp; path.node.name === </span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">state.argumentsPath.push(path);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">UnaryExpression(path) {</span><span class="s3">\n    </span><span class="s1">// Replace `delete this` with `true`</span><span class="s3">\n    </span><span class="s1">const { node } = path;</span><span class="s3">\n    </span><span class="s1">if (node.operator === </span><span class="s3">\&quot;</span><span class="s1">delete</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">const argument = skipTransparentExprWrapperNodes(node.argument);</span><span class="s3">\n      </span><span class="s1">if (t.isThisExpression(argument)) {</span><span class="s3">\n        </span><span class="s1">path.replaceWith(t.booleanLiteral(true));</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">ThisExpression(path, state) {</span><span class="s3">\n    </span><span class="s1">state.needsClassRef = true;</span><span class="s3">\n    </span><span class="s1">path.replaceWith(t.cloneNode(state.thisRef));</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">MetaProperty(path) {</span><span class="s3">\n    </span><span class="s1">const { node, scope } = path;</span><span class="s3">\n    </span><span class="s1">// if there are `new.target` in static field</span><span class="s3">\n    </span><span class="s1">// we should replace it with `undefined`</span><span class="s3">\n    </span><span class="s1">if (node.meta.name === </span><span class="s3">\&quot;</span><span class="s1">new</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; node.property.name === </span><span class="s3">\&quot;</span><span class="s1">target</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">path.replaceWith(scope.buildUndefinedNode());</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">const innerReferencesVisitor: Visitor&lt;ReplaceInnerBindingReferenceState&gt; = {</span><span class="s3">\n  </span><span class="s1">ReferencedIdentifier(path, state) {</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">path.scope.bindingIdentifierEquals(path.node.name, state.innerBinding)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">state.needsClassRef = true;</span><span class="s3">\n      </span><span class="s1">path.node.name = state.thisRef.name;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">function replaceThisContext(</span><span class="s3">\n  </span><span class="s1">path: PropPath,</span><span class="s3">\n  </span><span class="s1">ref: t.Identifier,</span><span class="s3">\n  </span><span class="s1">innerBindingRef: t.Identifier | null,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const state: ReplaceThisState = {</span><span class="s3">\n    </span><span class="s1">thisRef: ref,</span><span class="s3">\n    </span><span class="s1">needsClassRef: false,</span><span class="s3">\n    </span><span class="s1">innerBinding: innerBindingRef,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">if (!path.isMethod()) {</span><span class="s3">\n    </span><span class="s1">// replace `this` in property initializers and static blocks</span><span class="s3">\n    </span><span class="s1">path.traverse(thisContextVisitor, state);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// todo: use innerBinding.referencePaths to avoid full traversal</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">innerBindingRef != null &amp;&amp;</span><span class="s3">\n    </span><span class="s1">state.thisRef?.name &amp;&amp;</span><span class="s3">\n    </span><span class="s1">state.thisRef.name !== innerBindingRef.name</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">path.traverse(innerReferencesVisitor, state);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return state.needsClassRef;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type PropNode =</span><span class="s3">\n  </span><span class="s1">| t.ClassProperty</span><span class="s3">\n  </span><span class="s1">| t.ClassPrivateMethod</span><span class="s3">\n  </span><span class="s1">| t.ClassPrivateProperty</span><span class="s3">\n  </span><span class="s1">| t.StaticBlock;</span><span class="s3">\n</span><span class="s1">export type PropPath = NodePath&lt;PropNode&gt;;</span><span class="s3">\n\n</span><span class="s1">function isNameOrLength({ key, computed }: t.ClassProperty) {</span><span class="s3">\n  </span><span class="s1">if (key.type === </span><span class="s3">\&quot;</span><span class="s1">Identifier</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return !computed &amp;&amp; (key.name === </span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot; </span><span class="s1">|| key.name === </span><span class="s3">\&quot;</span><span class="s1">length</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (key.type === </span><span class="s3">\&quot;</span><span class="s1">StringLiteral</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return key.value === </span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot; </span><span class="s1">|| key.value === </span><span class="s3">\&quot;</span><span class="s1">length</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Inherit comments from class members. This is a reduced version of</span><span class="s3">\n </span><span class="s1">* t.inheritsComments: the trailing comments are not inherited because</span><span class="s3">\n </span><span class="s1">* for most class members except the last one, their trailing comments are</span><span class="s3">\n </span><span class="s1">* the next sibling's leading comments.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @template T transformed class member type</span><span class="s3">\n </span><span class="s1">* @param {T} node transformed class member</span><span class="s3">\n </span><span class="s1">* @param {PropPath} prop class member</span><span class="s3">\n </span><span class="s1">* @returns transformed class member type with comments inherited</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function inheritPropComments&lt;T extends t.Node&gt;(node: T, prop: PropPath) {</span><span class="s3">\n  </span><span class="s1">t.inheritLeadingComments(node, prop.node);</span><span class="s3">\n  </span><span class="s1">t.inheritInnerComments(node, prop.node);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function inheritLoc&lt;T extends t.Node&gt;(node: T, original: t.Node) {</span><span class="s3">\n  </span><span class="s1">node.start = original.start;</span><span class="s3">\n  </span><span class="s1">node.end = original.end;</span><span class="s3">\n  </span><span class="s1">node.loc = original.loc;</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* ClassRefFlag records the requirement of the class binding reference.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @enum {number}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const enum ClassRefFlag {</span><span class="s3">\n  </span><span class="s1">None,</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* When this flag is enabled, the binding reference can be the class id,</span><span class="s3">\n   </span><span class="s1">* if exists, or the uid identifier generated for class expression. The</span><span class="s3">\n   </span><span class="s1">* reference is safe to be consumed by [[Define]].</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">ForDefine = 1 &lt;&lt; 0,</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* When this flag is enabled, the reference must be a uid, because the outer</span><span class="s3">\n   </span><span class="s1">* class binding can be mutated by user codes.</span><span class="s3">\n   </span><span class="s1">* E.g.</span><span class="s3">\n   </span><span class="s1">* class C { static p = C }; const oldC = C; C = null; oldC.p;</span><span class="s3">\n   </span><span class="s1">* we must memoize class `C` before defining the property `p`.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">ForInnerBinding = 1 &lt;&lt; 1,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function buildFieldsInitNodes(</span><span class="s3">\n  </span><span class="s1">ref: t.Identifier | null,</span><span class="s3">\n  </span><span class="s1">superRef: t.Expression | undefined,</span><span class="s3">\n  </span><span class="s1">props: PropPath[],</span><span class="s3">\n  </span><span class="s1">privateNamesMap: PrivateNamesMap,</span><span class="s3">\n  </span><span class="s1">file: File,</span><span class="s3">\n  </span><span class="s1">setPublicClassFields: boolean,</span><span class="s3">\n  </span><span class="s1">privateFieldsAsSymbolsOrProperties: boolean,</span><span class="s3">\n  </span><span class="s1">noUninitializedPrivateFieldAccess: boolean,</span><span class="s3">\n  </span><span class="s1">constantSuper: boolean,</span><span class="s3">\n  </span><span class="s1">innerBindingRef: t.Identifier | null,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">let classRefFlags = ClassRefFlag.None;</span><span class="s3">\n  </span><span class="s1">let injectSuperRef: t.Identifier;</span><span class="s3">\n  </span><span class="s1">const staticNodes: t.Statement[] = [];</span><span class="s3">\n  </span><span class="s1">const instanceNodes: t.ExpressionStatement[] = [];</span><span class="s3">\n  </span><span class="s1">let lastInstanceNodeReturnsThis = false;</span><span class="s3">\n  </span><span class="s1">// These nodes are pure and can be moved to the closest statement position</span><span class="s3">\n  </span><span class="s1">const pureStaticNodes: t.FunctionDeclaration[] = [];</span><span class="s3">\n  </span><span class="s1">let classBindingNode: t.ExpressionStatement | null = null;</span><span class="s3">\n\n  </span><span class="s1">const getSuperRef = t.isIdentifier(superRef)</span><span class="s3">\n    </span><span class="s1">? () =&gt; superRef</span><span class="s3">\n    </span><span class="s1">: () =&gt; {</span><span class="s3">\n        </span><span class="s1">injectSuperRef ??=</span><span class="s3">\n          </span><span class="s1">props[0].scope.generateUidIdentifierBasedOnNode(superRef);</span><span class="s3">\n        </span><span class="s1">return injectSuperRef;</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">const classRefForInnerBinding =</span><span class="s3">\n    </span><span class="s1">ref ??</span><span class="s3">\n    </span><span class="s1">props[0].scope.generateUidIdentifier(innerBindingRef?.name || </span><span class="s3">\&quot;</span><span class="s1">Class</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">ref ??= t.cloneNode(innerBindingRef);</span><span class="s3">\n\n  </span><span class="s1">for (const prop of props) {</span><span class="s3">\n    </span><span class="s1">if (prop.isClassProperty()) {</span><span class="s3">\n      </span><span class="s1">ts.assertFieldTransformed(prop);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// @ts-expect-error: TS doesn't infer that prop.node is not a StaticBlock</span><span class="s3">\n    </span><span class="s1">const isStatic = !t.isStaticBlock?.(prop.node) &amp;&amp; prop.node.static;</span><span class="s3">\n    </span><span class="s1">const isInstance = !isStatic;</span><span class="s3">\n    </span><span class="s1">const isPrivate = prop.isPrivate();</span><span class="s3">\n    </span><span class="s1">const isPublic = !isPrivate;</span><span class="s3">\n    </span><span class="s1">const isField = prop.isProperty();</span><span class="s3">\n    </span><span class="s1">const isMethod = !isField;</span><span class="s3">\n    </span><span class="s1">const isStaticBlock = prop.isStaticBlock?.();</span><span class="s3">\n\n    </span><span class="s1">if (isStatic) classRefFlags |= ClassRefFlag.ForDefine;</span><span class="s3">\n\n    </span><span class="s1">if (isStatic || (isMethod &amp;&amp; isPrivate) || isStaticBlock) {</span><span class="s3">\n      </span><span class="s1">new ReplaceSupers({</span><span class="s3">\n        </span><span class="s1">methodPath: prop,</span><span class="s3">\n        </span><span class="s1">constantSuper,</span><span class="s3">\n        </span><span class="s1">file: file,</span><span class="s3">\n        </span><span class="s1">refToPreserve: innerBindingRef,</span><span class="s3">\n        </span><span class="s1">getSuperRef,</span><span class="s3">\n        </span><span class="s1">getObjectRef() {</span><span class="s3">\n          </span><span class="s1">classRefFlags |= ClassRefFlag.ForInnerBinding;</span><span class="s3">\n          </span><span class="s1">if (isStatic || isStaticBlock) {</span><span class="s3">\n            </span><span class="s1">return classRefForInnerBinding;</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">return t.memberExpression(</span><span class="s3">\n              </span><span class="s1">classRefForInnerBinding,</span><span class="s3">\n              </span><span class="s1">t.identifier(</span><span class="s3">\&quot;</span><span class="s1">prototype</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n            </span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">}).replace();</span><span class="s3">\n\n      </span><span class="s1">const replaced = replaceThisContext(</span><span class="s3">\n        </span><span class="s1">prop,</span><span class="s3">\n        </span><span class="s1">classRefForInnerBinding,</span><span class="s3">\n        </span><span class="s1">innerBindingRef,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">if (replaced) {</span><span class="s3">\n        </span><span class="s1">classRefFlags |= ClassRefFlag.ForInnerBinding;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">lastInstanceNodeReturnsThis = false;</span><span class="s3">\n\n    </span><span class="s1">// TODO(ts): there are so many `ts-expect-error` inside cases since</span><span class="s3">\n    </span><span class="s1">// ts can not infer type from pre-computed values (or a case test)</span><span class="s3">\n    </span><span class="s1">// even change `isStaticBlock` to `t.isStaticBlock(prop)` will not make prop</span><span class="s3">\n    </span><span class="s1">// a `NodePath&lt;t.StaticBlock&gt;`</span><span class="s3">\n    </span><span class="s1">// this maybe a bug for ts</span><span class="s3">\n    </span><span class="s1">switch (true) {</span><span class="s3">\n      </span><span class="s1">case isStaticBlock: {</span><span class="s3">\n        </span><span class="s1">const blockBody = prop.node.body;</span><span class="s3">\n        </span><span class="s1">// We special-case the single expression case to avoid the iife, since</span><span class="s3">\n        </span><span class="s1">// it's common.</span><span class="s3">\n        </span><span class="s1">if (blockBody.length === 1 &amp;&amp; t.isExpressionStatement(blockBody[0])) {</span><span class="s3">\n          </span><span class="s1">staticNodes.push(inheritPropComments(blockBody[0], prop));</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">staticNodes.push(</span><span class="s3">\n            </span><span class="s1">t.inheritsComments(</span><span class="s3">\n              </span><span class="s1">template.statement.ast`(() =&gt; { ${blockBody} })()`,</span><span class="s3">\n              </span><span class="s1">prop.node,</span><span class="s3">\n            </span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case isStatic &amp;&amp;</span><span class="s3">\n        </span><span class="s1">isPrivate &amp;&amp;</span><span class="s3">\n        </span><span class="s1">isField &amp;&amp;</span><span class="s3">\n        </span><span class="s1">privateFieldsAsSymbolsOrProperties:</span><span class="s3">\n        </span><span class="s1">staticNodes.push(</span><span class="s3">\n          </span><span class="s1">buildPrivateFieldInitLoose(t.cloneNode(ref), prop, privateNamesMap),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">case isStatic &amp;&amp;</span><span class="s3">\n        </span><span class="s1">isPrivate &amp;&amp;</span><span class="s3">\n        </span><span class="s1">isField &amp;&amp;</span><span class="s3">\n        </span><span class="s1">!privateFieldsAsSymbolsOrProperties:</span><span class="s3">\n        </span><span class="s1">if (!process.env.BABEL_8_BREAKING &amp;&amp; !newHelpers(file)) {</span><span class="s3">\n          </span><span class="s1">staticNodes.push(</span><span class="s3">\n            </span><span class="s1">buildPrivateStaticFieldInitSpecOld(prop, privateNamesMap),</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">staticNodes.push(</span><span class="s3">\n            </span><span class="s1">buildPrivateStaticFieldInitSpec(</span><span class="s3">\n              </span><span class="s1">prop,</span><span class="s3">\n              </span><span class="s1">privateNamesMap,</span><span class="s3">\n              </span><span class="s1">noUninitializedPrivateFieldAccess,</span><span class="s3">\n            </span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">case isStatic &amp;&amp; isPublic &amp;&amp; isField &amp;&amp; setPublicClassFields:</span><span class="s3">\n        </span><span class="s1">// Functions always have non-writable .name and .length properties,</span><span class="s3">\n        </span><span class="s1">// so we must always use [[Define]] for them.</span><span class="s3">\n        </span><span class="s1">// It might still be possible to a computed static fields whose resulting</span><span class="s3">\n        </span><span class="s1">// key is </span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot; </span><span class="s1">or </span><span class="s3">\&quot;</span><span class="s1">length</span><span class="s3">\&quot;</span><span class="s1">, but the assumption is telling us that it's</span><span class="s3">\n        </span><span class="s1">// not going to happen.</span><span class="s3">\n        </span><span class="s1">if (!isNameOrLength(prop.node)) {</span><span class="s3">\n          </span><span class="s1">staticNodes.push(buildPublicFieldInitLoose(t.cloneNode(ref), prop));</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">// falls through</span><span class="s3">\n      </span><span class="s1">case isStatic &amp;&amp; isPublic &amp;&amp; isField &amp;&amp; !setPublicClassFields:</span><span class="s3">\n        </span><span class="s1">staticNodes.push(</span><span class="s3">\n          </span><span class="s1">buildPublicFieldInitSpec(t.cloneNode(ref), prop, file),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">case isInstance &amp;&amp;</span><span class="s3">\n        </span><span class="s1">isPrivate &amp;&amp;</span><span class="s3">\n        </span><span class="s1">isField &amp;&amp;</span><span class="s3">\n        </span><span class="s1">privateFieldsAsSymbolsOrProperties:</span><span class="s3">\n        </span><span class="s1">instanceNodes.push(</span><span class="s3">\n          </span><span class="s1">buildPrivateFieldInitLoose(t.thisExpression(), prop, privateNamesMap),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">case isInstance &amp;&amp;</span><span class="s3">\n        </span><span class="s1">isPrivate &amp;&amp;</span><span class="s3">\n        </span><span class="s1">isField &amp;&amp;</span><span class="s3">\n        </span><span class="s1">!privateFieldsAsSymbolsOrProperties:</span><span class="s3">\n        </span><span class="s1">instanceNodes.push(</span><span class="s3">\n          </span><span class="s1">buildPrivateInstanceFieldInitSpec(</span><span class="s3">\n            </span><span class="s1">t.thisExpression(),</span><span class="s3">\n            </span><span class="s1">prop,</span><span class="s3">\n            </span><span class="s1">privateNamesMap,</span><span class="s3">\n            </span><span class="s1">file,</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">case isInstance &amp;&amp;</span><span class="s3">\n        </span><span class="s1">isPrivate &amp;&amp;</span><span class="s3">\n        </span><span class="s1">isMethod &amp;&amp;</span><span class="s3">\n        </span><span class="s1">privateFieldsAsSymbolsOrProperties:</span><span class="s3">\n        </span><span class="s1">instanceNodes.unshift(</span><span class="s3">\n          </span><span class="s1">buildPrivateMethodInitLoose(</span><span class="s3">\n            </span><span class="s1">t.thisExpression(),</span><span class="s3">\n            </span><span class="s1">prop,</span><span class="s3">\n            </span><span class="s1">privateNamesMap,</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">pureStaticNodes.push(</span><span class="s3">\n          </span><span class="s1">buildPrivateMethodDeclaration(</span><span class="s3">\n            </span><span class="s1">file,</span><span class="s3">\n            </span><span class="s1">prop,</span><span class="s3">\n            </span><span class="s1">privateNamesMap,</span><span class="s3">\n            </span><span class="s1">privateFieldsAsSymbolsOrProperties,</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">case isInstance &amp;&amp;</span><span class="s3">\n        </span><span class="s1">isPrivate &amp;&amp;</span><span class="s3">\n        </span><span class="s1">isMethod &amp;&amp;</span><span class="s3">\n        </span><span class="s1">!privateFieldsAsSymbolsOrProperties:</span><span class="s3">\n        </span><span class="s1">instanceNodes.unshift(</span><span class="s3">\n          </span><span class="s1">buildPrivateInstanceMethodInitSpec(</span><span class="s3">\n            </span><span class="s1">t.thisExpression(),</span><span class="s3">\n            </span><span class="s1">prop,</span><span class="s3">\n            </span><span class="s1">privateNamesMap,</span><span class="s3">\n            </span><span class="s1">file,</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">pureStaticNodes.push(</span><span class="s3">\n          </span><span class="s1">buildPrivateMethodDeclaration(</span><span class="s3">\n            </span><span class="s1">file,</span><span class="s3">\n            </span><span class="s1">prop,</span><span class="s3">\n            </span><span class="s1">privateNamesMap,</span><span class="s3">\n            </span><span class="s1">privateFieldsAsSymbolsOrProperties,</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">case isStatic &amp;&amp;</span><span class="s3">\n        </span><span class="s1">isPrivate &amp;&amp;</span><span class="s3">\n        </span><span class="s1">isMethod &amp;&amp;</span><span class="s3">\n        </span><span class="s1">!privateFieldsAsSymbolsOrProperties:</span><span class="s3">\n        </span><span class="s1">if (!process.env.BABEL_8_BREAKING &amp;&amp; !newHelpers(file)) {</span><span class="s3">\n          </span><span class="s1">staticNodes.unshift(</span><span class="s3">\n            </span><span class="s1">// @ts-expect-error checked in switch</span><span class="s3">\n            </span><span class="s1">buildPrivateStaticFieldInitSpecOld(prop, privateNamesMap),</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">pureStaticNodes.push(</span><span class="s3">\n          </span><span class="s1">buildPrivateMethodDeclaration(</span><span class="s3">\n            </span><span class="s1">file,</span><span class="s3">\n            </span><span class="s1">prop,</span><span class="s3">\n            </span><span class="s1">privateNamesMap,</span><span class="s3">\n            </span><span class="s1">privateFieldsAsSymbolsOrProperties,</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">case isStatic &amp;&amp;</span><span class="s3">\n        </span><span class="s1">isPrivate &amp;&amp;</span><span class="s3">\n        </span><span class="s1">isMethod &amp;&amp;</span><span class="s3">\n        </span><span class="s1">privateFieldsAsSymbolsOrProperties:</span><span class="s3">\n        </span><span class="s1">staticNodes.unshift(</span><span class="s3">\n          </span><span class="s1">buildPrivateStaticMethodInitLoose(</span><span class="s3">\n            </span><span class="s1">t.cloneNode(ref),</span><span class="s3">\n            </span><span class="s1">prop,</span><span class="s3">\n            </span><span class="s1">file,</span><span class="s3">\n            </span><span class="s1">privateNamesMap,</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">pureStaticNodes.push(</span><span class="s3">\n          </span><span class="s1">buildPrivateMethodDeclaration(</span><span class="s3">\n            </span><span class="s1">file,</span><span class="s3">\n            </span><span class="s1">prop,</span><span class="s3">\n            </span><span class="s1">privateNamesMap,</span><span class="s3">\n            </span><span class="s1">privateFieldsAsSymbolsOrProperties,</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">case isInstance &amp;&amp; isPublic &amp;&amp; isField &amp;&amp; setPublicClassFields:</span><span class="s3">\n        </span><span class="s1">instanceNodes.push(buildPublicFieldInitLoose(t.thisExpression(), prop));</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">case isInstance &amp;&amp; isPublic &amp;&amp; isField &amp;&amp; !setPublicClassFields:</span><span class="s3">\n        </span><span class="s1">lastInstanceNodeReturnsThis = true;</span><span class="s3">\n        </span><span class="s1">instanceNodes.push(</span><span class="s3">\n          </span><span class="s1">buildPublicFieldInitSpec(t.thisExpression(), prop, file),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">default:</span><span class="s3">\n        </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">Unreachable.</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (classRefFlags &amp; ClassRefFlag.ForInnerBinding &amp;&amp; innerBindingRef != null) {</span><span class="s3">\n    </span><span class="s1">classBindingNode = t.expressionStatement(</span><span class="s3">\n      </span><span class="s1">t.assignmentExpression(</span><span class="s3">\n        \&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">t.cloneNode(classRefForInnerBinding),</span><span class="s3">\n        </span><span class="s1">t.cloneNode(innerBindingRef),</span><span class="s3">\n      </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">staticNodes: staticNodes.filter(Boolean),</span><span class="s3">\n    </span><span class="s1">instanceNodes: instanceNodes.filter(Boolean),</span><span class="s3">\n    </span><span class="s1">lastInstanceNodeReturnsThis,</span><span class="s3">\n    </span><span class="s1">pureStaticNodes: pureStaticNodes.filter(Boolean),</span><span class="s3">\n    </span><span class="s1">classBindingNode,</span><span class="s3">\n    </span><span class="s1">wrapClass(path: NodePath&lt;t.Class&gt;) {</span><span class="s3">\n      </span><span class="s1">for (const prop of props) {</span><span class="s3">\n        </span><span class="s1">// Delete leading comments so that they don't get attached as</span><span class="s3">\n        </span><span class="s1">// trailing comments of the previous sibling.</span><span class="s3">\n        </span><span class="s1">// When transforming props, we explicitly attach their leading</span><span class="s3">\n        </span><span class="s1">// comments to the transformed node with `inheritPropComments`</span><span class="s3">\n        </span><span class="s1">// above.</span><span class="s3">\n        </span><span class="s1">prop.node.leadingComments = null;</span><span class="s3">\n        </span><span class="s1">prop.remove();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (injectSuperRef) {</span><span class="s3">\n        </span><span class="s1">path.scope.push({ id: t.cloneNode(injectSuperRef) });</span><span class="s3">\n        </span><span class="s1">path.set(</span><span class="s3">\n          \&quot;</span><span class="s1">superClass</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n          </span><span class="s1">t.assignmentExpression(</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">, injectSuperRef, path.node.superClass),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (classRefFlags !== ClassRefFlag.None) {</span><span class="s3">\n        </span><span class="s1">if (path.isClassExpression()) {</span><span class="s3">\n          </span><span class="s1">path.scope.push({ id: ref });</span><span class="s3">\n          </span><span class="s1">path.replaceWith(</span><span class="s3">\n            </span><span class="s1">t.assignmentExpression(</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">, t.cloneNode(ref), path.node),</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">if (innerBindingRef == null) {</span><span class="s3">\n            </span><span class="s1">// export anonymous class declaration</span><span class="s3">\n            </span><span class="s1">path.node.id = ref;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">if (classBindingNode != null) {</span><span class="s3">\n            </span><span class="s1">path.scope.push({ id: classRefForInnerBinding });</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return path;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;;AAAA,IAAAA,KAAA,GAAAC,OAAA;AAEA,IAAAC,SAAA,GAAAD,OAAA;AACA,IAAAE,oBAAA,GAAAF,OAAA;AACA,IAAAG,kCAAA,GAAAH,OAAA;AAKA,IAAAI,6BAAA,GAAAJ,OAAA;AACA,IAAAK,qBAAA,GAAAL,OAAA;AACA,IAAAM,wCAAA,GAAAN,OAAA;AAEA,IAAAO,EAAA,GAAAP,OAAA;AAkBmC;EAEjC,IAAIQ,UAAU,GAAIC,IAAU,IAAK;IAAA;IAS/B,OAAOA,IAAI,CAACC,eAAe,CAAC,uBAAuB,CAAC;EACtD,CAAC;AACH;AAEO,SAASC,oBAAoBA,CAClCC,SAAiB,EACjBC,kCAA2C,EAC3CC,KAAiB,EACjBL,IAAU,EACV;EACA,MAAMM,eAAgC,GAAG,IAAIC,GAAG,CAAC,CAAC;EAClD,IAAIC,YAA0B;EAC9B,KAAK,MAAMC,IAAI,IAAIJ,KAAK,EAAE;IACxB,IAAII,IAAI,CAACC,SAAS,CAAC,CAAC,EAAE;MACpB,MAAM;QAAEC;MAAK,CAAC,GAAGF,IAAI,CAACG,IAAI,CAACC,GAAG,CAACC,EAAE;MACjC,IAAIC,MAA2B,GAAGT,eAAe,CAACU,GAAG,CAACL,IAAI,CAAC;MAC3D,IAAI,CAACI,MAAM,EAAE;QACX,MAAME,QAAQ,GAAG,CAACR,IAAI,CAACS,UAAU,CAAC,CAAC;QACnC,MAAMC,QAAQ,GAAGV,IAAI,CAACG,IAAI,CAACQ,MAAM;QACjC,IAAIC,SAAS,GAAG,KAAK;QACrB,IAAIP,EAAgB;QACpB,IACE,CAACV,kCAAkC,IACFL,UAAU,CAACC,IAAI,CAAC,IACjDiB,QAAQ,IACR,CAACE,QAAQ,EACT;UACAE,SAAS,GAAG,CAAC,CAACb,YAAY;UAC1BA,YAAY,WAAZA,YAAY,GAAZA,YAAY,GAAKC,IAAI,CAACa,KAAK,CAACC,qBAAqB,CAC/C,GAAGpB,SAAS,QACd,CAAC;UACDW,EAAE,GAAGN,YAAY;QACnB,CAAC,MAAM;UACLM,EAAE,GAAGL,IAAI,CAACa,KAAK,CAACC,qBAAqB,CAACZ,IAAI,CAAC;QAC7C;QACAI,MAAM,GAAG;UAAED,EAAE;UAAEM,MAAM,EAAED,QAAQ;UAAEK,MAAM,EAAEP,QAAQ;UAAEI;QAAU,CAAC;QAC9Df,eAAe,CAACmB,GAAG,CAACd,IAAI,EAAEI,MAAM,CAAC;MACnC;MACA,IAAIN,IAAI,CAACiB,oBAAoB,CAAC,CAAC,EAAE;QAC/B,IAAIjB,IAAI,CAACG,IAAI,CAACe,IAAI,KAAK,KAAK,EAAE;UAC5B,MAAM;YAAEC;UAAK,CAAC,GAAGnB,IAAI,CAACG,IAAI,CAACgB,IAAI;UAC/B,IAAIC,CAAS;UACb,IAIED,IAAI,CAACE,MAAM,KAAK,CAAC,IACjBC,WAAC,CAACC,iBAAiB,CAAEH,CAAC,GAAGD,IAAI,CAAC,CAAC,CAAE,CAAC,IAClCG,WAAC,CAACE,gBAAgB,CAAEJ,CAAC,GAAGA,CAAC,CAACK,QAAS,CAAC,IACpCL,CAAC,CAACM,SAAS,CAACL,MAAM,KAAK,CAAC,IACxBC,WAAC,CAACK,gBAAgB,CAACP,CAAC,CAACM,SAAS,CAAC,CAAC,CAAC,CAAC,IAClCJ,WAAC,CAACM,YAAY,CAAER,CAAC,GAAGA,CAAC,CAACS,MAAO,CAAC,EAC9B;YACAvB,MAAM,CAACwB,KAAK,GAAGR,WAAC,CAACS,SAAS,CAACX,CAAC,CAAC;YAC7Bd,MAAM,CAAC0B,cAAc,GAAG,IAAI;UAC9B,CAAC,MAAM;YACL1B,MAAM,CAACwB,KAAK,GAAG9B,IAAI,CAACa,KAAK,CAACC,qBAAqB,CAAC,OAAOZ,IAAI,EAAE,CAAC;UAChE;QACF,CAAC,MAAM,IAAIF,IAAI,CAACG,IAAI,CAACe,IAAI,KAAK,KAAK,EAAE;UACnC,MAAM;YAAEe;UAAO,CAAC,GAAGjC,IAAI,CAACG,IAAI;UAC5B,MAAM;YAAEgB;UAAK,CAAC,GAAGnB,IAAI,CAACG,IAAI,CAACgB,IAAI;UAC/B,IAAIC,CAAS;UACb,IAIED,IAAI,CAACE,MAAM,KAAK,CAAC,IACjBC,WAAC,CAACY,qBAAqB,CAAEd,CAAC,GAAGD,IAAI,CAAC,CAAC,CAAE,CAAC,IACtCG,WAAC,CAACE,gBAAgB,CAAEJ,CAAC,GAAGA,CAAC,CAACe,UAAW,CAAC,IACtCf,CAAC,CAACM,SAAS,CAACL,MAAM,KAAK,CAAC,IACxBC,WAAC,CAACK,gBAAgB,CAACP,CAAC,CAACM,SAAS,CAAC,CAAC,CAAC,CAAC,IAClCJ,WAAC,CAACM,YAAY,CAACR,CAAC,CAACM,SAAS,CAAC,CAAC,CAAC,EAAE;YAC7BxB,IAAI,EAAG+B,MAAM,CAAC,CAAC,CAAC,CAAkB/B;UACpC,CAAC,CAAC,IACFoB,WAAC,CAACM,YAAY,CAAER,CAAC,GAAGA,CAAC,CAACS,MAAO,CAAC,EAC9B;YACAvB,MAAM,CAAC8B,KAAK,GAAGd,WAAC,CAACS,SAAS,CAACX,CAAC,CAAC;YAC7Bd,MAAM,CAAC+B,cAAc,GAAG,IAAI;UAC9B,CAAC,MAAM;YACL/B,MAAM,CAAC8B,KAAK,GAAGpC,IAAI,CAACa,KAAK,CAACC,qBAAqB,CAAC,OAAOZ,IAAI,EAAE,CAAC;UAChE;QACF,CAAC,MAAM,IAAIF,IAAI,CAACG,IAAI,CAACe,IAAI,KAAK,QAAQ,EAAE;UACtCZ,MAAM,CAACgC,QAAQ,GAAGtC,IAAI,CAACa,KAAK,CAACC,qBAAqB,CAACZ,IAAI,CAAC;QAC1D;MACF;MACAL,eAAe,CAACmB,GAAG,CAACd,IAAI,EAAEI,MAAM,CAAC;IACnC;EACF;EACA,OAAOT,eAAe;AACxB;AAEO,SAAS0C,sBAAsBA,CACpC1C,eAAgC,EAChC2C,yBAAkC,EAClCC,sBAA+B,EAC/BC,KAAW,EACX;EACA,MAAMC,SAAwB,GAAG,EAAE;EAEnC,MAAMC,WAAW,GAAG,IAAIC,GAAG,CAAS,CAAC;EAErC,KAAK,MAAM,CAAC3C,IAAI,EAAE4C,KAAK,CAAC,IAAIjD,eAAe,EAAE;IAW3C,MAAM;MAAEc,MAAM,EAAED,QAAQ;MAAEK,MAAM,EAAEP,QAAQ;MAAEsB,KAAK;MAAEM;IAAM,CAAC,GAAGU,KAAK;IAClE,MAAMC,gBAAgB,GAAGjB,KAAK,IAAIM,KAAK;IACvC,MAAM/B,EAAE,GAAGiB,WAAC,CAACS,SAAS,CAACe,KAAK,CAACzC,EAAE,CAAC;IAEhC,IAAI2C,IAAkB;IAEtB,IAAIR,yBAAyB,EAAE;MAC7BQ,IAAI,GAAG1B,WAAC,CAAC2B,cAAc,CAACP,KAAK,CAACQ,SAAS,CAAC,2BAA2B,CAAC,EAAE,CACpE5B,WAAC,CAAC6B,aAAa,CAACjD,IAAI,CAAC,CACtB,CAAC;IACJ,CAAC,MAAM,IAAIuC,sBAAsB,EAAE;MACjCO,IAAI,GAAG1B,WAAC,CAAC2B,cAAc,CAAC3B,WAAC,CAAC8B,UAAU,CAAC,QAAQ,CAAC,EAAE,CAAC9B,WAAC,CAAC6B,aAAa,CAACjD,IAAI,CAAC,CAAC,CAAC;IAC1E,CAAC,MAAM,IAAI,CAACQ,QAAQ,EAAE;MACpB,IAAIkC,WAAW,CAACS,GAAG,CAAChD,EAAE,CAACH,IAAI,CAAC,EAAE;MAC9B0C,WAAW,CAACU,GAAG,CAACjD,EAAE,CAACH,IAAI,CAAC;MAExB8C,IAAI,GAAG1B,WAAC,CAACiC,aAAa,CACpBjC,WAAC,CAAC8B,UAAU,CACV5C,QAAQ,KAEJ,CAACuC,gBAAgB,IACjBzD,UAAU,CAACoD,KAAK,CAAC,IACjB,SAAS,GACT,SACN,CAAC,EACD,EACF,CAAC;IACH;IAEA,IAAIM,IAAI,EAAE;MACR,IAAI,CAACP,sBAAsB,EAAE;QAC3B,IAAAe,6BAAc,EAACR,IAAI,CAAC;MACtB;MACAL,SAAS,CAACc,IAAI,CAACC,cAAQ,CAACC,SAAS,CAACC,GAAG,OAAOvD,EAAE,MAAM2C,IAAI,EAAE,CAAC;IAC7D;EACF;EAEA,OAAOL,SAAS;AAClB;AAUO,SAASkB,yBAAyBA,CACvCC,OAAsE,EACtE;EAGA,MAAMC,aAAa,GAAGC,kBAAQ,CAACC,kBAAkB,CAAAC,MAAA,CAAAC,MAAA,KAAML,OAAO,CAAE,CAAC;EAEjE,MAAMM,kBAEL,GAAAF,MAAA,CAAAC,MAAA,KACIL,OAAO;IAEVO,KAAKA,CAACC,IAAI,EAAE;MACV,MAAM;QAAEzE;MAAgB,CAAC,GAAG,IAAI;MAChC,MAAMsB,IAAI,GAAGmD,IAAI,CAAC/D,GAAG,CAAC,WAAW,CAAC;MAElC,MAAMgE,mBAAmB,GAAG,IAAIzE,GAAG,CAACD,eAAe,CAAC;MACpD,MAAM2E,UAAU,GAAG,EAAE;MACrB,KAAK,MAAMxE,IAAI,IAAImB,IAAI,EAAE;QACvB,IAAI,CAACnB,IAAI,CAACC,SAAS,CAAC,CAAC,EAAE;QACvB,MAAM;UAAEC;QAAK,CAAC,GAAGF,IAAI,CAACG,IAAI,CAACC,GAAG,CAACC,EAAE;QACjCkE,mBAAmB,CAACE,MAAM,CAACvE,IAAI,CAAC;QAChCsE,UAAU,CAACf,IAAI,CAACvD,IAAI,CAAC;MACvB;MAIA,IAAI,CAACsE,UAAU,CAACnD,MAAM,EAAE;QACtB;MACF;MAKAiD,IAAI,CAAC/D,GAAG,CAAC,MAAM,CAAC,CAACmE,QAAQ,CAACX,aAAa,EAAAG,MAAA,CAAAC,MAAA,KAClC,IAAI;QACPK;MAAU,EACX,CAAC;MACFF,IAAI,CAACI,QAAQ,CAACN,kBAAkB,EAAAF,MAAA,CAAAC,MAAA,KAC3B,IAAI;QACPtE,eAAe,EAAE0E;MAAmB,EACrC,CAAC;MAIFD,IAAI,CAACK,OAAO,CAAC,MAAM,CAAC;IACtB;EAAC,EACF;EAED,OAAOP,kBAAkB;AAC3B;AAWA,MAAMA,kBAAkB,GAAGP,yBAAyB,CAGlD;EACAe,WAAWA,CAACN,IAAI,EAAE;IAAEO;EAAc,CAAC,EAAE;IACnC,MAAM;MAAEhF,eAAe;MAAE2E;IAAW,CAAC,GAAG,IAAI;IAC5C,MAAM;MAAErE,IAAI;MAAE2E;IAAW,CAAC,GAAGR,IAAI;IAEjC,IACE,CAACQ,UAAU,CAACC,kBAAkB,CAAC;MAAEC,QAAQ,EAAE7E;IAAK,CAAC,CAAC,IAClD,CAAC2E,UAAU,CAACG,0BAA0B,CAAC;MAAED,QAAQ,EAAE7E;IAAK,CAAC,CAAC,EAC1D;MACA;IACF;IACA,MAAM;MAAED;IAAK,CAAC,GAAGC,IAAI,CAACE,EAAE;IACxB,IAAI,CAACR,eAAe,CAACwD,GAAG,CAACnD,IAAI,CAAC,EAAE;IAChC,IAAIsE,UAAU,YAAVA,UAAU,CAAEU,QAAQ,CAAChF,IAAI,CAAC,EAAE;IAEhC,IAAI,CAACiF,MAAM,CAACL,UAAU,EAAED,aAAa,CAAC;EACxC;AACF,CAAC,CAAC;AAGF,SAASO,QAAQA,CACflF,IAAY,EACZW,KAAY,EACZwE,YAAsC,EACtC;EAIA,OACE,CAAAC,MAAA,GAAAzE,KAAK,aAALyE,MAAA,CAAOC,UAAU,CAACrF,IAAI,CAAC,IACvB,CAACW,KAAK,CAAC2E,uBAAuB,CAACtF,IAAI,EAAEmF,YAAY,CAAC,EAClD;IAAA,IAAAC,MAAA;IACAzE,KAAK,CAAC4E,MAAM,CAACvF,IAAI,CAAC;IAClBW,KAAK,GAAGA,KAAK,CAAC6E,MAAM;EACtB;AACF;AAEO,SAASC,eAAeA,CAC7BC,GAAiB,EACjBrG,IAAU,EACVsG,aAAuB,EACvB;EACA,IAAIA,aAAa,IAAI,EAACtG,IAAI,CAACC,eAAe,YAApBD,IAAI,CAACC,eAAe,CAAG,YAAY,CAAC,GAAE,OAAOoG,GAAG;EACtE,OAAOtE,WAAC,CAAC2B,cAAc,CAAC1D,IAAI,CAAC2D,SAAS,CAAC,YAAY,CAAC,EAAE,CAAC0C,GAAG,CAAC,CAAC;AAC9D;AAEA,MAAME,gBAAgB,GAAGjC,yBAAyB,CAQhD;EACAkC,gBAAgBA,CAACzB,IAAI,EAAE;IAAE/E;EAAK,CAAC,EAAE;IAC/B,MAAM;MAAEyG,QAAQ;MAAEC,IAAI;MAAEC;IAAM,CAAC,GAAG5B,IAAI,CAACnE,IAAI;IAC3C,IAAI6F,QAAQ,KAAK,IAAI,EAAE;IACvB,IAAI,CAAC1E,WAAC,CAAC6E,aAAa,CAACF,IAAI,CAAC,EAAE;IAE5B,MAAM;MAAEzD,yBAAyB;MAAE3C,eAAe;MAAE2E;IAAW,CAAC,GAAG,IAAI;IAEvE,MAAM;MAAEtE;IAAK,CAAC,GAAG+F,IAAI,CAAC5F,EAAE;IAExB,IAAI,CAACR,eAAe,CAACwD,GAAG,CAACnD,IAAI,CAAC,EAAE;IAChC,IAAIsE,UAAU,YAAVA,UAAU,CAAEU,QAAQ,CAAChF,IAAI,CAAC,EAAE;IAIhCkF,QAAQ,CAAC,IAAI,CAACgB,QAAQ,CAAClG,IAAI,EAAEoE,IAAI,CAACzD,KAAK,EAAE,IAAI,CAACwE,YAAY,CAAC;IAE3D,IAAI7C,yBAAyB,EAAE;MAC7B,MAAM;QAAEnC;MAAG,CAAC,GAAGR,eAAe,CAACU,GAAG,CAACL,IAAI,CAAC;MACxCoE,IAAI,CAAC+B,WAAW,CAAC3C,cAAQ,CAACvB,UAAU,CAACyB,GAAG;AAC9C,+CAA+C+B,eAAe,CACpDO,KAAK,EACL3G,IACF,CAAC,KAAK+B,WAAC,CAACS,SAAS,CAAC1B,EAAE,CAAC;AAC7B,OAAO,CAAC;MACF;IACF;IAEA,MAAM;MAAEA,EAAE;MAAEM,MAAM,EAAED;IAAS,CAAC,GAAGb,eAAe,CAACU,GAAG,CAACL,IAAI,CAAC;IAE1D,IAAIQ,QAAQ,EAAE;MACZ4D,IAAI,CAAC+B,WAAW,CACd3C,cAAQ,CAACvB,UAAU,CAACyB,GAAG,GAAG+B,eAAe,CACvCO,KAAK,EACL3G,IACF,CAAC,QAAQ+B,WAAC,CAACS,SAAS,CAAC,IAAI,CAACqE,QAAQ,CAAC,EACrC,CAAC;MACD;IACF;IAEA9B,IAAI,CAAC+B,WAAW,CACd3C,cAAQ,CAACvB,UAAU,CAACyB,GAAG,GAAGtC,WAAC,CAACS,SAAS,CAAC1B,EAAE,CAAC,QAAQsF,eAAe,CAC9DO,KAAK,EACL3G,IACF,CAAC,GACH,CAAC;EACH;AACF,CAAC,CAAC;AASF,SAAS+G,aAAaA,CAAC/G,IAAU,EAAEW,IAAY,EAAE;EAC/C,OAAOoB,WAAC,CAAC2B,cAAc,CAAC1D,IAAI,CAAC2D,SAAS,CAAC,eAAe,CAAC,EAAE,CACvD5B,WAAC,CAAC6B,aAAa,CAAC,IAAIjD,IAAI,EAAE,CAAC,CAC5B,CAAC;AACJ;AAEA,SAASqG,cAAcA,CAAChH,IAAU,EAAEW,IAAY,EAAE;EAChD,IAEE,CAACX,IAAI,CAACC,eAAe,CAAC,gBAAgB,CAAC,EACvC;IACAgH,OAAO,CAACC,IAAI,CACV,gEACF,CAAC;IACD,OAAOnF,WAAC,CAACoF,kBAAkB,CAAC,CAAC;EAC/B;EACA,OAAOpF,WAAC,CAAC2B,cAAc,CAAC1D,IAAI,CAAC2D,SAAS,CAAC,gBAAgB,CAAC,EAAE,CACxD5B,WAAC,CAAC6B,aAAa,CAAC,IAAIjD,IAAI,EAAE,CAAC,CAC5B,CAAC;AACJ;AAEA,SAASyG,6BAA6BA,CACpCC,IAAO,EACPC,iCAA0C,EAC1C;EACA,IAAIA,iCAAiC,EAAE,OAAOD,IAAI;EAClD,OAAOtF,WAAC,CAACwF,gBAAgB,CAACF,IAAI,EAAEtF,WAAC,CAAC8B,UAAU,CAAC,GAAG,CAAC,CAAC;AACpD;AAEA,SAAS2D,YAAYA,CAInBC,EAAM,EAAM;EACZ,OAAO,UAAuCC,MAAM,EAAE;IACpD,OAAO3F,WAAC,CAAC4F,QAAQ,CAACF,EAAE,CAACG,KAAK,CAAC,IAAI,EAAEzF,SAAgB,CAAC,EAAEuF,MAAM,CAAC9G,IAAI,CAAC;EAClE,CAAC;AACH;AAEA,MAAMiH,sBAAuE,GAC3E;EACEC,OAAOA,CAACJ,MAAM,EAAEK,KAAK,EAAE;IACrB,MAAM;MAAEzG;IAAM,CAAC,GAAGoG,MAAM;IACxB,MAAM;MAAEM;IAAO,CAAC,GAAGN,MAAM,CAAC9G,IAAgC;IAE1D,MAAMqH,IAAI,GAAG3G,KAAK,CAAC4G,qBAAqB,CAACF,MAAM,CAAC;IAChD,IAAI,CAACC,IAAI,EAAE;MACT;IACF;IAEA,IAAI,CAACE,QAAQ,CAAC1G,GAAG,CAACuG,MAAM,EAAEC,IAAI,EAAEF,KAAK,CAAC;EACxC,CAAC;EAEDK,QAAQA,CAACV,MAAM,EAAE;IACf,MAAM;MAAEM;IAAO,CAAC,GAAGN,MAAM,CAAC9G,IAAgC;IAE1D,IAAI,IAAI,CAACuH,QAAQ,CAACrE,GAAG,CAACkE,MAAM,CAAC,EAAE;MAC7B,OAAOjG,WAAC,CAACS,SAAS,CAAC,IAAI,CAAC2F,QAAQ,CAACnH,GAAG,CAACgH,MAAM,CAAC,CAAC;IAC/C;IAEA,OAAOjG,WAAC,CAACS,SAAS,CAACwF,MAAM,CAAC;EAC5B,CAAC;EAEDhH,GAAG,EAAEwG,YAAY,CAAC,UAAUE,MAAM,EAAE;IAClC,MAAM;MACJb,QAAQ;MACRvG,eAAe;MACfN,IAAI;MACJ8F,YAAY;MACZwB;IACF,CAAC,GAAG,IAAI;IACR,MAAMe,WAAW,GAAGX,MAAM,CAAC9G,IAAI,CAAC6E,QAAyB;IACzD,MAAM;MAAE9E;IAAK,CAAC,GAAG0H,WAAW,CAACvH,EAAE;IAC/B,MAAM;MACJA,EAAE;MACFM,MAAM,EAAED,QAAQ;MAChBK,MAAM,EAAEP,QAAQ;MAChB8B,QAAQ;MACRR,KAAK;MACLM;IACF,CAAC,GAAGvC,eAAe,CAACU,GAAG,CAACL,IAAI,CAAC;IAC7B,MAAM6C,gBAAgB,GAAGjB,KAAK,IAAIM,KAAK;IAEvC,MAAMyF,OAAO,GAAIxH,EAAgB,IAC/BiB,WAAC,CAAC4F,QAAQ,CAAC5F,WAAC,CAACS,SAAS,CAAC1B,EAAE,CAAC,EAAEuH,WAAW,CAAC;IAE1C,IAAIlH,QAAQ,EAAE;MAGZ0E,QAAQ,CAACgB,QAAQ,CAAClG,IAAI,EAAE+G,MAAM,CAACpG,KAAK,EAAEwE,YAAY,CAAC;MAEnD,IAAqC,CAAC/F,UAAU,CAACC,IAAI,CAAC,EAAE;QAGtD,MAAMuI,UAAU,GACdtH,QAAQ,IAAI,CAACuC,gBAAgB,GACzB,6BAA6B,GAC7B,gCAAgC;QAEtC,OAAOzB,WAAC,CAAC2B,cAAc,CAAC1D,IAAI,CAAC2D,SAAS,CAAC4E,UAAU,CAAC,EAAE,CAClD,IAAI,CAACH,QAAQ,CAACV,MAAM,CAAC,EACrB3F,WAAC,CAACS,SAAS,CAACqE,QAAQ,CAAC,EACrByB,OAAO,CAACxH,EAAE,CAAC,CACZ,CAAC;MACJ;MAEA,MAAMsH,QAAQ,GAAG,IAAI,CAACA,QAAQ,CAACV,MAAM,CAAC;MACtC,MAAMc,SAAS,GACbzG,WAAC,CAACM,YAAY,CAAC+F,QAAQ,CAAC,IAAIA,QAAQ,CAACzH,IAAI,KAAKkG,QAAQ,CAAClG,IAAI;MAE7D,IAAI,CAACM,QAAQ,EAAE;QACb,IAAIuH,SAAS,EAAE;UACb,OAAOpB,6BAA6B,CAClCkB,OAAO,CAACxH,EAAE,CAAC,EACXwG,iCACF,CAAC;QACH;QAEA,OAAOF,6BAA6B,CAClCrF,WAAC,CAAC2B,cAAc,CAAC1D,IAAI,CAAC2D,SAAS,CAAC,kBAAkB,CAAC,EAAE,CACnD5B,WAAC,CAACS,SAAS,CAACqE,QAAQ,CAAC,EACrBuB,QAAQ,EACRE,OAAO,CAACxH,EAAE,CAAC,CACZ,CAAC,EACFwG,iCACF,CAAC;MACH;MAEA,IAAI/E,KAAK,EAAE;QACT,IAAIiG,SAAS,EAAE;UACb,OAAOzG,WAAC,CAAC2B,cAAc,CAAC4E,OAAO,CAAC/F,KAAK,CAAC,EAAE,CAAC6F,QAAQ,CAAC,CAAC;QACrD;QACA,OAAOrG,WAAC,CAAC2B,cAAc,CAAC1D,IAAI,CAAC2D,SAAS,CAAC,oBAAoB,CAAC,EAAE,CAC5D5B,WAAC,CAACS,SAAS,CAACqE,QAAQ,CAAC,EACrBuB,QAAQ,EACRE,OAAO,CAAC/F,KAAK,CAAC,CACf,CAAC;MACJ;MAEA,IAAIM,KAAK,EAAE;QACT,MAAM4F,GAAG,GAAG1G,WAAC,CAACoF,kBAAkB,CAAC,CAAC;QAClC,IAAIqB,SAAS,EAAE,OAAOC,GAAG;QACzB,OAAO1G,WAAC,CAAC2G,kBAAkB,CAAC,CAC1B3G,WAAC,CAAC2B,cAAc,CAAC1D,IAAI,CAAC2D,SAAS,CAAC,kBAAkB,CAAC,EAAE,CACnD5B,WAAC,CAACS,SAAS,CAACqE,QAAQ,CAAC,EACrBuB,QAAQ,CACT,CAAC,EACFK,GAAG,CACJ,CAAC;MACJ;MAEA,IAAID,SAAS,EAAE,OAAOF,OAAO,CAACxH,EAAE,CAAC;MACjC,OAAOiB,WAAC,CAAC2B,cAAc,CAAC1D,IAAI,CAAC2D,SAAS,CAAC,kBAAkB,CAAC,EAAE,CAC1D5B,WAAC,CAACS,SAAS,CAACqE,QAAQ,CAAC,EACrBuB,QAAQ,EACRE,OAAO,CAACxH,EAAE,CAAC,CACZ,CAAC;IACJ;IAEA,IAAIG,QAAQ,EAAE;MACZ,IAAIuC,gBAAgB,EAAE;QACpB,IAAI,CAACjB,KAAK,EAAE;UACV,OAAOR,WAAC,CAAC2G,kBAAkB,CAAC,CAC1B,IAAI,CAACN,QAAQ,CAACV,MAAM,CAAC,EACrBV,cAAc,CAAChH,IAAI,EAAEW,IAAI,CAAC,CAC3B,CAAC;QACJ;QACA,IAAqC,CAACZ,UAAU,CAACC,IAAI,CAAC,EAAE;UACtD,OAAO+B,WAAC,CAAC2B,cAAc,CAAC1D,IAAI,CAAC2D,SAAS,CAAC,sBAAsB,CAAC,EAAE,CAC9D,IAAI,CAACyE,QAAQ,CAACV,MAAM,CAAC,EACrBY,OAAO,CAACxH,EAAE,CAAC,CACZ,CAAC;QACJ;QACA,OAAOiB,WAAC,CAAC2B,cAAc,CAAC1D,IAAI,CAAC2D,SAAS,CAAC,oBAAoB,CAAC,EAAE,CAC5D5B,WAAC,CAACS,SAAS,CAAC1B,EAAE,CAAC,EACf,IAAI,CAACsH,QAAQ,CAACV,MAAM,CAAC,EACrBY,OAAO,CAAC/F,KAAK,CAAC,CACf,CAAC;MACJ;MACA,IAAqC,CAACxC,UAAU,CAACC,IAAI,CAAC,EAAE;QACtD,OAAO+B,WAAC,CAAC2B,cAAc,CAAC1D,IAAI,CAAC2D,SAAS,CAAC,uBAAuB,CAAC,EAAE,CAC/D,IAAI,CAACyE,QAAQ,CAACV,MAAM,CAAC,EACrB3F,WAAC,CAACS,SAAS,CAAC1B,EAAE,CAAC,EACfwH,OAAO,CAACvF,QAAQ,CAAC,CAClB,CAAC;MACJ;MACA,OAAOhB,WAAC,CAAC2B,cAAc,CAAC1D,IAAI,CAAC2D,SAAS,CAAC,kBAAkB,CAAC,EAAE,CAC1D5B,WAAC,CAACS,SAAS,CAAC1B,EAAE,CAAC,EACf,IAAI,CAACsH,QAAQ,CAACV,MAAM,CAAC,EACrBY,OAAO,CAACvF,QAAQ,CAAC,CAClB,CAAC;IACJ;IACA,IAAoChD,UAAU,CAACC,IAAI,CAAC,EAAE;MACpD,OAAO+B,WAAC,CAAC2B,cAAc,CAAC1D,IAAI,CAAC2D,SAAS,CAAC,uBAAuB,CAAC,EAAE,CAC/D2E,OAAO,CAACxH,EAAE,CAAC,EACX,IAAI,CAACsH,QAAQ,CAACV,MAAM,CAAC,CACtB,CAAC;IACJ;IAEA,OAAO3F,WAAC,CAAC2B,cAAc,CAAC1D,IAAI,CAAC2D,SAAS,CAAC,sBAAsB,CAAC,EAAE,CAC9D,IAAI,CAACyE,QAAQ,CAACV,MAAM,CAAC,EACrBY,OAAO,CAACxH,EAAE,CAAC,CACZ,CAAC;EACJ,CAAC,CAAC;EAEF6H,QAAQA,CAACjB,MAAM,EAAE;IACf,IAAI,CAACI,OAAO,CAACJ,MAAM,EAAE,CAAC,CAAC;IAEvB,OAAO3F,WAAC,CAAC2B,cAAc,CACrB3B,WAAC,CAACwF,gBAAgB,CAAC,IAAI,CAACvG,GAAG,CAAC0G,MAAM,CAAC,EAAE3F,WAAC,CAAC8B,UAAU,CAAC,MAAM,CAAC,CAAC,EAC1D,CAAC,IAAI,CAACuE,QAAQ,CAACV,MAAM,CAAC,CACxB,CAAC;EACH,CAAC;EAEDjG,GAAG,EAAE+F,YAAY,CAAC,UAAUE,MAAM,EAAEnE,KAAK,EAAE;IACzC,MAAM;MACJsD,QAAQ;MACRvG,eAAe;MACfN,IAAI;MACJsH;IACF,CAAC,GAAG,IAAI;IACR,MAAMe,WAAW,GAAGX,MAAM,CAAC9G,IAAI,CAAC6E,QAAyB;IACzD,MAAM;MAAE9E;IAAK,CAAC,GAAG0H,WAAW,CAACvH,EAAE;IAC/B,MAAM;MACJA,EAAE;MACFM,MAAM,EAAED,QAAQ;MAChBK,MAAM,EAAEP,QAAQ;MAChB4B,KAAK;MACLN;IACF,CAAC,GAAGjC,eAAe,CAACU,GAAG,CAACL,IAAI,CAAC;IAC7B,MAAM6C,gBAAgB,GAAGjB,KAAK,IAAIM,KAAK;IAEvC,MAAMyF,OAAO,GAAIxH,EAAgB,IAC/BiB,WAAC,CAAC4F,QAAQ,CAAC5F,WAAC,CAACS,SAAS,CAAC1B,EAAE,CAAC,EAAEuH,WAAW,CAAC;IAE1C,IAAIlH,QAAQ,EAAE;MACZ,IAAqC,CAACpB,UAAU,CAACC,IAAI,CAAC,EAAE;QACtD,MAAMuI,UAAU,GACdtH,QAAQ,IAAI,CAACuC,gBAAgB,GACzB,6BAA6B,GAC7B,gCAAgC;QAEtC,OAAOzB,WAAC,CAAC2B,cAAc,CAAC1D,IAAI,CAAC2D,SAAS,CAAC4E,UAAU,CAAC,EAAE,CAClD,IAAI,CAACH,QAAQ,CAACV,MAAM,CAAC,EACrB3F,WAAC,CAACS,SAAS,CAACqE,QAAQ,CAAC,EACrByB,OAAO,CAACxH,EAAE,CAAC,EACXyC,KAAK,CACN,CAAC;MACJ;MAEA,MAAM6E,QAAQ,GAAG,IAAI,CAACA,QAAQ,CAACV,MAAM,CAAC;MACtC,MAAMc,SAAS,GACbzG,WAAC,CAACM,YAAY,CAAC+F,QAAQ,CAAC,IAAIA,QAAQ,CAACzH,IAAI,KAAKkG,QAAQ,CAAClG,IAAI;MAE7D,IAAIM,QAAQ,IAAI,CAAC4B,KAAK,EAAE;QACtB,MAAM4F,GAAG,GAAG1B,aAAa,CAAC/G,IAAI,EAAEW,IAAI,CAAC;QACrC,IAAI6H,SAAS,EAAE,OAAOzG,WAAC,CAAC2G,kBAAkB,CAAC,CAACnF,KAAK,EAAEkF,GAAG,CAAC,CAAC;QACxD,OAAO1G,WAAC,CAAC2G,kBAAkB,CAAC,CAC1BnF,KAAK,EACLxB,WAAC,CAAC2B,cAAc,CAAC1D,IAAI,CAAC2D,SAAS,CAAC,kBAAkB,CAAC,EAAE,CACnD5B,WAAC,CAACS,SAAS,CAACqE,QAAQ,CAAC,EACrBuB,QAAQ,CACT,CAAC,EACFrB,aAAa,CAAC/G,IAAI,EAAEW,IAAI,CAAC,CAC1B,CAAC;MACJ;MAEA,IAAIkC,KAAK,EAAE;QACT,IAAI2F,SAAS,EAAE;UACb,OAAOzG,WAAC,CAAC2B,cAAc,CAAC3B,WAAC,CAACS,SAAS,CAACK,KAAK,CAAC,EAAE,CAACuF,QAAQ,EAAE7E,KAAK,CAAC,CAAC;QAChE;QACA,OAAOxB,WAAC,CAAC2B,cAAc,CAAC1D,IAAI,CAAC2D,SAAS,CAAC,oBAAoB,CAAC,EAAE,CAC5D5B,WAAC,CAACS,SAAS,CAACqE,QAAQ,CAAC,EACrByB,OAAO,CAACzF,KAAK,CAAC,EACduF,QAAQ,EACR7E,KAAK,CACN,CAAC;MACJ;MACA,OAAOxB,WAAC,CAAC6G,oBAAoB,CAC3B,GAAG,EACHxB,6BAA6B,CAC3BkB,OAAO,CAACxH,EAAE,CAAC,EACXwG,iCACF,CAAC,EACDkB,SAAS,GACLjF,KAAK,GACLxB,WAAC,CAAC2B,cAAc,CAAC1D,IAAI,CAAC2D,SAAS,CAAC,kBAAkB,CAAC,EAAE,CACnD5B,WAAC,CAACS,SAAS,CAACqE,QAAQ,CAAC,EACrBuB,QAAQ,EACR7E,KAAK,CACN,CACP,CAAC;IACH;IACA,IAAItC,QAAQ,EAAE;MACZ,IAAI4B,KAAK,EAAE;QACT,IAAqC,CAAC9C,UAAU,CAACC,IAAI,CAAC,EAAE;UACtD,OAAO+B,WAAC,CAAC2B,cAAc,CAAC1D,IAAI,CAAC2D,SAAS,CAAC,sBAAsB,CAAC,EAAE,CAC9D,IAAI,CAACyE,QAAQ,CAACV,MAAM,CAAC,EACrBY,OAAO,CAACxH,EAAE,CAAC,EACXyC,KAAK,CACN,CAAC;QACJ;QACA,OAAOxB,WAAC,CAAC2B,cAAc,CAAC1D,IAAI,CAAC2D,SAAS,CAAC,oBAAoB,CAAC,EAAE,CAC5D5B,WAAC,CAACS,SAAS,CAAC1B,EAAE,CAAC,EACfwH,OAAO,CAACzF,KAAK,CAAC,EACd,IAAI,CAACuF,QAAQ,CAACV,MAAM,CAAC,EACrBnE,KAAK,CACN,CAAC;MACJ;MACA,OAAOxB,WAAC,CAAC2G,kBAAkB,CAAC,CAC1B,IAAI,CAACN,QAAQ,CAACV,MAAM,CAAC,EACrBnE,KAAK,EACLwD,aAAa,CAAC/G,IAAI,EAAEW,IAAI,CAAC,CAC1B,CAAC;IACJ;IAEA,IAAoCZ,UAAU,CAACC,IAAI,CAAC,EAAE;MACpD,OAAO+B,WAAC,CAAC2B,cAAc,CAAC1D,IAAI,CAAC2D,SAAS,CAAC,uBAAuB,CAAC,EAAE,CAC/D2E,OAAO,CAACxH,EAAE,CAAC,EACX,IAAI,CAACsH,QAAQ,CAACV,MAAM,CAAC,EACrBnE,KAAK,CACN,CAAC;IACJ;IAEA,OAAOxB,WAAC,CAAC2B,cAAc,CAAC1D,IAAI,CAAC2D,SAAS,CAAC,sBAAsB,CAAC,EAAE,CAC9D,IAAI,CAACyE,QAAQ,CAACV,MAAM,CAAC,EACrBY,OAAO,CAACxH,EAAE,CAAC,EACXyC,KAAK,CACN,CAAC;EACJ,CAAC,CAAC;EAEFsF,cAAcA,CAACnB,MAAM,EAAE;IACrB,MAAM;MACJb,QAAQ;MACRvG,eAAe;MACfN,IAAI;MACJsH;IACF,CAAC,GAAG,IAAI;IACR,MAAMe,WAAW,GAAGX,MAAM,CAAC9G,IAAI,CAAC6E,QAAyB;IACzD,MAAM;MAAE9E;IAAK,CAAC,GAAG0H,WAAW,CAACvH,EAAE;IAC/B,MAAM;MACJA,EAAE;MACFM,MAAM,EAAED,QAAQ;MAChBK,MAAM,EAAEP,QAAQ;MAChB4B;IACF,CAAC,GAAGvC,eAAe,CAACU,GAAG,CAACL,IAAI,CAAC;IAE7B,MAAM2H,OAAO,GAAIxH,EAAgB,IAC/BiB,WAAC,CAAC4F,QAAQ,CAAC5F,WAAC,CAACS,SAAS,CAAC1B,EAAE,CAAC,EAAEuH,WAAW,CAAC;IAE1C,IAAqC,CAACtI,UAAU,CAACC,IAAI,CAAC,EAAE;MACtD,IAAImB,QAAQ,EAAE;QACZ,IAAI;UAGF,IAAI2H,MAAM,GAAG9I,IAAI,CAAC2D,SAAS,CACzB,uCACF,CAAC;QACH,CAAC,CAAC,OAAAoF,OAAA,EAAM;UACN,MAAM,IAAIC,KAAK,CACb,0EAA0E,GACxE,qDACJ,CAAC;QACH;QACA,OAAOjH,WAAC,CAACwF,gBAAgB,CACvBxF,WAAC,CAAC2B,cAAc,CAACoF,MAAM,EAAE,CACvB,IAAI,CAACV,QAAQ,CAACV,MAAM,CAAC,EACrB3F,WAAC,CAACS,SAAS,CAACqE,QAAQ,CAAC,EACrByB,OAAO,CAACxH,EAAE,CAAC,CACZ,CAAC,EACFiB,WAAC,CAAC8B,UAAU,CAAC,OAAO,CACtB,CAAC;MACH;MAEA,OAAO9B,WAAC,CAACwF,gBAAgB,CACvBxF,WAAC,CAAC2B,cAAc,CAAC1D,IAAI,CAAC2D,SAAS,CAAC,iCAAiC,CAAC,EAAE,CAClE,IAAI,CAACyE,QAAQ,CAACV,MAAM,CAAC,EACrBY,OAAO,CAACxH,EAAE,CAAC,CACZ,CAAC,EACFiB,WAAC,CAAC8B,UAAU,CAAC,OAAO,CACtB,CAAC;IACH;IAEA,IAAI5C,QAAQ,IAAI,CAAC4B,KAAK,EAAE;MACtB,OAAOd,WAAC,CAACwF,gBAAgB,CACvBxF,WAAC,CAAC2G,kBAAkB,CAAC,CAEnBhB,MAAM,CAAC9G,IAAI,CAACoH,MAAM,EAClBjB,aAAa,CAAC/G,IAAI,EAAEW,IAAI,CAAC,CAC1B,CAAC,EACFoB,WAAC,CAAC8B,UAAU,CAAC,GAAG,CAClB,CAAC;IACH;IAEA,IAAI1C,QAAQ,IAAI,CAACF,QAAQ,EAAE;MACzB,MAAMgI,OAAO,GAAG,IAAI,CAACjI,GAAG,CAAC0G,MAAM,CAAC;MAChC,IACE,CAACJ,iCAAiC,IAClC,CAACvF,WAAC,CAACE,gBAAgB,CAACgH,OAAO,CAAC,EAC5B;QACA,OAAOA,OAAO;MAChB;MACA,MAAMC,GAAG,GAAGD,OAAO,CAAC9G,SAAS,CAACgH,GAAG,CAAC,CAAC;MACnCF,OAAO,CAAC9G,SAAS,CAAC+B,IAAI,CAACC,cAAQ,CAACvB,UAAU,CAACyB,GAAG,UAAU6E,GAAG,MAAM,CAAC;MAClE,OAAOnH,WAAC,CAACwF,gBAAgB,CACvBxF,WAAC,CAAC2B,cAAc,CAAC1D,IAAI,CAAC2D,SAAS,CAAC,UAAU,CAAC,EAAE,CAACsF,OAAO,CAAC,CAAC,EACvDlH,WAAC,CAAC8B,UAAU,CAAC,GAAG,CAClB,CAAC;IACH;IAEA,MAAMuF,OAAO,GAAG,IAAI,CAAC3H,GAAG,CAACiG,MAAM,EAAE3F,WAAC,CAAC8B,UAAU,CAAC,GAAG,CAAC,CAAC;IACnD,IACE,CAAC9B,WAAC,CAACE,gBAAgB,CAACmH,OAAO,CAAC,IAC5B,CAACrH,WAAC,CAACM,YAAY,CAAC+G,OAAO,CAACjH,SAAS,CAACiH,OAAO,CAACjH,SAAS,CAACL,MAAM,GAAG,CAAC,CAAC,EAAE;MAC/DnB,IAAI,EAAE;IACR,CAAC,CAAC,EACF;MACA,MAAM+G,MAAM,CAAC2B,mBAAmB,CAC9B,uEAAuE,GACrE,4DACJ,CAAC;IACH;IAIA,IAAIC,IAAoB;IACxB,IACEvH,WAAC,CAACyD,kBAAkB,CAAC4D,OAAO,CAAC9G,MAAM,EAAE;MAAEiH,QAAQ,EAAE;IAAM,CAAC,CAAC,IACzDxH,WAAC,CAACM,YAAY,CAAC+G,OAAO,CAAC9G,MAAM,CAACmD,QAAQ,CAAC,IACvC2D,OAAO,CAAC9G,MAAM,CAACmD,QAAQ,CAAC9E,IAAI,KAAK,MAAM,EACvC;MACA2I,IAAI,GAAG,CAELF,OAAO,CAAC9G,MAAM,CAAC0F,MAAM,EACrBjG,WAAC,CAACyH,eAAe,CAEdJ,OAAO,CAACjH,SAAS,CAAoBsH,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CACnD,CAAC,EACDL,OAAO,CAACjH,SAAS,CAAC,CAAC,CAAC,CACrB;IACH,CAAC,MAAM;MACLmH,IAAI,GAAG,CACLF,OAAO,CAAC9G,MAAM,EACdP,WAAC,CAACyH,eAAe,CAEdJ,OAAO,CAACjH,SAAS,CAAoBsH,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CACnD,CAAC,CACF;IACH;IAEA,OAAO1H,WAAC,CAACwF,gBAAgB,CACvBxF,WAAC,CAAC2B,cAAc,CAAC1D,IAAI,CAAC2D,SAAS,CAAC,UAAU,CAAC,EAAE2F,IAAI,CAAC,EAClDvH,WAAC,CAAC8B,UAAU,CAAC,GAAG,CAClB,CAAC;EACH,CAAC;EAED6F,IAAIA,CAAChC,MAAM,EAAE4B,IAAwC,EAAE;IAErD,IAAI,CAACxB,OAAO,CAACJ,MAAM,EAAE,CAAC,CAAC;IAEvB,OAAO,IAAAiC,qCAAY,EAAC,IAAI,CAAC3I,GAAG,CAAC0G,MAAM,CAAC,EAAE,IAAI,CAACU,QAAQ,CAACV,MAAM,CAAC,EAAE4B,IAAI,EAAE,KAAK,CAAC;EAC3E,CAAC;EAEDM,YAAYA,CAAClC,MAAM,EAAE4B,IAAwC,EAAE;IAC7D,IAAI,CAACxB,OAAO,CAACJ,MAAM,EAAE,CAAC,CAAC;IAEvB,OAAO,IAAAiC,qCAAY,EAAC,IAAI,CAAC3I,GAAG,CAAC0G,MAAM,CAAC,EAAE,IAAI,CAACU,QAAQ,CAACV,MAAM,CAAC,EAAE4B,IAAI,EAAE,IAAI,CAAC;EAC1E,CAAC;EAEDpE,MAAMA,CAAA,EAAG;IACP,MAAM,IAAI8D,KAAK,CACb,qEACF,CAAC;EACH;AACF,CAAC;AAEH,MAAMa,uBAAkD,GAAG;EACzD7I,GAAGA,CAAC0G,MAAM,EAAE;IACV,MAAM;MAAEpH,eAAe;MAAEN;IAAK,CAAC,GAAG,IAAI;IACtC,MAAM;MAAEgI;IAAO,CAAC,GAAGN,MAAM,CAAC9G,IAAI;IAC9B,MAAM;MAAED;IAAK,CAAC,GAAI+G,MAAM,CAAC9G,IAAI,CAAC6E,QAAQ,CAAmB3E,EAAE;IAE3D,OAAOqD,cAAQ,CAACvB,UAAU,uBAAuB,CAAC;MAChDkH,IAAI,EAAE9J,IAAI,CAAC2D,SAAS,CAAC,4BAA4B,CAAC;MAClDoG,GAAG,EAAEhI,WAAC,CAACS,SAAS,CAACwF,MAAM,CAAC;MACxBgC,IAAI,EAAEjI,WAAC,CAACS,SAAS,CAAClC,eAAe,CAACU,GAAG,CAACL,IAAI,CAAC,CAACG,EAAE;IAChD,CAAC,CAAC;EACJ,CAAC;EAEDW,GAAGA,CAAA,EAAG;IAEJ,MAAM,IAAIuH,KAAK,CAAC,yDAAyD,CAAC;EAC5E,CAAC;EAEDL,QAAQA,CAACjB,MAAM,EAAE;IACf,OAAO3F,WAAC,CAAC2B,cAAc,CACrB3B,WAAC,CAACwF,gBAAgB,CAAC,IAAI,CAACvG,GAAG,CAAC0G,MAAM,CAAC,EAAE3F,WAAC,CAAC8B,UAAU,CAAC,MAAM,CAAC,CAAC,EAE1D,CAAC9B,WAAC,CAACS,SAAS,CAACkF,MAAM,CAAC9G,IAAI,CAACoH,MAAsB,CAAC,CAClD,CAAC;EACH,CAAC;EAEDiC,SAASA,CAACvC,MAAM,EAAE;IAChB,OAAO,IAAI,CAAC1G,GAAG,CAAC0G,MAAM,CAAC;EACzB,CAAC;EAEDmB,cAAcA,CAACnB,MAAM,EAAE;IACrB,OAAO,IAAI,CAAC1G,GAAG,CAAC0G,MAAM,CAAC;EACzB,CAAC;EAEDgC,IAAIA,CAAChC,MAAM,EAAE4B,IAAI,EAAE;IACjB,OAAOvH,WAAC,CAAC2B,cAAc,CAAC,IAAI,CAAC1C,GAAG,CAAC0G,MAAM,CAAC,EAAE4B,IAAI,CAAC;EACjD,CAAC;EAEDM,YAAYA,CAAClC,MAAM,EAAE4B,IAAI,EAAE;IACzB,OAAOvH,WAAC,CAACmI,sBAAsB,CAAC,IAAI,CAAClJ,GAAG,CAAC0G,MAAM,CAAC,EAAE4B,IAAI,EAAE,IAAI,CAAC;EAC/D,CAAC;EAEDpE,MAAMA,CAAA,EAAG;IACP,MAAM,IAAI8D,KAAK,CACb,qEACF,CAAC;EACH;AACF,CAAC;AAEM,SAASmB,0BAA0BA,CACxCjB,GAAiB,EACjBnE,IAAuB,EACvBzE,eAAgC,EAChC;EACE2C,yBAAyB;EACzBqE,iCAAiC;EACjChC,aAAa;EACbQ;AAMF,CAAC,EACD3C,KAAW,EACX;EACA,IAAI,CAAC7C,eAAe,CAAC8J,IAAI,EAAE;EAE3B,MAAMxI,IAAI,GAAGmD,IAAI,CAAC/D,GAAG,CAAC,MAAM,CAAC;EAC7B,MAAMqJ,OAAO,GAAGpH,yBAAyB,GACrC4G,uBAAuB,GACvBhC,sBAAsB;EAE1B,IAAAyC,0CAA2B,EAAmB1I,IAAI,EAAEiD,kBAAkB,EAAAF,MAAA,CAAAC,MAAA;IACpEtE,eAAe;IACfuG,QAAQ,EAAEqC,GAAG;IACblJ,IAAI,EAAEmD;EAAK,GACRkH,OAAO;IACV/E,aAAa;IACbgC,iCAAiC;IACjCxB;EAAY,EACb,CAAC;EACFlE,IAAI,CAACuD,QAAQ,CAACoB,gBAAgB,EAAE;IAC9BjG,eAAe;IACfuG,QAAQ,EAAEqC,GAAG;IACblJ,IAAI,EAAEmD,KAAK;IACXF,yBAAyB;IACzB6C;EACF,CAAC,CAAC;AACJ;AAEA,SAASyE,0BAA0BA,CACjCrB,GAAiB,EACjBzI,IAAsC,EACtCH,eAAgC,EAChC;EACA,MAAM;IAAEQ;EAAG,CAAC,GAAGR,eAAe,CAACU,GAAG,CAACP,IAAI,CAACG,IAAI,CAACC,GAAG,CAACC,EAAE,CAACH,IAAI,CAAC;EACzD,MAAM4C,KAAK,GAAG9C,IAAI,CAACG,IAAI,CAAC2C,KAAK,IAAI9C,IAAI,CAACa,KAAK,CAAC6F,kBAAkB,CAAC,CAAC;EAEhE,OAAOqD,mBAAmB,CACxBrG,cAAQ,CAACC,SAAS,CAACC,GAAG;AAC1B,8BAA8B6E,GAAG,KAAKnH,WAAC,CAACS,SAAS,CAAC1B,EAAE,CAAC;AACrD;AACA;AACA;AACA,iBAAiByC,KAAK;AACtB;AACA,KAAK,EACD9C,IACF,CAAC;AACH;AAEA,SAASgK,iCAAiCA,CACxCvB,GAAiB,EACjBzI,IAAsC,EACtCH,eAAgC,EAChC6C,KAAW,EACX;EACA,MAAM;IAAErC;EAAG,CAAC,GAAGR,eAAe,CAACU,GAAG,CAACP,IAAI,CAACG,IAAI,CAACC,GAAG,CAACC,EAAE,CAACH,IAAI,CAAC;EACzD,MAAM4C,KAAK,GAAG9C,IAAI,CAACG,IAAI,CAAC2C,KAAK,IAAI9C,IAAI,CAACa,KAAK,CAAC6F,kBAAkB,CAAC,CAAC;EAE7B;IACjC,IAAI,CAAChE,KAAK,CAAClD,eAAe,CAAC,2BAA2B,CAAC,EAAE;MACvD,OAAOuK,mBAAmB,CACxBrG,cAAQ,CAACC,SAAS,CAACC,GAAG,GAAGtC,WAAC,CAACS,SAAS,CAAC1B,EAAE,CAAC,QAAQoI,GAAG;AAC3D;AACA;AACA;AACA,mBAAmB3F,KAAK;AACxB,WAAW,EACH9C,IACF,CAAC;IACH;EACF;EAEA,MAAMqI,MAAM,GAAG3F,KAAK,CAACQ,SAAS,CAAC,2BAA2B,CAAC;EAC3D,OAAO+G,UAAU,CACfF,mBAAmB,CACjBzI,WAAC,CAAC4I,mBAAmB,CACnB5I,WAAC,CAAC2B,cAAc,CAACoF,MAAM,EAAE,CACvB/G,WAAC,CAAC6I,cAAc,CAAC,CAAC,EAClBF,UAAU,CAAC3I,WAAC,CAACS,SAAS,CAAC1B,EAAE,CAAC,EAAEL,IAAI,CAACG,IAAI,CAACC,GAAG,CAAC,EACVd,UAAU,CAACoD,KAAK,CAAC,GAC7CI,KAAK,GACLY,cAAQ,CAACvB,UAAU,CAACyB,GAAG,4BAA4Bd,KAAK,IAAI,CACjE,CACH,CAAC,EACD9C,IACF,CAAC,EACDA,IAAI,CAACG,IACP,CAAC;AACH;AAEA,SAASiK,+BAA+BA,CACtCpK,IAAsC,EACtCH,eAAgC,EAChCgH,iCAA0C,EAC1C;EACA,MAAMe,WAAW,GAAG/H,eAAe,CAACU,GAAG,CAACP,IAAI,CAACG,IAAI,CAACC,GAAG,CAACC,EAAE,CAACH,IAAI,CAAC;EAE9D,MAAM4C,KAAK,GAAG+D,iCAAiC,GAC3C7G,IAAI,CAACG,IAAI,CAAC2C,KAAK,GACfY,cAAQ,CAACvB,UAAU,CAACyB,GAAG;AAC7B,aAAa5D,IAAI,CAACG,IAAI,CAAC2C,KAAK,IAAIxB,WAAC,CAACoF,kBAAkB,CAAC,CAAC;AACtD,QAAQ;EAEN,OAAOqD,mBAAmB,CACxBzI,WAAC,CAAC+I,mBAAmB,CAAC,KAAK,EAAE,CAC3B/I,WAAC,CAACgJ,kBAAkB,CAAChJ,WAAC,CAACS,SAAS,CAAC6F,WAAW,CAACvH,EAAE,CAAC,EAAEyC,KAAK,CAAC,CACzD,CAAC,EACF9C,IACF,CAAC;AACH;AAEmC;EAEjC,IAAIuK,kCAAkC,GAAG,SAAAA,CACvCvK,IAAsC,EACtCH,eAAgC,EAChC;IACA,MAAM+H,WAAW,GAAG/H,eAAe,CAACU,GAAG,CAACP,IAAI,CAACG,IAAI,CAACC,GAAG,CAACC,EAAE,CAACH,IAAI,CAAC;IAC9D,MAAM;MAAEG,EAAE;MAAEyB,KAAK;MAAEM,KAAK;MAAExB;IAAU,CAAC,GAAGgH,WAAW;IACnD,MAAM7E,gBAAgB,GAAGjB,KAAK,IAAIM,KAAK;IAEvC,IAAI,CAACpC,IAAI,CAACS,UAAU,CAAC,CAAC,KAAKG,SAAS,IAAI,CAACmC,gBAAgB,CAAC,EAAE;IAE5D,IAAIA,gBAAgB,EAAE;MACpBlD,eAAe,CAACmB,GAAG,CAAChB,IAAI,CAACG,IAAI,CAACC,GAAG,CAACC,EAAE,CAACH,IAAI,EAAAgE,MAAA,CAAAC,MAAA,KACpCyD,WAAW;QACdhH,SAAS,EAAE;MAAI,EAChB,CAAC;MAEF,OAAOmJ,mBAAmB,CACxBrG,cAAQ,CAACC,SAAS,CAACC,GAAG;AAC9B,gBAAgBtC,WAAC,CAACS,SAAS,CAAC1B,EAAE,CAAC;AAC/B;AACA;AACA;AACA,mBAAmByB,KAAK,GAAGA,KAAK,CAAC5B,IAAI,GAAGF,IAAI,CAACa,KAAK,CAAC6F,kBAAkB,CAAC,CAAC;AACvE,mBAAmBtE,KAAK,GAAGA,KAAK,CAAClC,IAAI,GAAGF,IAAI,CAACa,KAAK,CAAC6F,kBAAkB,CAAC,CAAC;AACvE;AACA,SAAS,EACD1G,IACF,CAAC;IACH;IAEA,MAAM8C,KAAK,GAAG9C,IAAI,CAACG,IAAI,CAAC2C,KAAK,IAAI9C,IAAI,CAACa,KAAK,CAAC6F,kBAAkB,CAAC,CAAC;IAChE,OAAOqD,mBAAmB,CACxBrG,cAAQ,CAACC,SAAS,CAACC,GAAG;AAC5B,cAActC,WAAC,CAACS,SAAS,CAAC1B,EAAE,CAAC;AAC7B;AACA;AACA;AACA,mBAAmByC,KAAK;AACxB;AACA,OAAO,EACD9C,IACF,CAAC;EACH,CAAC;AACH;AAEA,SAASwK,2BAA2BA,CAClC/B,GAAiB,EACjBzI,IAAoC,EACpCH,eAAgC,EAChC;EACA,MAAM+H,WAAW,GAAG/H,eAAe,CAACU,GAAG,CAACP,IAAI,CAACG,IAAI,CAACC,GAAG,CAACC,EAAE,CAACH,IAAI,CAAC;EAC9D,MAAM;IAAEoC,QAAQ;IAAEjC,EAAE;IAAEyB,KAAK;IAAEM,KAAK;IAAExB;EAAU,CAAC,GAAGgH,WAAW;EAC7D,IAAIhH,SAAS,EAAE;EAEf,IAAI0B,QAAQ,EAAE;IACZ,OAAOyH,mBAAmB,CACxBrG,cAAQ,CAACC,SAAS,CAACC,GAAG;AAC5B,gCAAgC6E,GAAG,KAAKpI,EAAE;AAC1C;AACA;AACA;AACA,mBAAmBiC,QAAQ,CAACpC,IAAI;AAChC;AACA,OAAO,EACDF,IACF,CAAC;EACH;EACA,MAAM+C,gBAAgB,GAAGjB,KAAK,IAAIM,KAAK;EACvC,IAAIW,gBAAgB,EAAE;IACpBlD,eAAe,CAACmB,GAAG,CAAChB,IAAI,CAACG,IAAI,CAACC,GAAG,CAACC,EAAE,CAACH,IAAI,EAAAgE,MAAA,CAAAC,MAAA,KACpCyD,WAAW;MACdhH,SAAS,EAAE;IAAI,EAChB,CAAC;IAEF,OAAOmJ,mBAAmB,CACxBrG,cAAQ,CAACC,SAAS,CAACC,GAAG;AAC5B,gCAAgC6E,GAAG,KAAKpI,EAAE;AAC1C;AACA;AACA;AACA,iBAAiByB,KAAK,GAAGA,KAAK,CAAC5B,IAAI,GAAGF,IAAI,CAACa,KAAK,CAAC6F,kBAAkB,CAAC,CAAC;AACrE,iBAAiBtE,KAAK,GAAGA,KAAK,CAAClC,IAAI,GAAGF,IAAI,CAACa,KAAK,CAAC6F,kBAAkB,CAAC,CAAC;AACrE;AACA,OAAO,EACD1G,IACF,CAAC;EACH;AACF;AAEA,SAASyK,kCAAkCA,CACzChC,GAAiB,EACjBzI,IAAoC,EACpCH,eAAgC,EAChC6C,KAAW,EACX;EACA,MAAMkF,WAAW,GAAG/H,eAAe,CAACU,GAAG,CAACP,IAAI,CAACG,IAAI,CAACC,GAAG,CAACC,EAAE,CAACH,IAAI,CAAC;EAE9D,IAAI0H,WAAW,CAAChH,SAAS,EAAE;EAE3B,IAAqC,CAACtB,UAAU,CAACoD,KAAK,CAAC,EAAE;IACvD,MAAMK,gBAAgB,GAAG6E,WAAW,CAAC9F,KAAK,IAAI8F,WAAW,CAACxF,KAAK;IAC/D,IAAIW,gBAAgB,EAAE;MACpB,OAAO2H,kCAAkC,CACvCjC,GAAG,EACHzI,IAAI,EACJH,eAAe,EACf6C,KACF,CAAC;IACH;EACF;EAEA,OAAOiI,wCAAwC,CAC7ClC,GAAG,EACHzI,IAAI,EACJH,eAAe,EACf6C,KACF,CAAC;AACH;AAEA,SAASgI,kCAAkCA,CACzCjC,GAAiB,EACjBzI,IAAoC,EACpCH,eAAgC,EAChC6C,KAAW,EACX;EACA,MAAMkF,WAAW,GAAG/H,eAAe,CAACU,GAAG,CAACP,IAAI,CAACG,IAAI,CAACC,GAAG,CAACC,EAAE,CAACH,IAAI,CAAC;EAC9D,MAAM;IAAEG,EAAE;IAAEyB,KAAK;IAAEM;EAAM,CAAC,GAAGwF,WAAW;EAExC/H,eAAe,CAACmB,GAAG,CAAChB,IAAI,CAACG,IAAI,CAACC,GAAG,CAACC,EAAE,CAACH,IAAI,EAAAgE,MAAA,CAAAC,MAAA,KACpCyD,WAAW;IACdhH,SAAS,EAAE;EAAI,EAChB,CAAC;EAEiC;IACjC,IAAI,CAAC8B,KAAK,CAAClD,eAAe,CAAC,2BAA2B,CAAC,EAAE;MACvD,OAAOuK,mBAAmB,CACxBrG,cAAQ,CAACC,SAAS,CAACC,GAAG;AAC9B,YAAYvD,EAAE,QAAQoI,GAAG;AACzB,mBAAmB3G,KAAK,GAAGA,KAAK,CAAC5B,IAAI,GAAGF,IAAI,CAACa,KAAK,CAAC6F,kBAAkB,CAAC,CAAC;AACvE,mBAAmBtE,KAAK,GAAGA,KAAK,CAAClC,IAAI,GAAGF,IAAI,CAACa,KAAK,CAAC6F,kBAAkB,CAAC,CAAC;AACvE;AACA,SAAS,EACD1G,IACF,CAAC;IACH;EACF;EAEA,MAAMqI,MAAM,GAAG3F,KAAK,CAACQ,SAAS,CAAC,2BAA2B,CAAC;EAC3D,OAAO+G,UAAU,CACfF,mBAAmB,CACjBrG,cAAQ,CAACC,SAAS,CAACC,GAAG,GAAGyE,MAAM;AACrC,QAAQ/G,WAAC,CAAC6I,cAAc,CAAC,CAAC;AAC1B,QAAQ7I,WAAC,CAACS,SAAS,CAAC1B,EAAE,CAAC;AACvB;AACA,eAAeyB,KAAK,GAAGA,KAAK,CAAC5B,IAAI,GAAGF,IAAI,CAACa,KAAK,CAAC6F,kBAAkB,CAAC,CAAC;AACnE,eAAetE,KAAK,GAAGA,KAAK,CAAClC,IAAI,GAAGF,IAAI,CAACa,KAAK,CAAC6F,kBAAkB,CAAC,CAAC;AACnE;AACA,MAAM,EACA1G,IACF,CAAC,EACDA,IAAI,CAACG,IACP,CAAC;AACH;AAEA,SAASwK,wCAAwCA,CAC/ClC,GAAiB,EACjBzI,IAAoC,EACpCH,eAAgC,EAChC6C,KAAW,EACX;EACA,MAAMkF,WAAW,GAAG/H,eAAe,CAACU,GAAG,CAACP,IAAI,CAACG,IAAI,CAACC,GAAG,CAACC,EAAE,CAACH,IAAI,CAAC;EAC9D,MAAM;IAAEG;EAAG,CAAC,GAAGuH,WAAW;EAES;IACjC,IAAI,CAAClF,KAAK,CAAClD,eAAe,CAAC,4BAA4B,CAAC,EAAE;MACxD,OAAOuK,mBAAmB,CACxBrG,cAAQ,CAACC,SAAS,CAACC,GAAG,GAAGvD,EAAE,QAAQoI,GAAG,GAAG,EACzCzI,IACF,CAAC;IACH;EACF;EAEA,MAAMqI,MAAM,GAAG3F,KAAK,CAACQ,SAAS,CAAC,4BAA4B,CAAC;EAC5D,OAAO6G,mBAAmB,CACxBrG,cAAQ,CAACC,SAAS,CAACC,GAAG,GAAGyE,MAAM;AACnC,QAAQ/G,WAAC,CAAC6I,cAAc,CAAC,CAAC;AAC1B,QAAQ7I,WAAC,CAACS,SAAS,CAAC1B,EAAE,CAAC;AACvB,MAAM,EACFL,IACF,CAAC;AACH;AAEA,SAAS4K,yBAAyBA,CAChCnC,GAAiB,EACjBzI,IAA+B,EAC/B;EACA,MAAM;IAAEI,GAAG;IAAE0I;EAAS,CAAC,GAAG9I,IAAI,CAACG,IAAI;EACnC,MAAM2C,KAAK,GAAG9C,IAAI,CAACG,IAAI,CAAC2C,KAAK,IAAI9C,IAAI,CAACa,KAAK,CAAC6F,kBAAkB,CAAC,CAAC;EAEhE,OAAOqD,mBAAmB,CACxBzI,WAAC,CAAC4I,mBAAmB,CACnB5I,WAAC,CAAC6G,oBAAoB,CACpB,GAAG,EACH7G,WAAC,CAACwF,gBAAgB,CAAC2B,GAAG,EAAErI,GAAG,EAAE0I,QAAQ,IAAIxH,WAAC,CAACuJ,SAAS,CAACzK,GAAG,CAAC,CAAC,EAC1D0C,KACF,CACF,CAAC,EACD9C,IACF,CAAC;AACH;AAEA,SAAS8K,wBAAwBA,CAC/BrC,GAAiB,EACjBzI,IAA+B,EAC/B0C,KAAW,EACX;EACA,MAAM;IAAEtC,GAAG;IAAE0I;EAAS,CAAC,GAAG9I,IAAI,CAACG,IAAI;EACnC,MAAM2C,KAAK,GAAG9C,IAAI,CAACG,IAAI,CAAC2C,KAAK,IAAI9C,IAAI,CAACa,KAAK,CAAC6F,kBAAkB,CAAC,CAAC;EAEhE,OAAOqD,mBAAmB,CACxBzI,WAAC,CAAC4I,mBAAmB,CACnB5I,WAAC,CAAC2B,cAAc,CAACP,KAAK,CAACQ,SAAS,CAAC,gBAAgB,CAAC,EAAE,CAClDuF,GAAG,EACHK,QAAQ,IAAIxH,WAAC,CAACuJ,SAAS,CAACzK,GAAG,CAAC,GACxBA,GAAG,GACHkB,WAAC,CAAC6B,aAAa,CAAE/C,GAAG,CAAkBF,IAAI,CAAC,EAC/C4C,KAAK,CACN,CACH,CAAC,EACD9C,IACF,CAAC;AACH;AAEA,SAAS+K,iCAAiCA,CACxCtC,GAAiB,EACjBzI,IAAoC,EACpC0C,KAAW,EACX7C,eAAgC,EAChC;EACA,MAAM+H,WAAW,GAAG/H,eAAe,CAACU,GAAG,CAACP,IAAI,CAACG,IAAI,CAACC,GAAG,CAACC,EAAE,CAACH,IAAI,CAAC;EAC9D,MAAM;IAAEG,EAAE;IAAEiC,QAAQ;IAAER,KAAK;IAAEM,KAAK;IAAExB;EAAU,CAAC,GAAGgH,WAAW;EAE7D,IAAIhH,SAAS,EAAE;EAEf,MAAMmC,gBAAgB,GAAGjB,KAAK,IAAIM,KAAK;EACvC,IAAIW,gBAAgB,EAAE;IACpBlD,eAAe,CAACmB,GAAG,CAAChB,IAAI,CAACG,IAAI,CAACC,GAAG,CAACC,EAAE,CAACH,IAAI,EAAAgE,MAAA,CAAAC,MAAA,KACpCyD,WAAW;MACdhH,SAAS,EAAE;IAAI,EAChB,CAAC;IAEF,OAAOmJ,mBAAmB,CACxBrG,cAAQ,CAACC,SAAS,CAACC,GAAG;AAC5B,gCAAgC6E,GAAG,KAAKpI,EAAE;AAC1C;AACA;AACA;AACA,iBAAiByB,KAAK,GAAGA,KAAK,CAAC5B,IAAI,GAAGF,IAAI,CAACa,KAAK,CAAC6F,kBAAkB,CAAC,CAAC;AACrE,iBAAiBtE,KAAK,GAAGA,KAAK,CAAClC,IAAI,GAAGF,IAAI,CAACa,KAAK,CAAC6F,kBAAkB,CAAC,CAAC;AACrE;AACA,OAAO,EACD1G,IACF,CAAC;EACH;EAEA,OAAO+J,mBAAmB,CACxBrG,cAAQ,CAACC,SAAS,CAACC,GAAG;AAC1B,8BAA8B6E,GAAG,KAAKpI,EAAE;AACxC;AACA;AACA;AACA,iBAAiBiC,QAAQ,CAACpC,IAAI;AAC9B;AACA,KAAK,EACDF,IACF,CAAC;AACH;AAEA,SAASgL,6BAA6BA,CACpCzL,IAAU,EACVS,IAAoC,EACpCH,eAAgC,EAChCF,kCAAkC,GAAG,KAAK,EAC1C;EACA,MAAMiI,WAAW,GAAG/H,eAAe,CAACU,GAAG,CAACP,IAAI,CAACG,IAAI,CAACC,GAAG,CAACC,EAAE,CAACH,IAAI,CAAC;EAC9D,MAAM;IACJG,EAAE;IACFiC,QAAQ;IACRR,KAAK;IACLM,KAAK;IACLJ,cAAc;IACdK,cAAc;IACd1B,MAAM,EAAED;EACV,CAAC,GAAGkH,WAAW;EACf,MAAM;IAAE3F,MAAM;IAAEd,IAAI;IAAE8J,SAAS;IAAEC;EAAM,CAAC,GAAGlL,IAAI,CAACG,IAAI;EACpD,MAAMgL,QAAQ,GAAGrJ,KAAK,IAAIG,MAAM,CAACZ,MAAM,KAAK,CAAC;EAC7C,MAAM+J,QAAQ,GAAGhJ,KAAK,IAAIH,MAAM,CAACZ,MAAM,GAAG,CAAC;EAE3C,IAAK8J,QAAQ,IAAInJ,cAAc,IAAMoJ,QAAQ,IAAI/I,cAAe,EAAE;IAChExC,eAAe,CAACmB,GAAG,CAAChB,IAAI,CAACG,IAAI,CAACC,GAAG,CAACC,EAAE,CAACH,IAAI,EAAAgE,MAAA,CAAAC,MAAA,KACpCyD,WAAW;MACdhH,SAAS,EAAE;IAAI,EAChB,CAAC;IACF,OAAO,IAAI;EACb;EAEA,IACmCtB,UAAU,CAACC,IAAI,CAAC,KAChD4L,QAAQ,IAAIC,QAAQ,KACrB,CAACzL,kCAAkC,EACnC;IACA,MAAMkB,KAAK,GAAGb,IAAI,CAACO,GAAG,CAAC,MAAM,CAAC,CAACM,KAAK;IACpC,MAAMwK,OAAO,GAAGxK,KAAK,CAACC,qBAAqB,CAAC,MAAM,CAAC;IACnD,MAAM4B,KAAuB,GAAG;MAC9B4I,OAAO,EAAED,OAAO;MAChBE,aAAa,EAAE;IACjB,CAAC;IAEDvL,IAAI,CAAC0E,QAAQ,CAAC8G,kBAAkB,EAAE9I,KAAK,CAAC;IACxC,IAAIA,KAAK,CAAC6I,aAAa,CAAClK,MAAM,EAAE;MAC9B,MAAMoK,WAAW,GAAG5K,KAAK,CAACC,qBAAqB,CAAC,WAAW,CAAC;MAC5DD,KAAK,CAAC4C,IAAI,CAAC;QACTpD,EAAE,EAAEoL,WAAW;QACfzI,IAAI,EAAEU,cAAQ,CAACvB,UAAU,CAACyB,GAAG;MAC/B,CAAC,CAAC;MACF,KAAK,MAAMU,IAAI,IAAI5B,KAAK,CAAC6I,aAAa,EAAE;QACtCjH,IAAI,CAAC+B,WAAW,CAAC/E,WAAC,CAACS,SAAS,CAAC0J,WAAW,CAAC,CAAC;MAC5C;IACF;IAEAxJ,MAAM,CAACyJ,OAAO,CAACpK,WAAC,CAACS,SAAS,CAACsJ,OAAO,CAAC,CAAC;EACtC;EAEA,IAAIM,MAAM,GAAGrJ,QAAQ;EAErB,IAAI6I,QAAQ,EAAE;IACZtL,eAAe,CAACmB,GAAG,CAAChB,IAAI,CAACG,IAAI,CAACC,GAAG,CAACC,EAAE,CAACH,IAAI,EAAAgE,MAAA,CAAAC,MAAA,KACpCyD,WAAW;MACd5F,cAAc,EAAE,IAAI;MACpBpB,SAAS,EAAE;IAAI,EAChB,CAAC;IACF+K,MAAM,GAAG7J,KAAK;EAChB,CAAC,MAAM,IAAIsJ,QAAQ,EAAE;IACnBvL,eAAe,CAACmB,GAAG,CAAChB,IAAI,CAACG,IAAI,CAACC,GAAG,CAACC,EAAE,CAACH,IAAI,EAAAgE,MAAA,CAAAC,MAAA,KACpCyD,WAAW;MACdvF,cAAc,EAAE,IAAI;MACpBzB,SAAS,EAAE;IAAI,EAChB,CAAC;IACF+K,MAAM,GAAGvJ,KAAK;EAChB,CAAC,MAAM,IAAI1B,QAAQ,IAAI,CAACf,kCAAkC,EAAE;IAC1DgM,MAAM,GAAGtL,EAAE;EACb;EAEA,OAAO0J,mBAAmB,CACxBzI,WAAC,CAACsK,mBAAmB,CACnBtK,WAAC,CAACS,SAAS,CAAC4J,MAAM,CAAC,EAEnB1J,MAAM,EACNd,IAAI,EACJ8J,SAAS,EACTC,KACF,CAAC,EACDlL,IACF,CAAC;AACH;AAWA,MAAMwL,kBAAkB,GAAGxH,kBAAQ,CAACC,kBAAkB,CAAmB;EACvE4H,UAAUA,CAACvH,IAAI,EAAE5B,KAAK,EAAE;IACtB,IAAIA,KAAK,CAAC6I,aAAa,IAAIjH,IAAI,CAACnE,IAAI,CAACD,IAAI,KAAK,WAAW,EAAE;MACzDwC,KAAK,CAAC6I,aAAa,CAAC9H,IAAI,CAACa,IAAI,CAAC;IAChC;EACF,CAAC;EACDwH,eAAeA,CAACxH,IAAI,EAAE;IAEpB,MAAM;MAAEnE;IAAK,CAAC,GAAGmE,IAAI;IACrB,IAAInE,IAAI,CAAC6F,QAAQ,KAAK,QAAQ,EAAE;MAC9B,MAAMvE,QAAQ,GAAG,IAAAsK,wEAA+B,EAAC5L,IAAI,CAACsB,QAAQ,CAAC;MAC/D,IAAIH,WAAC,CAACK,gBAAgB,CAACF,QAAQ,CAAC,EAAE;QAChC6C,IAAI,CAAC+B,WAAW,CAAC/E,WAAC,CAAC0K,cAAc,CAAC,IAAI,CAAC,CAAC;MAC1C;IACF;EACF,CAAC;EACDC,cAAcA,CAAC3H,IAAI,EAAE5B,KAAK,EAAE;IAC1BA,KAAK,CAACwJ,aAAa,GAAG,IAAI;IAC1B5H,IAAI,CAAC+B,WAAW,CAAC/E,WAAC,CAACS,SAAS,CAACW,KAAK,CAAC4I,OAAO,CAAC,CAAC;EAC9C,CAAC;EACDa,YAAYA,CAAC7H,IAAI,EAAE;IACjB,MAAM;MAAEnE,IAAI;MAAEU;IAAM,CAAC,GAAGyD,IAAI;IAG5B,IAAInE,IAAI,CAACiM,IAAI,CAAClM,IAAI,KAAK,KAAK,IAAIC,IAAI,CAAC6E,QAAQ,CAAC9E,IAAI,KAAK,QAAQ,EAAE;MAC/DoE,IAAI,CAAC+B,WAAW,CAACxF,KAAK,CAAC6F,kBAAkB,CAAC,CAAC,CAAC;IAC9C;EACF;AACF,CAAC,CAAC;AAEF,MAAM2F,sBAAkE,GAAG;EACzEC,oBAAoBA,CAAChI,IAAI,EAAE5B,KAAK,EAAE;IAChC,IACE4B,IAAI,CAACzD,KAAK,CAAC2E,uBAAuB,CAAClB,IAAI,CAACnE,IAAI,CAACD,IAAI,EAAEwC,KAAK,CAAC2C,YAAY,CAAC,EACtE;MACA3C,KAAK,CAACwJ,aAAa,GAAG,IAAI;MAC1B5H,IAAI,CAACnE,IAAI,CAACD,IAAI,GAAGwC,KAAK,CAAC4I,OAAO,CAACpL,IAAI;IACrC;EACF;AACF,CAAC;AAED,SAASqM,kBAAkBA,CACzBjI,IAAc,EACdmE,GAAiB,EACjB+D,eAAoC,EACpC;EAAA,IAAAC,cAAA;EACA,MAAM/J,KAAuB,GAAG;IAC9B4I,OAAO,EAAE7C,GAAG;IACZyD,aAAa,EAAE,KAAK;IACpB7G,YAAY,EAAEmH;EAChB,CAAC;EACD,IAAI,CAAClI,IAAI,CAAC9D,QAAQ,CAAC,CAAC,EAAE;IAEpB8D,IAAI,CAACI,QAAQ,CAAC8G,kBAAkB,EAAE9I,KAAK,CAAC;EAC1C;EAGA,IACE8J,eAAe,IAAI,IAAI,KAAAC,cAAA,GACvB/J,KAAK,CAAC4I,OAAO,aAAbmB,cAAA,CAAevM,IAAI,IACnBwC,KAAK,CAAC4I,OAAO,CAACpL,IAAI,KAAKsM,eAAe,CAACtM,IAAI,EAC3C;IACAoE,IAAI,CAACI,QAAQ,CAAC2H,sBAAsB,EAAE3J,KAAK,CAAC;EAC9C;EAEA,OAAOA,KAAK,CAACwJ,aAAa;AAC5B;AASA,SAASQ,cAAcA,CAAC;EAAEtM,GAAG;EAAE0I;AAA0B,CAAC,EAAE;EAC1D,IAAI1I,GAAG,CAACuM,IAAI,KAAK,YAAY,EAAE;IAC7B,OAAO,CAAC7D,QAAQ,KAAK1I,GAAG,CAACF,IAAI,KAAK,MAAM,IAAIE,GAAG,CAACF,IAAI,KAAK,QAAQ,CAAC;EACpE;EACA,IAAIE,GAAG,CAACuM,IAAI,KAAK,eAAe,EAAE;IAChC,OAAOvM,GAAG,CAAC0C,KAAK,KAAK,MAAM,IAAI1C,GAAG,CAAC0C,KAAK,KAAK,QAAQ;EACvD;EACA,OAAO,KAAK;AACd;AAaA,SAASiH,mBAAmBA,CAAmB5J,IAAO,EAAEH,IAAc,EAAE;EACtEsB,WAAC,CAACsL,sBAAsB,CAACzM,IAAI,EAAEH,IAAI,CAACG,IAAI,CAAC;EACzCmB,WAAC,CAACuL,oBAAoB,CAAC1M,IAAI,EAAEH,IAAI,CAACG,IAAI,CAAC;EACvC,OAAOA,IAAI;AACb;AAEA,SAAS8J,UAAUA,CAAmB9J,IAAO,EAAE2M,QAAgB,EAAE;EAC/D3M,IAAI,CAAC4M,KAAK,GAAGD,QAAQ,CAACC,KAAK;EAC3B5M,IAAI,CAAC6M,GAAG,GAAGF,QAAQ,CAACE,GAAG;EACvB7M,IAAI,CAAC8M,GAAG,GAAGH,QAAQ,CAACG,GAAG;EACvB,OAAO9M,IAAI;AACb;AAyBO,SAAS+M,oBAAoBA,CAClCzE,GAAwB,EACxB0E,QAAkC,EAClCvN,KAAiB,EACjBC,eAAgC,EAChCN,IAAU,EACV6N,oBAA6B,EAC7BzN,kCAA2C,EAC3CkH,iCAA0C,EAC1CwG,aAAsB,EACtBb,eAAoC,EACpC;EACA,IAAIc,aAAa,IAAoB;EACrC,IAAIC,cAA4B;EAChC,MAAMC,WAA0B,GAAG,EAAE;EACrC,MAAMC,aAAsC,GAAG,EAAE;EACjD,IAAIC,2BAA2B,GAAG,KAAK;EAEvC,MAAMC,eAAwC,GAAG,EAAE;EACnD,IAAIC,gBAA8C,GAAG,IAAI;EAEzD,MAAMC,WAAW,GAAGvM,WAAC,CAACM,YAAY,CAACuL,QAAQ,CAAC,GACxC,MAAMA,QAAQ,GACd,MAAM;IACJI,cAAc,WAAdA,cAAc,GAAdA,cAAc,GACZ3N,KAAK,CAAC,CAAC,CAAC,CAACiB,KAAK,CAACiN,gCAAgC,CAACX,QAAQ,CAAC;IAC3D,OAAOI,cAAc;EACvB,CAAC;EAEL,MAAMQ,uBAAuB,GAC3BtF,GAAG,WAAHA,GAAG,GACH7I,KAAK,CAAC,CAAC,CAAC,CAACiB,KAAK,CAACC,qBAAqB,CAAC,CAAA0L,eAAe,oBAAfA,eAAe,CAAEtM,IAAI,KAAI,OAAO,CAAC;EACxEuI,GAAG,WAAHA,GAAG,GAAHA,GAAG,GAAKnH,WAAC,CAACS,SAAS,CAACyK,eAAe,CAAC;EAEpC,KAAK,MAAMxM,IAAI,IAAIJ,KAAK,EAAE;IACxB,IAAII,IAAI,CAACgO,eAAe,CAAC,CAAC,EAAE;MAC1B3O,EAAE,CAAC4O,sBAAsB,CAACjO,IAAI,CAAC;IACjC;IAGA,MAAMU,QAAQ,GAAG,EAACY,WAAC,CAAC4M,aAAa,YAAf5M,WAAC,CAAC4M,aAAa,CAAGlO,IAAI,CAACG,IAAI,CAAC,KAAIH,IAAI,CAACG,IAAI,CAACQ,MAAM;IAClE,MAAMwN,UAAU,GAAG,CAACzN,QAAQ;IAC5B,MAAMT,SAAS,GAAGD,IAAI,CAACC,SAAS,CAAC,CAAC;IAClC,MAAMmO,QAAQ,GAAG,CAACnO,SAAS;IAC3B,MAAMoO,OAAO,GAAGrO,IAAI,CAACS,UAAU,CAAC,CAAC;IACjC,MAAMD,QAAQ,GAAG,CAAC6N,OAAO;IACzB,MAAMH,aAAa,GAAGlO,IAAI,CAACkO,aAAa,oBAAlBlO,IAAI,CAACkO,aAAa,CAAG,CAAC;IAE5C,IAAIxN,QAAQ,EAAE4M,aAAa,KAA0B;IAErD,IAAI5M,QAAQ,IAAKF,QAAQ,IAAIP,SAAU,IAAIiO,aAAa,EAAE;MACxD,IAAII,4BAAa,CAAC;QAChBC,UAAU,EAAEvO,IAAI;QAChBqN,aAAa;QACb9N,IAAI,EAAEA,IAAI;QACViP,aAAa,EAAEhC,eAAe;QAC9BqB,WAAW;QACXY,YAAYA,CAAA,EAAG;UACbnB,aAAa,KAAgC;UAC7C,IAAI5M,QAAQ,IAAIwN,aAAa,EAAE;YAC7B,OAAOH,uBAAuB;UAChC,CAAC,MAAM;YACL,OAAOzM,WAAC,CAACwF,gBAAgB,CACvBiH,uBAAuB,EACvBzM,WAAC,CAAC8B,UAAU,CAAC,WAAW,CAC1B,CAAC;UACH;QACF;MACF,CAAC,CAAC,CAACsL,OAAO,CAAC,CAAC;MAEZ,MAAMC,QAAQ,GAAGpC,kBAAkB,CACjCvM,IAAI,EACJ+N,uBAAuB,EACvBvB,eACF,CAAC;MACD,IAAImC,QAAQ,EAAE;QACZrB,aAAa,KAAgC;MAC/C;IACF;IAEAI,2BAA2B,GAAG,KAAK;IAOnC,QAAQ,IAAI;MACV,KAAKQ,aAAa;QAAE;UAClB,MAAMU,SAAS,GAAG5O,IAAI,CAACG,IAAI,CAACgB,IAAI;UAGhC,IAAIyN,SAAS,CAACvN,MAAM,KAAK,CAAC,IAAIC,WAAC,CAACY,qBAAqB,CAAC0M,SAAS,CAAC,CAAC,CAAC,CAAC,EAAE;YACnEpB,WAAW,CAAC/J,IAAI,CAACsG,mBAAmB,CAAC6E,SAAS,CAAC,CAAC,CAAC,EAAE5O,IAAI,CAAC,CAAC;UAC3D,CAAC,MAAM;YACLwN,WAAW,CAAC/J,IAAI,CACdnC,WAAC,CAACuN,gBAAgB,CAChBnL,cAAQ,CAACC,SAAS,CAACC,GAAG,YAAYgL,SAAS,OAAO,EAClD5O,IAAI,CAACG,IACP,CACF,CAAC;UACH;UACA;QACF;MACA,KAAKO,QAAQ,IACXT,SAAS,IACToO,OAAO,IACP1O,kCAAkC;QAClC6N,WAAW,CAAC/J,IAAI,CACdqG,0BAA0B,CAACxI,WAAC,CAACS,SAAS,CAAC0G,GAAG,CAAC,EAAEzI,IAAI,EAAEH,eAAe,CACpE,CAAC;QACD;MACF,KAAKa,QAAQ,IACXT,SAAS,IACToO,OAAO,IACP,CAAC1O,kCAAkC;QACnC,IAAqC,CAACL,UAAU,CAACC,IAAI,CAAC,EAAE;UACtDiO,WAAW,CAAC/J,IAAI,CACd8G,kCAAkC,CAACvK,IAAI,EAAEH,eAAe,CAC1D,CAAC;QACH,CAAC,MAAM;UACL2N,WAAW,CAAC/J,IAAI,CACd2G,+BAA+B,CAC7BpK,IAAI,EACJH,eAAe,EACfgH,iCACF,CACF,CAAC;QACH;QACA;MACF,KAAKnG,QAAQ,IAAI0N,QAAQ,IAAIC,OAAO,IAAIjB,oBAAoB;QAM1D,IAAI,CAACV,cAAc,CAAC1M,IAAI,CAACG,IAAI,CAAC,EAAE;UAC9BqN,WAAW,CAAC/J,IAAI,CAACmH,yBAAyB,CAACtJ,WAAC,CAACS,SAAS,CAAC0G,GAAG,CAAC,EAAEzI,IAAI,CAAC,CAAC;UACnE;QACF;MAEF,KAAKU,QAAQ,IAAI0N,QAAQ,IAAIC,OAAO,IAAI,CAACjB,oBAAoB;QAC3DI,WAAW,CAAC/J,IAAI,CACdqH,wBAAwB,CAACxJ,WAAC,CAACS,SAAS,CAAC0G,GAAG,CAAC,EAAEzI,IAAI,EAAET,IAAI,CACvD,CAAC;QACD;MACF,KAAK4O,UAAU,IACblO,SAAS,IACToO,OAAO,IACP1O,kCAAkC;QAClC8N,aAAa,CAAChK,IAAI,CAChBqG,0BAA0B,CAACxI,WAAC,CAAC6I,cAAc,CAAC,CAAC,EAAEnK,IAAI,EAAEH,eAAe,CACtE,CAAC;QACD;MACF,KAAKsO,UAAU,IACblO,SAAS,IACToO,OAAO,IACP,CAAC1O,kCAAkC;QACnC8N,aAAa,CAAChK,IAAI,CAChBuG,iCAAiC,CAC/B1I,WAAC,CAAC6I,cAAc,CAAC,CAAC,EAClBnK,IAAI,EACJH,eAAe,EACfN,IACF,CACF,CAAC;QACD;MACF,KAAK4O,UAAU,IACblO,SAAS,IACTO,QAAQ,IACRb,kCAAkC;QAClC8N,aAAa,CAAC/B,OAAO,CACnBlB,2BAA2B,CACzBlJ,WAAC,CAAC6I,cAAc,CAAC,CAAC,EAClBnK,IAAI,EACJH,eACF,CACF,CAAC;QACD8N,eAAe,CAAClK,IAAI,CAClBuH,6BAA6B,CAC3BzL,IAAI,EACJS,IAAI,EACJH,eAAe,EACfF,kCACF,CACF,CAAC;QACD;MACF,KAAKwO,UAAU,IACblO,SAAS,IACTO,QAAQ,IACR,CAACb,kCAAkC;QACnC8N,aAAa,CAAC/B,OAAO,CACnBjB,kCAAkC,CAChCnJ,WAAC,CAAC6I,cAAc,CAAC,CAAC,EAClBnK,IAAI,EACJH,eAAe,EACfN,IACF,CACF,CAAC;QACDoO,eAAe,CAAClK,IAAI,CAClBuH,6BAA6B,CAC3BzL,IAAI,EACJS,IAAI,EACJH,eAAe,EACfF,kCACF,CACF,CAAC;QACD;MACF,KAAKe,QAAQ,IACXT,SAAS,IACTO,QAAQ,IACR,CAACb,kCAAkC;QACnC,IAAqC,CAACL,UAAU,CAACC,IAAI,CAAC,EAAE;UACtDiO,WAAW,CAAC9B,OAAO,CAEjBnB,kCAAkC,CAACvK,IAAI,EAAEH,eAAe,CAC1D,CAAC;QACH;QACA8N,eAAe,CAAClK,IAAI,CAClBuH,6BAA6B,CAC3BzL,IAAI,EACJS,IAAI,EACJH,eAAe,EACfF,kCACF,CACF,CAAC;QACD;MACF,KAAKe,QAAQ,IACXT,SAAS,IACTO,QAAQ,IACRb,kCAAkC;QAClC6N,WAAW,CAAC9B,OAAO,CACjBX,iCAAiC,CAC/BzJ,WAAC,CAACS,SAAS,CAAC0G,GAAG,CAAC,EAChBzI,IAAI,EACJT,IAAI,EACJM,eACF,CACF,CAAC;QACD8N,eAAe,CAAClK,IAAI,CAClBuH,6BAA6B,CAC3BzL,IAAI,EACJS,IAAI,EACJH,eAAe,EACfF,kCACF,CACF,CAAC;QACD;MACF,KAAKwO,UAAU,IAAIC,QAAQ,IAAIC,OAAO,IAAIjB,oBAAoB;QAC5DK,aAAa,CAAChK,IAAI,CAACmH,yBAAyB,CAACtJ,WAAC,CAAC6I,cAAc,CAAC,CAAC,EAAEnK,IAAI,CAAC,CAAC;QACvE;MACF,KAAKmO,UAAU,IAAIC,QAAQ,IAAIC,OAAO,IAAI,CAACjB,oBAAoB;QAC7DM,2BAA2B,GAAG,IAAI;QAClCD,aAAa,CAAChK,IAAI,CAChBqH,wBAAwB,CAACxJ,WAAC,CAAC6I,cAAc,CAAC,CAAC,EAAEnK,IAAI,EAAET,IAAI,CACzD,CAAC;QACD;MACF;QACE,MAAM,IAAIgJ,KAAK,CAAC,cAAc,CAAC;IACnC;EACF;EAEA,IAAI+E,aAAa,IAA+B,IAAId,eAAe,IAAI,IAAI,EAAE;IAC3EoB,gBAAgB,GAAGtM,WAAC,CAAC4I,mBAAmB,CACtC5I,WAAC,CAAC6G,oBAAoB,CACpB,GAAG,EACH7G,WAAC,CAACS,SAAS,CAACgM,uBAAuB,CAAC,EACpCzM,WAAC,CAACS,SAAS,CAACyK,eAAe,CAC7B,CACF,CAAC;EACH;EAEA,OAAO;IACLgB,WAAW,EAAEA,WAAW,CAACsB,MAAM,CAACC,OAAO,CAAC;IACxCtB,aAAa,EAAEA,aAAa,CAACqB,MAAM,CAACC,OAAO,CAAC;IAC5CrB,2BAA2B;IAC3BC,eAAe,EAAEA,eAAe,CAACmB,MAAM,CAACC,OAAO,CAAC;IAChDnB,gBAAgB;IAChBoB,SAASA,CAAC1K,IAAuB,EAAE;MACjC,KAAK,MAAMtE,IAAI,IAAIJ,KAAK,EAAE;QAMxBI,IAAI,CAACG,IAAI,CAAC8O,eAAe,GAAG,IAAI;QAChCjP,IAAI,CAACkP,MAAM,CAAC,CAAC;MACf;MAEA,IAAI3B,cAAc,EAAE;QAClBjJ,IAAI,CAACzD,KAAK,CAAC4C,IAAI,CAAC;UAAEpD,EAAE,EAAEiB,WAAC,CAACS,SAAS,CAACwL,cAAc;QAAE,CAAC,CAAC;QACpDjJ,IAAI,CAACtD,GAAG,CACN,YAAY,EACZM,WAAC,CAAC6G,oBAAoB,CAAC,GAAG,EAAEoF,cAAc,EAAEjJ,IAAI,CAACnE,IAAI,CAACgP,UAAU,CAClE,CAAC;MACH;MAEA,IAAI7B,aAAa,MAAsB,EAAE;QACvC,IAAIhJ,IAAI,CAAC8K,iBAAiB,CAAC,CAAC,EAAE;UAC5B9K,IAAI,CAACzD,KAAK,CAAC4C,IAAI,CAAC;YAAEpD,EAAE,EAAEoI;UAAI,CAAC,CAAC;UAC5BnE,IAAI,CAAC+B,WAAW,CACd/E,WAAC,CAAC6G,oBAAoB,CAAC,GAAG,EAAE7G,WAAC,CAACS,SAAS,CAAC0G,GAAG,CAAC,EAAEnE,IAAI,CAACnE,IAAI,CACzD,CAAC;QACH,CAAC,MAAM;UACL,IAAIqM,eAAe,IAAI,IAAI,EAAE;YAE3BlI,IAAI,CAACnE,IAAI,CAACE,EAAE,GAAGoI,GAAG;UACpB;UACA,IAAImF,gBAAgB,IAAI,IAAI,EAAE;YAC5BtJ,IAAI,CAACzD,KAAK,CAAC4C,IAAI,CAAC;cAAEpD,EAAE,EAAE0N;YAAwB,CAAC,CAAC;UAClD;QACF;MACF;MAEA,OAAOzJ,IAAI;IACb;EACF,CAAC;AACH&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[]}</span></pre>
</body>
</html>