<html>
<head>
<title>generate-patched-file.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
generate-patched-file.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;generate-patched-file.js&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceRoot&quot;</span><span class="s0">:</span><span class="s1">&quot;&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../src/eslint-bulk-suppressions/generate-patched-file.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.</span><span class="s3">\n</span><span class="s1">// See LICENSE in the project root for license information.</span><span class="s3">\n\n</span><span class="s1">import fs from 'fs';</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">ESLINT_BULK_FORCE_REGENERATE_PATCH_ENV_VAR_NAME,</span><span class="s3">\n  </span><span class="s1">ESLINT_BULK_PATCH_PATH_ENV_VAR_NAME</span><span class="s3">\n</span><span class="s1">} from './constants';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Dynamically generate file to properly patch many versions of ESLint</span><span class="s3">\n </span><span class="s1">* @param inputFilePath - Must be an iteration of https://github.com/eslint/eslint/blob/main/lib/linter/linter.js</span><span class="s3">\n </span><span class="s1">* @param outputFilePath - Some small changes to linter.js</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function generatePatchedLinterJsFileIfDoesNotExist(</span><span class="s3">\n  </span><span class="s1">inputFilePath: string,</span><span class="s3">\n  </span><span class="s1">outputFilePath: string</span><span class="s3">\n</span><span class="s1">): void {</span><span class="s3">\n  </span><span class="s1">const generateEnvVarValue: string | undefined =</span><span class="s3">\n    </span><span class="s1">process.env[ESLINT_BULK_FORCE_REGENERATE_PATCH_ENV_VAR_NAME];</span><span class="s3">\n  </span><span class="s1">if (generateEnvVarValue !== 'true' &amp;&amp; generateEnvVarValue !== '1' &amp;&amp; fs.existsSync(outputFilePath)) {</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const inputFile: string = fs.readFileSync(inputFilePath).toString();</span><span class="s3">\n\n  </span><span class="s1">let inputIndex: number = 0;</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Extract from the stream until marker is reached.  When matching marker,</span><span class="s3">\n   </span><span class="s1">* ignore whitespace in the stream and in the marker.  Return the extracted text.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">function scanUntilMarker(marker: string): string {</span><span class="s3">\n    </span><span class="s1">const trimmedMarker: string = marker.replace(/</span><span class="s3">\\</span><span class="s1">s/g, '');</span><span class="s3">\n\n    </span><span class="s1">let output: string = '';</span><span class="s3">\n    </span><span class="s1">let trimmed: string = '';</span><span class="s3">\n\n    </span><span class="s1">while (inputIndex &lt; inputFile.length) {</span><span class="s3">\n      </span><span class="s1">const char: string = inputFile[inputIndex++];</span><span class="s3">\n      </span><span class="s1">output += char;</span><span class="s3">\n      </span><span class="s1">if (!/^</span><span class="s3">\\</span><span class="s1">s$/.test(char)) {</span><span class="s3">\n        </span><span class="s1">trimmed += char;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (trimmed.endsWith(trimmedMarker)) {</span><span class="s3">\n        </span><span class="s1">return output;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">throw new Error('Unexpected end of input while looking for ' + JSON.stringify(marker));</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function scanUntilNewline(): string {</span><span class="s3">\n    </span><span class="s1">let output: string = '';</span><span class="s3">\n\n    </span><span class="s1">while (inputIndex &lt; inputFile.length) {</span><span class="s3">\n      </span><span class="s1">const char: string = inputFile[inputIndex++];</span><span class="s3">\n      </span><span class="s1">output += char;</span><span class="s3">\n      </span><span class="s1">if (char === '</span><span class="s3">\\</span><span class="s1">n') {</span><span class="s3">\n        </span><span class="s1">return output;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">throw new Error('Unexpected end of input while looking for new line');</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function scanUntilEnd(): string {</span><span class="s3">\n    </span><span class="s1">const output: string = inputFile.substring(inputIndex);</span><span class="s3">\n    </span><span class="s1">inputIndex = inputFile.length;</span><span class="s3">\n    </span><span class="s1">return output;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Returns index of next public method</span><span class="s3">\n   </span><span class="s1">* @param fromIndex - index of inputFile to search if public method still exists</span><span class="s3">\n   </span><span class="s1">* @returns -1 if public method does not exist or index of next public method</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">function getIndexOfNextPublicMethod(fromIndex: number): number {</span><span class="s3">\n    </span><span class="s1">const rest: string = inputFile.substring(fromIndex);</span><span class="s3">\n\n    </span><span class="s1">const endOfClassIndex: number = rest.indexOf('</span><span class="s3">\\</span><span class="s1">n}');</span><span class="s3">\n\n    </span><span class="s1">const markerForStartOfClassMethod: string = '</span><span class="s3">\\</span><span class="s1">n     */</span><span class="s3">\\</span><span class="s1">n    ';</span><span class="s3">\n\n    </span><span class="s1">const startOfClassMethodIndex: number = rest.indexOf(markerForStartOfClassMethod);</span><span class="s3">\n\n    </span><span class="s1">if (startOfClassMethodIndex === -1 || startOfClassMethodIndex &gt; endOfClassIndex) {</span><span class="s3">\n      </span><span class="s1">return -1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const afterMarkerIndex: number =</span><span class="s3">\n      </span><span class="s1">rest.indexOf(markerForStartOfClassMethod) + markerForStartOfClassMethod.length;</span><span class="s3">\n\n    </span><span class="s1">const isPublicMethod: boolean =</span><span class="s3">\n      </span><span class="s1">rest[afterMarkerIndex] !== '_' &amp;&amp;</span><span class="s3">\n      </span><span class="s1">rest[afterMarkerIndex] !== '#' &amp;&amp;</span><span class="s3">\n      </span><span class="s1">!rest.substring(afterMarkerIndex, rest.indexOf('</span><span class="s3">\\</span><span class="s1">n', afterMarkerIndex)).includes('static') &amp;&amp;</span><span class="s3">\n      </span><span class="s1">!rest.substring(afterMarkerIndex, rest.indexOf('</span><span class="s3">\\</span><span class="s1">n', afterMarkerIndex)).includes('constructor');</span><span class="s3">\n\n    </span><span class="s1">if (isPublicMethod) {</span><span class="s3">\n      </span><span class="s1">return fromIndex + afterMarkerIndex;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return getIndexOfNextPublicMethod(fromIndex + afterMarkerIndex);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function scanUntilIndex(indexToScanTo: number): string {</span><span class="s3">\n    </span><span class="s1">const output: string = inputFile.substring(inputIndex, indexToScanTo);</span><span class="s3">\n    </span><span class="s1">inputIndex = indexToScanTo;</span><span class="s3">\n    </span><span class="s1">return output;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let outputFile: string = '';</span><span class="s3">\n\n  </span><span class="s1">// Match this:</span><span class="s3">\n  </span><span class="s1">//    //------------------------------------------------------------------------------</span><span class="s3">\n  </span><span class="s1">//    // Requirements</span><span class="s3">\n  </span><span class="s1">//    //------------------------------------------------------------------------------</span><span class="s3">\n  </span><span class="s1">outputFile += scanUntilMarker('// Requirements');</span><span class="s3">\n  </span><span class="s1">outputFile += scanUntilMarker('//--');</span><span class="s3">\n  </span><span class="s1">outputFile += scanUntilNewline();</span><span class="s3">\n\n  </span><span class="s1">outputFile += `</span><span class="s3">\n</span><span class="s1">// --- BEGIN MONKEY PATCH ---</span><span class="s3">\n</span><span class="s1">const bulkSuppressionsPatch = require(process.env.${ESLINT_BULK_PATCH_PATH_ENV_VAR_NAME});</span><span class="s3">\n</span><span class="s1">const requireFromPathToLinterJS = bulkSuppressionsPatch.requireFromPathToLinterJS;</span><span class="s3">\n</span><span class="s1">`;</span><span class="s3">\n\n  </span><span class="s1">// Match this:</span><span class="s3">\n  </span><span class="s1">//    //------------------------------------------------------------------------------</span><span class="s3">\n  </span><span class="s1">//    // Typedefs</span><span class="s3">\n  </span><span class="s1">//    //------------------------------------------------------------------------------</span><span class="s3">\n  </span><span class="s1">const requireSection: string = scanUntilMarker('// Typedefs');</span><span class="s3">\n\n  </span><span class="s1">// Match something like this:</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">//    const path = require('path'),</span><span class="s3">\n  </span><span class="s1">//    eslintScope = require('eslint-scope'),</span><span class="s3">\n  </span><span class="s1">//    evk = require('eslint-visitor-keys'),</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// Convert to something like this:</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">//    const path = require('path'),</span><span class="s3">\n  </span><span class="s1">//    eslintScope = requireFromPathToLinterJS('eslint-scope'),</span><span class="s3">\n  </span><span class="s1">//    evk = requireFromPathToLinterJS('eslint-visitor-keys'),</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">outputFile += requireSection.replace(/require</span><span class="s3">\\</span><span class="s1">s*</span><span class="s3">\\</span><span class="s1">((?:'([^']+)'|</span><span class="s3">\&quot;</span><span class="s1">([^</span><span class="s3">\&quot;</span><span class="s1">]+)</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\\</span><span class="s1">)/g, (match, p1, p2) =&gt; {</span><span class="s3">\n    </span><span class="s1">const importPath: string = p1 ?? p2 ?? '';</span><span class="s3">\n\n    </span><span class="s1">if (importPath !== 'path') {</span><span class="s3">\n      </span><span class="s1">if (p1) {</span><span class="s3">\n        </span><span class="s1">return `requireFromPathToLinterJS('${p1}')`;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (p2) {</span><span class="s3">\n        </span><span class="s1">return `requireFromPathToLinterJS(</span><span class="s3">\&quot;</span><span class="s1">${p2}</span><span class="s3">\&quot;</span><span class="s1">)`;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Keep as-is</span><span class="s3">\n    </span><span class="s1">return match;</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">outputFile += `--- END MONKEY PATCH ---</span><span class="s3">\n</span><span class="s1">`;</span><span class="s3">\n\n  </span><span class="s1">// Match this:</span><span class="s3">\n  </span><span class="s1">// ```</span><span class="s3">\n  </span><span class="s1">//      if (reportTranslator === null) {</span><span class="s3">\n  </span><span class="s1">//        reportTranslator = createReportTranslator({</span><span class="s3">\n  </span><span class="s1">//            ruleId,</span><span class="s3">\n  </span><span class="s1">//            severity,</span><span class="s3">\n  </span><span class="s1">//            sourceCode,</span><span class="s3">\n  </span><span class="s1">//            messageIds,</span><span class="s3">\n  </span><span class="s1">//            disableFixes</span><span class="s3">\n  </span><span class="s1">//        });</span><span class="s3">\n  </span><span class="s1">//    }</span><span class="s3">\n  </span><span class="s1">//    const problem = reportTranslator(...args);</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">//    if (problem.fix &amp;&amp; !(rule.meta &amp;&amp; rule.meta.fixable)) {</span><span class="s3">\n  </span><span class="s1">//        throw new Error(</span><span class="s3">\&quot;</span><span class="s1">Fixable rules must set the `meta.fixable` property to </span><span class="s3">\\\&quot;</span><span class="s1">code</span><span class="s3">\\\&quot; </span><span class="s1">or </span><span class="s3">\\\&quot;</span><span class="s1">whitespace</span><span class="s3">\\\&quot;</span><span class="s1">.</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">//    }</span><span class="s3">\n  </span><span class="s1">// ```</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// Convert to something like this:</span><span class="s3">\n  </span><span class="s1">// ```</span><span class="s3">\n  </span><span class="s1">//      if (reportTranslator === null) {</span><span class="s3">\n  </span><span class="s1">//        reportTranslator = createReportTranslator({</span><span class="s3">\n  </span><span class="s1">//            ruleId,</span><span class="s3">\n  </span><span class="s1">//            severity,</span><span class="s3">\n  </span><span class="s1">//            sourceCode,</span><span class="s3">\n  </span><span class="s1">//            messageIds,</span><span class="s3">\n  </span><span class="s1">//            disableFixes</span><span class="s3">\n  </span><span class="s1">//        });</span><span class="s3">\n  </span><span class="s1">//    }</span><span class="s3">\n  </span><span class="s1">//    const problem = reportTranslator(...args);</span><span class="s3">\n  </span><span class="s1">//    // --- BEGIN MONKEY PATCH ---</span><span class="s3">\n  </span><span class="s1">//    if (bulkSuppressionsPatch.shouldBulkSuppress({ filename, currentNode, ruleId })) return;</span><span class="s3">\n  </span><span class="s1">//    // --- END MONKEY PATCH ---</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">//    if (problem.fix &amp;&amp; !(rule.meta &amp;&amp; rule.meta.fixable)) {</span><span class="s3">\n  </span><span class="s1">//        throw new Error(</span><span class="s3">\&quot;</span><span class="s1">Fixable rules must set the `meta.fixable` property to </span><span class="s3">\\\&quot;</span><span class="s1">code</span><span class="s3">\\\&quot; </span><span class="s1">or </span><span class="s3">\\\&quot;</span><span class="s1">whitespace</span><span class="s3">\\\&quot;</span><span class="s1">.</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">//    }</span><span class="s3">\n  </span><span class="s1">// ```</span><span class="s3">\n  </span><span class="s1">outputFile += scanUntilMarker('const problem = reportTranslator(...args);');</span><span class="s3">\n  </span><span class="s1">outputFile += `</span><span class="s3">\n                        </span><span class="s1">// --- BEGIN MONKEY PATCH ---</span><span class="s3">\n                        </span><span class="s1">if (bulkSuppressionsPatch.shouldBulkSuppress({ filename, currentNode, ruleId, problem })) return;</span><span class="s3">\n                        </span><span class="s1">// --- END MONKEY PATCH ---</span><span class="s3">\n</span><span class="s1">`;</span><span class="s3">\n\n  </span><span class="s1">outputFile += scanUntilMarker('nodeQueue.forEach(traversalInfo =&gt; {');</span><span class="s3">\n  </span><span class="s1">outputFile += scanUntilMarker('});');</span><span class="s3">\n  </span><span class="s1">outputFile += scanUntilNewline();</span><span class="s3">\n  </span><span class="s1">outputFile += scanUntilMarker('class Linter {');</span><span class="s3">\n  </span><span class="s1">outputFile += scanUntilNewline();</span><span class="s3">\n  </span><span class="s1">outputFile += `</span><span class="s3">\n    </span><span class="s1">// --- BEGIN MONKEY PATCH ---</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* We intercept ESLint execution at the .eslintrc.js file, but unfortunately the Linter class is</span><span class="s3">\n     </span><span class="s1">* initialized before the .eslintrc.js file is executed. This means the internalSlotsMap that all</span><span class="s3">\n     </span><span class="s1">* the patched methods refer to is not initialized. This method checks if the internalSlotsMap is</span><span class="s3">\n     </span><span class="s1">* initialized, and if not, initializes it.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">_conditionallyReinitialize({ cwd, configType } = {}) {</span><span class="s3">\n        </span><span class="s1">if (internalSlotsMap.get(this) === undefined) {</span><span class="s3">\n            </span><span class="s1">internalSlotsMap.set(this, {</span><span class="s3">\n              </span><span class="s1">cwd: normalizeCwd(cwd),</span><span class="s3">\n              </span><span class="s1">lastConfigArray: null,</span><span class="s3">\n              </span><span class="s1">lastSourceCode: null,</span><span class="s3">\n              </span><span class="s1">lastSuppressedMessages: [],</span><span class="s3">\n              </span><span class="s1">configType, // TODO: Remove after flat config conversion</span><span class="s3">\n              </span><span class="s1">parserMap: new Map([['espree', espree]]),</span><span class="s3">\n              </span><span class="s1">ruleMap: new Rules()</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n\n            </span><span class="s1">this.version = pkg.version;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// --- END MONKEY PATCH ---</span><span class="s3">\n</span><span class="s1">`;</span><span class="s3">\n\n  </span><span class="s1">let indexOfNextPublicMethod: number = getIndexOfNextPublicMethod(inputIndex);</span><span class="s3">\n  </span><span class="s1">while (indexOfNextPublicMethod !== -1) {</span><span class="s3">\n    </span><span class="s1">outputFile += scanUntilIndex(indexOfNextPublicMethod);</span><span class="s3">\n    </span><span class="s1">outputFile += scanUntilNewline();</span><span class="s3">\n    </span><span class="s1">outputFile += `        // --- BEGIN MONKEY PATCH ---</span><span class="s3">\n        </span><span class="s1">this._conditionallyReinitialize();</span><span class="s3">\n        </span><span class="s1">// --- END MONKEY PATCH ---</span><span class="s3">\n</span><span class="s1">`;</span><span class="s3">\n    </span><span class="s1">indexOfNextPublicMethod = getIndexOfNextPublicMethod(inputIndex);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">outputFile += scanUntilEnd();</span><span class="s3">\n\n  </span><span class="s1">fs.writeFileSync(outputFilePath, outputFile);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">]}</span></pre>
</body>
</html>