<html>
<head>
<title>immer.umd.development.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #cf8e6d;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #7a7e85;}
.s5 { color: #5f826b; font-style: italic;}
.s6 { color: #2aacb8;}
.s7 { color: #67a37c; font-style: italic;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
immer.umd.development.js</font>
</center></td></tr></table>
<pre><span class="s0">(</span><span class="s1">function </span><span class="s0">(</span><span class="s2">global</span><span class="s0">, </span><span class="s2">factory</span><span class="s0">) {</span>
	<span class="s1">typeof </span><span class="s2">exports </span><span class="s0">=== </span><span class="s3">'object' </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s2">module </span><span class="s0">!== </span><span class="s3">'undefined' </span><span class="s0">? </span><span class="s2">factory</span><span class="s0">(</span><span class="s2">exports</span><span class="s0">) :</span>
	<span class="s1">typeof </span><span class="s2">define </span><span class="s0">=== </span><span class="s3">'function' </span><span class="s0">&amp;&amp; </span><span class="s2">define</span><span class="s0">.</span><span class="s2">amd </span><span class="s0">? </span><span class="s2">define</span><span class="s0">([</span><span class="s3">'exports'</span><span class="s0">], </span><span class="s2">factory</span><span class="s0">) :</span>
	<span class="s0">(</span><span class="s2">global </span><span class="s0">= </span><span class="s2">global </span><span class="s0">|| </span><span class="s2">self</span><span class="s0">, </span><span class="s2">factory</span><span class="s0">(</span><span class="s2">global</span><span class="s0">.</span><span class="s2">immer </span><span class="s0">= {}));</span>
<span class="s0">}(</span><span class="s1">this</span><span class="s0">, (</span><span class="s1">function </span><span class="s0">(</span><span class="s2">exports</span><span class="s0">) { </span><span class="s3">'use strict'</span><span class="s0">;</span>

	<span class="s1">var </span><span class="s2">_ref</span><span class="s0">;</span>

	<span class="s4">// Should be no imports here!</span>
	<span class="s4">// Some things that should be evaluated before all else...</span>
	<span class="s4">// We only want to know if non-polyfilled symbols are available</span>
	<span class="s1">var </span><span class="s2">hasSymbol </span><span class="s0">= </span><span class="s1">typeof </span><span class="s2">Symbol </span><span class="s0">!== </span><span class="s3">&quot;undefined&quot; </span><span class="s0">&amp;&amp; </span><span class="s1">typeof</span>
	<span class="s4">/*#__PURE__*/</span>
	<span class="s2">Symbol</span><span class="s0">(</span><span class="s3">&quot;x&quot;</span><span class="s0">) === </span><span class="s3">&quot;symbol&quot;</span><span class="s0">;</span>
	<span class="s1">var </span><span class="s2">hasMap </span><span class="s0">= </span><span class="s1">typeof </span><span class="s2">Map </span><span class="s0">!== </span><span class="s3">&quot;undefined&quot;</span><span class="s0">;</span>
	<span class="s1">var </span><span class="s2">hasSet </span><span class="s0">= </span><span class="s1">typeof </span><span class="s2">Set </span><span class="s0">!== </span><span class="s3">&quot;undefined&quot;</span><span class="s0">;</span>
	<span class="s1">var </span><span class="s2">hasProxies </span><span class="s0">= </span><span class="s1">typeof </span><span class="s2">Proxy </span><span class="s0">!== </span><span class="s3">&quot;undefined&quot; </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s2">Proxy</span><span class="s0">.</span><span class="s2">revocable </span><span class="s0">!== </span><span class="s3">&quot;undefined&quot; </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s2">Reflect </span><span class="s0">!== </span><span class="s3">&quot;undefined&quot;</span><span class="s0">;</span>
	<span class="s5">/**</span>
	 <span class="s5">* The sentinel value returned by producers to replace the draft with undefined.</span>
	 <span class="s5">*/</span>

	<span class="s1">var </span><span class="s2">NOTHING </span><span class="s0">= </span><span class="s2">hasSymbol </span><span class="s0">?</span>
	<span class="s4">/*#__PURE__*/</span>
	<span class="s2">Symbol</span><span class="s0">.</span><span class="s2">for</span><span class="s0">(</span><span class="s3">&quot;immer-nothing&quot;</span><span class="s0">) : (</span><span class="s2">_ref </span><span class="s0">= {}, </span><span class="s2">_ref</span><span class="s0">[</span><span class="s3">&quot;immer-nothing&quot;</span><span class="s0">] = </span><span class="s1">true</span><span class="s0">, </span><span class="s2">_ref</span><span class="s0">);</span>
	<span class="s5">/**</span>
	 <span class="s5">* To let Immer treat your class instances as plain immutable objects</span>
	 <span class="s5">* (albeit with a custom prototype), you must define either an instance property</span>
	 <span class="s5">* or a static property on each of your custom classes.</span>
	 <span class="s5">*</span>
	 <span class="s5">* Otherwise, your class instance will never be drafted, which means it won't be</span>
	 <span class="s5">* safe to mutate in a produce callback.</span>
	 <span class="s5">*/</span>

	<span class="s1">var </span><span class="s2">DRAFTABLE </span><span class="s0">= </span><span class="s2">hasSymbol </span><span class="s0">?</span>
	<span class="s4">/*#__PURE__*/</span>
	<span class="s2">Symbol</span><span class="s0">.</span><span class="s2">for</span><span class="s0">(</span><span class="s3">&quot;immer-draftable&quot;</span><span class="s0">) : </span><span class="s3">&quot;__$immer_draftable&quot;</span><span class="s0">;</span>
	<span class="s1">var </span><span class="s2">DRAFT_STATE </span><span class="s0">= </span><span class="s2">hasSymbol </span><span class="s0">?</span>
	<span class="s4">/*#__PURE__*/</span>
	<span class="s2">Symbol</span><span class="s0">.</span><span class="s2">for</span><span class="s0">(</span><span class="s3">&quot;immer-state&quot;</span><span class="s0">) : </span><span class="s3">&quot;__$immer_state&quot;</span><span class="s0">; </span><span class="s4">// Even a polyfilled Symbol might provide Symbol.iterator</span>

	<span class="s1">var </span><span class="s2">iteratorSymbol </span><span class="s0">= </span><span class="s1">typeof </span><span class="s2">Symbol </span><span class="s0">!= </span><span class="s3">&quot;undefined&quot; </span><span class="s0">&amp;&amp; </span><span class="s2">Symbol</span><span class="s0">.</span><span class="s2">iterator </span><span class="s0">|| </span><span class="s3">&quot;@@iterator&quot;</span><span class="s0">;</span>

	<span class="s1">var </span><span class="s2">errors </span><span class="s0">= {</span>
	  <span class="s6">0</span><span class="s0">: </span><span class="s3">&quot;Illegal state&quot;</span><span class="s0">,</span>
	  <span class="s6">1</span><span class="s0">: </span><span class="s3">&quot;Immer drafts cannot have computed properties&quot;</span><span class="s0">,</span>
	  <span class="s6">2</span><span class="s0">: </span><span class="s3">&quot;This object has been frozen and should not be mutated&quot;</span><span class="s0">,</span>
	  <span class="s6">3</span><span class="s0">: </span><span class="s1">function </span><span class="s2">_</span><span class="s0">(</span><span class="s2">data</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s3">&quot;Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? &quot; </span><span class="s0">+ </span><span class="s2">data</span><span class="s0">;</span>
	  <span class="s0">},</span>
	  <span class="s6">4</span><span class="s0">: </span><span class="s3">&quot;An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.&quot;</span><span class="s0">,</span>
	  <span class="s6">5</span><span class="s0">: </span><span class="s3">&quot;Immer forbids circular references&quot;</span><span class="s0">,</span>
	  <span class="s6">6</span><span class="s0">: </span><span class="s3">&quot;The first or second argument to `produce` must be a function&quot;</span><span class="s0">,</span>
	  <span class="s6">7</span><span class="s0">: </span><span class="s3">&quot;The third argument to `produce` must be a function or undefined&quot;</span><span class="s0">,</span>
	  <span class="s6">8</span><span class="s0">: </span><span class="s3">&quot;First argument to `createDraft` must be a plain object, an array, or an immerable object&quot;</span><span class="s0">,</span>
	  <span class="s6">9</span><span class="s0">: </span><span class="s3">&quot;First argument to `finishDraft` must be a draft returned by `createDraft`&quot;</span><span class="s0">,</span>
	  <span class="s6">10</span><span class="s0">: </span><span class="s3">&quot;The given draft is already finalized&quot;</span><span class="s0">,</span>
	  <span class="s6">11</span><span class="s0">: </span><span class="s3">&quot;Object.defineProperty() cannot be used on an Immer draft&quot;</span><span class="s0">,</span>
	  <span class="s6">12</span><span class="s0">: </span><span class="s3">&quot;Object.setPrototypeOf() cannot be used on an Immer draft&quot;</span><span class="s0">,</span>
	  <span class="s6">13</span><span class="s0">: </span><span class="s3">&quot;Immer only supports deleting array indices&quot;</span><span class="s0">,</span>
	  <span class="s6">14</span><span class="s0">: </span><span class="s3">&quot;Immer only supports setting array indices and the 'length' property&quot;</span><span class="s0">,</span>
	  <span class="s6">15</span><span class="s0">: </span><span class="s1">function </span><span class="s2">_</span><span class="s0">(</span><span class="s2">path</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s3">&quot;Cannot apply patch, path doesn't resolve: &quot; </span><span class="s0">+ </span><span class="s2">path</span><span class="s0">;</span>
	  <span class="s0">},</span>
	  <span class="s6">16</span><span class="s0">: </span><span class="s3">'Sets cannot have &quot;replace&quot; patches.'</span><span class="s0">,</span>
	  <span class="s6">17</span><span class="s0">: </span><span class="s1">function </span><span class="s2">_</span><span class="s0">(</span><span class="s2">op</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s3">&quot;Unsupported patch operation: &quot; </span><span class="s0">+ </span><span class="s2">op</span><span class="s0">;</span>
	  <span class="s0">},</span>
	  <span class="s6">18</span><span class="s0">: </span><span class="s1">function </span><span class="s2">_</span><span class="s0">(</span><span class="s2">plugin</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s3">&quot;The plugin for '&quot; </span><span class="s0">+ </span><span class="s2">plugin </span><span class="s0">+ </span><span class="s3">&quot;' has not been loaded into Immer. To enable the plugin, import and call `enable&quot; </span><span class="s0">+ </span><span class="s2">plugin </span><span class="s0">+ </span><span class="s3">&quot;()` when initializing your application.&quot;</span><span class="s0">;</span>
	  <span class="s0">},</span>
	  <span class="s6">20</span><span class="s0">: </span><span class="s3">&quot;Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available&quot;</span><span class="s0">,</span>
	  <span class="s6">21</span><span class="s0">: </span><span class="s1">function </span><span class="s2">_</span><span class="s0">(</span><span class="s2">thing</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s3">&quot;produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '&quot; </span><span class="s0">+ </span><span class="s2">thing </span><span class="s0">+ </span><span class="s3">&quot;'&quot;</span><span class="s0">;</span>
	  <span class="s0">},</span>
	  <span class="s6">22</span><span class="s0">: </span><span class="s1">function </span><span class="s2">_</span><span class="s0">(</span><span class="s2">thing</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s3">&quot;'current' expects a draft, got: &quot; </span><span class="s0">+ </span><span class="s2">thing</span><span class="s0">;</span>
	  <span class="s0">},</span>
	  <span class="s6">23</span><span class="s0">: </span><span class="s1">function </span><span class="s2">_</span><span class="s0">(</span><span class="s2">thing</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s3">&quot;'original' expects a draft, got: &quot; </span><span class="s0">+ </span><span class="s2">thing</span><span class="s0">;</span>
	  <span class="s0">},</span>
	  <span class="s6">24</span><span class="s0">: </span><span class="s3">&quot;Patching reserved attributes like __proto__, prototype and constructor is not allowed&quot;</span>
	<span class="s0">};</span>
	<span class="s1">function </span><span class="s2">die</span><span class="s0">(</span><span class="s2">error</span><span class="s0">) {</span>
	  <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s2">_len </span><span class="s0">= </span><span class="s2">arguments</span><span class="s0">.</span><span class="s2">length</span><span class="s0">, </span><span class="s2">args </span><span class="s0">= </span><span class="s1">new </span><span class="s2">Array</span><span class="s0">(</span><span class="s2">_len </span><span class="s0">&gt; </span><span class="s6">1 </span><span class="s0">? </span><span class="s2">_len </span><span class="s0">- </span><span class="s6">1 </span><span class="s0">: </span><span class="s6">0</span><span class="s0">), </span><span class="s2">_key </span><span class="s0">= </span><span class="s6">1</span><span class="s0">; </span><span class="s2">_key </span><span class="s0">&lt; </span><span class="s2">_len</span><span class="s0">; </span><span class="s2">_key</span><span class="s0">++) {</span>
	    <span class="s2">args</span><span class="s0">[</span><span class="s2">_key </span><span class="s0">- </span><span class="s6">1</span><span class="s0">] = </span><span class="s2">arguments</span><span class="s0">[</span><span class="s2">_key</span><span class="s0">];</span>
	  <span class="s0">}</span>

	  <span class="s0">{</span>
	    <span class="s1">var </span><span class="s2">e </span><span class="s0">= </span><span class="s2">errors</span><span class="s0">[</span><span class="s2">error</span><span class="s0">];</span>
	    <span class="s1">var </span><span class="s2">msg </span><span class="s0">= !</span><span class="s2">e </span><span class="s0">? </span><span class="s3">&quot;unknown error nr: &quot; </span><span class="s0">+ </span><span class="s2">error </span><span class="s0">: </span><span class="s1">typeof </span><span class="s2">e </span><span class="s0">=== </span><span class="s3">&quot;function&quot; </span><span class="s0">? </span><span class="s2">e</span><span class="s0">.</span><span class="s2">apply</span><span class="s0">(</span><span class="s1">null</span><span class="s0">, </span><span class="s2">args</span><span class="s0">) : </span><span class="s2">e</span><span class="s0">;</span>
	    <span class="s1">throw new </span><span class="s2">Error</span><span class="s0">(</span><span class="s3">&quot;[Immer] &quot; </span><span class="s0">+ </span><span class="s2">msg</span><span class="s0">);</span>
	  <span class="s0">}</span>
	<span class="s0">}</span>

	<span class="s5">/** Returns true if the given value is an Immer draft */</span>

	<span class="s4">/*#__PURE__*/</span>

	<span class="s1">function </span><span class="s2">isDraft</span><span class="s0">(</span><span class="s2">value</span><span class="s0">) {</span>
	  <span class="s1">return </span><span class="s0">!!</span><span class="s2">value </span><span class="s0">&amp;&amp; !!</span><span class="s2">value</span><span class="s0">[</span><span class="s2">DRAFT_STATE</span><span class="s0">];</span>
	<span class="s0">}</span>
	<span class="s5">/** Returns true if the given value can be drafted by Immer */</span>

	<span class="s4">/*#__PURE__*/</span>

	<span class="s1">function </span><span class="s2">isDraftable</span><span class="s0">(</span><span class="s2">value</span><span class="s0">) {</span>
	  <span class="s1">var </span><span class="s2">_value$constructor</span><span class="s0">;</span>

	  <span class="s1">if </span><span class="s0">(!</span><span class="s2">value</span><span class="s0">) </span><span class="s1">return false</span><span class="s0">;</span>
	  <span class="s1">return </span><span class="s2">isPlainObject</span><span class="s0">(</span><span class="s2">value</span><span class="s0">) || </span><span class="s2">Array</span><span class="s0">.</span><span class="s2">isArray</span><span class="s0">(</span><span class="s2">value</span><span class="s0">) || !!</span><span class="s2">value</span><span class="s0">[</span><span class="s2">DRAFTABLE</span><span class="s0">] || !!((</span><span class="s2">_value$constructor </span><span class="s0">= </span><span class="s2">value</span><span class="s0">.</span><span class="s2">constructor</span><span class="s0">) === </span><span class="s1">null </span><span class="s0">|| </span><span class="s2">_value$constructor </span><span class="s0">=== </span><span class="s1">void </span><span class="s6">0 </span><span class="s0">? </span><span class="s1">void </span><span class="s6">0 </span><span class="s0">: </span><span class="s2">_value$constructor</span><span class="s0">[</span><span class="s2">DRAFTABLE</span><span class="s0">]) || </span><span class="s2">isMap</span><span class="s0">(</span><span class="s2">value</span><span class="s0">) || </span><span class="s2">isSet</span><span class="s0">(</span><span class="s2">value</span><span class="s0">);</span>
	<span class="s0">}</span>
	<span class="s1">var </span><span class="s2">objectCtorString </span><span class="s0">=</span>
	<span class="s4">/*#__PURE__*/</span>
	<span class="s2">Object</span><span class="s0">.</span><span class="s2">prototype</span><span class="s0">.</span><span class="s2">constructor</span><span class="s0">.</span><span class="s2">toString</span><span class="s0">();</span>
	<span class="s4">/*#__PURE__*/</span>

	<span class="s1">function </span><span class="s2">isPlainObject</span><span class="s0">(</span><span class="s2">value</span><span class="s0">) {</span>
	  <span class="s1">if </span><span class="s0">(!</span><span class="s2">value </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s2">value </span><span class="s0">!== </span><span class="s3">&quot;object&quot;</span><span class="s0">) </span><span class="s1">return false</span><span class="s0">;</span>
	  <span class="s1">var </span><span class="s2">proto </span><span class="s0">= </span><span class="s2">Object</span><span class="s0">.</span><span class="s2">getPrototypeOf</span><span class="s0">(</span><span class="s2">value</span><span class="s0">);</span>

	  <span class="s1">if </span><span class="s0">(</span><span class="s2">proto </span><span class="s0">=== </span><span class="s1">null</span><span class="s0">) {</span>
	    <span class="s1">return true</span><span class="s0">;</span>
	  <span class="s0">}</span>

	  <span class="s1">var </span><span class="s2">Ctor </span><span class="s0">= </span><span class="s2">Object</span><span class="s0">.</span><span class="s2">hasOwnProperty</span><span class="s0">.</span><span class="s2">call</span><span class="s0">(</span><span class="s2">proto</span><span class="s0">, </span><span class="s3">&quot;constructor&quot;</span><span class="s0">) &amp;&amp; </span><span class="s2">proto</span><span class="s0">.</span><span class="s2">constructor</span><span class="s0">;</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">Ctor </span><span class="s0">=== </span><span class="s2">Object</span><span class="s0">) </span><span class="s1">return true</span><span class="s0">;</span>
	  <span class="s1">return typeof </span><span class="s2">Ctor </span><span class="s0">== </span><span class="s3">&quot;function&quot; </span><span class="s0">&amp;&amp; </span><span class="s2">Function</span><span class="s0">.</span><span class="s2">toString</span><span class="s0">.</span><span class="s2">call</span><span class="s0">(</span><span class="s2">Ctor</span><span class="s0">) === </span><span class="s2">objectCtorString</span><span class="s0">;</span>
	<span class="s0">}</span>
	<span class="s1">function </span><span class="s2">original</span><span class="s0">(</span><span class="s2">value</span><span class="s0">) {</span>
	  <span class="s1">if </span><span class="s0">(!</span><span class="s2">isDraft</span><span class="s0">(</span><span class="s2">value</span><span class="s0">)) </span><span class="s2">die</span><span class="s0">(</span><span class="s6">23</span><span class="s0">, </span><span class="s2">value</span><span class="s0">);</span>
	  <span class="s1">return </span><span class="s2">value</span><span class="s0">[</span><span class="s2">DRAFT_STATE</span><span class="s0">].</span><span class="s2">base_</span><span class="s0">;</span>
	<span class="s0">}</span>
	<span class="s4">/*#__PURE__*/</span>

	<span class="s1">var </span><span class="s2">ownKeys </span><span class="s0">= </span><span class="s1">typeof </span><span class="s2">Reflect </span><span class="s0">!== </span><span class="s3">&quot;undefined&quot; </span><span class="s0">&amp;&amp; </span><span class="s2">Reflect</span><span class="s0">.</span><span class="s2">ownKeys </span><span class="s0">? </span><span class="s2">Reflect</span><span class="s0">.</span><span class="s2">ownKeys </span><span class="s0">: </span><span class="s1">typeof </span><span class="s2">Object</span><span class="s0">.</span><span class="s2">getOwnPropertySymbols </span><span class="s0">!== </span><span class="s3">&quot;undefined&quot; </span><span class="s0">? </span><span class="s1">function </span><span class="s0">(</span><span class="s2">obj</span><span class="s0">) {</span>
	  <span class="s1">return </span><span class="s2">Object</span><span class="s0">.</span><span class="s2">getOwnPropertyNames</span><span class="s0">(</span><span class="s2">obj</span><span class="s0">).</span><span class="s2">concat</span><span class="s0">(</span><span class="s2">Object</span><span class="s0">.</span><span class="s2">getOwnPropertySymbols</span><span class="s0">(</span><span class="s2">obj</span><span class="s0">));</span>
	<span class="s0">} :</span>
	<span class="s4">/* istanbul ignore next */</span>
	<span class="s2">Object</span><span class="s0">.</span><span class="s2">getOwnPropertyNames</span><span class="s0">;</span>
	<span class="s1">var </span><span class="s2">getOwnPropertyDescriptors </span><span class="s0">= </span><span class="s2">Object</span><span class="s0">.</span><span class="s2">getOwnPropertyDescriptors </span><span class="s0">|| </span><span class="s1">function </span><span class="s2">getOwnPropertyDescriptors</span><span class="s0">(</span><span class="s2">target</span><span class="s0">) {</span>
	  <span class="s4">// Polyfill needed for Hermes and IE, see https://github.com/facebook/hermes/issues/274</span>
	  <span class="s1">var </span><span class="s2">res </span><span class="s0">= {};</span>
	  <span class="s2">ownKeys</span><span class="s0">(</span><span class="s2">target</span><span class="s0">).</span><span class="s2">forEach</span><span class="s0">(</span><span class="s1">function </span><span class="s0">(</span><span class="s2">key</span><span class="s0">) {</span>
	    <span class="s2">res</span><span class="s0">[</span><span class="s2">key</span><span class="s0">] = </span><span class="s2">Object</span><span class="s0">.</span><span class="s2">getOwnPropertyDescriptor</span><span class="s0">(</span><span class="s2">target</span><span class="s0">, </span><span class="s2">key</span><span class="s0">);</span>
	  <span class="s0">});</span>
	  <span class="s1">return </span><span class="s2">res</span><span class="s0">;</span>
	<span class="s0">};</span>
	<span class="s1">function </span><span class="s2">each</span><span class="s0">(</span><span class="s2">obj</span><span class="s0">, </span><span class="s2">iter</span><span class="s0">, </span><span class="s2">enumerableOnly</span><span class="s0">) {</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">enumerableOnly </span><span class="s0">=== </span><span class="s1">void </span><span class="s6">0</span><span class="s0">) {</span>
	    <span class="s2">enumerableOnly </span><span class="s0">= </span><span class="s1">false</span><span class="s0">;</span>
	  <span class="s0">}</span>

	  <span class="s1">if </span><span class="s0">(</span><span class="s2">getArchtype</span><span class="s0">(</span><span class="s2">obj</span><span class="s0">) === </span><span class="s6">0</span>
	  <span class="s4">/* Object */</span>
	  <span class="s0">) {</span>
	      <span class="s0">(</span><span class="s2">enumerableOnly </span><span class="s0">? </span><span class="s2">Object</span><span class="s0">.</span><span class="s2">keys </span><span class="s0">: </span><span class="s2">ownKeys</span><span class="s0">)(</span><span class="s2">obj</span><span class="s0">).</span><span class="s2">forEach</span><span class="s0">(</span><span class="s1">function </span><span class="s0">(</span><span class="s2">key</span><span class="s0">) {</span>
	        <span class="s1">if </span><span class="s0">(!</span><span class="s2">enumerableOnly </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s2">key </span><span class="s0">!== </span><span class="s3">&quot;symbol&quot;</span><span class="s0">) </span><span class="s2">iter</span><span class="s0">(</span><span class="s2">key</span><span class="s0">, </span><span class="s2">obj</span><span class="s0">[</span><span class="s2">key</span><span class="s0">], </span><span class="s2">obj</span><span class="s0">);</span>
	      <span class="s0">});</span>
	    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
	    <span class="s2">obj</span><span class="s0">.</span><span class="s2">forEach</span><span class="s0">(</span><span class="s1">function </span><span class="s0">(</span><span class="s2">entry</span><span class="s0">, </span><span class="s2">index</span><span class="s0">) {</span>
	      <span class="s1">return </span><span class="s2">iter</span><span class="s0">(</span><span class="s2">index</span><span class="s0">, </span><span class="s2">entry</span><span class="s0">, </span><span class="s2">obj</span><span class="s0">);</span>
	    <span class="s0">});</span>
	  <span class="s0">}</span>
	<span class="s0">}</span>
	<span class="s4">/*#__PURE__*/</span>

	<span class="s1">function </span><span class="s2">getArchtype</span><span class="s0">(</span><span class="s2">thing</span><span class="s0">) {</span>
	  <span class="s4">/* istanbul ignore next */</span>
	  <span class="s1">var </span><span class="s2">state </span><span class="s0">= </span><span class="s2">thing</span><span class="s0">[</span><span class="s2">DRAFT_STATE</span><span class="s0">];</span>
	  <span class="s1">return </span><span class="s2">state </span><span class="s0">? </span><span class="s2">state</span><span class="s0">.</span><span class="s2">type_ </span><span class="s0">&gt; </span><span class="s6">3 </span><span class="s0">? </span><span class="s2">state</span><span class="s0">.</span><span class="s2">type_ </span><span class="s0">- </span><span class="s6">4 </span><span class="s4">// cause Object and Array map back from 4 and 5</span>
	  <span class="s0">: </span><span class="s2">state</span><span class="s0">.</span><span class="s2">type_ </span><span class="s4">// others are the same</span>
	  <span class="s0">: </span><span class="s2">Array</span><span class="s0">.</span><span class="s2">isArray</span><span class="s0">(</span><span class="s2">thing</span><span class="s0">) ? </span><span class="s6">1</span>
	  <span class="s4">/* Array */</span>
	  <span class="s0">: </span><span class="s2">isMap</span><span class="s0">(</span><span class="s2">thing</span><span class="s0">) ? </span><span class="s6">2</span>
	  <span class="s4">/* Map */</span>
	  <span class="s0">: </span><span class="s2">isSet</span><span class="s0">(</span><span class="s2">thing</span><span class="s0">) ? </span><span class="s6">3</span>
	  <span class="s4">/* Set */</span>
	  <span class="s0">: </span><span class="s6">0</span>
	  <span class="s4">/* Object */</span>
	  <span class="s0">;</span>
	<span class="s0">}</span>
	<span class="s4">/*#__PURE__*/</span>

	<span class="s1">function </span><span class="s2">has</span><span class="s0">(</span><span class="s2">thing</span><span class="s0">, </span><span class="s2">prop</span><span class="s0">) {</span>
	  <span class="s1">return </span><span class="s2">getArchtype</span><span class="s0">(</span><span class="s2">thing</span><span class="s0">) === </span><span class="s6">2</span>
	  <span class="s4">/* Map */</span>
	  <span class="s0">? </span><span class="s2">thing</span><span class="s0">.</span><span class="s2">has</span><span class="s0">(</span><span class="s2">prop</span><span class="s0">) : </span><span class="s2">Object</span><span class="s0">.</span><span class="s2">prototype</span><span class="s0">.</span><span class="s2">hasOwnProperty</span><span class="s0">.</span><span class="s2">call</span><span class="s0">(</span><span class="s2">thing</span><span class="s0">, </span><span class="s2">prop</span><span class="s0">);</span>
	<span class="s0">}</span>
	<span class="s4">/*#__PURE__*/</span>

	<span class="s1">function </span><span class="s2">get</span><span class="s0">(</span><span class="s2">thing</span><span class="s0">, </span><span class="s2">prop</span><span class="s0">) {</span>
	  <span class="s4">// @ts-ignore</span>
	  <span class="s1">return </span><span class="s2">getArchtype</span><span class="s0">(</span><span class="s2">thing</span><span class="s0">) === </span><span class="s6">2</span>
	  <span class="s4">/* Map */</span>
	  <span class="s0">? </span><span class="s2">thing</span><span class="s0">.</span><span class="s2">get</span><span class="s0">(</span><span class="s2">prop</span><span class="s0">) : </span><span class="s2">thing</span><span class="s0">[</span><span class="s2">prop</span><span class="s0">];</span>
	<span class="s0">}</span>
	<span class="s4">/*#__PURE__*/</span>

	<span class="s1">function </span><span class="s2">set</span><span class="s0">(</span><span class="s2">thing</span><span class="s0">, </span><span class="s2">propOrOldValue</span><span class="s0">, </span><span class="s2">value</span><span class="s0">) {</span>
	  <span class="s1">var </span><span class="s2">t </span><span class="s0">= </span><span class="s2">getArchtype</span><span class="s0">(</span><span class="s2">thing</span><span class="s0">);</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">t </span><span class="s0">=== </span><span class="s6">2</span>
	  <span class="s4">/* Map */</span>
	  <span class="s0">) </span><span class="s2">thing</span><span class="s0">.</span><span class="s2">set</span><span class="s0">(</span><span class="s2">propOrOldValue</span><span class="s0">, </span><span class="s2">value</span><span class="s0">);</span><span class="s1">else if </span><span class="s0">(</span><span class="s2">t </span><span class="s0">=== </span><span class="s6">3</span>
	  <span class="s4">/* Set */</span>
	  <span class="s0">) {</span>
	      <span class="s2">thing</span><span class="s0">.</span><span class="s2">add</span><span class="s0">(</span><span class="s2">value</span><span class="s0">);</span>
	    <span class="s0">} </span><span class="s1">else </span><span class="s2">thing</span><span class="s0">[</span><span class="s2">propOrOldValue</span><span class="s0">] = </span><span class="s2">value</span><span class="s0">;</span>
	<span class="s0">}</span>
	<span class="s4">/*#__PURE__*/</span>

	<span class="s1">function </span><span class="s2">is</span><span class="s0">(</span><span class="s2">x</span><span class="s0">, </span><span class="s2">y</span><span class="s0">) {</span>
	  <span class="s4">// From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">x </span><span class="s0">=== </span><span class="s2">y</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s2">x </span><span class="s0">!== </span><span class="s6">0 </span><span class="s0">|| </span><span class="s6">1 </span><span class="s0">/ </span><span class="s2">x </span><span class="s0">=== </span><span class="s6">1 </span><span class="s0">/ </span><span class="s2">y</span><span class="s0">;</span>
	  <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
	    <span class="s1">return </span><span class="s2">x </span><span class="s0">!== </span><span class="s2">x </span><span class="s0">&amp;&amp; </span><span class="s2">y </span><span class="s0">!== </span><span class="s2">y</span><span class="s0">;</span>
	  <span class="s0">}</span>
	<span class="s0">}</span>
	<span class="s4">/*#__PURE__*/</span>

	<span class="s1">function </span><span class="s2">isMap</span><span class="s0">(</span><span class="s2">target</span><span class="s0">) {</span>
	  <span class="s1">return </span><span class="s2">hasMap </span><span class="s0">&amp;&amp; </span><span class="s2">target </span><span class="s1">instanceof </span><span class="s2">Map</span><span class="s0">;</span>
	<span class="s0">}</span>
	<span class="s4">/*#__PURE__*/</span>

	<span class="s1">function </span><span class="s2">isSet</span><span class="s0">(</span><span class="s2">target</span><span class="s0">) {</span>
	  <span class="s1">return </span><span class="s2">hasSet </span><span class="s0">&amp;&amp; </span><span class="s2">target </span><span class="s1">instanceof </span><span class="s2">Set</span><span class="s0">;</span>
	<span class="s0">}</span>
	<span class="s4">/*#__PURE__*/</span>

	<span class="s1">function </span><span class="s2">latest</span><span class="s0">(</span><span class="s2">state</span><span class="s0">) {</span>
	  <span class="s1">return </span><span class="s2">state</span><span class="s0">.</span><span class="s2">copy_ </span><span class="s0">|| </span><span class="s2">state</span><span class="s0">.</span><span class="s2">base_</span><span class="s0">;</span>
	<span class="s0">}</span>
	<span class="s4">/*#__PURE__*/</span>

	<span class="s1">function </span><span class="s2">shallowCopy</span><span class="s0">(</span><span class="s2">base</span><span class="s0">) {</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">Array</span><span class="s0">.</span><span class="s2">isArray</span><span class="s0">(</span><span class="s2">base</span><span class="s0">)) </span><span class="s1">return </span><span class="s2">Array</span><span class="s0">.</span><span class="s2">prototype</span><span class="s0">.</span><span class="s2">slice</span><span class="s0">.</span><span class="s2">call</span><span class="s0">(</span><span class="s2">base</span><span class="s0">);</span>
	  <span class="s1">var </span><span class="s2">descriptors </span><span class="s0">= </span><span class="s2">getOwnPropertyDescriptors</span><span class="s0">(</span><span class="s2">base</span><span class="s0">);</span>
	  <span class="s1">delete </span><span class="s2">descriptors</span><span class="s0">[</span><span class="s2">DRAFT_STATE</span><span class="s0">];</span>
	  <span class="s1">var </span><span class="s2">keys </span><span class="s0">= </span><span class="s2">ownKeys</span><span class="s0">(</span><span class="s2">descriptors</span><span class="s0">);</span>

	  <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s2">i </span><span class="s0">= </span><span class="s6">0</span><span class="s0">; </span><span class="s2">i </span><span class="s0">&lt; </span><span class="s2">keys</span><span class="s0">.</span><span class="s2">length</span><span class="s0">; </span><span class="s2">i</span><span class="s0">++) {</span>
	    <span class="s1">var </span><span class="s2">key </span><span class="s0">= </span><span class="s2">keys</span><span class="s0">[</span><span class="s2">i</span><span class="s0">];</span>
	    <span class="s1">var </span><span class="s2">desc </span><span class="s0">= </span><span class="s2">descriptors</span><span class="s0">[</span><span class="s2">key</span><span class="s0">];</span>

	    <span class="s1">if </span><span class="s0">(</span><span class="s2">desc</span><span class="s0">.</span><span class="s2">writable </span><span class="s0">=== </span><span class="s1">false</span><span class="s0">) {</span>
	      <span class="s2">desc</span><span class="s0">.</span><span class="s2">writable </span><span class="s0">= </span><span class="s1">true</span><span class="s0">;</span>
	      <span class="s2">desc</span><span class="s0">.</span><span class="s2">configurable </span><span class="s0">= </span><span class="s1">true</span><span class="s0">;</span>
	    <span class="s0">} </span><span class="s4">// like object.assign, we will read any _own_, get/set accessors. This helps in dealing</span>
	    <span class="s4">// with libraries that trap values, like mobx or vue</span>
	    <span class="s4">// unlike object.assign, non-enumerables will be copied as well</span>


	    <span class="s1">if </span><span class="s0">(</span><span class="s2">desc</span><span class="s0">.</span><span class="s2">get </span><span class="s0">|| </span><span class="s2">desc</span><span class="s0">.</span><span class="s2">set</span><span class="s0">) </span><span class="s2">descriptors</span><span class="s0">[</span><span class="s2">key</span><span class="s0">] = {</span>
	      <span class="s2">configurable</span><span class="s0">: </span><span class="s1">true</span><span class="s0">,</span>
	      <span class="s2">writable</span><span class="s0">: </span><span class="s1">true</span><span class="s0">,</span>
	      <span class="s2">enumerable</span><span class="s0">: </span><span class="s2">desc</span><span class="s0">.</span><span class="s2">enumerable</span><span class="s0">,</span>
	      <span class="s2">value</span><span class="s0">: </span><span class="s2">base</span><span class="s0">[</span><span class="s2">key</span><span class="s0">]</span>
	    <span class="s0">};</span>
	  <span class="s0">}</span>

	  <span class="s1">return </span><span class="s2">Object</span><span class="s0">.</span><span class="s2">create</span><span class="s0">(</span><span class="s2">Object</span><span class="s0">.</span><span class="s2">getPrototypeOf</span><span class="s0">(</span><span class="s2">base</span><span class="s0">), </span><span class="s2">descriptors</span><span class="s0">);</span>
	<span class="s0">}</span>
	<span class="s1">function </span><span class="s2">freeze</span><span class="s0">(</span><span class="s2">obj</span><span class="s0">, </span><span class="s2">deep</span><span class="s0">) {</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">deep </span><span class="s0">=== </span><span class="s1">void </span><span class="s6">0</span><span class="s0">) {</span>
	    <span class="s2">deep </span><span class="s0">= </span><span class="s1">false</span><span class="s0">;</span>
	  <span class="s0">}</span>

	  <span class="s1">if </span><span class="s0">(</span><span class="s2">isFrozen</span><span class="s0">(</span><span class="s2">obj</span><span class="s0">) || </span><span class="s2">isDraft</span><span class="s0">(</span><span class="s2">obj</span><span class="s0">) || !</span><span class="s2">isDraftable</span><span class="s0">(</span><span class="s2">obj</span><span class="s0">)) </span><span class="s1">return </span><span class="s2">obj</span><span class="s0">;</span>

	  <span class="s1">if </span><span class="s0">(</span><span class="s2">getArchtype</span><span class="s0">(</span><span class="s2">obj</span><span class="s0">) &gt; </span><span class="s6">1</span>
	  <span class="s4">/* Map or Set */</span>
	  <span class="s0">) {</span>
	      <span class="s2">obj</span><span class="s0">.</span><span class="s2">set </span><span class="s0">= </span><span class="s2">obj</span><span class="s0">.</span><span class="s2">add </span><span class="s0">= </span><span class="s2">obj</span><span class="s0">.</span><span class="s2">clear </span><span class="s0">= </span><span class="s2">obj</span><span class="s0">.</span><span class="s2">delete </span><span class="s0">= </span><span class="s2">dontMutateFrozenCollections</span><span class="s0">;</span>
	    <span class="s0">}</span>

	  <span class="s2">Object</span><span class="s0">.</span><span class="s2">freeze</span><span class="s0">(</span><span class="s2">obj</span><span class="s0">);</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">deep</span><span class="s0">) </span><span class="s2">each</span><span class="s0">(</span><span class="s2">obj</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(</span><span class="s2">key</span><span class="s0">, </span><span class="s2">value</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s2">freeze</span><span class="s0">(</span><span class="s2">value</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>
	  <span class="s0">}, </span><span class="s1">true</span><span class="s0">);</span>
	  <span class="s1">return </span><span class="s2">obj</span><span class="s0">;</span>
	<span class="s0">}</span>

	<span class="s1">function </span><span class="s2">dontMutateFrozenCollections</span><span class="s0">() {</span>
	  <span class="s2">die</span><span class="s0">(</span><span class="s6">2</span><span class="s0">);</span>
	<span class="s0">}</span>

	<span class="s1">function </span><span class="s2">isFrozen</span><span class="s0">(</span><span class="s2">obj</span><span class="s0">) {</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">obj </span><span class="s0">== </span><span class="s1">null </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s2">obj </span><span class="s0">!== </span><span class="s3">&quot;object&quot;</span><span class="s0">) </span><span class="s1">return true</span><span class="s0">; </span><span class="s4">// See #600, IE dies on non-objects in Object.isFrozen</span>

	  <span class="s1">return </span><span class="s2">Object</span><span class="s0">.</span><span class="s2">isFrozen</span><span class="s0">(</span><span class="s2">obj</span><span class="s0">);</span>
	<span class="s0">}</span>

	<span class="s5">/** Plugin utilities */</span>

	<span class="s1">var </span><span class="s2">plugins </span><span class="s0">= {};</span>
	<span class="s1">function </span><span class="s2">getPlugin</span><span class="s0">(</span><span class="s2">pluginKey</span><span class="s0">) {</span>
	  <span class="s1">var </span><span class="s2">plugin </span><span class="s0">= </span><span class="s2">plugins</span><span class="s0">[</span><span class="s2">pluginKey</span><span class="s0">];</span>

	  <span class="s1">if </span><span class="s0">(!</span><span class="s2">plugin</span><span class="s0">) {</span>
	    <span class="s2">die</span><span class="s0">(</span><span class="s6">18</span><span class="s0">, </span><span class="s2">pluginKey</span><span class="s0">);</span>
	  <span class="s0">} </span><span class="s4">// @ts-ignore</span>


	  <span class="s1">return </span><span class="s2">plugin</span><span class="s0">;</span>
	<span class="s0">}</span>
	<span class="s1">function </span><span class="s2">loadPlugin</span><span class="s0">(</span><span class="s2">pluginKey</span><span class="s0">, </span><span class="s2">implementation</span><span class="s0">) {</span>
	  <span class="s1">if </span><span class="s0">(!</span><span class="s2">plugins</span><span class="s0">[</span><span class="s2">pluginKey</span><span class="s0">]) </span><span class="s2">plugins</span><span class="s0">[</span><span class="s2">pluginKey</span><span class="s0">] = </span><span class="s2">implementation</span><span class="s0">;</span>
	<span class="s0">}</span>

	<span class="s1">var </span><span class="s2">currentScope</span><span class="s0">;</span>
	<span class="s1">function </span><span class="s2">getCurrentScope</span><span class="s0">() {</span>
	  <span class="s1">if </span><span class="s0">( !</span><span class="s2">currentScope</span><span class="s0">) </span><span class="s2">die</span><span class="s0">(</span><span class="s6">0</span><span class="s0">);</span>
	  <span class="s1">return </span><span class="s2">currentScope</span><span class="s0">;</span>
	<span class="s0">}</span>

	<span class="s1">function </span><span class="s2">createScope</span><span class="s0">(</span><span class="s2">parent_</span><span class="s0">, </span><span class="s2">immer_</span><span class="s0">) {</span>
	  <span class="s1">return </span><span class="s0">{</span>
	    <span class="s2">drafts_</span><span class="s0">: [],</span>
	    <span class="s2">parent_</span><span class="s0">: </span><span class="s2">parent_</span><span class="s0">,</span>
	    <span class="s2">immer_</span><span class="s0">: </span><span class="s2">immer_</span><span class="s0">,</span>
	    <span class="s4">// Whenever the modified draft contains a draft from another scope, we</span>
	    <span class="s4">// need to prevent auto-freezing so the unowned draft can be finalized.</span>
	    <span class="s2">canAutoFreeze_</span><span class="s0">: </span><span class="s1">true</span><span class="s0">,</span>
	    <span class="s2">unfinalizedDrafts_</span><span class="s0">: </span><span class="s6">0</span>
	  <span class="s0">};</span>
	<span class="s0">}</span>

	<span class="s1">function </span><span class="s2">usePatchesInScope</span><span class="s0">(</span><span class="s2">scope</span><span class="s0">, </span><span class="s2">patchListener</span><span class="s0">) {</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">patchListener</span><span class="s0">) {</span>
	    <span class="s2">getPlugin</span><span class="s0">(</span><span class="s3">&quot;Patches&quot;</span><span class="s0">); </span><span class="s4">// assert we have the plugin</span>

	    <span class="s2">scope</span><span class="s0">.</span><span class="s2">patches_ </span><span class="s0">= [];</span>
	    <span class="s2">scope</span><span class="s0">.</span><span class="s2">inversePatches_ </span><span class="s0">= [];</span>
	    <span class="s2">scope</span><span class="s0">.</span><span class="s2">patchListener_ </span><span class="s0">= </span><span class="s2">patchListener</span><span class="s0">;</span>
	  <span class="s0">}</span>
	<span class="s0">}</span>
	<span class="s1">function </span><span class="s2">revokeScope</span><span class="s0">(</span><span class="s2">scope</span><span class="s0">) {</span>
	  <span class="s2">leaveScope</span><span class="s0">(</span><span class="s2">scope</span><span class="s0">);</span>
	  <span class="s2">scope</span><span class="s0">.</span><span class="s2">drafts_</span><span class="s0">.</span><span class="s2">forEach</span><span class="s0">(</span><span class="s2">revokeDraft</span><span class="s0">); </span><span class="s4">// @ts-ignore</span>

	  <span class="s2">scope</span><span class="s0">.</span><span class="s2">drafts_ </span><span class="s0">= </span><span class="s1">null</span><span class="s0">;</span>
	<span class="s0">}</span>
	<span class="s1">function </span><span class="s2">leaveScope</span><span class="s0">(</span><span class="s2">scope</span><span class="s0">) {</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">scope </span><span class="s0">=== </span><span class="s2">currentScope</span><span class="s0">) {</span>
	    <span class="s2">currentScope </span><span class="s0">= </span><span class="s2">scope</span><span class="s0">.</span><span class="s2">parent_</span><span class="s0">;</span>
	  <span class="s0">}</span>
	<span class="s0">}</span>
	<span class="s1">function </span><span class="s2">enterScope</span><span class="s0">(</span><span class="s2">immer</span><span class="s0">) {</span>
	  <span class="s1">return </span><span class="s2">currentScope </span><span class="s0">= </span><span class="s2">createScope</span><span class="s0">(</span><span class="s2">currentScope</span><span class="s0">, </span><span class="s2">immer</span><span class="s0">);</span>
	<span class="s0">}</span>

	<span class="s1">function </span><span class="s2">revokeDraft</span><span class="s0">(</span><span class="s2">draft</span><span class="s0">) {</span>
	  <span class="s1">var </span><span class="s2">state </span><span class="s0">= </span><span class="s2">draft</span><span class="s0">[</span><span class="s2">DRAFT_STATE</span><span class="s0">];</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">state</span><span class="s0">.</span><span class="s2">type_ </span><span class="s0">=== </span><span class="s6">0</span>
	  <span class="s4">/* ProxyObject */</span>
	  <span class="s0">|| </span><span class="s2">state</span><span class="s0">.</span><span class="s2">type_ </span><span class="s0">=== </span><span class="s6">1</span>
	  <span class="s4">/* ProxyArray */</span>
	  <span class="s0">) </span><span class="s2">state</span><span class="s0">.</span><span class="s2">revoke_</span><span class="s0">();</span><span class="s1">else </span><span class="s2">state</span><span class="s0">.</span><span class="s2">revoked_ </span><span class="s0">= </span><span class="s1">true</span><span class="s0">;</span>
	<span class="s0">}</span>

	<span class="s1">function </span><span class="s2">processResult</span><span class="s0">(</span><span class="s2">result</span><span class="s0">, </span><span class="s2">scope</span><span class="s0">) {</span>
	  <span class="s2">scope</span><span class="s0">.</span><span class="s2">unfinalizedDrafts_ </span><span class="s0">= </span><span class="s2">scope</span><span class="s0">.</span><span class="s2">drafts_</span><span class="s0">.</span><span class="s2">length</span><span class="s0">;</span>
	  <span class="s1">var </span><span class="s2">baseDraft </span><span class="s0">= </span><span class="s2">scope</span><span class="s0">.</span><span class="s2">drafts_</span><span class="s0">[</span><span class="s6">0</span><span class="s0">];</span>
	  <span class="s1">var </span><span class="s2">isReplaced </span><span class="s0">= </span><span class="s2">result </span><span class="s0">!== </span><span class="s2">undefined </span><span class="s0">&amp;&amp; </span><span class="s2">result </span><span class="s0">!== </span><span class="s2">baseDraft</span><span class="s0">;</span>
	  <span class="s1">if </span><span class="s0">(!</span><span class="s2">scope</span><span class="s0">.</span><span class="s2">immer_</span><span class="s0">.</span><span class="s2">useProxies_</span><span class="s0">) </span><span class="s2">getPlugin</span><span class="s0">(</span><span class="s3">&quot;ES5&quot;</span><span class="s0">).</span><span class="s2">willFinalizeES5_</span><span class="s0">(</span><span class="s2">scope</span><span class="s0">, </span><span class="s2">result</span><span class="s0">, </span><span class="s2">isReplaced</span><span class="s0">);</span>

	  <span class="s1">if </span><span class="s0">(</span><span class="s2">isReplaced</span><span class="s0">) {</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s2">baseDraft</span><span class="s0">[</span><span class="s2">DRAFT_STATE</span><span class="s0">].</span><span class="s2">modified_</span><span class="s0">) {</span>
	      <span class="s2">revokeScope</span><span class="s0">(</span><span class="s2">scope</span><span class="s0">);</span>
	      <span class="s2">die</span><span class="s0">(</span><span class="s6">4</span><span class="s0">);</span>
	    <span class="s0">}</span>

	    <span class="s1">if </span><span class="s0">(</span><span class="s2">isDraftable</span><span class="s0">(</span><span class="s2">result</span><span class="s0">)) {</span>
	      <span class="s4">// Finalize the result in case it contains (or is) a subset of the draft.</span>
	      <span class="s2">result </span><span class="s0">= </span><span class="s2">finalize</span><span class="s0">(</span><span class="s2">scope</span><span class="s0">, </span><span class="s2">result</span><span class="s0">);</span>
	      <span class="s1">if </span><span class="s0">(!</span><span class="s2">scope</span><span class="s0">.</span><span class="s2">parent_</span><span class="s0">) </span><span class="s2">maybeFreeze</span><span class="s0">(</span><span class="s2">scope</span><span class="s0">, </span><span class="s2">result</span><span class="s0">);</span>
	    <span class="s0">}</span>

	    <span class="s1">if </span><span class="s0">(</span><span class="s2">scope</span><span class="s0">.</span><span class="s2">patches_</span><span class="s0">) {</span>
	      <span class="s2">getPlugin</span><span class="s0">(</span><span class="s3">&quot;Patches&quot;</span><span class="s0">).</span><span class="s2">generateReplacementPatches_</span><span class="s0">(</span><span class="s2">baseDraft</span><span class="s0">[</span><span class="s2">DRAFT_STATE</span><span class="s0">].</span><span class="s2">base_</span><span class="s0">, </span><span class="s2">result</span><span class="s0">, </span><span class="s2">scope</span><span class="s0">.</span><span class="s2">patches_</span><span class="s0">, </span><span class="s2">scope</span><span class="s0">.</span><span class="s2">inversePatches_</span><span class="s0">);</span>
	    <span class="s0">}</span>
	  <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
	    <span class="s4">// Finalize the base draft.</span>
	    <span class="s2">result </span><span class="s0">= </span><span class="s2">finalize</span><span class="s0">(</span><span class="s2">scope</span><span class="s0">, </span><span class="s2">baseDraft</span><span class="s0">, []);</span>
	  <span class="s0">}</span>

	  <span class="s2">revokeScope</span><span class="s0">(</span><span class="s2">scope</span><span class="s0">);</span>

	  <span class="s1">if </span><span class="s0">(</span><span class="s2">scope</span><span class="s0">.</span><span class="s2">patches_</span><span class="s0">) {</span>
	    <span class="s2">scope</span><span class="s0">.</span><span class="s2">patchListener_</span><span class="s0">(</span><span class="s2">scope</span><span class="s0">.</span><span class="s2">patches_</span><span class="s0">, </span><span class="s2">scope</span><span class="s0">.</span><span class="s2">inversePatches_</span><span class="s0">);</span>
	  <span class="s0">}</span>

	  <span class="s1">return </span><span class="s2">result </span><span class="s0">!== </span><span class="s2">NOTHING </span><span class="s0">? </span><span class="s2">result </span><span class="s0">: </span><span class="s2">undefined</span><span class="s0">;</span>
	<span class="s0">}</span>

	<span class="s1">function </span><span class="s2">finalize</span><span class="s0">(</span><span class="s2">rootScope</span><span class="s0">, </span><span class="s2">value</span><span class="s0">, </span><span class="s2">path</span><span class="s0">) {</span>
	  <span class="s4">// Don't recurse in tho recursive data structures</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">isFrozen</span><span class="s0">(</span><span class="s2">value</span><span class="s0">)) </span><span class="s1">return </span><span class="s2">value</span><span class="s0">;</span>
	  <span class="s1">var </span><span class="s2">state </span><span class="s0">= </span><span class="s2">value</span><span class="s0">[</span><span class="s2">DRAFT_STATE</span><span class="s0">]; </span><span class="s4">// A plain object, might need freezing, might contain drafts</span>

	  <span class="s1">if </span><span class="s0">(!</span><span class="s2">state</span><span class="s0">) {</span>
	    <span class="s2">each</span><span class="s0">(</span><span class="s2">value</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(</span><span class="s2">key</span><span class="s0">, </span><span class="s2">childValue</span><span class="s0">) {</span>
	      <span class="s1">return </span><span class="s2">finalizeProperty</span><span class="s0">(</span><span class="s2">rootScope</span><span class="s0">, </span><span class="s2">state</span><span class="s0">, </span><span class="s2">value</span><span class="s0">, </span><span class="s2">key</span><span class="s0">, </span><span class="s2">childValue</span><span class="s0">, </span><span class="s2">path</span><span class="s0">);</span>
	    <span class="s0">}, </span><span class="s1">true </span><span class="s4">// See #590, don't recurse into non-enumerable of non drafted objects</span>
	    <span class="s0">);</span>
	    <span class="s1">return </span><span class="s2">value</span><span class="s0">;</span>
	  <span class="s0">} </span><span class="s4">// Never finalize drafts owned by another scope.</span>


	  <span class="s1">if </span><span class="s0">(</span><span class="s2">state</span><span class="s0">.</span><span class="s2">scope_ </span><span class="s0">!== </span><span class="s2">rootScope</span><span class="s0">) </span><span class="s1">return </span><span class="s2">value</span><span class="s0">; </span><span class="s4">// Unmodified draft, return the (frozen) original</span>

	  <span class="s1">if </span><span class="s0">(!</span><span class="s2">state</span><span class="s0">.</span><span class="s2">modified_</span><span class="s0">) {</span>
	    <span class="s2">maybeFreeze</span><span class="s0">(</span><span class="s2">rootScope</span><span class="s0">, </span><span class="s2">state</span><span class="s0">.</span><span class="s2">base_</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>
	    <span class="s1">return </span><span class="s2">state</span><span class="s0">.</span><span class="s2">base_</span><span class="s0">;</span>
	  <span class="s0">} </span><span class="s4">// Not finalized yet, let's do that now</span>


	  <span class="s1">if </span><span class="s0">(!</span><span class="s2">state</span><span class="s0">.</span><span class="s2">finalized_</span><span class="s0">) {</span>
	    <span class="s2">state</span><span class="s0">.</span><span class="s2">finalized_ </span><span class="s0">= </span><span class="s1">true</span><span class="s0">;</span>
	    <span class="s2">state</span><span class="s0">.</span><span class="s2">scope_</span><span class="s0">.</span><span class="s2">unfinalizedDrafts_</span><span class="s0">--;</span>
	    <span class="s1">var </span><span class="s2">result </span><span class="s0">= </span><span class="s4">// For ES5, create a good copy from the draft first, with added keys and without deleted keys.</span>
	    <span class="s2">state</span><span class="s0">.</span><span class="s2">type_ </span><span class="s0">=== </span><span class="s6">4</span>
	    <span class="s4">/* ES5Object */</span>
	    <span class="s0">|| </span><span class="s2">state</span><span class="s0">.</span><span class="s2">type_ </span><span class="s0">=== </span><span class="s6">5</span>
	    <span class="s4">/* ES5Array */</span>
	    <span class="s0">? </span><span class="s2">state</span><span class="s0">.</span><span class="s2">copy_ </span><span class="s0">= </span><span class="s2">shallowCopy</span><span class="s0">(</span><span class="s2">state</span><span class="s0">.</span><span class="s2">draft_</span><span class="s0">) : </span><span class="s2">state</span><span class="s0">.</span><span class="s2">copy_</span><span class="s0">; </span><span class="s4">// Finalize all children of the copy</span>
	    <span class="s4">// For sets we clone before iterating, otherwise we can get in endless loop due to modifying during iteration, see #628</span>
	    <span class="s4">// To preserve insertion order in all cases we then clear the set</span>
	    <span class="s4">// And we let finalizeProperty know it needs to re-add non-draft children back to the target</span>

	    <span class="s1">var </span><span class="s2">resultEach </span><span class="s0">= </span><span class="s2">result</span><span class="s0">;</span>
	    <span class="s1">var </span><span class="s2">isSet </span><span class="s0">= </span><span class="s1">false</span><span class="s0">;</span>

	    <span class="s1">if </span><span class="s0">(</span><span class="s2">state</span><span class="s0">.</span><span class="s2">type_ </span><span class="s0">=== </span><span class="s6">3</span>
	    <span class="s4">/* Set */</span>
	    <span class="s0">) {</span>
	        <span class="s2">resultEach </span><span class="s0">= </span><span class="s1">new </span><span class="s2">Set</span><span class="s0">(</span><span class="s2">result</span><span class="s0">);</span>
	        <span class="s2">result</span><span class="s0">.</span><span class="s2">clear</span><span class="s0">();</span>
	        <span class="s2">isSet </span><span class="s0">= </span><span class="s1">true</span><span class="s0">;</span>
	      <span class="s0">}</span>

	    <span class="s2">each</span><span class="s0">(</span><span class="s2">resultEach</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(</span><span class="s2">key</span><span class="s0">, </span><span class="s2">childValue</span><span class="s0">) {</span>
	      <span class="s1">return </span><span class="s2">finalizeProperty</span><span class="s0">(</span><span class="s2">rootScope</span><span class="s0">, </span><span class="s2">state</span><span class="s0">, </span><span class="s2">result</span><span class="s0">, </span><span class="s2">key</span><span class="s0">, </span><span class="s2">childValue</span><span class="s0">, </span><span class="s2">path</span><span class="s0">, </span><span class="s2">isSet</span><span class="s0">);</span>
	    <span class="s0">}); </span><span class="s4">// everything inside is frozen, we can freeze here</span>

	    <span class="s2">maybeFreeze</span><span class="s0">(</span><span class="s2">rootScope</span><span class="s0">, </span><span class="s2">result</span><span class="s0">, </span><span class="s1">false</span><span class="s0">); </span><span class="s4">// first time finalizing, let's create those patches</span>

	    <span class="s1">if </span><span class="s0">(</span><span class="s2">path </span><span class="s0">&amp;&amp; </span><span class="s2">rootScope</span><span class="s0">.</span><span class="s2">patches_</span><span class="s0">) {</span>
	      <span class="s2">getPlugin</span><span class="s0">(</span><span class="s3">&quot;Patches&quot;</span><span class="s0">).</span><span class="s2">generatePatches_</span><span class="s0">(</span><span class="s2">state</span><span class="s0">, </span><span class="s2">path</span><span class="s0">, </span><span class="s2">rootScope</span><span class="s0">.</span><span class="s2">patches_</span><span class="s0">, </span><span class="s2">rootScope</span><span class="s0">.</span><span class="s2">inversePatches_</span><span class="s0">);</span>
	    <span class="s0">}</span>
	  <span class="s0">}</span>

	  <span class="s1">return </span><span class="s2">state</span><span class="s0">.</span><span class="s2">copy_</span><span class="s0">;</span>
	<span class="s0">}</span>

	<span class="s1">function </span><span class="s2">finalizeProperty</span><span class="s0">(</span><span class="s2">rootScope</span><span class="s0">, </span><span class="s2">parentState</span><span class="s0">, </span><span class="s2">targetObject</span><span class="s0">, </span><span class="s2">prop</span><span class="s0">, </span><span class="s2">childValue</span><span class="s0">, </span><span class="s2">rootPath</span><span class="s0">, </span><span class="s2">targetIsSet</span><span class="s0">) {</span>
	  <span class="s1">if </span><span class="s0">( </span><span class="s2">childValue </span><span class="s0">=== </span><span class="s2">targetObject</span><span class="s0">) </span><span class="s2">die</span><span class="s0">(</span><span class="s6">5</span><span class="s0">);</span>

	  <span class="s1">if </span><span class="s0">(</span><span class="s2">isDraft</span><span class="s0">(</span><span class="s2">childValue</span><span class="s0">)) {</span>
	    <span class="s1">var </span><span class="s2">path </span><span class="s0">= </span><span class="s2">rootPath </span><span class="s0">&amp;&amp; </span><span class="s2">parentState </span><span class="s0">&amp;&amp; </span><span class="s2">parentState</span><span class="s0">.</span><span class="s2">type_ </span><span class="s0">!== </span><span class="s6">3</span>
	    <span class="s4">/* Set */</span>
	    <span class="s0">&amp;&amp; </span><span class="s4">// Set objects are atomic since they have no keys.</span>
	    <span class="s0">!</span><span class="s2">has</span><span class="s0">(</span><span class="s2">parentState</span><span class="s0">.</span><span class="s2">assigned_</span><span class="s0">, </span><span class="s2">prop</span><span class="s0">) </span><span class="s4">// Skip deep patches for assigned keys.</span>
	    <span class="s0">? </span><span class="s2">rootPath</span><span class="s0">.</span><span class="s2">concat</span><span class="s0">(</span><span class="s2">prop</span><span class="s0">) : </span><span class="s2">undefined</span><span class="s0">; </span><span class="s4">// Drafts owned by `scope` are finalized here.</span>

	    <span class="s1">var </span><span class="s2">res </span><span class="s0">= </span><span class="s2">finalize</span><span class="s0">(</span><span class="s2">rootScope</span><span class="s0">, </span><span class="s2">childValue</span><span class="s0">, </span><span class="s2">path</span><span class="s0">);</span>
	    <span class="s2">set</span><span class="s0">(</span><span class="s2">targetObject</span><span class="s0">, </span><span class="s2">prop</span><span class="s0">, </span><span class="s2">res</span><span class="s0">); </span><span class="s4">// Drafts from another scope must prevented to be frozen</span>
	    <span class="s4">// if we got a draft back from finalize, we're in a nested produce and shouldn't freeze</span>

	    <span class="s1">if </span><span class="s0">(</span><span class="s2">isDraft</span><span class="s0">(</span><span class="s2">res</span><span class="s0">)) {</span>
	      <span class="s2">rootScope</span><span class="s0">.</span><span class="s2">canAutoFreeze_ </span><span class="s0">= </span><span class="s1">false</span><span class="s0">;</span>
	    <span class="s0">} </span><span class="s1">else return</span><span class="s0">;</span>
	  <span class="s0">} </span><span class="s1">else if </span><span class="s0">(</span><span class="s2">targetIsSet</span><span class="s0">) {</span>
	    <span class="s2">targetObject</span><span class="s0">.</span><span class="s2">add</span><span class="s0">(</span><span class="s2">childValue</span><span class="s0">);</span>
	  <span class="s0">} </span><span class="s4">// Search new objects for unfinalized drafts. Frozen objects should never contain drafts.</span>


	  <span class="s1">if </span><span class="s0">(</span><span class="s2">isDraftable</span><span class="s0">(</span><span class="s2">childValue</span><span class="s0">) &amp;&amp; !</span><span class="s2">isFrozen</span><span class="s0">(</span><span class="s2">childValue</span><span class="s0">)) {</span>
	    <span class="s1">if </span><span class="s0">(!</span><span class="s2">rootScope</span><span class="s0">.</span><span class="s2">immer_</span><span class="s0">.</span><span class="s2">autoFreeze_ </span><span class="s0">&amp;&amp; </span><span class="s2">rootScope</span><span class="s0">.</span><span class="s2">unfinalizedDrafts_ </span><span class="s0">&lt; </span><span class="s6">1</span><span class="s0">) {</span>
	      <span class="s4">// optimization: if an object is not a draft, and we don't have to</span>
	      <span class="s4">// deepfreeze everything, and we are sure that no drafts are left in the remaining object</span>
	      <span class="s4">// cause we saw and finalized all drafts already; we can stop visiting the rest of the tree.</span>
	      <span class="s4">// This benefits especially adding large data tree's without further processing.</span>
	      <span class="s4">// See add-data.js perf test</span>
	      <span class="s1">return</span><span class="s0">;</span>
	    <span class="s0">}</span>

	    <span class="s2">finalize</span><span class="s0">(</span><span class="s2">rootScope</span><span class="s0">, </span><span class="s2">childValue</span><span class="s0">); </span><span class="s4">// immer deep freezes plain objects, so if there is no parent state, we freeze as well</span>

	    <span class="s1">if </span><span class="s0">(!</span><span class="s2">parentState </span><span class="s0">|| !</span><span class="s2">parentState</span><span class="s0">.</span><span class="s2">scope_</span><span class="s0">.</span><span class="s2">parent_</span><span class="s0">) </span><span class="s2">maybeFreeze</span><span class="s0">(</span><span class="s2">rootScope</span><span class="s0">, </span><span class="s2">childValue</span><span class="s0">);</span>
	  <span class="s0">}</span>
	<span class="s0">}</span>

	<span class="s1">function </span><span class="s2">maybeFreeze</span><span class="s0">(</span><span class="s2">scope</span><span class="s0">, </span><span class="s2">value</span><span class="s0">, </span><span class="s2">deep</span><span class="s0">) {</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s2">deep </span><span class="s0">=== </span><span class="s1">void </span><span class="s6">0</span><span class="s0">) {</span>
	    <span class="s2">deep </span><span class="s0">= </span><span class="s1">false</span><span class="s0">;</span>
	  <span class="s0">}</span>

	  <span class="s4">// we never freeze for a non-root scope; as it would prevent pruning for drafts inside wrapping objects</span>
	  <span class="s1">if </span><span class="s0">(!</span><span class="s2">scope</span><span class="s0">.</span><span class="s2">parent_ </span><span class="s0">&amp;&amp; </span><span class="s2">scope</span><span class="s0">.</span><span class="s2">immer_</span><span class="s0">.</span><span class="s2">autoFreeze_ </span><span class="s0">&amp;&amp; </span><span class="s2">scope</span><span class="s0">.</span><span class="s2">canAutoFreeze_</span><span class="s0">) {</span>
	    <span class="s2">freeze</span><span class="s0">(</span><span class="s2">value</span><span class="s0">, </span><span class="s2">deep</span><span class="s0">);</span>
	  <span class="s0">}</span>
	<span class="s0">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* Returns a new draft of the `base` object.</span>
	 <span class="s5">*</span>
	 <span class="s5">* The second argument is the parent draft-state (used internally).</span>
	 <span class="s5">*/</span>

	<span class="s1">function </span><span class="s2">createProxyProxy</span><span class="s0">(</span><span class="s2">base</span><span class="s0">, </span><span class="s2">parent</span><span class="s0">) {</span>
	  <span class="s1">var </span><span class="s2">isArray </span><span class="s0">= </span><span class="s2">Array</span><span class="s0">.</span><span class="s2">isArray</span><span class="s0">(</span><span class="s2">base</span><span class="s0">);</span>
	  <span class="s1">var </span><span class="s2">state </span><span class="s0">= {</span>
	    <span class="s2">type_</span><span class="s0">: </span><span class="s2">isArray </span><span class="s0">? </span><span class="s6">1</span>
	    <span class="s4">/* ProxyArray */</span>
	    <span class="s0">: </span><span class="s6">0</span>
	    <span class="s4">/* ProxyObject */</span>
	    <span class="s0">,</span>
	    <span class="s4">// Track which produce call this is associated with.</span>
	    <span class="s2">scope_</span><span class="s0">: </span><span class="s2">parent </span><span class="s0">? </span><span class="s2">parent</span><span class="s0">.</span><span class="s2">scope_ </span><span class="s0">: </span><span class="s2">getCurrentScope</span><span class="s0">(),</span>
	    <span class="s4">// True for both shallow and deep changes.</span>
	    <span class="s2">modified_</span><span class="s0">: </span><span class="s1">false</span><span class="s0">,</span>
	    <span class="s4">// Used during finalization.</span>
	    <span class="s2">finalized_</span><span class="s0">: </span><span class="s1">false</span><span class="s0">,</span>
	    <span class="s4">// Track which properties have been assigned (true) or deleted (false).</span>
	    <span class="s2">assigned_</span><span class="s0">: {},</span>
	    <span class="s4">// The parent draft state.</span>
	    <span class="s2">parent_</span><span class="s0">: </span><span class="s2">parent</span><span class="s0">,</span>
	    <span class="s4">// The base state.</span>
	    <span class="s2">base_</span><span class="s0">: </span><span class="s2">base</span><span class="s0">,</span>
	    <span class="s4">// The base proxy.</span>
	    <span class="s2">draft_</span><span class="s0">: </span><span class="s1">null</span><span class="s0">,</span>
	    <span class="s4">// The base copy with any updated values.</span>
	    <span class="s2">copy_</span><span class="s0">: </span><span class="s1">null</span><span class="s0">,</span>
	    <span class="s4">// Called by the `produce` function.</span>
	    <span class="s2">revoke_</span><span class="s0">: </span><span class="s1">null</span><span class="s0">,</span>
	    <span class="s2">isManual_</span><span class="s0">: </span><span class="s1">false</span>
	  <span class="s0">}; </span><span class="s4">// the traps must target something, a bit like the 'real' base.</span>
	  <span class="s4">// but also, we need to be able to determine from the target what the relevant state is</span>
	  <span class="s4">// (to avoid creating traps per instance to capture the state in closure,</span>
	  <span class="s4">// and to avoid creating weird hidden properties as well)</span>
	  <span class="s4">// So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)</span>
	  <span class="s4">// Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb</span>

	  <span class="s1">var </span><span class="s2">target </span><span class="s0">= </span><span class="s2">state</span><span class="s0">;</span>
	  <span class="s1">var </span><span class="s2">traps </span><span class="s0">= </span><span class="s2">objectTraps</span><span class="s0">;</span>

	  <span class="s1">if </span><span class="s0">(</span><span class="s2">isArray</span><span class="s0">) {</span>
	    <span class="s2">target </span><span class="s0">= [</span><span class="s2">state</span><span class="s0">];</span>
	    <span class="s2">traps </span><span class="s0">= </span><span class="s2">arrayTraps</span><span class="s0">;</span>
	  <span class="s0">}</span>

	  <span class="s1">var </span><span class="s2">_Proxy$revocable </span><span class="s0">= </span><span class="s2">Proxy</span><span class="s0">.</span><span class="s2">revocable</span><span class="s0">(</span><span class="s2">target</span><span class="s0">, </span><span class="s2">traps</span><span class="s0">),</span>
	      <span class="s2">revoke </span><span class="s0">= </span><span class="s2">_Proxy$revocable</span><span class="s0">.</span><span class="s2">revoke</span><span class="s0">,</span>
	      <span class="s2">proxy </span><span class="s0">= </span><span class="s2">_Proxy$revocable</span><span class="s0">.</span><span class="s2">proxy</span><span class="s0">;</span>

	  <span class="s2">state</span><span class="s0">.</span><span class="s2">draft_ </span><span class="s0">= </span><span class="s2">proxy</span><span class="s0">;</span>
	  <span class="s2">state</span><span class="s0">.</span><span class="s2">revoke_ </span><span class="s0">= </span><span class="s2">revoke</span><span class="s0">;</span>
	  <span class="s1">return </span><span class="s2">proxy</span><span class="s0">;</span>
	<span class="s0">}</span>
	<span class="s5">/**</span>
	 <span class="s5">* Object drafts</span>
	 <span class="s5">*/</span>

	<span class="s1">var </span><span class="s2">objectTraps </span><span class="s0">= {</span>
	  <span class="s2">get</span><span class="s0">: </span><span class="s1">function </span><span class="s2">get</span><span class="s0">(</span><span class="s2">state</span><span class="s0">, </span><span class="s2">prop</span><span class="s0">) {</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s2">prop </span><span class="s0">=== </span><span class="s2">DRAFT_STATE</span><span class="s0">) </span><span class="s1">return </span><span class="s2">state</span><span class="s0">;</span>
	    <span class="s1">var </span><span class="s2">source </span><span class="s0">= </span><span class="s2">latest</span><span class="s0">(</span><span class="s2">state</span><span class="s0">);</span>

	    <span class="s1">if </span><span class="s0">(!</span><span class="s2">has</span><span class="s0">(</span><span class="s2">source</span><span class="s0">, </span><span class="s2">prop</span><span class="s0">)) {</span>
	      <span class="s4">// non-existing or non-own property...</span>
	      <span class="s1">return </span><span class="s2">readPropFromProto</span><span class="s0">(</span><span class="s2">state</span><span class="s0">, </span><span class="s2">source</span><span class="s0">, </span><span class="s2">prop</span><span class="s0">);</span>
	    <span class="s0">}</span>

	    <span class="s1">var </span><span class="s2">value </span><span class="s0">= </span><span class="s2">source</span><span class="s0">[</span><span class="s2">prop</span><span class="s0">];</span>

	    <span class="s1">if </span><span class="s0">(</span><span class="s2">state</span><span class="s0">.</span><span class="s2">finalized_ </span><span class="s0">|| !</span><span class="s2">isDraftable</span><span class="s0">(</span><span class="s2">value</span><span class="s0">)) {</span>
	      <span class="s1">return </span><span class="s2">value</span><span class="s0">;</span>
	    <span class="s0">} </span><span class="s4">// Check for existing draft in modified state.</span>
	    <span class="s4">// Assigned values are never drafted. This catches any drafts we created, too.</span>


	    <span class="s1">if </span><span class="s0">(</span><span class="s2">value </span><span class="s0">=== </span><span class="s2">peek</span><span class="s0">(</span><span class="s2">state</span><span class="s0">.</span><span class="s2">base_</span><span class="s0">, </span><span class="s2">prop</span><span class="s0">)) {</span>
	      <span class="s2">prepareCopy</span><span class="s0">(</span><span class="s2">state</span><span class="s0">);</span>
	      <span class="s1">return </span><span class="s2">state</span><span class="s0">.</span><span class="s2">copy_</span><span class="s0">[</span><span class="s2">prop</span><span class="s0">] = </span><span class="s2">createProxy</span><span class="s0">(</span><span class="s2">state</span><span class="s0">.</span><span class="s2">scope_</span><span class="s0">.</span><span class="s2">immer_</span><span class="s0">, </span><span class="s2">value</span><span class="s0">, </span><span class="s2">state</span><span class="s0">);</span>
	    <span class="s0">}</span>

	    <span class="s1">return </span><span class="s2">value</span><span class="s0">;</span>
	  <span class="s0">},</span>
	  <span class="s2">has</span><span class="s0">: </span><span class="s1">function </span><span class="s2">has</span><span class="s0">(</span><span class="s2">state</span><span class="s0">, </span><span class="s2">prop</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s2">prop </span><span class="s1">in </span><span class="s2">latest</span><span class="s0">(</span><span class="s2">state</span><span class="s0">);</span>
	  <span class="s0">},</span>
	  <span class="s2">ownKeys</span><span class="s0">: </span><span class="s1">function </span><span class="s2">ownKeys</span><span class="s0">(</span><span class="s2">state</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s2">Reflect</span><span class="s0">.</span><span class="s2">ownKeys</span><span class="s0">(</span><span class="s2">latest</span><span class="s0">(</span><span class="s2">state</span><span class="s0">));</span>
	  <span class="s0">},</span>
	  <span class="s2">set</span><span class="s0">: </span><span class="s1">function </span><span class="s2">set</span><span class="s0">(</span><span class="s2">state</span><span class="s0">, </span><span class="s2">prop</span>
	  <span class="s4">/* strictly not, but helps TS */</span>
	  <span class="s0">, </span><span class="s2">value</span><span class="s0">) {</span>
	    <span class="s1">var </span><span class="s2">desc </span><span class="s0">= </span><span class="s2">getDescriptorFromProto</span><span class="s0">(</span><span class="s2">latest</span><span class="s0">(</span><span class="s2">state</span><span class="s0">), </span><span class="s2">prop</span><span class="s0">);</span>

	    <span class="s1">if </span><span class="s0">(</span><span class="s2">desc </span><span class="s0">=== </span><span class="s1">null </span><span class="s0">|| </span><span class="s2">desc </span><span class="s0">=== </span><span class="s1">void </span><span class="s6">0 </span><span class="s0">? </span><span class="s1">void </span><span class="s6">0 </span><span class="s0">: </span><span class="s2">desc</span><span class="s0">.</span><span class="s2">set</span><span class="s0">) {</span>
	      <span class="s4">// special case: if this write is captured by a setter, we have</span>
	      <span class="s4">// to trigger it with the correct context</span>
	      <span class="s2">desc</span><span class="s0">.</span><span class="s2">set</span><span class="s0">.</span><span class="s2">call</span><span class="s0">(</span><span class="s2">state</span><span class="s0">.</span><span class="s2">draft_</span><span class="s0">, </span><span class="s2">value</span><span class="s0">);</span>
	      <span class="s1">return true</span><span class="s0">;</span>
	    <span class="s0">}</span>

	    <span class="s1">if </span><span class="s0">(!</span><span class="s2">state</span><span class="s0">.</span><span class="s2">modified_</span><span class="s0">) {</span>
	      <span class="s4">// the last check is because we need to be able to distinguish setting a non-existing to undefined (which is a change)</span>
	      <span class="s4">// from setting an existing property with value undefined to undefined (which is not a change)</span>
	      <span class="s1">var </span><span class="s2">current </span><span class="s0">= </span><span class="s2">peek</span><span class="s0">(</span><span class="s2">latest</span><span class="s0">(</span><span class="s2">state</span><span class="s0">), </span><span class="s2">prop</span><span class="s0">); </span><span class="s4">// special case, if we assigning the original value to a draft, we can ignore the assignment</span>

	      <span class="s1">var </span><span class="s2">currentState </span><span class="s0">= </span><span class="s2">current </span><span class="s0">=== </span><span class="s1">null </span><span class="s0">|| </span><span class="s2">current </span><span class="s0">=== </span><span class="s1">void </span><span class="s6">0 </span><span class="s0">? </span><span class="s1">void </span><span class="s6">0 </span><span class="s0">: </span><span class="s2">current</span><span class="s0">[</span><span class="s2">DRAFT_STATE</span><span class="s0">];</span>

	      <span class="s1">if </span><span class="s0">(</span><span class="s2">currentState </span><span class="s0">&amp;&amp; </span><span class="s2">currentState</span><span class="s0">.</span><span class="s2">base_ </span><span class="s0">=== </span><span class="s2">value</span><span class="s0">) {</span>
	        <span class="s2">state</span><span class="s0">.</span><span class="s2">copy_</span><span class="s0">[</span><span class="s2">prop</span><span class="s0">] = </span><span class="s2">value</span><span class="s0">;</span>
	        <span class="s2">state</span><span class="s0">.</span><span class="s2">assigned_</span><span class="s0">[</span><span class="s2">prop</span><span class="s0">] = </span><span class="s1">false</span><span class="s0">;</span>
	        <span class="s1">return true</span><span class="s0">;</span>
	      <span class="s0">}</span>

	      <span class="s1">if </span><span class="s0">(</span><span class="s2">is</span><span class="s0">(</span><span class="s2">value</span><span class="s0">, </span><span class="s2">current</span><span class="s0">) &amp;&amp; (</span><span class="s2">value </span><span class="s0">!== </span><span class="s2">undefined </span><span class="s0">|| </span><span class="s2">has</span><span class="s0">(</span><span class="s2">state</span><span class="s0">.</span><span class="s2">base_</span><span class="s0">, </span><span class="s2">prop</span><span class="s0">))) </span><span class="s1">return true</span><span class="s0">;</span>
	      <span class="s2">prepareCopy</span><span class="s0">(</span><span class="s2">state</span><span class="s0">);</span>
	      <span class="s2">markChanged</span><span class="s0">(</span><span class="s2">state</span><span class="s0">);</span>
	    <span class="s0">}</span>

	    <span class="s1">if </span><span class="s0">(</span><span class="s2">state</span><span class="s0">.</span><span class="s2">copy_</span><span class="s0">[</span><span class="s2">prop</span><span class="s0">] === </span><span class="s2">value </span><span class="s0">&amp;&amp; ( </span><span class="s4">// special case: handle new props with value 'undefined'</span>
	    <span class="s2">value </span><span class="s0">!== </span><span class="s2">undefined </span><span class="s0">|| </span><span class="s2">prop </span><span class="s1">in </span><span class="s2">state</span><span class="s0">.</span><span class="s2">copy_</span><span class="s0">) || </span><span class="s4">// special case: NaN</span>
	    <span class="s2">Number</span><span class="s0">.</span><span class="s2">isNaN</span><span class="s0">(</span><span class="s2">value</span><span class="s0">) &amp;&amp; </span><span class="s2">Number</span><span class="s0">.</span><span class="s2">isNaN</span><span class="s0">(</span><span class="s2">state</span><span class="s0">.</span><span class="s2">copy_</span><span class="s0">[</span><span class="s2">prop</span><span class="s0">])) </span><span class="s1">return true</span><span class="s0">; </span><span class="s4">// @ts-ignore</span>

	    <span class="s2">state</span><span class="s0">.</span><span class="s2">copy_</span><span class="s0">[</span><span class="s2">prop</span><span class="s0">] = </span><span class="s2">value</span><span class="s0">;</span>
	    <span class="s2">state</span><span class="s0">.</span><span class="s2">assigned_</span><span class="s0">[</span><span class="s2">prop</span><span class="s0">] = </span><span class="s1">true</span><span class="s0">;</span>
	    <span class="s1">return true</span><span class="s0">;</span>
	  <span class="s0">},</span>
	  <span class="s2">deleteProperty</span><span class="s0">: </span><span class="s1">function </span><span class="s2">deleteProperty</span><span class="s0">(</span><span class="s2">state</span><span class="s0">, </span><span class="s2">prop</span><span class="s0">) {</span>
	    <span class="s4">// The `undefined` check is a fast path for pre-existing keys.</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s2">peek</span><span class="s0">(</span><span class="s2">state</span><span class="s0">.</span><span class="s2">base_</span><span class="s0">, </span><span class="s2">prop</span><span class="s0">) !== </span><span class="s2">undefined </span><span class="s0">|| </span><span class="s2">prop </span><span class="s1">in </span><span class="s2">state</span><span class="s0">.</span><span class="s2">base_</span><span class="s0">) {</span>
	      <span class="s2">state</span><span class="s0">.</span><span class="s2">assigned_</span><span class="s0">[</span><span class="s2">prop</span><span class="s0">] = </span><span class="s1">false</span><span class="s0">;</span>
	      <span class="s2">prepareCopy</span><span class="s0">(</span><span class="s2">state</span><span class="s0">);</span>
	      <span class="s2">markChanged</span><span class="s0">(</span><span class="s2">state</span><span class="s0">);</span>
	    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
	      <span class="s4">// if an originally not assigned property was deleted</span>
	      <span class="s1">delete </span><span class="s2">state</span><span class="s0">.</span><span class="s2">assigned_</span><span class="s0">[</span><span class="s2">prop</span><span class="s0">];</span>
	    <span class="s0">} </span><span class="s4">// @ts-ignore</span>


	    <span class="s1">if </span><span class="s0">(</span><span class="s2">state</span><span class="s0">.</span><span class="s2">copy_</span><span class="s0">) </span><span class="s1">delete </span><span class="s2">state</span><span class="s0">.</span><span class="s2">copy_</span><span class="s0">[</span><span class="s2">prop</span><span class="s0">];</span>
	    <span class="s1">return true</span><span class="s0">;</span>
	  <span class="s0">},</span>
	  <span class="s4">// Note: We never coerce `desc.value` into an Immer draft, because we can't make</span>
	  <span class="s4">// the same guarantee in ES5 mode.</span>
	  <span class="s2">getOwnPropertyDescriptor</span><span class="s0">: </span><span class="s1">function </span><span class="s2">getOwnPropertyDescriptor</span><span class="s0">(</span><span class="s2">state</span><span class="s0">, </span><span class="s2">prop</span><span class="s0">) {</span>
	    <span class="s1">var </span><span class="s2">owner </span><span class="s0">= </span><span class="s2">latest</span><span class="s0">(</span><span class="s2">state</span><span class="s0">);</span>
	    <span class="s1">var </span><span class="s2">desc </span><span class="s0">= </span><span class="s2">Reflect</span><span class="s0">.</span><span class="s2">getOwnPropertyDescriptor</span><span class="s0">(</span><span class="s2">owner</span><span class="s0">, </span><span class="s2">prop</span><span class="s0">);</span>
	    <span class="s1">if </span><span class="s0">(!</span><span class="s2">desc</span><span class="s0">) </span><span class="s1">return </span><span class="s2">desc</span><span class="s0">;</span>
	    <span class="s1">return </span><span class="s0">{</span>
	      <span class="s2">writable</span><span class="s0">: </span><span class="s1">true</span><span class="s0">,</span>
	      <span class="s2">configurable</span><span class="s0">: </span><span class="s2">state</span><span class="s0">.</span><span class="s2">type_ </span><span class="s0">!== </span><span class="s6">1</span>
	      <span class="s4">/* ProxyArray */</span>
	      <span class="s0">|| </span><span class="s2">prop </span><span class="s0">!== </span><span class="s3">&quot;length&quot;</span><span class="s0">,</span>
	      <span class="s2">enumerable</span><span class="s0">: </span><span class="s2">desc</span><span class="s0">.</span><span class="s2">enumerable</span><span class="s0">,</span>
	      <span class="s2">value</span><span class="s0">: </span><span class="s2">owner</span><span class="s0">[</span><span class="s2">prop</span><span class="s0">]</span>
	    <span class="s0">};</span>
	  <span class="s0">},</span>
	  <span class="s2">defineProperty</span><span class="s0">: </span><span class="s1">function </span><span class="s2">defineProperty</span><span class="s0">() {</span>
	    <span class="s2">die</span><span class="s0">(</span><span class="s6">11</span><span class="s0">);</span>
	  <span class="s0">},</span>
	  <span class="s2">getPrototypeOf</span><span class="s0">: </span><span class="s1">function </span><span class="s2">getPrototypeOf</span><span class="s0">(</span><span class="s2">state</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s2">Object</span><span class="s0">.</span><span class="s2">getPrototypeOf</span><span class="s0">(</span><span class="s2">state</span><span class="s0">.</span><span class="s2">base_</span><span class="s0">);</span>
	  <span class="s0">},</span>
	  <span class="s2">setPrototypeOf</span><span class="s0">: </span><span class="s1">function </span><span class="s2">setPrototypeOf</span><span class="s0">() {</span>
	    <span class="s2">die</span><span class="s0">(</span><span class="s6">12</span><span class="s0">);</span>
	  <span class="s0">}</span>
	<span class="s0">};</span>
	<span class="s5">/**</span>
	 <span class="s5">* Array drafts</span>
	 <span class="s5">*/</span>

	<span class="s1">var </span><span class="s2">arrayTraps </span><span class="s0">= {};</span>
	<span class="s2">each</span><span class="s0">(</span><span class="s2">objectTraps</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(</span><span class="s2">key</span><span class="s0">, </span><span class="s2">fn</span><span class="s0">) {</span>
	  <span class="s4">// @ts-ignore</span>
	  <span class="s2">arrayTraps</span><span class="s0">[</span><span class="s2">key</span><span class="s0">] = </span><span class="s1">function </span><span class="s0">() {</span>
	    <span class="s2">arguments</span><span class="s0">[</span><span class="s6">0</span><span class="s0">] = </span><span class="s2">arguments</span><span class="s0">[</span><span class="s6">0</span><span class="s0">][</span><span class="s6">0</span><span class="s0">];</span>
	    <span class="s1">return </span><span class="s2">fn</span><span class="s0">.</span><span class="s2">apply</span><span class="s0">(</span><span class="s1">this</span><span class="s0">, </span><span class="s2">arguments</span><span class="s0">);</span>
	  <span class="s0">};</span>
	<span class="s0">});</span>

	<span class="s2">arrayTraps</span><span class="s0">.</span><span class="s2">deleteProperty </span><span class="s0">= </span><span class="s1">function </span><span class="s0">(</span><span class="s2">state</span><span class="s0">, </span><span class="s2">prop</span><span class="s0">) {</span>
	  <span class="s1">if </span><span class="s0">( </span><span class="s2">isNaN</span><span class="s0">(</span><span class="s2">parseInt</span><span class="s0">(</span><span class="s2">prop</span><span class="s0">))) </span><span class="s2">die</span><span class="s0">(</span><span class="s6">13</span><span class="s0">); </span><span class="s4">// @ts-ignore</span>

	  <span class="s1">return </span><span class="s2">arrayTraps</span><span class="s0">.</span><span class="s2">set</span><span class="s0">.</span><span class="s2">call</span><span class="s0">(</span><span class="s1">this</span><span class="s0">, </span><span class="s2">state</span><span class="s0">, </span><span class="s2">prop</span><span class="s0">, </span><span class="s2">undefined</span><span class="s0">);</span>
	<span class="s0">};</span>

	<span class="s2">arrayTraps</span><span class="s0">.</span><span class="s2">set </span><span class="s0">= </span><span class="s1">function </span><span class="s0">(</span><span class="s2">state</span><span class="s0">, </span><span class="s2">prop</span><span class="s0">, </span><span class="s2">value</span><span class="s0">) {</span>
	  <span class="s1">if </span><span class="s0">( </span><span class="s2">prop </span><span class="s0">!== </span><span class="s3">&quot;length&quot; </span><span class="s0">&amp;&amp; </span><span class="s2">isNaN</span><span class="s0">(</span><span class="s2">parseInt</span><span class="s0">(</span><span class="s2">prop</span><span class="s0">))) </span><span class="s2">die</span><span class="s0">(</span><span class="s6">14</span><span class="s0">);</span>
	  <span class="s1">return </span><span class="s2">objectTraps</span><span class="s0">.</span><span class="s2">set</span><span class="s0">.</span><span class="s2">call</span><span class="s0">(</span><span class="s1">this</span><span class="s0">, </span><span class="s2">state</span><span class="s0">[</span><span class="s6">0</span><span class="s0">], </span><span class="s2">prop</span><span class="s0">, </span><span class="s2">value</span><span class="s0">, </span><span class="s2">state</span><span class="s0">[</span><span class="s6">0</span><span class="s0">]);</span>
	<span class="s0">}; </span><span class="s4">// Access a property without creating an Immer draft.</span>


	<span class="s1">function </span><span class="s2">peek</span><span class="s0">(</span><span class="s2">draft</span><span class="s0">, </span><span class="s2">prop</span><span class="s0">) {</span>
	  <span class="s1">var </span><span class="s2">state </span><span class="s0">= </span><span class="s2">draft</span><span class="s0">[</span><span class="s2">DRAFT_STATE</span><span class="s0">];</span>
	  <span class="s1">var </span><span class="s2">source </span><span class="s0">= </span><span class="s2">state </span><span class="s0">? </span><span class="s2">latest</span><span class="s0">(</span><span class="s2">state</span><span class="s0">) : </span><span class="s2">draft</span><span class="s0">;</span>
	  <span class="s1">return </span><span class="s2">source</span><span class="s0">[</span><span class="s2">prop</span><span class="s0">];</span>
	<span class="s0">}</span>

	<span class="s1">function </span><span class="s2">readPropFromProto</span><span class="s0">(</span><span class="s2">state</span><span class="s0">, </span><span class="s2">source</span><span class="s0">, </span><span class="s2">prop</span><span class="s0">) {</span>
	  <span class="s1">var </span><span class="s2">_desc$get</span><span class="s0">;</span>

	  <span class="s1">var </span><span class="s2">desc </span><span class="s0">= </span><span class="s2">getDescriptorFromProto</span><span class="s0">(</span><span class="s2">source</span><span class="s0">, </span><span class="s2">prop</span><span class="s0">);</span>
	  <span class="s1">return </span><span class="s2">desc </span><span class="s0">? </span><span class="s3">&quot;value&quot; </span><span class="s1">in </span><span class="s2">desc </span><span class="s0">? </span><span class="s2">desc</span><span class="s0">.</span><span class="s2">value </span><span class="s0">: </span><span class="s4">// This is a very special case, if the prop is a getter defined by the</span>
	  <span class="s4">// prototype, we should invoke it with the draft as context!</span>
	  <span class="s0">(</span><span class="s2">_desc$get </span><span class="s0">= </span><span class="s2">desc</span><span class="s0">.</span><span class="s2">get</span><span class="s0">) === </span><span class="s1">null </span><span class="s0">|| </span><span class="s2">_desc$get </span><span class="s0">=== </span><span class="s1">void </span><span class="s6">0 </span><span class="s0">? </span><span class="s1">void </span><span class="s6">0 </span><span class="s0">: </span><span class="s2">_desc$get</span><span class="s0">.</span><span class="s2">call</span><span class="s0">(</span><span class="s2">state</span><span class="s0">.</span><span class="s2">draft_</span><span class="s0">) : </span><span class="s2">undefined</span><span class="s0">;</span>
	<span class="s0">}</span>

	<span class="s1">function </span><span class="s2">getDescriptorFromProto</span><span class="s0">(</span><span class="s2">source</span><span class="s0">, </span><span class="s2">prop</span><span class="s0">) {</span>
	  <span class="s4">// 'in' checks proto!</span>
	  <span class="s1">if </span><span class="s0">(!(</span><span class="s2">prop </span><span class="s1">in </span><span class="s2">source</span><span class="s0">)) </span><span class="s1">return </span><span class="s2">undefined</span><span class="s0">;</span>
	  <span class="s1">var </span><span class="s2">proto </span><span class="s0">= </span><span class="s2">Object</span><span class="s0">.</span><span class="s2">getPrototypeOf</span><span class="s0">(</span><span class="s2">source</span><span class="s0">);</span>

	  <span class="s1">while </span><span class="s0">(</span><span class="s2">proto</span><span class="s0">) {</span>
	    <span class="s1">var </span><span class="s2">desc </span><span class="s0">= </span><span class="s2">Object</span><span class="s0">.</span><span class="s2">getOwnPropertyDescriptor</span><span class="s0">(</span><span class="s2">proto</span><span class="s0">, </span><span class="s2">prop</span><span class="s0">);</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s2">desc</span><span class="s0">) </span><span class="s1">return </span><span class="s2">desc</span><span class="s0">;</span>
	    <span class="s2">proto </span><span class="s0">= </span><span class="s2">Object</span><span class="s0">.</span><span class="s2">getPrototypeOf</span><span class="s0">(</span><span class="s2">proto</span><span class="s0">);</span>
	  <span class="s0">}</span>

	  <span class="s1">return </span><span class="s2">undefined</span><span class="s0">;</span>
	<span class="s0">}</span>

	<span class="s1">function </span><span class="s2">markChanged</span><span class="s0">(</span><span class="s2">state</span><span class="s0">) {</span>
	  <span class="s1">if </span><span class="s0">(!</span><span class="s2">state</span><span class="s0">.</span><span class="s2">modified_</span><span class="s0">) {</span>
	    <span class="s2">state</span><span class="s0">.</span><span class="s2">modified_ </span><span class="s0">= </span><span class="s1">true</span><span class="s0">;</span>

	    <span class="s1">if </span><span class="s0">(</span><span class="s2">state</span><span class="s0">.</span><span class="s2">parent_</span><span class="s0">) {</span>
	      <span class="s2">markChanged</span><span class="s0">(</span><span class="s2">state</span><span class="s0">.</span><span class="s2">parent_</span><span class="s0">);</span>
	    <span class="s0">}</span>
	  <span class="s0">}</span>
	<span class="s0">}</span>
	<span class="s1">function </span><span class="s2">prepareCopy</span><span class="s0">(</span><span class="s2">state</span><span class="s0">) {</span>
	  <span class="s1">if </span><span class="s0">(!</span><span class="s2">state</span><span class="s0">.</span><span class="s2">copy_</span><span class="s0">) {</span>
	    <span class="s2">state</span><span class="s0">.</span><span class="s2">copy_ </span><span class="s0">= </span><span class="s2">shallowCopy</span><span class="s0">(</span><span class="s2">state</span><span class="s0">.</span><span class="s2">base_</span><span class="s0">);</span>
	  <span class="s0">}</span>
	<span class="s0">}</span>

	<span class="s1">var </span><span class="s2">Immer </span><span class="s0">=</span>
	<span class="s4">/*#__PURE__*/</span>
	<span class="s1">function </span><span class="s0">() {</span>
	  <span class="s1">function </span><span class="s2">Immer</span><span class="s0">(</span><span class="s2">config</span><span class="s0">) {</span>
	    <span class="s1">var </span><span class="s2">_this </span><span class="s0">= </span><span class="s1">this</span><span class="s0">;</span>

	    <span class="s1">this</span><span class="s0">.</span><span class="s2">useProxies_ </span><span class="s0">= </span><span class="s2">hasProxies</span><span class="s0">;</span>
	    <span class="s1">this</span><span class="s0">.</span><span class="s2">autoFreeze_ </span><span class="s0">= </span><span class="s1">true</span><span class="s0">;</span>
	    <span class="s5">/**</span>
	     <span class="s5">* The `produce` function takes a value and a &quot;recipe function&quot; (whose</span>
	     <span class="s5">* return value often depends on the base state). The recipe function is</span>
	     <span class="s5">* free to mutate its first argument however it wants. All mutations are</span>
	     <span class="s5">* only ever applied to a __copy__ of the base state.</span>
	     <span class="s5">*</span>
	     <span class="s5">* Pass only a function to create a &quot;curried producer&quot; which relieves you</span>
	     <span class="s5">* from passing the recipe function every time.</span>
	     <span class="s5">*</span>
	     <span class="s5">* Only plain objects and arrays are made mutable. All other objects are</span>
	     <span class="s5">* considered uncopyable.</span>
	     <span class="s5">*</span>
	     <span class="s5">* Note: This function is __bound__ to its `Immer` instance.</span>
	     <span class="s5">*</span>
	     <span class="s5">* </span><span class="s7">@param </span><span class="s5">{any} base - the initial state</span>
	     <span class="s5">* </span><span class="s7">@param </span><span class="s5">{Function} recipe - function that receives a proxy of the base state as first argument and which can be freely modified</span>
	     <span class="s5">* </span><span class="s7">@param </span><span class="s5">{Function} patchListener - optional function that will be called with all the patches produced here</span>
	     <span class="s5">* </span><span class="s7">@returns </span><span class="s5">{any} a new state, or the initial state if nothing was modified</span>
	     <span class="s5">*/</span>

	    <span class="s1">this</span><span class="s0">.</span><span class="s2">produce </span><span class="s0">= </span><span class="s1">function </span><span class="s0">(</span><span class="s2">base</span><span class="s0">, </span><span class="s2">recipe</span><span class="s0">, </span><span class="s2">patchListener</span><span class="s0">) {</span>
	      <span class="s4">// curried invocation</span>
	      <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s2">base </span><span class="s0">=== </span><span class="s3">&quot;function&quot; </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s2">recipe </span><span class="s0">!== </span><span class="s3">&quot;function&quot;</span><span class="s0">) {</span>
	        <span class="s1">var </span><span class="s2">defaultBase </span><span class="s0">= </span><span class="s2">recipe</span><span class="s0">;</span>
	        <span class="s2">recipe </span><span class="s0">= </span><span class="s2">base</span><span class="s0">;</span>
	        <span class="s1">var </span><span class="s2">self </span><span class="s0">= </span><span class="s2">_this</span><span class="s0">;</span>
	        <span class="s1">return function </span><span class="s2">curriedProduce</span><span class="s0">(</span><span class="s2">base</span><span class="s0">) {</span>
	          <span class="s1">var </span><span class="s2">_this2 </span><span class="s0">= </span><span class="s1">this</span><span class="s0">;</span>

	          <span class="s1">if </span><span class="s0">(</span><span class="s2">base </span><span class="s0">=== </span><span class="s1">void </span><span class="s6">0</span><span class="s0">) {</span>
	            <span class="s2">base </span><span class="s0">= </span><span class="s2">defaultBase</span><span class="s0">;</span>
	          <span class="s0">}</span>

	          <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s2">_len </span><span class="s0">= </span><span class="s2">arguments</span><span class="s0">.</span><span class="s2">length</span><span class="s0">, </span><span class="s2">args </span><span class="s0">= </span><span class="s1">new </span><span class="s2">Array</span><span class="s0">(</span><span class="s2">_len </span><span class="s0">&gt; </span><span class="s6">1 </span><span class="s0">? </span><span class="s2">_len </span><span class="s0">- </span><span class="s6">1 </span><span class="s0">: </span><span class="s6">0</span><span class="s0">), </span><span class="s2">_key </span><span class="s0">= </span><span class="s6">1</span><span class="s0">; </span><span class="s2">_key </span><span class="s0">&lt; </span><span class="s2">_len</span><span class="s0">; </span><span class="s2">_key</span><span class="s0">++) {</span>
	            <span class="s2">args</span><span class="s0">[</span><span class="s2">_key </span><span class="s0">- </span><span class="s6">1</span><span class="s0">] = </span><span class="s2">arguments</span><span class="s0">[</span><span class="s2">_key</span><span class="s0">];</span>
	          <span class="s0">}</span>

	          <span class="s1">return </span><span class="s2">self</span><span class="s0">.</span><span class="s2">produce</span><span class="s0">(</span><span class="s2">base</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(</span><span class="s2">draft</span><span class="s0">) {</span>
	            <span class="s1">var </span><span class="s2">_recipe</span><span class="s0">;</span>

	            <span class="s1">return </span><span class="s0">(</span><span class="s2">_recipe </span><span class="s0">= </span><span class="s2">recipe</span><span class="s0">).</span><span class="s2">call</span><span class="s0">.</span><span class="s2">apply</span><span class="s0">(</span><span class="s2">_recipe</span><span class="s0">, [</span><span class="s2">_this2</span><span class="s0">, </span><span class="s2">draft</span><span class="s0">].</span><span class="s2">concat</span><span class="s0">(</span><span class="s2">args</span><span class="s0">));</span>
	          <span class="s0">}); </span><span class="s4">// prettier-ignore</span>
	        <span class="s0">};</span>
	      <span class="s0">}</span>

	      <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s2">recipe </span><span class="s0">!== </span><span class="s3">&quot;function&quot;</span><span class="s0">) </span><span class="s2">die</span><span class="s0">(</span><span class="s6">6</span><span class="s0">);</span>
	      <span class="s1">if </span><span class="s0">(</span><span class="s2">patchListener </span><span class="s0">!== </span><span class="s2">undefined </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s2">patchListener </span><span class="s0">!== </span><span class="s3">&quot;function&quot;</span><span class="s0">) </span><span class="s2">die</span><span class="s0">(</span><span class="s6">7</span><span class="s0">);</span>
	      <span class="s1">var </span><span class="s2">result</span><span class="s0">; </span><span class="s4">// Only plain objects, arrays, and &quot;immerable classes&quot; are drafted.</span>

	      <span class="s1">if </span><span class="s0">(</span><span class="s2">isDraftable</span><span class="s0">(</span><span class="s2">base</span><span class="s0">)) {</span>
	        <span class="s1">var </span><span class="s2">scope </span><span class="s0">= </span><span class="s2">enterScope</span><span class="s0">(</span><span class="s2">_this</span><span class="s0">);</span>
	        <span class="s1">var </span><span class="s2">proxy </span><span class="s0">= </span><span class="s2">createProxy</span><span class="s0">(</span><span class="s2">_this</span><span class="s0">, </span><span class="s2">base</span><span class="s0">, </span><span class="s2">undefined</span><span class="s0">);</span>
	        <span class="s1">var </span><span class="s2">hasError </span><span class="s0">= </span><span class="s1">true</span><span class="s0">;</span>

	        <span class="s1">try </span><span class="s0">{</span>
	          <span class="s2">result </span><span class="s0">= </span><span class="s2">recipe</span><span class="s0">(</span><span class="s2">proxy</span><span class="s0">);</span>
	          <span class="s2">hasError </span><span class="s0">= </span><span class="s1">false</span><span class="s0">;</span>
	        <span class="s0">} </span><span class="s1">finally </span><span class="s0">{</span>
	          <span class="s4">// finally instead of catch + rethrow better preserves original stack</span>
	          <span class="s1">if </span><span class="s0">(</span><span class="s2">hasError</span><span class="s0">) </span><span class="s2">revokeScope</span><span class="s0">(</span><span class="s2">scope</span><span class="s0">);</span><span class="s1">else </span><span class="s2">leaveScope</span><span class="s0">(</span><span class="s2">scope</span><span class="s0">);</span>
	        <span class="s0">}</span>

	        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s2">Promise </span><span class="s0">!== </span><span class="s3">&quot;undefined&quot; </span><span class="s0">&amp;&amp; </span><span class="s2">result </span><span class="s1">instanceof </span><span class="s2">Promise</span><span class="s0">) {</span>
	          <span class="s1">return </span><span class="s2">result</span><span class="s0">.</span><span class="s2">then</span><span class="s0">(</span><span class="s1">function </span><span class="s0">(</span><span class="s2">result</span><span class="s0">) {</span>
	            <span class="s2">usePatchesInScope</span><span class="s0">(</span><span class="s2">scope</span><span class="s0">, </span><span class="s2">patchListener</span><span class="s0">);</span>
	            <span class="s1">return </span><span class="s2">processResult</span><span class="s0">(</span><span class="s2">result</span><span class="s0">, </span><span class="s2">scope</span><span class="s0">);</span>
	          <span class="s0">}, </span><span class="s1">function </span><span class="s0">(</span><span class="s2">error</span><span class="s0">) {</span>
	            <span class="s2">revokeScope</span><span class="s0">(</span><span class="s2">scope</span><span class="s0">);</span>
	            <span class="s1">throw </span><span class="s2">error</span><span class="s0">;</span>
	          <span class="s0">});</span>
	        <span class="s0">}</span>

	        <span class="s2">usePatchesInScope</span><span class="s0">(</span><span class="s2">scope</span><span class="s0">, </span><span class="s2">patchListener</span><span class="s0">);</span>
	        <span class="s1">return </span><span class="s2">processResult</span><span class="s0">(</span><span class="s2">result</span><span class="s0">, </span><span class="s2">scope</span><span class="s0">);</span>
	      <span class="s0">} </span><span class="s1">else if </span><span class="s0">(!</span><span class="s2">base </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s2">base </span><span class="s0">!== </span><span class="s3">&quot;object&quot;</span><span class="s0">) {</span>
	        <span class="s2">result </span><span class="s0">= </span><span class="s2">recipe</span><span class="s0">(</span><span class="s2">base</span><span class="s0">);</span>
	        <span class="s1">if </span><span class="s0">(</span><span class="s2">result </span><span class="s0">=== </span><span class="s2">undefined</span><span class="s0">) </span><span class="s2">result </span><span class="s0">= </span><span class="s2">base</span><span class="s0">;</span>
	        <span class="s1">if </span><span class="s0">(</span><span class="s2">result </span><span class="s0">=== </span><span class="s2">NOTHING</span><span class="s0">) </span><span class="s2">result </span><span class="s0">= </span><span class="s2">undefined</span><span class="s0">;</span>
	        <span class="s1">if </span><span class="s0">(</span><span class="s2">_this</span><span class="s0">.</span><span class="s2">autoFreeze_</span><span class="s0">) </span><span class="s2">freeze</span><span class="s0">(</span><span class="s2">result</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>

	        <span class="s1">if </span><span class="s0">(</span><span class="s2">patchListener</span><span class="s0">) {</span>
	          <span class="s1">var </span><span class="s2">p </span><span class="s0">= [];</span>
	          <span class="s1">var </span><span class="s2">ip </span><span class="s0">= [];</span>
	          <span class="s2">getPlugin</span><span class="s0">(</span><span class="s3">&quot;Patches&quot;</span><span class="s0">).</span><span class="s2">generateReplacementPatches_</span><span class="s0">(</span><span class="s2">base</span><span class="s0">, </span><span class="s2">result</span><span class="s0">, </span><span class="s2">p</span><span class="s0">, </span><span class="s2">ip</span><span class="s0">);</span>
	          <span class="s2">patchListener</span><span class="s0">(</span><span class="s2">p</span><span class="s0">, </span><span class="s2">ip</span><span class="s0">);</span>
	        <span class="s0">}</span>

	        <span class="s1">return </span><span class="s2">result</span><span class="s0">;</span>
	      <span class="s0">} </span><span class="s1">else </span><span class="s2">die</span><span class="s0">(</span><span class="s6">21</span><span class="s0">, </span><span class="s2">base</span><span class="s0">);</span>
	    <span class="s0">};</span>

	    <span class="s1">this</span><span class="s0">.</span><span class="s2">produceWithPatches </span><span class="s0">= </span><span class="s1">function </span><span class="s0">(</span><span class="s2">base</span><span class="s0">, </span><span class="s2">recipe</span><span class="s0">) {</span>
	      <span class="s4">// curried invocation</span>
	      <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s2">base </span><span class="s0">=== </span><span class="s3">&quot;function&quot;</span><span class="s0">) {</span>
	        <span class="s1">return function </span><span class="s0">(</span><span class="s2">state</span><span class="s0">) {</span>
	          <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s2">_len2 </span><span class="s0">= </span><span class="s2">arguments</span><span class="s0">.</span><span class="s2">length</span><span class="s0">, </span><span class="s2">args </span><span class="s0">= </span><span class="s1">new </span><span class="s2">Array</span><span class="s0">(</span><span class="s2">_len2 </span><span class="s0">&gt; </span><span class="s6">1 </span><span class="s0">? </span><span class="s2">_len2 </span><span class="s0">- </span><span class="s6">1 </span><span class="s0">: </span><span class="s6">0</span><span class="s0">), </span><span class="s2">_key2 </span><span class="s0">= </span><span class="s6">1</span><span class="s0">; </span><span class="s2">_key2 </span><span class="s0">&lt; </span><span class="s2">_len2</span><span class="s0">; </span><span class="s2">_key2</span><span class="s0">++) {</span>
	            <span class="s2">args</span><span class="s0">[</span><span class="s2">_key2 </span><span class="s0">- </span><span class="s6">1</span><span class="s0">] = </span><span class="s2">arguments</span><span class="s0">[</span><span class="s2">_key2</span><span class="s0">];</span>
	          <span class="s0">}</span>

	          <span class="s1">return </span><span class="s2">_this</span><span class="s0">.</span><span class="s2">produceWithPatches</span><span class="s0">(</span><span class="s2">state</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(</span><span class="s2">draft</span><span class="s0">) {</span>
	            <span class="s1">return </span><span class="s2">base</span><span class="s0">.</span><span class="s2">apply</span><span class="s0">(</span><span class="s1">void </span><span class="s6">0</span><span class="s0">, [</span><span class="s2">draft</span><span class="s0">].</span><span class="s2">concat</span><span class="s0">(</span><span class="s2">args</span><span class="s0">));</span>
	          <span class="s0">});</span>
	        <span class="s0">};</span>
	      <span class="s0">}</span>

	      <span class="s1">var </span><span class="s2">patches</span><span class="s0">, </span><span class="s2">inversePatches</span><span class="s0">;</span>

	      <span class="s1">var </span><span class="s2">result </span><span class="s0">= </span><span class="s2">_this</span><span class="s0">.</span><span class="s2">produce</span><span class="s0">(</span><span class="s2">base</span><span class="s0">, </span><span class="s2">recipe</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(</span><span class="s2">p</span><span class="s0">, </span><span class="s2">ip</span><span class="s0">) {</span>
	        <span class="s2">patches </span><span class="s0">= </span><span class="s2">p</span><span class="s0">;</span>
	        <span class="s2">inversePatches </span><span class="s0">= </span><span class="s2">ip</span><span class="s0">;</span>
	      <span class="s0">});</span>

	      <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s2">Promise </span><span class="s0">!== </span><span class="s3">&quot;undefined&quot; </span><span class="s0">&amp;&amp; </span><span class="s2">result </span><span class="s1">instanceof </span><span class="s2">Promise</span><span class="s0">) {</span>
	        <span class="s1">return </span><span class="s2">result</span><span class="s0">.</span><span class="s2">then</span><span class="s0">(</span><span class="s1">function </span><span class="s0">(</span><span class="s2">nextState</span><span class="s0">) {</span>
	          <span class="s1">return </span><span class="s0">[</span><span class="s2">nextState</span><span class="s0">, </span><span class="s2">patches</span><span class="s0">, </span><span class="s2">inversePatches</span><span class="s0">];</span>
	        <span class="s0">});</span>
	      <span class="s0">}</span>

	      <span class="s1">return </span><span class="s0">[</span><span class="s2">result</span><span class="s0">, </span><span class="s2">patches</span><span class="s0">, </span><span class="s2">inversePatches</span><span class="s0">];</span>
	    <span class="s0">};</span>

	    <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">(</span><span class="s2">config </span><span class="s0">=== </span><span class="s1">null </span><span class="s0">|| </span><span class="s2">config </span><span class="s0">=== </span><span class="s1">void </span><span class="s6">0 </span><span class="s0">? </span><span class="s1">void </span><span class="s6">0 </span><span class="s0">: </span><span class="s2">config</span><span class="s0">.</span><span class="s2">useProxies</span><span class="s0">) === </span><span class="s3">&quot;boolean&quot;</span><span class="s0">) </span><span class="s1">this</span><span class="s0">.</span><span class="s2">setUseProxies</span><span class="s0">(</span><span class="s2">config</span><span class="s0">.</span><span class="s2">useProxies</span><span class="s0">);</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">(</span><span class="s2">config </span><span class="s0">=== </span><span class="s1">null </span><span class="s0">|| </span><span class="s2">config </span><span class="s0">=== </span><span class="s1">void </span><span class="s6">0 </span><span class="s0">? </span><span class="s1">void </span><span class="s6">0 </span><span class="s0">: </span><span class="s2">config</span><span class="s0">.</span><span class="s2">autoFreeze</span><span class="s0">) === </span><span class="s3">&quot;boolean&quot;</span><span class="s0">) </span><span class="s1">this</span><span class="s0">.</span><span class="s2">setAutoFreeze</span><span class="s0">(</span><span class="s2">config</span><span class="s0">.</span><span class="s2">autoFreeze</span><span class="s0">);</span>
	  <span class="s0">}</span>

	  <span class="s1">var </span><span class="s2">_proto </span><span class="s0">= </span><span class="s2">Immer</span><span class="s0">.</span><span class="s2">prototype</span><span class="s0">;</span>

	  <span class="s2">_proto</span><span class="s0">.</span><span class="s2">createDraft </span><span class="s0">= </span><span class="s1">function </span><span class="s2">createDraft</span><span class="s0">(</span><span class="s2">base</span><span class="s0">) {</span>
	    <span class="s1">if </span><span class="s0">(!</span><span class="s2">isDraftable</span><span class="s0">(</span><span class="s2">base</span><span class="s0">)) </span><span class="s2">die</span><span class="s0">(</span><span class="s6">8</span><span class="s0">);</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s2">isDraft</span><span class="s0">(</span><span class="s2">base</span><span class="s0">)) </span><span class="s2">base </span><span class="s0">= </span><span class="s2">current</span><span class="s0">(</span><span class="s2">base</span><span class="s0">);</span>
	    <span class="s1">var </span><span class="s2">scope </span><span class="s0">= </span><span class="s2">enterScope</span><span class="s0">(</span><span class="s1">this</span><span class="s0">);</span>
	    <span class="s1">var </span><span class="s2">proxy </span><span class="s0">= </span><span class="s2">createProxy</span><span class="s0">(</span><span class="s1">this</span><span class="s0">, </span><span class="s2">base</span><span class="s0">, </span><span class="s2">undefined</span><span class="s0">);</span>
	    <span class="s2">proxy</span><span class="s0">[</span><span class="s2">DRAFT_STATE</span><span class="s0">].</span><span class="s2">isManual_ </span><span class="s0">= </span><span class="s1">true</span><span class="s0">;</span>
	    <span class="s2">leaveScope</span><span class="s0">(</span><span class="s2">scope</span><span class="s0">);</span>
	    <span class="s1">return </span><span class="s2">proxy</span><span class="s0">;</span>
	  <span class="s0">};</span>

	  <span class="s2">_proto</span><span class="s0">.</span><span class="s2">finishDraft </span><span class="s0">= </span><span class="s1">function </span><span class="s2">finishDraft</span><span class="s0">(</span><span class="s2">draft</span><span class="s0">, </span><span class="s2">patchListener</span><span class="s0">) {</span>
	    <span class="s1">var </span><span class="s2">state </span><span class="s0">= </span><span class="s2">draft </span><span class="s0">&amp;&amp; </span><span class="s2">draft</span><span class="s0">[</span><span class="s2">DRAFT_STATE</span><span class="s0">];</span>

	    <span class="s0">{</span>
	      <span class="s1">if </span><span class="s0">(!</span><span class="s2">state </span><span class="s0">|| !</span><span class="s2">state</span><span class="s0">.</span><span class="s2">isManual_</span><span class="s0">) </span><span class="s2">die</span><span class="s0">(</span><span class="s6">9</span><span class="s0">);</span>
	      <span class="s1">if </span><span class="s0">(</span><span class="s2">state</span><span class="s0">.</span><span class="s2">finalized_</span><span class="s0">) </span><span class="s2">die</span><span class="s0">(</span><span class="s6">10</span><span class="s0">);</span>
	    <span class="s0">}</span>

	    <span class="s1">var </span><span class="s2">scope </span><span class="s0">= </span><span class="s2">state</span><span class="s0">.</span><span class="s2">scope_</span><span class="s0">;</span>
	    <span class="s2">usePatchesInScope</span><span class="s0">(</span><span class="s2">scope</span><span class="s0">, </span><span class="s2">patchListener</span><span class="s0">);</span>
	    <span class="s1">return </span><span class="s2">processResult</span><span class="s0">(</span><span class="s2">undefined</span><span class="s0">, </span><span class="s2">scope</span><span class="s0">);</span>
	  <span class="s0">}</span>
	  <span class="s5">/**</span>
	   <span class="s5">* Pass true to automatically freeze all copies created by Immer.</span>
	   <span class="s5">*</span>
	   <span class="s5">* By default, auto-freezing is enabled.</span>
	   <span class="s5">*/</span>
	  <span class="s0">;</span>

	  <span class="s2">_proto</span><span class="s0">.</span><span class="s2">setAutoFreeze </span><span class="s0">= </span><span class="s1">function </span><span class="s2">setAutoFreeze</span><span class="s0">(</span><span class="s2">value</span><span class="s0">) {</span>
	    <span class="s1">this</span><span class="s0">.</span><span class="s2">autoFreeze_ </span><span class="s0">= </span><span class="s2">value</span><span class="s0">;</span>
	  <span class="s0">}</span>
	  <span class="s5">/**</span>
	   <span class="s5">* Pass true to use the ES2015 `Proxy` class when creating drafts, which is</span>
	   <span class="s5">* always faster than using ES5 proxies.</span>
	   <span class="s5">*</span>
	   <span class="s5">* By default, feature detection is used, so calling this is rarely necessary.</span>
	   <span class="s5">*/</span>
	  <span class="s0">;</span>

	  <span class="s2">_proto</span><span class="s0">.</span><span class="s2">setUseProxies </span><span class="s0">= </span><span class="s1">function </span><span class="s2">setUseProxies</span><span class="s0">(</span><span class="s2">value</span><span class="s0">) {</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s2">value </span><span class="s0">&amp;&amp; !</span><span class="s2">hasProxies</span><span class="s0">) {</span>
	      <span class="s2">die</span><span class="s0">(</span><span class="s6">20</span><span class="s0">);</span>
	    <span class="s0">}</span>

	    <span class="s1">this</span><span class="s0">.</span><span class="s2">useProxies_ </span><span class="s0">= </span><span class="s2">value</span><span class="s0">;</span>
	  <span class="s0">};</span>

	  <span class="s2">_proto</span><span class="s0">.</span><span class="s2">applyPatches </span><span class="s0">= </span><span class="s1">function </span><span class="s2">applyPatches</span><span class="s0">(</span><span class="s2">base</span><span class="s0">, </span><span class="s2">patches</span><span class="s0">) {</span>
	    <span class="s4">// If a patch replaces the entire state, take that replacement as base</span>
	    <span class="s4">// before applying patches</span>
	    <span class="s1">var </span><span class="s2">i</span><span class="s0">;</span>

	    <span class="s1">for </span><span class="s0">(</span><span class="s2">i </span><span class="s0">= </span><span class="s2">patches</span><span class="s0">.</span><span class="s2">length </span><span class="s0">- </span><span class="s6">1</span><span class="s0">; </span><span class="s2">i </span><span class="s0">&gt;= </span><span class="s6">0</span><span class="s0">; </span><span class="s2">i</span><span class="s0">--) {</span>
	      <span class="s1">var </span><span class="s2">patch </span><span class="s0">= </span><span class="s2">patches</span><span class="s0">[</span><span class="s2">i</span><span class="s0">];</span>

	      <span class="s1">if </span><span class="s0">(</span><span class="s2">patch</span><span class="s0">.</span><span class="s2">path</span><span class="s0">.</span><span class="s2">length </span><span class="s0">=== </span><span class="s6">0 </span><span class="s0">&amp;&amp; </span><span class="s2">patch</span><span class="s0">.</span><span class="s2">op </span><span class="s0">=== </span><span class="s3">&quot;replace&quot;</span><span class="s0">) {</span>
	        <span class="s2">base </span><span class="s0">= </span><span class="s2">patch</span><span class="s0">.</span><span class="s2">value</span><span class="s0">;</span>
	        <span class="s1">break</span><span class="s0">;</span>
	      <span class="s0">}</span>
	    <span class="s0">} </span><span class="s4">// If there was a patch that replaced the entire state, start from the</span>
	    <span class="s4">// patch after that.</span>


	    <span class="s1">if </span><span class="s0">(</span><span class="s2">i </span><span class="s0">&gt; -</span><span class="s6">1</span><span class="s0">) {</span>
	      <span class="s2">patches </span><span class="s0">= </span><span class="s2">patches</span><span class="s0">.</span><span class="s2">slice</span><span class="s0">(</span><span class="s2">i </span><span class="s0">+ </span><span class="s6">1</span><span class="s0">);</span>
	    <span class="s0">}</span>

	    <span class="s1">var </span><span class="s2">applyPatchesImpl </span><span class="s0">= </span><span class="s2">getPlugin</span><span class="s0">(</span><span class="s3">&quot;Patches&quot;</span><span class="s0">).</span><span class="s2">applyPatches_</span><span class="s0">;</span>

	    <span class="s1">if </span><span class="s0">(</span><span class="s2">isDraft</span><span class="s0">(</span><span class="s2">base</span><span class="s0">)) {</span>
	      <span class="s4">// N.B: never hits if some patch a replacement, patches are never drafts</span>
	      <span class="s1">return </span><span class="s2">applyPatchesImpl</span><span class="s0">(</span><span class="s2">base</span><span class="s0">, </span><span class="s2">patches</span><span class="s0">);</span>
	    <span class="s0">} </span><span class="s4">// Otherwise, produce a copy of the base state.</span>


	    <span class="s1">return this</span><span class="s0">.</span><span class="s2">produce</span><span class="s0">(</span><span class="s2">base</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(</span><span class="s2">draft</span><span class="s0">) {</span>
	      <span class="s1">return </span><span class="s2">applyPatchesImpl</span><span class="s0">(</span><span class="s2">draft</span><span class="s0">, </span><span class="s2">patches</span><span class="s0">);</span>
	    <span class="s0">});</span>
	  <span class="s0">};</span>

	  <span class="s1">return </span><span class="s2">Immer</span><span class="s0">;</span>
	<span class="s0">}();</span>
	<span class="s1">function </span><span class="s2">createProxy</span><span class="s0">(</span><span class="s2">immer</span><span class="s0">, </span><span class="s2">value</span><span class="s0">, </span><span class="s2">parent</span><span class="s0">) {</span>
	  <span class="s4">// precondition: createProxy should be guarded by isDraftable, so we know we can safely draft</span>
	  <span class="s1">var </span><span class="s2">draft </span><span class="s0">= </span><span class="s2">isMap</span><span class="s0">(</span><span class="s2">value</span><span class="s0">) ? </span><span class="s2">getPlugin</span><span class="s0">(</span><span class="s3">&quot;MapSet&quot;</span><span class="s0">).</span><span class="s2">proxyMap_</span><span class="s0">(</span><span class="s2">value</span><span class="s0">, </span><span class="s2">parent</span><span class="s0">) : </span><span class="s2">isSet</span><span class="s0">(</span><span class="s2">value</span><span class="s0">) ? </span><span class="s2">getPlugin</span><span class="s0">(</span><span class="s3">&quot;MapSet&quot;</span><span class="s0">).</span><span class="s2">proxySet_</span><span class="s0">(</span><span class="s2">value</span><span class="s0">, </span><span class="s2">parent</span><span class="s0">) : </span><span class="s2">immer</span><span class="s0">.</span><span class="s2">useProxies_ </span><span class="s0">? </span><span class="s2">createProxyProxy</span><span class="s0">(</span><span class="s2">value</span><span class="s0">, </span><span class="s2">parent</span><span class="s0">) : </span><span class="s2">getPlugin</span><span class="s0">(</span><span class="s3">&quot;ES5&quot;</span><span class="s0">).</span><span class="s2">createES5Proxy_</span><span class="s0">(</span><span class="s2">value</span><span class="s0">, </span><span class="s2">parent</span><span class="s0">);</span>
	  <span class="s1">var </span><span class="s2">scope </span><span class="s0">= </span><span class="s2">parent </span><span class="s0">? </span><span class="s2">parent</span><span class="s0">.</span><span class="s2">scope_ </span><span class="s0">: </span><span class="s2">getCurrentScope</span><span class="s0">();</span>
	  <span class="s2">scope</span><span class="s0">.</span><span class="s2">drafts_</span><span class="s0">.</span><span class="s2">push</span><span class="s0">(</span><span class="s2">draft</span><span class="s0">);</span>
	  <span class="s1">return </span><span class="s2">draft</span><span class="s0">;</span>
	<span class="s0">}</span>

	<span class="s1">function </span><span class="s2">current</span><span class="s0">(</span><span class="s2">value</span><span class="s0">) {</span>
	  <span class="s1">if </span><span class="s0">(!</span><span class="s2">isDraft</span><span class="s0">(</span><span class="s2">value</span><span class="s0">)) </span><span class="s2">die</span><span class="s0">(</span><span class="s6">22</span><span class="s0">, </span><span class="s2">value</span><span class="s0">);</span>
	  <span class="s1">return </span><span class="s2">currentImpl</span><span class="s0">(</span><span class="s2">value</span><span class="s0">);</span>
	<span class="s0">}</span>

	<span class="s1">function </span><span class="s2">currentImpl</span><span class="s0">(</span><span class="s2">value</span><span class="s0">) {</span>
	  <span class="s1">if </span><span class="s0">(!</span><span class="s2">isDraftable</span><span class="s0">(</span><span class="s2">value</span><span class="s0">)) </span><span class="s1">return </span><span class="s2">value</span><span class="s0">;</span>
	  <span class="s1">var </span><span class="s2">state </span><span class="s0">= </span><span class="s2">value</span><span class="s0">[</span><span class="s2">DRAFT_STATE</span><span class="s0">];</span>
	  <span class="s1">var </span><span class="s2">copy</span><span class="s0">;</span>
	  <span class="s1">var </span><span class="s2">archType </span><span class="s0">= </span><span class="s2">getArchtype</span><span class="s0">(</span><span class="s2">value</span><span class="s0">);</span>

	  <span class="s1">if </span><span class="s0">(</span><span class="s2">state</span><span class="s0">) {</span>
	    <span class="s1">if </span><span class="s0">(!</span><span class="s2">state</span><span class="s0">.</span><span class="s2">modified_ </span><span class="s0">&amp;&amp; (</span><span class="s2">state</span><span class="s0">.</span><span class="s2">type_ </span><span class="s0">&lt; </span><span class="s6">4 </span><span class="s0">|| !</span><span class="s2">getPlugin</span><span class="s0">(</span><span class="s3">&quot;ES5&quot;</span><span class="s0">).</span><span class="s2">hasChanges_</span><span class="s0">(</span><span class="s2">state</span><span class="s0">))) </span><span class="s1">return </span><span class="s2">state</span><span class="s0">.</span><span class="s2">base_</span><span class="s0">; </span><span class="s4">// Optimization: avoid generating new drafts during copying</span>

	    <span class="s2">state</span><span class="s0">.</span><span class="s2">finalized_ </span><span class="s0">= </span><span class="s1">true</span><span class="s0">;</span>
	    <span class="s2">copy </span><span class="s0">= </span><span class="s2">copyHelper</span><span class="s0">(</span><span class="s2">value</span><span class="s0">, </span><span class="s2">archType</span><span class="s0">);</span>
	    <span class="s2">state</span><span class="s0">.</span><span class="s2">finalized_ </span><span class="s0">= </span><span class="s1">false</span><span class="s0">;</span>
	  <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
	    <span class="s2">copy </span><span class="s0">= </span><span class="s2">copyHelper</span><span class="s0">(</span><span class="s2">value</span><span class="s0">, </span><span class="s2">archType</span><span class="s0">);</span>
	  <span class="s0">}</span>

	  <span class="s2">each</span><span class="s0">(</span><span class="s2">copy</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(</span><span class="s2">key</span><span class="s0">, </span><span class="s2">childValue</span><span class="s0">) {</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s2">state </span><span class="s0">&amp;&amp; </span><span class="s2">get</span><span class="s0">(</span><span class="s2">state</span><span class="s0">.</span><span class="s2">base_</span><span class="s0">, </span><span class="s2">key</span><span class="s0">) === </span><span class="s2">childValue</span><span class="s0">) </span><span class="s1">return</span><span class="s0">; </span><span class="s4">// no need to copy or search in something that didn't change</span>

	    <span class="s2">set</span><span class="s0">(</span><span class="s2">copy</span><span class="s0">, </span><span class="s2">key</span><span class="s0">, </span><span class="s2">currentImpl</span><span class="s0">(</span><span class="s2">childValue</span><span class="s0">));</span>
	  <span class="s0">}); </span><span class="s4">// In the future, we might consider freezing here, based on the current settings</span>

	  <span class="s1">return </span><span class="s2">archType </span><span class="s0">=== </span><span class="s6">3</span>
	  <span class="s4">/* Set */</span>
	  <span class="s0">? </span><span class="s1">new </span><span class="s2">Set</span><span class="s0">(</span><span class="s2">copy</span><span class="s0">) : </span><span class="s2">copy</span><span class="s0">;</span>
	<span class="s0">}</span>

	<span class="s1">function </span><span class="s2">copyHelper</span><span class="s0">(</span><span class="s2">value</span><span class="s0">, </span><span class="s2">archType</span><span class="s0">) {</span>
	  <span class="s4">// creates a shallow copy, even if it is a map or set</span>
	  <span class="s1">switch </span><span class="s0">(</span><span class="s2">archType</span><span class="s0">) {</span>
	    <span class="s1">case </span><span class="s6">2</span>
	    <span class="s4">/* Map */</span>
	    <span class="s0">:</span>
	      <span class="s1">return new </span><span class="s2">Map</span><span class="s0">(</span><span class="s2">value</span><span class="s0">);</span>

	    <span class="s1">case </span><span class="s6">3</span>
	    <span class="s4">/* Set */</span>
	    <span class="s0">:</span>
	      <span class="s4">// Set will be cloned as array temporarily, so that we can replace individual items</span>
	      <span class="s1">return </span><span class="s2">Array</span><span class="s0">.</span><span class="s2">from</span><span class="s0">(</span><span class="s2">value</span><span class="s0">);</span>
	  <span class="s0">}</span>

	  <span class="s1">return </span><span class="s2">shallowCopy</span><span class="s0">(</span><span class="s2">value</span><span class="s0">);</span>
	<span class="s0">}</span>

	<span class="s1">function </span><span class="s2">enableES5</span><span class="s0">() {</span>
	  <span class="s1">function </span><span class="s2">willFinalizeES5_</span><span class="s0">(</span><span class="s2">scope</span><span class="s0">, </span><span class="s2">result</span><span class="s0">, </span><span class="s2">isReplaced</span><span class="s0">) {</span>
	    <span class="s1">if </span><span class="s0">(!</span><span class="s2">isReplaced</span><span class="s0">) {</span>
	      <span class="s1">if </span><span class="s0">(</span><span class="s2">scope</span><span class="s0">.</span><span class="s2">patches_</span><span class="s0">) {</span>
	        <span class="s2">markChangesRecursively</span><span class="s0">(</span><span class="s2">scope</span><span class="s0">.</span><span class="s2">drafts_</span><span class="s0">[</span><span class="s6">0</span><span class="s0">]);</span>
	      <span class="s0">} </span><span class="s4">// This is faster when we don't care about which attributes changed.</span>


	      <span class="s2">markChangesSweep</span><span class="s0">(</span><span class="s2">scope</span><span class="s0">.</span><span class="s2">drafts_</span><span class="s0">);</span>
	    <span class="s0">} </span><span class="s4">// When a child draft is returned, look for changes.</span>
	    <span class="s1">else if </span><span class="s0">(</span><span class="s2">isDraft</span><span class="s0">(</span><span class="s2">result</span><span class="s0">) &amp;&amp; </span><span class="s2">result</span><span class="s0">[</span><span class="s2">DRAFT_STATE</span><span class="s0">].</span><span class="s2">scope_ </span><span class="s0">=== </span><span class="s2">scope</span><span class="s0">) {</span>
	        <span class="s2">markChangesSweep</span><span class="s0">(</span><span class="s2">scope</span><span class="s0">.</span><span class="s2">drafts_</span><span class="s0">);</span>
	      <span class="s0">}</span>
	  <span class="s0">}</span>

	  <span class="s1">function </span><span class="s2">createES5Draft</span><span class="s0">(</span><span class="s2">isArray</span><span class="s0">, </span><span class="s2">base</span><span class="s0">) {</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s2">isArray</span><span class="s0">) {</span>
	      <span class="s1">var </span><span class="s2">draft </span><span class="s0">= </span><span class="s1">new </span><span class="s2">Array</span><span class="s0">(</span><span class="s2">base</span><span class="s0">.</span><span class="s2">length</span><span class="s0">);</span>

	      <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s2">i </span><span class="s0">= </span><span class="s6">0</span><span class="s0">; </span><span class="s2">i </span><span class="s0">&lt; </span><span class="s2">base</span><span class="s0">.</span><span class="s2">length</span><span class="s0">; </span><span class="s2">i</span><span class="s0">++) {</span>
	        <span class="s2">Object</span><span class="s0">.</span><span class="s2">defineProperty</span><span class="s0">(</span><span class="s2">draft</span><span class="s0">, </span><span class="s3">&quot;&quot; </span><span class="s0">+ </span><span class="s2">i</span><span class="s0">, </span><span class="s2">proxyProperty</span><span class="s0">(</span><span class="s2">i</span><span class="s0">, </span><span class="s1">true</span><span class="s0">));</span>
	      <span class="s0">}</span>

	      <span class="s1">return </span><span class="s2">draft</span><span class="s0">;</span>
	    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
	      <span class="s1">var </span><span class="s2">_descriptors </span><span class="s0">= </span><span class="s2">getOwnPropertyDescriptors</span><span class="s0">(</span><span class="s2">base</span><span class="s0">);</span>

	      <span class="s1">delete </span><span class="s2">_descriptors</span><span class="s0">[</span><span class="s2">DRAFT_STATE</span><span class="s0">];</span>
	      <span class="s1">var </span><span class="s2">keys </span><span class="s0">= </span><span class="s2">ownKeys</span><span class="s0">(</span><span class="s2">_descriptors</span><span class="s0">);</span>

	      <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s2">_i </span><span class="s0">= </span><span class="s6">0</span><span class="s0">; </span><span class="s2">_i </span><span class="s0">&lt; </span><span class="s2">keys</span><span class="s0">.</span><span class="s2">length</span><span class="s0">; </span><span class="s2">_i</span><span class="s0">++) {</span>
	        <span class="s1">var </span><span class="s2">key </span><span class="s0">= </span><span class="s2">keys</span><span class="s0">[</span><span class="s2">_i</span><span class="s0">];</span>
	        <span class="s2">_descriptors</span><span class="s0">[</span><span class="s2">key</span><span class="s0">] = </span><span class="s2">proxyProperty</span><span class="s0">(</span><span class="s2">key</span><span class="s0">, </span><span class="s2">isArray </span><span class="s0">|| !!</span><span class="s2">_descriptors</span><span class="s0">[</span><span class="s2">key</span><span class="s0">].</span><span class="s2">enumerable</span><span class="s0">);</span>
	      <span class="s0">}</span>

	      <span class="s1">return </span><span class="s2">Object</span><span class="s0">.</span><span class="s2">create</span><span class="s0">(</span><span class="s2">Object</span><span class="s0">.</span><span class="s2">getPrototypeOf</span><span class="s0">(</span><span class="s2">base</span><span class="s0">), </span><span class="s2">_descriptors</span><span class="s0">);</span>
	    <span class="s0">}</span>
	  <span class="s0">}</span>

	  <span class="s1">function </span><span class="s2">createES5Proxy_</span><span class="s0">(</span><span class="s2">base</span><span class="s0">, </span><span class="s2">parent</span><span class="s0">) {</span>
	    <span class="s1">var </span><span class="s2">isArray </span><span class="s0">= </span><span class="s2">Array</span><span class="s0">.</span><span class="s2">isArray</span><span class="s0">(</span><span class="s2">base</span><span class="s0">);</span>
	    <span class="s1">var </span><span class="s2">draft </span><span class="s0">= </span><span class="s2">createES5Draft</span><span class="s0">(</span><span class="s2">isArray</span><span class="s0">, </span><span class="s2">base</span><span class="s0">);</span>
	    <span class="s1">var </span><span class="s2">state </span><span class="s0">= {</span>
	      <span class="s2">type_</span><span class="s0">: </span><span class="s2">isArray </span><span class="s0">? </span><span class="s6">5</span>
	      <span class="s4">/* ES5Array */</span>
	      <span class="s0">: </span><span class="s6">4</span>
	      <span class="s4">/* ES5Object */</span>
	      <span class="s0">,</span>
	      <span class="s2">scope_</span><span class="s0">: </span><span class="s2">parent </span><span class="s0">? </span><span class="s2">parent</span><span class="s0">.</span><span class="s2">scope_ </span><span class="s0">: </span><span class="s2">getCurrentScope</span><span class="s0">(),</span>
	      <span class="s2">modified_</span><span class="s0">: </span><span class="s1">false</span><span class="s0">,</span>
	      <span class="s2">finalized_</span><span class="s0">: </span><span class="s1">false</span><span class="s0">,</span>
	      <span class="s2">assigned_</span><span class="s0">: {},</span>
	      <span class="s2">parent_</span><span class="s0">: </span><span class="s2">parent</span><span class="s0">,</span>
	      <span class="s4">// base is the object we are drafting</span>
	      <span class="s2">base_</span><span class="s0">: </span><span class="s2">base</span><span class="s0">,</span>
	      <span class="s4">// draft is the draft object itself, that traps all reads and reads from either the base (if unmodified) or copy (if modified)</span>
	      <span class="s2">draft_</span><span class="s0">: </span><span class="s2">draft</span><span class="s0">,</span>
	      <span class="s2">copy_</span><span class="s0">: </span><span class="s1">null</span><span class="s0">,</span>
	      <span class="s2">revoked_</span><span class="s0">: </span><span class="s1">false</span><span class="s0">,</span>
	      <span class="s2">isManual_</span><span class="s0">: </span><span class="s1">false</span>
	    <span class="s0">};</span>
	    <span class="s2">Object</span><span class="s0">.</span><span class="s2">defineProperty</span><span class="s0">(</span><span class="s2">draft</span><span class="s0">, </span><span class="s2">DRAFT_STATE</span><span class="s0">, {</span>
	      <span class="s2">value</span><span class="s0">: </span><span class="s2">state</span><span class="s0">,</span>
	      <span class="s4">// enumerable: false &lt;- the default</span>
	      <span class="s2">writable</span><span class="s0">: </span><span class="s1">true</span>
	    <span class="s0">});</span>
	    <span class="s1">return </span><span class="s2">draft</span><span class="s0">;</span>
	  <span class="s0">} </span><span class="s4">// property descriptors are recycled to make sure we don't create a get and set closure per property,</span>
	  <span class="s4">// but share them all instead</span>


	  <span class="s1">var </span><span class="s2">descriptors </span><span class="s0">= {};</span>

	  <span class="s1">function </span><span class="s2">proxyProperty</span><span class="s0">(</span><span class="s2">prop</span><span class="s0">, </span><span class="s2">enumerable</span><span class="s0">) {</span>
	    <span class="s1">var </span><span class="s2">desc </span><span class="s0">= </span><span class="s2">descriptors</span><span class="s0">[</span><span class="s2">prop</span><span class="s0">];</span>

	    <span class="s1">if </span><span class="s0">(</span><span class="s2">desc</span><span class="s0">) {</span>
	      <span class="s2">desc</span><span class="s0">.</span><span class="s2">enumerable </span><span class="s0">= </span><span class="s2">enumerable</span><span class="s0">;</span>
	    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
	      <span class="s2">descriptors</span><span class="s0">[</span><span class="s2">prop</span><span class="s0">] = </span><span class="s2">desc </span><span class="s0">= {</span>
	        <span class="s2">configurable</span><span class="s0">: </span><span class="s1">true</span><span class="s0">,</span>
	        <span class="s2">enumerable</span><span class="s0">: </span><span class="s2">enumerable</span><span class="s0">,</span>
	        <span class="s2">get</span><span class="s0">: </span><span class="s1">function </span><span class="s2">get</span><span class="s0">() {</span>
	          <span class="s1">var </span><span class="s2">state </span><span class="s0">= </span><span class="s1">this</span><span class="s0">[</span><span class="s2">DRAFT_STATE</span><span class="s0">];</span>
	          <span class="s2">assertUnrevoked</span><span class="s0">(</span><span class="s2">state</span><span class="s0">); </span><span class="s4">// @ts-ignore</span>

	          <span class="s1">return </span><span class="s2">objectTraps</span><span class="s0">.</span><span class="s2">get</span><span class="s0">(</span><span class="s2">state</span><span class="s0">, </span><span class="s2">prop</span><span class="s0">);</span>
	        <span class="s0">},</span>
	        <span class="s2">set</span><span class="s0">: </span><span class="s1">function </span><span class="s2">set</span><span class="s0">(</span><span class="s2">value</span><span class="s0">) {</span>
	          <span class="s1">var </span><span class="s2">state </span><span class="s0">= </span><span class="s1">this</span><span class="s0">[</span><span class="s2">DRAFT_STATE</span><span class="s0">];</span>
	          <span class="s2">assertUnrevoked</span><span class="s0">(</span><span class="s2">state</span><span class="s0">); </span><span class="s4">// @ts-ignore</span>

	          <span class="s2">objectTraps</span><span class="s0">.</span><span class="s2">set</span><span class="s0">(</span><span class="s2">state</span><span class="s0">, </span><span class="s2">prop</span><span class="s0">, </span><span class="s2">value</span><span class="s0">);</span>
	        <span class="s0">}</span>
	      <span class="s0">};</span>
	    <span class="s0">}</span>

	    <span class="s1">return </span><span class="s2">desc</span><span class="s0">;</span>
	  <span class="s0">} </span><span class="s4">// This looks expensive, but only proxies are visited, and only objects without known changes are scanned.</span>


	  <span class="s1">function </span><span class="s2">markChangesSweep</span><span class="s0">(</span><span class="s2">drafts</span><span class="s0">) {</span>
	    <span class="s4">// The natural order of drafts in the `scope` array is based on when they</span>
	    <span class="s4">// were accessed. By processing drafts in reverse natural order, we have a</span>
	    <span class="s4">// better chance of processing leaf nodes first. When a leaf node is known to</span>
	    <span class="s4">// have changed, we can avoid any traversal of its ancestor nodes.</span>
	    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s2">i </span><span class="s0">= </span><span class="s2">drafts</span><span class="s0">.</span><span class="s2">length </span><span class="s0">- </span><span class="s6">1</span><span class="s0">; </span><span class="s2">i </span><span class="s0">&gt;= </span><span class="s6">0</span><span class="s0">; </span><span class="s2">i</span><span class="s0">--) {</span>
	      <span class="s1">var </span><span class="s2">state </span><span class="s0">= </span><span class="s2">drafts</span><span class="s0">[</span><span class="s2">i</span><span class="s0">][</span><span class="s2">DRAFT_STATE</span><span class="s0">];</span>

	      <span class="s1">if </span><span class="s0">(!</span><span class="s2">state</span><span class="s0">.</span><span class="s2">modified_</span><span class="s0">) {</span>
	        <span class="s1">switch </span><span class="s0">(</span><span class="s2">state</span><span class="s0">.</span><span class="s2">type_</span><span class="s0">) {</span>
	          <span class="s1">case </span><span class="s6">5</span>
	          <span class="s4">/* ES5Array */</span>
	          <span class="s0">:</span>
	            <span class="s1">if </span><span class="s0">(</span><span class="s2">hasArrayChanges</span><span class="s0">(</span><span class="s2">state</span><span class="s0">)) </span><span class="s2">markChanged</span><span class="s0">(</span><span class="s2">state</span><span class="s0">);</span>
	            <span class="s1">break</span><span class="s0">;</span>

	          <span class="s1">case </span><span class="s6">4</span>
	          <span class="s4">/* ES5Object */</span>
	          <span class="s0">:</span>
	            <span class="s1">if </span><span class="s0">(</span><span class="s2">hasObjectChanges</span><span class="s0">(</span><span class="s2">state</span><span class="s0">)) </span><span class="s2">markChanged</span><span class="s0">(</span><span class="s2">state</span><span class="s0">);</span>
	            <span class="s1">break</span><span class="s0">;</span>
	        <span class="s0">}</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>
	  <span class="s0">}</span>

	  <span class="s1">function </span><span class="s2">markChangesRecursively</span><span class="s0">(</span><span class="s2">object</span><span class="s0">) {</span>
	    <span class="s1">if </span><span class="s0">(!</span><span class="s2">object </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s2">object </span><span class="s0">!== </span><span class="s3">&quot;object&quot;</span><span class="s0">) </span><span class="s1">return</span><span class="s0">;</span>
	    <span class="s1">var </span><span class="s2">state </span><span class="s0">= </span><span class="s2">object</span><span class="s0">[</span><span class="s2">DRAFT_STATE</span><span class="s0">];</span>
	    <span class="s1">if </span><span class="s0">(!</span><span class="s2">state</span><span class="s0">) </span><span class="s1">return</span><span class="s0">;</span>
	    <span class="s1">var </span><span class="s2">base_ </span><span class="s0">= </span><span class="s2">state</span><span class="s0">.</span><span class="s2">base_</span><span class="s0">,</span>
	        <span class="s2">draft_ </span><span class="s0">= </span><span class="s2">state</span><span class="s0">.</span><span class="s2">draft_</span><span class="s0">,</span>
	        <span class="s2">assigned_ </span><span class="s0">= </span><span class="s2">state</span><span class="s0">.</span><span class="s2">assigned_</span><span class="s0">,</span>
	        <span class="s2">type_ </span><span class="s0">= </span><span class="s2">state</span><span class="s0">.</span><span class="s2">type_</span><span class="s0">;</span>

	    <span class="s1">if </span><span class="s0">(</span><span class="s2">type_ </span><span class="s0">=== </span><span class="s6">4</span>
	    <span class="s4">/* ES5Object */</span>
	    <span class="s0">) {</span>
	        <span class="s4">// Look for added keys.</span>
	        <span class="s4">// probably there is a faster way to detect changes, as sweep + recurse seems to do some</span>
	        <span class="s4">// unnecessary work.</span>
	        <span class="s4">// also: probably we can store the information we detect here, to speed up tree finalization!</span>
	        <span class="s2">each</span><span class="s0">(</span><span class="s2">draft_</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(</span><span class="s2">key</span><span class="s0">) {</span>
	          <span class="s1">if </span><span class="s0">(</span><span class="s2">key </span><span class="s0">=== </span><span class="s2">DRAFT_STATE</span><span class="s0">) </span><span class="s1">return</span><span class="s0">; </span><span class="s4">// The `undefined` check is a fast path for pre-existing keys.</span>

	          <span class="s1">if </span><span class="s0">(</span><span class="s2">base_</span><span class="s0">[</span><span class="s2">key</span><span class="s0">] === </span><span class="s2">undefined </span><span class="s0">&amp;&amp; !</span><span class="s2">has</span><span class="s0">(</span><span class="s2">base_</span><span class="s0">, </span><span class="s2">key</span><span class="s0">)) {</span>
	            <span class="s2">assigned_</span><span class="s0">[</span><span class="s2">key</span><span class="s0">] = </span><span class="s1">true</span><span class="s0">;</span>
	            <span class="s2">markChanged</span><span class="s0">(</span><span class="s2">state</span><span class="s0">);</span>
	          <span class="s0">} </span><span class="s1">else if </span><span class="s0">(!</span><span class="s2">assigned_</span><span class="s0">[</span><span class="s2">key</span><span class="s0">]) {</span>
	            <span class="s4">// Only untouched properties trigger recursion.</span>
	            <span class="s2">markChangesRecursively</span><span class="s0">(</span><span class="s2">draft_</span><span class="s0">[</span><span class="s2">key</span><span class="s0">]);</span>
	          <span class="s0">}</span>
	        <span class="s0">}); </span><span class="s4">// Look for removed keys.</span>

	        <span class="s2">each</span><span class="s0">(</span><span class="s2">base_</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(</span><span class="s2">key</span><span class="s0">) {</span>
	          <span class="s4">// The `undefined` check is a fast path for pre-existing keys.</span>
	          <span class="s1">if </span><span class="s0">(</span><span class="s2">draft_</span><span class="s0">[</span><span class="s2">key</span><span class="s0">] === </span><span class="s2">undefined </span><span class="s0">&amp;&amp; !</span><span class="s2">has</span><span class="s0">(</span><span class="s2">draft_</span><span class="s0">, </span><span class="s2">key</span><span class="s0">)) {</span>
	            <span class="s2">assigned_</span><span class="s0">[</span><span class="s2">key</span><span class="s0">] = </span><span class="s1">false</span><span class="s0">;</span>
	            <span class="s2">markChanged</span><span class="s0">(</span><span class="s2">state</span><span class="s0">);</span>
	          <span class="s0">}</span>
	        <span class="s0">});</span>
	      <span class="s0">} </span><span class="s1">else if </span><span class="s0">(</span><span class="s2">type_ </span><span class="s0">=== </span><span class="s6">5</span>
	    <span class="s4">/* ES5Array */</span>
	    <span class="s0">) {</span>
	        <span class="s1">if </span><span class="s0">(</span><span class="s2">hasArrayChanges</span><span class="s0">(</span><span class="s2">state</span><span class="s0">)) {</span>
	          <span class="s2">markChanged</span><span class="s0">(</span><span class="s2">state</span><span class="s0">);</span>
	          <span class="s2">assigned_</span><span class="s0">.</span><span class="s2">length </span><span class="s0">= </span><span class="s1">true</span><span class="s0">;</span>
	        <span class="s0">}</span>

	        <span class="s1">if </span><span class="s0">(</span><span class="s2">draft_</span><span class="s0">.</span><span class="s2">length </span><span class="s0">&lt; </span><span class="s2">base_</span><span class="s0">.</span><span class="s2">length</span><span class="s0">) {</span>
	          <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s2">i </span><span class="s0">= </span><span class="s2">draft_</span><span class="s0">.</span><span class="s2">length</span><span class="s0">; </span><span class="s2">i </span><span class="s0">&lt; </span><span class="s2">base_</span><span class="s0">.</span><span class="s2">length</span><span class="s0">; </span><span class="s2">i</span><span class="s0">++) {</span>
	            <span class="s2">assigned_</span><span class="s0">[</span><span class="s2">i</span><span class="s0">] = </span><span class="s1">false</span><span class="s0">;</span>
	          <span class="s0">}</span>
	        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
	          <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s2">_i2 </span><span class="s0">= </span><span class="s2">base_</span><span class="s0">.</span><span class="s2">length</span><span class="s0">; </span><span class="s2">_i2 </span><span class="s0">&lt; </span><span class="s2">draft_</span><span class="s0">.</span><span class="s2">length</span><span class="s0">; </span><span class="s2">_i2</span><span class="s0">++) {</span>
	            <span class="s2">assigned_</span><span class="s0">[</span><span class="s2">_i2</span><span class="s0">] = </span><span class="s1">true</span><span class="s0">;</span>
	          <span class="s0">}</span>
	        <span class="s0">} </span><span class="s4">// Minimum count is enough, the other parts has been processed.</span>


	        <span class="s1">var </span><span class="s2">min </span><span class="s0">= </span><span class="s2">Math</span><span class="s0">.</span><span class="s2">min</span><span class="s0">(</span><span class="s2">draft_</span><span class="s0">.</span><span class="s2">length</span><span class="s0">, </span><span class="s2">base_</span><span class="s0">.</span><span class="s2">length</span><span class="s0">);</span>

	        <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s2">_i3 </span><span class="s0">= </span><span class="s6">0</span><span class="s0">; </span><span class="s2">_i3 </span><span class="s0">&lt; </span><span class="s2">min</span><span class="s0">; </span><span class="s2">_i3</span><span class="s0">++) {</span>
	          <span class="s4">// Only untouched indices trigger recursion.</span>
	          <span class="s1">if </span><span class="s0">(!</span><span class="s2">draft_</span><span class="s0">.</span><span class="s2">hasOwnProperty</span><span class="s0">(</span><span class="s2">_i3</span><span class="s0">)) {</span>
	            <span class="s2">assigned_</span><span class="s0">[</span><span class="s2">_i3</span><span class="s0">] = </span><span class="s1">true</span><span class="s0">;</span>
	          <span class="s0">}</span>

	          <span class="s1">if </span><span class="s0">(</span><span class="s2">assigned_</span><span class="s0">[</span><span class="s2">_i3</span><span class="s0">] === </span><span class="s2">undefined</span><span class="s0">) </span><span class="s2">markChangesRecursively</span><span class="s0">(</span><span class="s2">draft_</span><span class="s0">[</span><span class="s2">_i3</span><span class="s0">]);</span>
	        <span class="s0">}</span>
	      <span class="s0">}</span>
	  <span class="s0">}</span>

	  <span class="s1">function </span><span class="s2">hasObjectChanges</span><span class="s0">(</span><span class="s2">state</span><span class="s0">) {</span>
	    <span class="s1">var </span><span class="s2">base_ </span><span class="s0">= </span><span class="s2">state</span><span class="s0">.</span><span class="s2">base_</span><span class="s0">,</span>
	        <span class="s2">draft_ </span><span class="s0">= </span><span class="s2">state</span><span class="s0">.</span><span class="s2">draft_</span><span class="s0">; </span><span class="s4">// Search for added keys and changed keys. Start at the back, because</span>
	    <span class="s4">// non-numeric keys are ordered by time of definition on the object.</span>

	    <span class="s1">var </span><span class="s2">keys </span><span class="s0">= </span><span class="s2">ownKeys</span><span class="s0">(</span><span class="s2">draft_</span><span class="s0">);</span>

	    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s2">i </span><span class="s0">= </span><span class="s2">keys</span><span class="s0">.</span><span class="s2">length </span><span class="s0">- </span><span class="s6">1</span><span class="s0">; </span><span class="s2">i </span><span class="s0">&gt;= </span><span class="s6">0</span><span class="s0">; </span><span class="s2">i</span><span class="s0">--) {</span>
	      <span class="s1">var </span><span class="s2">key </span><span class="s0">= </span><span class="s2">keys</span><span class="s0">[</span><span class="s2">i</span><span class="s0">];</span>
	      <span class="s1">if </span><span class="s0">(</span><span class="s2">key </span><span class="s0">=== </span><span class="s2">DRAFT_STATE</span><span class="s0">) </span><span class="s1">continue</span><span class="s0">;</span>
	      <span class="s1">var </span><span class="s2">baseValue </span><span class="s0">= </span><span class="s2">base_</span><span class="s0">[</span><span class="s2">key</span><span class="s0">]; </span><span class="s4">// The `undefined` check is a fast path for pre-existing keys.</span>

	      <span class="s1">if </span><span class="s0">(</span><span class="s2">baseValue </span><span class="s0">=== </span><span class="s2">undefined </span><span class="s0">&amp;&amp; !</span><span class="s2">has</span><span class="s0">(</span><span class="s2">base_</span><span class="s0">, </span><span class="s2">key</span><span class="s0">)) {</span>
	        <span class="s1">return true</span><span class="s0">;</span>
	      <span class="s0">} </span><span class="s4">// Once a base key is deleted, future changes go undetected, because its</span>
	      <span class="s4">// descriptor is erased. This branch detects any missed changes.</span>
	      <span class="s1">else </span><span class="s0">{</span>
	          <span class="s1">var </span><span class="s2">value </span><span class="s0">= </span><span class="s2">draft_</span><span class="s0">[</span><span class="s2">key</span><span class="s0">];</span>

	          <span class="s1">var </span><span class="s2">_state </span><span class="s0">= </span><span class="s2">value </span><span class="s0">&amp;&amp; </span><span class="s2">value</span><span class="s0">[</span><span class="s2">DRAFT_STATE</span><span class="s0">];</span>

	          <span class="s1">if </span><span class="s0">(</span><span class="s2">_state </span><span class="s0">? </span><span class="s2">_state</span><span class="s0">.</span><span class="s2">base_ </span><span class="s0">!== </span><span class="s2">baseValue </span><span class="s0">: !</span><span class="s2">is</span><span class="s0">(</span><span class="s2">value</span><span class="s0">, </span><span class="s2">baseValue</span><span class="s0">)) {</span>
	            <span class="s1">return true</span><span class="s0">;</span>
	          <span class="s0">}</span>
	        <span class="s0">}</span>
	    <span class="s0">} </span><span class="s4">// At this point, no keys were added or changed.</span>
	    <span class="s4">// Compare key count to determine if keys were deleted.</span>


	    <span class="s1">var </span><span class="s2">baseIsDraft </span><span class="s0">= !!</span><span class="s2">base_</span><span class="s0">[</span><span class="s2">DRAFT_STATE</span><span class="s0">];</span>
	    <span class="s1">return </span><span class="s2">keys</span><span class="s0">.</span><span class="s2">length </span><span class="s0">!== </span><span class="s2">ownKeys</span><span class="s0">(</span><span class="s2">base_</span><span class="s0">).</span><span class="s2">length </span><span class="s0">+ (</span><span class="s2">baseIsDraft </span><span class="s0">? </span><span class="s6">0 </span><span class="s0">: </span><span class="s6">1</span><span class="s0">); </span><span class="s4">// + 1 to correct for DRAFT_STATE</span>
	  <span class="s0">}</span>

	  <span class="s1">function </span><span class="s2">hasArrayChanges</span><span class="s0">(</span><span class="s2">state</span><span class="s0">) {</span>
	    <span class="s1">var </span><span class="s2">draft_ </span><span class="s0">= </span><span class="s2">state</span><span class="s0">.</span><span class="s2">draft_</span><span class="s0">;</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s2">draft_</span><span class="s0">.</span><span class="s2">length </span><span class="s0">!== </span><span class="s2">state</span><span class="s0">.</span><span class="s2">base_</span><span class="s0">.</span><span class="s2">length</span><span class="s0">) </span><span class="s1">return true</span><span class="s0">; </span><span class="s4">// See #116</span>
	    <span class="s4">// If we first shorten the length, our array interceptors will be removed.</span>
	    <span class="s4">// If after that new items are added, result in the same original length,</span>
	    <span class="s4">// those last items will have no intercepting property.</span>
	    <span class="s4">// So if there is no own descriptor on the last position, we know that items were removed and added</span>
	    <span class="s4">// N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check</span>
	    <span class="s4">// the last one</span>
	    <span class="s4">// last descriptor can be not a trap, if the array was extended</span>

	    <span class="s1">var </span><span class="s2">descriptor </span><span class="s0">= </span><span class="s2">Object</span><span class="s0">.</span><span class="s2">getOwnPropertyDescriptor</span><span class="s0">(</span><span class="s2">draft_</span><span class="s0">, </span><span class="s2">draft_</span><span class="s0">.</span><span class="s2">length </span><span class="s0">- </span><span class="s6">1</span><span class="s0">); </span><span class="s4">// descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)</span>

	    <span class="s1">if </span><span class="s0">(</span><span class="s2">descriptor </span><span class="s0">&amp;&amp; !</span><span class="s2">descriptor</span><span class="s0">.</span><span class="s2">get</span><span class="s0">) </span><span class="s1">return true</span><span class="s0">; </span><span class="s4">// if we miss a property, it has been deleted, so array probobaly changed</span>

	    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s2">i </span><span class="s0">= </span><span class="s6">0</span><span class="s0">; </span><span class="s2">i </span><span class="s0">&lt; </span><span class="s2">draft_</span><span class="s0">.</span><span class="s2">length</span><span class="s0">; </span><span class="s2">i</span><span class="s0">++) {</span>
	      <span class="s1">if </span><span class="s0">(!</span><span class="s2">draft_</span><span class="s0">.</span><span class="s2">hasOwnProperty</span><span class="s0">(</span><span class="s2">i</span><span class="s0">)) </span><span class="s1">return true</span><span class="s0">;</span>
	    <span class="s0">} </span><span class="s4">// For all other cases, we don't have to compare, as they would have been picked up by the index setters</span>


	    <span class="s1">return false</span><span class="s0">;</span>
	  <span class="s0">}</span>

	  <span class="s1">function </span><span class="s2">hasChanges_</span><span class="s0">(</span><span class="s2">state</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s2">state</span><span class="s0">.</span><span class="s2">type_ </span><span class="s0">=== </span><span class="s6">4</span>
	    <span class="s4">/* ES5Object */</span>
	    <span class="s0">? </span><span class="s2">hasObjectChanges</span><span class="s0">(</span><span class="s2">state</span><span class="s0">) : </span><span class="s2">hasArrayChanges</span><span class="s0">(</span><span class="s2">state</span><span class="s0">);</span>
	  <span class="s0">}</span>

	  <span class="s1">function </span><span class="s2">assertUnrevoked</span><span class="s0">(</span><span class="s2">state</span>
	  <span class="s4">/*ES5State | MapState | SetState*/</span>
	  <span class="s0">) {</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s2">state</span><span class="s0">.</span><span class="s2">revoked_</span><span class="s0">) </span><span class="s2">die</span><span class="s0">(</span><span class="s6">3</span><span class="s0">, </span><span class="s2">JSON</span><span class="s0">.</span><span class="s2">stringify</span><span class="s0">(</span><span class="s2">latest</span><span class="s0">(</span><span class="s2">state</span><span class="s0">)));</span>
	  <span class="s0">}</span>

	  <span class="s2">loadPlugin</span><span class="s0">(</span><span class="s3">&quot;ES5&quot;</span><span class="s0">, {</span>
	    <span class="s2">createES5Proxy_</span><span class="s0">: </span><span class="s2">createES5Proxy_</span><span class="s0">,</span>
	    <span class="s2">willFinalizeES5_</span><span class="s0">: </span><span class="s2">willFinalizeES5_</span><span class="s0">,</span>
	    <span class="s2">hasChanges_</span><span class="s0">: </span><span class="s2">hasChanges_</span>
	  <span class="s0">});</span>
	<span class="s0">}</span>

	<span class="s1">function </span><span class="s2">enablePatches</span><span class="s0">() {</span>
	  <span class="s1">var </span><span class="s2">REPLACE </span><span class="s0">= </span><span class="s3">&quot;replace&quot;</span><span class="s0">;</span>
	  <span class="s1">var </span><span class="s2">ADD </span><span class="s0">= </span><span class="s3">&quot;add&quot;</span><span class="s0">;</span>
	  <span class="s1">var </span><span class="s2">REMOVE </span><span class="s0">= </span><span class="s3">&quot;remove&quot;</span><span class="s0">;</span>

	  <span class="s1">function </span><span class="s2">generatePatches_</span><span class="s0">(</span><span class="s2">state</span><span class="s0">, </span><span class="s2">basePath</span><span class="s0">, </span><span class="s2">patches</span><span class="s0">, </span><span class="s2">inversePatches</span><span class="s0">) {</span>
	    <span class="s1">switch </span><span class="s0">(</span><span class="s2">state</span><span class="s0">.</span><span class="s2">type_</span><span class="s0">) {</span>
	      <span class="s1">case </span><span class="s6">0</span>
	      <span class="s4">/* ProxyObject */</span>
	      <span class="s0">:</span>
	      <span class="s1">case </span><span class="s6">4</span>
	      <span class="s4">/* ES5Object */</span>
	      <span class="s0">:</span>
	      <span class="s1">case </span><span class="s6">2</span>
	      <span class="s4">/* Map */</span>
	      <span class="s0">:</span>
	        <span class="s1">return </span><span class="s2">generatePatchesFromAssigned</span><span class="s0">(</span><span class="s2">state</span><span class="s0">, </span><span class="s2">basePath</span><span class="s0">, </span><span class="s2">patches</span><span class="s0">, </span><span class="s2">inversePatches</span><span class="s0">);</span>

	      <span class="s1">case </span><span class="s6">5</span>
	      <span class="s4">/* ES5Array */</span>
	      <span class="s0">:</span>
	      <span class="s1">case </span><span class="s6">1</span>
	      <span class="s4">/* ProxyArray */</span>
	      <span class="s0">:</span>
	        <span class="s1">return </span><span class="s2">generateArrayPatches</span><span class="s0">(</span><span class="s2">state</span><span class="s0">, </span><span class="s2">basePath</span><span class="s0">, </span><span class="s2">patches</span><span class="s0">, </span><span class="s2">inversePatches</span><span class="s0">);</span>

	      <span class="s1">case </span><span class="s6">3</span>
	      <span class="s4">/* Set */</span>
	      <span class="s0">:</span>
	        <span class="s1">return </span><span class="s2">generateSetPatches</span><span class="s0">(</span><span class="s2">state</span><span class="s0">, </span><span class="s2">basePath</span><span class="s0">, </span><span class="s2">patches</span><span class="s0">, </span><span class="s2">inversePatches</span><span class="s0">);</span>
	    <span class="s0">}</span>
	  <span class="s0">}</span>

	  <span class="s1">function </span><span class="s2">generateArrayPatches</span><span class="s0">(</span><span class="s2">state</span><span class="s0">, </span><span class="s2">basePath</span><span class="s0">, </span><span class="s2">patches</span><span class="s0">, </span><span class="s2">inversePatches</span><span class="s0">) {</span>
	    <span class="s1">var </span><span class="s2">base_ </span><span class="s0">= </span><span class="s2">state</span><span class="s0">.</span><span class="s2">base_</span><span class="s0">,</span>
	        <span class="s2">assigned_ </span><span class="s0">= </span><span class="s2">state</span><span class="s0">.</span><span class="s2">assigned_</span><span class="s0">;</span>
	    <span class="s1">var </span><span class="s2">copy_ </span><span class="s0">= </span><span class="s2">state</span><span class="s0">.</span><span class="s2">copy_</span><span class="s0">; </span><span class="s4">// Reduce complexity by ensuring `base` is never longer.</span>

	    <span class="s1">if </span><span class="s0">(</span><span class="s2">copy_</span><span class="s0">.</span><span class="s2">length </span><span class="s0">&lt; </span><span class="s2">base_</span><span class="s0">.</span><span class="s2">length</span><span class="s0">) {</span>
	      <span class="s1">var </span><span class="s2">_ref </span><span class="s0">= [</span><span class="s2">copy_</span><span class="s0">, </span><span class="s2">base_</span><span class="s0">];</span>
	      <span class="s2">base_ </span><span class="s0">= </span><span class="s2">_ref</span><span class="s0">[</span><span class="s6">0</span><span class="s0">];</span>
	      <span class="s2">copy_ </span><span class="s0">= </span><span class="s2">_ref</span><span class="s0">[</span><span class="s6">1</span><span class="s0">];</span>
	      <span class="s1">var </span><span class="s2">_ref2 </span><span class="s0">= [</span><span class="s2">inversePatches</span><span class="s0">, </span><span class="s2">patches</span><span class="s0">];</span>
	      <span class="s2">patches </span><span class="s0">= </span><span class="s2">_ref2</span><span class="s0">[</span><span class="s6">0</span><span class="s0">];</span>
	      <span class="s2">inversePatches </span><span class="s0">= </span><span class="s2">_ref2</span><span class="s0">[</span><span class="s6">1</span><span class="s0">];</span>
	    <span class="s0">} </span><span class="s4">// Process replaced indices.</span>


	    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s2">i </span><span class="s0">= </span><span class="s6">0</span><span class="s0">; </span><span class="s2">i </span><span class="s0">&lt; </span><span class="s2">base_</span><span class="s0">.</span><span class="s2">length</span><span class="s0">; </span><span class="s2">i</span><span class="s0">++) {</span>
	      <span class="s1">if </span><span class="s0">(</span><span class="s2">assigned_</span><span class="s0">[</span><span class="s2">i</span><span class="s0">] &amp;&amp; </span><span class="s2">copy_</span><span class="s0">[</span><span class="s2">i</span><span class="s0">] !== </span><span class="s2">base_</span><span class="s0">[</span><span class="s2">i</span><span class="s0">]) {</span>
	        <span class="s1">var </span><span class="s2">path </span><span class="s0">= </span><span class="s2">basePath</span><span class="s0">.</span><span class="s2">concat</span><span class="s0">([</span><span class="s2">i</span><span class="s0">]);</span>
	        <span class="s2">patches</span><span class="s0">.</span><span class="s2">push</span><span class="s0">({</span>
	          <span class="s2">op</span><span class="s0">: </span><span class="s2">REPLACE</span><span class="s0">,</span>
	          <span class="s2">path</span><span class="s0">: </span><span class="s2">path</span><span class="s0">,</span>
	          <span class="s4">// Need to maybe clone it, as it can in fact be the original value</span>
	          <span class="s4">// due to the base/copy inversion at the start of this function</span>
	          <span class="s2">value</span><span class="s0">: </span><span class="s2">clonePatchValueIfNeeded</span><span class="s0">(</span><span class="s2">copy_</span><span class="s0">[</span><span class="s2">i</span><span class="s0">])</span>
	        <span class="s0">});</span>
	        <span class="s2">inversePatches</span><span class="s0">.</span><span class="s2">push</span><span class="s0">({</span>
	          <span class="s2">op</span><span class="s0">: </span><span class="s2">REPLACE</span><span class="s0">,</span>
	          <span class="s2">path</span><span class="s0">: </span><span class="s2">path</span><span class="s0">,</span>
	          <span class="s2">value</span><span class="s0">: </span><span class="s2">clonePatchValueIfNeeded</span><span class="s0">(</span><span class="s2">base_</span><span class="s0">[</span><span class="s2">i</span><span class="s0">])</span>
	        <span class="s0">});</span>
	      <span class="s0">}</span>
	    <span class="s0">} </span><span class="s4">// Process added indices.</span>


	    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s2">_i </span><span class="s0">= </span><span class="s2">base_</span><span class="s0">.</span><span class="s2">length</span><span class="s0">; </span><span class="s2">_i </span><span class="s0">&lt; </span><span class="s2">copy_</span><span class="s0">.</span><span class="s2">length</span><span class="s0">; </span><span class="s2">_i</span><span class="s0">++) {</span>
	      <span class="s1">var </span><span class="s2">_path </span><span class="s0">= </span><span class="s2">basePath</span><span class="s0">.</span><span class="s2">concat</span><span class="s0">([</span><span class="s2">_i</span><span class="s0">]);</span>

	      <span class="s2">patches</span><span class="s0">.</span><span class="s2">push</span><span class="s0">({</span>
	        <span class="s2">op</span><span class="s0">: </span><span class="s2">ADD</span><span class="s0">,</span>
	        <span class="s2">path</span><span class="s0">: </span><span class="s2">_path</span><span class="s0">,</span>
	        <span class="s4">// Need to maybe clone it, as it can in fact be the original value</span>
	        <span class="s4">// due to the base/copy inversion at the start of this function</span>
	        <span class="s2">value</span><span class="s0">: </span><span class="s2">clonePatchValueIfNeeded</span><span class="s0">(</span><span class="s2">copy_</span><span class="s0">[</span><span class="s2">_i</span><span class="s0">])</span>
	      <span class="s0">});</span>
	    <span class="s0">}</span>

	    <span class="s1">if </span><span class="s0">(</span><span class="s2">base_</span><span class="s0">.</span><span class="s2">length </span><span class="s0">&lt; </span><span class="s2">copy_</span><span class="s0">.</span><span class="s2">length</span><span class="s0">) {</span>
	      <span class="s2">inversePatches</span><span class="s0">.</span><span class="s2">push</span><span class="s0">({</span>
	        <span class="s2">op</span><span class="s0">: </span><span class="s2">REPLACE</span><span class="s0">,</span>
	        <span class="s2">path</span><span class="s0">: </span><span class="s2">basePath</span><span class="s0">.</span><span class="s2">concat</span><span class="s0">([</span><span class="s3">&quot;length&quot;</span><span class="s0">]),</span>
	        <span class="s2">value</span><span class="s0">: </span><span class="s2">base_</span><span class="s0">.</span><span class="s2">length</span>
	      <span class="s0">});</span>
	    <span class="s0">}</span>
	  <span class="s0">} </span><span class="s4">// This is used for both Map objects and normal objects.</span>


	  <span class="s1">function </span><span class="s2">generatePatchesFromAssigned</span><span class="s0">(</span><span class="s2">state</span><span class="s0">, </span><span class="s2">basePath</span><span class="s0">, </span><span class="s2">patches</span><span class="s0">, </span><span class="s2">inversePatches</span><span class="s0">) {</span>
	    <span class="s1">var </span><span class="s2">base_ </span><span class="s0">= </span><span class="s2">state</span><span class="s0">.</span><span class="s2">base_</span><span class="s0">,</span>
	        <span class="s2">copy_ </span><span class="s0">= </span><span class="s2">state</span><span class="s0">.</span><span class="s2">copy_</span><span class="s0">;</span>
	    <span class="s2">each</span><span class="s0">(</span><span class="s2">state</span><span class="s0">.</span><span class="s2">assigned_</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(</span><span class="s2">key</span><span class="s0">, </span><span class="s2">assignedValue</span><span class="s0">) {</span>
	      <span class="s1">var </span><span class="s2">origValue </span><span class="s0">= </span><span class="s2">get</span><span class="s0">(</span><span class="s2">base_</span><span class="s0">, </span><span class="s2">key</span><span class="s0">);</span>
	      <span class="s1">var </span><span class="s2">value </span><span class="s0">= </span><span class="s2">get</span><span class="s0">(</span><span class="s2">copy_</span><span class="s0">, </span><span class="s2">key</span><span class="s0">);</span>
	      <span class="s1">var </span><span class="s2">op </span><span class="s0">= !</span><span class="s2">assignedValue </span><span class="s0">? </span><span class="s2">REMOVE </span><span class="s0">: </span><span class="s2">has</span><span class="s0">(</span><span class="s2">base_</span><span class="s0">, </span><span class="s2">key</span><span class="s0">) ? </span><span class="s2">REPLACE </span><span class="s0">: </span><span class="s2">ADD</span><span class="s0">;</span>
	      <span class="s1">if </span><span class="s0">(</span><span class="s2">origValue </span><span class="s0">=== </span><span class="s2">value </span><span class="s0">&amp;&amp; </span><span class="s2">op </span><span class="s0">=== </span><span class="s2">REPLACE</span><span class="s0">) </span><span class="s1">return</span><span class="s0">;</span>
	      <span class="s1">var </span><span class="s2">path </span><span class="s0">= </span><span class="s2">basePath</span><span class="s0">.</span><span class="s2">concat</span><span class="s0">(</span><span class="s2">key</span><span class="s0">);</span>
	      <span class="s2">patches</span><span class="s0">.</span><span class="s2">push</span><span class="s0">(</span><span class="s2">op </span><span class="s0">=== </span><span class="s2">REMOVE </span><span class="s0">? {</span>
	        <span class="s2">op</span><span class="s0">: </span><span class="s2">op</span><span class="s0">,</span>
	        <span class="s2">path</span><span class="s0">: </span><span class="s2">path</span>
	      <span class="s0">} : {</span>
	        <span class="s2">op</span><span class="s0">: </span><span class="s2">op</span><span class="s0">,</span>
	        <span class="s2">path</span><span class="s0">: </span><span class="s2">path</span><span class="s0">,</span>
	        <span class="s2">value</span><span class="s0">: </span><span class="s2">value</span>
	      <span class="s0">});</span>
	      <span class="s2">inversePatches</span><span class="s0">.</span><span class="s2">push</span><span class="s0">(</span><span class="s2">op </span><span class="s0">=== </span><span class="s2">ADD </span><span class="s0">? {</span>
	        <span class="s2">op</span><span class="s0">: </span><span class="s2">REMOVE</span><span class="s0">,</span>
	        <span class="s2">path</span><span class="s0">: </span><span class="s2">path</span>
	      <span class="s0">} : </span><span class="s2">op </span><span class="s0">=== </span><span class="s2">REMOVE </span><span class="s0">? {</span>
	        <span class="s2">op</span><span class="s0">: </span><span class="s2">ADD</span><span class="s0">,</span>
	        <span class="s2">path</span><span class="s0">: </span><span class="s2">path</span><span class="s0">,</span>
	        <span class="s2">value</span><span class="s0">: </span><span class="s2">clonePatchValueIfNeeded</span><span class="s0">(</span><span class="s2">origValue</span><span class="s0">)</span>
	      <span class="s0">} : {</span>
	        <span class="s2">op</span><span class="s0">: </span><span class="s2">REPLACE</span><span class="s0">,</span>
	        <span class="s2">path</span><span class="s0">: </span><span class="s2">path</span><span class="s0">,</span>
	        <span class="s2">value</span><span class="s0">: </span><span class="s2">clonePatchValueIfNeeded</span><span class="s0">(</span><span class="s2">origValue</span><span class="s0">)</span>
	      <span class="s0">});</span>
	    <span class="s0">});</span>
	  <span class="s0">}</span>

	  <span class="s1">function </span><span class="s2">generateSetPatches</span><span class="s0">(</span><span class="s2">state</span><span class="s0">, </span><span class="s2">basePath</span><span class="s0">, </span><span class="s2">patches</span><span class="s0">, </span><span class="s2">inversePatches</span><span class="s0">) {</span>
	    <span class="s1">var </span><span class="s2">base_ </span><span class="s0">= </span><span class="s2">state</span><span class="s0">.</span><span class="s2">base_</span><span class="s0">,</span>
	        <span class="s2">copy_ </span><span class="s0">= </span><span class="s2">state</span><span class="s0">.</span><span class="s2">copy_</span><span class="s0">;</span>
	    <span class="s1">var </span><span class="s2">i </span><span class="s0">= </span><span class="s6">0</span><span class="s0">;</span>
	    <span class="s2">base_</span><span class="s0">.</span><span class="s2">forEach</span><span class="s0">(</span><span class="s1">function </span><span class="s0">(</span><span class="s2">value</span><span class="s0">) {</span>
	      <span class="s1">if </span><span class="s0">(!</span><span class="s2">copy_</span><span class="s0">.</span><span class="s2">has</span><span class="s0">(</span><span class="s2">value</span><span class="s0">)) {</span>
	        <span class="s1">var </span><span class="s2">path </span><span class="s0">= </span><span class="s2">basePath</span><span class="s0">.</span><span class="s2">concat</span><span class="s0">([</span><span class="s2">i</span><span class="s0">]);</span>
	        <span class="s2">patches</span><span class="s0">.</span><span class="s2">push</span><span class="s0">({</span>
	          <span class="s2">op</span><span class="s0">: </span><span class="s2">REMOVE</span><span class="s0">,</span>
	          <span class="s2">path</span><span class="s0">: </span><span class="s2">path</span><span class="s0">,</span>
	          <span class="s2">value</span><span class="s0">: </span><span class="s2">value</span>
	        <span class="s0">});</span>
	        <span class="s2">inversePatches</span><span class="s0">.</span><span class="s2">unshift</span><span class="s0">({</span>
	          <span class="s2">op</span><span class="s0">: </span><span class="s2">ADD</span><span class="s0">,</span>
	          <span class="s2">path</span><span class="s0">: </span><span class="s2">path</span><span class="s0">,</span>
	          <span class="s2">value</span><span class="s0">: </span><span class="s2">value</span>
	        <span class="s0">});</span>
	      <span class="s0">}</span>

	      <span class="s2">i</span><span class="s0">++;</span>
	    <span class="s0">});</span>
	    <span class="s2">i </span><span class="s0">= </span><span class="s6">0</span><span class="s0">;</span>
	    <span class="s2">copy_</span><span class="s0">.</span><span class="s2">forEach</span><span class="s0">(</span><span class="s1">function </span><span class="s0">(</span><span class="s2">value</span><span class="s0">) {</span>
	      <span class="s1">if </span><span class="s0">(!</span><span class="s2">base_</span><span class="s0">.</span><span class="s2">has</span><span class="s0">(</span><span class="s2">value</span><span class="s0">)) {</span>
	        <span class="s1">var </span><span class="s2">path </span><span class="s0">= </span><span class="s2">basePath</span><span class="s0">.</span><span class="s2">concat</span><span class="s0">([</span><span class="s2">i</span><span class="s0">]);</span>
	        <span class="s2">patches</span><span class="s0">.</span><span class="s2">push</span><span class="s0">({</span>
	          <span class="s2">op</span><span class="s0">: </span><span class="s2">ADD</span><span class="s0">,</span>
	          <span class="s2">path</span><span class="s0">: </span><span class="s2">path</span><span class="s0">,</span>
	          <span class="s2">value</span><span class="s0">: </span><span class="s2">value</span>
	        <span class="s0">});</span>
	        <span class="s2">inversePatches</span><span class="s0">.</span><span class="s2">unshift</span><span class="s0">({</span>
	          <span class="s2">op</span><span class="s0">: </span><span class="s2">REMOVE</span><span class="s0">,</span>
	          <span class="s2">path</span><span class="s0">: </span><span class="s2">path</span><span class="s0">,</span>
	          <span class="s2">value</span><span class="s0">: </span><span class="s2">value</span>
	        <span class="s0">});</span>
	      <span class="s0">}</span>

	      <span class="s2">i</span><span class="s0">++;</span>
	    <span class="s0">});</span>
	  <span class="s0">}</span>

	  <span class="s1">function </span><span class="s2">generateReplacementPatches_</span><span class="s0">(</span><span class="s2">baseValue</span><span class="s0">, </span><span class="s2">replacement</span><span class="s0">, </span><span class="s2">patches</span><span class="s0">, </span><span class="s2">inversePatches</span><span class="s0">) {</span>
	    <span class="s2">patches</span><span class="s0">.</span><span class="s2">push</span><span class="s0">({</span>
	      <span class="s2">op</span><span class="s0">: </span><span class="s2">REPLACE</span><span class="s0">,</span>
	      <span class="s2">path</span><span class="s0">: [],</span>
	      <span class="s2">value</span><span class="s0">: </span><span class="s2">replacement </span><span class="s0">=== </span><span class="s2">NOTHING </span><span class="s0">? </span><span class="s2">undefined </span><span class="s0">: </span><span class="s2">replacement</span>
	    <span class="s0">});</span>
	    <span class="s2">inversePatches</span><span class="s0">.</span><span class="s2">push</span><span class="s0">({</span>
	      <span class="s2">op</span><span class="s0">: </span><span class="s2">REPLACE</span><span class="s0">,</span>
	      <span class="s2">path</span><span class="s0">: [],</span>
	      <span class="s2">value</span><span class="s0">: </span><span class="s2">baseValue</span>
	    <span class="s0">});</span>
	  <span class="s0">}</span>

	  <span class="s1">function </span><span class="s2">applyPatches_</span><span class="s0">(</span><span class="s2">draft</span><span class="s0">, </span><span class="s2">patches</span><span class="s0">) {</span>
	    <span class="s2">patches</span><span class="s0">.</span><span class="s2">forEach</span><span class="s0">(</span><span class="s1">function </span><span class="s0">(</span><span class="s2">patch</span><span class="s0">) {</span>
	      <span class="s1">var </span><span class="s2">path </span><span class="s0">= </span><span class="s2">patch</span><span class="s0">.</span><span class="s2">path</span><span class="s0">,</span>
	          <span class="s2">op </span><span class="s0">= </span><span class="s2">patch</span><span class="s0">.</span><span class="s2">op</span><span class="s0">;</span>
	      <span class="s1">var </span><span class="s2">base </span><span class="s0">= </span><span class="s2">draft</span><span class="s0">;</span>

	      <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s2">i </span><span class="s0">= </span><span class="s6">0</span><span class="s0">; </span><span class="s2">i </span><span class="s0">&lt; </span><span class="s2">path</span><span class="s0">.</span><span class="s2">length </span><span class="s0">- </span><span class="s6">1</span><span class="s0">; </span><span class="s2">i</span><span class="s0">++) {</span>
	        <span class="s1">var </span><span class="s2">parentType </span><span class="s0">= </span><span class="s2">getArchtype</span><span class="s0">(</span><span class="s2">base</span><span class="s0">);</span>
	        <span class="s1">var </span><span class="s2">p </span><span class="s0">= </span><span class="s2">path</span><span class="s0">[</span><span class="s2">i</span><span class="s0">];</span>

	        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s2">p </span><span class="s0">!== </span><span class="s3">&quot;string&quot; </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s2">p </span><span class="s0">!== </span><span class="s3">&quot;number&quot;</span><span class="s0">) {</span>
	          <span class="s2">p </span><span class="s0">= </span><span class="s3">&quot;&quot; </span><span class="s0">+ </span><span class="s2">p</span><span class="s0">;</span>
	        <span class="s0">} </span><span class="s4">// See #738, avoid prototype pollution</span>


	        <span class="s1">if </span><span class="s0">((</span><span class="s2">parentType </span><span class="s0">=== </span><span class="s6">0</span>
	        <span class="s4">/* Object */</span>
	        <span class="s0">|| </span><span class="s2">parentType </span><span class="s0">=== </span><span class="s6">1</span>
	        <span class="s4">/* Array */</span>
	        <span class="s0">) &amp;&amp; (</span><span class="s2">p </span><span class="s0">=== </span><span class="s3">&quot;__proto__&quot; </span><span class="s0">|| </span><span class="s2">p </span><span class="s0">=== </span><span class="s3">&quot;constructor&quot;</span><span class="s0">)) </span><span class="s2">die</span><span class="s0">(</span><span class="s6">24</span><span class="s0">);</span>
	        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s2">base </span><span class="s0">=== </span><span class="s3">&quot;function&quot; </span><span class="s0">&amp;&amp; </span><span class="s2">p </span><span class="s0">=== </span><span class="s3">&quot;prototype&quot;</span><span class="s0">) </span><span class="s2">die</span><span class="s0">(</span><span class="s6">24</span><span class="s0">);</span>
	        <span class="s2">base </span><span class="s0">= </span><span class="s2">get</span><span class="s0">(</span><span class="s2">base</span><span class="s0">, </span><span class="s2">p</span><span class="s0">);</span>
	        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s2">base </span><span class="s0">!== </span><span class="s3">&quot;object&quot;</span><span class="s0">) </span><span class="s2">die</span><span class="s0">(</span><span class="s6">15</span><span class="s0">, </span><span class="s2">path</span><span class="s0">.</span><span class="s2">join</span><span class="s0">(</span><span class="s3">&quot;/&quot;</span><span class="s0">));</span>
	      <span class="s0">}</span>

	      <span class="s1">var </span><span class="s2">type </span><span class="s0">= </span><span class="s2">getArchtype</span><span class="s0">(</span><span class="s2">base</span><span class="s0">);</span>
	      <span class="s1">var </span><span class="s2">value </span><span class="s0">= </span><span class="s2">deepClonePatchValue</span><span class="s0">(</span><span class="s2">patch</span><span class="s0">.</span><span class="s2">value</span><span class="s0">); </span><span class="s4">// used to clone patch to ensure original patch is not modified, see #411</span>

	      <span class="s1">var </span><span class="s2">key </span><span class="s0">= </span><span class="s2">path</span><span class="s0">[</span><span class="s2">path</span><span class="s0">.</span><span class="s2">length </span><span class="s0">- </span><span class="s6">1</span><span class="s0">];</span>

	      <span class="s1">switch </span><span class="s0">(</span><span class="s2">op</span><span class="s0">) {</span>
	        <span class="s1">case </span><span class="s2">REPLACE</span><span class="s0">:</span>
	          <span class="s1">switch </span><span class="s0">(</span><span class="s2">type</span><span class="s0">) {</span>
	            <span class="s1">case </span><span class="s6">2</span>
	            <span class="s4">/* Map */</span>
	            <span class="s0">:</span>
	              <span class="s1">return </span><span class="s2">base</span><span class="s0">.</span><span class="s2">set</span><span class="s0">(</span><span class="s2">key</span><span class="s0">, </span><span class="s2">value</span><span class="s0">);</span>

	            <span class="s4">/* istanbul ignore next */</span>

	            <span class="s1">case </span><span class="s6">3</span>
	            <span class="s4">/* Set */</span>
	            <span class="s0">:</span>
	              <span class="s2">die</span><span class="s0">(</span><span class="s6">16</span><span class="s0">);</span>

	            <span class="s1">default</span><span class="s0">:</span>
	              <span class="s4">// if value is an object, then it's assigned by reference</span>
	              <span class="s4">// in the following add or remove ops, the value field inside the patch will also be modifyed</span>
	              <span class="s4">// so we use value from the cloned patch</span>
	              <span class="s4">// @ts-ignore</span>
	              <span class="s1">return </span><span class="s2">base</span><span class="s0">[</span><span class="s2">key</span><span class="s0">] = </span><span class="s2">value</span><span class="s0">;</span>
	          <span class="s0">}</span>

	        <span class="s1">case </span><span class="s2">ADD</span><span class="s0">:</span>
	          <span class="s1">switch </span><span class="s0">(</span><span class="s2">type</span><span class="s0">) {</span>
	            <span class="s1">case </span><span class="s6">1</span>
	            <span class="s4">/* Array */</span>
	            <span class="s0">:</span>
	              <span class="s1">return </span><span class="s2">key </span><span class="s0">=== </span><span class="s3">&quot;-&quot; </span><span class="s0">? </span><span class="s2">base</span><span class="s0">.</span><span class="s2">push</span><span class="s0">(</span><span class="s2">value</span><span class="s0">) : </span><span class="s2">base</span><span class="s0">.</span><span class="s2">splice</span><span class="s0">(</span><span class="s2">key</span><span class="s0">, </span><span class="s6">0</span><span class="s0">, </span><span class="s2">value</span><span class="s0">);</span>

	            <span class="s1">case </span><span class="s6">2</span>
	            <span class="s4">/* Map */</span>
	            <span class="s0">:</span>
	              <span class="s1">return </span><span class="s2">base</span><span class="s0">.</span><span class="s2">set</span><span class="s0">(</span><span class="s2">key</span><span class="s0">, </span><span class="s2">value</span><span class="s0">);</span>

	            <span class="s1">case </span><span class="s6">3</span>
	            <span class="s4">/* Set */</span>
	            <span class="s0">:</span>
	              <span class="s1">return </span><span class="s2">base</span><span class="s0">.</span><span class="s2">add</span><span class="s0">(</span><span class="s2">value</span><span class="s0">);</span>

	            <span class="s1">default</span><span class="s0">:</span>
	              <span class="s1">return </span><span class="s2">base</span><span class="s0">[</span><span class="s2">key</span><span class="s0">] = </span><span class="s2">value</span><span class="s0">;</span>
	          <span class="s0">}</span>

	        <span class="s1">case </span><span class="s2">REMOVE</span><span class="s0">:</span>
	          <span class="s1">switch </span><span class="s0">(</span><span class="s2">type</span><span class="s0">) {</span>
	            <span class="s1">case </span><span class="s6">1</span>
	            <span class="s4">/* Array */</span>
	            <span class="s0">:</span>
	              <span class="s1">return </span><span class="s2">base</span><span class="s0">.</span><span class="s2">splice</span><span class="s0">(</span><span class="s2">key</span><span class="s0">, </span><span class="s6">1</span><span class="s0">);</span>

	            <span class="s1">case </span><span class="s6">2</span>
	            <span class="s4">/* Map */</span>
	            <span class="s0">:</span>
	              <span class="s1">return </span><span class="s2">base</span><span class="s0">.</span><span class="s2">delete</span><span class="s0">(</span><span class="s2">key</span><span class="s0">);</span>

	            <span class="s1">case </span><span class="s6">3</span>
	            <span class="s4">/* Set */</span>
	            <span class="s0">:</span>
	              <span class="s1">return </span><span class="s2">base</span><span class="s0">.</span><span class="s2">delete</span><span class="s0">(</span><span class="s2">patch</span><span class="s0">.</span><span class="s2">value</span><span class="s0">);</span>

	            <span class="s1">default</span><span class="s0">:</span>
	              <span class="s1">return delete </span><span class="s2">base</span><span class="s0">[</span><span class="s2">key</span><span class="s0">];</span>
	          <span class="s0">}</span>

	        <span class="s1">default</span><span class="s0">:</span>
	          <span class="s2">die</span><span class="s0">(</span><span class="s6">17</span><span class="s0">, </span><span class="s2">op</span><span class="s0">);</span>
	      <span class="s0">}</span>
	    <span class="s0">});</span>
	    <span class="s1">return </span><span class="s2">draft</span><span class="s0">;</span>
	  <span class="s0">}</span>

	  <span class="s1">function </span><span class="s2">deepClonePatchValue</span><span class="s0">(</span><span class="s2">obj</span><span class="s0">) {</span>
	    <span class="s1">if </span><span class="s0">(!</span><span class="s2">isDraftable</span><span class="s0">(</span><span class="s2">obj</span><span class="s0">)) </span><span class="s1">return </span><span class="s2">obj</span><span class="s0">;</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s2">Array</span><span class="s0">.</span><span class="s2">isArray</span><span class="s0">(</span><span class="s2">obj</span><span class="s0">)) </span><span class="s1">return </span><span class="s2">obj</span><span class="s0">.</span><span class="s2">map</span><span class="s0">(</span><span class="s2">deepClonePatchValue</span><span class="s0">);</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s2">isMap</span><span class="s0">(</span><span class="s2">obj</span><span class="s0">)) </span><span class="s1">return new </span><span class="s2">Map</span><span class="s0">(</span><span class="s2">Array</span><span class="s0">.</span><span class="s2">from</span><span class="s0">(</span><span class="s2">obj</span><span class="s0">.</span><span class="s2">entries</span><span class="s0">()).</span><span class="s2">map</span><span class="s0">(</span><span class="s1">function </span><span class="s0">(</span><span class="s2">_ref3</span><span class="s0">) {</span>
	      <span class="s1">var </span><span class="s2">k </span><span class="s0">= </span><span class="s2">_ref3</span><span class="s0">[</span><span class="s6">0</span><span class="s0">],</span>
	          <span class="s2">v </span><span class="s0">= </span><span class="s2">_ref3</span><span class="s0">[</span><span class="s6">1</span><span class="s0">];</span>
	      <span class="s1">return </span><span class="s0">[</span><span class="s2">k</span><span class="s0">, </span><span class="s2">deepClonePatchValue</span><span class="s0">(</span><span class="s2">v</span><span class="s0">)];</span>
	    <span class="s0">}));</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s2">isSet</span><span class="s0">(</span><span class="s2">obj</span><span class="s0">)) </span><span class="s1">return new </span><span class="s2">Set</span><span class="s0">(</span><span class="s2">Array</span><span class="s0">.</span><span class="s2">from</span><span class="s0">(</span><span class="s2">obj</span><span class="s0">).</span><span class="s2">map</span><span class="s0">(</span><span class="s2">deepClonePatchValue</span><span class="s0">));</span>
	    <span class="s1">var </span><span class="s2">cloned </span><span class="s0">= </span><span class="s2">Object</span><span class="s0">.</span><span class="s2">create</span><span class="s0">(</span><span class="s2">Object</span><span class="s0">.</span><span class="s2">getPrototypeOf</span><span class="s0">(</span><span class="s2">obj</span><span class="s0">));</span>

	    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s2">key </span><span class="s1">in </span><span class="s2">obj</span><span class="s0">) {</span>
	      <span class="s2">cloned</span><span class="s0">[</span><span class="s2">key</span><span class="s0">] = </span><span class="s2">deepClonePatchValue</span><span class="s0">(</span><span class="s2">obj</span><span class="s0">[</span><span class="s2">key</span><span class="s0">]);</span>
	    <span class="s0">}</span>

	    <span class="s1">if </span><span class="s0">(</span><span class="s2">has</span><span class="s0">(</span><span class="s2">obj</span><span class="s0">, </span><span class="s2">DRAFTABLE</span><span class="s0">)) </span><span class="s2">cloned</span><span class="s0">[</span><span class="s2">DRAFTABLE</span><span class="s0">] = </span><span class="s2">obj</span><span class="s0">[</span><span class="s2">DRAFTABLE</span><span class="s0">];</span>
	    <span class="s1">return </span><span class="s2">cloned</span><span class="s0">;</span>
	  <span class="s0">}</span>

	  <span class="s1">function </span><span class="s2">clonePatchValueIfNeeded</span><span class="s0">(</span><span class="s2">obj</span><span class="s0">) {</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s2">isDraft</span><span class="s0">(</span><span class="s2">obj</span><span class="s0">)) {</span>
	      <span class="s1">return </span><span class="s2">deepClonePatchValue</span><span class="s0">(</span><span class="s2">obj</span><span class="s0">);</span>
	    <span class="s0">} </span><span class="s1">else return </span><span class="s2">obj</span><span class="s0">;</span>
	  <span class="s0">}</span>

	  <span class="s2">loadPlugin</span><span class="s0">(</span><span class="s3">&quot;Patches&quot;</span><span class="s0">, {</span>
	    <span class="s2">applyPatches_</span><span class="s0">: </span><span class="s2">applyPatches_</span><span class="s0">,</span>
	    <span class="s2">generatePatches_</span><span class="s0">: </span><span class="s2">generatePatches_</span><span class="s0">,</span>
	    <span class="s2">generateReplacementPatches_</span><span class="s0">: </span><span class="s2">generateReplacementPatches_</span>
	  <span class="s0">});</span>
	<span class="s0">}</span>

	<span class="s4">// types only!</span>
	<span class="s1">function </span><span class="s2">enableMapSet</span><span class="s0">() {</span>
	  <span class="s4">/* istanbul ignore next */</span>
	  <span class="s1">var </span><span class="s2">_extendStatics </span><span class="s0">= </span><span class="s1">function </span><span class="s2">extendStatics</span><span class="s0">(</span><span class="s2">d</span><span class="s0">, </span><span class="s2">b</span><span class="s0">) {</span>
	    <span class="s2">_extendStatics </span><span class="s0">= </span><span class="s2">Object</span><span class="s0">.</span><span class="s2">setPrototypeOf </span><span class="s0">|| {</span>
	      <span class="s2">__proto__</span><span class="s0">: []</span>
	    <span class="s0">} </span><span class="s1">instanceof </span><span class="s2">Array </span><span class="s0">&amp;&amp; </span><span class="s1">function </span><span class="s0">(</span><span class="s2">d</span><span class="s0">, </span><span class="s2">b</span><span class="s0">) {</span>
	      <span class="s2">d</span><span class="s0">.</span><span class="s2">__proto__ </span><span class="s0">= </span><span class="s2">b</span><span class="s0">;</span>
	    <span class="s0">} || </span><span class="s1">function </span><span class="s0">(</span><span class="s2">d</span><span class="s0">, </span><span class="s2">b</span><span class="s0">) {</span>
	      <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s2">p </span><span class="s1">in </span><span class="s2">b</span><span class="s0">) {</span>
	        <span class="s1">if </span><span class="s0">(</span><span class="s2">b</span><span class="s0">.</span><span class="s2">hasOwnProperty</span><span class="s0">(</span><span class="s2">p</span><span class="s0">)) </span><span class="s2">d</span><span class="s0">[</span><span class="s2">p</span><span class="s0">] = </span><span class="s2">b</span><span class="s0">[</span><span class="s2">p</span><span class="s0">];</span>
	      <span class="s0">}</span>
	    <span class="s0">};</span>

	    <span class="s1">return </span><span class="s2">_extendStatics</span><span class="s0">(</span><span class="s2">d</span><span class="s0">, </span><span class="s2">b</span><span class="s0">);</span>
	  <span class="s0">}; </span><span class="s4">// Ugly hack to resolve #502 and inherit built in Map / Set</span>


	  <span class="s1">function </span><span class="s2">__extends</span><span class="s0">(</span><span class="s2">d</span><span class="s0">, </span><span class="s2">b</span><span class="s0">) {</span>
	    <span class="s2">_extendStatics</span><span class="s0">(</span><span class="s2">d</span><span class="s0">, </span><span class="s2">b</span><span class="s0">);</span>

	    <span class="s1">function </span><span class="s2">__</span><span class="s0">() {</span>
	      <span class="s1">this</span><span class="s0">.</span><span class="s2">constructor </span><span class="s0">= </span><span class="s2">d</span><span class="s0">;</span>
	    <span class="s0">}</span>

	    <span class="s2">d</span><span class="s0">.</span><span class="s2">prototype </span><span class="s0">= ( </span><span class="s4">// @ts-ignore</span>
	    <span class="s2">__</span><span class="s0">.</span><span class="s2">prototype </span><span class="s0">= </span><span class="s2">b</span><span class="s0">.</span><span class="s2">prototype</span><span class="s0">, </span><span class="s1">new </span><span class="s2">__</span><span class="s0">());</span>
	  <span class="s0">}</span>

	  <span class="s1">var </span><span class="s2">DraftMap </span><span class="s0">= </span><span class="s1">function </span><span class="s0">(</span><span class="s2">_super</span><span class="s0">) {</span>
	    <span class="s2">__extends</span><span class="s0">(</span><span class="s2">DraftMap</span><span class="s0">, </span><span class="s2">_super</span><span class="s0">); </span><span class="s4">// Create class manually, cause #502</span>


	    <span class="s1">function </span><span class="s2">DraftMap</span><span class="s0">(</span><span class="s2">target</span><span class="s0">, </span><span class="s2">parent</span><span class="s0">) {</span>
	      <span class="s1">this</span><span class="s0">[</span><span class="s2">DRAFT_STATE</span><span class="s0">] = {</span>
	        <span class="s2">type_</span><span class="s0">: </span><span class="s6">2</span>
	        <span class="s4">/* Map */</span>
	        <span class="s0">,</span>
	        <span class="s2">parent_</span><span class="s0">: </span><span class="s2">parent</span><span class="s0">,</span>
	        <span class="s2">scope_</span><span class="s0">: </span><span class="s2">parent </span><span class="s0">? </span><span class="s2">parent</span><span class="s0">.</span><span class="s2">scope_ </span><span class="s0">: </span><span class="s2">getCurrentScope</span><span class="s0">(),</span>
	        <span class="s2">modified_</span><span class="s0">: </span><span class="s1">false</span><span class="s0">,</span>
	        <span class="s2">finalized_</span><span class="s0">: </span><span class="s1">false</span><span class="s0">,</span>
	        <span class="s2">copy_</span><span class="s0">: </span><span class="s2">undefined</span><span class="s0">,</span>
	        <span class="s2">assigned_</span><span class="s0">: </span><span class="s2">undefined</span><span class="s0">,</span>
	        <span class="s2">base_</span><span class="s0">: </span><span class="s2">target</span><span class="s0">,</span>
	        <span class="s2">draft_</span><span class="s0">: </span><span class="s1">this</span><span class="s0">,</span>
	        <span class="s2">isManual_</span><span class="s0">: </span><span class="s1">false</span><span class="s0">,</span>
	        <span class="s2">revoked_</span><span class="s0">: </span><span class="s1">false</span>
	      <span class="s0">};</span>
	      <span class="s1">return this</span><span class="s0">;</span>
	    <span class="s0">}</span>

	    <span class="s1">var </span><span class="s2">p </span><span class="s0">= </span><span class="s2">DraftMap</span><span class="s0">.</span><span class="s2">prototype</span><span class="s0">;</span>
	    <span class="s2">Object</span><span class="s0">.</span><span class="s2">defineProperty</span><span class="s0">(</span><span class="s2">p</span><span class="s0">, </span><span class="s3">&quot;size&quot;</span><span class="s0">, {</span>
	      <span class="s2">get</span><span class="s0">: </span><span class="s1">function </span><span class="s2">get</span><span class="s0">() {</span>
	        <span class="s1">return </span><span class="s2">latest</span><span class="s0">(</span><span class="s1">this</span><span class="s0">[</span><span class="s2">DRAFT_STATE</span><span class="s0">]).</span><span class="s2">size</span><span class="s0">;</span>
	      <span class="s0">} </span><span class="s4">// enumerable: false,</span>
	      <span class="s4">// configurable: true</span>

	    <span class="s0">});</span>

	    <span class="s2">p</span><span class="s0">.</span><span class="s2">has </span><span class="s0">= </span><span class="s1">function </span><span class="s0">(</span><span class="s2">key</span><span class="s0">) {</span>
	      <span class="s1">return </span><span class="s2">latest</span><span class="s0">(</span><span class="s1">this</span><span class="s0">[</span><span class="s2">DRAFT_STATE</span><span class="s0">]).</span><span class="s2">has</span><span class="s0">(</span><span class="s2">key</span><span class="s0">);</span>
	    <span class="s0">};</span>

	    <span class="s2">p</span><span class="s0">.</span><span class="s2">set </span><span class="s0">= </span><span class="s1">function </span><span class="s0">(</span><span class="s2">key</span><span class="s0">, </span><span class="s2">value</span><span class="s0">) {</span>
	      <span class="s1">var </span><span class="s2">state </span><span class="s0">= </span><span class="s1">this</span><span class="s0">[</span><span class="s2">DRAFT_STATE</span><span class="s0">];</span>
	      <span class="s2">assertUnrevoked</span><span class="s0">(</span><span class="s2">state</span><span class="s0">);</span>

	      <span class="s1">if </span><span class="s0">(!</span><span class="s2">latest</span><span class="s0">(</span><span class="s2">state</span><span class="s0">).</span><span class="s2">has</span><span class="s0">(</span><span class="s2">key</span><span class="s0">) || </span><span class="s2">latest</span><span class="s0">(</span><span class="s2">state</span><span class="s0">).</span><span class="s2">get</span><span class="s0">(</span><span class="s2">key</span><span class="s0">) !== </span><span class="s2">value</span><span class="s0">) {</span>
	        <span class="s2">prepareMapCopy</span><span class="s0">(</span><span class="s2">state</span><span class="s0">);</span>
	        <span class="s2">markChanged</span><span class="s0">(</span><span class="s2">state</span><span class="s0">);</span>
	        <span class="s2">state</span><span class="s0">.</span><span class="s2">assigned_</span><span class="s0">.</span><span class="s2">set</span><span class="s0">(</span><span class="s2">key</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>
	        <span class="s2">state</span><span class="s0">.</span><span class="s2">copy_</span><span class="s0">.</span><span class="s2">set</span><span class="s0">(</span><span class="s2">key</span><span class="s0">, </span><span class="s2">value</span><span class="s0">);</span>
	        <span class="s2">state</span><span class="s0">.</span><span class="s2">assigned_</span><span class="s0">.</span><span class="s2">set</span><span class="s0">(</span><span class="s2">key</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>
	      <span class="s0">}</span>

	      <span class="s1">return this</span><span class="s0">;</span>
	    <span class="s0">};</span>

	    <span class="s2">p</span><span class="s0">.</span><span class="s2">delete </span><span class="s0">= </span><span class="s1">function </span><span class="s0">(</span><span class="s2">key</span><span class="s0">) {</span>
	      <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.</span><span class="s2">has</span><span class="s0">(</span><span class="s2">key</span><span class="s0">)) {</span>
	        <span class="s1">return false</span><span class="s0">;</span>
	      <span class="s0">}</span>

	      <span class="s1">var </span><span class="s2">state </span><span class="s0">= </span><span class="s1">this</span><span class="s0">[</span><span class="s2">DRAFT_STATE</span><span class="s0">];</span>
	      <span class="s2">assertUnrevoked</span><span class="s0">(</span><span class="s2">state</span><span class="s0">);</span>
	      <span class="s2">prepareMapCopy</span><span class="s0">(</span><span class="s2">state</span><span class="s0">);</span>
	      <span class="s2">markChanged</span><span class="s0">(</span><span class="s2">state</span><span class="s0">);</span>

	      <span class="s1">if </span><span class="s0">(</span><span class="s2">state</span><span class="s0">.</span><span class="s2">base_</span><span class="s0">.</span><span class="s2">has</span><span class="s0">(</span><span class="s2">key</span><span class="s0">)) {</span>
	        <span class="s2">state</span><span class="s0">.</span><span class="s2">assigned_</span><span class="s0">.</span><span class="s2">set</span><span class="s0">(</span><span class="s2">key</span><span class="s0">, </span><span class="s1">false</span><span class="s0">);</span>
	      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
	        <span class="s2">state</span><span class="s0">.</span><span class="s2">assigned_</span><span class="s0">.</span><span class="s2">delete</span><span class="s0">(</span><span class="s2">key</span><span class="s0">);</span>
	      <span class="s0">}</span>

	      <span class="s2">state</span><span class="s0">.</span><span class="s2">copy_</span><span class="s0">.</span><span class="s2">delete</span><span class="s0">(</span><span class="s2">key</span><span class="s0">);</span>
	      <span class="s1">return true</span><span class="s0">;</span>
	    <span class="s0">};</span>

	    <span class="s2">p</span><span class="s0">.</span><span class="s2">clear </span><span class="s0">= </span><span class="s1">function </span><span class="s0">() {</span>
	      <span class="s1">var </span><span class="s2">state </span><span class="s0">= </span><span class="s1">this</span><span class="s0">[</span><span class="s2">DRAFT_STATE</span><span class="s0">];</span>
	      <span class="s2">assertUnrevoked</span><span class="s0">(</span><span class="s2">state</span><span class="s0">);</span>

	      <span class="s1">if </span><span class="s0">(</span><span class="s2">latest</span><span class="s0">(</span><span class="s2">state</span><span class="s0">).</span><span class="s2">size</span><span class="s0">) {</span>
	        <span class="s2">prepareMapCopy</span><span class="s0">(</span><span class="s2">state</span><span class="s0">);</span>
	        <span class="s2">markChanged</span><span class="s0">(</span><span class="s2">state</span><span class="s0">);</span>
	        <span class="s2">state</span><span class="s0">.</span><span class="s2">assigned_ </span><span class="s0">= </span><span class="s1">new </span><span class="s2">Map</span><span class="s0">();</span>
	        <span class="s2">each</span><span class="s0">(</span><span class="s2">state</span><span class="s0">.</span><span class="s2">base_</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(</span><span class="s2">key</span><span class="s0">) {</span>
	          <span class="s2">state</span><span class="s0">.</span><span class="s2">assigned_</span><span class="s0">.</span><span class="s2">set</span><span class="s0">(</span><span class="s2">key</span><span class="s0">, </span><span class="s1">false</span><span class="s0">);</span>
	        <span class="s0">});</span>
	        <span class="s2">state</span><span class="s0">.</span><span class="s2">copy_</span><span class="s0">.</span><span class="s2">clear</span><span class="s0">();</span>
	      <span class="s0">}</span>
	    <span class="s0">};</span>

	    <span class="s2">p</span><span class="s0">.</span><span class="s2">forEach </span><span class="s0">= </span><span class="s1">function </span><span class="s0">(</span><span class="s2">cb</span><span class="s0">, </span><span class="s2">thisArg</span><span class="s0">) {</span>
	      <span class="s1">var </span><span class="s2">_this </span><span class="s0">= </span><span class="s1">this</span><span class="s0">;</span>

	      <span class="s1">var </span><span class="s2">state </span><span class="s0">= </span><span class="s1">this</span><span class="s0">[</span><span class="s2">DRAFT_STATE</span><span class="s0">];</span>
	      <span class="s2">latest</span><span class="s0">(</span><span class="s2">state</span><span class="s0">).</span><span class="s2">forEach</span><span class="s0">(</span><span class="s1">function </span><span class="s0">(</span><span class="s2">_value</span><span class="s0">, </span><span class="s2">key</span><span class="s0">, </span><span class="s2">_map</span><span class="s0">) {</span>
	        <span class="s2">cb</span><span class="s0">.</span><span class="s2">call</span><span class="s0">(</span><span class="s2">thisArg</span><span class="s0">, </span><span class="s2">_this</span><span class="s0">.</span><span class="s2">get</span><span class="s0">(</span><span class="s2">key</span><span class="s0">), </span><span class="s2">key</span><span class="s0">, </span><span class="s2">_this</span><span class="s0">);</span>
	      <span class="s0">});</span>
	    <span class="s0">};</span>

	    <span class="s2">p</span><span class="s0">.</span><span class="s2">get </span><span class="s0">= </span><span class="s1">function </span><span class="s0">(</span><span class="s2">key</span><span class="s0">) {</span>
	      <span class="s1">var </span><span class="s2">state </span><span class="s0">= </span><span class="s1">this</span><span class="s0">[</span><span class="s2">DRAFT_STATE</span><span class="s0">];</span>
	      <span class="s2">assertUnrevoked</span><span class="s0">(</span><span class="s2">state</span><span class="s0">);</span>
	      <span class="s1">var </span><span class="s2">value </span><span class="s0">= </span><span class="s2">latest</span><span class="s0">(</span><span class="s2">state</span><span class="s0">).</span><span class="s2">get</span><span class="s0">(</span><span class="s2">key</span><span class="s0">);</span>

	      <span class="s1">if </span><span class="s0">(</span><span class="s2">state</span><span class="s0">.</span><span class="s2">finalized_ </span><span class="s0">|| !</span><span class="s2">isDraftable</span><span class="s0">(</span><span class="s2">value</span><span class="s0">)) {</span>
	        <span class="s1">return </span><span class="s2">value</span><span class="s0">;</span>
	      <span class="s0">}</span>

	      <span class="s1">if </span><span class="s0">(</span><span class="s2">value </span><span class="s0">!== </span><span class="s2">state</span><span class="s0">.</span><span class="s2">base_</span><span class="s0">.</span><span class="s2">get</span><span class="s0">(</span><span class="s2">key</span><span class="s0">)) {</span>
	        <span class="s1">return </span><span class="s2">value</span><span class="s0">; </span><span class="s4">// either already drafted or reassigned</span>
	      <span class="s0">} </span><span class="s4">// despite what it looks, this creates a draft only once, see above condition</span>


	      <span class="s1">var </span><span class="s2">draft </span><span class="s0">= </span><span class="s2">createProxy</span><span class="s0">(</span><span class="s2">state</span><span class="s0">.</span><span class="s2">scope_</span><span class="s0">.</span><span class="s2">immer_</span><span class="s0">, </span><span class="s2">value</span><span class="s0">, </span><span class="s2">state</span><span class="s0">);</span>
	      <span class="s2">prepareMapCopy</span><span class="s0">(</span><span class="s2">state</span><span class="s0">);</span>
	      <span class="s2">state</span><span class="s0">.</span><span class="s2">copy_</span><span class="s0">.</span><span class="s2">set</span><span class="s0">(</span><span class="s2">key</span><span class="s0">, </span><span class="s2">draft</span><span class="s0">);</span>
	      <span class="s1">return </span><span class="s2">draft</span><span class="s0">;</span>
	    <span class="s0">};</span>

	    <span class="s2">p</span><span class="s0">.</span><span class="s2">keys </span><span class="s0">= </span><span class="s1">function </span><span class="s0">() {</span>
	      <span class="s1">return </span><span class="s2">latest</span><span class="s0">(</span><span class="s1">this</span><span class="s0">[</span><span class="s2">DRAFT_STATE</span><span class="s0">]).</span><span class="s2">keys</span><span class="s0">();</span>
	    <span class="s0">};</span>

	    <span class="s2">p</span><span class="s0">.</span><span class="s2">values </span><span class="s0">= </span><span class="s1">function </span><span class="s0">() {</span>
	      <span class="s1">var </span><span class="s2">_this2 </span><span class="s0">= </span><span class="s1">this</span><span class="s0">,</span>
	          <span class="s2">_ref</span><span class="s0">;</span>

	      <span class="s1">var </span><span class="s2">iterator </span><span class="s0">= </span><span class="s1">this</span><span class="s0">.</span><span class="s2">keys</span><span class="s0">();</span>
	      <span class="s1">return </span><span class="s2">_ref </span><span class="s0">= {}, </span><span class="s2">_ref</span><span class="s0">[</span><span class="s2">iteratorSymbol</span><span class="s0">] = </span><span class="s1">function </span><span class="s0">() {</span>
	        <span class="s1">return </span><span class="s2">_this2</span><span class="s0">.</span><span class="s2">values</span><span class="s0">();</span>
	      <span class="s0">}, </span><span class="s2">_ref</span><span class="s0">.</span><span class="s2">next </span><span class="s0">= </span><span class="s1">function </span><span class="s2">next</span><span class="s0">() {</span>
	        <span class="s1">var </span><span class="s2">r </span><span class="s0">= </span><span class="s2">iterator</span><span class="s0">.</span><span class="s2">next</span><span class="s0">();</span>
	        <span class="s4">/* istanbul ignore next */</span>

	        <span class="s1">if </span><span class="s0">(</span><span class="s2">r</span><span class="s0">.</span><span class="s2">done</span><span class="s0">) </span><span class="s1">return </span><span class="s2">r</span><span class="s0">;</span>

	        <span class="s1">var </span><span class="s2">value </span><span class="s0">= </span><span class="s2">_this2</span><span class="s0">.</span><span class="s2">get</span><span class="s0">(</span><span class="s2">r</span><span class="s0">.</span><span class="s2">value</span><span class="s0">);</span>

	        <span class="s1">return </span><span class="s0">{</span>
	          <span class="s2">done</span><span class="s0">: </span><span class="s1">false</span><span class="s0">,</span>
	          <span class="s2">value</span><span class="s0">: </span><span class="s2">value</span>
	        <span class="s0">};</span>
	      <span class="s0">}, </span><span class="s2">_ref</span><span class="s0">;</span>
	    <span class="s0">};</span>

	    <span class="s2">p</span><span class="s0">.</span><span class="s2">entries </span><span class="s0">= </span><span class="s1">function </span><span class="s0">() {</span>
	      <span class="s1">var </span><span class="s2">_this3 </span><span class="s0">= </span><span class="s1">this</span><span class="s0">,</span>
	          <span class="s2">_ref2</span><span class="s0">;</span>

	      <span class="s1">var </span><span class="s2">iterator </span><span class="s0">= </span><span class="s1">this</span><span class="s0">.</span><span class="s2">keys</span><span class="s0">();</span>
	      <span class="s1">return </span><span class="s2">_ref2 </span><span class="s0">= {}, </span><span class="s2">_ref2</span><span class="s0">[</span><span class="s2">iteratorSymbol</span><span class="s0">] = </span><span class="s1">function </span><span class="s0">() {</span>
	        <span class="s1">return </span><span class="s2">_this3</span><span class="s0">.</span><span class="s2">entries</span><span class="s0">();</span>
	      <span class="s0">}, </span><span class="s2">_ref2</span><span class="s0">.</span><span class="s2">next </span><span class="s0">= </span><span class="s1">function </span><span class="s2">next</span><span class="s0">() {</span>
	        <span class="s1">var </span><span class="s2">r </span><span class="s0">= </span><span class="s2">iterator</span><span class="s0">.</span><span class="s2">next</span><span class="s0">();</span>
	        <span class="s4">/* istanbul ignore next */</span>

	        <span class="s1">if </span><span class="s0">(</span><span class="s2">r</span><span class="s0">.</span><span class="s2">done</span><span class="s0">) </span><span class="s1">return </span><span class="s2">r</span><span class="s0">;</span>

	        <span class="s1">var </span><span class="s2">value </span><span class="s0">= </span><span class="s2">_this3</span><span class="s0">.</span><span class="s2">get</span><span class="s0">(</span><span class="s2">r</span><span class="s0">.</span><span class="s2">value</span><span class="s0">);</span>

	        <span class="s1">return </span><span class="s0">{</span>
	          <span class="s2">done</span><span class="s0">: </span><span class="s1">false</span><span class="s0">,</span>
	          <span class="s2">value</span><span class="s0">: [</span><span class="s2">r</span><span class="s0">.</span><span class="s2">value</span><span class="s0">, </span><span class="s2">value</span><span class="s0">]</span>
	        <span class="s0">};</span>
	      <span class="s0">}, </span><span class="s2">_ref2</span><span class="s0">;</span>
	    <span class="s0">};</span>

	    <span class="s2">p</span><span class="s0">[</span><span class="s2">iteratorSymbol</span><span class="s0">] = </span><span class="s1">function </span><span class="s0">() {</span>
	      <span class="s1">return this</span><span class="s0">.</span><span class="s2">entries</span><span class="s0">();</span>
	    <span class="s0">};</span>

	    <span class="s1">return </span><span class="s2">DraftMap</span><span class="s0">;</span>
	  <span class="s0">}(</span><span class="s2">Map</span><span class="s0">);</span>

	  <span class="s1">function </span><span class="s2">proxyMap_</span><span class="s0">(</span><span class="s2">target</span><span class="s0">, </span><span class="s2">parent</span><span class="s0">) {</span>
	    <span class="s4">// @ts-ignore</span>
	    <span class="s1">return new </span><span class="s2">DraftMap</span><span class="s0">(</span><span class="s2">target</span><span class="s0">, </span><span class="s2">parent</span><span class="s0">);</span>
	  <span class="s0">}</span>

	  <span class="s1">function </span><span class="s2">prepareMapCopy</span><span class="s0">(</span><span class="s2">state</span><span class="s0">) {</span>
	    <span class="s1">if </span><span class="s0">(!</span><span class="s2">state</span><span class="s0">.</span><span class="s2">copy_</span><span class="s0">) {</span>
	      <span class="s2">state</span><span class="s0">.</span><span class="s2">assigned_ </span><span class="s0">= </span><span class="s1">new </span><span class="s2">Map</span><span class="s0">();</span>
	      <span class="s2">state</span><span class="s0">.</span><span class="s2">copy_ </span><span class="s0">= </span><span class="s1">new </span><span class="s2">Map</span><span class="s0">(</span><span class="s2">state</span><span class="s0">.</span><span class="s2">base_</span><span class="s0">);</span>
	    <span class="s0">}</span>
	  <span class="s0">}</span>

	  <span class="s1">var </span><span class="s2">DraftSet </span><span class="s0">= </span><span class="s1">function </span><span class="s0">(</span><span class="s2">_super</span><span class="s0">) {</span>
	    <span class="s2">__extends</span><span class="s0">(</span><span class="s2">DraftSet</span><span class="s0">, </span><span class="s2">_super</span><span class="s0">); </span><span class="s4">// Create class manually, cause #502</span>


	    <span class="s1">function </span><span class="s2">DraftSet</span><span class="s0">(</span><span class="s2">target</span><span class="s0">, </span><span class="s2">parent</span><span class="s0">) {</span>
	      <span class="s1">this</span><span class="s0">[</span><span class="s2">DRAFT_STATE</span><span class="s0">] = {</span>
	        <span class="s2">type_</span><span class="s0">: </span><span class="s6">3</span>
	        <span class="s4">/* Set */</span>
	        <span class="s0">,</span>
	        <span class="s2">parent_</span><span class="s0">: </span><span class="s2">parent</span><span class="s0">,</span>
	        <span class="s2">scope_</span><span class="s0">: </span><span class="s2">parent </span><span class="s0">? </span><span class="s2">parent</span><span class="s0">.</span><span class="s2">scope_ </span><span class="s0">: </span><span class="s2">getCurrentScope</span><span class="s0">(),</span>
	        <span class="s2">modified_</span><span class="s0">: </span><span class="s1">false</span><span class="s0">,</span>
	        <span class="s2">finalized_</span><span class="s0">: </span><span class="s1">false</span><span class="s0">,</span>
	        <span class="s2">copy_</span><span class="s0">: </span><span class="s2">undefined</span><span class="s0">,</span>
	        <span class="s2">base_</span><span class="s0">: </span><span class="s2">target</span><span class="s0">,</span>
	        <span class="s2">draft_</span><span class="s0">: </span><span class="s1">this</span><span class="s0">,</span>
	        <span class="s2">drafts_</span><span class="s0">: </span><span class="s1">new </span><span class="s2">Map</span><span class="s0">(),</span>
	        <span class="s2">revoked_</span><span class="s0">: </span><span class="s1">false</span><span class="s0">,</span>
	        <span class="s2">isManual_</span><span class="s0">: </span><span class="s1">false</span>
	      <span class="s0">};</span>
	      <span class="s1">return this</span><span class="s0">;</span>
	    <span class="s0">}</span>

	    <span class="s1">var </span><span class="s2">p </span><span class="s0">= </span><span class="s2">DraftSet</span><span class="s0">.</span><span class="s2">prototype</span><span class="s0">;</span>
	    <span class="s2">Object</span><span class="s0">.</span><span class="s2">defineProperty</span><span class="s0">(</span><span class="s2">p</span><span class="s0">, </span><span class="s3">&quot;size&quot;</span><span class="s0">, {</span>
	      <span class="s2">get</span><span class="s0">: </span><span class="s1">function </span><span class="s2">get</span><span class="s0">() {</span>
	        <span class="s1">return </span><span class="s2">latest</span><span class="s0">(</span><span class="s1">this</span><span class="s0">[</span><span class="s2">DRAFT_STATE</span><span class="s0">]).</span><span class="s2">size</span><span class="s0">;</span>
	      <span class="s0">} </span><span class="s4">// enumerable: true,</span>

	    <span class="s0">});</span>

	    <span class="s2">p</span><span class="s0">.</span><span class="s2">has </span><span class="s0">= </span><span class="s1">function </span><span class="s0">(</span><span class="s2">value</span><span class="s0">) {</span>
	      <span class="s1">var </span><span class="s2">state </span><span class="s0">= </span><span class="s1">this</span><span class="s0">[</span><span class="s2">DRAFT_STATE</span><span class="s0">];</span>
	      <span class="s2">assertUnrevoked</span><span class="s0">(</span><span class="s2">state</span><span class="s0">); </span><span class="s4">// bit of trickery here, to be able to recognize both the value, and the draft of its value</span>

	      <span class="s1">if </span><span class="s0">(!</span><span class="s2">state</span><span class="s0">.</span><span class="s2">copy_</span><span class="s0">) {</span>
	        <span class="s1">return </span><span class="s2">state</span><span class="s0">.</span><span class="s2">base_</span><span class="s0">.</span><span class="s2">has</span><span class="s0">(</span><span class="s2">value</span><span class="s0">);</span>
	      <span class="s0">}</span>

	      <span class="s1">if </span><span class="s0">(</span><span class="s2">state</span><span class="s0">.</span><span class="s2">copy_</span><span class="s0">.</span><span class="s2">has</span><span class="s0">(</span><span class="s2">value</span><span class="s0">)) </span><span class="s1">return true</span><span class="s0">;</span>
	      <span class="s1">if </span><span class="s0">(</span><span class="s2">state</span><span class="s0">.</span><span class="s2">drafts_</span><span class="s0">.</span><span class="s2">has</span><span class="s0">(</span><span class="s2">value</span><span class="s0">) &amp;&amp; </span><span class="s2">state</span><span class="s0">.</span><span class="s2">copy_</span><span class="s0">.</span><span class="s2">has</span><span class="s0">(</span><span class="s2">state</span><span class="s0">.</span><span class="s2">drafts_</span><span class="s0">.</span><span class="s2">get</span><span class="s0">(</span><span class="s2">value</span><span class="s0">))) </span><span class="s1">return true</span><span class="s0">;</span>
	      <span class="s1">return false</span><span class="s0">;</span>
	    <span class="s0">};</span>

	    <span class="s2">p</span><span class="s0">.</span><span class="s2">add </span><span class="s0">= </span><span class="s1">function </span><span class="s0">(</span><span class="s2">value</span><span class="s0">) {</span>
	      <span class="s1">var </span><span class="s2">state </span><span class="s0">= </span><span class="s1">this</span><span class="s0">[</span><span class="s2">DRAFT_STATE</span><span class="s0">];</span>
	      <span class="s2">assertUnrevoked</span><span class="s0">(</span><span class="s2">state</span><span class="s0">);</span>

	      <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.</span><span class="s2">has</span><span class="s0">(</span><span class="s2">value</span><span class="s0">)) {</span>
	        <span class="s2">prepareSetCopy</span><span class="s0">(</span><span class="s2">state</span><span class="s0">);</span>
	        <span class="s2">markChanged</span><span class="s0">(</span><span class="s2">state</span><span class="s0">);</span>
	        <span class="s2">state</span><span class="s0">.</span><span class="s2">copy_</span><span class="s0">.</span><span class="s2">add</span><span class="s0">(</span><span class="s2">value</span><span class="s0">);</span>
	      <span class="s0">}</span>

	      <span class="s1">return this</span><span class="s0">;</span>
	    <span class="s0">};</span>

	    <span class="s2">p</span><span class="s0">.</span><span class="s2">delete </span><span class="s0">= </span><span class="s1">function </span><span class="s0">(</span><span class="s2">value</span><span class="s0">) {</span>
	      <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.</span><span class="s2">has</span><span class="s0">(</span><span class="s2">value</span><span class="s0">)) {</span>
	        <span class="s1">return false</span><span class="s0">;</span>
	      <span class="s0">}</span>

	      <span class="s1">var </span><span class="s2">state </span><span class="s0">= </span><span class="s1">this</span><span class="s0">[</span><span class="s2">DRAFT_STATE</span><span class="s0">];</span>
	      <span class="s2">assertUnrevoked</span><span class="s0">(</span><span class="s2">state</span><span class="s0">);</span>
	      <span class="s2">prepareSetCopy</span><span class="s0">(</span><span class="s2">state</span><span class="s0">);</span>
	      <span class="s2">markChanged</span><span class="s0">(</span><span class="s2">state</span><span class="s0">);</span>
	      <span class="s1">return </span><span class="s2">state</span><span class="s0">.</span><span class="s2">copy_</span><span class="s0">.</span><span class="s2">delete</span><span class="s0">(</span><span class="s2">value</span><span class="s0">) || (</span><span class="s2">state</span><span class="s0">.</span><span class="s2">drafts_</span><span class="s0">.</span><span class="s2">has</span><span class="s0">(</span><span class="s2">value</span><span class="s0">) ? </span><span class="s2">state</span><span class="s0">.</span><span class="s2">copy_</span><span class="s0">.</span><span class="s2">delete</span><span class="s0">(</span><span class="s2">state</span><span class="s0">.</span><span class="s2">drafts_</span><span class="s0">.</span><span class="s2">get</span><span class="s0">(</span><span class="s2">value</span><span class="s0">)) :</span>
	      <span class="s4">/* istanbul ignore next */</span>
	      <span class="s1">false</span><span class="s0">);</span>
	    <span class="s0">};</span>

	    <span class="s2">p</span><span class="s0">.</span><span class="s2">clear </span><span class="s0">= </span><span class="s1">function </span><span class="s0">() {</span>
	      <span class="s1">var </span><span class="s2">state </span><span class="s0">= </span><span class="s1">this</span><span class="s0">[</span><span class="s2">DRAFT_STATE</span><span class="s0">];</span>
	      <span class="s2">assertUnrevoked</span><span class="s0">(</span><span class="s2">state</span><span class="s0">);</span>

	      <span class="s1">if </span><span class="s0">(</span><span class="s2">latest</span><span class="s0">(</span><span class="s2">state</span><span class="s0">).</span><span class="s2">size</span><span class="s0">) {</span>
	        <span class="s2">prepareSetCopy</span><span class="s0">(</span><span class="s2">state</span><span class="s0">);</span>
	        <span class="s2">markChanged</span><span class="s0">(</span><span class="s2">state</span><span class="s0">);</span>
	        <span class="s2">state</span><span class="s0">.</span><span class="s2">copy_</span><span class="s0">.</span><span class="s2">clear</span><span class="s0">();</span>
	      <span class="s0">}</span>
	    <span class="s0">};</span>

	    <span class="s2">p</span><span class="s0">.</span><span class="s2">values </span><span class="s0">= </span><span class="s1">function </span><span class="s0">() {</span>
	      <span class="s1">var </span><span class="s2">state </span><span class="s0">= </span><span class="s1">this</span><span class="s0">[</span><span class="s2">DRAFT_STATE</span><span class="s0">];</span>
	      <span class="s2">assertUnrevoked</span><span class="s0">(</span><span class="s2">state</span><span class="s0">);</span>
	      <span class="s2">prepareSetCopy</span><span class="s0">(</span><span class="s2">state</span><span class="s0">);</span>
	      <span class="s1">return </span><span class="s2">state</span><span class="s0">.</span><span class="s2">copy_</span><span class="s0">.</span><span class="s2">values</span><span class="s0">();</span>
	    <span class="s0">};</span>

	    <span class="s2">p</span><span class="s0">.</span><span class="s2">entries </span><span class="s0">= </span><span class="s1">function </span><span class="s2">entries</span><span class="s0">() {</span>
	      <span class="s1">var </span><span class="s2">state </span><span class="s0">= </span><span class="s1">this</span><span class="s0">[</span><span class="s2">DRAFT_STATE</span><span class="s0">];</span>
	      <span class="s2">assertUnrevoked</span><span class="s0">(</span><span class="s2">state</span><span class="s0">);</span>
	      <span class="s2">prepareSetCopy</span><span class="s0">(</span><span class="s2">state</span><span class="s0">);</span>
	      <span class="s1">return </span><span class="s2">state</span><span class="s0">.</span><span class="s2">copy_</span><span class="s0">.</span><span class="s2">entries</span><span class="s0">();</span>
	    <span class="s0">};</span>

	    <span class="s2">p</span><span class="s0">.</span><span class="s2">keys </span><span class="s0">= </span><span class="s1">function </span><span class="s0">() {</span>
	      <span class="s1">return this</span><span class="s0">.</span><span class="s2">values</span><span class="s0">();</span>
	    <span class="s0">};</span>

	    <span class="s2">p</span><span class="s0">[</span><span class="s2">iteratorSymbol</span><span class="s0">] = </span><span class="s1">function </span><span class="s0">() {</span>
	      <span class="s1">return this</span><span class="s0">.</span><span class="s2">values</span><span class="s0">();</span>
	    <span class="s0">};</span>

	    <span class="s2">p</span><span class="s0">.</span><span class="s2">forEach </span><span class="s0">= </span><span class="s1">function </span><span class="s2">forEach</span><span class="s0">(</span><span class="s2">cb</span><span class="s0">, </span><span class="s2">thisArg</span><span class="s0">) {</span>
	      <span class="s1">var </span><span class="s2">iterator </span><span class="s0">= </span><span class="s1">this</span><span class="s0">.</span><span class="s2">values</span><span class="s0">();</span>
	      <span class="s1">var </span><span class="s2">result </span><span class="s0">= </span><span class="s2">iterator</span><span class="s0">.</span><span class="s2">next</span><span class="s0">();</span>

	      <span class="s1">while </span><span class="s0">(!</span><span class="s2">result</span><span class="s0">.</span><span class="s2">done</span><span class="s0">) {</span>
	        <span class="s2">cb</span><span class="s0">.</span><span class="s2">call</span><span class="s0">(</span><span class="s2">thisArg</span><span class="s0">, </span><span class="s2">result</span><span class="s0">.</span><span class="s2">value</span><span class="s0">, </span><span class="s2">result</span><span class="s0">.</span><span class="s2">value</span><span class="s0">, </span><span class="s1">this</span><span class="s0">);</span>
	        <span class="s2">result </span><span class="s0">= </span><span class="s2">iterator</span><span class="s0">.</span><span class="s2">next</span><span class="s0">();</span>
	      <span class="s0">}</span>
	    <span class="s0">};</span>

	    <span class="s1">return </span><span class="s2">DraftSet</span><span class="s0">;</span>
	  <span class="s0">}(</span><span class="s2">Set</span><span class="s0">);</span>

	  <span class="s1">function </span><span class="s2">proxySet_</span><span class="s0">(</span><span class="s2">target</span><span class="s0">, </span><span class="s2">parent</span><span class="s0">) {</span>
	    <span class="s4">// @ts-ignore</span>
	    <span class="s1">return new </span><span class="s2">DraftSet</span><span class="s0">(</span><span class="s2">target</span><span class="s0">, </span><span class="s2">parent</span><span class="s0">);</span>
	  <span class="s0">}</span>

	  <span class="s1">function </span><span class="s2">prepareSetCopy</span><span class="s0">(</span><span class="s2">state</span><span class="s0">) {</span>
	    <span class="s1">if </span><span class="s0">(!</span><span class="s2">state</span><span class="s0">.</span><span class="s2">copy_</span><span class="s0">) {</span>
	      <span class="s4">// create drafts for all entries to preserve insertion order</span>
	      <span class="s2">state</span><span class="s0">.</span><span class="s2">copy_ </span><span class="s0">= </span><span class="s1">new </span><span class="s2">Set</span><span class="s0">();</span>
	      <span class="s2">state</span><span class="s0">.</span><span class="s2">base_</span><span class="s0">.</span><span class="s2">forEach</span><span class="s0">(</span><span class="s1">function </span><span class="s0">(</span><span class="s2">value</span><span class="s0">) {</span>
	        <span class="s1">if </span><span class="s0">(</span><span class="s2">isDraftable</span><span class="s0">(</span><span class="s2">value</span><span class="s0">)) {</span>
	          <span class="s1">var </span><span class="s2">draft </span><span class="s0">= </span><span class="s2">createProxy</span><span class="s0">(</span><span class="s2">state</span><span class="s0">.</span><span class="s2">scope_</span><span class="s0">.</span><span class="s2">immer_</span><span class="s0">, </span><span class="s2">value</span><span class="s0">, </span><span class="s2">state</span><span class="s0">);</span>
	          <span class="s2">state</span><span class="s0">.</span><span class="s2">drafts_</span><span class="s0">.</span><span class="s2">set</span><span class="s0">(</span><span class="s2">value</span><span class="s0">, </span><span class="s2">draft</span><span class="s0">);</span>
	          <span class="s2">state</span><span class="s0">.</span><span class="s2">copy_</span><span class="s0">.</span><span class="s2">add</span><span class="s0">(</span><span class="s2">draft</span><span class="s0">);</span>
	        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
	          <span class="s2">state</span><span class="s0">.</span><span class="s2">copy_</span><span class="s0">.</span><span class="s2">add</span><span class="s0">(</span><span class="s2">value</span><span class="s0">);</span>
	        <span class="s0">}</span>
	      <span class="s0">});</span>
	    <span class="s0">}</span>
	  <span class="s0">}</span>

	  <span class="s1">function </span><span class="s2">assertUnrevoked</span><span class="s0">(</span><span class="s2">state</span>
	  <span class="s4">/*ES5State | MapState | SetState*/</span>
	  <span class="s0">) {</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s2">state</span><span class="s0">.</span><span class="s2">revoked_</span><span class="s0">) </span><span class="s2">die</span><span class="s0">(</span><span class="s6">3</span><span class="s0">, </span><span class="s2">JSON</span><span class="s0">.</span><span class="s2">stringify</span><span class="s0">(</span><span class="s2">latest</span><span class="s0">(</span><span class="s2">state</span><span class="s0">)));</span>
	  <span class="s0">}</span>

	  <span class="s2">loadPlugin</span><span class="s0">(</span><span class="s3">&quot;MapSet&quot;</span><span class="s0">, {</span>
	    <span class="s2">proxyMap_</span><span class="s0">: </span><span class="s2">proxyMap_</span><span class="s0">,</span>
	    <span class="s2">proxySet_</span><span class="s0">: </span><span class="s2">proxySet_</span>
	  <span class="s0">});</span>
	<span class="s0">}</span>

	<span class="s1">function </span><span class="s2">enableAllPlugins</span><span class="s0">() {</span>
	  <span class="s2">enableES5</span><span class="s0">();</span>
	  <span class="s2">enableMapSet</span><span class="s0">();</span>
	  <span class="s2">enablePatches</span><span class="s0">();</span>
	<span class="s0">}</span>

	<span class="s1">var </span><span class="s2">immer </span><span class="s0">=</span>
	<span class="s4">/*#__PURE__*/</span>
	<span class="s1">new </span><span class="s2">Immer</span><span class="s0">();</span>
	<span class="s5">/**</span>
	 <span class="s5">* The `produce` function takes a value and a &quot;recipe function&quot; (whose</span>
	 <span class="s5">* return value often depends on the base state). The recipe function is</span>
	 <span class="s5">* free to mutate its first argument however it wants. All mutations are</span>
	 <span class="s5">* only ever applied to a __copy__ of the base state.</span>
	 <span class="s5">*</span>
	 <span class="s5">* Pass only a function to create a &quot;curried producer&quot; which relieves you</span>
	 <span class="s5">* from passing the recipe function every time.</span>
	 <span class="s5">*</span>
	 <span class="s5">* Only plain objects and arrays are made mutable. All other objects are</span>
	 <span class="s5">* considered uncopyable.</span>
	 <span class="s5">*</span>
	 <span class="s5">* Note: This function is __bound__ to its `Immer` instance.</span>
	 <span class="s5">*</span>
	 <span class="s5">* </span><span class="s7">@param </span><span class="s5">{any} base - the initial state</span>
	 <span class="s5">* </span><span class="s7">@param </span><span class="s5">{Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified</span>
	 <span class="s5">* </span><span class="s7">@param </span><span class="s5">{Function} patchListener - optional function that will be called with all the patches produced here</span>
	 <span class="s5">* </span><span class="s7">@returns </span><span class="s5">{any} a new state, or the initial state if nothing was modified</span>
	 <span class="s5">*/</span>

	<span class="s1">var </span><span class="s2">produce </span><span class="s0">= </span><span class="s2">immer</span><span class="s0">.</span><span class="s2">produce</span><span class="s0">;</span>
	<span class="s5">/**</span>
	 <span class="s5">* Like `produce`, but `produceWithPatches` always returns a tuple</span>
	 <span class="s5">* [nextState, patches, inversePatches] (instead of just the next state)</span>
	 <span class="s5">*/</span>

	<span class="s1">var </span><span class="s2">produceWithPatches </span><span class="s0">=</span>
	<span class="s4">/*#__PURE__*/</span>
	<span class="s2">immer</span><span class="s0">.</span><span class="s2">produceWithPatches</span><span class="s0">.</span><span class="s2">bind</span><span class="s0">(</span><span class="s2">immer</span><span class="s0">);</span>
	<span class="s5">/**</span>
	 <span class="s5">* Pass true to automatically freeze all copies created by Immer.</span>
	 <span class="s5">*</span>
	 <span class="s5">* Always freeze by default, even in production mode</span>
	 <span class="s5">*/</span>

	<span class="s1">var </span><span class="s2">setAutoFreeze </span><span class="s0">=</span>
	<span class="s4">/*#__PURE__*/</span>
	<span class="s2">immer</span><span class="s0">.</span><span class="s2">setAutoFreeze</span><span class="s0">.</span><span class="s2">bind</span><span class="s0">(</span><span class="s2">immer</span><span class="s0">);</span>
	<span class="s5">/**</span>
	 <span class="s5">* Pass true to use the ES2015 `Proxy` class when creating drafts, which is</span>
	 <span class="s5">* always faster than using ES5 proxies.</span>
	 <span class="s5">*</span>
	 <span class="s5">* By default, feature detection is used, so calling this is rarely necessary.</span>
	 <span class="s5">*/</span>

	<span class="s1">var </span><span class="s2">setUseProxies </span><span class="s0">=</span>
	<span class="s4">/*#__PURE__*/</span>
	<span class="s2">immer</span><span class="s0">.</span><span class="s2">setUseProxies</span><span class="s0">.</span><span class="s2">bind</span><span class="s0">(</span><span class="s2">immer</span><span class="s0">);</span>
	<span class="s5">/**</span>
	 <span class="s5">* Apply an array of Immer patches to the first argument.</span>
	 <span class="s5">*</span>
	 <span class="s5">* This function is a producer, which means copy-on-write is in effect.</span>
	 <span class="s5">*/</span>

	<span class="s1">var </span><span class="s2">applyPatches </span><span class="s0">=</span>
	<span class="s4">/*#__PURE__*/</span>
	<span class="s2">immer</span><span class="s0">.</span><span class="s2">applyPatches</span><span class="s0">.</span><span class="s2">bind</span><span class="s0">(</span><span class="s2">immer</span><span class="s0">);</span>
	<span class="s5">/**</span>
	 <span class="s5">* Create an Immer draft from the given base state, which may be a draft itself.</span>
	 <span class="s5">* The draft can be modified until you finalize it with the `finishDraft` function.</span>
	 <span class="s5">*/</span>

	<span class="s1">var </span><span class="s2">createDraft </span><span class="s0">=</span>
	<span class="s4">/*#__PURE__*/</span>
	<span class="s2">immer</span><span class="s0">.</span><span class="s2">createDraft</span><span class="s0">.</span><span class="s2">bind</span><span class="s0">(</span><span class="s2">immer</span><span class="s0">);</span>
	<span class="s5">/**</span>
	 <span class="s5">* Finalize an Immer draft from a `createDraft` call, returning the base state</span>
	 <span class="s5">* (if no changes were made) or a modified copy. The draft must *not* be</span>
	 <span class="s5">* mutated afterwards.</span>
	 <span class="s5">*</span>
	 <span class="s5">* Pass a function as the 2nd argument to generate Immer patches based on the</span>
	 <span class="s5">* changes that were made.</span>
	 <span class="s5">*/</span>

	<span class="s1">var </span><span class="s2">finishDraft </span><span class="s0">=</span>
	<span class="s4">/*#__PURE__*/</span>
	<span class="s2">immer</span><span class="s0">.</span><span class="s2">finishDraft</span><span class="s0">.</span><span class="s2">bind</span><span class="s0">(</span><span class="s2">immer</span><span class="s0">);</span>
	<span class="s5">/**</span>
	 <span class="s5">* This function is actually a no-op, but can be used to cast an immutable type</span>
	 <span class="s5">* to an draft type and make TypeScript happy</span>
	 <span class="s5">*</span>
	 <span class="s5">* </span><span class="s7">@param </span><span class="s5">value</span>
	 <span class="s5">*/</span>

	<span class="s1">function </span><span class="s2">castDraft</span><span class="s0">(</span><span class="s2">value</span><span class="s0">) {</span>
	  <span class="s1">return </span><span class="s2">value</span><span class="s0">;</span>
	<span class="s0">}</span>
	<span class="s5">/**</span>
	 <span class="s5">* This function is actually a no-op, but can be used to cast a mutable type</span>
	 <span class="s5">* to an immutable type and make TypeScript happy</span>
	 <span class="s5">* </span><span class="s7">@param </span><span class="s5">value</span>
	 <span class="s5">*/</span>

	<span class="s1">function </span><span class="s2">castImmutable</span><span class="s0">(</span><span class="s2">value</span><span class="s0">) {</span>
	  <span class="s1">return </span><span class="s2">value</span><span class="s0">;</span>
	<span class="s0">}</span>

	<span class="s2">exports</span><span class="s0">.</span><span class="s2">Immer </span><span class="s0">= </span><span class="s2">Immer</span><span class="s0">;</span>
	<span class="s2">exports</span><span class="s0">.</span><span class="s2">applyPatches </span><span class="s0">= </span><span class="s2">applyPatches</span><span class="s0">;</span>
	<span class="s2">exports</span><span class="s0">.</span><span class="s2">castDraft </span><span class="s0">= </span><span class="s2">castDraft</span><span class="s0">;</span>
	<span class="s2">exports</span><span class="s0">.</span><span class="s2">castImmutable </span><span class="s0">= </span><span class="s2">castImmutable</span><span class="s0">;</span>
	<span class="s2">exports</span><span class="s0">.</span><span class="s2">createDraft </span><span class="s0">= </span><span class="s2">createDraft</span><span class="s0">;</span>
	<span class="s2">exports</span><span class="s0">.</span><span class="s2">current </span><span class="s0">= </span><span class="s2">current</span><span class="s0">;</span>
	<span class="s2">exports</span><span class="s0">.</span><span class="s2">default </span><span class="s0">= </span><span class="s2">produce</span><span class="s0">;</span>
	<span class="s2">exports</span><span class="s0">.</span><span class="s2">enableAllPlugins </span><span class="s0">= </span><span class="s2">enableAllPlugins</span><span class="s0">;</span>
	<span class="s2">exports</span><span class="s0">.</span><span class="s2">enableES5 </span><span class="s0">= </span><span class="s2">enableES5</span><span class="s0">;</span>
	<span class="s2">exports</span><span class="s0">.</span><span class="s2">enableMapSet </span><span class="s0">= </span><span class="s2">enableMapSet</span><span class="s0">;</span>
	<span class="s2">exports</span><span class="s0">.</span><span class="s2">enablePatches </span><span class="s0">= </span><span class="s2">enablePatches</span><span class="s0">;</span>
	<span class="s2">exports</span><span class="s0">.</span><span class="s2">finishDraft </span><span class="s0">= </span><span class="s2">finishDraft</span><span class="s0">;</span>
	<span class="s2">exports</span><span class="s0">.</span><span class="s2">freeze </span><span class="s0">= </span><span class="s2">freeze</span><span class="s0">;</span>
	<span class="s2">exports</span><span class="s0">.</span><span class="s2">immerable </span><span class="s0">= </span><span class="s2">DRAFTABLE</span><span class="s0">;</span>
	<span class="s2">exports</span><span class="s0">.</span><span class="s2">isDraft </span><span class="s0">= </span><span class="s2">isDraft</span><span class="s0">;</span>
	<span class="s2">exports</span><span class="s0">.</span><span class="s2">isDraftable </span><span class="s0">= </span><span class="s2">isDraftable</span><span class="s0">;</span>
	<span class="s2">exports</span><span class="s0">.</span><span class="s2">nothing </span><span class="s0">= </span><span class="s2">NOTHING</span><span class="s0">;</span>
	<span class="s2">exports</span><span class="s0">.</span><span class="s2">original </span><span class="s0">= </span><span class="s2">original</span><span class="s0">;</span>
	<span class="s2">exports</span><span class="s0">.</span><span class="s2">produce </span><span class="s0">= </span><span class="s2">produce</span><span class="s0">;</span>
	<span class="s2">exports</span><span class="s0">.</span><span class="s2">produceWithPatches </span><span class="s0">= </span><span class="s2">produceWithPatches</span><span class="s0">;</span>
	<span class="s2">exports</span><span class="s0">.</span><span class="s2">setAutoFreeze </span><span class="s0">= </span><span class="s2">setAutoFreeze</span><span class="s0">;</span>
	<span class="s2">exports</span><span class="s0">.</span><span class="s2">setUseProxies </span><span class="s0">= </span><span class="s2">setUseProxies</span><span class="s0">;</span>

	<span class="s2">Object</span><span class="s0">.</span><span class="s2">defineProperty</span><span class="s0">(</span><span class="s2">exports</span><span class="s0">, </span><span class="s3">'__esModule'</span><span class="s0">, { </span><span class="s2">value</span><span class="s0">: </span><span class="s1">true </span><span class="s0">});</span>

<span class="s0">})));</span>
<span class="s4">//# sourceMappingURL=immer.umd.development.js.map</span>
</pre>
</body>
</html>