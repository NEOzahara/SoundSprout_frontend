<html>
<head>
<title>indent.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #67a37c; font-style: italic;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #bcbec4;}
.s5 { color: #7a7e85;}
.s6 { color: #cf8e6d;}
.s7 { color: #2aacb8;}
.s8 { color: #42c3d4;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
indent.js</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* </span><span class="s1">@fileoverview </span><span class="s0">This rule sets a specific indentation style and width for your code</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s1">@author </span><span class="s0">Teddy Katz</span>
 <span class="s0">* </span><span class="s1">@author </span><span class="s0">Vitaly Puzrin</span>
 <span class="s0">* </span><span class="s1">@author </span><span class="s0">Gyandeep Singh</span>
 <span class="s0">* </span><span class="s1">@deprecated </span><span class="s0">in ESLint v8.53.0</span>
 <span class="s0">*/</span>

<span class="s3">&quot;use strict&quot;</span><span class="s4">;</span>

<span class="s5">//------------------------------------------------------------------------------</span>
<span class="s5">// Requirements</span>
<span class="s5">//------------------------------------------------------------------------------</span>

<span class="s6">const </span><span class="s2">astUtils </span><span class="s4">= </span><span class="s2">require</span><span class="s4">(</span><span class="s3">&quot;./utils/ast-utils&quot;</span><span class="s4">);</span>

<span class="s5">//------------------------------------------------------------------------------</span>
<span class="s5">// Rule Definition</span>
<span class="s5">//------------------------------------------------------------------------------</span>

<span class="s6">const </span><span class="s2">KNOWN_NODES </span><span class="s4">= </span><span class="s6">new </span><span class="s2">Set</span><span class="s4">([</span>
    <span class="s3">&quot;AssignmentExpression&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;AssignmentPattern&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;ArrayExpression&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;ArrayPattern&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;ArrowFunctionExpression&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;AwaitExpression&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;BlockStatement&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;BinaryExpression&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;BreakStatement&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;CallExpression&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;CatchClause&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;ChainExpression&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;ClassBody&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;ClassDeclaration&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;ClassExpression&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;ConditionalExpression&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;ContinueStatement&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;DoWhileStatement&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;DebuggerStatement&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;EmptyStatement&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;ExperimentalRestProperty&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;ExperimentalSpreadProperty&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;ExpressionStatement&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;ForStatement&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;ForInStatement&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;ForOfStatement&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;FunctionDeclaration&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;FunctionExpression&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;Identifier&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;IfStatement&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;Literal&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;LabeledStatement&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;LogicalExpression&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;MemberExpression&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;MetaProperty&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;MethodDefinition&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;NewExpression&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;ObjectExpression&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;ObjectPattern&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;PrivateIdentifier&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;Program&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;Property&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;PropertyDefinition&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;RestElement&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;ReturnStatement&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;SequenceExpression&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;SpreadElement&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;StaticBlock&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;Super&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;SwitchCase&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;SwitchStatement&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;TaggedTemplateExpression&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;TemplateElement&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;TemplateLiteral&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;ThisExpression&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;ThrowStatement&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;TryStatement&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;UnaryExpression&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;UpdateExpression&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;VariableDeclaration&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;VariableDeclarator&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;WhileStatement&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;WithStatement&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;YieldExpression&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;JSXFragment&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;JSXOpeningFragment&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;JSXClosingFragment&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;JSXIdentifier&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;JSXNamespacedName&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;JSXMemberExpression&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;JSXEmptyExpression&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;JSXExpressionContainer&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;JSXElement&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;JSXClosingElement&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;JSXOpeningElement&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;JSXAttribute&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;JSXSpreadAttribute&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;JSXText&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;ExportDefaultDeclaration&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;ExportNamedDeclaration&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;ExportAllDeclaration&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;ExportSpecifier&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;ImportDeclaration&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;ImportSpecifier&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;ImportDefaultSpecifier&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;ImportNamespaceSpecifier&quot;</span><span class="s4">,</span>
    <span class="s3">&quot;ImportExpression&quot;</span>
<span class="s4">]);</span>

<span class="s5">/* 
 * General rule strategy: 
 * 1. An OffsetStorage instance stores a map of desired offsets, where each token has a specified offset from another 
 *    specified token or to the first column. 
 * 2. As the AST is traversed, modify the desired offsets of tokens accordingly. For example, when entering a 
 *    BlockStatement, offset all of the tokens in the BlockStatement by 1 indent level from the opening curly 
 *    brace of the BlockStatement. 
 * 3. After traversing the AST, calculate the expected indentation levels of every token according to the 
 *    OffsetStorage container. 
 * 4. For each line, compare the expected indentation of the first token to the actual indentation in the file, 
 *    and report the token if the two values are not equal. 
 */</span>


<span class="s0">/**</span>
 <span class="s0">* A mutable map that stores (key, value) pairs. The keys are numeric indices, and must be unique.</span>
 <span class="s0">* This is intended to be a generic wrapper around a map with non-negative integer keys, so that the underlying implementation</span>
 <span class="s0">* can easily be swapped out.</span>
 <span class="s0">*/</span>
<span class="s6">class </span><span class="s2">IndexMap </span><span class="s4">{</span>

    <span class="s0">/**</span>
     <span class="s0">* Creates an empty map</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{number} maxKey The maximum key</span>
     <span class="s0">*/</span>
    <span class="s2">constructor</span><span class="s4">(</span><span class="s2">maxKey</span><span class="s4">) {</span>

        <span class="s5">// Initializing the array with the maximum expected size avoids dynamic reallocations that could degrade performance.</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">_values </span><span class="s4">= </span><span class="s2">Array</span><span class="s4">(</span><span class="s2">maxKey </span><span class="s4">+ </span><span class="s7">1</span><span class="s4">);</span>
    <span class="s4">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Inserts an entry into the map.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{number} key The entry's key</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{any} value The entry's value</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
     <span class="s0">*/</span>
    <span class="s2">insert</span><span class="s4">(</span><span class="s2">key</span><span class="s4">, </span><span class="s2">value</span><span class="s4">) {</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">_values</span><span class="s4">[</span><span class="s2">key</span><span class="s4">] = </span><span class="s2">value</span><span class="s4">;</span>
    <span class="s4">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Finds the value of the entry with the largest key less than or equal to the provided key</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{number} key The provided key</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{*|undefined} The value of the found entry, or undefined if no such entry exists.</span>
     <span class="s0">*/</span>
    <span class="s2">findLastNotAfter</span><span class="s4">(</span><span class="s2">key</span><span class="s4">) {</span>
        <span class="s6">const </span><span class="s2">values </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">_values</span><span class="s4">;</span>

        <span class="s6">for </span><span class="s4">(</span><span class="s6">let </span><span class="s2">index </span><span class="s4">= </span><span class="s2">key</span><span class="s4">; </span><span class="s2">index </span><span class="s4">&gt;= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">index</span><span class="s4">--) {</span>
            <span class="s6">const </span><span class="s2">value </span><span class="s4">= </span><span class="s2">values</span><span class="s4">[</span><span class="s2">index</span><span class="s4">];</span>

            <span class="s6">if </span><span class="s4">(</span><span class="s2">value</span><span class="s4">) {</span>
                <span class="s6">return </span><span class="s2">value</span><span class="s4">;</span>
            <span class="s4">}</span>
        <span class="s4">}</span>
        <span class="s6">return void </span><span class="s7">0</span><span class="s4">;</span>
    <span class="s4">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Deletes all of the keys in the interval [start, end)</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{number} start The start of the range</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{number} end The end of the range</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
     <span class="s0">*/</span>
    <span class="s2">deleteRange</span><span class="s4">(</span><span class="s2">start</span><span class="s4">, </span><span class="s2">end</span><span class="s4">) {</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">_values</span><span class="s4">.</span><span class="s2">fill</span><span class="s4">(</span><span class="s6">void </span><span class="s7">0</span><span class="s4">, </span><span class="s2">start</span><span class="s4">, </span><span class="s2">end</span><span class="s4">);</span>
    <span class="s4">}</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* A helper class to get token-based info related to indentation</span>
 <span class="s0">*/</span>
<span class="s6">class </span><span class="s2">TokenInfo </span><span class="s4">{</span>

    <span class="s0">/**</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{SourceCode} sourceCode A SourceCode object</span>
     <span class="s0">*/</span>
    <span class="s2">constructor</span><span class="s4">(</span><span class="s2">sourceCode</span><span class="s4">) {</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">sourceCode </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">;</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">firstTokensByLineNumber </span><span class="s4">= </span><span class="s6">new </span><span class="s2">Map</span><span class="s4">();</span>
        <span class="s6">const </span><span class="s2">tokens </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">tokensAndComments</span><span class="s4">;</span>

        <span class="s6">for </span><span class="s4">(</span><span class="s6">let </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s2">tokens</span><span class="s4">.</span><span class="s2">length</span><span class="s4">; </span><span class="s2">i</span><span class="s4">++) {</span>
            <span class="s6">const </span><span class="s2">token </span><span class="s4">= </span><span class="s2">tokens</span><span class="s4">[</span><span class="s2">i</span><span class="s4">];</span>

            <span class="s6">if </span><span class="s4">(!</span><span class="s6">this</span><span class="s4">.</span><span class="s2">firstTokensByLineNumber</span><span class="s4">.</span><span class="s2">has</span><span class="s4">(</span><span class="s2">token</span><span class="s4">.</span><span class="s2">loc</span><span class="s4">.</span><span class="s2">start</span><span class="s4">.</span><span class="s2">line</span><span class="s4">)) {</span>
                <span class="s6">this</span><span class="s4">.</span><span class="s2">firstTokensByLineNumber</span><span class="s4">.</span><span class="s2">set</span><span class="s4">(</span><span class="s2">token</span><span class="s4">.</span><span class="s2">loc</span><span class="s4">.</span><span class="s2">start</span><span class="s4">.</span><span class="s2">line</span><span class="s4">, </span><span class="s2">token</span><span class="s4">);</span>
            <span class="s4">}</span>
            <span class="s6">if </span><span class="s4">(!</span><span class="s6">this</span><span class="s4">.</span><span class="s2">firstTokensByLineNumber</span><span class="s4">.</span><span class="s2">has</span><span class="s4">(</span><span class="s2">token</span><span class="s4">.</span><span class="s2">loc</span><span class="s4">.</span><span class="s2">end</span><span class="s4">.</span><span class="s2">line</span><span class="s4">) &amp;&amp; </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">text</span><span class="s4">.</span><span class="s2">slice</span><span class="s4">(</span><span class="s2">token</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s7">1</span><span class="s4">] - </span><span class="s2">token</span><span class="s4">.</span><span class="s2">loc</span><span class="s4">.</span><span class="s2">end</span><span class="s4">.</span><span class="s2">column</span><span class="s4">, </span><span class="s2">token</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s7">1</span><span class="s4">]).</span><span class="s2">trim</span><span class="s4">()) {</span>
                <span class="s6">this</span><span class="s4">.</span><span class="s2">firstTokensByLineNumber</span><span class="s4">.</span><span class="s2">set</span><span class="s4">(</span><span class="s2">token</span><span class="s4">.</span><span class="s2">loc</span><span class="s4">.</span><span class="s2">end</span><span class="s4">.</span><span class="s2">line</span><span class="s4">, </span><span class="s2">token</span><span class="s4">);</span>
            <span class="s4">}</span>
        <span class="s4">}</span>
    <span class="s4">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Gets the first token on a given token's line</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Token|ASTNode} token a node or token</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Token} The first token on the given line</span>
     <span class="s0">*/</span>
    <span class="s2">getFirstTokenOfLine</span><span class="s4">(</span><span class="s2">token</span><span class="s4">) {</span>
        <span class="s6">return this</span><span class="s4">.</span><span class="s2">firstTokensByLineNumber</span><span class="s4">.</span><span class="s2">get</span><span class="s4">(</span><span class="s2">token</span><span class="s4">.</span><span class="s2">loc</span><span class="s4">.</span><span class="s2">start</span><span class="s4">.</span><span class="s2">line</span><span class="s4">);</span>
    <span class="s4">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Determines whether a token is the first token in its line</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Token} token The token</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} `true` if the token is the first on its line</span>
     <span class="s0">*/</span>
    <span class="s2">isFirstTokenOfLine</span><span class="s4">(</span><span class="s2">token</span><span class="s4">) {</span>
        <span class="s6">return this</span><span class="s4">.</span><span class="s2">getFirstTokenOfLine</span><span class="s4">(</span><span class="s2">token</span><span class="s4">) === </span><span class="s2">token</span><span class="s4">;</span>
    <span class="s4">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Get the actual indent of a token</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Token} token Token to examine. This should be the first token on its line.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{string} The indentation characters that precede the token</span>
     <span class="s0">*/</span>
    <span class="s2">getTokenIndent</span><span class="s4">(</span><span class="s2">token</span><span class="s4">) {</span>
        <span class="s6">return this</span><span class="s4">.</span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">text</span><span class="s4">.</span><span class="s2">slice</span><span class="s4">(</span><span class="s2">token</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s7">0</span><span class="s4">] - </span><span class="s2">token</span><span class="s4">.</span><span class="s2">loc</span><span class="s4">.</span><span class="s2">start</span><span class="s4">.</span><span class="s2">column</span><span class="s4">, </span><span class="s2">token</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s7">0</span><span class="s4">]);</span>
    <span class="s4">}</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* A class to store information on desired offsets of tokens from each other</span>
 <span class="s0">*/</span>
<span class="s6">class </span><span class="s2">OffsetStorage </span><span class="s4">{</span>

    <span class="s0">/**</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{TokenInfo} tokenInfo a TokenInfo instance</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{number} indentSize The desired size of each indentation level</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} indentType The indentation character</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{number} maxIndex The maximum end index of any token</span>
     <span class="s0">*/</span>
    <span class="s2">constructor</span><span class="s4">(</span><span class="s2">tokenInfo</span><span class="s4">, </span><span class="s2">indentSize</span><span class="s4">, </span><span class="s2">indentType</span><span class="s4">, </span><span class="s2">maxIndex</span><span class="s4">) {</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">_tokenInfo </span><span class="s4">= </span><span class="s2">tokenInfo</span><span class="s4">;</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">_indentSize </span><span class="s4">= </span><span class="s2">indentSize</span><span class="s4">;</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">_indentType </span><span class="s4">= </span><span class="s2">indentType</span><span class="s4">;</span>

        <span class="s6">this</span><span class="s4">.</span><span class="s2">_indexMap </span><span class="s4">= </span><span class="s6">new </span><span class="s2">IndexMap</span><span class="s4">(</span><span class="s2">maxIndex</span><span class="s4">);</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">_indexMap</span><span class="s4">.</span><span class="s2">insert</span><span class="s4">(</span><span class="s7">0</span><span class="s4">, { </span><span class="s2">offset</span><span class="s4">: </span><span class="s7">0</span><span class="s4">, </span><span class="s2">from</span><span class="s4">: </span><span class="s6">null</span><span class="s4">, </span><span class="s2">force</span><span class="s4">: </span><span class="s6">false </span><span class="s4">});</span>

        <span class="s6">this</span><span class="s4">.</span><span class="s2">_lockedFirstTokens </span><span class="s4">= </span><span class="s6">new </span><span class="s2">WeakMap</span><span class="s4">();</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">_desiredIndentCache </span><span class="s4">= </span><span class="s6">new </span><span class="s2">WeakMap</span><span class="s4">();</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">_ignoredTokens </span><span class="s4">= </span><span class="s6">new </span><span class="s2">WeakSet</span><span class="s4">();</span>
    <span class="s4">}</span>

    <span class="s2">_getOffsetDescriptor</span><span class="s4">(</span><span class="s2">token</span><span class="s4">) {</span>
        <span class="s6">return this</span><span class="s4">.</span><span class="s2">_indexMap</span><span class="s4">.</span><span class="s2">findLastNotAfter</span><span class="s4">(</span><span class="s2">token</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s7">0</span><span class="s4">]);</span>
    <span class="s4">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Sets the offset column of token B to match the offset column of token A.</span>
     <span class="s0">* - **WARNING**: This matches a *column*, even if baseToken is not the first token on its line. In</span>
     <span class="s0">* most cases, `setDesiredOffset` should be used instead.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Token} baseToken The first token</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Token} offsetToken The second token, whose offset should be matched to the first token</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
     <span class="s0">*/</span>
    <span class="s2">matchOffsetOf</span><span class="s4">(</span><span class="s2">baseToken</span><span class="s4">, </span><span class="s2">offsetToken</span><span class="s4">) {</span>

        <span class="s5">/* 
         * lockedFirstTokens is a map from a token whose indentation is controlled by the &quot;first&quot; option to 
         * the token that it depends on. For example, with the `ArrayExpression: first` option, the first 
         * token of each element in the array after the first will be mapped to the first token of the first 
         * element. The desired indentation of each of these tokens is computed based on the desired indentation 
         * of the &quot;first&quot; element, rather than through the normal offset mechanism. 
         */</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">_lockedFirstTokens</span><span class="s4">.</span><span class="s2">set</span><span class="s4">(</span><span class="s2">offsetToken</span><span class="s4">, </span><span class="s2">baseToken</span><span class="s4">);</span>
    <span class="s4">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Sets the desired offset of a token.</span>
     <span class="s0">*</span>
     <span class="s0">* This uses a line-based offset collapsing behavior to handle tokens on the same line.</span>
     <span class="s0">* For example, consider the following two cases:</span>
     <span class="s0">*</span>
     <span class="s0">* (</span>
     <span class="s0">*     [</span>
     <span class="s0">*         bar</span>
     <span class="s0">*     ]</span>
     <span class="s0">* )</span>
     <span class="s0">*</span>
     <span class="s0">* ([</span>
     <span class="s0">*     bar</span>
     <span class="s0">* ])</span>
     <span class="s0">*</span>
     <span class="s0">* Based on the first case, it's clear that the `bar` token needs to have an offset of 1 indent level (4 spaces) from</span>
     <span class="s0">* the `[` token, and the `[` token has to have an offset of 1 indent level from the `(` token. Since the `(` token is</span>
     <span class="s0">* the first on its line (with an indent of 0 spaces), the `bar` token needs to be offset by 2 indent levels (8 spaces)</span>
     <span class="s0">* from the start of its line.</span>
     <span class="s0">*</span>
     <span class="s0">* However, in the second case `bar` should only be indented by 4 spaces. This is because the offset of 1 indent level</span>
     <span class="s0">* between the `(` and the `[` tokens gets &quot;collapsed&quot; because the two tokens are on the same line. As a result, the</span>
     <span class="s0">* `(` token is mapped to the `[` token with an offset of 0, and the rule correctly decides that `bar` should be indented</span>
     <span class="s0">* by 1 indent level from the start of the line.</span>
     <span class="s0">*</span>
     <span class="s0">* This is useful because rule listeners can usually just call `setDesiredOffset` for all the tokens in the node,</span>
     <span class="s0">* without needing to check which lines those tokens are on.</span>
     <span class="s0">*</span>
     <span class="s0">* Note that since collapsing only occurs when two tokens are on the same line, there are a few cases where non-intuitive</span>
     <span class="s0">* behavior can occur. For example, consider the following cases:</span>
     <span class="s0">*</span>
     <span class="s0">* foo(</span>
     <span class="s0">* ).</span>
     <span class="s0">*     bar(</span>
     <span class="s0">*         baz</span>
     <span class="s0">*     )</span>
     <span class="s0">*</span>
     <span class="s0">* foo(</span>
     <span class="s0">* ).bar(</span>
     <span class="s0">*     baz</span>
     <span class="s0">* )</span>
     <span class="s0">*</span>
     <span class="s0">* Based on the first example, it would seem that `bar` should be offset by 1 indent level from `foo`, and `baz`</span>
     <span class="s0">* should be offset by 1 indent level from `bar`. However, this is not correct, because it would result in `baz`</span>
     <span class="s0">* being indented by 2 indent levels in the second case (since `foo`, `bar`, and `baz` are all on separate lines, no</span>
     <span class="s0">* collapsing would occur).</span>
     <span class="s0">*</span>
     <span class="s0">* Instead, the correct way would be to offset `baz` by 1 level from `bar`, offset `bar` by 1 level from the `)`, and</span>
     <span class="s0">* offset the `)` by 0 levels from `foo`. This ensures that the offset between `bar` and the `)` are correctly collapsed</span>
     <span class="s0">* in the second case.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Token} token The token</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Token} fromToken The token that `token` should be offset from</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{number} offset The desired indent level</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
     <span class="s0">*/</span>
    <span class="s2">setDesiredOffset</span><span class="s4">(</span><span class="s2">token</span><span class="s4">, </span><span class="s2">fromToken</span><span class="s4">, </span><span class="s2">offset</span><span class="s4">) {</span>
        <span class="s6">return this</span><span class="s4">.</span><span class="s2">setDesiredOffsets</span><span class="s4">(</span><span class="s2">token</span><span class="s4">.</span><span class="s2">range</span><span class="s4">, </span><span class="s2">fromToken</span><span class="s4">, </span><span class="s2">offset</span><span class="s4">);</span>
    <span class="s4">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Sets the desired offset of all tokens in a range</span>
     <span class="s0">* It's common for node listeners in this file to need to apply the same offset to a large, contiguous range of tokens.</span>
     <span class="s0">* Moreover, the offset of any given token is usually updated multiple times (roughly once for each node that contains</span>
     <span class="s0">* it). This means that the offset of each token is updated O(AST depth) times.</span>
     <span class="s0">* It would not be performant to store and update the offsets for each token independently, because the rule would end</span>
     <span class="s0">* up having a time complexity of O(number of tokens * AST depth), which is quite slow for large files.</span>
     <span class="s0">*</span>
     <span class="s0">* Instead, the offset tree is represented as a collection of contiguous offset ranges in a file. For example, the following</span>
     <span class="s0">* list could represent the state of the offset tree at a given point:</span>
     <span class="s0">*</span>
     <span class="s0">* - Tokens starting in the interval [0, 15) are aligned with the beginning of the file</span>
     <span class="s0">* - Tokens starting in the interval [15, 30) are offset by 1 indent level from the `bar` token</span>
     <span class="s0">* - Tokens starting in the interval [30, 43) are offset by 1 indent level from the `foo` token</span>
     <span class="s0">* - Tokens starting in the interval [43, 820) are offset by 2 indent levels from the `bar` token</span>
     <span class="s0">* - Tokens starting in the interval [820, âˆž) are offset by 1 indent level from the `baz` token</span>
     <span class="s0">*</span>
     <span class="s0">* The `setDesiredOffsets` methods inserts ranges like the ones above. The third line above would be inserted by using:</span>
     <span class="s0">* `setDesiredOffsets([30, 43], fooToken, 1);`</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{[number, number]} range A [start, end] pair. All tokens with range[0] &lt;= token.start &lt; range[1] will have the offset applied.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Token} fromToken The token that this is offset from</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{number} offset The desired indent level</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{boolean} force `true` if this offset should not use the normal collapsing behavior. This should almost always be false.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
     <span class="s0">*/</span>
    <span class="s2">setDesiredOffsets</span><span class="s4">(</span><span class="s2">range</span><span class="s4">, </span><span class="s2">fromToken</span><span class="s4">, </span><span class="s2">offset</span><span class="s4">, </span><span class="s2">force</span><span class="s4">) {</span>

        <span class="s5">/* 
         * Offset ranges are stored as a collection of nodes, where each node maps a numeric key to an offset 
         * descriptor. The tree for the example above would have the following nodes: 
         * 
         * * key: 0, value: { offset: 0, from: null } 
         * * key: 15, value: { offset: 1, from: barToken } 
         * * key: 30, value: { offset: 1, from: fooToken } 
         * * key: 43, value: { offset: 2, from: barToken } 
         * * key: 820, value: { offset: 1, from: bazToken } 
         * 
         * To find the offset descriptor for any given token, one needs to find the node with the largest key 
         * which is &lt;= token.start. To make this operation fast, the nodes are stored in a map indexed by key. 
         */</span>

        <span class="s6">const </span><span class="s2">descriptorToInsert </span><span class="s4">= { </span><span class="s2">offset</span><span class="s4">, </span><span class="s2">from</span><span class="s4">: </span><span class="s2">fromToken</span><span class="s4">, </span><span class="s2">force </span><span class="s4">};</span>

        <span class="s6">const </span><span class="s2">descriptorAfterRange </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">_indexMap</span><span class="s4">.</span><span class="s2">findLastNotAfter</span><span class="s4">(</span><span class="s2">range</span><span class="s4">[</span><span class="s7">1</span><span class="s4">]);</span>

        <span class="s6">const </span><span class="s2">fromTokenIsInRange </span><span class="s4">= </span><span class="s2">fromToken </span><span class="s4">&amp;&amp; </span><span class="s2">fromToken</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s7">0</span><span class="s4">] &gt;= </span><span class="s2">range</span><span class="s4">[</span><span class="s7">0</span><span class="s4">] &amp;&amp; </span><span class="s2">fromToken</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s7">1</span><span class="s4">] &lt;= </span><span class="s2">range</span><span class="s4">[</span><span class="s7">1</span><span class="s4">];</span>
        <span class="s6">const </span><span class="s2">fromTokenDescriptor </span><span class="s4">= </span><span class="s2">fromTokenIsInRange </span><span class="s4">&amp;&amp; </span><span class="s6">this</span><span class="s4">.</span><span class="s2">_getOffsetDescriptor</span><span class="s4">(</span><span class="s2">fromToken</span><span class="s4">);</span>

        <span class="s5">// First, remove any existing nodes in the range from the map.</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">_indexMap</span><span class="s4">.</span><span class="s2">deleteRange</span><span class="s4">(</span><span class="s2">range</span><span class="s4">[</span><span class="s7">0</span><span class="s4">] + </span><span class="s7">1</span><span class="s4">, </span><span class="s2">range</span><span class="s4">[</span><span class="s7">1</span><span class="s4">]);</span>

        <span class="s5">// Insert a new node into the map for this range</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">_indexMap</span><span class="s4">.</span><span class="s2">insert</span><span class="s4">(</span><span class="s2">range</span><span class="s4">[</span><span class="s7">0</span><span class="s4">], </span><span class="s2">descriptorToInsert</span><span class="s4">);</span>

        <span class="s5">/* 
         * To avoid circular offset dependencies, keep the `fromToken` token mapped to whatever it was mapped to previously, 
         * even if it's in the current range. 
         */</span>
        <span class="s6">if </span><span class="s4">(</span><span class="s2">fromTokenIsInRange</span><span class="s4">) {</span>
            <span class="s6">this</span><span class="s4">.</span><span class="s2">_indexMap</span><span class="s4">.</span><span class="s2">insert</span><span class="s4">(</span><span class="s2">fromToken</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s7">0</span><span class="s4">], </span><span class="s2">fromTokenDescriptor</span><span class="s4">);</span>
            <span class="s6">this</span><span class="s4">.</span><span class="s2">_indexMap</span><span class="s4">.</span><span class="s2">insert</span><span class="s4">(</span><span class="s2">fromToken</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s7">1</span><span class="s4">], </span><span class="s2">descriptorToInsert</span><span class="s4">);</span>
        <span class="s4">}</span>

        <span class="s5">/* 
         * To avoid modifying the offset of tokens after the range, insert another node to keep the offset of the following 
         * tokens the same as it was before. 
         */</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">_indexMap</span><span class="s4">.</span><span class="s2">insert</span><span class="s4">(</span><span class="s2">range</span><span class="s4">[</span><span class="s7">1</span><span class="s4">], </span><span class="s2">descriptorAfterRange</span><span class="s4">);</span>
    <span class="s4">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Gets the desired indent of a token</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Token} token The token</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{string} The desired indent of the token</span>
     <span class="s0">*/</span>
    <span class="s2">getDesiredIndent</span><span class="s4">(</span><span class="s2">token</span><span class="s4">) {</span>
        <span class="s6">if </span><span class="s4">(!</span><span class="s6">this</span><span class="s4">.</span><span class="s2">_desiredIndentCache</span><span class="s4">.</span><span class="s2">has</span><span class="s4">(</span><span class="s2">token</span><span class="s4">)) {</span>

            <span class="s6">if </span><span class="s4">(</span><span class="s6">this</span><span class="s4">.</span><span class="s2">_ignoredTokens</span><span class="s4">.</span><span class="s2">has</span><span class="s4">(</span><span class="s2">token</span><span class="s4">)) {</span>

                <span class="s5">/* 
                 * If the token is ignored, use the actual indent of the token as the desired indent. 
                 * This ensures that no errors are reported for this token. 
                 */</span>
                <span class="s6">this</span><span class="s4">.</span><span class="s2">_desiredIndentCache</span><span class="s4">.</span><span class="s2">set</span><span class="s4">(</span>
                    <span class="s2">token</span><span class="s4">,</span>
                    <span class="s6">this</span><span class="s4">.</span><span class="s2">_tokenInfo</span><span class="s4">.</span><span class="s2">getTokenIndent</span><span class="s4">(</span><span class="s2">token</span><span class="s4">)</span>
                <span class="s4">);</span>
            <span class="s4">} </span><span class="s6">else if </span><span class="s4">(</span><span class="s6">this</span><span class="s4">.</span><span class="s2">_lockedFirstTokens</span><span class="s4">.</span><span class="s2">has</span><span class="s4">(</span><span class="s2">token</span><span class="s4">)) {</span>
                <span class="s6">const </span><span class="s2">firstToken </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">_lockedFirstTokens</span><span class="s4">.</span><span class="s2">get</span><span class="s4">(</span><span class="s2">token</span><span class="s4">);</span>

                <span class="s6">this</span><span class="s4">.</span><span class="s2">_desiredIndentCache</span><span class="s4">.</span><span class="s2">set</span><span class="s4">(</span>
                    <span class="s2">token</span><span class="s4">,</span>

                    <span class="s5">// (indentation for the first element's line)</span>
                    <span class="s6">this</span><span class="s4">.</span><span class="s2">getDesiredIndent</span><span class="s4">(</span><span class="s6">this</span><span class="s4">.</span><span class="s2">_tokenInfo</span><span class="s4">.</span><span class="s2">getFirstTokenOfLine</span><span class="s4">(</span><span class="s2">firstToken</span><span class="s4">)) +</span>

                        <span class="s5">// (space between the start of the first element's line and the first element)</span>
                        <span class="s6">this</span><span class="s4">.</span><span class="s2">_indentType</span><span class="s4">.</span><span class="s2">repeat</span><span class="s4">(</span><span class="s2">firstToken</span><span class="s4">.</span><span class="s2">loc</span><span class="s4">.</span><span class="s2">start</span><span class="s4">.</span><span class="s2">column </span><span class="s4">- </span><span class="s6">this</span><span class="s4">.</span><span class="s2">_tokenInfo</span><span class="s4">.</span><span class="s2">getFirstTokenOfLine</span><span class="s4">(</span><span class="s2">firstToken</span><span class="s4">).</span><span class="s2">loc</span><span class="s4">.</span><span class="s2">start</span><span class="s4">.</span><span class="s2">column</span><span class="s4">)</span>
                <span class="s4">);</span>
            <span class="s4">} </span><span class="s6">else </span><span class="s4">{</span>
                <span class="s6">const </span><span class="s2">offsetInfo </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">_getOffsetDescriptor</span><span class="s4">(</span><span class="s2">token</span><span class="s4">);</span>
                <span class="s6">const </span><span class="s2">offset </span><span class="s4">= (</span>
                    <span class="s2">offsetInfo</span><span class="s4">.</span><span class="s2">from </span><span class="s4">&amp;&amp;</span>
                    <span class="s2">offsetInfo</span><span class="s4">.</span><span class="s2">from</span><span class="s4">.</span><span class="s2">loc</span><span class="s4">.</span><span class="s2">start</span><span class="s4">.</span><span class="s2">line </span><span class="s4">=== </span><span class="s2">token</span><span class="s4">.</span><span class="s2">loc</span><span class="s4">.</span><span class="s2">start</span><span class="s4">.</span><span class="s2">line </span><span class="s4">&amp;&amp;</span>
                    <span class="s4">!</span><span class="s8">/^\s*?\n/u</span><span class="s4">.</span><span class="s2">test</span><span class="s4">(</span><span class="s2">token</span><span class="s4">.</span><span class="s2">value</span><span class="s4">) &amp;&amp;</span>
                    <span class="s4">!</span><span class="s2">offsetInfo</span><span class="s4">.</span><span class="s2">force</span>
                <span class="s4">) ? </span><span class="s7">0 </span><span class="s4">: </span><span class="s2">offsetInfo</span><span class="s4">.</span><span class="s2">offset </span><span class="s4">* </span><span class="s6">this</span><span class="s4">.</span><span class="s2">_indentSize</span><span class="s4">;</span>

                <span class="s6">this</span><span class="s4">.</span><span class="s2">_desiredIndentCache</span><span class="s4">.</span><span class="s2">set</span><span class="s4">(</span>
                    <span class="s2">token</span><span class="s4">,</span>
                    <span class="s4">(</span><span class="s2">offsetInfo</span><span class="s4">.</span><span class="s2">from </span><span class="s4">? </span><span class="s6">this</span><span class="s4">.</span><span class="s2">getDesiredIndent</span><span class="s4">(</span><span class="s2">offsetInfo</span><span class="s4">.</span><span class="s2">from</span><span class="s4">) : </span><span class="s3">&quot;&quot;</span><span class="s4">) + </span><span class="s6">this</span><span class="s4">.</span><span class="s2">_indentType</span><span class="s4">.</span><span class="s2">repeat</span><span class="s4">(</span><span class="s2">offset</span><span class="s4">)</span>
                <span class="s4">);</span>
            <span class="s4">}</span>
        <span class="s4">}</span>
        <span class="s6">return this</span><span class="s4">.</span><span class="s2">_desiredIndentCache</span><span class="s4">.</span><span class="s2">get</span><span class="s4">(</span><span class="s2">token</span><span class="s4">);</span>
    <span class="s4">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Ignores a token, preventing it from being reported.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Token} token The token</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
     <span class="s0">*/</span>
    <span class="s2">ignoreToken</span><span class="s4">(</span><span class="s2">token</span><span class="s4">) {</span>
        <span class="s6">if </span><span class="s4">(</span><span class="s6">this</span><span class="s4">.</span><span class="s2">_tokenInfo</span><span class="s4">.</span><span class="s2">isFirstTokenOfLine</span><span class="s4">(</span><span class="s2">token</span><span class="s4">)) {</span>
            <span class="s6">this</span><span class="s4">.</span><span class="s2">_ignoredTokens</span><span class="s4">.</span><span class="s2">add</span><span class="s4">(</span><span class="s2">token</span><span class="s4">);</span>
        <span class="s4">}</span>
    <span class="s4">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Gets the first token that the given token's indentation is dependent on</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Token} token The token</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Token} The token that the given token depends on, or `null` if the given token is at the top level</span>
     <span class="s0">*/</span>
    <span class="s2">getFirstDependency</span><span class="s4">(</span><span class="s2">token</span><span class="s4">) {</span>
        <span class="s6">return this</span><span class="s4">.</span><span class="s2">_getOffsetDescriptor</span><span class="s4">(</span><span class="s2">token</span><span class="s4">).</span><span class="s2">from</span><span class="s4">;</span>
    <span class="s4">}</span>
<span class="s4">}</span>

<span class="s6">const </span><span class="s2">ELEMENT_LIST_SCHEMA </span><span class="s4">= {</span>
    <span class="s2">oneOf</span><span class="s4">: [</span>
        <span class="s4">{</span>
            <span class="s2">type</span><span class="s4">: </span><span class="s3">&quot;integer&quot;</span><span class="s4">,</span>
            <span class="s2">minimum</span><span class="s4">: </span><span class="s7">0</span>
        <span class="s4">},</span>
        <span class="s4">{</span>
            <span class="s6">enum</span><span class="s4">: [</span><span class="s3">&quot;first&quot;</span><span class="s4">, </span><span class="s3">&quot;off&quot;</span><span class="s4">]</span>
        <span class="s4">}</span>
    <span class="s4">]</span>
<span class="s4">};</span>

<span class="s0">/** </span><span class="s1">@type </span><span class="s0">{import('../shared/types').Rule} */</span>
<span class="s2">module</span><span class="s4">.</span><span class="s2">exports </span><span class="s4">= {</span>
    <span class="s2">meta</span><span class="s4">: {</span>
        <span class="s2">deprecated</span><span class="s4">: </span><span class="s6">true</span><span class="s4">,</span>
        <span class="s2">replacedBy</span><span class="s4">: [],</span>
        <span class="s2">type</span><span class="s4">: </span><span class="s3">&quot;layout&quot;</span><span class="s4">,</span>

        <span class="s2">docs</span><span class="s4">: {</span>
            <span class="s2">description</span><span class="s4">: </span><span class="s3">&quot;Enforce consistent indentation&quot;</span><span class="s4">,</span>
            <span class="s2">recommended</span><span class="s4">: </span><span class="s6">false</span><span class="s4">,</span>
            <span class="s2">url</span><span class="s4">: </span><span class="s3">&quot;https://eslint.org/docs/latest/rules/indent&quot;</span>
        <span class="s4">},</span>

        <span class="s2">fixable</span><span class="s4">: </span><span class="s3">&quot;whitespace&quot;</span><span class="s4">,</span>

        <span class="s2">schema</span><span class="s4">: [</span>
            <span class="s4">{</span>
                <span class="s2">oneOf</span><span class="s4">: [</span>
                    <span class="s4">{</span>
                        <span class="s6">enum</span><span class="s4">: [</span><span class="s3">&quot;tab&quot;</span><span class="s4">]</span>
                    <span class="s4">},</span>
                    <span class="s4">{</span>
                        <span class="s2">type</span><span class="s4">: </span><span class="s3">&quot;integer&quot;</span><span class="s4">,</span>
                        <span class="s2">minimum</span><span class="s4">: </span><span class="s7">0</span>
                    <span class="s4">}</span>
                <span class="s4">]</span>
            <span class="s4">},</span>
            <span class="s4">{</span>
                <span class="s2">type</span><span class="s4">: </span><span class="s3">&quot;object&quot;</span><span class="s4">,</span>
                <span class="s2">properties</span><span class="s4">: {</span>
                    <span class="s2">SwitchCase</span><span class="s4">: {</span>
                        <span class="s2">type</span><span class="s4">: </span><span class="s3">&quot;integer&quot;</span><span class="s4">,</span>
                        <span class="s2">minimum</span><span class="s4">: </span><span class="s7">0</span><span class="s4">,</span>
                        <span class="s6">default</span><span class="s4">: </span><span class="s7">0</span>
                    <span class="s4">},</span>
                    <span class="s2">VariableDeclarator</span><span class="s4">: {</span>
                        <span class="s2">oneOf</span><span class="s4">: [</span>
                            <span class="s2">ELEMENT_LIST_SCHEMA</span><span class="s4">,</span>
                            <span class="s4">{</span>
                                <span class="s2">type</span><span class="s4">: </span><span class="s3">&quot;object&quot;</span><span class="s4">,</span>
                                <span class="s2">properties</span><span class="s4">: {</span>
                                    <span class="s6">var</span><span class="s4">: </span><span class="s2">ELEMENT_LIST_SCHEMA</span><span class="s4">,</span>
                                    <span class="s6">let</span><span class="s4">: </span><span class="s2">ELEMENT_LIST_SCHEMA</span><span class="s4">,</span>
                                    <span class="s6">const</span><span class="s4">: </span><span class="s2">ELEMENT_LIST_SCHEMA</span>
                                <span class="s4">},</span>
                                <span class="s2">additionalProperties</span><span class="s4">: </span><span class="s6">false</span>
                            <span class="s4">}</span>
                        <span class="s4">]</span>
                    <span class="s4">},</span>
                    <span class="s2">outerIIFEBody</span><span class="s4">: {</span>
                        <span class="s2">oneOf</span><span class="s4">: [</span>
                            <span class="s4">{</span>
                                <span class="s2">type</span><span class="s4">: </span><span class="s3">&quot;integer&quot;</span><span class="s4">,</span>
                                <span class="s2">minimum</span><span class="s4">: </span><span class="s7">0</span>
                            <span class="s4">},</span>
                            <span class="s4">{</span>
                                <span class="s6">enum</span><span class="s4">: [</span><span class="s3">&quot;off&quot;</span><span class="s4">]</span>
                            <span class="s4">}</span>
                        <span class="s4">]</span>
                    <span class="s4">},</span>
                    <span class="s2">MemberExpression</span><span class="s4">: {</span>
                        <span class="s2">oneOf</span><span class="s4">: [</span>
                            <span class="s4">{</span>
                                <span class="s2">type</span><span class="s4">: </span><span class="s3">&quot;integer&quot;</span><span class="s4">,</span>
                                <span class="s2">minimum</span><span class="s4">: </span><span class="s7">0</span>
                            <span class="s4">},</span>
                            <span class="s4">{</span>
                                <span class="s6">enum</span><span class="s4">: [</span><span class="s3">&quot;off&quot;</span><span class="s4">]</span>
                            <span class="s4">}</span>
                        <span class="s4">]</span>
                    <span class="s4">},</span>
                    <span class="s2">FunctionDeclaration</span><span class="s4">: {</span>
                        <span class="s2">type</span><span class="s4">: </span><span class="s3">&quot;object&quot;</span><span class="s4">,</span>
                        <span class="s2">properties</span><span class="s4">: {</span>
                            <span class="s2">parameters</span><span class="s4">: </span><span class="s2">ELEMENT_LIST_SCHEMA</span><span class="s4">,</span>
                            <span class="s2">body</span><span class="s4">: {</span>
                                <span class="s2">type</span><span class="s4">: </span><span class="s3">&quot;integer&quot;</span><span class="s4">,</span>
                                <span class="s2">minimum</span><span class="s4">: </span><span class="s7">0</span>
                            <span class="s4">}</span>
                        <span class="s4">},</span>
                        <span class="s2">additionalProperties</span><span class="s4">: </span><span class="s6">false</span>
                    <span class="s4">},</span>
                    <span class="s2">FunctionExpression</span><span class="s4">: {</span>
                        <span class="s2">type</span><span class="s4">: </span><span class="s3">&quot;object&quot;</span><span class="s4">,</span>
                        <span class="s2">properties</span><span class="s4">: {</span>
                            <span class="s2">parameters</span><span class="s4">: </span><span class="s2">ELEMENT_LIST_SCHEMA</span><span class="s4">,</span>
                            <span class="s2">body</span><span class="s4">: {</span>
                                <span class="s2">type</span><span class="s4">: </span><span class="s3">&quot;integer&quot;</span><span class="s4">,</span>
                                <span class="s2">minimum</span><span class="s4">: </span><span class="s7">0</span>
                            <span class="s4">}</span>
                        <span class="s4">},</span>
                        <span class="s2">additionalProperties</span><span class="s4">: </span><span class="s6">false</span>
                    <span class="s4">},</span>
                    <span class="s2">StaticBlock</span><span class="s4">: {</span>
                        <span class="s2">type</span><span class="s4">: </span><span class="s3">&quot;object&quot;</span><span class="s4">,</span>
                        <span class="s2">properties</span><span class="s4">: {</span>
                            <span class="s2">body</span><span class="s4">: {</span>
                                <span class="s2">type</span><span class="s4">: </span><span class="s3">&quot;integer&quot;</span><span class="s4">,</span>
                                <span class="s2">minimum</span><span class="s4">: </span><span class="s7">0</span>
                            <span class="s4">}</span>
                        <span class="s4">},</span>
                        <span class="s2">additionalProperties</span><span class="s4">: </span><span class="s6">false</span>
                    <span class="s4">},</span>
                    <span class="s2">CallExpression</span><span class="s4">: {</span>
                        <span class="s2">type</span><span class="s4">: </span><span class="s3">&quot;object&quot;</span><span class="s4">,</span>
                        <span class="s2">properties</span><span class="s4">: {</span>
                            <span class="s2">arguments</span><span class="s4">: </span><span class="s2">ELEMENT_LIST_SCHEMA</span>
                        <span class="s4">},</span>
                        <span class="s2">additionalProperties</span><span class="s4">: </span><span class="s6">false</span>
                    <span class="s4">},</span>
                    <span class="s2">ArrayExpression</span><span class="s4">: </span><span class="s2">ELEMENT_LIST_SCHEMA</span><span class="s4">,</span>
                    <span class="s2">ObjectExpression</span><span class="s4">: </span><span class="s2">ELEMENT_LIST_SCHEMA</span><span class="s4">,</span>
                    <span class="s2">ImportDeclaration</span><span class="s4">: </span><span class="s2">ELEMENT_LIST_SCHEMA</span><span class="s4">,</span>
                    <span class="s2">flatTernaryExpressions</span><span class="s4">: {</span>
                        <span class="s2">type</span><span class="s4">: </span><span class="s3">&quot;boolean&quot;</span><span class="s4">,</span>
                        <span class="s6">default</span><span class="s4">: </span><span class="s6">false</span>
                    <span class="s4">},</span>
                    <span class="s2">offsetTernaryExpressions</span><span class="s4">: {</span>
                        <span class="s2">type</span><span class="s4">: </span><span class="s3">&quot;boolean&quot;</span><span class="s4">,</span>
                        <span class="s6">default</span><span class="s4">: </span><span class="s6">false</span>
                    <span class="s4">},</span>
                    <span class="s2">ignoredNodes</span><span class="s4">: {</span>
                        <span class="s2">type</span><span class="s4">: </span><span class="s3">&quot;array&quot;</span><span class="s4">,</span>
                        <span class="s2">items</span><span class="s4">: {</span>
                            <span class="s2">type</span><span class="s4">: </span><span class="s3">&quot;string&quot;</span><span class="s4">,</span>
                            <span class="s2">not</span><span class="s4">: {</span>
                                <span class="s2">pattern</span><span class="s4">: </span><span class="s3">&quot;:exit$&quot;</span>
                            <span class="s4">}</span>
                        <span class="s4">}</span>
                    <span class="s4">},</span>
                    <span class="s2">ignoreComments</span><span class="s4">: {</span>
                        <span class="s2">type</span><span class="s4">: </span><span class="s3">&quot;boolean&quot;</span><span class="s4">,</span>
                        <span class="s6">default</span><span class="s4">: </span><span class="s6">false</span>
                    <span class="s4">}</span>
                <span class="s4">},</span>
                <span class="s2">additionalProperties</span><span class="s4">: </span><span class="s6">false</span>
            <span class="s4">}</span>
        <span class="s4">],</span>
        <span class="s2">messages</span><span class="s4">: {</span>
            <span class="s2">wrongIndentation</span><span class="s4">: </span><span class="s3">&quot;Expected indentation of {{expected}} but found {{actual}}.&quot;</span>
        <span class="s4">}</span>
    <span class="s4">},</span>

    <span class="s2">create</span><span class="s4">(</span><span class="s2">context</span><span class="s4">) {</span>
        <span class="s6">const </span><span class="s2">DEFAULT_VARIABLE_INDENT </span><span class="s4">= </span><span class="s7">1</span><span class="s4">;</span>
        <span class="s6">const </span><span class="s2">DEFAULT_PARAMETER_INDENT </span><span class="s4">= </span><span class="s7">1</span><span class="s4">;</span>
        <span class="s6">const </span><span class="s2">DEFAULT_FUNCTION_BODY_INDENT </span><span class="s4">= </span><span class="s7">1</span><span class="s4">;</span>

        <span class="s6">let </span><span class="s2">indentType </span><span class="s4">= </span><span class="s3">&quot;space&quot;</span><span class="s4">;</span>
        <span class="s6">let </span><span class="s2">indentSize </span><span class="s4">= </span><span class="s7">4</span><span class="s4">;</span>
        <span class="s6">const </span><span class="s2">options </span><span class="s4">= {</span>
            <span class="s2">SwitchCase</span><span class="s4">: </span><span class="s7">0</span><span class="s4">,</span>
            <span class="s2">VariableDeclarator</span><span class="s4">: {</span>
                <span class="s6">var</span><span class="s4">: </span><span class="s2">DEFAULT_VARIABLE_INDENT</span><span class="s4">,</span>
                <span class="s6">let</span><span class="s4">: </span><span class="s2">DEFAULT_VARIABLE_INDENT</span><span class="s4">,</span>
                <span class="s6">const</span><span class="s4">: </span><span class="s2">DEFAULT_VARIABLE_INDENT</span>
            <span class="s4">},</span>
            <span class="s2">outerIIFEBody</span><span class="s4">: </span><span class="s7">1</span><span class="s4">,</span>
            <span class="s2">FunctionDeclaration</span><span class="s4">: {</span>
                <span class="s2">parameters</span><span class="s4">: </span><span class="s2">DEFAULT_PARAMETER_INDENT</span><span class="s4">,</span>
                <span class="s2">body</span><span class="s4">: </span><span class="s2">DEFAULT_FUNCTION_BODY_INDENT</span>
            <span class="s4">},</span>
            <span class="s2">FunctionExpression</span><span class="s4">: {</span>
                <span class="s2">parameters</span><span class="s4">: </span><span class="s2">DEFAULT_PARAMETER_INDENT</span><span class="s4">,</span>
                <span class="s2">body</span><span class="s4">: </span><span class="s2">DEFAULT_FUNCTION_BODY_INDENT</span>
            <span class="s4">},</span>
            <span class="s2">StaticBlock</span><span class="s4">: {</span>
                <span class="s2">body</span><span class="s4">: </span><span class="s2">DEFAULT_FUNCTION_BODY_INDENT</span>
            <span class="s4">},</span>
            <span class="s2">CallExpression</span><span class="s4">: {</span>
                <span class="s2">arguments</span><span class="s4">: </span><span class="s2">DEFAULT_PARAMETER_INDENT</span>
            <span class="s4">},</span>
            <span class="s2">MemberExpression</span><span class="s4">: </span><span class="s7">1</span><span class="s4">,</span>
            <span class="s2">ArrayExpression</span><span class="s4">: </span><span class="s7">1</span><span class="s4">,</span>
            <span class="s2">ObjectExpression</span><span class="s4">: </span><span class="s7">1</span><span class="s4">,</span>
            <span class="s2">ImportDeclaration</span><span class="s4">: </span><span class="s7">1</span><span class="s4">,</span>
            <span class="s2">flatTernaryExpressions</span><span class="s4">: </span><span class="s6">false</span><span class="s4">,</span>
            <span class="s2">ignoredNodes</span><span class="s4">: [],</span>
            <span class="s2">ignoreComments</span><span class="s4">: </span><span class="s6">false</span>
        <span class="s4">};</span>

        <span class="s6">if </span><span class="s4">(</span><span class="s2">context</span><span class="s4">.</span><span class="s2">options</span><span class="s4">.</span><span class="s2">length</span><span class="s4">) {</span>
            <span class="s6">if </span><span class="s4">(</span><span class="s2">context</span><span class="s4">.</span><span class="s2">options</span><span class="s4">[</span><span class="s7">0</span><span class="s4">] === </span><span class="s3">&quot;tab&quot;</span><span class="s4">) {</span>
                <span class="s2">indentSize </span><span class="s4">= </span><span class="s7">1</span><span class="s4">;</span>
                <span class="s2">indentType </span><span class="s4">= </span><span class="s3">&quot;tab&quot;</span><span class="s4">;</span>
            <span class="s4">} </span><span class="s6">else </span><span class="s4">{</span>
                <span class="s2">indentSize </span><span class="s4">= </span><span class="s2">context</span><span class="s4">.</span><span class="s2">options</span><span class="s4">[</span><span class="s7">0</span><span class="s4">];</span>
                <span class="s2">indentType </span><span class="s4">= </span><span class="s3">&quot;space&quot;</span><span class="s4">;</span>
            <span class="s4">}</span>

            <span class="s6">if </span><span class="s4">(</span><span class="s2">context</span><span class="s4">.</span><span class="s2">options</span><span class="s4">[</span><span class="s7">1</span><span class="s4">]) {</span>
                <span class="s2">Object</span><span class="s4">.</span><span class="s2">assign</span><span class="s4">(</span><span class="s2">options</span><span class="s4">, </span><span class="s2">context</span><span class="s4">.</span><span class="s2">options</span><span class="s4">[</span><span class="s7">1</span><span class="s4">]);</span>

                <span class="s6">if </span><span class="s4">(</span><span class="s6">typeof </span><span class="s2">options</span><span class="s4">.</span><span class="s2">VariableDeclarator </span><span class="s4">=== </span><span class="s3">&quot;number&quot; </span><span class="s4">|| </span><span class="s2">options</span><span class="s4">.</span><span class="s2">VariableDeclarator </span><span class="s4">=== </span><span class="s3">&quot;first&quot;</span><span class="s4">) {</span>
                    <span class="s2">options</span><span class="s4">.</span><span class="s2">VariableDeclarator </span><span class="s4">= {</span>
                        <span class="s6">var</span><span class="s4">: </span><span class="s2">options</span><span class="s4">.</span><span class="s2">VariableDeclarator</span><span class="s4">,</span>
                        <span class="s6">let</span><span class="s4">: </span><span class="s2">options</span><span class="s4">.</span><span class="s2">VariableDeclarator</span><span class="s4">,</span>
                        <span class="s6">const</span><span class="s4">: </span><span class="s2">options</span><span class="s4">.</span><span class="s2">VariableDeclarator</span>
                    <span class="s4">};</span>
                <span class="s4">}</span>
            <span class="s4">}</span>
        <span class="s4">}</span>

        <span class="s6">const </span><span class="s2">sourceCode </span><span class="s4">= </span><span class="s2">context</span><span class="s4">.</span><span class="s2">sourceCode</span><span class="s4">;</span>
        <span class="s6">const </span><span class="s2">tokenInfo </span><span class="s4">= </span><span class="s6">new </span><span class="s2">TokenInfo</span><span class="s4">(</span><span class="s2">sourceCode</span><span class="s4">);</span>
        <span class="s6">const </span><span class="s2">offsets </span><span class="s4">= </span><span class="s6">new </span><span class="s2">OffsetStorage</span><span class="s4">(</span><span class="s2">tokenInfo</span><span class="s4">, </span><span class="s2">indentSize</span><span class="s4">, </span><span class="s2">indentType </span><span class="s4">=== </span><span class="s3">&quot;space&quot; </span><span class="s4">? </span><span class="s3">&quot; &quot; </span><span class="s4">: </span><span class="s3">&quot;</span><span class="s6">\t</span><span class="s3">&quot;</span><span class="s4">, </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">text</span><span class="s4">.</span><span class="s2">length</span><span class="s4">);</span>
        <span class="s6">const </span><span class="s2">parameterParens </span><span class="s4">= </span><span class="s6">new </span><span class="s2">WeakSet</span><span class="s4">();</span>

        <span class="s0">/**</span>
         <span class="s0">* Creates an error message for a line, given the expected/actual indentation.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">{int} expectedAmount The expected amount of indentation characters for this line</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">{int} actualSpaces The actual number of indentation spaces that were found on this line</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">{int} actualTabs The actual number of indentation tabs that were found on this line</span>
         <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{string} An error message for this line</span>
         <span class="s0">*/</span>
        <span class="s6">function </span><span class="s2">createErrorMessageData</span><span class="s4">(</span><span class="s2">expectedAmount</span><span class="s4">, </span><span class="s2">actualSpaces</span><span class="s4">, </span><span class="s2">actualTabs</span><span class="s4">) {</span>
            <span class="s6">const </span><span class="s2">expectedStatement </span><span class="s4">= </span><span class="s3">`</span><span class="s2">$</span><span class="s4">{</span><span class="s2">expectedAmount</span><span class="s4">} </span><span class="s2">$</span><span class="s4">{</span><span class="s2">indentType</span><span class="s4">}</span><span class="s2">$</span><span class="s4">{</span><span class="s2">expectedAmount </span><span class="s4">=== </span><span class="s7">1 </span><span class="s4">? </span><span class="s3">&quot;&quot; </span><span class="s4">: </span><span class="s3">&quot;s&quot;</span><span class="s4">}</span><span class="s3">`</span><span class="s4">; </span><span class="s5">// e.g. &quot;2 tabs&quot;</span>
            <span class="s6">const </span><span class="s2">foundSpacesWord </span><span class="s4">= </span><span class="s3">`space</span><span class="s2">$</span><span class="s4">{</span><span class="s2">actualSpaces </span><span class="s4">=== </span><span class="s7">1 </span><span class="s4">? </span><span class="s3">&quot;&quot; </span><span class="s4">: </span><span class="s3">&quot;s&quot;</span><span class="s4">}</span><span class="s3">`</span><span class="s4">; </span><span class="s5">// e.g. &quot;space&quot;</span>
            <span class="s6">const </span><span class="s2">foundTabsWord </span><span class="s4">= </span><span class="s3">`tab</span><span class="s2">$</span><span class="s4">{</span><span class="s2">actualTabs </span><span class="s4">=== </span><span class="s7">1 </span><span class="s4">? </span><span class="s3">&quot;&quot; </span><span class="s4">: </span><span class="s3">&quot;s&quot;</span><span class="s4">}</span><span class="s3">`</span><span class="s4">; </span><span class="s5">// e.g. &quot;tabs&quot;</span>
            <span class="s6">let </span><span class="s2">foundStatement</span><span class="s4">;</span>

            <span class="s6">if </span><span class="s4">(</span><span class="s2">actualSpaces </span><span class="s4">&gt; </span><span class="s7">0</span><span class="s4">) {</span>

                <span class="s5">/* 
                 * Abbreviate the message if the expected indentation is also spaces. 
                 * e.g. 'Expected 4 spaces but found 2' rather than 'Expected 4 spaces but found 2 spaces' 
                 */</span>
                <span class="s2">foundStatement </span><span class="s4">= </span><span class="s2">indentType </span><span class="s4">=== </span><span class="s3">&quot;space&quot; </span><span class="s4">? </span><span class="s2">actualSpaces </span><span class="s4">: </span><span class="s3">`</span><span class="s2">$</span><span class="s4">{</span><span class="s2">actualSpaces</span><span class="s4">} </span><span class="s2">$</span><span class="s4">{</span><span class="s2">foundSpacesWord</span><span class="s4">}</span><span class="s3">`</span><span class="s4">;</span>
            <span class="s4">} </span><span class="s6">else if </span><span class="s4">(</span><span class="s2">actualTabs </span><span class="s4">&gt; </span><span class="s7">0</span><span class="s4">) {</span>
                <span class="s2">foundStatement </span><span class="s4">= </span><span class="s2">indentType </span><span class="s4">=== </span><span class="s3">&quot;tab&quot; </span><span class="s4">? </span><span class="s2">actualTabs </span><span class="s4">: </span><span class="s3">`</span><span class="s2">$</span><span class="s4">{</span><span class="s2">actualTabs</span><span class="s4">} </span><span class="s2">$</span><span class="s4">{</span><span class="s2">foundTabsWord</span><span class="s4">}</span><span class="s3">`</span><span class="s4">;</span>
            <span class="s4">} </span><span class="s6">else </span><span class="s4">{</span>
                <span class="s2">foundStatement </span><span class="s4">= </span><span class="s3">&quot;0&quot;</span><span class="s4">;</span>
            <span class="s4">}</span>
            <span class="s6">return </span><span class="s4">{</span>
                <span class="s2">expected</span><span class="s4">: </span><span class="s2">expectedStatement</span><span class="s4">,</span>
                <span class="s2">actual</span><span class="s4">: </span><span class="s2">foundStatement</span>
            <span class="s4">};</span>
        <span class="s4">}</span>

        <span class="s0">/**</span>
         <span class="s0">* Reports a given indent violation</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Token} token Token violating the indent rule</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} neededIndent Expected indentation string</span>
         <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
         <span class="s0">*/</span>
        <span class="s6">function </span><span class="s2">report</span><span class="s4">(</span><span class="s2">token</span><span class="s4">, </span><span class="s2">neededIndent</span><span class="s4">) {</span>
            <span class="s6">const </span><span class="s2">actualIndent </span><span class="s4">= </span><span class="s2">Array</span><span class="s4">.</span><span class="s2">from</span><span class="s4">(</span><span class="s2">tokenInfo</span><span class="s4">.</span><span class="s2">getTokenIndent</span><span class="s4">(</span><span class="s2">token</span><span class="s4">));</span>
            <span class="s6">const </span><span class="s2">numSpaces </span><span class="s4">= </span><span class="s2">actualIndent</span><span class="s4">.</span><span class="s2">filter</span><span class="s4">(</span><span class="s2">char </span><span class="s4">=&gt; </span><span class="s2">char </span><span class="s4">=== </span><span class="s3">&quot; &quot;</span><span class="s4">).</span><span class="s2">length</span><span class="s4">;</span>
            <span class="s6">const </span><span class="s2">numTabs </span><span class="s4">= </span><span class="s2">actualIndent</span><span class="s4">.</span><span class="s2">filter</span><span class="s4">(</span><span class="s2">char </span><span class="s4">=&gt; </span><span class="s2">char </span><span class="s4">=== </span><span class="s3">&quot;</span><span class="s6">\t</span><span class="s3">&quot;</span><span class="s4">).</span><span class="s2">length</span><span class="s4">;</span>

            <span class="s2">context</span><span class="s4">.</span><span class="s2">report</span><span class="s4">({</span>
                <span class="s2">node</span><span class="s4">: </span><span class="s2">token</span><span class="s4">,</span>
                <span class="s2">messageId</span><span class="s4">: </span><span class="s3">&quot;wrongIndentation&quot;</span><span class="s4">,</span>
                <span class="s2">data</span><span class="s4">: </span><span class="s2">createErrorMessageData</span><span class="s4">(</span><span class="s2">neededIndent</span><span class="s4">.</span><span class="s2">length</span><span class="s4">, </span><span class="s2">numSpaces</span><span class="s4">, </span><span class="s2">numTabs</span><span class="s4">),</span>
                <span class="s2">loc</span><span class="s4">: {</span>
                    <span class="s2">start</span><span class="s4">: { </span><span class="s2">line</span><span class="s4">: </span><span class="s2">token</span><span class="s4">.</span><span class="s2">loc</span><span class="s4">.</span><span class="s2">start</span><span class="s4">.</span><span class="s2">line</span><span class="s4">, </span><span class="s2">column</span><span class="s4">: </span><span class="s7">0 </span><span class="s4">},</span>
                    <span class="s2">end</span><span class="s4">: { </span><span class="s2">line</span><span class="s4">: </span><span class="s2">token</span><span class="s4">.</span><span class="s2">loc</span><span class="s4">.</span><span class="s2">start</span><span class="s4">.</span><span class="s2">line</span><span class="s4">, </span><span class="s2">column</span><span class="s4">: </span><span class="s2">token</span><span class="s4">.</span><span class="s2">loc</span><span class="s4">.</span><span class="s2">start</span><span class="s4">.</span><span class="s2">column </span><span class="s4">}</span>
                <span class="s4">},</span>
                <span class="s2">fix</span><span class="s4">(</span><span class="s2">fixer</span><span class="s4">) {</span>
                    <span class="s6">const </span><span class="s2">range </span><span class="s4">= [</span><span class="s2">token</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s7">0</span><span class="s4">] - </span><span class="s2">token</span><span class="s4">.</span><span class="s2">loc</span><span class="s4">.</span><span class="s2">start</span><span class="s4">.</span><span class="s2">column</span><span class="s4">, </span><span class="s2">token</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s7">0</span><span class="s4">]];</span>
                    <span class="s6">const </span><span class="s2">newText </span><span class="s4">= </span><span class="s2">neededIndent</span><span class="s4">;</span>

                    <span class="s6">return </span><span class="s2">fixer</span><span class="s4">.</span><span class="s2">replaceTextRange</span><span class="s4">(</span><span class="s2">range</span><span class="s4">, </span><span class="s2">newText</span><span class="s4">);</span>
                <span class="s4">}</span>
            <span class="s4">});</span>
        <span class="s4">}</span>

        <span class="s0">/**</span>
         <span class="s0">* Checks if a token's indentation is correct</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Token} token Token to examine</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} desiredIndent Desired indentation of the string</span>
         <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} `true` if the token's indentation is correct</span>
         <span class="s0">*/</span>
        <span class="s6">function </span><span class="s2">validateTokenIndent</span><span class="s4">(</span><span class="s2">token</span><span class="s4">, </span><span class="s2">desiredIndent</span><span class="s4">) {</span>
            <span class="s6">const </span><span class="s2">indentation </span><span class="s4">= </span><span class="s2">tokenInfo</span><span class="s4">.</span><span class="s2">getTokenIndent</span><span class="s4">(</span><span class="s2">token</span><span class="s4">);</span>

            <span class="s6">return </span><span class="s2">indentation </span><span class="s4">=== </span><span class="s2">desiredIndent </span><span class="s4">||</span>

                <span class="s5">// To avoid conflicts with no-mixed-spaces-and-tabs, don't report mixed spaces and tabs.</span>
                <span class="s2">indentation</span><span class="s4">.</span><span class="s2">includes</span><span class="s4">(</span><span class="s3">&quot; &quot;</span><span class="s4">) &amp;&amp; </span><span class="s2">indentation</span><span class="s4">.</span><span class="s2">includes</span><span class="s4">(</span><span class="s3">&quot;</span><span class="s6">\t</span><span class="s3">&quot;</span><span class="s4">);</span>
        <span class="s4">}</span>

        <span class="s0">/**</span>
         <span class="s0">* Check to see if the node is a file level IIFE</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The function node to check.</span>
         <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} True if the node is the outer IIFE</span>
         <span class="s0">*/</span>
        <span class="s6">function </span><span class="s2">isOuterIIFE</span><span class="s4">(</span><span class="s2">node</span><span class="s4">) {</span>

            <span class="s5">/* 
             * Verify that the node is an IIFE 
             */</span>
            <span class="s6">if </span><span class="s4">(!</span><span class="s2">node</span><span class="s4">.</span><span class="s2">parent </span><span class="s4">|| </span><span class="s2">node</span><span class="s4">.</span><span class="s2">parent</span><span class="s4">.</span><span class="s2">type </span><span class="s4">!== </span><span class="s3">&quot;CallExpression&quot; </span><span class="s4">|| </span><span class="s2">node</span><span class="s4">.</span><span class="s2">parent</span><span class="s4">.</span><span class="s2">callee </span><span class="s4">!== </span><span class="s2">node</span><span class="s4">) {</span>
                <span class="s6">return false</span><span class="s4">;</span>
            <span class="s4">}</span>

            <span class="s5">/* 
             * Navigate legal ancestors to determine whether this IIFE is outer. 
             * A &quot;legal ancestor&quot; is an expression or statement that causes the function to get executed immediately. 
             * For example, `!(function(){})()` is an outer IIFE even though it is preceded by a ! operator. 
             */</span>
            <span class="s6">let </span><span class="s2">statement </span><span class="s4">= </span><span class="s2">node</span><span class="s4">.</span><span class="s2">parent </span><span class="s4">&amp;&amp; </span><span class="s2">node</span><span class="s4">.</span><span class="s2">parent</span><span class="s4">.</span><span class="s2">parent</span><span class="s4">;</span>

            <span class="s6">while </span><span class="s4">(</span>
                <span class="s2">statement</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;UnaryExpression&quot; </span><span class="s4">&amp;&amp; [</span><span class="s3">&quot;!&quot;</span><span class="s4">, </span><span class="s3">&quot;~&quot;</span><span class="s4">, </span><span class="s3">&quot;+&quot;</span><span class="s4">, </span><span class="s3">&quot;-&quot;</span><span class="s4">].</span><span class="s2">includes</span><span class="s4">(</span><span class="s2">statement</span><span class="s4">.</span><span class="s2">operator</span><span class="s4">) ||</span>
                <span class="s2">statement</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;AssignmentExpression&quot; </span><span class="s4">||</span>
                <span class="s2">statement</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;LogicalExpression&quot; </span><span class="s4">||</span>
                <span class="s2">statement</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;SequenceExpression&quot; </span><span class="s4">||</span>
                <span class="s2">statement</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;VariableDeclarator&quot;</span>
            <span class="s4">) {</span>
                <span class="s2">statement </span><span class="s4">= </span><span class="s2">statement</span><span class="s4">.</span><span class="s2">parent</span><span class="s4">;</span>
            <span class="s4">}</span>

            <span class="s6">return </span><span class="s4">(</span><span class="s2">statement</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;ExpressionStatement&quot; </span><span class="s4">|| </span><span class="s2">statement</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;VariableDeclaration&quot;</span><span class="s4">) &amp;&amp; </span><span class="s2">statement</span><span class="s4">.</span><span class="s2">parent</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;Program&quot;</span><span class="s4">;</span>
        <span class="s4">}</span>

        <span class="s0">/**</span>
         <span class="s0">* Counts the number of linebreaks that follow the last non-whitespace character in a string</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} string The string to check</span>
         <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{number} The number of JavaScript linebreaks that follow the last non-whitespace character,</span>
         <span class="s0">* or the total number of linebreaks if the string is all whitespace.</span>
         <span class="s0">*/</span>
        <span class="s6">function </span><span class="s2">countTrailingLinebreaks</span><span class="s4">(</span><span class="s2">string</span><span class="s4">) {</span>
            <span class="s6">const </span><span class="s2">trailingWhitespace </span><span class="s4">= </span><span class="s2">string</span><span class="s4">.</span><span class="s2">match</span><span class="s4">(</span><span class="s8">/\s*$/u</span><span class="s4">)[</span><span class="s7">0</span><span class="s4">];</span>
            <span class="s6">const </span><span class="s2">linebreakMatches </span><span class="s4">= </span><span class="s2">trailingWhitespace</span><span class="s4">.</span><span class="s2">match</span><span class="s4">(</span><span class="s2">astUtils</span><span class="s4">.</span><span class="s2">createGlobalLinebreakMatcher</span><span class="s4">());</span>

            <span class="s6">return </span><span class="s2">linebreakMatches </span><span class="s4">=== </span><span class="s6">null </span><span class="s4">? </span><span class="s7">0 </span><span class="s4">: </span><span class="s2">linebreakMatches</span><span class="s4">.</span><span class="s2">length</span><span class="s4">;</span>
        <span class="s4">}</span>

        <span class="s0">/**</span>
         <span class="s0">* Check indentation for lists of elements (arrays, objects, function params)</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode[]} elements List of elements that should be offset</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Token} startToken The start token of the list that element should be aligned against, e.g. '['</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Token} endToken The end token of the list, e.g. ']'</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">{number|string} offset The amount that the elements should be offset</span>
         <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
         <span class="s0">*/</span>
        <span class="s6">function </span><span class="s2">addElementListIndent</span><span class="s4">(</span><span class="s2">elements</span><span class="s4">, </span><span class="s2">startToken</span><span class="s4">, </span><span class="s2">endToken</span><span class="s4">, </span><span class="s2">offset</span><span class="s4">) {</span>

            <span class="s0">/**</span>
             <span class="s0">* Gets the first token of a given element, including surrounding parentheses.</span>
             <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} element A node in the `elements` list</span>
             <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Token} The first token of this element</span>
             <span class="s0">*/</span>
            <span class="s6">function </span><span class="s2">getFirstToken</span><span class="s4">(</span><span class="s2">element</span><span class="s4">) {</span>
                <span class="s6">let </span><span class="s2">token </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getTokenBefore</span><span class="s4">(</span><span class="s2">element</span><span class="s4">);</span>

                <span class="s6">while </span><span class="s4">(</span><span class="s2">astUtils</span><span class="s4">.</span><span class="s2">isOpeningParenToken</span><span class="s4">(</span><span class="s2">token</span><span class="s4">) &amp;&amp; </span><span class="s2">token </span><span class="s4">!== </span><span class="s2">startToken</span><span class="s4">) {</span>
                    <span class="s2">token </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getTokenBefore</span><span class="s4">(</span><span class="s2">token</span><span class="s4">);</span>
                <span class="s4">}</span>
                <span class="s6">return </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getTokenAfter</span><span class="s4">(</span><span class="s2">token</span><span class="s4">);</span>
            <span class="s4">}</span>

            <span class="s5">// Run through all the tokens in the list, and offset them by one indent level (mainly for comments, other things will end up overridden)</span>
            <span class="s2">offsets</span><span class="s4">.</span><span class="s2">setDesiredOffsets</span><span class="s4">(</span>
                <span class="s4">[</span><span class="s2">startToken</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s7">1</span><span class="s4">], </span><span class="s2">endToken</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s7">0</span><span class="s4">]],</span>
                <span class="s2">startToken</span><span class="s4">,</span>
                <span class="s6">typeof </span><span class="s2">offset </span><span class="s4">=== </span><span class="s3">&quot;number&quot; </span><span class="s4">? </span><span class="s2">offset </span><span class="s4">: </span><span class="s7">1</span>
            <span class="s4">);</span>
            <span class="s2">offsets</span><span class="s4">.</span><span class="s2">setDesiredOffset</span><span class="s4">(</span><span class="s2">endToken</span><span class="s4">, </span><span class="s2">startToken</span><span class="s4">, </span><span class="s7">0</span><span class="s4">);</span>

            <span class="s5">// If the preference is &quot;first&quot; but there is no first element (e.g. sparse arrays w/ empty first slot), fall back to 1 level.</span>
            <span class="s6">if </span><span class="s4">(</span><span class="s2">offset </span><span class="s4">=== </span><span class="s3">&quot;first&quot; </span><span class="s4">&amp;&amp; </span><span class="s2">elements</span><span class="s4">.</span><span class="s2">length </span><span class="s4">&amp;&amp; !</span><span class="s2">elements</span><span class="s4">[</span><span class="s7">0</span><span class="s4">]) {</span>
                <span class="s6">return</span><span class="s4">;</span>
            <span class="s4">}</span>
            <span class="s2">elements</span><span class="s4">.</span><span class="s2">forEach</span><span class="s4">((</span><span class="s2">element</span><span class="s4">, </span><span class="s2">index</span><span class="s4">) =&gt; {</span>
                <span class="s6">if </span><span class="s4">(!</span><span class="s2">element</span><span class="s4">) {</span>

                    <span class="s5">// Skip holes in arrays</span>
                    <span class="s6">return</span><span class="s4">;</span>
                <span class="s4">}</span>
                <span class="s6">if </span><span class="s4">(</span><span class="s2">offset </span><span class="s4">=== </span><span class="s3">&quot;off&quot;</span><span class="s4">) {</span>

                    <span class="s5">// Ignore the first token of every element if the &quot;off&quot; option is used</span>
                    <span class="s2">offsets</span><span class="s4">.</span><span class="s2">ignoreToken</span><span class="s4">(</span><span class="s2">getFirstToken</span><span class="s4">(</span><span class="s2">element</span><span class="s4">));</span>
                <span class="s4">}</span>

                <span class="s5">// Offset the following elements correctly relative to the first element</span>
                <span class="s6">if </span><span class="s4">(</span><span class="s2">index </span><span class="s4">=== </span><span class="s7">0</span><span class="s4">) {</span>
                    <span class="s6">return</span><span class="s4">;</span>
                <span class="s4">}</span>
                <span class="s6">if </span><span class="s4">(</span><span class="s2">offset </span><span class="s4">=== </span><span class="s3">&quot;first&quot; </span><span class="s4">&amp;&amp; </span><span class="s2">tokenInfo</span><span class="s4">.</span><span class="s2">isFirstTokenOfLine</span><span class="s4">(</span><span class="s2">getFirstToken</span><span class="s4">(</span><span class="s2">element</span><span class="s4">))) {</span>
                    <span class="s2">offsets</span><span class="s4">.</span><span class="s2">matchOffsetOf</span><span class="s4">(</span><span class="s2">getFirstToken</span><span class="s4">(</span><span class="s2">elements</span><span class="s4">[</span><span class="s7">0</span><span class="s4">]), </span><span class="s2">getFirstToken</span><span class="s4">(</span><span class="s2">element</span><span class="s4">));</span>
                <span class="s4">} </span><span class="s6">else </span><span class="s4">{</span>
                    <span class="s6">const </span><span class="s2">previousElement </span><span class="s4">= </span><span class="s2">elements</span><span class="s4">[</span><span class="s2">index </span><span class="s4">- </span><span class="s7">1</span><span class="s4">];</span>
                    <span class="s6">const </span><span class="s2">firstTokenOfPreviousElement </span><span class="s4">= </span><span class="s2">previousElement </span><span class="s4">&amp;&amp; </span><span class="s2">getFirstToken</span><span class="s4">(</span><span class="s2">previousElement</span><span class="s4">);</span>
                    <span class="s6">const </span><span class="s2">previousElementLastToken </span><span class="s4">= </span><span class="s2">previousElement </span><span class="s4">&amp;&amp; </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getLastToken</span><span class="s4">(</span><span class="s2">previousElement</span><span class="s4">);</span>

                    <span class="s6">if </span><span class="s4">(</span>
                        <span class="s2">previousElement </span><span class="s4">&amp;&amp;</span>
                        <span class="s2">previousElementLastToken</span><span class="s4">.</span><span class="s2">loc</span><span class="s4">.</span><span class="s2">end</span><span class="s4">.</span><span class="s2">line </span><span class="s4">- </span><span class="s2">countTrailingLinebreaks</span><span class="s4">(</span><span class="s2">previousElementLastToken</span><span class="s4">.</span><span class="s2">value</span><span class="s4">) &gt; </span><span class="s2">startToken</span><span class="s4">.</span><span class="s2">loc</span><span class="s4">.</span><span class="s2">end</span><span class="s4">.</span><span class="s2">line</span>
                    <span class="s4">) {</span>
                        <span class="s2">offsets</span><span class="s4">.</span><span class="s2">setDesiredOffsets</span><span class="s4">(</span>
                            <span class="s4">[</span><span class="s2">previousElement</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s7">1</span><span class="s4">], </span><span class="s2">element</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s7">1</span><span class="s4">]],</span>
                            <span class="s2">firstTokenOfPreviousElement</span><span class="s4">,</span>
                            <span class="s7">0</span>
                        <span class="s4">);</span>
                    <span class="s4">}</span>
                <span class="s4">}</span>
            <span class="s4">});</span>
        <span class="s4">}</span>

        <span class="s0">/**</span>
         <span class="s0">* Check and decide whether to check for indentation for blockless nodes</span>
         <span class="s0">* Scenarios are for or while statements without braces around them</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node node to examine</span>
         <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
         <span class="s0">*/</span>
        <span class="s6">function </span><span class="s2">addBlocklessNodeIndent</span><span class="s4">(</span><span class="s2">node</span><span class="s4">) {</span>
            <span class="s6">if </span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">type </span><span class="s4">!== </span><span class="s3">&quot;BlockStatement&quot;</span><span class="s4">) {</span>
                <span class="s6">const </span><span class="s2">lastParentToken </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getTokenBefore</span><span class="s4">(</span><span class="s2">node</span><span class="s4">, </span><span class="s2">astUtils</span><span class="s4">.</span><span class="s2">isNotOpeningParenToken</span><span class="s4">);</span>

                <span class="s6">let </span><span class="s2">firstBodyToken </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getFirstToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">);</span>
                <span class="s6">let </span><span class="s2">lastBodyToken </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getLastToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">);</span>

                <span class="s6">while </span><span class="s4">(</span>
                    <span class="s2">astUtils</span><span class="s4">.</span><span class="s2">isOpeningParenToken</span><span class="s4">(</span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getTokenBefore</span><span class="s4">(</span><span class="s2">firstBodyToken</span><span class="s4">)) &amp;&amp;</span>
                    <span class="s2">astUtils</span><span class="s4">.</span><span class="s2">isClosingParenToken</span><span class="s4">(</span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getTokenAfter</span><span class="s4">(</span><span class="s2">lastBodyToken</span><span class="s4">))</span>
                <span class="s4">) {</span>
                    <span class="s2">firstBodyToken </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getTokenBefore</span><span class="s4">(</span><span class="s2">firstBodyToken</span><span class="s4">);</span>
                    <span class="s2">lastBodyToken </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getTokenAfter</span><span class="s4">(</span><span class="s2">lastBodyToken</span><span class="s4">);</span>
                <span class="s4">}</span>

                <span class="s2">offsets</span><span class="s4">.</span><span class="s2">setDesiredOffsets</span><span class="s4">([</span><span class="s2">firstBodyToken</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s7">0</span><span class="s4">], </span><span class="s2">lastBodyToken</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s7">1</span><span class="s4">]], </span><span class="s2">lastParentToken</span><span class="s4">, </span><span class="s7">1</span><span class="s4">);</span>
            <span class="s4">}</span>
        <span class="s4">}</span>

        <span class="s0">/**</span>
         <span class="s0">* Checks the indentation for nodes that are like function calls (`CallExpression` and `NewExpression`)</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node A CallExpression or NewExpression node</span>
         <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
         <span class="s0">*/</span>
        <span class="s6">function </span><span class="s2">addFunctionCallIndent</span><span class="s4">(</span><span class="s2">node</span><span class="s4">) {</span>
            <span class="s6">let </span><span class="s2">openingParen</span><span class="s4">;</span>

            <span class="s6">if </span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">arguments</span><span class="s4">.</span><span class="s2">length</span><span class="s4">) {</span>
                <span class="s2">openingParen </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getFirstTokenBetween</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">callee</span><span class="s4">, </span><span class="s2">node</span><span class="s4">.</span><span class="s2">arguments</span><span class="s4">[</span><span class="s7">0</span><span class="s4">], </span><span class="s2">astUtils</span><span class="s4">.</span><span class="s2">isOpeningParenToken</span><span class="s4">);</span>
            <span class="s4">} </span><span class="s6">else </span><span class="s4">{</span>
                <span class="s2">openingParen </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getLastToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">, </span><span class="s7">1</span><span class="s4">);</span>
            <span class="s4">}</span>
            <span class="s6">const </span><span class="s2">closingParen </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getLastToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">);</span>

            <span class="s2">parameterParens</span><span class="s4">.</span><span class="s2">add</span><span class="s4">(</span><span class="s2">openingParen</span><span class="s4">);</span>
            <span class="s2">parameterParens</span><span class="s4">.</span><span class="s2">add</span><span class="s4">(</span><span class="s2">closingParen</span><span class="s4">);</span>

            <span class="s5">/* 
             * If `?.` token exists, set desired offset for that. 
             * This logic is copied from `MemberExpression`'s. 
             */</span>
            <span class="s6">if </span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">optional</span><span class="s4">) {</span>
                <span class="s6">const </span><span class="s2">dotToken </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getTokenAfter</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">callee</span><span class="s4">, </span><span class="s2">astUtils</span><span class="s4">.</span><span class="s2">isQuestionDotToken</span><span class="s4">);</span>
                <span class="s6">const </span><span class="s2">calleeParenCount </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getTokensBetween</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">callee</span><span class="s4">, </span><span class="s2">dotToken</span><span class="s4">, { </span><span class="s2">filter</span><span class="s4">: </span><span class="s2">astUtils</span><span class="s4">.</span><span class="s2">isClosingParenToken </span><span class="s4">}).</span><span class="s2">length</span><span class="s4">;</span>
                <span class="s6">const </span><span class="s2">firstTokenOfCallee </span><span class="s4">= </span><span class="s2">calleeParenCount</span>
                    <span class="s4">? </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getTokenBefore</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">callee</span><span class="s4">, { </span><span class="s2">skip</span><span class="s4">: </span><span class="s2">calleeParenCount </span><span class="s4">- </span><span class="s7">1 </span><span class="s4">})</span>
                    <span class="s4">: </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getFirstToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">callee</span><span class="s4">);</span>
                <span class="s6">const </span><span class="s2">lastTokenOfCallee </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getTokenBefore</span><span class="s4">(</span><span class="s2">dotToken</span><span class="s4">);</span>
                <span class="s6">const </span><span class="s2">offsetBase </span><span class="s4">= </span><span class="s2">lastTokenOfCallee</span><span class="s4">.</span><span class="s2">loc</span><span class="s4">.</span><span class="s2">end</span><span class="s4">.</span><span class="s2">line </span><span class="s4">=== </span><span class="s2">openingParen</span><span class="s4">.</span><span class="s2">loc</span><span class="s4">.</span><span class="s2">start</span><span class="s4">.</span><span class="s2">line</span>
                    <span class="s4">? </span><span class="s2">lastTokenOfCallee</span>
                    <span class="s4">: </span><span class="s2">firstTokenOfCallee</span><span class="s4">;</span>

                <span class="s2">offsets</span><span class="s4">.</span><span class="s2">setDesiredOffset</span><span class="s4">(</span><span class="s2">dotToken</span><span class="s4">, </span><span class="s2">offsetBase</span><span class="s4">, </span><span class="s7">1</span><span class="s4">);</span>
            <span class="s4">}</span>

            <span class="s6">const </span><span class="s2">offsetAfterToken </span><span class="s4">= </span><span class="s2">node</span><span class="s4">.</span><span class="s2">callee</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;TaggedTemplateExpression&quot; </span><span class="s4">? </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getFirstToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">callee</span><span class="s4">.</span><span class="s2">quasi</span><span class="s4">) : </span><span class="s2">openingParen</span><span class="s4">;</span>
            <span class="s6">const </span><span class="s2">offsetToken </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getTokenBefore</span><span class="s4">(</span><span class="s2">offsetAfterToken</span><span class="s4">);</span>

            <span class="s2">offsets</span><span class="s4">.</span><span class="s2">setDesiredOffset</span><span class="s4">(</span><span class="s2">openingParen</span><span class="s4">, </span><span class="s2">offsetToken</span><span class="s4">, </span><span class="s7">0</span><span class="s4">);</span>

            <span class="s2">addElementListIndent</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">arguments</span><span class="s4">, </span><span class="s2">openingParen</span><span class="s4">, </span><span class="s2">closingParen</span><span class="s4">, </span><span class="s2">options</span><span class="s4">.</span><span class="s2">CallExpression</span><span class="s4">.</span><span class="s2">arguments</span><span class="s4">);</span>
        <span class="s4">}</span>

        <span class="s0">/**</span>
         <span class="s0">* Checks the indentation of parenthesized values, given a list of tokens in a program</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Token[]} tokens A list of tokens</span>
         <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
         <span class="s0">*/</span>
        <span class="s6">function </span><span class="s2">addParensIndent</span><span class="s4">(</span><span class="s2">tokens</span><span class="s4">) {</span>
            <span class="s6">const </span><span class="s2">parenStack </span><span class="s4">= [];</span>
            <span class="s6">const </span><span class="s2">parenPairs </span><span class="s4">= [];</span>

            <span class="s6">for </span><span class="s4">(</span><span class="s6">let </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s2">tokens</span><span class="s4">.</span><span class="s2">length</span><span class="s4">; </span><span class="s2">i</span><span class="s4">++) {</span>
                <span class="s6">const </span><span class="s2">nextToken </span><span class="s4">= </span><span class="s2">tokens</span><span class="s4">[</span><span class="s2">i</span><span class="s4">];</span>

                <span class="s6">if </span><span class="s4">(</span><span class="s2">astUtils</span><span class="s4">.</span><span class="s2">isOpeningParenToken</span><span class="s4">(</span><span class="s2">nextToken</span><span class="s4">)) {</span>
                    <span class="s2">parenStack</span><span class="s4">.</span><span class="s2">push</span><span class="s4">(</span><span class="s2">nextToken</span><span class="s4">);</span>
                <span class="s4">} </span><span class="s6">else if </span><span class="s4">(</span><span class="s2">astUtils</span><span class="s4">.</span><span class="s2">isClosingParenToken</span><span class="s4">(</span><span class="s2">nextToken</span><span class="s4">)) {</span>
                    <span class="s2">parenPairs</span><span class="s4">.</span><span class="s2">push</span><span class="s4">({ </span><span class="s2">left</span><span class="s4">: </span><span class="s2">parenStack</span><span class="s4">.</span><span class="s2">pop</span><span class="s4">(), </span><span class="s2">right</span><span class="s4">: </span><span class="s2">nextToken </span><span class="s4">});</span>
                <span class="s4">}</span>
            <span class="s4">}</span>

            <span class="s6">for </span><span class="s4">(</span><span class="s6">let </span><span class="s2">i </span><span class="s4">= </span><span class="s2">parenPairs</span><span class="s4">.</span><span class="s2">length </span><span class="s4">- </span><span class="s7">1</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&gt;= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">i</span><span class="s4">--) {</span>
                <span class="s6">const </span><span class="s2">leftParen </span><span class="s4">= </span><span class="s2">parenPairs</span><span class="s4">[</span><span class="s2">i</span><span class="s4">].</span><span class="s2">left</span><span class="s4">;</span>
                <span class="s6">const </span><span class="s2">rightParen </span><span class="s4">= </span><span class="s2">parenPairs</span><span class="s4">[</span><span class="s2">i</span><span class="s4">].</span><span class="s2">right</span><span class="s4">;</span>

                <span class="s5">// We only want to handle parens around expressions, so exclude parentheses that are in function parameters and function call arguments.</span>
                <span class="s6">if </span><span class="s4">(!</span><span class="s2">parameterParens</span><span class="s4">.</span><span class="s2">has</span><span class="s4">(</span><span class="s2">leftParen</span><span class="s4">) &amp;&amp; !</span><span class="s2">parameterParens</span><span class="s4">.</span><span class="s2">has</span><span class="s4">(</span><span class="s2">rightParen</span><span class="s4">)) {</span>
                    <span class="s6">const </span><span class="s2">parenthesizedTokens </span><span class="s4">= </span><span class="s6">new </span><span class="s2">Set</span><span class="s4">(</span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getTokensBetween</span><span class="s4">(</span><span class="s2">leftParen</span><span class="s4">, </span><span class="s2">rightParen</span><span class="s4">));</span>

                    <span class="s2">parenthesizedTokens</span><span class="s4">.</span><span class="s2">forEach</span><span class="s4">(</span><span class="s2">token </span><span class="s4">=&gt; {</span>
                        <span class="s6">if </span><span class="s4">(!</span><span class="s2">parenthesizedTokens</span><span class="s4">.</span><span class="s2">has</span><span class="s4">(</span><span class="s2">offsets</span><span class="s4">.</span><span class="s2">getFirstDependency</span><span class="s4">(</span><span class="s2">token</span><span class="s4">))) {</span>
                            <span class="s2">offsets</span><span class="s4">.</span><span class="s2">setDesiredOffset</span><span class="s4">(</span><span class="s2">token</span><span class="s4">, </span><span class="s2">leftParen</span><span class="s4">, </span><span class="s7">1</span><span class="s4">);</span>
                        <span class="s4">}</span>
                    <span class="s4">});</span>
                <span class="s4">}</span>

                <span class="s2">offsets</span><span class="s4">.</span><span class="s2">setDesiredOffset</span><span class="s4">(</span><span class="s2">rightParen</span><span class="s4">, </span><span class="s2">leftParen</span><span class="s4">, </span><span class="s7">0</span><span class="s4">);</span>
            <span class="s4">}</span>
        <span class="s4">}</span>

        <span class="s0">/**</span>
         <span class="s0">* Ignore all tokens within an unknown node whose offset do not depend</span>
         <span class="s0">* on another token's offset within the unknown node</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node Unknown Node</span>
         <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
         <span class="s0">*/</span>
        <span class="s6">function </span><span class="s2">ignoreNode</span><span class="s4">(</span><span class="s2">node</span><span class="s4">) {</span>
            <span class="s6">const </span><span class="s2">unknownNodeTokens </span><span class="s4">= </span><span class="s6">new </span><span class="s2">Set</span><span class="s4">(</span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getTokens</span><span class="s4">(</span><span class="s2">node</span><span class="s4">, { </span><span class="s2">includeComments</span><span class="s4">: </span><span class="s6">true </span><span class="s4">}));</span>

            <span class="s2">unknownNodeTokens</span><span class="s4">.</span><span class="s2">forEach</span><span class="s4">(</span><span class="s2">token </span><span class="s4">=&gt; {</span>
                <span class="s6">if </span><span class="s4">(!</span><span class="s2">unknownNodeTokens</span><span class="s4">.</span><span class="s2">has</span><span class="s4">(</span><span class="s2">offsets</span><span class="s4">.</span><span class="s2">getFirstDependency</span><span class="s4">(</span><span class="s2">token</span><span class="s4">))) {</span>
                    <span class="s6">const </span><span class="s2">firstTokenOfLine </span><span class="s4">= </span><span class="s2">tokenInfo</span><span class="s4">.</span><span class="s2">getFirstTokenOfLine</span><span class="s4">(</span><span class="s2">token</span><span class="s4">);</span>

                    <span class="s6">if </span><span class="s4">(</span><span class="s2">token </span><span class="s4">=== </span><span class="s2">firstTokenOfLine</span><span class="s4">) {</span>
                        <span class="s2">offsets</span><span class="s4">.</span><span class="s2">ignoreToken</span><span class="s4">(</span><span class="s2">token</span><span class="s4">);</span>
                    <span class="s4">} </span><span class="s6">else </span><span class="s4">{</span>
                        <span class="s2">offsets</span><span class="s4">.</span><span class="s2">setDesiredOffset</span><span class="s4">(</span><span class="s2">token</span><span class="s4">, </span><span class="s2">firstTokenOfLine</span><span class="s4">, </span><span class="s7">0</span><span class="s4">);</span>
                    <span class="s4">}</span>
                <span class="s4">}</span>
            <span class="s4">});</span>
        <span class="s4">}</span>

        <span class="s0">/**</span>
         <span class="s0">* Check whether the given token is on the first line of a statement.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Token} token The token to check.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} leafNode The expression node that the token belongs directly.</span>
         <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} `true` if the token is on the first line of a statement.</span>
         <span class="s0">*/</span>
        <span class="s6">function </span><span class="s2">isOnFirstLineOfStatement</span><span class="s4">(</span><span class="s2">token</span><span class="s4">, </span><span class="s2">leafNode</span><span class="s4">) {</span>
            <span class="s6">let </span><span class="s2">node </span><span class="s4">= </span><span class="s2">leafNode</span><span class="s4">;</span>

            <span class="s6">while </span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">parent </span><span class="s4">&amp;&amp; !</span><span class="s2">node</span><span class="s4">.</span><span class="s2">parent</span><span class="s4">.</span><span class="s2">type</span><span class="s4">.</span><span class="s2">endsWith</span><span class="s4">(</span><span class="s3">&quot;Statement&quot;</span><span class="s4">) &amp;&amp; !</span><span class="s2">node</span><span class="s4">.</span><span class="s2">parent</span><span class="s4">.</span><span class="s2">type</span><span class="s4">.</span><span class="s2">endsWith</span><span class="s4">(</span><span class="s3">&quot;Declaration&quot;</span><span class="s4">)) {</span>
                <span class="s2">node </span><span class="s4">= </span><span class="s2">node</span><span class="s4">.</span><span class="s2">parent</span><span class="s4">;</span>
            <span class="s4">}</span>
            <span class="s2">node </span><span class="s4">= </span><span class="s2">node</span><span class="s4">.</span><span class="s2">parent</span><span class="s4">;</span>

            <span class="s6">return </span><span class="s4">!</span><span class="s2">node </span><span class="s4">|| </span><span class="s2">node</span><span class="s4">.</span><span class="s2">loc</span><span class="s4">.</span><span class="s2">start</span><span class="s4">.</span><span class="s2">line </span><span class="s4">=== </span><span class="s2">token</span><span class="s4">.</span><span class="s2">loc</span><span class="s4">.</span><span class="s2">start</span><span class="s4">.</span><span class="s2">line</span><span class="s4">;</span>
        <span class="s4">}</span>

        <span class="s0">/**</span>
         <span class="s0">* Check whether there are any blank (whitespace-only) lines between</span>
         <span class="s0">* two tokens on separate lines.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Token} firstToken The first token.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Token} secondToken The second token.</span>
         <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} `true` if the tokens are on separate lines and</span>
         <span class="s0">*   there exists a blank line between them, `false` otherwise.</span>
         <span class="s0">*/</span>
        <span class="s6">function </span><span class="s2">hasBlankLinesBetween</span><span class="s4">(</span><span class="s2">firstToken</span><span class="s4">, </span><span class="s2">secondToken</span><span class="s4">) {</span>
            <span class="s6">const </span><span class="s2">firstTokenLine </span><span class="s4">= </span><span class="s2">firstToken</span><span class="s4">.</span><span class="s2">loc</span><span class="s4">.</span><span class="s2">end</span><span class="s4">.</span><span class="s2">line</span><span class="s4">;</span>
            <span class="s6">const </span><span class="s2">secondTokenLine </span><span class="s4">= </span><span class="s2">secondToken</span><span class="s4">.</span><span class="s2">loc</span><span class="s4">.</span><span class="s2">start</span><span class="s4">.</span><span class="s2">line</span><span class="s4">;</span>

            <span class="s6">if </span><span class="s4">(</span><span class="s2">firstTokenLine </span><span class="s4">=== </span><span class="s2">secondTokenLine </span><span class="s4">|| </span><span class="s2">firstTokenLine </span><span class="s4">=== </span><span class="s2">secondTokenLine </span><span class="s4">- </span><span class="s7">1</span><span class="s4">) {</span>
                <span class="s6">return false</span><span class="s4">;</span>
            <span class="s4">}</span>

            <span class="s6">for </span><span class="s4">(</span><span class="s6">let </span><span class="s2">line </span><span class="s4">= </span><span class="s2">firstTokenLine </span><span class="s4">+ </span><span class="s7">1</span><span class="s4">; </span><span class="s2">line </span><span class="s4">&lt; </span><span class="s2">secondTokenLine</span><span class="s4">; ++</span><span class="s2">line</span><span class="s4">) {</span>
                <span class="s6">if </span><span class="s4">(!</span><span class="s2">tokenInfo</span><span class="s4">.</span><span class="s2">firstTokensByLineNumber</span><span class="s4">.</span><span class="s2">has</span><span class="s4">(</span><span class="s2">line</span><span class="s4">)) {</span>
                    <span class="s6">return true</span><span class="s4">;</span>
                <span class="s4">}</span>
            <span class="s4">}</span>

            <span class="s6">return false</span><span class="s4">;</span>
        <span class="s4">}</span>

        <span class="s6">const </span><span class="s2">ignoredNodeFirstTokens </span><span class="s4">= </span><span class="s6">new </span><span class="s2">Set</span><span class="s4">();</span>

        <span class="s6">const </span><span class="s2">baseOffsetListeners </span><span class="s4">= {</span>
            <span class="s3">&quot;ArrayExpression, ArrayPattern&quot;</span><span class="s4">(</span><span class="s2">node</span><span class="s4">) {</span>
                <span class="s6">const </span><span class="s2">openingBracket </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getFirstToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">);</span>
                <span class="s6">const </span><span class="s2">closingBracket </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getTokenAfter</span><span class="s4">([</span><span class="s2">...node</span><span class="s4">.</span><span class="s2">elements</span><span class="s4">].</span><span class="s2">reverse</span><span class="s4">().</span><span class="s2">find</span><span class="s4">(</span><span class="s2">_ </span><span class="s4">=&gt; </span><span class="s2">_</span><span class="s4">) || </span><span class="s2">openingBracket</span><span class="s4">, </span><span class="s2">astUtils</span><span class="s4">.</span><span class="s2">isClosingBracketToken</span><span class="s4">);</span>

                <span class="s2">addElementListIndent</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">elements</span><span class="s4">, </span><span class="s2">openingBracket</span><span class="s4">, </span><span class="s2">closingBracket</span><span class="s4">, </span><span class="s2">options</span><span class="s4">.</span><span class="s2">ArrayExpression</span><span class="s4">);</span>
            <span class="s4">},</span>

            <span class="s3">&quot;ObjectExpression, ObjectPattern&quot;</span><span class="s4">(</span><span class="s2">node</span><span class="s4">) {</span>
                <span class="s6">const </span><span class="s2">openingCurly </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getFirstToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">);</span>
                <span class="s6">const </span><span class="s2">closingCurly </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getTokenAfter</span><span class="s4">(</span>
                    <span class="s2">node</span><span class="s4">.</span><span class="s2">properties</span><span class="s4">.</span><span class="s2">length </span><span class="s4">? </span><span class="s2">node</span><span class="s4">.</span><span class="s2">properties</span><span class="s4">[</span><span class="s2">node</span><span class="s4">.</span><span class="s2">properties</span><span class="s4">.</span><span class="s2">length </span><span class="s4">- </span><span class="s7">1</span><span class="s4">] : </span><span class="s2">openingCurly</span><span class="s4">,</span>
                    <span class="s2">astUtils</span><span class="s4">.</span><span class="s2">isClosingBraceToken</span>
                <span class="s4">);</span>

                <span class="s2">addElementListIndent</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">properties</span><span class="s4">, </span><span class="s2">openingCurly</span><span class="s4">, </span><span class="s2">closingCurly</span><span class="s4">, </span><span class="s2">options</span><span class="s4">.</span><span class="s2">ObjectExpression</span><span class="s4">);</span>
            <span class="s4">},</span>

            <span class="s2">ArrowFunctionExpression</span><span class="s4">(</span><span class="s2">node</span><span class="s4">) {</span>
                <span class="s6">const </span><span class="s2">maybeOpeningParen </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getFirstToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">, { </span><span class="s2">skip</span><span class="s4">: </span><span class="s2">node</span><span class="s4">.</span><span class="s2">async </span><span class="s4">? </span><span class="s7">1 </span><span class="s4">: </span><span class="s7">0 </span><span class="s4">});</span>

                <span class="s6">if </span><span class="s4">(</span><span class="s2">astUtils</span><span class="s4">.</span><span class="s2">isOpeningParenToken</span><span class="s4">(</span><span class="s2">maybeOpeningParen</span><span class="s4">)) {</span>
                    <span class="s6">const </span><span class="s2">openingParen </span><span class="s4">= </span><span class="s2">maybeOpeningParen</span><span class="s4">;</span>
                    <span class="s6">const </span><span class="s2">closingParen </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getTokenBefore</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">body</span><span class="s4">, </span><span class="s2">astUtils</span><span class="s4">.</span><span class="s2">isClosingParenToken</span><span class="s4">);</span>

                    <span class="s2">parameterParens</span><span class="s4">.</span><span class="s2">add</span><span class="s4">(</span><span class="s2">openingParen</span><span class="s4">);</span>
                    <span class="s2">parameterParens</span><span class="s4">.</span><span class="s2">add</span><span class="s4">(</span><span class="s2">closingParen</span><span class="s4">);</span>
                    <span class="s2">addElementListIndent</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">params</span><span class="s4">, </span><span class="s2">openingParen</span><span class="s4">, </span><span class="s2">closingParen</span><span class="s4">, </span><span class="s2">options</span><span class="s4">.</span><span class="s2">FunctionExpression</span><span class="s4">.</span><span class="s2">parameters</span><span class="s4">);</span>
                <span class="s4">}</span>

                <span class="s2">addBlocklessNodeIndent</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">body</span><span class="s4">);</span>
            <span class="s4">},</span>

            <span class="s2">AssignmentExpression</span><span class="s4">(</span><span class="s2">node</span><span class="s4">) {</span>
                <span class="s6">const </span><span class="s2">operator </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getFirstTokenBetween</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">left</span><span class="s4">, </span><span class="s2">node</span><span class="s4">.</span><span class="s2">right</span><span class="s4">, </span><span class="s2">token </span><span class="s4">=&gt; </span><span class="s2">token</span><span class="s4">.</span><span class="s2">value </span><span class="s4">=== </span><span class="s2">node</span><span class="s4">.</span><span class="s2">operator</span><span class="s4">);</span>

                <span class="s2">offsets</span><span class="s4">.</span><span class="s2">setDesiredOffsets</span><span class="s4">([</span><span class="s2">operator</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s7">0</span><span class="s4">], </span><span class="s2">node</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s7">1</span><span class="s4">]], </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getLastToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">left</span><span class="s4">), </span><span class="s7">1</span><span class="s4">);</span>
                <span class="s2">offsets</span><span class="s4">.</span><span class="s2">ignoreToken</span><span class="s4">(</span><span class="s2">operator</span><span class="s4">);</span>
                <span class="s2">offsets</span><span class="s4">.</span><span class="s2">ignoreToken</span><span class="s4">(</span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getTokenAfter</span><span class="s4">(</span><span class="s2">operator</span><span class="s4">));</span>
            <span class="s4">},</span>

            <span class="s3">&quot;BinaryExpression, LogicalExpression&quot;</span><span class="s4">(</span><span class="s2">node</span><span class="s4">) {</span>
                <span class="s6">const </span><span class="s2">operator </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getFirstTokenBetween</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">left</span><span class="s4">, </span><span class="s2">node</span><span class="s4">.</span><span class="s2">right</span><span class="s4">, </span><span class="s2">token </span><span class="s4">=&gt; </span><span class="s2">token</span><span class="s4">.</span><span class="s2">value </span><span class="s4">=== </span><span class="s2">node</span><span class="s4">.</span><span class="s2">operator</span><span class="s4">);</span>

                <span class="s5">/* 
                 * For backwards compatibility, don't check BinaryExpression indents, e.g. 
                 * var foo = bar &amp;&amp; 
                 *                   baz; 
                 */</span>

                <span class="s6">const </span><span class="s2">tokenAfterOperator </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getTokenAfter</span><span class="s4">(</span><span class="s2">operator</span><span class="s4">);</span>

                <span class="s2">offsets</span><span class="s4">.</span><span class="s2">ignoreToken</span><span class="s4">(</span><span class="s2">operator</span><span class="s4">);</span>
                <span class="s2">offsets</span><span class="s4">.</span><span class="s2">ignoreToken</span><span class="s4">(</span><span class="s2">tokenAfterOperator</span><span class="s4">);</span>
                <span class="s2">offsets</span><span class="s4">.</span><span class="s2">setDesiredOffset</span><span class="s4">(</span><span class="s2">tokenAfterOperator</span><span class="s4">, </span><span class="s2">operator</span><span class="s4">, </span><span class="s7">0</span><span class="s4">);</span>
            <span class="s4">},</span>

            <span class="s3">&quot;BlockStatement, ClassBody&quot;</span><span class="s4">(</span><span class="s2">node</span><span class="s4">) {</span>
                <span class="s6">let </span><span class="s2">blockIndentLevel</span><span class="s4">;</span>

                <span class="s6">if </span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">parent </span><span class="s4">&amp;&amp; </span><span class="s2">isOuterIIFE</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">parent</span><span class="s4">)) {</span>
                    <span class="s2">blockIndentLevel </span><span class="s4">= </span><span class="s2">options</span><span class="s4">.</span><span class="s2">outerIIFEBody</span><span class="s4">;</span>
                <span class="s4">} </span><span class="s6">else if </span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">parent </span><span class="s4">&amp;&amp; (</span><span class="s2">node</span><span class="s4">.</span><span class="s2">parent</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;FunctionExpression&quot; </span><span class="s4">|| </span><span class="s2">node</span><span class="s4">.</span><span class="s2">parent</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;ArrowFunctionExpression&quot;</span><span class="s4">)) {</span>
                    <span class="s2">blockIndentLevel </span><span class="s4">= </span><span class="s2">options</span><span class="s4">.</span><span class="s2">FunctionExpression</span><span class="s4">.</span><span class="s2">body</span><span class="s4">;</span>
                <span class="s4">} </span><span class="s6">else if </span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">parent </span><span class="s4">&amp;&amp; </span><span class="s2">node</span><span class="s4">.</span><span class="s2">parent</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;FunctionDeclaration&quot;</span><span class="s4">) {</span>
                    <span class="s2">blockIndentLevel </span><span class="s4">= </span><span class="s2">options</span><span class="s4">.</span><span class="s2">FunctionDeclaration</span><span class="s4">.</span><span class="s2">body</span><span class="s4">;</span>
                <span class="s4">} </span><span class="s6">else </span><span class="s4">{</span>
                    <span class="s2">blockIndentLevel </span><span class="s4">= </span><span class="s7">1</span><span class="s4">;</span>
                <span class="s4">}</span>

                <span class="s5">/* 
                 * For blocks that aren't lone statements, ensure that the opening curly brace 
                 * is aligned with the parent. 
                 */</span>
                <span class="s6">if </span><span class="s4">(!</span><span class="s2">astUtils</span><span class="s4">.</span><span class="s2">STATEMENT_LIST_PARENTS</span><span class="s4">.</span><span class="s2">has</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">parent</span><span class="s4">.</span><span class="s2">type</span><span class="s4">)) {</span>
                    <span class="s2">offsets</span><span class="s4">.</span><span class="s2">setDesiredOffset</span><span class="s4">(</span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getFirstToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">), </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getFirstToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">parent</span><span class="s4">), </span><span class="s7">0</span><span class="s4">);</span>
                <span class="s4">}</span>

                <span class="s2">addElementListIndent</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">body</span><span class="s4">, </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getFirstToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">), </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getLastToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">), </span><span class="s2">blockIndentLevel</span><span class="s4">);</span>
            <span class="s4">},</span>

            <span class="s2">CallExpression</span><span class="s4">: </span><span class="s2">addFunctionCallIndent</span><span class="s4">,</span>

            <span class="s3">&quot;ClassDeclaration[superClass], ClassExpression[superClass]&quot;</span><span class="s4">(</span><span class="s2">node</span><span class="s4">) {</span>
                <span class="s6">const </span><span class="s2">classToken </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getFirstToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">);</span>
                <span class="s6">const </span><span class="s2">extendsToken </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getTokenBefore</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">superClass</span><span class="s4">, </span><span class="s2">astUtils</span><span class="s4">.</span><span class="s2">isNotOpeningParenToken</span><span class="s4">);</span>

                <span class="s2">offsets</span><span class="s4">.</span><span class="s2">setDesiredOffsets</span><span class="s4">([</span><span class="s2">extendsToken</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s7">0</span><span class="s4">], </span><span class="s2">node</span><span class="s4">.</span><span class="s2">body</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s7">0</span><span class="s4">]], </span><span class="s2">classToken</span><span class="s4">, </span><span class="s7">1</span><span class="s4">);</span>
            <span class="s4">},</span>

            <span class="s2">ConditionalExpression</span><span class="s4">(</span><span class="s2">node</span><span class="s4">) {</span>
                <span class="s6">const </span><span class="s2">firstToken </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getFirstToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">);</span>

                <span class="s5">// `flatTernaryExpressions` option is for the following style:</span>
                <span class="s5">// var a =</span>
                <span class="s5">//     foo &gt; 0 ? bar :</span>
                <span class="s5">//     foo &lt; 0 ? baz :</span>
                <span class="s5">//     /*else*/ qiz ;</span>
                <span class="s6">if </span><span class="s4">(!</span><span class="s2">options</span><span class="s4">.</span><span class="s2">flatTernaryExpressions </span><span class="s4">||</span>
                    <span class="s4">!</span><span class="s2">astUtils</span><span class="s4">.</span><span class="s2">isTokenOnSameLine</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">test</span><span class="s4">, </span><span class="s2">node</span><span class="s4">.</span><span class="s2">consequent</span><span class="s4">) ||</span>
                    <span class="s2">isOnFirstLineOfStatement</span><span class="s4">(</span><span class="s2">firstToken</span><span class="s4">, </span><span class="s2">node</span><span class="s4">)</span>
                <span class="s4">) {</span>
                    <span class="s6">const </span><span class="s2">questionMarkToken </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getFirstTokenBetween</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">test</span><span class="s4">, </span><span class="s2">node</span><span class="s4">.</span><span class="s2">consequent</span><span class="s4">, </span><span class="s2">token </span><span class="s4">=&gt; </span><span class="s2">token</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;Punctuator&quot; </span><span class="s4">&amp;&amp; </span><span class="s2">token</span><span class="s4">.</span><span class="s2">value </span><span class="s4">=== </span><span class="s3">&quot;?&quot;</span><span class="s4">);</span>
                    <span class="s6">const </span><span class="s2">colonToken </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getFirstTokenBetween</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">consequent</span><span class="s4">, </span><span class="s2">node</span><span class="s4">.</span><span class="s2">alternate</span><span class="s4">, </span><span class="s2">token </span><span class="s4">=&gt; </span><span class="s2">token</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;Punctuator&quot; </span><span class="s4">&amp;&amp; </span><span class="s2">token</span><span class="s4">.</span><span class="s2">value </span><span class="s4">=== </span><span class="s3">&quot;:&quot;</span><span class="s4">);</span>

                    <span class="s6">const </span><span class="s2">firstConsequentToken </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getTokenAfter</span><span class="s4">(</span><span class="s2">questionMarkToken</span><span class="s4">);</span>
                    <span class="s6">const </span><span class="s2">lastConsequentToken </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getTokenBefore</span><span class="s4">(</span><span class="s2">colonToken</span><span class="s4">);</span>
                    <span class="s6">const </span><span class="s2">firstAlternateToken </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getTokenAfter</span><span class="s4">(</span><span class="s2">colonToken</span><span class="s4">);</span>

                    <span class="s2">offsets</span><span class="s4">.</span><span class="s2">setDesiredOffset</span><span class="s4">(</span><span class="s2">questionMarkToken</span><span class="s4">, </span><span class="s2">firstToken</span><span class="s4">, </span><span class="s7">1</span><span class="s4">);</span>
                    <span class="s2">offsets</span><span class="s4">.</span><span class="s2">setDesiredOffset</span><span class="s4">(</span><span class="s2">colonToken</span><span class="s4">, </span><span class="s2">firstToken</span><span class="s4">, </span><span class="s7">1</span><span class="s4">);</span>

                    <span class="s2">offsets</span><span class="s4">.</span><span class="s2">setDesiredOffset</span><span class="s4">(</span><span class="s2">firstConsequentToken</span><span class="s4">, </span><span class="s2">firstToken</span><span class="s4">, </span><span class="s2">firstConsequentToken</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;Punctuator&quot; </span><span class="s4">&amp;&amp;</span>
                        <span class="s2">options</span><span class="s4">.</span><span class="s2">offsetTernaryExpressions </span><span class="s4">? </span><span class="s7">2 </span><span class="s4">: </span><span class="s7">1</span><span class="s4">);</span>

                    <span class="s5">/* 
                     * The alternate and the consequent should usually have the same indentation. 
                     * If they share part of a line, align the alternate against the first token of the consequent. 
                     * This allows the alternate to be indented correctly in cases like this: 
                     * foo ? ( 
                     *   bar 
                     * ) : ( // this '(' is aligned with the '(' above, so it's considered to be aligned with `foo` 
                     *   baz // as a result, `baz` is offset by 1 rather than 2 
                     * ) 
                     */</span>
                    <span class="s6">if </span><span class="s4">(</span><span class="s2">lastConsequentToken</span><span class="s4">.</span><span class="s2">loc</span><span class="s4">.</span><span class="s2">end</span><span class="s4">.</span><span class="s2">line </span><span class="s4">=== </span><span class="s2">firstAlternateToken</span><span class="s4">.</span><span class="s2">loc</span><span class="s4">.</span><span class="s2">start</span><span class="s4">.</span><span class="s2">line</span><span class="s4">) {</span>
                        <span class="s2">offsets</span><span class="s4">.</span><span class="s2">setDesiredOffset</span><span class="s4">(</span><span class="s2">firstAlternateToken</span><span class="s4">, </span><span class="s2">firstConsequentToken</span><span class="s4">, </span><span class="s7">0</span><span class="s4">);</span>
                    <span class="s4">} </span><span class="s6">else </span><span class="s4">{</span>

                        <span class="s0">/**</span>
                         <span class="s0">* If the alternate and consequent do not share part of a line, offset the alternate from the first</span>
                         <span class="s0">* token of the conditional expression. For example:</span>
                         <span class="s0">* foo ? bar</span>
                         <span class="s0">*   : baz</span>
                         <span class="s0">*</span>
                         <span class="s0">* If `baz` were aligned with `bar` rather than being offset by 1 from `foo`, `baz` would end up</span>
                         <span class="s0">* having no expected indentation.</span>
                         <span class="s0">*/</span>
                        <span class="s2">offsets</span><span class="s4">.</span><span class="s2">setDesiredOffset</span><span class="s4">(</span><span class="s2">firstAlternateToken</span><span class="s4">, </span><span class="s2">firstToken</span><span class="s4">, </span><span class="s2">firstAlternateToken</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;Punctuator&quot; </span><span class="s4">&amp;&amp;</span>
                            <span class="s2">options</span><span class="s4">.</span><span class="s2">offsetTernaryExpressions </span><span class="s4">? </span><span class="s7">2 </span><span class="s4">: </span><span class="s7">1</span><span class="s4">);</span>
                    <span class="s4">}</span>
                <span class="s4">}</span>
            <span class="s4">},</span>

            <span class="s3">&quot;DoWhileStatement, WhileStatement, ForInStatement, ForOfStatement, WithStatement&quot;</span><span class="s4">: </span><span class="s2">node </span><span class="s4">=&gt; </span><span class="s2">addBlocklessNodeIndent</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">body</span><span class="s4">),</span>

            <span class="s2">ExportNamedDeclaration</span><span class="s4">(</span><span class="s2">node</span><span class="s4">) {</span>
                <span class="s6">if </span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">declaration </span><span class="s4">=== </span><span class="s6">null</span><span class="s4">) {</span>
                    <span class="s6">const </span><span class="s2">closingCurly </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getLastToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">, </span><span class="s2">astUtils</span><span class="s4">.</span><span class="s2">isClosingBraceToken</span><span class="s4">);</span>

                    <span class="s5">// Indent the specifiers in `export {foo, bar, baz}`</span>
                    <span class="s2">addElementListIndent</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">specifiers</span><span class="s4">, </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getFirstToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">, { </span><span class="s2">skip</span><span class="s4">: </span><span class="s7">1 </span><span class="s4">}), </span><span class="s2">closingCurly</span><span class="s4">, </span><span class="s7">1</span><span class="s4">);</span>

                    <span class="s6">if </span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">source</span><span class="s4">) {</span>

                        <span class="s5">// Indent everything after and including the `from` token in `export {foo, bar, baz} from 'qux'`</span>
                        <span class="s2">offsets</span><span class="s4">.</span><span class="s2">setDesiredOffsets</span><span class="s4">([</span><span class="s2">closingCurly</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s7">1</span><span class="s4">], </span><span class="s2">node</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s7">1</span><span class="s4">]], </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getFirstToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">), </span><span class="s7">1</span><span class="s4">);</span>
                    <span class="s4">}</span>
                <span class="s4">}</span>
            <span class="s4">},</span>

            <span class="s2">ForStatement</span><span class="s4">(</span><span class="s2">node</span><span class="s4">) {</span>
                <span class="s6">const </span><span class="s2">forOpeningParen </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getFirstToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">, </span><span class="s7">1</span><span class="s4">);</span>

                <span class="s6">if </span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">init</span><span class="s4">) {</span>
                    <span class="s2">offsets</span><span class="s4">.</span><span class="s2">setDesiredOffsets</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">init</span><span class="s4">.</span><span class="s2">range</span><span class="s4">, </span><span class="s2">forOpeningParen</span><span class="s4">, </span><span class="s7">1</span><span class="s4">);</span>
                <span class="s4">}</span>
                <span class="s6">if </span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">test</span><span class="s4">) {</span>
                    <span class="s2">offsets</span><span class="s4">.</span><span class="s2">setDesiredOffsets</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">test</span><span class="s4">.</span><span class="s2">range</span><span class="s4">, </span><span class="s2">forOpeningParen</span><span class="s4">, </span><span class="s7">1</span><span class="s4">);</span>
                <span class="s4">}</span>
                <span class="s6">if </span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">update</span><span class="s4">) {</span>
                    <span class="s2">offsets</span><span class="s4">.</span><span class="s2">setDesiredOffsets</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">update</span><span class="s4">.</span><span class="s2">range</span><span class="s4">, </span><span class="s2">forOpeningParen</span><span class="s4">, </span><span class="s7">1</span><span class="s4">);</span>
                <span class="s4">}</span>
                <span class="s2">addBlocklessNodeIndent</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">body</span><span class="s4">);</span>
            <span class="s4">},</span>

            <span class="s3">&quot;FunctionDeclaration, FunctionExpression&quot;</span><span class="s4">(</span><span class="s2">node</span><span class="s4">) {</span>
                <span class="s6">const </span><span class="s2">closingParen </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getTokenBefore</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">body</span><span class="s4">);</span>
                <span class="s6">const </span><span class="s2">openingParen </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getTokenBefore</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">params</span><span class="s4">.</span><span class="s2">length </span><span class="s4">? </span><span class="s2">node</span><span class="s4">.</span><span class="s2">params</span><span class="s4">[</span><span class="s7">0</span><span class="s4">] : </span><span class="s2">closingParen</span><span class="s4">);</span>

                <span class="s2">parameterParens</span><span class="s4">.</span><span class="s2">add</span><span class="s4">(</span><span class="s2">openingParen</span><span class="s4">);</span>
                <span class="s2">parameterParens</span><span class="s4">.</span><span class="s2">add</span><span class="s4">(</span><span class="s2">closingParen</span><span class="s4">);</span>
                <span class="s2">addElementListIndent</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">params</span><span class="s4">, </span><span class="s2">openingParen</span><span class="s4">, </span><span class="s2">closingParen</span><span class="s4">, </span><span class="s2">options</span><span class="s4">[</span><span class="s2">node</span><span class="s4">.</span><span class="s2">type</span><span class="s4">].</span><span class="s2">parameters</span><span class="s4">);</span>
            <span class="s4">},</span>

            <span class="s2">IfStatement</span><span class="s4">(</span><span class="s2">node</span><span class="s4">) {</span>
                <span class="s2">addBlocklessNodeIndent</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">consequent</span><span class="s4">);</span>
                <span class="s6">if </span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">alternate</span><span class="s4">) {</span>
                    <span class="s2">addBlocklessNodeIndent</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">alternate</span><span class="s4">);</span>
                <span class="s4">}</span>
            <span class="s4">},</span>

            <span class="s5">/* 
             * For blockless nodes with semicolon-first style, don't indent the semicolon. 
             * e.g. 
             * if (foo) 
             *     bar() 
             * ; [1, 2, 3].map(foo) 
             * 
             * Traversal into the node sets indentation of the semicolon, so we need to override it on exit. 
             */</span>
            <span class="s3">&quot;:matches(DoWhileStatement, ForStatement, ForInStatement, ForOfStatement, IfStatement, WhileStatement, WithStatement):exit&quot;</span><span class="s4">(</span><span class="s2">node</span><span class="s4">) {</span>
                <span class="s6">let </span><span class="s2">nodesToCheck</span><span class="s4">;</span>

                <span class="s6">if </span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;IfStatement&quot;</span><span class="s4">) {</span>
                    <span class="s2">nodesToCheck </span><span class="s4">= [</span><span class="s2">node</span><span class="s4">.</span><span class="s2">consequent</span><span class="s4">];</span>
                    <span class="s6">if </span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">alternate</span><span class="s4">) {</span>
                        <span class="s2">nodesToCheck</span><span class="s4">.</span><span class="s2">push</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">alternate</span><span class="s4">);</span>
                    <span class="s4">}</span>
                <span class="s4">} </span><span class="s6">else </span><span class="s4">{</span>
                    <span class="s2">nodesToCheck </span><span class="s4">= [</span><span class="s2">node</span><span class="s4">.</span><span class="s2">body</span><span class="s4">];</span>
                <span class="s4">}</span>

                <span class="s6">for </span><span class="s4">(</span><span class="s6">const </span><span class="s2">nodeToCheck of nodesToCheck</span><span class="s4">) {</span>
                    <span class="s6">const </span><span class="s2">lastToken </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getLastToken</span><span class="s4">(</span><span class="s2">nodeToCheck</span><span class="s4">);</span>

                    <span class="s6">if </span><span class="s4">(</span><span class="s2">astUtils</span><span class="s4">.</span><span class="s2">isSemicolonToken</span><span class="s4">(</span><span class="s2">lastToken</span><span class="s4">)) {</span>
                        <span class="s6">const </span><span class="s2">tokenBeforeLast </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getTokenBefore</span><span class="s4">(</span><span class="s2">lastToken</span><span class="s4">);</span>
                        <span class="s6">const </span><span class="s2">tokenAfterLast </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getTokenAfter</span><span class="s4">(</span><span class="s2">lastToken</span><span class="s4">);</span>

                        <span class="s5">// override indentation of `;` only if its line looks like a semicolon-first style line</span>
                        <span class="s6">if </span><span class="s4">(</span>
                            <span class="s4">!</span><span class="s2">astUtils</span><span class="s4">.</span><span class="s2">isTokenOnSameLine</span><span class="s4">(</span><span class="s2">tokenBeforeLast</span><span class="s4">, </span><span class="s2">lastToken</span><span class="s4">) &amp;&amp;</span>
                            <span class="s2">tokenAfterLast </span><span class="s4">&amp;&amp;</span>
                            <span class="s2">astUtils</span><span class="s4">.</span><span class="s2">isTokenOnSameLine</span><span class="s4">(</span><span class="s2">lastToken</span><span class="s4">, </span><span class="s2">tokenAfterLast</span><span class="s4">)</span>
                        <span class="s4">) {</span>
                            <span class="s2">offsets</span><span class="s4">.</span><span class="s2">setDesiredOffset</span><span class="s4">(</span>
                                <span class="s2">lastToken</span><span class="s4">,</span>
                                <span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getFirstToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">),</span>
                                <span class="s7">0</span>
                            <span class="s4">);</span>
                        <span class="s4">}</span>
                    <span class="s4">}</span>
                <span class="s4">}</span>
            <span class="s4">},</span>

            <span class="s2">ImportDeclaration</span><span class="s4">(</span><span class="s2">node</span><span class="s4">) {</span>
                <span class="s6">if </span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">specifiers</span><span class="s4">.</span><span class="s2">some</span><span class="s4">(</span><span class="s2">specifier </span><span class="s4">=&gt; </span><span class="s2">specifier</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;ImportSpecifier&quot;</span><span class="s4">)) {</span>
                    <span class="s6">const </span><span class="s2">openingCurly </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getFirstToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">, </span><span class="s2">astUtils</span><span class="s4">.</span><span class="s2">isOpeningBraceToken</span><span class="s4">);</span>
                    <span class="s6">const </span><span class="s2">closingCurly </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getLastToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">, </span><span class="s2">astUtils</span><span class="s4">.</span><span class="s2">isClosingBraceToken</span><span class="s4">);</span>

                    <span class="s2">addElementListIndent</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">specifiers</span><span class="s4">.</span><span class="s2">filter</span><span class="s4">(</span><span class="s2">specifier </span><span class="s4">=&gt; </span><span class="s2">specifier</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;ImportSpecifier&quot;</span><span class="s4">), </span><span class="s2">openingCurly</span><span class="s4">, </span><span class="s2">closingCurly</span><span class="s4">, </span><span class="s2">options</span><span class="s4">.</span><span class="s2">ImportDeclaration</span><span class="s4">);</span>
                <span class="s4">}</span>

                <span class="s6">const </span><span class="s2">fromToken </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getLastToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">, </span><span class="s2">token </span><span class="s4">=&gt; </span><span class="s2">token</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;Identifier&quot; </span><span class="s4">&amp;&amp; </span><span class="s2">token</span><span class="s4">.</span><span class="s2">value </span><span class="s4">=== </span><span class="s3">&quot;from&quot;</span><span class="s4">);</span>
                <span class="s6">const </span><span class="s2">sourceToken </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getLastToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">, </span><span class="s2">token </span><span class="s4">=&gt; </span><span class="s2">token</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;String&quot;</span><span class="s4">);</span>
                <span class="s6">const </span><span class="s2">semiToken </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getLastToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">, </span><span class="s2">token </span><span class="s4">=&gt; </span><span class="s2">token</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;Punctuator&quot; </span><span class="s4">&amp;&amp; </span><span class="s2">token</span><span class="s4">.</span><span class="s2">value </span><span class="s4">=== </span><span class="s3">&quot;;&quot;</span><span class="s4">);</span>

                <span class="s6">if </span><span class="s4">(</span><span class="s2">fromToken</span><span class="s4">) {</span>
                    <span class="s6">const </span><span class="s2">end </span><span class="s4">= </span><span class="s2">semiToken </span><span class="s4">&amp;&amp; </span><span class="s2">semiToken</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s7">1</span><span class="s4">] === </span><span class="s2">sourceToken</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s7">1</span><span class="s4">] ? </span><span class="s2">node</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s7">1</span><span class="s4">] : </span><span class="s2">sourceToken</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s7">1</span><span class="s4">];</span>

                    <span class="s2">offsets</span><span class="s4">.</span><span class="s2">setDesiredOffsets</span><span class="s4">([</span><span class="s2">fromToken</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s7">0</span><span class="s4">], </span><span class="s2">end</span><span class="s4">], </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getFirstToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">), </span><span class="s7">1</span><span class="s4">);</span>
                <span class="s4">}</span>
            <span class="s4">},</span>

            <span class="s2">ImportExpression</span><span class="s4">(</span><span class="s2">node</span><span class="s4">) {</span>
                <span class="s6">const </span><span class="s2">openingParen </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getFirstToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">, </span><span class="s7">1</span><span class="s4">);</span>
                <span class="s6">const </span><span class="s2">closingParen </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getLastToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">);</span>

                <span class="s2">parameterParens</span><span class="s4">.</span><span class="s2">add</span><span class="s4">(</span><span class="s2">openingParen</span><span class="s4">);</span>
                <span class="s2">parameterParens</span><span class="s4">.</span><span class="s2">add</span><span class="s4">(</span><span class="s2">closingParen</span><span class="s4">);</span>
                <span class="s2">offsets</span><span class="s4">.</span><span class="s2">setDesiredOffset</span><span class="s4">(</span><span class="s2">openingParen</span><span class="s4">, </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getTokenBefore</span><span class="s4">(</span><span class="s2">openingParen</span><span class="s4">), </span><span class="s7">0</span><span class="s4">);</span>

                <span class="s2">addElementListIndent</span><span class="s4">([</span><span class="s2">node</span><span class="s4">.</span><span class="s2">source</span><span class="s4">], </span><span class="s2">openingParen</span><span class="s4">, </span><span class="s2">closingParen</span><span class="s4">, </span><span class="s2">options</span><span class="s4">.</span><span class="s2">CallExpression</span><span class="s4">.</span><span class="s2">arguments</span><span class="s4">);</span>
            <span class="s4">},</span>

            <span class="s3">&quot;MemberExpression, JSXMemberExpression, MetaProperty&quot;</span><span class="s4">(</span><span class="s2">node</span><span class="s4">) {</span>
                <span class="s6">const </span><span class="s2">object </span><span class="s4">= </span><span class="s2">node</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;MetaProperty&quot; </span><span class="s4">? </span><span class="s2">node</span><span class="s4">.</span><span class="s2">meta </span><span class="s4">: </span><span class="s2">node</span><span class="s4">.</span><span class="s2">object</span><span class="s4">;</span>
                <span class="s6">const </span><span class="s2">firstNonObjectToken </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getFirstTokenBetween</span><span class="s4">(</span><span class="s2">object</span><span class="s4">, </span><span class="s2">node</span><span class="s4">.</span><span class="s2">property</span><span class="s4">, </span><span class="s2">astUtils</span><span class="s4">.</span><span class="s2">isNotClosingParenToken</span><span class="s4">);</span>
                <span class="s6">const </span><span class="s2">secondNonObjectToken </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getTokenAfter</span><span class="s4">(</span><span class="s2">firstNonObjectToken</span><span class="s4">);</span>

                <span class="s6">const </span><span class="s2">objectParenCount </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getTokensBetween</span><span class="s4">(</span><span class="s2">object</span><span class="s4">, </span><span class="s2">node</span><span class="s4">.</span><span class="s2">property</span><span class="s4">, { </span><span class="s2">filter</span><span class="s4">: </span><span class="s2">astUtils</span><span class="s4">.</span><span class="s2">isClosingParenToken </span><span class="s4">}).</span><span class="s2">length</span><span class="s4">;</span>
                <span class="s6">const </span><span class="s2">firstObjectToken </span><span class="s4">= </span><span class="s2">objectParenCount</span>
                    <span class="s4">? </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getTokenBefore</span><span class="s4">(</span><span class="s2">object</span><span class="s4">, { </span><span class="s2">skip</span><span class="s4">: </span><span class="s2">objectParenCount </span><span class="s4">- </span><span class="s7">1 </span><span class="s4">})</span>
                    <span class="s4">: </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getFirstToken</span><span class="s4">(</span><span class="s2">object</span><span class="s4">);</span>
                <span class="s6">const </span><span class="s2">lastObjectToken </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getTokenBefore</span><span class="s4">(</span><span class="s2">firstNonObjectToken</span><span class="s4">);</span>
                <span class="s6">const </span><span class="s2">firstPropertyToken </span><span class="s4">= </span><span class="s2">node</span><span class="s4">.</span><span class="s2">computed </span><span class="s4">? </span><span class="s2">firstNonObjectToken </span><span class="s4">: </span><span class="s2">secondNonObjectToken</span><span class="s4">;</span>

                <span class="s6">if </span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">computed</span><span class="s4">) {</span>

                    <span class="s5">// For computed MemberExpressions, match the closing bracket with the opening bracket.</span>
                    <span class="s2">offsets</span><span class="s4">.</span><span class="s2">setDesiredOffset</span><span class="s4">(</span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getLastToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">), </span><span class="s2">firstNonObjectToken</span><span class="s4">, </span><span class="s7">0</span><span class="s4">);</span>
                    <span class="s2">offsets</span><span class="s4">.</span><span class="s2">setDesiredOffsets</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">property</span><span class="s4">.</span><span class="s2">range</span><span class="s4">, </span><span class="s2">firstNonObjectToken</span><span class="s4">, </span><span class="s7">1</span><span class="s4">);</span>
                <span class="s4">}</span>

                <span class="s5">/* 
                 * If the object ends on the same line that the property starts, match against the last token 
                 * of the object, to ensure that the MemberExpression is not indented. 
                 * 
                 * Otherwise, match against the first token of the object, e.g. 
                 * foo 
                 *   .bar 
                 *   .baz // &lt;-- offset by 1 from `foo` 
                 */</span>
                <span class="s6">const </span><span class="s2">offsetBase </span><span class="s4">= </span><span class="s2">lastObjectToken</span><span class="s4">.</span><span class="s2">loc</span><span class="s4">.</span><span class="s2">end</span><span class="s4">.</span><span class="s2">line </span><span class="s4">=== </span><span class="s2">firstPropertyToken</span><span class="s4">.</span><span class="s2">loc</span><span class="s4">.</span><span class="s2">start</span><span class="s4">.</span><span class="s2">line</span>
                    <span class="s4">? </span><span class="s2">lastObjectToken</span>
                    <span class="s4">: </span><span class="s2">firstObjectToken</span><span class="s4">;</span>

                <span class="s6">if </span><span class="s4">(</span><span class="s6">typeof </span><span class="s2">options</span><span class="s4">.</span><span class="s2">MemberExpression </span><span class="s4">=== </span><span class="s3">&quot;number&quot;</span><span class="s4">) {</span>

                    <span class="s5">// Match the dot (for non-computed properties) or the opening bracket (for computed properties) against the object.</span>
                    <span class="s2">offsets</span><span class="s4">.</span><span class="s2">setDesiredOffset</span><span class="s4">(</span><span class="s2">firstNonObjectToken</span><span class="s4">, </span><span class="s2">offsetBase</span><span class="s4">, </span><span class="s2">options</span><span class="s4">.</span><span class="s2">MemberExpression</span><span class="s4">);</span>

                    <span class="s5">/* 
                     * For computed MemberExpressions, match the first token of the property against the opening bracket. 
                     * Otherwise, match the first token of the property against the object. 
                     */</span>
                    <span class="s2">offsets</span><span class="s4">.</span><span class="s2">setDesiredOffset</span><span class="s4">(</span><span class="s2">secondNonObjectToken</span><span class="s4">, </span><span class="s2">node</span><span class="s4">.</span><span class="s2">computed </span><span class="s4">? </span><span class="s2">firstNonObjectToken </span><span class="s4">: </span><span class="s2">offsetBase</span><span class="s4">, </span><span class="s2">options</span><span class="s4">.</span><span class="s2">MemberExpression</span><span class="s4">);</span>
                <span class="s4">} </span><span class="s6">else </span><span class="s4">{</span>

                    <span class="s5">// If the MemberExpression option is off, ignore the dot and the first token of the property.</span>
                    <span class="s2">offsets</span><span class="s4">.</span><span class="s2">ignoreToken</span><span class="s4">(</span><span class="s2">firstNonObjectToken</span><span class="s4">);</span>
                    <span class="s2">offsets</span><span class="s4">.</span><span class="s2">ignoreToken</span><span class="s4">(</span><span class="s2">secondNonObjectToken</span><span class="s4">);</span>

                    <span class="s5">// To ignore the property indentation, ensure that the property tokens depend on the ignored tokens.</span>
                    <span class="s2">offsets</span><span class="s4">.</span><span class="s2">setDesiredOffset</span><span class="s4">(</span><span class="s2">firstNonObjectToken</span><span class="s4">, </span><span class="s2">offsetBase</span><span class="s4">, </span><span class="s7">0</span><span class="s4">);</span>
                    <span class="s2">offsets</span><span class="s4">.</span><span class="s2">setDesiredOffset</span><span class="s4">(</span><span class="s2">secondNonObjectToken</span><span class="s4">, </span><span class="s2">firstNonObjectToken</span><span class="s4">, </span><span class="s7">0</span><span class="s4">);</span>
                <span class="s4">}</span>
            <span class="s4">},</span>

            <span class="s2">NewExpression</span><span class="s4">(</span><span class="s2">node</span><span class="s4">) {</span>

                <span class="s5">// Only indent the arguments if the NewExpression has parens (e.g. `new Foo(bar)` or `new Foo()`, but not `new Foo`</span>
                <span class="s6">if </span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">arguments</span><span class="s4">.</span><span class="s2">length </span><span class="s4">&gt; </span><span class="s7">0 </span><span class="s4">||</span>
                        <span class="s2">astUtils</span><span class="s4">.</span><span class="s2">isClosingParenToken</span><span class="s4">(</span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getLastToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">)) &amp;&amp;</span>
                        <span class="s2">astUtils</span><span class="s4">.</span><span class="s2">isOpeningParenToken</span><span class="s4">(</span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getLastToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">, </span><span class="s7">1</span><span class="s4">))) {</span>
                    <span class="s2">addFunctionCallIndent</span><span class="s4">(</span><span class="s2">node</span><span class="s4">);</span>
                <span class="s4">}</span>
            <span class="s4">},</span>

            <span class="s2">Property</span><span class="s4">(</span><span class="s2">node</span><span class="s4">) {</span>
                <span class="s6">if </span><span class="s4">(!</span><span class="s2">node</span><span class="s4">.</span><span class="s2">shorthand </span><span class="s4">&amp;&amp; !</span><span class="s2">node</span><span class="s4">.</span><span class="s2">method </span><span class="s4">&amp;&amp; </span><span class="s2">node</span><span class="s4">.</span><span class="s2">kind </span><span class="s4">=== </span><span class="s3">&quot;init&quot;</span><span class="s4">) {</span>
                    <span class="s6">const </span><span class="s2">colon </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getFirstTokenBetween</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">key</span><span class="s4">, </span><span class="s2">node</span><span class="s4">.</span><span class="s2">value</span><span class="s4">, </span><span class="s2">astUtils</span><span class="s4">.</span><span class="s2">isColonToken</span><span class="s4">);</span>

                    <span class="s2">offsets</span><span class="s4">.</span><span class="s2">ignoreToken</span><span class="s4">(</span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getTokenAfter</span><span class="s4">(</span><span class="s2">colon</span><span class="s4">));</span>
                <span class="s4">}</span>
            <span class="s4">},</span>

            <span class="s2">PropertyDefinition</span><span class="s4">(</span><span class="s2">node</span><span class="s4">) {</span>
                <span class="s6">const </span><span class="s2">firstToken </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getFirstToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">);</span>
                <span class="s6">const </span><span class="s2">maybeSemicolonToken </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getLastToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">);</span>
                <span class="s6">let </span><span class="s2">keyLastToken </span><span class="s4">= </span><span class="s6">null</span><span class="s4">;</span>

                <span class="s5">// Indent key.</span>
                <span class="s6">if </span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">computed</span><span class="s4">) {</span>
                    <span class="s6">const </span><span class="s2">bracketTokenL </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getTokenBefore</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">key</span><span class="s4">, </span><span class="s2">astUtils</span><span class="s4">.</span><span class="s2">isOpeningBracketToken</span><span class="s4">);</span>
                    <span class="s6">const </span><span class="s2">bracketTokenR </span><span class="s4">= </span><span class="s2">keyLastToken </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getTokenAfter</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">key</span><span class="s4">, </span><span class="s2">astUtils</span><span class="s4">.</span><span class="s2">isClosingBracketToken</span><span class="s4">);</span>
                    <span class="s6">const </span><span class="s2">keyRange </span><span class="s4">= [</span><span class="s2">bracketTokenL</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s7">1</span><span class="s4">], </span><span class="s2">bracketTokenR</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s7">0</span><span class="s4">]];</span>

                    <span class="s6">if </span><span class="s4">(</span><span class="s2">bracketTokenL </span><span class="s4">!== </span><span class="s2">firstToken</span><span class="s4">) {</span>
                        <span class="s2">offsets</span><span class="s4">.</span><span class="s2">setDesiredOffset</span><span class="s4">(</span><span class="s2">bracketTokenL</span><span class="s4">, </span><span class="s2">firstToken</span><span class="s4">, </span><span class="s7">0</span><span class="s4">);</span>
                    <span class="s4">}</span>
                    <span class="s2">offsets</span><span class="s4">.</span><span class="s2">setDesiredOffsets</span><span class="s4">(</span><span class="s2">keyRange</span><span class="s4">, </span><span class="s2">bracketTokenL</span><span class="s4">, </span><span class="s7">1</span><span class="s4">);</span>
                    <span class="s2">offsets</span><span class="s4">.</span><span class="s2">setDesiredOffset</span><span class="s4">(</span><span class="s2">bracketTokenR</span><span class="s4">, </span><span class="s2">bracketTokenL</span><span class="s4">, </span><span class="s7">0</span><span class="s4">);</span>
                <span class="s4">} </span><span class="s6">else </span><span class="s4">{</span>
                    <span class="s6">const </span><span class="s2">idToken </span><span class="s4">= </span><span class="s2">keyLastToken </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getFirstToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">key</span><span class="s4">);</span>

                    <span class="s6">if </span><span class="s4">(</span><span class="s2">idToken </span><span class="s4">!== </span><span class="s2">firstToken</span><span class="s4">) {</span>
                        <span class="s2">offsets</span><span class="s4">.</span><span class="s2">setDesiredOffset</span><span class="s4">(</span><span class="s2">idToken</span><span class="s4">, </span><span class="s2">firstToken</span><span class="s4">, </span><span class="s7">1</span><span class="s4">);</span>
                    <span class="s4">}</span>
                <span class="s4">}</span>

                <span class="s5">// Indent initializer.</span>
                <span class="s6">if </span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">value</span><span class="s4">) {</span>
                    <span class="s6">const </span><span class="s2">eqToken </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getTokenBefore</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">value</span><span class="s4">, </span><span class="s2">astUtils</span><span class="s4">.</span><span class="s2">isEqToken</span><span class="s4">);</span>
                    <span class="s6">const </span><span class="s2">valueToken </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getTokenAfter</span><span class="s4">(</span><span class="s2">eqToken</span><span class="s4">);</span>

                    <span class="s2">offsets</span><span class="s4">.</span><span class="s2">setDesiredOffset</span><span class="s4">(</span><span class="s2">eqToken</span><span class="s4">, </span><span class="s2">keyLastToken</span><span class="s4">, </span><span class="s7">1</span><span class="s4">);</span>
                    <span class="s2">offsets</span><span class="s4">.</span><span class="s2">setDesiredOffset</span><span class="s4">(</span><span class="s2">valueToken</span><span class="s4">, </span><span class="s2">eqToken</span><span class="s4">, </span><span class="s7">1</span><span class="s4">);</span>
                    <span class="s6">if </span><span class="s4">(</span><span class="s2">astUtils</span><span class="s4">.</span><span class="s2">isSemicolonToken</span><span class="s4">(</span><span class="s2">maybeSemicolonToken</span><span class="s4">)) {</span>
                        <span class="s2">offsets</span><span class="s4">.</span><span class="s2">setDesiredOffset</span><span class="s4">(</span><span class="s2">maybeSemicolonToken</span><span class="s4">, </span><span class="s2">eqToken</span><span class="s4">, </span><span class="s7">1</span><span class="s4">);</span>
                    <span class="s4">}</span>
                <span class="s4">} </span><span class="s6">else if </span><span class="s4">(</span><span class="s2">astUtils</span><span class="s4">.</span><span class="s2">isSemicolonToken</span><span class="s4">(</span><span class="s2">maybeSemicolonToken</span><span class="s4">)) {</span>
                    <span class="s2">offsets</span><span class="s4">.</span><span class="s2">setDesiredOffset</span><span class="s4">(</span><span class="s2">maybeSemicolonToken</span><span class="s4">, </span><span class="s2">keyLastToken</span><span class="s4">, </span><span class="s7">1</span><span class="s4">);</span>
                <span class="s4">}</span>
            <span class="s4">},</span>

            <span class="s2">StaticBlock</span><span class="s4">(</span><span class="s2">node</span><span class="s4">) {</span>
                <span class="s6">const </span><span class="s2">openingCurly </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getFirstToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">, { </span><span class="s2">skip</span><span class="s4">: </span><span class="s7">1 </span><span class="s4">}); </span><span class="s5">// skip the `static` token</span>
                <span class="s6">const </span><span class="s2">closingCurly </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getLastToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">);</span>

                <span class="s2">addElementListIndent</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">body</span><span class="s4">, </span><span class="s2">openingCurly</span><span class="s4">, </span><span class="s2">closingCurly</span><span class="s4">, </span><span class="s2">options</span><span class="s4">.</span><span class="s2">StaticBlock</span><span class="s4">.</span><span class="s2">body</span><span class="s4">);</span>
            <span class="s4">},</span>

            <span class="s2">SwitchStatement</span><span class="s4">(</span><span class="s2">node</span><span class="s4">) {</span>
                <span class="s6">const </span><span class="s2">openingCurly </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getTokenAfter</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">discriminant</span><span class="s4">, </span><span class="s2">astUtils</span><span class="s4">.</span><span class="s2">isOpeningBraceToken</span><span class="s4">);</span>
                <span class="s6">const </span><span class="s2">closingCurly </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getLastToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">);</span>

                <span class="s2">offsets</span><span class="s4">.</span><span class="s2">setDesiredOffsets</span><span class="s4">([</span><span class="s2">openingCurly</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s7">1</span><span class="s4">], </span><span class="s2">closingCurly</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s7">0</span><span class="s4">]], </span><span class="s2">openingCurly</span><span class="s4">, </span><span class="s2">options</span><span class="s4">.</span><span class="s2">SwitchCase</span><span class="s4">);</span>

                <span class="s6">if </span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">cases</span><span class="s4">.</span><span class="s2">length</span><span class="s4">) {</span>
                    <span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getTokensBetween</span><span class="s4">(</span>
                        <span class="s2">node</span><span class="s4">.</span><span class="s2">cases</span><span class="s4">[</span><span class="s2">node</span><span class="s4">.</span><span class="s2">cases</span><span class="s4">.</span><span class="s2">length </span><span class="s4">- </span><span class="s7">1</span><span class="s4">],</span>
                        <span class="s2">closingCurly</span><span class="s4">,</span>
                        <span class="s4">{ </span><span class="s2">includeComments</span><span class="s4">: </span><span class="s6">true</span><span class="s4">, </span><span class="s2">filter</span><span class="s4">: </span><span class="s2">astUtils</span><span class="s4">.</span><span class="s2">isCommentToken </span><span class="s4">}</span>
                    <span class="s4">).</span><span class="s2">forEach</span><span class="s4">(</span><span class="s2">token </span><span class="s4">=&gt; </span><span class="s2">offsets</span><span class="s4">.</span><span class="s2">ignoreToken</span><span class="s4">(</span><span class="s2">token</span><span class="s4">));</span>
                <span class="s4">}</span>
            <span class="s4">},</span>

            <span class="s2">SwitchCase</span><span class="s4">(</span><span class="s2">node</span><span class="s4">) {</span>
                <span class="s6">if </span><span class="s4">(!(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">consequent</span><span class="s4">.</span><span class="s2">length </span><span class="s4">=== </span><span class="s7">1 </span><span class="s4">&amp;&amp; </span><span class="s2">node</span><span class="s4">.</span><span class="s2">consequent</span><span class="s4">[</span><span class="s7">0</span><span class="s4">].</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;BlockStatement&quot;</span><span class="s4">)) {</span>
                    <span class="s6">const </span><span class="s2">caseKeyword </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getFirstToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">);</span>
                    <span class="s6">const </span><span class="s2">tokenAfterCurrentCase </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getTokenAfter</span><span class="s4">(</span><span class="s2">node</span><span class="s4">);</span>

                    <span class="s2">offsets</span><span class="s4">.</span><span class="s2">setDesiredOffsets</span><span class="s4">([</span><span class="s2">caseKeyword</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s7">1</span><span class="s4">], </span><span class="s2">tokenAfterCurrentCase</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s7">0</span><span class="s4">]], </span><span class="s2">caseKeyword</span><span class="s4">, </span><span class="s7">1</span><span class="s4">);</span>
                <span class="s4">}</span>
            <span class="s4">},</span>

            <span class="s2">TemplateLiteral</span><span class="s4">(</span><span class="s2">node</span><span class="s4">) {</span>
                <span class="s2">node</span><span class="s4">.</span><span class="s2">expressions</span><span class="s4">.</span><span class="s2">forEach</span><span class="s4">((</span><span class="s2">expression</span><span class="s4">, </span><span class="s2">index</span><span class="s4">) =&gt; {</span>
                    <span class="s6">const </span><span class="s2">previousQuasi </span><span class="s4">= </span><span class="s2">node</span><span class="s4">.</span><span class="s2">quasis</span><span class="s4">[</span><span class="s2">index</span><span class="s4">];</span>
                    <span class="s6">const </span><span class="s2">nextQuasi </span><span class="s4">= </span><span class="s2">node</span><span class="s4">.</span><span class="s2">quasis</span><span class="s4">[</span><span class="s2">index </span><span class="s4">+ </span><span class="s7">1</span><span class="s4">];</span>
                    <span class="s6">const </span><span class="s2">tokenToAlignFrom </span><span class="s4">= </span><span class="s2">previousQuasi</span><span class="s4">.</span><span class="s2">loc</span><span class="s4">.</span><span class="s2">start</span><span class="s4">.</span><span class="s2">line </span><span class="s4">=== </span><span class="s2">previousQuasi</span><span class="s4">.</span><span class="s2">loc</span><span class="s4">.</span><span class="s2">end</span><span class="s4">.</span><span class="s2">line</span>
                        <span class="s4">? </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getFirstToken</span><span class="s4">(</span><span class="s2">previousQuasi</span><span class="s4">)</span>
                        <span class="s4">: </span><span class="s6">null</span><span class="s4">;</span>

                    <span class="s2">offsets</span><span class="s4">.</span><span class="s2">setDesiredOffsets</span><span class="s4">([</span><span class="s2">previousQuasi</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s7">1</span><span class="s4">], </span><span class="s2">nextQuasi</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s7">0</span><span class="s4">]], </span><span class="s2">tokenToAlignFrom</span><span class="s4">, </span><span class="s7">1</span><span class="s4">);</span>
                    <span class="s2">offsets</span><span class="s4">.</span><span class="s2">setDesiredOffset</span><span class="s4">(</span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getFirstToken</span><span class="s4">(</span><span class="s2">nextQuasi</span><span class="s4">), </span><span class="s2">tokenToAlignFrom</span><span class="s4">, </span><span class="s7">0</span><span class="s4">);</span>
                <span class="s4">});</span>
            <span class="s4">},</span>

            <span class="s2">VariableDeclaration</span><span class="s4">(</span><span class="s2">node</span><span class="s4">) {</span>
                <span class="s6">let </span><span class="s2">variableIndent </span><span class="s4">= </span><span class="s2">Object</span><span class="s4">.</span><span class="s2">prototype</span><span class="s4">.</span><span class="s2">hasOwnProperty</span><span class="s4">.</span><span class="s2">call</span><span class="s4">(</span><span class="s2">options</span><span class="s4">.</span><span class="s2">VariableDeclarator</span><span class="s4">, </span><span class="s2">node</span><span class="s4">.</span><span class="s2">kind</span><span class="s4">)</span>
                    <span class="s4">? </span><span class="s2">options</span><span class="s4">.</span><span class="s2">VariableDeclarator</span><span class="s4">[</span><span class="s2">node</span><span class="s4">.</span><span class="s2">kind</span><span class="s4">]</span>
                    <span class="s4">: </span><span class="s2">DEFAULT_VARIABLE_INDENT</span><span class="s4">;</span>

                <span class="s6">const </span><span class="s2">firstToken </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getFirstToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">),</span>
                    <span class="s2">lastToken </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getLastToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">);</span>

                <span class="s6">if </span><span class="s4">(</span><span class="s2">options</span><span class="s4">.</span><span class="s2">VariableDeclarator</span><span class="s4">[</span><span class="s2">node</span><span class="s4">.</span><span class="s2">kind</span><span class="s4">] === </span><span class="s3">&quot;first&quot;</span><span class="s4">) {</span>
                    <span class="s6">if </span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">declarations</span><span class="s4">.</span><span class="s2">length </span><span class="s4">&gt; </span><span class="s7">1</span><span class="s4">) {</span>
                        <span class="s2">addElementListIndent</span><span class="s4">(</span>
                            <span class="s2">node</span><span class="s4">.</span><span class="s2">declarations</span><span class="s4">,</span>
                            <span class="s2">firstToken</span><span class="s4">,</span>
                            <span class="s2">lastToken</span><span class="s4">,</span>
                            <span class="s3">&quot;first&quot;</span>
                        <span class="s4">);</span>
                        <span class="s6">return</span><span class="s4">;</span>
                    <span class="s4">}</span>

                    <span class="s2">variableIndent </span><span class="s4">= </span><span class="s2">DEFAULT_VARIABLE_INDENT</span><span class="s4">;</span>
                <span class="s4">}</span>

                <span class="s6">if </span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">declarations</span><span class="s4">[</span><span class="s2">node</span><span class="s4">.</span><span class="s2">declarations</span><span class="s4">.</span><span class="s2">length </span><span class="s4">- </span><span class="s7">1</span><span class="s4">].</span><span class="s2">loc</span><span class="s4">.</span><span class="s2">start</span><span class="s4">.</span><span class="s2">line </span><span class="s4">&gt; </span><span class="s2">node</span><span class="s4">.</span><span class="s2">loc</span><span class="s4">.</span><span class="s2">start</span><span class="s4">.</span><span class="s2">line</span><span class="s4">) {</span>

                    <span class="s5">/* 
                     * VariableDeclarator indentation is a bit different from other forms of indentation, in that the 
                     * indentation of an opening bracket sometimes won't match that of a closing bracket. For example, 
                     * the following indentations are correct: 
                     * 
                     * var foo = { 
                     *   ok: true 
                     * }; 
                     * 
                     * var foo = { 
                     *     ok: true, 
                     *   }, 
                     *   bar = 1; 
                     * 
                     * Account for when exiting the AST (after indentations have already been set for the nodes in 
                     * the declaration) by manually increasing the indentation level of the tokens in this declarator 
                     * on the same line as the start of the declaration, provided that there are declarators that 
                     * follow this one. 
                     */</span>
                    <span class="s2">offsets</span><span class="s4">.</span><span class="s2">setDesiredOffsets</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">range</span><span class="s4">, </span><span class="s2">firstToken</span><span class="s4">, </span><span class="s2">variableIndent</span><span class="s4">, </span><span class="s6">true</span><span class="s4">);</span>
                <span class="s4">} </span><span class="s6">else </span><span class="s4">{</span>
                    <span class="s2">offsets</span><span class="s4">.</span><span class="s2">setDesiredOffsets</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">range</span><span class="s4">, </span><span class="s2">firstToken</span><span class="s4">, </span><span class="s2">variableIndent</span><span class="s4">);</span>
                <span class="s4">}</span>

                <span class="s6">if </span><span class="s4">(</span><span class="s2">astUtils</span><span class="s4">.</span><span class="s2">isSemicolonToken</span><span class="s4">(</span><span class="s2">lastToken</span><span class="s4">)) {</span>
                    <span class="s2">offsets</span><span class="s4">.</span><span class="s2">ignoreToken</span><span class="s4">(</span><span class="s2">lastToken</span><span class="s4">);</span>
                <span class="s4">}</span>
            <span class="s4">},</span>

            <span class="s2">VariableDeclarator</span><span class="s4">(</span><span class="s2">node</span><span class="s4">) {</span>
                <span class="s6">if </span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">init</span><span class="s4">) {</span>
                    <span class="s6">const </span><span class="s2">equalOperator </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getTokenBefore</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">init</span><span class="s4">, </span><span class="s2">astUtils</span><span class="s4">.</span><span class="s2">isNotOpeningParenToken</span><span class="s4">);</span>
                    <span class="s6">const </span><span class="s2">tokenAfterOperator </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getTokenAfter</span><span class="s4">(</span><span class="s2">equalOperator</span><span class="s4">);</span>

                    <span class="s2">offsets</span><span class="s4">.</span><span class="s2">ignoreToken</span><span class="s4">(</span><span class="s2">equalOperator</span><span class="s4">);</span>
                    <span class="s2">offsets</span><span class="s4">.</span><span class="s2">ignoreToken</span><span class="s4">(</span><span class="s2">tokenAfterOperator</span><span class="s4">);</span>
                    <span class="s2">offsets</span><span class="s4">.</span><span class="s2">setDesiredOffsets</span><span class="s4">([</span><span class="s2">tokenAfterOperator</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s7">0</span><span class="s4">], </span><span class="s2">node</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s7">1</span><span class="s4">]], </span><span class="s2">equalOperator</span><span class="s4">, </span><span class="s7">1</span><span class="s4">);</span>
                    <span class="s2">offsets</span><span class="s4">.</span><span class="s2">setDesiredOffset</span><span class="s4">(</span><span class="s2">equalOperator</span><span class="s4">, </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getLastToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">id</span><span class="s4">), </span><span class="s7">0</span><span class="s4">);</span>
                <span class="s4">}</span>
            <span class="s4">},</span>

            <span class="s3">&quot;JSXAttribute[value]&quot;</span><span class="s4">(</span><span class="s2">node</span><span class="s4">) {</span>
                <span class="s6">const </span><span class="s2">equalsToken </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getFirstTokenBetween</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">name</span><span class="s4">, </span><span class="s2">node</span><span class="s4">.</span><span class="s2">value</span><span class="s4">, </span><span class="s2">token </span><span class="s4">=&gt; </span><span class="s2">token</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;Punctuator&quot; </span><span class="s4">&amp;&amp; </span><span class="s2">token</span><span class="s4">.</span><span class="s2">value </span><span class="s4">=== </span><span class="s3">&quot;=&quot;</span><span class="s4">);</span>

                <span class="s2">offsets</span><span class="s4">.</span><span class="s2">setDesiredOffsets</span><span class="s4">([</span><span class="s2">equalsToken</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s7">0</span><span class="s4">], </span><span class="s2">node</span><span class="s4">.</span><span class="s2">value</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s7">1</span><span class="s4">]], </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getFirstToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">name</span><span class="s4">), </span><span class="s7">1</span><span class="s4">);</span>
            <span class="s4">},</span>

            <span class="s2">JSXElement</span><span class="s4">(</span><span class="s2">node</span><span class="s4">) {</span>
                <span class="s6">if </span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">closingElement</span><span class="s4">) {</span>
                    <span class="s2">addElementListIndent</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">children</span><span class="s4">, </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getFirstToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">openingElement</span><span class="s4">), </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getFirstToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">closingElement</span><span class="s4">), </span><span class="s7">1</span><span class="s4">);</span>
                <span class="s4">}</span>
            <span class="s4">},</span>

            <span class="s2">JSXOpeningElement</span><span class="s4">(</span><span class="s2">node</span><span class="s4">) {</span>
                <span class="s6">const </span><span class="s2">firstToken </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getFirstToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">);</span>
                <span class="s6">let </span><span class="s2">closingToken</span><span class="s4">;</span>

                <span class="s6">if </span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">selfClosing</span><span class="s4">) {</span>
                    <span class="s2">closingToken </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getLastToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">, { </span><span class="s2">skip</span><span class="s4">: </span><span class="s7">1 </span><span class="s4">});</span>
                    <span class="s2">offsets</span><span class="s4">.</span><span class="s2">setDesiredOffset</span><span class="s4">(</span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getLastToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">), </span><span class="s2">closingToken</span><span class="s4">, </span><span class="s7">0</span><span class="s4">);</span>
                <span class="s4">} </span><span class="s6">else </span><span class="s4">{</span>
                    <span class="s2">closingToken </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getLastToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">);</span>
                <span class="s4">}</span>
                <span class="s2">offsets</span><span class="s4">.</span><span class="s2">setDesiredOffsets</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">name</span><span class="s4">.</span><span class="s2">range</span><span class="s4">, </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getFirstToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">));</span>
                <span class="s2">addElementListIndent</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">attributes</span><span class="s4">, </span><span class="s2">firstToken</span><span class="s4">, </span><span class="s2">closingToken</span><span class="s4">, </span><span class="s7">1</span><span class="s4">);</span>
            <span class="s4">},</span>

            <span class="s2">JSXClosingElement</span><span class="s4">(</span><span class="s2">node</span><span class="s4">) {</span>
                <span class="s6">const </span><span class="s2">firstToken </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getFirstToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">);</span>

                <span class="s2">offsets</span><span class="s4">.</span><span class="s2">setDesiredOffsets</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">name</span><span class="s4">.</span><span class="s2">range</span><span class="s4">, </span><span class="s2">firstToken</span><span class="s4">, </span><span class="s7">1</span><span class="s4">);</span>
            <span class="s4">},</span>

            <span class="s2">JSXFragment</span><span class="s4">(</span><span class="s2">node</span><span class="s4">) {</span>
                <span class="s6">const </span><span class="s2">firstOpeningToken </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getFirstToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">openingFragment</span><span class="s4">);</span>
                <span class="s6">const </span><span class="s2">firstClosingToken </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getFirstToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">closingFragment</span><span class="s4">);</span>

                <span class="s2">addElementListIndent</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">children</span><span class="s4">, </span><span class="s2">firstOpeningToken</span><span class="s4">, </span><span class="s2">firstClosingToken</span><span class="s4">, </span><span class="s7">1</span><span class="s4">);</span>
            <span class="s4">},</span>

            <span class="s2">JSXOpeningFragment</span><span class="s4">(</span><span class="s2">node</span><span class="s4">) {</span>
                <span class="s6">const </span><span class="s2">firstToken </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getFirstToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">);</span>
                <span class="s6">const </span><span class="s2">closingToken </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getLastToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">);</span>

                <span class="s2">offsets</span><span class="s4">.</span><span class="s2">setDesiredOffsets</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">range</span><span class="s4">, </span><span class="s2">firstToken</span><span class="s4">, </span><span class="s7">1</span><span class="s4">);</span>
                <span class="s2">offsets</span><span class="s4">.</span><span class="s2">matchOffsetOf</span><span class="s4">(</span><span class="s2">firstToken</span><span class="s4">, </span><span class="s2">closingToken</span><span class="s4">);</span>
            <span class="s4">},</span>

            <span class="s2">JSXClosingFragment</span><span class="s4">(</span><span class="s2">node</span><span class="s4">) {</span>
                <span class="s6">const </span><span class="s2">firstToken </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getFirstToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">);</span>
                <span class="s6">const </span><span class="s2">slashToken </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getLastToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">, { </span><span class="s2">skip</span><span class="s4">: </span><span class="s7">1 </span><span class="s4">});</span>
                <span class="s6">const </span><span class="s2">closingToken </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getLastToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">);</span>
                <span class="s6">const </span><span class="s2">tokenToMatch </span><span class="s4">= </span><span class="s2">astUtils</span><span class="s4">.</span><span class="s2">isTokenOnSameLine</span><span class="s4">(</span><span class="s2">slashToken</span><span class="s4">, </span><span class="s2">closingToken</span><span class="s4">) ? </span><span class="s2">slashToken </span><span class="s4">: </span><span class="s2">closingToken</span><span class="s4">;</span>

                <span class="s2">offsets</span><span class="s4">.</span><span class="s2">setDesiredOffsets</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">range</span><span class="s4">, </span><span class="s2">firstToken</span><span class="s4">, </span><span class="s7">1</span><span class="s4">);</span>
                <span class="s2">offsets</span><span class="s4">.</span><span class="s2">matchOffsetOf</span><span class="s4">(</span><span class="s2">firstToken</span><span class="s4">, </span><span class="s2">tokenToMatch</span><span class="s4">);</span>
            <span class="s4">},</span>

            <span class="s2">JSXExpressionContainer</span><span class="s4">(</span><span class="s2">node</span><span class="s4">) {</span>
                <span class="s6">const </span><span class="s2">openingCurly </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getFirstToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">);</span>
                <span class="s6">const </span><span class="s2">closingCurly </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getLastToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">);</span>

                <span class="s2">offsets</span><span class="s4">.</span><span class="s2">setDesiredOffsets</span><span class="s4">(</span>
                    <span class="s4">[</span><span class="s2">openingCurly</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s7">1</span><span class="s4">], </span><span class="s2">closingCurly</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s7">0</span><span class="s4">]],</span>
                    <span class="s2">openingCurly</span><span class="s4">,</span>
                    <span class="s7">1</span>
                <span class="s4">);</span>
            <span class="s4">},</span>

            <span class="s2">JSXSpreadAttribute</span><span class="s4">(</span><span class="s2">node</span><span class="s4">) {</span>
                <span class="s6">const </span><span class="s2">openingCurly </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getFirstToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">);</span>
                <span class="s6">const </span><span class="s2">closingCurly </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getLastToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">);</span>

                <span class="s2">offsets</span><span class="s4">.</span><span class="s2">setDesiredOffsets</span><span class="s4">(</span>
                    <span class="s4">[</span><span class="s2">openingCurly</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s7">1</span><span class="s4">], </span><span class="s2">closingCurly</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s7">0</span><span class="s4">]],</span>
                    <span class="s2">openingCurly</span><span class="s4">,</span>
                    <span class="s7">1</span>
                <span class="s4">);</span>
            <span class="s4">},</span>

            <span class="s3">&quot;*&quot;</span><span class="s4">(</span><span class="s2">node</span><span class="s4">) {</span>
                <span class="s6">const </span><span class="s2">firstToken </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getFirstToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">);</span>

                <span class="s5">// Ensure that the children of every node are indented at least as much as the first token.</span>
                <span class="s6">if </span><span class="s4">(</span><span class="s2">firstToken </span><span class="s4">&amp;&amp; !</span><span class="s2">ignoredNodeFirstTokens</span><span class="s4">.</span><span class="s2">has</span><span class="s4">(</span><span class="s2">firstToken</span><span class="s4">)) {</span>
                    <span class="s2">offsets</span><span class="s4">.</span><span class="s2">setDesiredOffsets</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">range</span><span class="s4">, </span><span class="s2">firstToken</span><span class="s4">, </span><span class="s7">0</span><span class="s4">);</span>
                <span class="s4">}</span>
            <span class="s4">}</span>
        <span class="s4">};</span>

        <span class="s6">const </span><span class="s2">listenerCallQueue </span><span class="s4">= [];</span>

        <span class="s5">/* 
         * To ignore the indentation of a node: 
         * 1. Don't call the node's listener when entering it (if it has a listener) 
         * 2. Don't set any offsets against the first token of the node. 
         * 3. Call `ignoreNode` on the node sometime after exiting it and before validating offsets. 
         */</span>
        <span class="s6">const </span><span class="s2">offsetListeners </span><span class="s4">= {};</span>

        <span class="s6">for </span><span class="s4">(</span><span class="s6">const </span><span class="s4">[</span><span class="s2">selector</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">] </span><span class="s2">of Object</span><span class="s4">.</span><span class="s2">entries</span><span class="s4">(</span><span class="s2">baseOffsetListeners</span><span class="s4">)) {</span>

            <span class="s5">/* 
             * Offset listener calls are deferred until traversal is finished, and are called as 
             * part of the final `Program:exit` listener. This is necessary because a node might 
             * be matched by multiple selectors. 
             * 
             * Example: Suppose there is an offset listener for `Identifier`, and the user has 
             * specified in configuration that `MemberExpression &gt; Identifier` should be ignored. 
             * Due to selector specificity rules, the `Identifier` listener will get called first. However, 
             * if a given Identifier node is supposed to be ignored, then the `Identifier` offset listener 
             * should not have been called at all. Without doing extra selector matching, we don't know 
             * whether the Identifier matches the `MemberExpression &gt; Identifier` selector until the 
             * `MemberExpression &gt; Identifier` listener is called. 
             * 
             * To avoid this, the `Identifier` listener isn't called until traversal finishes and all 
             * ignored nodes are known. 
             */</span>
            <span class="s2">offsetListeners</span><span class="s4">[</span><span class="s2">selector</span><span class="s4">] = </span><span class="s2">node </span><span class="s4">=&gt; </span><span class="s2">listenerCallQueue</span><span class="s4">.</span><span class="s2">push</span><span class="s4">({ </span><span class="s2">listener</span><span class="s4">, </span><span class="s2">node </span><span class="s4">});</span>
        <span class="s4">}</span>

        <span class="s5">// For each ignored node selector, set up a listener to collect it into the `ignoredNodes` set.</span>
        <span class="s6">const </span><span class="s2">ignoredNodes </span><span class="s4">= </span><span class="s6">new </span><span class="s2">Set</span><span class="s4">();</span>

        <span class="s0">/**</span>
         <span class="s0">* Ignores a node</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The node to ignore</span>
         <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
         <span class="s0">*/</span>
        <span class="s6">function </span><span class="s2">addToIgnoredNodes</span><span class="s4">(</span><span class="s2">node</span><span class="s4">) {</span>
            <span class="s2">ignoredNodes</span><span class="s4">.</span><span class="s2">add</span><span class="s4">(</span><span class="s2">node</span><span class="s4">);</span>
            <span class="s2">ignoredNodeFirstTokens</span><span class="s4">.</span><span class="s2">add</span><span class="s4">(</span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getFirstToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">));</span>
        <span class="s4">}</span>

        <span class="s6">const </span><span class="s2">ignoredNodeListeners </span><span class="s4">= </span><span class="s2">options</span><span class="s4">.</span><span class="s2">ignoredNodes</span><span class="s4">.</span><span class="s2">reduce</span><span class="s4">(</span>
            <span class="s4">(</span><span class="s2">listeners</span><span class="s4">, </span><span class="s2">ignoredSelector</span><span class="s4">) =&gt; </span><span class="s2">Object</span><span class="s4">.</span><span class="s2">assign</span><span class="s4">(</span><span class="s2">listeners</span><span class="s4">, { [</span><span class="s2">ignoredSelector</span><span class="s4">]: </span><span class="s2">addToIgnoredNodes </span><span class="s4">}),</span>
            <span class="s4">{}</span>
        <span class="s4">);</span>

        <span class="s5">/* 
         * Join the listeners, and add a listener to verify that all tokens actually have the correct indentation 
         * at the end. 
         * 
         * Using Object.assign will cause some offset listeners to be overwritten if the same selector also appears 
         * in `ignoredNodeListeners`. This isn't a problem because all of the matching nodes will be ignored, 
         * so those listeners wouldn't be called anyway. 
         */</span>
        <span class="s6">return </span><span class="s2">Object</span><span class="s4">.</span><span class="s2">assign</span><span class="s4">(</span>
            <span class="s2">offsetListeners</span><span class="s4">,</span>
            <span class="s2">ignoredNodeListeners</span><span class="s4">,</span>
            <span class="s4">{</span>
                <span class="s3">&quot;*:exit&quot;</span><span class="s4">(</span><span class="s2">node</span><span class="s4">) {</span>

                    <span class="s5">// If a node's type is nonstandard, we can't tell how its children should be offset, so ignore it.</span>
                    <span class="s6">if </span><span class="s4">(!</span><span class="s2">KNOWN_NODES</span><span class="s4">.</span><span class="s2">has</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">type</span><span class="s4">)) {</span>
                        <span class="s2">addToIgnoredNodes</span><span class="s4">(</span><span class="s2">node</span><span class="s4">);</span>
                    <span class="s4">}</span>
                <span class="s4">},</span>
                <span class="s3">&quot;Program:exit&quot;</span><span class="s4">() {</span>

                    <span class="s5">// If ignoreComments option is enabled, ignore all comment tokens.</span>
                    <span class="s6">if </span><span class="s4">(</span><span class="s2">options</span><span class="s4">.</span><span class="s2">ignoreComments</span><span class="s4">) {</span>
                        <span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getAllComments</span><span class="s4">()</span>
                            <span class="s4">.</span><span class="s2">forEach</span><span class="s4">(</span><span class="s2">comment </span><span class="s4">=&gt; </span><span class="s2">offsets</span><span class="s4">.</span><span class="s2">ignoreToken</span><span class="s4">(</span><span class="s2">comment</span><span class="s4">));</span>
                    <span class="s4">}</span>

                    <span class="s5">// Invoke the queued offset listeners for the nodes that aren't ignored.</span>
                    <span class="s6">for </span><span class="s4">(</span><span class="s6">let </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s2">listenerCallQueue</span><span class="s4">.</span><span class="s2">length</span><span class="s4">; </span><span class="s2">i</span><span class="s4">++) {</span>
                        <span class="s6">const </span><span class="s2">nodeInfo </span><span class="s4">= </span><span class="s2">listenerCallQueue</span><span class="s4">[</span><span class="s2">i</span><span class="s4">];</span>

                        <span class="s6">if </span><span class="s4">(!</span><span class="s2">ignoredNodes</span><span class="s4">.</span><span class="s2">has</span><span class="s4">(</span><span class="s2">nodeInfo</span><span class="s4">.</span><span class="s2">node</span><span class="s4">)) {</span>
                            <span class="s2">nodeInfo</span><span class="s4">.</span><span class="s2">listener</span><span class="s4">(</span><span class="s2">nodeInfo</span><span class="s4">.</span><span class="s2">node</span><span class="s4">);</span>
                        <span class="s4">}</span>
                    <span class="s4">}</span>

                    <span class="s5">// Update the offsets for ignored nodes to prevent their child tokens from being reported.</span>
                    <span class="s2">ignoredNodes</span><span class="s4">.</span><span class="s2">forEach</span><span class="s4">(</span><span class="s2">ignoreNode</span><span class="s4">);</span>

                    <span class="s2">addParensIndent</span><span class="s4">(</span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">ast</span><span class="s4">.</span><span class="s2">tokens</span><span class="s4">);</span>

                    <span class="s5">/* 
                     * Create a Map from (tokenOrComment) =&gt; (precedingToken). 
                     * This is necessary because sourceCode.getTokenBefore does not handle a comment as an argument correctly. 
                     */</span>
                    <span class="s6">const </span><span class="s2">precedingTokens </span><span class="s4">= </span><span class="s6">new </span><span class="s2">WeakMap</span><span class="s4">();</span>

                    <span class="s6">for </span><span class="s4">(</span><span class="s6">let </span><span class="s2">i </span><span class="s4">= </span><span class="s7">0</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">ast</span><span class="s4">.</span><span class="s2">comments</span><span class="s4">.</span><span class="s2">length</span><span class="s4">; </span><span class="s2">i</span><span class="s4">++) {</span>
                        <span class="s6">const </span><span class="s2">comment </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">ast</span><span class="s4">.</span><span class="s2">comments</span><span class="s4">[</span><span class="s2">i</span><span class="s4">];</span>

                        <span class="s6">const </span><span class="s2">tokenOrCommentBefore </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getTokenBefore</span><span class="s4">(</span><span class="s2">comment</span><span class="s4">, { </span><span class="s2">includeComments</span><span class="s4">: </span><span class="s6">true </span><span class="s4">});</span>
                        <span class="s6">const </span><span class="s2">hasToken </span><span class="s4">= </span><span class="s2">precedingTokens</span><span class="s4">.</span><span class="s2">has</span><span class="s4">(</span><span class="s2">tokenOrCommentBefore</span><span class="s4">) ? </span><span class="s2">precedingTokens</span><span class="s4">.</span><span class="s2">get</span><span class="s4">(</span><span class="s2">tokenOrCommentBefore</span><span class="s4">) : </span><span class="s2">tokenOrCommentBefore</span><span class="s4">;</span>

                        <span class="s2">precedingTokens</span><span class="s4">.</span><span class="s2">set</span><span class="s4">(</span><span class="s2">comment</span><span class="s4">, </span><span class="s2">hasToken</span><span class="s4">);</span>
                    <span class="s4">}</span>

                    <span class="s6">for </span><span class="s4">(</span><span class="s6">let </span><span class="s2">i </span><span class="s4">= </span><span class="s7">1</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">lines</span><span class="s4">.</span><span class="s2">length </span><span class="s4">+ </span><span class="s7">1</span><span class="s4">; </span><span class="s2">i</span><span class="s4">++) {</span>

                        <span class="s6">if </span><span class="s4">(!</span><span class="s2">tokenInfo</span><span class="s4">.</span><span class="s2">firstTokensByLineNumber</span><span class="s4">.</span><span class="s2">has</span><span class="s4">(</span><span class="s2">i</span><span class="s4">)) {</span>

                            <span class="s5">// Don't check indentation on blank lines</span>
                            <span class="s6">continue</span><span class="s4">;</span>
                        <span class="s4">}</span>

                        <span class="s6">const </span><span class="s2">firstTokenOfLine </span><span class="s4">= </span><span class="s2">tokenInfo</span><span class="s4">.</span><span class="s2">firstTokensByLineNumber</span><span class="s4">.</span><span class="s2">get</span><span class="s4">(</span><span class="s2">i</span><span class="s4">);</span>

                        <span class="s6">if </span><span class="s4">(</span><span class="s2">firstTokenOfLine</span><span class="s4">.</span><span class="s2">loc</span><span class="s4">.</span><span class="s2">start</span><span class="s4">.</span><span class="s2">line </span><span class="s4">!== </span><span class="s2">i</span><span class="s4">) {</span>

                            <span class="s5">// Don't check the indentation of multi-line tokens (e.g. template literals or block comments) twice.</span>
                            <span class="s6">continue</span><span class="s4">;</span>
                        <span class="s4">}</span>

                        <span class="s6">if </span><span class="s4">(</span><span class="s2">astUtils</span><span class="s4">.</span><span class="s2">isCommentToken</span><span class="s4">(</span><span class="s2">firstTokenOfLine</span><span class="s4">)) {</span>
                            <span class="s6">const </span><span class="s2">tokenBefore </span><span class="s4">= </span><span class="s2">precedingTokens</span><span class="s4">.</span><span class="s2">get</span><span class="s4">(</span><span class="s2">firstTokenOfLine</span><span class="s4">);</span>
                            <span class="s6">const </span><span class="s2">tokenAfter </span><span class="s4">= </span><span class="s2">tokenBefore </span><span class="s4">? </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getTokenAfter</span><span class="s4">(</span><span class="s2">tokenBefore</span><span class="s4">) : </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">ast</span><span class="s4">.</span><span class="s2">tokens</span><span class="s4">[</span><span class="s7">0</span><span class="s4">];</span>
                            <span class="s6">const </span><span class="s2">mayAlignWithBefore </span><span class="s4">= </span><span class="s2">tokenBefore </span><span class="s4">&amp;&amp; !</span><span class="s2">hasBlankLinesBetween</span><span class="s4">(</span><span class="s2">tokenBefore</span><span class="s4">, </span><span class="s2">firstTokenOfLine</span><span class="s4">);</span>
                            <span class="s6">const </span><span class="s2">mayAlignWithAfter </span><span class="s4">= </span><span class="s2">tokenAfter </span><span class="s4">&amp;&amp; !</span><span class="s2">hasBlankLinesBetween</span><span class="s4">(</span><span class="s2">firstTokenOfLine</span><span class="s4">, </span><span class="s2">tokenAfter</span><span class="s4">);</span>

                            <span class="s5">/* 
                             * If a comment precedes a line that begins with a semicolon token, align to that token, i.e. 
                             * 
                             * let foo 
                             * // comment 
                             * ;(async () =&gt; {})() 
                             */</span>
                            <span class="s6">if </span><span class="s4">(</span><span class="s2">tokenAfter </span><span class="s4">&amp;&amp; </span><span class="s2">astUtils</span><span class="s4">.</span><span class="s2">isSemicolonToken</span><span class="s4">(</span><span class="s2">tokenAfter</span><span class="s4">) &amp;&amp; !</span><span class="s2">astUtils</span><span class="s4">.</span><span class="s2">isTokenOnSameLine</span><span class="s4">(</span><span class="s2">firstTokenOfLine</span><span class="s4">, </span><span class="s2">tokenAfter</span><span class="s4">)) {</span>
                                <span class="s2">offsets</span><span class="s4">.</span><span class="s2">setDesiredOffset</span><span class="s4">(</span><span class="s2">firstTokenOfLine</span><span class="s4">, </span><span class="s2">tokenAfter</span><span class="s4">, </span><span class="s7">0</span><span class="s4">);</span>
                            <span class="s4">}</span>

                            <span class="s5">// If a comment matches the expected indentation of the token immediately before or after, don't report it.</span>
                            <span class="s6">if </span><span class="s4">(</span>
                                <span class="s2">mayAlignWithBefore </span><span class="s4">&amp;&amp; </span><span class="s2">validateTokenIndent</span><span class="s4">(</span><span class="s2">firstTokenOfLine</span><span class="s4">, </span><span class="s2">offsets</span><span class="s4">.</span><span class="s2">getDesiredIndent</span><span class="s4">(</span><span class="s2">tokenBefore</span><span class="s4">)) ||</span>
                                <span class="s2">mayAlignWithAfter </span><span class="s4">&amp;&amp; </span><span class="s2">validateTokenIndent</span><span class="s4">(</span><span class="s2">firstTokenOfLine</span><span class="s4">, </span><span class="s2">offsets</span><span class="s4">.</span><span class="s2">getDesiredIndent</span><span class="s4">(</span><span class="s2">tokenAfter</span><span class="s4">))</span>
                            <span class="s4">) {</span>
                                <span class="s6">continue</span><span class="s4">;</span>
                            <span class="s4">}</span>
                        <span class="s4">}</span>

                        <span class="s5">// If the token matches the expected indentation, don't report it.</span>
                        <span class="s6">if </span><span class="s4">(</span><span class="s2">validateTokenIndent</span><span class="s4">(</span><span class="s2">firstTokenOfLine</span><span class="s4">, </span><span class="s2">offsets</span><span class="s4">.</span><span class="s2">getDesiredIndent</span><span class="s4">(</span><span class="s2">firstTokenOfLine</span><span class="s4">))) {</span>
                            <span class="s6">continue</span><span class="s4">;</span>
                        <span class="s4">}</span>

                        <span class="s5">// Otherwise, report the token/comment.</span>
                        <span class="s2">report</span><span class="s4">(</span><span class="s2">firstTokenOfLine</span><span class="s4">, </span><span class="s2">offsets</span><span class="s4">.</span><span class="s2">getDesiredIndent</span><span class="s4">(</span><span class="s2">firstTokenOfLine</span><span class="s4">));</span>
                    <span class="s4">}</span>
                <span class="s4">}</span>
            <span class="s4">}</span>
        <span class="s4">);</span>
    <span class="s4">}</span>
<span class="s4">};</span>
</pre>
</body>
</html>