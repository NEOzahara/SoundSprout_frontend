<html>
<head>
<title>index.min.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #bcbec4;}
.s2 { color: #6aab73;}
.s3 { color: #2aacb8;}
.s4 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
index.min.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span>
  <span class="s2">&quot;version&quot;</span><span class="s0">: </span><span class="s3">3</span><span class="s0">,</span>
  <span class="s2">&quot;sources&quot;</span><span class="s0">: [</span><span class="s2">&quot;../../src/index.ts&quot;</span><span class="s0">],</span>
  <span class="s2">&quot;sourcesContent&quot;</span><span class="s0">: [</span><span class="s2">&quot;/**</span><span class="s4">\n </span><span class="s2">* @module LRUCache</span><span class="s4">\n </span><span class="s2">*/</span><span class="s4">\n\n</span><span class="s2">// module-private names and types</span><span class="s4">\n</span><span class="s2">type Perf = { now: () =&gt; number }</span><span class="s4">\n</span><span class="s2">const perf: Perf =</span><span class="s4">\n  </span><span class="s2">typeof performance === 'object' &amp;&amp;</span><span class="s4">\n  </span><span class="s2">performance &amp;&amp;</span><span class="s4">\n  </span><span class="s2">typeof performance.now === 'function'</span><span class="s4">\n    </span><span class="s2">? performance</span><span class="s4">\n    </span><span class="s2">: Date</span><span class="s4">\n\n</span><span class="s2">const warned = new Set&lt;string&gt;()</span><span class="s4">\n\n</span><span class="s2">// either a function or a class</span><span class="s4">\n</span><span class="s2">type ForC = ((...a: any[]) =&gt; any) | { new (...a: any[]): any }</span><span class="s4">\n\n</span><span class="s2">/* c8 ignore start */</span><span class="s4">\n</span><span class="s2">const PROCESS = (</span><span class="s4">\n  </span><span class="s2">typeof process === 'object' &amp;&amp; !!process ? process : {}</span><span class="s4">\n</span><span class="s2">) as { [k: string]: any }</span><span class="s4">\n</span><span class="s2">/* c8 ignore start */</span><span class="s4">\n\n</span><span class="s2">const emitWarning = (</span><span class="s4">\n  </span><span class="s2">msg: string,</span><span class="s4">\n  </span><span class="s2">type: string,</span><span class="s4">\n  </span><span class="s2">code: string,</span><span class="s4">\n  </span><span class="s2">fn: ForC</span><span class="s4">\n</span><span class="s2">) =&gt; {</span><span class="s4">\n  </span><span class="s2">typeof PROCESS.emitWarning === 'function'</span><span class="s4">\n    </span><span class="s2">? PROCESS.emitWarning(msg, type, code, fn)</span><span class="s4">\n    </span><span class="s2">: console.error(`[${code}] ${type}: ${msg}`)</span><span class="s4">\n</span><span class="s2">}</span><span class="s4">\n\n</span><span class="s2">let AC = globalThis.AbortController</span><span class="s4">\n</span><span class="s2">let AS = globalThis.AbortSignal</span><span class="s4">\n\n</span><span class="s2">/* c8 ignore start */</span><span class="s4">\n</span><span class="s2">if (typeof AC === 'undefined') {</span><span class="s4">\n  </span><span class="s2">//@ts-ignore</span><span class="s4">\n  </span><span class="s2">AS = class AbortSignal {</span><span class="s4">\n    </span><span class="s2">onabort?: (...a: any[]) =&gt; any</span><span class="s4">\n    </span><span class="s2">_onabort: ((...a: any[]) =&gt; any)[] = []</span><span class="s4">\n    </span><span class="s2">reason?: any</span><span class="s4">\n    </span><span class="s2">aborted: boolean = false</span><span class="s4">\n    </span><span class="s2">addEventListener(_: string, fn: (...a: any[]) =&gt; any) {</span><span class="s4">\n      </span><span class="s2">this._onabort.push(fn)</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n  </span><span class="s2">//@ts-ignore</span><span class="s4">\n  </span><span class="s2">AC = class AbortController {</span><span class="s4">\n    </span><span class="s2">constructor() {</span><span class="s4">\n      </span><span class="s2">warnACPolyfill()</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n    </span><span class="s2">signal = new AS()</span><span class="s4">\n    </span><span class="s2">abort(reason: any) {</span><span class="s4">\n      </span><span class="s2">if (this.signal.aborted) return</span><span class="s4">\n      </span><span class="s2">//@ts-ignore</span><span class="s4">\n      </span><span class="s2">this.signal.reason = reason</span><span class="s4">\n      </span><span class="s2">//@ts-ignore</span><span class="s4">\n      </span><span class="s2">this.signal.aborted = true</span><span class="s4">\n      </span><span class="s2">//@ts-ignore</span><span class="s4">\n      </span><span class="s2">for (const fn of this.signal._onabort) {</span><span class="s4">\n        </span><span class="s2">fn(reason)</span><span class="s4">\n      </span><span class="s2">}</span><span class="s4">\n      </span><span class="s2">this.signal.onabort?.(reason)</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n  </span><span class="s2">let printACPolyfillWarning =</span><span class="s4">\n    </span><span class="s2">PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== '1'</span><span class="s4">\n  </span><span class="s2">const warnACPolyfill = () =&gt; {</span><span class="s4">\n    </span><span class="s2">if (!printACPolyfillWarning) return</span><span class="s4">\n    </span><span class="s2">printACPolyfillWarning = false</span><span class="s4">\n    </span><span class="s2">emitWarning(</span><span class="s4">\n      </span><span class="s2">'AbortController is not defined. If using lru-cache in ' +</span><span class="s4">\n        </span><span class="s2">'node 14, load an AbortController polyfill from the ' +</span><span class="s4">\n        </span><span class="s2">'`node-abort-controller` package. A minimal polyfill is ' +</span><span class="s4">\n        </span><span class="s2">'provided for use by LRUCache.fetch(), but it should not be ' +</span><span class="s4">\n        </span><span class="s2">'relied upon in other contexts (eg, passing it to other APIs that ' +</span><span class="s4">\n        </span><span class="s2">'use AbortController/AbortSignal might have undesirable effects). ' +</span><span class="s4">\n        </span><span class="s2">'You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.',</span><span class="s4">\n      </span><span class="s2">'NO_ABORT_CONTROLLER',</span><span class="s4">\n      </span><span class="s2">'ENOTSUP',</span><span class="s4">\n      </span><span class="s2">warnACPolyfill</span><span class="s4">\n    </span><span class="s2">)</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n</span><span class="s2">}</span><span class="s4">\n</span><span class="s2">/* c8 ignore stop */</span><span class="s4">\n\n</span><span class="s2">const shouldWarn = (code: string) =&gt; !warned.has(code)</span><span class="s4">\n\n</span><span class="s2">const TYPE = Symbol('type')</span><span class="s4">\n</span><span class="s2">export type PosInt = number &amp; { [TYPE]: 'Positive Integer' }</span><span class="s4">\n</span><span class="s2">export type Index = number &amp; { [TYPE]: 'LRUCache Index' }</span><span class="s4">\n\n</span><span class="s2">const isPosInt = (n: any): n is PosInt =&gt;</span><span class="s4">\n  </span><span class="s2">n &amp;&amp; n === Math.floor(n) &amp;&amp; n &gt; 0 &amp;&amp; isFinite(n)</span><span class="s4">\n\n</span><span class="s2">export type UintArray = Uint8Array | Uint16Array | Uint32Array</span><span class="s4">\n</span><span class="s2">export type NumberArray = UintArray | number[]</span><span class="s4">\n\n</span><span class="s2">/* c8 ignore start */</span><span class="s4">\n</span><span class="s2">// This is a little bit ridiculous, tbh.</span><span class="s4">\n</span><span class="s2">// The maximum array length is 2^32-1 or thereabouts on most JS impls.</span><span class="s4">\n</span><span class="s2">// And well before that point, you're caching the entire world, I mean,</span><span class="s4">\n</span><span class="s2">// that's ~32GB of just integers for the next/prev links, plus whatever</span><span class="s4">\n</span><span class="s2">// else to hold that many keys and values.  Just filling the memory with</span><span class="s4">\n</span><span class="s2">// zeroes at init time is brutal when you get that big.</span><span class="s4">\n</span><span class="s2">// But why not be complete?</span><span class="s4">\n</span><span class="s2">// Maybe in the future, these limits will have expanded.</span><span class="s4">\n</span><span class="s2">const getUintArray = (max: number) =&gt;</span><span class="s4">\n  </span><span class="s2">!isPosInt(max)</span><span class="s4">\n    </span><span class="s2">? null</span><span class="s4">\n    </span><span class="s2">: max &lt;= Math.pow(2, 8)</span><span class="s4">\n    </span><span class="s2">? Uint8Array</span><span class="s4">\n    </span><span class="s2">: max &lt;= Math.pow(2, 16)</span><span class="s4">\n    </span><span class="s2">? Uint16Array</span><span class="s4">\n    </span><span class="s2">: max &lt;= Math.pow(2, 32)</span><span class="s4">\n    </span><span class="s2">? Uint32Array</span><span class="s4">\n    </span><span class="s2">: max &lt;= Number.MAX_SAFE_INTEGER</span><span class="s4">\n    </span><span class="s2">? ZeroArray</span><span class="s4">\n    </span><span class="s2">: null</span><span class="s4">\n</span><span class="s2">/* c8 ignore stop */</span><span class="s4">\n\n</span><span class="s2">class ZeroArray extends Array&lt;number&gt; {</span><span class="s4">\n  </span><span class="s2">constructor(size: number) {</span><span class="s4">\n    </span><span class="s2">super(size)</span><span class="s4">\n    </span><span class="s2">this.fill(0)</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n</span><span class="s2">}</span><span class="s4">\n</span><span class="s2">export type { ZeroArray }</span><span class="s4">\n</span><span class="s2">export type { Stack }</span><span class="s4">\n\n</span><span class="s2">export type StackLike = Stack | Index[]</span><span class="s4">\n</span><span class="s2">class Stack {</span><span class="s4">\n  </span><span class="s2">heap: NumberArray</span><span class="s4">\n  </span><span class="s2">length: number</span><span class="s4">\n  </span><span class="s2">// private constructor</span><span class="s4">\n  </span><span class="s2">static #constructing: boolean = false</span><span class="s4">\n  </span><span class="s2">static create(max: number): StackLike {</span><span class="s4">\n    </span><span class="s2">const HeapCls = getUintArray(max)</span><span class="s4">\n    </span><span class="s2">if (!HeapCls) return []</span><span class="s4">\n    </span><span class="s2">Stack.#constructing = true</span><span class="s4">\n    </span><span class="s2">const s = new Stack(max, HeapCls)</span><span class="s4">\n    </span><span class="s2">Stack.#constructing = false</span><span class="s4">\n    </span><span class="s2">return s</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n  </span><span class="s2">constructor(</span><span class="s4">\n    </span><span class="s2">max: number,</span><span class="s4">\n    </span><span class="s2">HeapCls: { new (n: number): NumberArray }</span><span class="s4">\n  </span><span class="s2">) {</span><span class="s4">\n    </span><span class="s2">/* c8 ignore start */</span><span class="s4">\n    </span><span class="s2">if (!Stack.#constructing) {</span><span class="s4">\n      </span><span class="s2">throw new TypeError('instantiate Stack using Stack.create(n)')</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n    </span><span class="s2">/* c8 ignore stop */</span><span class="s4">\n    </span><span class="s2">this.heap = new HeapCls(max)</span><span class="s4">\n    </span><span class="s2">this.length = 0</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n  </span><span class="s2">push(n: Index) {</span><span class="s4">\n    </span><span class="s2">this.heap[this.length++] = n</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n  </span><span class="s2">pop(): Index {</span><span class="s4">\n    </span><span class="s2">return this.heap[--this.length] as Index</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n</span><span class="s2">}</span><span class="s4">\n\n</span><span class="s2">/**</span><span class="s4">\n </span><span class="s2">* Promise representing an in-progress {@link LRUCache#fetch} call</span><span class="s4">\n </span><span class="s2">*/</span><span class="s4">\n</span><span class="s2">export type BackgroundFetch&lt;V&gt; = Promise&lt;V | undefined&gt; &amp; {</span><span class="s4">\n  </span><span class="s2">__returned: BackgroundFetch&lt;V&gt; | undefined</span><span class="s4">\n  </span><span class="s2">__abortController: AbortController</span><span class="s4">\n  </span><span class="s2">__staleWhileFetching: V | undefined</span><span class="s4">\n</span><span class="s2">}</span><span class="s4">\n\n</span><span class="s2">export type DisposeTask&lt;K, V&gt; = [</span><span class="s4">\n  </span><span class="s2">value: V,</span><span class="s4">\n  </span><span class="s2">key: K,</span><span class="s4">\n  </span><span class="s2">reason: LRUCache.DisposeReason</span><span class="s4">\n</span><span class="s2">]</span><span class="s4">\n\n</span><span class="s2">export namespace LRUCache {</span><span class="s4">\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* An integer greater than 0, reflecting the calculated size of items</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">export type Size = number</span><span class="s4">\n\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* Integer greater than 0, representing some number of milliseconds, or the</span><span class="s4">\n   </span><span class="s2">* time at which a TTL started counting from.</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">export type Milliseconds = number</span><span class="s4">\n\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* An integer greater than 0, reflecting a number of items</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">export type Count = number</span><span class="s4">\n\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* The reason why an item was removed from the cache, passed</span><span class="s4">\n   </span><span class="s2">* to the {@link Disposer} methods.</span><span class="s4">\n   </span><span class="s2">*</span><span class="s4">\n   </span><span class="s2">* - `evict`: The item was evicted because it is the least recently used,</span><span class="s4">\n   </span><span class="s2">*   and the cache is full.</span><span class="s4">\n   </span><span class="s2">* - `set`: A new value was set, overwriting the old value being disposed.</span><span class="s4">\n   </span><span class="s2">* - `delete`: The item was explicitly deleted, either by calling</span><span class="s4">\n   </span><span class="s2">*   {@link LRUCache#delete}, {@link LRUCache#clear}, or</span><span class="s4">\n   </span><span class="s2">*   {@link LRUCache#set} with an undefined value.</span><span class="s4">\n   </span><span class="s2">* - `expire`: The item was removed due to exceeding its TTL.</span><span class="s4">\n   </span><span class="s2">* - `fetch`: A {@link OptionsBase#fetchMethod} operation returned</span><span class="s4">\n   </span><span class="s2">*   `undefined` or was aborted, causing the item to be deleted.</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">export type DisposeReason =</span><span class="s4">\n    </span><span class="s2">| 'evict'</span><span class="s4">\n    </span><span class="s2">| 'set'</span><span class="s4">\n    </span><span class="s2">| 'delete'</span><span class="s4">\n    </span><span class="s2">| 'expire'</span><span class="s4">\n    </span><span class="s2">| 'fetch'</span><span class="s4">\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* A method called upon item removal, passed as the</span><span class="s4">\n   </span><span class="s2">* {@link OptionsBase.dispose} and/or</span><span class="s4">\n   </span><span class="s2">* {@link OptionsBase.disposeAfter} options.</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">export type Disposer&lt;K, V&gt; = (</span><span class="s4">\n    </span><span class="s2">value: V,</span><span class="s4">\n    </span><span class="s2">key: K,</span><span class="s4">\n    </span><span class="s2">reason: DisposeReason</span><span class="s4">\n  </span><span class="s2">) =&gt; void</span><span class="s4">\n\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* A function that returns the effective calculated size</span><span class="s4">\n   </span><span class="s2">* of an entry in the cache.</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">export type SizeCalculator&lt;K, V&gt; = (value: V, key: K) =&gt; Size</span><span class="s4">\n\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* Options provided to the</span><span class="s4">\n   </span><span class="s2">* {@link OptionsBase.fetchMethod} function.</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">export interface FetcherOptions&lt;K, V, FC = unknown&gt; {</span><span class="s4">\n    </span><span class="s2">signal: AbortSignal</span><span class="s4">\n    </span><span class="s2">options: FetcherFetchOptions&lt;K, V, FC&gt;</span><span class="s4">\n    </span><span class="s2">/**</span><span class="s4">\n     </span><span class="s2">* Object provided in the {@link FetchOptions.context} option to</span><span class="s4">\n     </span><span class="s2">* {@link LRUCache#fetch}</span><span class="s4">\n     </span><span class="s2">*/</span><span class="s4">\n    </span><span class="s2">context: FC</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* Occasionally, it may be useful to track the internal behavior of the</span><span class="s4">\n   </span><span class="s2">* cache, particularly for logging, debugging, or for behavior within the</span><span class="s4">\n   </span><span class="s2">* `fetchMethod`. To do this, you can pass a `status` object to the</span><span class="s4">\n   </span><span class="s2">* {@link LRUCache#fetch}, {@link LRUCache#get}, {@link LRUCache#set},</span><span class="s4">\n   </span><span class="s2">* {@link LRUCache#memo}, and {@link LRUCache#has} methods.</span><span class="s4">\n   </span><span class="s2">*</span><span class="s4">\n   </span><span class="s2">* The `status` option should be a plain JavaScript object. The following</span><span class="s4">\n   </span><span class="s2">* fields will be set on it appropriately, depending on the situation.</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">export interface Status&lt;V&gt; {</span><span class="s4">\n    </span><span class="s2">/**</span><span class="s4">\n     </span><span class="s2">* The status of a set() operation.</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* - add: the item was not found in the cache, and was added</span><span class="s4">\n     </span><span class="s2">* - update: the item was in the cache, with the same value provided</span><span class="s4">\n     </span><span class="s2">* - replace: the item was in the cache, and replaced</span><span class="s4">\n     </span><span class="s2">* - miss: the item was not added to the cache for some reason</span><span class="s4">\n     </span><span class="s2">*/</span><span class="s4">\n    </span><span class="s2">set?: 'add' | 'update' | 'replace' | 'miss'</span><span class="s4">\n\n    </span><span class="s2">/**</span><span class="s4">\n     </span><span class="s2">* the ttl stored for the item, or undefined if ttls are not used.</span><span class="s4">\n     </span><span class="s2">*/</span><span class="s4">\n    </span><span class="s2">ttl?: Milliseconds</span><span class="s4">\n\n    </span><span class="s2">/**</span><span class="s4">\n     </span><span class="s2">* the start time for the item, or undefined if ttls are not used.</span><span class="s4">\n     </span><span class="s2">*/</span><span class="s4">\n    </span><span class="s2">start?: Milliseconds</span><span class="s4">\n\n    </span><span class="s2">/**</span><span class="s4">\n     </span><span class="s2">* The timestamp used for TTL calculation</span><span class="s4">\n     </span><span class="s2">*/</span><span class="s4">\n    </span><span class="s2">now?: Milliseconds</span><span class="s4">\n\n    </span><span class="s2">/**</span><span class="s4">\n     </span><span class="s2">* the remaining ttl for the item, or undefined if ttls are not used.</span><span class="s4">\n     </span><span class="s2">*/</span><span class="s4">\n    </span><span class="s2">remainingTTL?: Milliseconds</span><span class="s4">\n\n    </span><span class="s2">/**</span><span class="s4">\n     </span><span class="s2">* The calculated size for the item, if sizes are used.</span><span class="s4">\n     </span><span class="s2">*/</span><span class="s4">\n    </span><span class="s2">entrySize?: Size</span><span class="s4">\n\n    </span><span class="s2">/**</span><span class="s4">\n     </span><span class="s2">* The total calculated size of the cache, if sizes are used.</span><span class="s4">\n     </span><span class="s2">*/</span><span class="s4">\n    </span><span class="s2">totalCalculatedSize?: Size</span><span class="s4">\n\n    </span><span class="s2">/**</span><span class="s4">\n     </span><span class="s2">* A flag indicating that the item was not stored, due to exceeding the</span><span class="s4">\n     </span><span class="s2">* {@link OptionsBase.maxEntrySize}</span><span class="s4">\n     </span><span class="s2">*/</span><span class="s4">\n    </span><span class="s2">maxEntrySizeExceeded?: true</span><span class="s4">\n\n    </span><span class="s2">/**</span><span class="s4">\n     </span><span class="s2">* The old value, specified in the case of `set:'update'` or</span><span class="s4">\n     </span><span class="s2">* `set:'replace'`</span><span class="s4">\n     </span><span class="s2">*/</span><span class="s4">\n    </span><span class="s2">oldValue?: V</span><span class="s4">\n\n    </span><span class="s2">/**</span><span class="s4">\n     </span><span class="s2">* The results of a {@link LRUCache#has} operation</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* - hit: the item was found in the cache</span><span class="s4">\n     </span><span class="s2">* - stale: the item was found in the cache, but is stale</span><span class="s4">\n     </span><span class="s2">* - miss: the item was not found in the cache</span><span class="s4">\n     </span><span class="s2">*/</span><span class="s4">\n    </span><span class="s2">has?: 'hit' | 'stale' | 'miss'</span><span class="s4">\n\n    </span><span class="s2">/**</span><span class="s4">\n     </span><span class="s2">* The status of a {@link LRUCache#fetch} operation.</span><span class="s4">\n     </span><span class="s2">* Note that this can change as the underlying fetch() moves through</span><span class="s4">\n     </span><span class="s2">* various states.</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* - inflight: there is another fetch() for this key which is in process</span><span class="s4">\n     </span><span class="s2">* - get: there is no {@link OptionsBase.fetchMethod}, so</span><span class="s4">\n     </span><span class="s2">*   {@link LRUCache#get} was called.</span><span class="s4">\n     </span><span class="s2">* - miss: the item is not in cache, and will be fetched.</span><span class="s4">\n     </span><span class="s2">* - hit: the item is in the cache, and was resolved immediately.</span><span class="s4">\n     </span><span class="s2">* - stale: the item is in the cache, but stale.</span><span class="s4">\n     </span><span class="s2">* - refresh: the item is in the cache, and not stale, but</span><span class="s4">\n     </span><span class="s2">*   {@link FetchOptions.forceRefresh} was specified.</span><span class="s4">\n     </span><span class="s2">*/</span><span class="s4">\n    </span><span class="s2">fetch?: 'get' | 'inflight' | 'miss' | 'hit' | 'stale' | 'refresh'</span><span class="s4">\n\n    </span><span class="s2">/**</span><span class="s4">\n     </span><span class="s2">* The {@link OptionsBase.fetchMethod} was called</span><span class="s4">\n     </span><span class="s2">*/</span><span class="s4">\n    </span><span class="s2">fetchDispatched?: true</span><span class="s4">\n\n    </span><span class="s2">/**</span><span class="s4">\n     </span><span class="s2">* The cached value was updated after a successful call to</span><span class="s4">\n     </span><span class="s2">* {@link OptionsBase.fetchMethod}</span><span class="s4">\n     </span><span class="s2">*/</span><span class="s4">\n    </span><span class="s2">fetchUpdated?: true</span><span class="s4">\n\n    </span><span class="s2">/**</span><span class="s4">\n     </span><span class="s2">* The reason for a fetch() rejection.  Either the error raised by the</span><span class="s4">\n     </span><span class="s2">* {@link OptionsBase.fetchMethod}, or the reason for an</span><span class="s4">\n     </span><span class="s2">* AbortSignal.</span><span class="s4">\n     </span><span class="s2">*/</span><span class="s4">\n    </span><span class="s2">fetchError?: Error</span><span class="s4">\n\n    </span><span class="s2">/**</span><span class="s4">\n     </span><span class="s2">* The fetch received an abort signal</span><span class="s4">\n     </span><span class="s2">*/</span><span class="s4">\n    </span><span class="s2">fetchAborted?: true</span><span class="s4">\n\n    </span><span class="s2">/**</span><span class="s4">\n     </span><span class="s2">* The abort signal received was ignored, and the fetch was allowed to</span><span class="s4">\n     </span><span class="s2">* continue.</span><span class="s4">\n     </span><span class="s2">*/</span><span class="s4">\n    </span><span class="s2">fetchAbortIgnored?: true</span><span class="s4">\n\n    </span><span class="s2">/**</span><span class="s4">\n     </span><span class="s2">* The fetchMethod promise resolved successfully</span><span class="s4">\n     </span><span class="s2">*/</span><span class="s4">\n    </span><span class="s2">fetchResolved?: true</span><span class="s4">\n\n    </span><span class="s2">/**</span><span class="s4">\n     </span><span class="s2">* The fetchMethod promise was rejected</span><span class="s4">\n     </span><span class="s2">*/</span><span class="s4">\n    </span><span class="s2">fetchRejected?: true</span><span class="s4">\n\n    </span><span class="s2">/**</span><span class="s4">\n     </span><span class="s2">* The status of a {@link LRUCache#get} operation.</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* - fetching: The item is currently being fetched.  If a previous value</span><span class="s4">\n     </span><span class="s2">*   is present and allowed, that will be returned.</span><span class="s4">\n     </span><span class="s2">* - stale: The item is in the cache, and is stale.</span><span class="s4">\n     </span><span class="s2">* - hit: the item is in the cache</span><span class="s4">\n     </span><span class="s2">* - miss: the item is not in the cache</span><span class="s4">\n     </span><span class="s2">*/</span><span class="s4">\n    </span><span class="s2">get?: 'stale' | 'hit' | 'miss'</span><span class="s4">\n\n    </span><span class="s2">/**</span><span class="s4">\n     </span><span class="s2">* A fetch or get operation returned a stale value.</span><span class="s4">\n     </span><span class="s2">*/</span><span class="s4">\n    </span><span class="s2">returnedStale?: true</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* options which override the options set in the LRUCache constructor</span><span class="s4">\n   </span><span class="s2">* when calling {@link LRUCache#fetch}.</span><span class="s4">\n   </span><span class="s2">*</span><span class="s4">\n   </span><span class="s2">* This is the union of {@link GetOptions} and {@link SetOptions}, plus</span><span class="s4">\n   </span><span class="s2">* {@link OptionsBase.noDeleteOnFetchRejection},</span><span class="s4">\n   </span><span class="s2">* {@link OptionsBase.allowStaleOnFetchRejection},</span><span class="s4">\n   </span><span class="s2">* {@link FetchOptions.forceRefresh}, and</span><span class="s4">\n   </span><span class="s2">* {@link FetcherOptions.context}</span><span class="s4">\n   </span><span class="s2">*</span><span class="s4">\n   </span><span class="s2">* Any of these may be modified in the {@link OptionsBase.fetchMethod}</span><span class="s4">\n   </span><span class="s2">* function, but the {@link GetOptions} fields will of course have no</span><span class="s4">\n   </span><span class="s2">* effect, as the {@link LRUCache#get} call already happened by the time</span><span class="s4">\n   </span><span class="s2">* the fetchMethod is called.</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">export interface FetcherFetchOptions&lt;K, V, FC = unknown&gt;</span><span class="s4">\n    </span><span class="s2">extends Pick&lt;</span><span class="s4">\n      </span><span class="s2">OptionsBase&lt;K, V, FC&gt;,</span><span class="s4">\n      </span><span class="s2">| 'allowStale'</span><span class="s4">\n      </span><span class="s2">| 'updateAgeOnGet'</span><span class="s4">\n      </span><span class="s2">| 'noDeleteOnStaleGet'</span><span class="s4">\n      </span><span class="s2">| 'sizeCalculation'</span><span class="s4">\n      </span><span class="s2">| 'ttl'</span><span class="s4">\n      </span><span class="s2">| 'noDisposeOnSet'</span><span class="s4">\n      </span><span class="s2">| 'noUpdateTTL'</span><span class="s4">\n      </span><span class="s2">| 'noDeleteOnFetchRejection'</span><span class="s4">\n      </span><span class="s2">| 'allowStaleOnFetchRejection'</span><span class="s4">\n      </span><span class="s2">| 'ignoreFetchAbort'</span><span class="s4">\n      </span><span class="s2">| 'allowStaleOnFetchAbort'</span><span class="s4">\n    </span><span class="s2">&gt; {</span><span class="s4">\n    </span><span class="s2">status?: Status&lt;V&gt;</span><span class="s4">\n    </span><span class="s2">size?: Size</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* Options that may be passed to the {@link LRUCache#fetch} method.</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">export interface FetchOptions&lt;K, V, FC&gt;</span><span class="s4">\n    </span><span class="s2">extends FetcherFetchOptions&lt;K, V, FC&gt; {</span><span class="s4">\n    </span><span class="s2">/**</span><span class="s4">\n     </span><span class="s2">* Set to true to force a re-load of the existing data, even if it</span><span class="s4">\n     </span><span class="s2">* is not yet stale.</span><span class="s4">\n     </span><span class="s2">*/</span><span class="s4">\n    </span><span class="s2">forceRefresh?: boolean</span><span class="s4">\n    </span><span class="s2">/**</span><span class="s4">\n     </span><span class="s2">* Context provided to the {@link OptionsBase.fetchMethod} as</span><span class="s4">\n     </span><span class="s2">* the {@link FetcherOptions.context} param.</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* If the FC type is specified as unknown (the default),</span><span class="s4">\n     </span><span class="s2">* undefined or void, then this is optional.  Otherwise, it will</span><span class="s4">\n     </span><span class="s2">* be required.</span><span class="s4">\n     </span><span class="s2">*/</span><span class="s4">\n    </span><span class="s2">context?: FC</span><span class="s4">\n    </span><span class="s2">signal?: AbortSignal</span><span class="s4">\n    </span><span class="s2">status?: Status&lt;V&gt;</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* Options provided to {@link LRUCache#fetch} when the FC type is something</span><span class="s4">\n   </span><span class="s2">* other than `unknown`, `undefined`, or `void`</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">export interface FetchOptionsWithContext&lt;K, V, FC&gt;</span><span class="s4">\n    </span><span class="s2">extends FetchOptions&lt;K, V, FC&gt; {</span><span class="s4">\n    </span><span class="s2">context: FC</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* Options provided to {@link LRUCache#fetch} when the FC type is</span><span class="s4">\n   </span><span class="s2">* `undefined` or `void`</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">export interface FetchOptionsNoContext&lt;K, V&gt;</span><span class="s4">\n    </span><span class="s2">extends FetchOptions&lt;K, V, undefined&gt; {</span><span class="s4">\n    </span><span class="s2">context?: undefined</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n\n  </span><span class="s2">export interface MemoOptions&lt;K, V, FC = unknown&gt;</span><span class="s4">\n    </span><span class="s2">extends Pick&lt;</span><span class="s4">\n      </span><span class="s2">OptionsBase&lt;K, V, FC&gt;,</span><span class="s4">\n      </span><span class="s2">| 'allowStale'</span><span class="s4">\n      </span><span class="s2">| 'updateAgeOnGet'</span><span class="s4">\n      </span><span class="s2">| 'noDeleteOnStaleGet'</span><span class="s4">\n      </span><span class="s2">| 'sizeCalculation'</span><span class="s4">\n      </span><span class="s2">| 'ttl'</span><span class="s4">\n      </span><span class="s2">| 'noDisposeOnSet'</span><span class="s4">\n      </span><span class="s2">| 'noUpdateTTL'</span><span class="s4">\n      </span><span class="s2">| 'noDeleteOnFetchRejection'</span><span class="s4">\n      </span><span class="s2">| 'allowStaleOnFetchRejection'</span><span class="s4">\n      </span><span class="s2">| 'ignoreFetchAbort'</span><span class="s4">\n      </span><span class="s2">| 'allowStaleOnFetchAbort'</span><span class="s4">\n    </span><span class="s2">&gt; {</span><span class="s4">\n    </span><span class="s2">/**</span><span class="s4">\n     </span><span class="s2">* Set to true to force a re-load of the existing data, even if it</span><span class="s4">\n     </span><span class="s2">* is not yet stale.</span><span class="s4">\n     </span><span class="s2">*/</span><span class="s4">\n    </span><span class="s2">forceRefresh?: boolean</span><span class="s4">\n    </span><span class="s2">/**</span><span class="s4">\n     </span><span class="s2">* Context provided to the {@link OptionsBase.memoMethod} as</span><span class="s4">\n     </span><span class="s2">* the {@link MemoizerOptions.context} param.</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* If the FC type is specified as unknown (the default),</span><span class="s4">\n     </span><span class="s2">* undefined or void, then this is optional.  Otherwise, it will</span><span class="s4">\n     </span><span class="s2">* be required.</span><span class="s4">\n     </span><span class="s2">*/</span><span class="s4">\n    </span><span class="s2">context?: FC</span><span class="s4">\n    </span><span class="s2">status?: Status&lt;V&gt;</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* Options provided to {@link LRUCache#memo} when the FC type is something</span><span class="s4">\n   </span><span class="s2">* other than `unknown`, `undefined`, or `void`</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">export interface MemoOptionsWithContext&lt;K, V, FC&gt;</span><span class="s4">\n    </span><span class="s2">extends MemoOptions&lt;K, V, FC&gt; {</span><span class="s4">\n    </span><span class="s2">context: FC</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* Options provided to {@link LRUCache#memo} when the FC type is</span><span class="s4">\n   </span><span class="s2">* `undefined` or `void`</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">export interface MemoOptionsNoContext&lt;K, V&gt;</span><span class="s4">\n    </span><span class="s2">extends MemoOptions&lt;K, V, undefined&gt; {</span><span class="s4">\n    </span><span class="s2">context?: undefined</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* Options provided to the</span><span class="s4">\n   </span><span class="s2">* {@link OptionsBase.memoMethod} function.</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">export interface MemoizerOptions&lt;K, V, FC = unknown&gt; {</span><span class="s4">\n    </span><span class="s2">options: MemoizerMemoOptions&lt;K, V, FC&gt;</span><span class="s4">\n    </span><span class="s2">/**</span><span class="s4">\n     </span><span class="s2">* Object provided in the {@link MemoOptions.context} option to</span><span class="s4">\n     </span><span class="s2">* {@link LRUCache#memo}</span><span class="s4">\n     </span><span class="s2">*/</span><span class="s4">\n    </span><span class="s2">context: FC</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* options which override the options set in the LRUCache constructor</span><span class="s4">\n   </span><span class="s2">* when calling {@link LRUCache#memo}.</span><span class="s4">\n   </span><span class="s2">*</span><span class="s4">\n   </span><span class="s2">* This is the union of {@link GetOptions} and {@link SetOptions}, plus</span><span class="s4">\n   </span><span class="s2">* {@link MemoOptions.forceRefresh}, and</span><span class="s4">\n   </span><span class="s2">* {@link MemoerOptions.context}</span><span class="s4">\n   </span><span class="s2">*</span><span class="s4">\n   </span><span class="s2">* Any of these may be modified in the {@link OptionsBase.memoMethod}</span><span class="s4">\n   </span><span class="s2">* function, but the {@link GetOptions} fields will of course have no</span><span class="s4">\n   </span><span class="s2">* effect, as the {@link LRUCache#get} call already happened by the time</span><span class="s4">\n   </span><span class="s2">* the memoMethod is called.</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">export interface MemoizerMemoOptions&lt;K, V, FC = unknown&gt;</span><span class="s4">\n    </span><span class="s2">extends Pick&lt;</span><span class="s4">\n      </span><span class="s2">OptionsBase&lt;K, V, FC&gt;,</span><span class="s4">\n      </span><span class="s2">| 'allowStale'</span><span class="s4">\n      </span><span class="s2">| 'updateAgeOnGet'</span><span class="s4">\n      </span><span class="s2">| 'noDeleteOnStaleGet'</span><span class="s4">\n      </span><span class="s2">| 'sizeCalculation'</span><span class="s4">\n      </span><span class="s2">| 'ttl'</span><span class="s4">\n      </span><span class="s2">| 'noDisposeOnSet'</span><span class="s4">\n      </span><span class="s2">| 'noUpdateTTL'</span><span class="s4">\n    </span><span class="s2">&gt; {</span><span class="s4">\n    </span><span class="s2">status?: Status&lt;V&gt;</span><span class="s4">\n    </span><span class="s2">size?: Size</span><span class="s4">\n    </span><span class="s2">start?: Milliseconds</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* Options that may be passed to the {@link LRUCache#has} method.</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">export interface HasOptions&lt;K, V, FC&gt;</span><span class="s4">\n    </span><span class="s2">extends Pick&lt;OptionsBase&lt;K, V, FC&gt;, 'updateAgeOnHas'&gt; {</span><span class="s4">\n    </span><span class="s2">status?: Status&lt;V&gt;</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* Options that may be passed to the {@link LRUCache#get} method.</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">export interface GetOptions&lt;K, V, FC&gt;</span><span class="s4">\n    </span><span class="s2">extends Pick&lt;</span><span class="s4">\n      </span><span class="s2">OptionsBase&lt;K, V, FC&gt;,</span><span class="s4">\n      </span><span class="s2">'allowStale' | 'updateAgeOnGet' | 'noDeleteOnStaleGet'</span><span class="s4">\n    </span><span class="s2">&gt; {</span><span class="s4">\n    </span><span class="s2">status?: Status&lt;V&gt;</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* Options that may be passed to the {@link LRUCache#peek} method.</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">export interface PeekOptions&lt;K, V, FC&gt;</span><span class="s4">\n    </span><span class="s2">extends Pick&lt;OptionsBase&lt;K, V, FC&gt;, 'allowStale'&gt; {}</span><span class="s4">\n\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* Options that may be passed to the {@link LRUCache#set} method.</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">export interface SetOptions&lt;K, V, FC&gt;</span><span class="s4">\n    </span><span class="s2">extends Pick&lt;</span><span class="s4">\n      </span><span class="s2">OptionsBase&lt;K, V, FC&gt;,</span><span class="s4">\n      </span><span class="s2">'sizeCalculation' | 'ttl' | 'noDisposeOnSet' | 'noUpdateTTL'</span><span class="s4">\n    </span><span class="s2">&gt; {</span><span class="s4">\n    </span><span class="s2">/**</span><span class="s4">\n     </span><span class="s2">* If size tracking is enabled, then setting an explicit size</span><span class="s4">\n     </span><span class="s2">* in the {@link LRUCache#set} call will prevent calling the</span><span class="s4">\n     </span><span class="s2">* {@link OptionsBase.sizeCalculation} function.</span><span class="s4">\n     </span><span class="s2">*/</span><span class="s4">\n    </span><span class="s2">size?: Size</span><span class="s4">\n    </span><span class="s2">/**</span><span class="s4">\n     </span><span class="s2">* If TTL tracking is enabled, then setting an explicit start</span><span class="s4">\n     </span><span class="s2">* time in the {@link LRUCache#set} call will override the</span><span class="s4">\n     </span><span class="s2">* default time from `performance.now()` or `Date.now()`.</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* Note that it must be a valid value for whichever time-tracking</span><span class="s4">\n     </span><span class="s2">* method is in use.</span><span class="s4">\n     </span><span class="s2">*/</span><span class="s4">\n    </span><span class="s2">start?: Milliseconds</span><span class="s4">\n    </span><span class="s2">status?: Status&lt;V&gt;</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* The type signature for the {@link OptionsBase.fetchMethod} option.</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">export type Fetcher&lt;K, V, FC = unknown&gt; = (</span><span class="s4">\n    </span><span class="s2">key: K,</span><span class="s4">\n    </span><span class="s2">staleValue: V | undefined,</span><span class="s4">\n    </span><span class="s2">options: FetcherOptions&lt;K, V, FC&gt;</span><span class="s4">\n  </span><span class="s2">) =&gt; Promise&lt;V | undefined | void&gt; | V | undefined | void</span><span class="s4">\n\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* the type signature for the {@link OptionsBase.memoMethod} option.</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">export type Memoizer&lt;K, V, FC = unknown&gt; = (</span><span class="s4">\n    </span><span class="s2">key: K,</span><span class="s4">\n    </span><span class="s2">staleValue: V | undefined,</span><span class="s4">\n    </span><span class="s2">options: MemoizerOptions&lt;K, V, FC&gt;</span><span class="s4">\n  </span><span class="s2">) =&gt; V</span><span class="s4">\n\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* Options which may be passed to the {@link LRUCache} constructor.</span><span class="s4">\n   </span><span class="s2">*</span><span class="s4">\n   </span><span class="s2">* Most of these may be overridden in the various options that use</span><span class="s4">\n   </span><span class="s2">* them.</span><span class="s4">\n   </span><span class="s2">*</span><span class="s4">\n   </span><span class="s2">* Despite all being technically optional, the constructor requires that</span><span class="s4">\n   </span><span class="s2">* a cache is at minimum limited by one or more of {@link OptionsBase.max},</span><span class="s4">\n   </span><span class="s2">* {@link OptionsBase.ttl}, or {@link OptionsBase.maxSize}.</span><span class="s4">\n   </span><span class="s2">*</span><span class="s4">\n   </span><span class="s2">* If {@link OptionsBase.ttl} is used alone, then it is strongly advised</span><span class="s4">\n   </span><span class="s2">* (and in fact required by the type definitions here) that the cache</span><span class="s4">\n   </span><span class="s2">* also set {@link OptionsBase.ttlAutopurge}, to prevent potentially</span><span class="s4">\n   </span><span class="s2">* unbounded storage.</span><span class="s4">\n   </span><span class="s2">*</span><span class="s4">\n   </span><span class="s2">* All options are also available on the {@link LRUCache} instance, making</span><span class="s4">\n   </span><span class="s2">* it safe to pass an LRUCache instance as the options argumemnt to</span><span class="s4">\n   </span><span class="s2">* make another empty cache of the same type.</span><span class="s4">\n   </span><span class="s2">*</span><span class="s4">\n   </span><span class="s2">* Some options are marked as read-only, because changing them after</span><span class="s4">\n   </span><span class="s2">* instantiation is not safe. Changing any of the other options will of</span><span class="s4">\n   </span><span class="s2">* course only have an effect on subsequent method calls.</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">export interface OptionsBase&lt;K, V, FC&gt; {</span><span class="s4">\n    </span><span class="s2">/**</span><span class="s4">\n     </span><span class="s2">* The maximum number of items to store in the cache before evicting</span><span class="s4">\n     </span><span class="s2">* old entries. This is read-only on the {@link LRUCache} instance,</span><span class="s4">\n     </span><span class="s2">* and may not be overridden.</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* If set, then storage space will be pre-allocated at construction</span><span class="s4">\n     </span><span class="s2">* time, and the cache will perform significantly faster.</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* Note that significantly fewer items may be stored, if</span><span class="s4">\n     </span><span class="s2">* {@link OptionsBase.maxSize} and/or {@link OptionsBase.ttl} are also</span><span class="s4">\n     </span><span class="s2">* set.</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* **It is strongly recommended to set a `max` to prevent unbounded growth</span><span class="s4">\n     </span><span class="s2">* of the cache.**</span><span class="s4">\n     </span><span class="s2">*/</span><span class="s4">\n    </span><span class="s2">max?: Count</span><span class="s4">\n\n    </span><span class="s2">/**</span><span class="s4">\n     </span><span class="s2">* Max time in milliseconds for items to live in cache before they are</span><span class="s4">\n     </span><span class="s2">* considered stale.  Note that stale items are NOT preemptively removed by</span><span class="s4">\n     </span><span class="s2">* default, and MAY live in the cache, contributing to its LRU max, long</span><span class="s4">\n     </span><span class="s2">* after they have expired, unless {@link OptionsBase.ttlAutopurge} is</span><span class="s4">\n     </span><span class="s2">* set.</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* If set to `0` (the default value), then that means </span><span class="s4">\&quot;</span><span class="s2">do not track</span><span class="s4">\n     </span><span class="s2">* TTL</span><span class="s4">\&quot;</span><span class="s2">, not </span><span class="s4">\&quot;</span><span class="s2">expire immediately</span><span class="s4">\&quot;</span><span class="s2">.</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* Also, as this cache is optimized for LRU/MRU operations, some of</span><span class="s4">\n     </span><span class="s2">* the staleness/TTL checks will reduce performance, as they will incur</span><span class="s4">\n     </span><span class="s2">* overhead by deleting items.</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* This is not primarily a TTL cache, and does not make strong TTL</span><span class="s4">\n     </span><span class="s2">* guarantees. There is no pre-emptive pruning of expired items, but you</span><span class="s4">\n     </span><span class="s2">* _may_ set a TTL on the cache, and it will treat expired items as missing</span><span class="s4">\n     </span><span class="s2">* when they are fetched, and delete them.</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* Optional, but must be a non-negative integer in ms if specified.</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* This may be overridden by passing an options object to `cache.set()`.</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* At least one of `max`, `maxSize`, or `TTL` is required. This must be a</span><span class="s4">\n     </span><span class="s2">* positive integer if set.</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* Even if ttl tracking is enabled, **it is strongly recommended to set a</span><span class="s4">\n     </span><span class="s2">* `max` to prevent unbounded growth of the cache.**</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* If ttl tracking is enabled, and `max` and `maxSize` are not set,</span><span class="s4">\n     </span><span class="s2">* and `ttlAutopurge` is not set, then a warning will be emitted</span><span class="s4">\n     </span><span class="s2">* cautioning about the potential for unbounded memory consumption.</span><span class="s4">\n     </span><span class="s2">* (The TypeScript definitions will also discourage this.)</span><span class="s4">\n     </span><span class="s2">*/</span><span class="s4">\n    </span><span class="s2">ttl?: Milliseconds</span><span class="s4">\n\n    </span><span class="s2">/**</span><span class="s4">\n     </span><span class="s2">* Minimum amount of time in ms in which to check for staleness.</span><span class="s4">\n     </span><span class="s2">* Defaults to 1, which means that the current time is checked</span><span class="s4">\n     </span><span class="s2">* at most once per millisecond.</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* Set to 0 to check the current time every time staleness is tested.</span><span class="s4">\n     </span><span class="s2">* (This reduces performance, and is theoretically unnecessary.)</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* Setting this to a higher value will improve performance somewhat</span><span class="s4">\n     </span><span class="s2">* while using ttl tracking, albeit at the expense of keeping stale</span><span class="s4">\n     </span><span class="s2">* items around a bit longer than their TTLs would indicate.</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* @default 1</span><span class="s4">\n     </span><span class="s2">*/</span><span class="s4">\n    </span><span class="s2">ttlResolution?: Milliseconds</span><span class="s4">\n\n    </span><span class="s2">/**</span><span class="s4">\n     </span><span class="s2">* Preemptively remove stale items from the cache.</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* Note that this may *significantly* degrade performance, especially if</span><span class="s4">\n     </span><span class="s2">* the cache is storing a large number of items. It is almost always best</span><span class="s4">\n     </span><span class="s2">* to just leave the stale items in the cache, and let them fall out as new</span><span class="s4">\n     </span><span class="s2">* items are added.</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* Note that this means that {@link OptionsBase.allowStale} is a bit</span><span class="s4">\n     </span><span class="s2">* pointless, as stale items will be deleted almost as soon as they</span><span class="s4">\n     </span><span class="s2">* expire.</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* Use with caution!</span><span class="s4">\n     </span><span class="s2">*/</span><span class="s4">\n    </span><span class="s2">ttlAutopurge?: boolean</span><span class="s4">\n\n    </span><span class="s2">/**</span><span class="s4">\n     </span><span class="s2">* When using time-expiring entries with `ttl`, setting this to `true` will</span><span class="s4">\n     </span><span class="s2">* make each item's age reset to 0 whenever it is retrieved from cache with</span><span class="s4">\n     </span><span class="s2">* {@link LRUCache#get}, causing it to not expire. (It can still fall out</span><span class="s4">\n     </span><span class="s2">* of cache based on recency of use, of course.)</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* Has no effect if {@link OptionsBase.ttl} is not set.</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* This may be overridden by passing an options object to `cache.get()`.</span><span class="s4">\n     </span><span class="s2">*/</span><span class="s4">\n    </span><span class="s2">updateAgeOnGet?: boolean</span><span class="s4">\n\n    </span><span class="s2">/**</span><span class="s4">\n     </span><span class="s2">* When using time-expiring entries with `ttl`, setting this to `true` will</span><span class="s4">\n     </span><span class="s2">* make each item's age reset to 0 whenever its presence in the cache is</span><span class="s4">\n     </span><span class="s2">* checked with {@link LRUCache#has}, causing it to not expire. (It can</span><span class="s4">\n     </span><span class="s2">* still fall out of cache based on recency of use, of course.)</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* Has no effect if {@link OptionsBase.ttl} is not set.</span><span class="s4">\n     </span><span class="s2">*/</span><span class="s4">\n    </span><span class="s2">updateAgeOnHas?: boolean</span><span class="s4">\n\n    </span><span class="s2">/**</span><span class="s4">\n     </span><span class="s2">* Allow {@link LRUCache#get} and {@link LRUCache#fetch} calls to return</span><span class="s4">\n     </span><span class="s2">* stale data, if available.</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* By default, if you set `ttl`, stale items will only be deleted from the</span><span class="s4">\n     </span><span class="s2">* cache when you `get(key)`. That is, it's not preemptively pruning items,</span><span class="s4">\n     </span><span class="s2">* unless {@link OptionsBase.ttlAutopurge} is set.</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* If you set `allowStale:true`, it'll return the stale value *as well as*</span><span class="s4">\n     </span><span class="s2">* deleting it. If you don't set this, then it'll return `undefined` when</span><span class="s4">\n     </span><span class="s2">* you try to get a stale entry.</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* Note that when a stale entry is fetched, _even if it is returned due to</span><span class="s4">\n     </span><span class="s2">* `allowStale` being set_, it is removed from the cache immediately. You</span><span class="s4">\n     </span><span class="s2">* can suppress this behavior by setting</span><span class="s4">\n     </span><span class="s2">* {@link OptionsBase.noDeleteOnStaleGet}, either in the constructor, or in</span><span class="s4">\n     </span><span class="s2">* the options provided to {@link LRUCache#get}.</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* This may be overridden by passing an options object to `cache.get()`.</span><span class="s4">\n     </span><span class="s2">* The `cache.has()` method will always return `false` for stale items.</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* Only relevant if a ttl is set.</span><span class="s4">\n     </span><span class="s2">*/</span><span class="s4">\n    </span><span class="s2">allowStale?: boolean</span><span class="s4">\n\n    </span><span class="s2">/**</span><span class="s4">\n     </span><span class="s2">* Function that is called on items when they are dropped from the</span><span class="s4">\n     </span><span class="s2">* cache, as `dispose(value, key, reason)`.</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* This can be handy if you want to close file descriptors or do</span><span class="s4">\n     </span><span class="s2">* other cleanup tasks when items are no longer stored in the cache.</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* **NOTE**: It is called _before_ the item has been fully removed</span><span class="s4">\n     </span><span class="s2">* from the cache, so if you want to put it right back in, you need</span><span class="s4">\n     </span><span class="s2">* to wait until the next tick. If you try to add it back in during</span><span class="s4">\n     </span><span class="s2">* the `dispose()` function call, it will break things in subtle and</span><span class="s4">\n     </span><span class="s2">* weird ways.</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* Unlike several other options, this may _not_ be overridden by</span><span class="s4">\n     </span><span class="s2">* passing an option to `set()`, for performance reasons.</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* The `reason` will be one of the following strings, corresponding</span><span class="s4">\n     </span><span class="s2">* to the reason for the item's deletion:</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* - `evict` Item was evicted to make space for a new addition</span><span class="s4">\n     </span><span class="s2">* - `set` Item was overwritten by a new value</span><span class="s4">\n     </span><span class="s2">* - `expire` Item expired its TTL</span><span class="s4">\n     </span><span class="s2">* - `fetch` Item was deleted due to a failed or aborted fetch, or a</span><span class="s4">\n     </span><span class="s2">*   fetchMethod returning `undefined.</span><span class="s4">\n     </span><span class="s2">* - `delete` Item was removed by explicit `cache.delete(key)`,</span><span class="s4">\n     </span><span class="s2">*   `cache.clear()`, or `cache.set(key, undefined)`.</span><span class="s4">\n     </span><span class="s2">*/</span><span class="s4">\n    </span><span class="s2">dispose?: Disposer&lt;K, V&gt;</span><span class="s4">\n\n    </span><span class="s2">/**</span><span class="s4">\n     </span><span class="s2">* The same as {@link OptionsBase.dispose}, but called *after* the entry</span><span class="s4">\n     </span><span class="s2">* is completely removed and the cache is once again in a clean state.</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* It is safe to add an item right back into the cache at this point.</span><span class="s4">\n     </span><span class="s2">* However, note that it is *very* easy to inadvertently create infinite</span><span class="s4">\n     </span><span class="s2">* recursion this way.</span><span class="s4">\n     </span><span class="s2">*/</span><span class="s4">\n    </span><span class="s2">disposeAfter?: Disposer&lt;K, V&gt;</span><span class="s4">\n\n    </span><span class="s2">/**</span><span class="s4">\n     </span><span class="s2">* Set to true to suppress calling the</span><span class="s4">\n     </span><span class="s2">* {@link OptionsBase.dispose} function if the entry key is</span><span class="s4">\n     </span><span class="s2">* still accessible within the cache.</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* This may be overridden by passing an options object to</span><span class="s4">\n     </span><span class="s2">* {@link LRUCache#set}.</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* Only relevant if `dispose` or `disposeAfter` are set.</span><span class="s4">\n     </span><span class="s2">*/</span><span class="s4">\n    </span><span class="s2">noDisposeOnSet?: boolean</span><span class="s4">\n\n    </span><span class="s2">/**</span><span class="s4">\n     </span><span class="s2">* Boolean flag to tell the cache to not update the TTL when setting a new</span><span class="s4">\n     </span><span class="s2">* value for an existing key (ie, when updating a value rather than</span><span class="s4">\n     </span><span class="s2">* inserting a new value).  Note that the TTL value is _always_ set (if</span><span class="s4">\n     </span><span class="s2">* provided) when adding a new entry into the cache.</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* Has no effect if a {@link OptionsBase.ttl} is not set.</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* May be passed as an option to {@link LRUCache#set}.</span><span class="s4">\n     </span><span class="s2">*/</span><span class="s4">\n    </span><span class="s2">noUpdateTTL?: boolean</span><span class="s4">\n\n    </span><span class="s2">/**</span><span class="s4">\n     </span><span class="s2">* Set to a positive integer to track the sizes of items added to the</span><span class="s4">\n     </span><span class="s2">* cache, and automatically evict items in order to stay below this size.</span><span class="s4">\n     </span><span class="s2">* Note that this may result in fewer than `max` items being stored.</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* Attempting to add an item to the cache whose calculated size is greater</span><span class="s4">\n     </span><span class="s2">* that this amount will be a no-op. The item will not be cached, and no</span><span class="s4">\n     </span><span class="s2">* other items will be evicted.</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* Optional, must be a positive integer if provided.</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* Sets `maxEntrySize` to the same value, unless a different value is</span><span class="s4">\n     </span><span class="s2">* provided for `maxEntrySize`.</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* At least one of `max`, `maxSize`, or `TTL` is required. This must be a</span><span class="s4">\n     </span><span class="s2">* positive integer if set.</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* Even if size tracking is enabled, **it is strongly recommended to set a</span><span class="s4">\n     </span><span class="s2">* `max` to prevent unbounded growth of the cache.**</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* Note also that size tracking can negatively impact performance,</span><span class="s4">\n     </span><span class="s2">* though for most cases, only minimally.</span><span class="s4">\n     </span><span class="s2">*/</span><span class="s4">\n    </span><span class="s2">maxSize?: Size</span><span class="s4">\n\n    </span><span class="s2">/**</span><span class="s4">\n     </span><span class="s2">* The maximum allowed size for any single item in the cache.</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* If a larger item is passed to {@link LRUCache#set} or returned by a</span><span class="s4">\n     </span><span class="s2">* {@link OptionsBase.fetchMethod} or {@link OptionsBase.memoMethod}, then</span><span class="s4">\n     </span><span class="s2">* it will not be stored in the cache.</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* Attempting to add an item whose calculated size is greater than</span><span class="s4">\n     </span><span class="s2">* this amount will not cache the item or evict any old items, but</span><span class="s4">\n     </span><span class="s2">* WILL delete an existing value if one is already present.</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* Optional, must be a positive integer if provided. Defaults to</span><span class="s4">\n     </span><span class="s2">* the value of `maxSize` if provided.</span><span class="s4">\n     </span><span class="s2">*/</span><span class="s4">\n    </span><span class="s2">maxEntrySize?: Size</span><span class="s4">\n\n    </span><span class="s2">/**</span><span class="s4">\n     </span><span class="s2">* A function that returns a number indicating the item's size.</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* Requires {@link OptionsBase.maxSize} to be set.</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* If not provided, and {@link OptionsBase.maxSize} or</span><span class="s4">\n     </span><span class="s2">* {@link OptionsBase.maxEntrySize} are set, then all</span><span class="s4">\n     </span><span class="s2">* {@link LRUCache#set} calls **must** provide an explicit</span><span class="s4">\n     </span><span class="s2">* {@link SetOptions.size} or sizeCalculation param.</span><span class="s4">\n     </span><span class="s2">*/</span><span class="s4">\n    </span><span class="s2">sizeCalculation?: SizeCalculator&lt;K, V&gt;</span><span class="s4">\n\n    </span><span class="s2">/**</span><span class="s4">\n     </span><span class="s2">* Method that provides the implementation for {@link LRUCache#fetch}</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* ```ts</span><span class="s4">\n     </span><span class="s2">* fetchMethod(key, staleValue, { signal, options, context })</span><span class="s4">\n     </span><span class="s2">* ```</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* If `fetchMethod` is not provided, then `cache.fetch(key)` is equivalent</span><span class="s4">\n     </span><span class="s2">* to `Promise.resolve(cache.get(key))`.</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* If at any time, `signal.aborted` is set to `true`, or if the</span><span class="s4">\n     </span><span class="s2">* `signal.onabort` method is called, or if it emits an `'abort'` event</span><span class="s4">\n     </span><span class="s2">* which you can listen to with `addEventListener`, then that means that</span><span class="s4">\n     </span><span class="s2">* the fetch should be abandoned. This may be passed along to async</span><span class="s4">\n     </span><span class="s2">* functions aware of AbortController/AbortSignal behavior.</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* The `fetchMethod` should **only** return `undefined` or a Promise</span><span class="s4">\n     </span><span class="s2">* resolving to `undefined` if the AbortController signaled an `abort`</span><span class="s4">\n     </span><span class="s2">* event. In all other cases, it should return or resolve to a value</span><span class="s4">\n     </span><span class="s2">* suitable for adding to the cache.</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* The `options` object is a union of the options that may be provided to</span><span class="s4">\n     </span><span class="s2">* `set()` and `get()`. If they are modified, then that will result in</span><span class="s4">\n     </span><span class="s2">* modifying the settings to `cache.set()` when the value is resolved, and</span><span class="s4">\n     </span><span class="s2">* in the case of</span><span class="s4">\n     </span><span class="s2">* {@link OptionsBase.noDeleteOnFetchRejection} and</span><span class="s4">\n     </span><span class="s2">* {@link OptionsBase.allowStaleOnFetchRejection}, the handling of</span><span class="s4">\n     </span><span class="s2">* `fetchMethod` failures.</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* For example, a DNS cache may update the TTL based on the value returned</span><span class="s4">\n     </span><span class="s2">* from a remote DNS server by changing `options.ttl` in the `fetchMethod`.</span><span class="s4">\n     </span><span class="s2">*/</span><span class="s4">\n    </span><span class="s2">fetchMethod?: Fetcher&lt;K, V, FC&gt;</span><span class="s4">\n\n    </span><span class="s2">/**</span><span class="s4">\n     </span><span class="s2">* Method that provides the implementation for {@link LRUCache#memo}</span><span class="s4">\n     </span><span class="s2">*/</span><span class="s4">\n    </span><span class="s2">memoMethod?: Memoizer&lt;K, V, FC&gt;</span><span class="s4">\n\n    </span><span class="s2">/**</span><span class="s4">\n     </span><span class="s2">* Set to true to suppress the deletion of stale data when a</span><span class="s4">\n     </span><span class="s2">* {@link OptionsBase.fetchMethod} returns a rejected promise.</span><span class="s4">\n     </span><span class="s2">*/</span><span class="s4">\n    </span><span class="s2">noDeleteOnFetchRejection?: boolean</span><span class="s4">\n\n    </span><span class="s2">/**</span><span class="s4">\n     </span><span class="s2">* Do not delete stale items when they are retrieved with</span><span class="s4">\n     </span><span class="s2">* {@link LRUCache#get}.</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* Note that the `get` return value will still be `undefined`</span><span class="s4">\n     </span><span class="s2">* unless {@link OptionsBase.allowStale} is true.</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* When using time-expiring entries with `ttl`, by default stale</span><span class="s4">\n     </span><span class="s2">* items will be removed from the cache when the key is accessed</span><span class="s4">\n     </span><span class="s2">* with `cache.get()`.</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* Setting this option will cause stale items to remain in the cache, until</span><span class="s4">\n     </span><span class="s2">* they are explicitly deleted with `cache.delete(key)`, or retrieved with</span><span class="s4">\n     </span><span class="s2">* `noDeleteOnStaleGet` set to `false`.</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* This may be overridden by passing an options object to `cache.get()`.</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* Only relevant if a ttl is used.</span><span class="s4">\n     </span><span class="s2">*/</span><span class="s4">\n    </span><span class="s2">noDeleteOnStaleGet?: boolean</span><span class="s4">\n\n    </span><span class="s2">/**</span><span class="s4">\n     </span><span class="s2">* Set to true to allow returning stale data when a</span><span class="s4">\n     </span><span class="s2">* {@link OptionsBase.fetchMethod} throws an error or returns a rejected</span><span class="s4">\n     </span><span class="s2">* promise.</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* This differs from using {@link OptionsBase.allowStale} in that stale</span><span class="s4">\n     </span><span class="s2">* data will ONLY be returned in the case that the {@link LRUCache#fetch}</span><span class="s4">\n     </span><span class="s2">* fails, not any other times.</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* If a `fetchMethod` fails, and there is no stale value available, the</span><span class="s4">\n     </span><span class="s2">* `fetch()` will resolve to `undefined`. Ie, all `fetchMethod` errors are</span><span class="s4">\n     </span><span class="s2">* suppressed.</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* Implies `noDeleteOnFetchRejection`.</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* This may be set in calls to `fetch()`, or defaulted on the constructor,</span><span class="s4">\n     </span><span class="s2">* or overridden by modifying the options object in the `fetchMethod`.</span><span class="s4">\n     </span><span class="s2">*/</span><span class="s4">\n    </span><span class="s2">allowStaleOnFetchRejection?: boolean</span><span class="s4">\n\n    </span><span class="s2">/**</span><span class="s4">\n     </span><span class="s2">* Set to true to return a stale value from the cache when the</span><span class="s4">\n     </span><span class="s2">* `AbortSignal` passed to the {@link OptionsBase.fetchMethod} dispatches</span><span class="s4">\n     </span><span class="s2">* an `'abort'` event, whether user-triggered, or due to internal cache</span><span class="s4">\n     </span><span class="s2">* behavior.</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* Unless {@link OptionsBase.ignoreFetchAbort} is also set, the underlying</span><span class="s4">\n     </span><span class="s2">* {@link OptionsBase.fetchMethod} will still be considered canceled, and</span><span class="s4">\n     </span><span class="s2">* any value it returns will be ignored and not cached.</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* Caveat: since fetches are aborted when a new value is explicitly</span><span class="s4">\n     </span><span class="s2">* set in the cache, this can lead to fetch returning a stale value,</span><span class="s4">\n     </span><span class="s2">* since that was the fallback value _at the moment the `fetch()` was</span><span class="s4">\n     </span><span class="s2">* initiated_, even though the new updated value is now present in</span><span class="s4">\n     </span><span class="s2">* the cache.</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* For example:</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* ```ts</span><span class="s4">\n     </span><span class="s2">* const cache = new LRUCache&lt;string, any&gt;({</span><span class="s4">\n     </span><span class="s2">*   ttl: 100,</span><span class="s4">\n     </span><span class="s2">*   fetchMethod: async (url, oldValue, { signal }) =&gt;  {</span><span class="s4">\n     </span><span class="s2">*     const res = await fetch(url, { signal })</span><span class="s4">\n     </span><span class="s2">*     return await res.json()</span><span class="s4">\n     </span><span class="s2">*   }</span><span class="s4">\n     </span><span class="s2">* })</span><span class="s4">\n     </span><span class="s2">* cache.set('https://example.com/', { some: 'data' })</span><span class="s4">\n     </span><span class="s2">* // 100ms go by...</span><span class="s4">\n     </span><span class="s2">* const result = cache.fetch('https://example.com/')</span><span class="s4">\n     </span><span class="s2">* cache.set('https://example.com/', { other: 'thing' })</span><span class="s4">\n     </span><span class="s2">* console.log(await result) // { some: 'data' }</span><span class="s4">\n     </span><span class="s2">* console.log(cache.get('https://example.com/')) // { other: 'thing' }</span><span class="s4">\n     </span><span class="s2">* ```</span><span class="s4">\n     </span><span class="s2">*/</span><span class="s4">\n    </span><span class="s2">allowStaleOnFetchAbort?: boolean</span><span class="s4">\n\n    </span><span class="s2">/**</span><span class="s4">\n     </span><span class="s2">* Set to true to ignore the `abort` event emitted by the `AbortSignal`</span><span class="s4">\n     </span><span class="s2">* object passed to {@link OptionsBase.fetchMethod}, and still cache the</span><span class="s4">\n     </span><span class="s2">* resulting resolution value, as long as it is not `undefined`.</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* When used on its own, this means aborted {@link LRUCache#fetch} calls</span><span class="s4">\n     </span><span class="s2">* are not immediately resolved or rejected when they are aborted, and</span><span class="s4">\n     </span><span class="s2">* instead take the full time to await.</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* When used with {@link OptionsBase.allowStaleOnFetchAbort}, aborted</span><span class="s4">\n     </span><span class="s2">* {@link LRUCache#fetch} calls will resolve immediately to their stale</span><span class="s4">\n     </span><span class="s2">* cached value or `undefined`, and will continue to process and eventually</span><span class="s4">\n     </span><span class="s2">* update the cache when they resolve, as long as the resulting value is</span><span class="s4">\n     </span><span class="s2">* not `undefined`, thus supporting a </span><span class="s4">\&quot;</span><span class="s2">return stale on timeout while</span><span class="s4">\n     </span><span class="s2">* refreshing</span><span class="s4">\&quot; </span><span class="s2">mechanism by passing `AbortSignal.timeout(n)` as the signal.</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* For example:</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* ```ts</span><span class="s4">\n     </span><span class="s2">* const c = new LRUCache({</span><span class="s4">\n     </span><span class="s2">*   ttl: 100,</span><span class="s4">\n     </span><span class="s2">*   ignoreFetchAbort: true,</span><span class="s4">\n     </span><span class="s2">*   allowStaleOnFetchAbort: true,</span><span class="s4">\n     </span><span class="s2">*   fetchMethod: async (key, oldValue, { signal }) =&gt; {</span><span class="s4">\n     </span><span class="s2">*     // note: do NOT pass the signal to fetch()!</span><span class="s4">\n     </span><span class="s2">*     // let's say this fetch can take a long time.</span><span class="s4">\n     </span><span class="s2">*     const res = await fetch(`https://slow-backend-server/${key}`)</span><span class="s4">\n     </span><span class="s2">*     return await res.json()</span><span class="s4">\n     </span><span class="s2">*   },</span><span class="s4">\n     </span><span class="s2">* })</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* // this will return the stale value after 100ms, while still</span><span class="s4">\n     </span><span class="s2">* // updating in the background for next time.</span><span class="s4">\n     </span><span class="s2">* const val = await c.fetch('key', { signal: AbortSignal.timeout(100) })</span><span class="s4">\n     </span><span class="s2">* ```</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* **Note**: regardless of this setting, an `abort` event _is still</span><span class="s4">\n     </span><span class="s2">* emitted on the `AbortSignal` object_, so may result in invalid results</span><span class="s4">\n     </span><span class="s2">* when passed to other underlying APIs that use AbortSignals.</span><span class="s4">\n     </span><span class="s2">*</span><span class="s4">\n     </span><span class="s2">* This may be overridden in the {@link OptionsBase.fetchMethod} or the</span><span class="s4">\n     </span><span class="s2">* call to {@link LRUCache#fetch}.</span><span class="s4">\n     </span><span class="s2">*/</span><span class="s4">\n    </span><span class="s2">ignoreFetchAbort?: boolean</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n\n  </span><span class="s2">export interface OptionsMaxLimit&lt;K, V, FC&gt;</span><span class="s4">\n    </span><span class="s2">extends OptionsBase&lt;K, V, FC&gt; {</span><span class="s4">\n    </span><span class="s2">max: Count</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n  </span><span class="s2">export interface OptionsTTLLimit&lt;K, V, FC&gt;</span><span class="s4">\n    </span><span class="s2">extends OptionsBase&lt;K, V, FC&gt; {</span><span class="s4">\n    </span><span class="s2">ttl: Milliseconds</span><span class="s4">\n    </span><span class="s2">ttlAutopurge: boolean</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n  </span><span class="s2">export interface OptionsSizeLimit&lt;K, V, FC&gt;</span><span class="s4">\n    </span><span class="s2">extends OptionsBase&lt;K, V, FC&gt; {</span><span class="s4">\n    </span><span class="s2">maxSize: Size</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* The valid safe options for the {@link LRUCache} constructor</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">export type Options&lt;K, V, FC&gt; =</span><span class="s4">\n    </span><span class="s2">| OptionsMaxLimit&lt;K, V, FC&gt;</span><span class="s4">\n    </span><span class="s2">| OptionsSizeLimit&lt;K, V, FC&gt;</span><span class="s4">\n    </span><span class="s2">| OptionsTTLLimit&lt;K, V, FC&gt;</span><span class="s4">\n\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* Entry objects used by {@link LRUCache#load} and {@link LRUCache#dump},</span><span class="s4">\n   </span><span class="s2">* and returned by {@link LRUCache#info}.</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">export interface Entry&lt;V&gt; {</span><span class="s4">\n    </span><span class="s2">value: V</span><span class="s4">\n    </span><span class="s2">ttl?: Milliseconds</span><span class="s4">\n    </span><span class="s2">size?: Size</span><span class="s4">\n    </span><span class="s2">start?: Milliseconds</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n</span><span class="s2">}</span><span class="s4">\n\n</span><span class="s2">/**</span><span class="s4">\n </span><span class="s2">* Default export, the thing you're using this module to get.</span><span class="s4">\n </span><span class="s2">*</span><span class="s4">\n </span><span class="s2">* The `K` and `V` types define the key and value types, respectively. The</span><span class="s4">\n </span><span class="s2">* optional `FC` type defines the type of the `context` object passed to</span><span class="s4">\n </span><span class="s2">* `cache.fetch()` and `cache.memo()`.</span><span class="s4">\n </span><span class="s2">*</span><span class="s4">\n </span><span class="s2">* Keys and values **must not** be `null` or `undefined`.</span><span class="s4">\n </span><span class="s2">*</span><span class="s4">\n </span><span class="s2">* All properties from the options object (with the exception of `max`,</span><span class="s4">\n </span><span class="s2">* `maxSize`, `fetchMethod`, `memoMethod`, `dispose` and `disposeAfter`) are</span><span class="s4">\n </span><span class="s2">* added as normal public members. (The listed options are read-only getters.)</span><span class="s4">\n </span><span class="s2">*</span><span class="s4">\n </span><span class="s2">* Changing any of these will alter the defaults for subsequent method calls.</span><span class="s4">\n </span><span class="s2">*/</span><span class="s4">\n</span><span class="s2">export class LRUCache&lt;K extends {}, V extends {}, FC = unknown&gt;</span><span class="s4">\n  </span><span class="s2">implements Map&lt;K, V&gt;</span><span class="s4">\n</span><span class="s2">{</span><span class="s4">\n  </span><span class="s2">// options that cannot be changed without disaster</span><span class="s4">\n  </span><span class="s2">readonly #max: LRUCache.Count</span><span class="s4">\n  </span><span class="s2">readonly #maxSize: LRUCache.Size</span><span class="s4">\n  </span><span class="s2">readonly #dispose?: LRUCache.Disposer&lt;K, V&gt;</span><span class="s4">\n  </span><span class="s2">readonly #disposeAfter?: LRUCache.Disposer&lt;K, V&gt;</span><span class="s4">\n  </span><span class="s2">readonly #fetchMethod?: LRUCache.Fetcher&lt;K, V, FC&gt;</span><span class="s4">\n  </span><span class="s2">readonly #memoMethod?: LRUCache.Memoizer&lt;K, V, FC&gt;</span><span class="s4">\n\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* {@link LRUCache.OptionsBase.ttl}</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">ttl: LRUCache.Milliseconds</span><span class="s4">\n\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* {@link LRUCache.OptionsBase.ttlResolution}</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">ttlResolution: LRUCache.Milliseconds</span><span class="s4">\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* {@link LRUCache.OptionsBase.ttlAutopurge}</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">ttlAutopurge: boolean</span><span class="s4">\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* {@link LRUCache.OptionsBase.updateAgeOnGet}</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">updateAgeOnGet: boolean</span><span class="s4">\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* {@link LRUCache.OptionsBase.updateAgeOnHas}</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">updateAgeOnHas: boolean</span><span class="s4">\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* {@link LRUCache.OptionsBase.allowStale}</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">allowStale: boolean</span><span class="s4">\n\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* {@link LRUCache.OptionsBase.noDisposeOnSet}</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">noDisposeOnSet: boolean</span><span class="s4">\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* {@link LRUCache.OptionsBase.noUpdateTTL}</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">noUpdateTTL: boolean</span><span class="s4">\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* {@link LRUCache.OptionsBase.maxEntrySize}</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">maxEntrySize: LRUCache.Size</span><span class="s4">\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* {@link LRUCache.OptionsBase.sizeCalculation}</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">sizeCalculation?: LRUCache.SizeCalculator&lt;K, V&gt;</span><span class="s4">\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">noDeleteOnFetchRejection: boolean</span><span class="s4">\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* {@link LRUCache.OptionsBase.noDeleteOnStaleGet}</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">noDeleteOnStaleGet: boolean</span><span class="s4">\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">allowStaleOnFetchAbort: boolean</span><span class="s4">\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">allowStaleOnFetchRejection: boolean</span><span class="s4">\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* {@link LRUCache.OptionsBase.ignoreFetchAbort}</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">ignoreFetchAbort: boolean</span><span class="s4">\n\n  </span><span class="s2">// computed properties</span><span class="s4">\n  </span><span class="s2">#size: LRUCache.Count</span><span class="s4">\n  </span><span class="s2">#calculatedSize: LRUCache.Size</span><span class="s4">\n  </span><span class="s2">#keyMap: Map&lt;K, Index&gt;</span><span class="s4">\n  </span><span class="s2">#keyList: (K | undefined)[]</span><span class="s4">\n  </span><span class="s2">#valList: (V | BackgroundFetch&lt;V&gt; | undefined)[]</span><span class="s4">\n  </span><span class="s2">#next: NumberArray</span><span class="s4">\n  </span><span class="s2">#prev: NumberArray</span><span class="s4">\n  </span><span class="s2">#head: Index</span><span class="s4">\n  </span><span class="s2">#tail: Index</span><span class="s4">\n  </span><span class="s2">#free: StackLike</span><span class="s4">\n  </span><span class="s2">#disposed?: DisposeTask&lt;K, V&gt;[]</span><span class="s4">\n  </span><span class="s2">#sizes?: ZeroArray</span><span class="s4">\n  </span><span class="s2">#starts?: ZeroArray</span><span class="s4">\n  </span><span class="s2">#ttls?: ZeroArray</span><span class="s4">\n\n  </span><span class="s2">#hasDispose: boolean</span><span class="s4">\n  </span><span class="s2">#hasFetchMethod: boolean</span><span class="s4">\n  </span><span class="s2">#hasDisposeAfter: boolean</span><span class="s4">\n\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* Do not call this method unless you need to inspect the</span><span class="s4">\n   </span><span class="s2">* inner workings of the cache.  If anything returned by this</span><span class="s4">\n   </span><span class="s2">* object is modified in any way, strange breakage may occur.</span><span class="s4">\n   </span><span class="s2">*</span><span class="s4">\n   </span><span class="s2">* These fields are private for a reason!</span><span class="s4">\n   </span><span class="s2">*</span><span class="s4">\n   </span><span class="s2">* @internal</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">static unsafeExposeInternals&lt;</span><span class="s4">\n    </span><span class="s2">K extends {},</span><span class="s4">\n    </span><span class="s2">V extends {},</span><span class="s4">\n    </span><span class="s2">FC extends unknown = unknown</span><span class="s4">\n  </span><span class="s2">&gt;(c: LRUCache&lt;K, V, FC&gt;) {</span><span class="s4">\n    </span><span class="s2">return {</span><span class="s4">\n      </span><span class="s2">// properties</span><span class="s4">\n      </span><span class="s2">starts: c.#starts,</span><span class="s4">\n      </span><span class="s2">ttls: c.#ttls,</span><span class="s4">\n      </span><span class="s2">sizes: c.#sizes,</span><span class="s4">\n      </span><span class="s2">keyMap: c.#keyMap as Map&lt;K, number&gt;,</span><span class="s4">\n      </span><span class="s2">keyList: c.#keyList,</span><span class="s4">\n      </span><span class="s2">valList: c.#valList,</span><span class="s4">\n      </span><span class="s2">next: c.#next,</span><span class="s4">\n      </span><span class="s2">prev: c.#prev,</span><span class="s4">\n      </span><span class="s2">get head() {</span><span class="s4">\n        </span><span class="s2">return c.#head</span><span class="s4">\n      </span><span class="s2">},</span><span class="s4">\n      </span><span class="s2">get tail() {</span><span class="s4">\n        </span><span class="s2">return c.#tail</span><span class="s4">\n      </span><span class="s2">},</span><span class="s4">\n      </span><span class="s2">free: c.#free,</span><span class="s4">\n      </span><span class="s2">// methods</span><span class="s4">\n      </span><span class="s2">isBackgroundFetch: (p: any) =&gt; c.#isBackgroundFetch(p),</span><span class="s4">\n      </span><span class="s2">backgroundFetch: (</span><span class="s4">\n        </span><span class="s2">k: K,</span><span class="s4">\n        </span><span class="s2">index: number | undefined,</span><span class="s4">\n        </span><span class="s2">options: LRUCache.FetchOptions&lt;K, V, FC&gt;,</span><span class="s4">\n        </span><span class="s2">context: any</span><span class="s4">\n      </span><span class="s2">): BackgroundFetch&lt;V&gt; =&gt;</span><span class="s4">\n        </span><span class="s2">c.#backgroundFetch(</span><span class="s4">\n          </span><span class="s2">k,</span><span class="s4">\n          </span><span class="s2">index as Index | undefined,</span><span class="s4">\n          </span><span class="s2">options,</span><span class="s4">\n          </span><span class="s2">context</span><span class="s4">\n        </span><span class="s2">),</span><span class="s4">\n      </span><span class="s2">moveToTail: (index: number): void =&gt;</span><span class="s4">\n        </span><span class="s2">c.#moveToTail(index as Index),</span><span class="s4">\n      </span><span class="s2">indexes: (options?: { allowStale: boolean }) =&gt;</span><span class="s4">\n        </span><span class="s2">c.#indexes(options),</span><span class="s4">\n      </span><span class="s2">rindexes: (options?: { allowStale: boolean }) =&gt;</span><span class="s4">\n        </span><span class="s2">c.#rindexes(options),</span><span class="s4">\n      </span><span class="s2">isStale: (index: number | undefined) =&gt;</span><span class="s4">\n        </span><span class="s2">c.#isStale(index as Index),</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n\n  </span><span class="s2">// Protected read-only members</span><span class="s4">\n\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* {@link LRUCache.OptionsBase.max} (read-only)</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">get max(): LRUCache.Count {</span><span class="s4">\n    </span><span class="s2">return this.#max</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* {@link LRUCache.OptionsBase.maxSize} (read-only)</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">get maxSize(): LRUCache.Count {</span><span class="s4">\n    </span><span class="s2">return this.#maxSize</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* The total computed size of items in the cache (read-only)</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">get calculatedSize(): LRUCache.Size {</span><span class="s4">\n    </span><span class="s2">return this.#calculatedSize</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* The number of items stored in the cache (read-only)</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">get size(): LRUCache.Count {</span><span class="s4">\n    </span><span class="s2">return this.#size</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* {@link LRUCache.OptionsBase.fetchMethod} (read-only)</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">get fetchMethod(): LRUCache.Fetcher&lt;K, V, FC&gt; | undefined {</span><span class="s4">\n    </span><span class="s2">return this.#fetchMethod</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n  </span><span class="s2">get memoMethod(): LRUCache.Memoizer&lt;K, V, FC&gt; | undefined {</span><span class="s4">\n    </span><span class="s2">return this.#memoMethod</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* {@link LRUCache.OptionsBase.dispose} (read-only)</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">get dispose() {</span><span class="s4">\n    </span><span class="s2">return this.#dispose</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* {@link LRUCache.OptionsBase.disposeAfter} (read-only)</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">get disposeAfter() {</span><span class="s4">\n    </span><span class="s2">return this.#disposeAfter</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n\n  </span><span class="s2">constructor(</span><span class="s4">\n    </span><span class="s2">options: LRUCache.Options&lt;K, V, FC&gt; | LRUCache&lt;K, V, FC&gt;</span><span class="s4">\n  </span><span class="s2">) {</span><span class="s4">\n    </span><span class="s2">const {</span><span class="s4">\n      </span><span class="s2">max = 0,</span><span class="s4">\n      </span><span class="s2">ttl,</span><span class="s4">\n      </span><span class="s2">ttlResolution = 1,</span><span class="s4">\n      </span><span class="s2">ttlAutopurge,</span><span class="s4">\n      </span><span class="s2">updateAgeOnGet,</span><span class="s4">\n      </span><span class="s2">updateAgeOnHas,</span><span class="s4">\n      </span><span class="s2">allowStale,</span><span class="s4">\n      </span><span class="s2">dispose,</span><span class="s4">\n      </span><span class="s2">disposeAfter,</span><span class="s4">\n      </span><span class="s2">noDisposeOnSet,</span><span class="s4">\n      </span><span class="s2">noUpdateTTL,</span><span class="s4">\n      </span><span class="s2">maxSize = 0,</span><span class="s4">\n      </span><span class="s2">maxEntrySize = 0,</span><span class="s4">\n      </span><span class="s2">sizeCalculation,</span><span class="s4">\n      </span><span class="s2">fetchMethod,</span><span class="s4">\n      </span><span class="s2">memoMethod,</span><span class="s4">\n      </span><span class="s2">noDeleteOnFetchRejection,</span><span class="s4">\n      </span><span class="s2">noDeleteOnStaleGet,</span><span class="s4">\n      </span><span class="s2">allowStaleOnFetchRejection,</span><span class="s4">\n      </span><span class="s2">allowStaleOnFetchAbort,</span><span class="s4">\n      </span><span class="s2">ignoreFetchAbort,</span><span class="s4">\n    </span><span class="s2">} = options</span><span class="s4">\n\n    </span><span class="s2">if (max !== 0 &amp;&amp; !isPosInt(max)) {</span><span class="s4">\n      </span><span class="s2">throw new TypeError('max option must be a nonnegative integer')</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n\n    </span><span class="s2">const UintArray = max ? getUintArray(max) : Array</span><span class="s4">\n    </span><span class="s2">if (!UintArray) {</span><span class="s4">\n      </span><span class="s2">throw new Error('invalid max value: ' + max)</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n\n    </span><span class="s2">this.#max = max</span><span class="s4">\n    </span><span class="s2">this.#maxSize = maxSize</span><span class="s4">\n    </span><span class="s2">this.maxEntrySize = maxEntrySize || this.#maxSize</span><span class="s4">\n    </span><span class="s2">this.sizeCalculation = sizeCalculation</span><span class="s4">\n    </span><span class="s2">if (this.sizeCalculation) {</span><span class="s4">\n      </span><span class="s2">if (!this.#maxSize &amp;&amp; !this.maxEntrySize) {</span><span class="s4">\n        </span><span class="s2">throw new TypeError(</span><span class="s4">\n          </span><span class="s2">'cannot set sizeCalculation without setting maxSize or maxEntrySize'</span><span class="s4">\n        </span><span class="s2">)</span><span class="s4">\n      </span><span class="s2">}</span><span class="s4">\n      </span><span class="s2">if (typeof this.sizeCalculation !== 'function') {</span><span class="s4">\n        </span><span class="s2">throw new TypeError('sizeCalculation set to non-function')</span><span class="s4">\n      </span><span class="s2">}</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n\n    </span><span class="s2">if (</span><span class="s4">\n      </span><span class="s2">memoMethod !== undefined &amp;&amp;</span><span class="s4">\n      </span><span class="s2">typeof memoMethod !== 'function'</span><span class="s4">\n    </span><span class="s2">) {</span><span class="s4">\n      </span><span class="s2">throw new TypeError('memoMethod must be a function if defined')</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n    </span><span class="s2">this.#memoMethod = memoMethod</span><span class="s4">\n\n    </span><span class="s2">if (</span><span class="s4">\n      </span><span class="s2">fetchMethod !== undefined &amp;&amp;</span><span class="s4">\n      </span><span class="s2">typeof fetchMethod !== 'function'</span><span class="s4">\n    </span><span class="s2">) {</span><span class="s4">\n      </span><span class="s2">throw new TypeError(</span><span class="s4">\n        </span><span class="s2">'fetchMethod must be a function if specified'</span><span class="s4">\n      </span><span class="s2">)</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n    </span><span class="s2">this.#fetchMethod = fetchMethod</span><span class="s4">\n    </span><span class="s2">this.#hasFetchMethod = !!fetchMethod</span><span class="s4">\n\n    </span><span class="s2">this.#keyMap = new Map()</span><span class="s4">\n    </span><span class="s2">this.#keyList = new Array(max).fill(undefined)</span><span class="s4">\n    </span><span class="s2">this.#valList = new Array(max).fill(undefined)</span><span class="s4">\n    </span><span class="s2">this.#next = new UintArray(max)</span><span class="s4">\n    </span><span class="s2">this.#prev = new UintArray(max)</span><span class="s4">\n    </span><span class="s2">this.#head = 0 as Index</span><span class="s4">\n    </span><span class="s2">this.#tail = 0 as Index</span><span class="s4">\n    </span><span class="s2">this.#free = Stack.create(max)</span><span class="s4">\n    </span><span class="s2">this.#size = 0</span><span class="s4">\n    </span><span class="s2">this.#calculatedSize = 0</span><span class="s4">\n\n    </span><span class="s2">if (typeof dispose === 'function') {</span><span class="s4">\n      </span><span class="s2">this.#dispose = dispose</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n    </span><span class="s2">if (typeof disposeAfter === 'function') {</span><span class="s4">\n      </span><span class="s2">this.#disposeAfter = disposeAfter</span><span class="s4">\n      </span><span class="s2">this.#disposed = []</span><span class="s4">\n    </span><span class="s2">} else {</span><span class="s4">\n      </span><span class="s2">this.#disposeAfter = undefined</span><span class="s4">\n      </span><span class="s2">this.#disposed = undefined</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n    </span><span class="s2">this.#hasDispose = !!this.#dispose</span><span class="s4">\n    </span><span class="s2">this.#hasDisposeAfter = !!this.#disposeAfter</span><span class="s4">\n\n    </span><span class="s2">this.noDisposeOnSet = !!noDisposeOnSet</span><span class="s4">\n    </span><span class="s2">this.noUpdateTTL = !!noUpdateTTL</span><span class="s4">\n    </span><span class="s2">this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection</span><span class="s4">\n    </span><span class="s2">this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection</span><span class="s4">\n    </span><span class="s2">this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort</span><span class="s4">\n    </span><span class="s2">this.ignoreFetchAbort = !!ignoreFetchAbort</span><span class="s4">\n\n    </span><span class="s2">// NB: maxEntrySize is set to maxSize if it's set</span><span class="s4">\n    </span><span class="s2">if (this.maxEntrySize !== 0) {</span><span class="s4">\n      </span><span class="s2">if (this.#maxSize !== 0) {</span><span class="s4">\n        </span><span class="s2">if (!isPosInt(this.#maxSize)) {</span><span class="s4">\n          </span><span class="s2">throw new TypeError(</span><span class="s4">\n            </span><span class="s2">'maxSize must be a positive integer if specified'</span><span class="s4">\n          </span><span class="s2">)</span><span class="s4">\n        </span><span class="s2">}</span><span class="s4">\n      </span><span class="s2">}</span><span class="s4">\n      </span><span class="s2">if (!isPosInt(this.maxEntrySize)) {</span><span class="s4">\n        </span><span class="s2">throw new TypeError(</span><span class="s4">\n          </span><span class="s2">'maxEntrySize must be a positive integer if specified'</span><span class="s4">\n        </span><span class="s2">)</span><span class="s4">\n      </span><span class="s2">}</span><span class="s4">\n      </span><span class="s2">this.#initializeSizeTracking()</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n\n    </span><span class="s2">this.allowStale = !!allowStale</span><span class="s4">\n    </span><span class="s2">this.noDeleteOnStaleGet = !!noDeleteOnStaleGet</span><span class="s4">\n    </span><span class="s2">this.updateAgeOnGet = !!updateAgeOnGet</span><span class="s4">\n    </span><span class="s2">this.updateAgeOnHas = !!updateAgeOnHas</span><span class="s4">\n    </span><span class="s2">this.ttlResolution =</span><span class="s4">\n      </span><span class="s2">isPosInt(ttlResolution) || ttlResolution === 0</span><span class="s4">\n        </span><span class="s2">? ttlResolution</span><span class="s4">\n        </span><span class="s2">: 1</span><span class="s4">\n    </span><span class="s2">this.ttlAutopurge = !!ttlAutopurge</span><span class="s4">\n    </span><span class="s2">this.ttl = ttl || 0</span><span class="s4">\n    </span><span class="s2">if (this.ttl) {</span><span class="s4">\n      </span><span class="s2">if (!isPosInt(this.ttl)) {</span><span class="s4">\n        </span><span class="s2">throw new TypeError(</span><span class="s4">\n          </span><span class="s2">'ttl must be a positive integer if specified'</span><span class="s4">\n        </span><span class="s2">)</span><span class="s4">\n      </span><span class="s2">}</span><span class="s4">\n      </span><span class="s2">this.#initializeTTLTracking()</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n\n    </span><span class="s2">// do not allow completely unbounded caches</span><span class="s4">\n    </span><span class="s2">if (this.#max === 0 &amp;&amp; this.ttl === 0 &amp;&amp; this.#maxSize === 0) {</span><span class="s4">\n      </span><span class="s2">throw new TypeError(</span><span class="s4">\n        </span><span class="s2">'At least one of max, maxSize, or ttl is required'</span><span class="s4">\n      </span><span class="s2">)</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n    </span><span class="s2">if (!this.ttlAutopurge &amp;&amp; !this.#max &amp;&amp; !this.#maxSize) {</span><span class="s4">\n      </span><span class="s2">const code = 'LRU_CACHE_UNBOUNDED'</span><span class="s4">\n      </span><span class="s2">if (shouldWarn(code)) {</span><span class="s4">\n        </span><span class="s2">warned.add(code)</span><span class="s4">\n        </span><span class="s2">const msg =</span><span class="s4">\n          </span><span class="s2">'TTL caching without ttlAutopurge, max, or maxSize can ' +</span><span class="s4">\n          </span><span class="s2">'result in unbounded memory consumption.'</span><span class="s4">\n        </span><span class="s2">emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache)</span><span class="s4">\n      </span><span class="s2">}</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* Return the number of ms left in the item's TTL. If item is not in cache,</span><span class="s4">\n   </span><span class="s2">* returns `0`. Returns `Infinity` if item is in cache without a defined TTL.</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">getRemainingTTL(key: K) {</span><span class="s4">\n    </span><span class="s2">return this.#keyMap.has(key) ? Infinity : 0</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n\n  </span><span class="s2">#initializeTTLTracking() {</span><span class="s4">\n    </span><span class="s2">const ttls = new ZeroArray(this.#max)</span><span class="s4">\n    </span><span class="s2">const starts = new ZeroArray(this.#max)</span><span class="s4">\n    </span><span class="s2">this.#ttls = ttls</span><span class="s4">\n    </span><span class="s2">this.#starts = starts</span><span class="s4">\n\n    </span><span class="s2">this.#setItemTTL = (index, ttl, start = perf.now()) =&gt; {</span><span class="s4">\n      </span><span class="s2">starts[index] = ttl !== 0 ? start : 0</span><span class="s4">\n      </span><span class="s2">ttls[index] = ttl</span><span class="s4">\n      </span><span class="s2">if (ttl !== 0 &amp;&amp; this.ttlAutopurge) {</span><span class="s4">\n        </span><span class="s2">const t = setTimeout(() =&gt; {</span><span class="s4">\n          </span><span class="s2">if (this.#isStale(index)) {</span><span class="s4">\n            </span><span class="s2">this.#delete(this.#keyList[index] as K, 'expire')</span><span class="s4">\n          </span><span class="s2">}</span><span class="s4">\n        </span><span class="s2">}, ttl + 1)</span><span class="s4">\n        </span><span class="s2">// unref() not supported on all platforms</span><span class="s4">\n        </span><span class="s2">/* c8 ignore start */</span><span class="s4">\n        </span><span class="s2">if (t.unref) {</span><span class="s4">\n          </span><span class="s2">t.unref()</span><span class="s4">\n        </span><span class="s2">}</span><span class="s4">\n        </span><span class="s2">/* c8 ignore stop */</span><span class="s4">\n      </span><span class="s2">}</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n\n    </span><span class="s2">this.#updateItemAge = index =&gt; {</span><span class="s4">\n      </span><span class="s2">starts[index] = ttls[index] !== 0 ? perf.now() : 0</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n\n    </span><span class="s2">this.#statusTTL = (status, index) =&gt; {</span><span class="s4">\n      </span><span class="s2">if (ttls[index]) {</span><span class="s4">\n        </span><span class="s2">const ttl = ttls[index]</span><span class="s4">\n        </span><span class="s2">const start = starts[index]</span><span class="s4">\n        </span><span class="s2">/* c8 ignore next */</span><span class="s4">\n        </span><span class="s2">if (!ttl || !start) return</span><span class="s4">\n        </span><span class="s2">status.ttl = ttl</span><span class="s4">\n        </span><span class="s2">status.start = start</span><span class="s4">\n        </span><span class="s2">status.now = cachedNow || getNow()</span><span class="s4">\n        </span><span class="s2">const age = status.now - start</span><span class="s4">\n        </span><span class="s2">status.remainingTTL = ttl - age</span><span class="s4">\n      </span><span class="s2">}</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n\n    </span><span class="s2">// debounce calls to perf.now() to 1s so we're not hitting</span><span class="s4">\n    </span><span class="s2">// that costly call repeatedly.</span><span class="s4">\n    </span><span class="s2">let cachedNow = 0</span><span class="s4">\n    </span><span class="s2">const getNow = () =&gt; {</span><span class="s4">\n      </span><span class="s2">const n = perf.now()</span><span class="s4">\n      </span><span class="s2">if (this.ttlResolution &gt; 0) {</span><span class="s4">\n        </span><span class="s2">cachedNow = n</span><span class="s4">\n        </span><span class="s2">const t = setTimeout(</span><span class="s4">\n          </span><span class="s2">() =&gt; (cachedNow = 0),</span><span class="s4">\n          </span><span class="s2">this.ttlResolution</span><span class="s4">\n        </span><span class="s2">)</span><span class="s4">\n        </span><span class="s2">// not available on all platforms</span><span class="s4">\n        </span><span class="s2">/* c8 ignore start */</span><span class="s4">\n        </span><span class="s2">if (t.unref) {</span><span class="s4">\n          </span><span class="s2">t.unref()</span><span class="s4">\n        </span><span class="s2">}</span><span class="s4">\n        </span><span class="s2">/* c8 ignore stop */</span><span class="s4">\n      </span><span class="s2">}</span><span class="s4">\n      </span><span class="s2">return n</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n\n    </span><span class="s2">this.getRemainingTTL = key =&gt; {</span><span class="s4">\n      </span><span class="s2">const index = this.#keyMap.get(key)</span><span class="s4">\n      </span><span class="s2">if (index === undefined) {</span><span class="s4">\n        </span><span class="s2">return 0</span><span class="s4">\n      </span><span class="s2">}</span><span class="s4">\n      </span><span class="s2">const ttl = ttls[index]</span><span class="s4">\n      </span><span class="s2">const start = starts[index]</span><span class="s4">\n      </span><span class="s2">if (!ttl || !start) {</span><span class="s4">\n        </span><span class="s2">return Infinity</span><span class="s4">\n      </span><span class="s2">}</span><span class="s4">\n      </span><span class="s2">const age = (cachedNow || getNow()) - start</span><span class="s4">\n      </span><span class="s2">return ttl - age</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n\n    </span><span class="s2">this.#isStale = index =&gt; {</span><span class="s4">\n      </span><span class="s2">const s = starts[index]</span><span class="s4">\n      </span><span class="s2">const t = ttls[index]</span><span class="s4">\n      </span><span class="s2">return !!t &amp;&amp; !!s &amp;&amp; (cachedNow || getNow()) - s &gt; t</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n\n  </span><span class="s2">// conditionally set private methods related to TTL</span><span class="s4">\n  </span><span class="s2">#updateItemAge: (index: Index) =&gt; void = () =&gt; {}</span><span class="s4">\n  </span><span class="s2">#statusTTL: (status: LRUCache.Status&lt;V&gt;, index: Index) =&gt; void =</span><span class="s4">\n    </span><span class="s2">() =&gt; {}</span><span class="s4">\n  </span><span class="s2">#setItemTTL: (</span><span class="s4">\n    </span><span class="s2">index: Index,</span><span class="s4">\n    </span><span class="s2">ttl: LRUCache.Milliseconds,</span><span class="s4">\n    </span><span class="s2">start?: LRUCache.Milliseconds</span><span class="s4">\n    </span><span class="s2">// ignore because we never call this if we're not already in TTL mode</span><span class="s4">\n    </span><span class="s2">/* c8 ignore start */</span><span class="s4">\n  </span><span class="s2">) =&gt; void = () =&gt; {}</span><span class="s4">\n  </span><span class="s2">/* c8 ignore stop */</span><span class="s4">\n\n  </span><span class="s2">#isStale: (index: Index) =&gt; boolean = () =&gt; false</span><span class="s4">\n\n  </span><span class="s2">#initializeSizeTracking() {</span><span class="s4">\n    </span><span class="s2">const sizes = new ZeroArray(this.#max)</span><span class="s4">\n    </span><span class="s2">this.#calculatedSize = 0</span><span class="s4">\n    </span><span class="s2">this.#sizes = sizes</span><span class="s4">\n    </span><span class="s2">this.#removeItemSize = index =&gt; {</span><span class="s4">\n      </span><span class="s2">this.#calculatedSize -= sizes[index] as number</span><span class="s4">\n      </span><span class="s2">sizes[index] = 0</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n    </span><span class="s2">this.#requireSize = (k, v, size, sizeCalculation) =&gt; {</span><span class="s4">\n      </span><span class="s2">// provisionally accept background fetches.</span><span class="s4">\n      </span><span class="s2">// actual value size will be checked when they return.</span><span class="s4">\n      </span><span class="s2">if (this.#isBackgroundFetch(v)) {</span><span class="s4">\n        </span><span class="s2">return 0</span><span class="s4">\n      </span><span class="s2">}</span><span class="s4">\n      </span><span class="s2">if (!isPosInt(size)) {</span><span class="s4">\n        </span><span class="s2">if (sizeCalculation) {</span><span class="s4">\n          </span><span class="s2">if (typeof sizeCalculation !== 'function') {</span><span class="s4">\n            </span><span class="s2">throw new TypeError('sizeCalculation must be a function')</span><span class="s4">\n          </span><span class="s2">}</span><span class="s4">\n          </span><span class="s2">size = sizeCalculation(v, k)</span><span class="s4">\n          </span><span class="s2">if (!isPosInt(size)) {</span><span class="s4">\n            </span><span class="s2">throw new TypeError(</span><span class="s4">\n              </span><span class="s2">'sizeCalculation return invalid (expect positive integer)'</span><span class="s4">\n            </span><span class="s2">)</span><span class="s4">\n          </span><span class="s2">}</span><span class="s4">\n        </span><span class="s2">} else {</span><span class="s4">\n          </span><span class="s2">throw new TypeError(</span><span class="s4">\n            </span><span class="s2">'invalid size value (must be positive integer). ' +</span><span class="s4">\n              </span><span class="s2">'When maxSize or maxEntrySize is used, sizeCalculation ' +</span><span class="s4">\n              </span><span class="s2">'or size must be set.'</span><span class="s4">\n          </span><span class="s2">)</span><span class="s4">\n        </span><span class="s2">}</span><span class="s4">\n      </span><span class="s2">}</span><span class="s4">\n      </span><span class="s2">return size</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n    </span><span class="s2">this.#addItemSize = (</span><span class="s4">\n      </span><span class="s2">index: Index,</span><span class="s4">\n      </span><span class="s2">size: LRUCache.Size,</span><span class="s4">\n      </span><span class="s2">status?: LRUCache.Status&lt;V&gt;</span><span class="s4">\n    </span><span class="s2">) =&gt; {</span><span class="s4">\n      </span><span class="s2">sizes[index] = size</span><span class="s4">\n      </span><span class="s2">if (this.#maxSize) {</span><span class="s4">\n        </span><span class="s2">const maxSize = this.#maxSize - (sizes[index] as number)</span><span class="s4">\n        </span><span class="s2">while (this.#calculatedSize &gt; maxSize) {</span><span class="s4">\n          </span><span class="s2">this.#evict(true)</span><span class="s4">\n        </span><span class="s2">}</span><span class="s4">\n      </span><span class="s2">}</span><span class="s4">\n      </span><span class="s2">this.#calculatedSize += sizes[index] as number</span><span class="s4">\n      </span><span class="s2">if (status) {</span><span class="s4">\n        </span><span class="s2">status.entrySize = size</span><span class="s4">\n        </span><span class="s2">status.totalCalculatedSize = this.#calculatedSize</span><span class="s4">\n      </span><span class="s2">}</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n\n  </span><span class="s2">#removeItemSize: (index: Index) =&gt; void = _i =&gt; {}</span><span class="s4">\n  </span><span class="s2">#addItemSize: (</span><span class="s4">\n    </span><span class="s2">index: Index,</span><span class="s4">\n    </span><span class="s2">size: LRUCache.Size,</span><span class="s4">\n    </span><span class="s2">status?: LRUCache.Status&lt;V&gt;</span><span class="s4">\n  </span><span class="s2">) =&gt; void = (_i, _s, _st) =&gt; {}</span><span class="s4">\n  </span><span class="s2">#requireSize: (</span><span class="s4">\n    </span><span class="s2">k: K,</span><span class="s4">\n    </span><span class="s2">v: V | BackgroundFetch&lt;V&gt;,</span><span class="s4">\n    </span><span class="s2">size?: LRUCache.Size,</span><span class="s4">\n    </span><span class="s2">sizeCalculation?: LRUCache.SizeCalculator&lt;K, V&gt;</span><span class="s4">\n  </span><span class="s2">) =&gt; LRUCache.Size = (</span><span class="s4">\n    </span><span class="s2">_k: K,</span><span class="s4">\n    </span><span class="s2">_v: V | BackgroundFetch&lt;V&gt;,</span><span class="s4">\n    </span><span class="s2">size?: LRUCache.Size,</span><span class="s4">\n    </span><span class="s2">sizeCalculation?: LRUCache.SizeCalculator&lt;K, V&gt;</span><span class="s4">\n  </span><span class="s2">) =&gt; {</span><span class="s4">\n    </span><span class="s2">if (size || sizeCalculation) {</span><span class="s4">\n      </span><span class="s2">throw new TypeError(</span><span class="s4">\n        </span><span class="s2">'cannot set size without setting maxSize or maxEntrySize on cache'</span><span class="s4">\n      </span><span class="s2">)</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n    </span><span class="s2">return 0</span><span class="s4">\n  </span><span class="s2">};</span><span class="s4">\n\n  </span><span class="s2">*#indexes({ allowStale = this.allowStale } = {}) {</span><span class="s4">\n    </span><span class="s2">if (this.#size) {</span><span class="s4">\n      </span><span class="s2">for (let i = this.#tail; true; ) {</span><span class="s4">\n        </span><span class="s2">if (!this.#isValidIndex(i)) {</span><span class="s4">\n          </span><span class="s2">break</span><span class="s4">\n        </span><span class="s2">}</span><span class="s4">\n        </span><span class="s2">if (allowStale || !this.#isStale(i)) {</span><span class="s4">\n          </span><span class="s2">yield i</span><span class="s4">\n        </span><span class="s2">}</span><span class="s4">\n        </span><span class="s2">if (i === this.#head) {</span><span class="s4">\n          </span><span class="s2">break</span><span class="s4">\n        </span><span class="s2">} else {</span><span class="s4">\n          </span><span class="s2">i = this.#prev[i] as Index</span><span class="s4">\n        </span><span class="s2">}</span><span class="s4">\n      </span><span class="s2">}</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n\n  </span><span class="s2">*#rindexes({ allowStale = this.allowStale } = {}) {</span><span class="s4">\n    </span><span class="s2">if (this.#size) {</span><span class="s4">\n      </span><span class="s2">for (let i = this.#head; true; ) {</span><span class="s4">\n        </span><span class="s2">if (!this.#isValidIndex(i)) {</span><span class="s4">\n          </span><span class="s2">break</span><span class="s4">\n        </span><span class="s2">}</span><span class="s4">\n        </span><span class="s2">if (allowStale || !this.#isStale(i)) {</span><span class="s4">\n          </span><span class="s2">yield i</span><span class="s4">\n        </span><span class="s2">}</span><span class="s4">\n        </span><span class="s2">if (i === this.#tail) {</span><span class="s4">\n          </span><span class="s2">break</span><span class="s4">\n        </span><span class="s2">} else {</span><span class="s4">\n          </span><span class="s2">i = this.#next[i] as Index</span><span class="s4">\n        </span><span class="s2">}</span><span class="s4">\n      </span><span class="s2">}</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n\n  </span><span class="s2">#isValidIndex(index: Index) {</span><span class="s4">\n    </span><span class="s2">return (</span><span class="s4">\n      </span><span class="s2">index !== undefined &amp;&amp;</span><span class="s4">\n      </span><span class="s2">this.#keyMap.get(this.#keyList[index] as K) === index</span><span class="s4">\n    </span><span class="s2">)</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* Return a generator yielding `[key, value]` pairs,</span><span class="s4">\n   </span><span class="s2">* in order from most recently used to least recently used.</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">*entries() {</span><span class="s4">\n    </span><span class="s2">for (const i of this.#indexes()) {</span><span class="s4">\n      </span><span class="s2">if (</span><span class="s4">\n        </span><span class="s2">this.#valList[i] !== undefined &amp;&amp;</span><span class="s4">\n        </span><span class="s2">this.#keyList[i] !== undefined &amp;&amp;</span><span class="s4">\n        </span><span class="s2">!this.#isBackgroundFetch(this.#valList[i])</span><span class="s4">\n      </span><span class="s2">) {</span><span class="s4">\n        </span><span class="s2">yield [this.#keyList[i], this.#valList[i]] as [K, V]</span><span class="s4">\n      </span><span class="s2">}</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* Inverse order version of {@link LRUCache.entries}</span><span class="s4">\n   </span><span class="s2">*</span><span class="s4">\n   </span><span class="s2">* Return a generator yielding `[key, value]` pairs,</span><span class="s4">\n   </span><span class="s2">* in order from least recently used to most recently used.</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">*rentries() {</span><span class="s4">\n    </span><span class="s2">for (const i of this.#rindexes()) {</span><span class="s4">\n      </span><span class="s2">if (</span><span class="s4">\n        </span><span class="s2">this.#valList[i] !== undefined &amp;&amp;</span><span class="s4">\n        </span><span class="s2">this.#keyList[i] !== undefined &amp;&amp;</span><span class="s4">\n        </span><span class="s2">!this.#isBackgroundFetch(this.#valList[i])</span><span class="s4">\n      </span><span class="s2">) {</span><span class="s4">\n        </span><span class="s2">yield [this.#keyList[i], this.#valList[i]]</span><span class="s4">\n      </span><span class="s2">}</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* Return a generator yielding the keys in the cache,</span><span class="s4">\n   </span><span class="s2">* in order from most recently used to least recently used.</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">*keys() {</span><span class="s4">\n    </span><span class="s2">for (const i of this.#indexes()) {</span><span class="s4">\n      </span><span class="s2">const k = this.#keyList[i]</span><span class="s4">\n      </span><span class="s2">if (</span><span class="s4">\n        </span><span class="s2">k !== undefined &amp;&amp;</span><span class="s4">\n        </span><span class="s2">!this.#isBackgroundFetch(this.#valList[i])</span><span class="s4">\n      </span><span class="s2">) {</span><span class="s4">\n        </span><span class="s2">yield k</span><span class="s4">\n      </span><span class="s2">}</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* Inverse order version of {@link LRUCache.keys}</span><span class="s4">\n   </span><span class="s2">*</span><span class="s4">\n   </span><span class="s2">* Return a generator yielding the keys in the cache,</span><span class="s4">\n   </span><span class="s2">* in order from least recently used to most recently used.</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">*rkeys() {</span><span class="s4">\n    </span><span class="s2">for (const i of this.#rindexes()) {</span><span class="s4">\n      </span><span class="s2">const k = this.#keyList[i]</span><span class="s4">\n      </span><span class="s2">if (</span><span class="s4">\n        </span><span class="s2">k !== undefined &amp;&amp;</span><span class="s4">\n        </span><span class="s2">!this.#isBackgroundFetch(this.#valList[i])</span><span class="s4">\n      </span><span class="s2">) {</span><span class="s4">\n        </span><span class="s2">yield k</span><span class="s4">\n      </span><span class="s2">}</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* Return a generator yielding the values in the cache,</span><span class="s4">\n   </span><span class="s2">* in order from most recently used to least recently used.</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">*values() {</span><span class="s4">\n    </span><span class="s2">for (const i of this.#indexes()) {</span><span class="s4">\n      </span><span class="s2">const v = this.#valList[i]</span><span class="s4">\n      </span><span class="s2">if (</span><span class="s4">\n        </span><span class="s2">v !== undefined &amp;&amp;</span><span class="s4">\n        </span><span class="s2">!this.#isBackgroundFetch(this.#valList[i])</span><span class="s4">\n      </span><span class="s2">) {</span><span class="s4">\n        </span><span class="s2">yield this.#valList[i] as V</span><span class="s4">\n      </span><span class="s2">}</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* Inverse order version of {@link LRUCache.values}</span><span class="s4">\n   </span><span class="s2">*</span><span class="s4">\n   </span><span class="s2">* Return a generator yielding the values in the cache,</span><span class="s4">\n   </span><span class="s2">* in order from least recently used to most recently used.</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">*rvalues() {</span><span class="s4">\n    </span><span class="s2">for (const i of this.#rindexes()) {</span><span class="s4">\n      </span><span class="s2">const v = this.#valList[i]</span><span class="s4">\n      </span><span class="s2">if (</span><span class="s4">\n        </span><span class="s2">v !== undefined &amp;&amp;</span><span class="s4">\n        </span><span class="s2">!this.#isBackgroundFetch(this.#valList[i])</span><span class="s4">\n      </span><span class="s2">) {</span><span class="s4">\n        </span><span class="s2">yield this.#valList[i]</span><span class="s4">\n      </span><span class="s2">}</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* Iterating over the cache itself yields the same results as</span><span class="s4">\n   </span><span class="s2">* {@link LRUCache.entries}</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">[Symbol.iterator]() {</span><span class="s4">\n    </span><span class="s2">return this.entries()</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* A String value that is used in the creation of the default string</span><span class="s4">\n   </span><span class="s2">* description of an object. Called by the built-in method</span><span class="s4">\n   </span><span class="s2">* `Object.prototype.toString`.</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">[Symbol.toStringTag] = 'LRUCache'</span><span class="s4">\n\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* Find a value for which the supplied fn method returns a truthy value,</span><span class="s4">\n   </span><span class="s2">* similar to `Array.find()`. fn is called as `fn(value, key, cache)`.</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">find(</span><span class="s4">\n    </span><span class="s2">fn: (v: V, k: K, self: LRUCache&lt;K, V, FC&gt;) =&gt; boolean,</span><span class="s4">\n    </span><span class="s2">getOptions: LRUCache.GetOptions&lt;K, V, FC&gt; = {}</span><span class="s4">\n  </span><span class="s2">) {</span><span class="s4">\n    </span><span class="s2">for (const i of this.#indexes()) {</span><span class="s4">\n      </span><span class="s2">const v = this.#valList[i]</span><span class="s4">\n      </span><span class="s2">const value = this.#isBackgroundFetch(v)</span><span class="s4">\n        </span><span class="s2">? v.__staleWhileFetching</span><span class="s4">\n        </span><span class="s2">: v</span><span class="s4">\n      </span><span class="s2">if (value === undefined) continue</span><span class="s4">\n      </span><span class="s2">if (fn(value, this.#keyList[i] as K, this)) {</span><span class="s4">\n        </span><span class="s2">return this.get(this.#keyList[i] as K, getOptions)</span><span class="s4">\n      </span><span class="s2">}</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* Call the supplied function on each item in the cache, in order from most</span><span class="s4">\n   </span><span class="s2">* recently used to least recently used.</span><span class="s4">\n   </span><span class="s2">*</span><span class="s4">\n   </span><span class="s2">* `fn` is called as `fn(value, key, cache)`.</span><span class="s4">\n   </span><span class="s2">*</span><span class="s4">\n   </span><span class="s2">* If `thisp` is provided, function will be called in the `this`-context of</span><span class="s4">\n   </span><span class="s2">* the provided object, or the cache if no `thisp` object is provided.</span><span class="s4">\n   </span><span class="s2">*</span><span class="s4">\n   </span><span class="s2">* Does not update age or recenty of use, or iterate over stale values.</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">forEach(</span><span class="s4">\n    </span><span class="s2">fn: (v: V, k: K, self: LRUCache&lt;K, V, FC&gt;) =&gt; any,</span><span class="s4">\n    </span><span class="s2">thisp: any = this</span><span class="s4">\n  </span><span class="s2">) {</span><span class="s4">\n    </span><span class="s2">for (const i of this.#indexes()) {</span><span class="s4">\n      </span><span class="s2">const v = this.#valList[i]</span><span class="s4">\n      </span><span class="s2">const value = this.#isBackgroundFetch(v)</span><span class="s4">\n        </span><span class="s2">? v.__staleWhileFetching</span><span class="s4">\n        </span><span class="s2">: v</span><span class="s4">\n      </span><span class="s2">if (value === undefined) continue</span><span class="s4">\n      </span><span class="s2">fn.call(thisp, value, this.#keyList[i] as K, this)</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* The same as {@link LRUCache.forEach} but items are iterated over in</span><span class="s4">\n   </span><span class="s2">* reverse order.  (ie, less recently used items are iterated over first.)</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">rforEach(</span><span class="s4">\n    </span><span class="s2">fn: (v: V, k: K, self: LRUCache&lt;K, V, FC&gt;) =&gt; any,</span><span class="s4">\n    </span><span class="s2">thisp: any = this</span><span class="s4">\n  </span><span class="s2">) {</span><span class="s4">\n    </span><span class="s2">for (const i of this.#rindexes()) {</span><span class="s4">\n      </span><span class="s2">const v = this.#valList[i]</span><span class="s4">\n      </span><span class="s2">const value = this.#isBackgroundFetch(v)</span><span class="s4">\n        </span><span class="s2">? v.__staleWhileFetching</span><span class="s4">\n        </span><span class="s2">: v</span><span class="s4">\n      </span><span class="s2">if (value === undefined) continue</span><span class="s4">\n      </span><span class="s2">fn.call(thisp, value, this.#keyList[i] as K, this)</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* Delete any stale entries. Returns true if anything was removed,</span><span class="s4">\n   </span><span class="s2">* false otherwise.</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">purgeStale() {</span><span class="s4">\n    </span><span class="s2">let deleted = false</span><span class="s4">\n    </span><span class="s2">for (const i of this.#rindexes({ allowStale: true })) {</span><span class="s4">\n      </span><span class="s2">if (this.#isStale(i)) {</span><span class="s4">\n        </span><span class="s2">this.#delete(this.#keyList[i] as K, 'expire')</span><span class="s4">\n        </span><span class="s2">deleted = true</span><span class="s4">\n      </span><span class="s2">}</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n    </span><span class="s2">return deleted</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* Get the extended info about a given entry, to get its value, size, and</span><span class="s4">\n   </span><span class="s2">* TTL info simultaneously. Returns `undefined` if the key is not present.</span><span class="s4">\n   </span><span class="s2">*</span><span class="s4">\n   </span><span class="s2">* Unlike {@link LRUCache#dump}, which is designed to be portable and survive</span><span class="s4">\n   </span><span class="s2">* serialization, the `start` value is always the current timestamp, and the</span><span class="s4">\n   </span><span class="s2">* `ttl` is a calculated remaining time to live (negative if expired).</span><span class="s4">\n   </span><span class="s2">*</span><span class="s4">\n   </span><span class="s2">* Always returns stale values, if their info is found in the cache, so be</span><span class="s4">\n   </span><span class="s2">* sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})</span><span class="s4">\n   </span><span class="s2">* if relevant.</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">info(key: K): LRUCache.Entry&lt;V&gt; | undefined {</span><span class="s4">\n    </span><span class="s2">const i = this.#keyMap.get(key)</span><span class="s4">\n    </span><span class="s2">if (i === undefined) return undefined</span><span class="s4">\n    </span><span class="s2">const v = this.#valList[i]</span><span class="s4">\n    </span><span class="s2">const value: V | undefined = this.#isBackgroundFetch(v)</span><span class="s4">\n      </span><span class="s2">? v.__staleWhileFetching</span><span class="s4">\n      </span><span class="s2">: v</span><span class="s4">\n    </span><span class="s2">if (value === undefined) return undefined</span><span class="s4">\n    </span><span class="s2">const entry: LRUCache.Entry&lt;V&gt; = { value }</span><span class="s4">\n    </span><span class="s2">if (this.#ttls &amp;&amp; this.#starts) {</span><span class="s4">\n      </span><span class="s2">const ttl = this.#ttls[i]</span><span class="s4">\n      </span><span class="s2">const start = this.#starts[i]</span><span class="s4">\n      </span><span class="s2">if (ttl &amp;&amp; start) {</span><span class="s4">\n        </span><span class="s2">const remain = ttl - (perf.now() - start)</span><span class="s4">\n        </span><span class="s2">entry.ttl = remain</span><span class="s4">\n        </span><span class="s2">entry.start = Date.now()</span><span class="s4">\n      </span><span class="s2">}</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n    </span><span class="s2">if (this.#sizes) {</span><span class="s4">\n      </span><span class="s2">entry.size = this.#sizes[i]</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n    </span><span class="s2">return entry</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* Return an array of [key, {@link LRUCache.Entry}] tuples which can be</span><span class="s4">\n   </span><span class="s2">* passed to {@link LRLUCache#load}.</span><span class="s4">\n   </span><span class="s2">*</span><span class="s4">\n   </span><span class="s2">* The `start` fields are calculated relative to a portable `Date.now()`</span><span class="s4">\n   </span><span class="s2">* timestamp, even if `performance.now()` is available.</span><span class="s4">\n   </span><span class="s2">*</span><span class="s4">\n   </span><span class="s2">* Stale entries are always included in the `dump`, even if</span><span class="s4">\n   </span><span class="s2">* {@link LRUCache.OptionsBase.allowStale} is false.</span><span class="s4">\n   </span><span class="s2">*</span><span class="s4">\n   </span><span class="s2">* Note: this returns an actual array, not a generator, so it can be more</span><span class="s4">\n   </span><span class="s2">* easily passed around.</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">dump() {</span><span class="s4">\n    </span><span class="s2">const arr: [K, LRUCache.Entry&lt;V&gt;][] = []</span><span class="s4">\n    </span><span class="s2">for (const i of this.#indexes({ allowStale: true })) {</span><span class="s4">\n      </span><span class="s2">const key = this.#keyList[i]</span><span class="s4">\n      </span><span class="s2">const v = this.#valList[i]</span><span class="s4">\n      </span><span class="s2">const value: V | undefined = this.#isBackgroundFetch(v)</span><span class="s4">\n        </span><span class="s2">? v.__staleWhileFetching</span><span class="s4">\n        </span><span class="s2">: v</span><span class="s4">\n      </span><span class="s2">if (value === undefined || key === undefined) continue</span><span class="s4">\n      </span><span class="s2">const entry: LRUCache.Entry&lt;V&gt; = { value }</span><span class="s4">\n      </span><span class="s2">if (this.#ttls &amp;&amp; this.#starts) {</span><span class="s4">\n        </span><span class="s2">entry.ttl = this.#ttls[i]</span><span class="s4">\n        </span><span class="s2">// always dump the start relative to a portable timestamp</span><span class="s4">\n        </span><span class="s2">// it's ok for this to be a bit slow, it's a rare operation.</span><span class="s4">\n        </span><span class="s2">const age = perf.now() - (this.#starts[i] as number)</span><span class="s4">\n        </span><span class="s2">entry.start = Math.floor(Date.now() - age)</span><span class="s4">\n      </span><span class="s2">}</span><span class="s4">\n      </span><span class="s2">if (this.#sizes) {</span><span class="s4">\n        </span><span class="s2">entry.size = this.#sizes[i]</span><span class="s4">\n      </span><span class="s2">}</span><span class="s4">\n      </span><span class="s2">arr.unshift([key, entry])</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n    </span><span class="s2">return arr</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* Reset the cache and load in the items in entries in the order listed.</span><span class="s4">\n   </span><span class="s2">*</span><span class="s4">\n   </span><span class="s2">* The shape of the resulting cache may be different if the same options are</span><span class="s4">\n   </span><span class="s2">* not used in both caches.</span><span class="s4">\n   </span><span class="s2">*</span><span class="s4">\n   </span><span class="s2">* The `start` fields are assumed to be calculated relative to a portable</span><span class="s4">\n   </span><span class="s2">* `Date.now()` timestamp, even if `performance.now()` is available.</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">load(arr: [K, LRUCache.Entry&lt;V&gt;][]) {</span><span class="s4">\n    </span><span class="s2">this.clear()</span><span class="s4">\n    </span><span class="s2">for (const [key, entry] of arr) {</span><span class="s4">\n      </span><span class="s2">if (entry.start) {</span><span class="s4">\n        </span><span class="s2">// entry.start is a portable timestamp, but we may be using</span><span class="s4">\n        </span><span class="s2">// node's performance.now(), so calculate the offset, so that</span><span class="s4">\n        </span><span class="s2">// we get the intended remaining TTL, no matter how long it's</span><span class="s4">\n        </span><span class="s2">// been on ice.</span><span class="s4">\n        </span><span class="s2">//</span><span class="s4">\n        </span><span class="s2">// it's ok for this to be a bit slow, it's a rare operation.</span><span class="s4">\n        </span><span class="s2">const age = Date.now() - entry.start</span><span class="s4">\n        </span><span class="s2">entry.start = perf.now() - age</span><span class="s4">\n      </span><span class="s2">}</span><span class="s4">\n      </span><span class="s2">this.set(key, entry.value, entry)</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* Add a value to the cache.</span><span class="s4">\n   </span><span class="s2">*</span><span class="s4">\n   </span><span class="s2">* Note: if `undefined` is specified as a value, this is an alias for</span><span class="s4">\n   </span><span class="s2">* {@link LRUCache#delete}</span><span class="s4">\n   </span><span class="s2">*</span><span class="s4">\n   </span><span class="s2">* Fields on the {@link LRUCache.SetOptions} options param will override</span><span class="s4">\n   </span><span class="s2">* their corresponding values in the constructor options for the scope</span><span class="s4">\n   </span><span class="s2">* of this single `set()` operation.</span><span class="s4">\n   </span><span class="s2">*</span><span class="s4">\n   </span><span class="s2">* If `start` is provided, then that will set the effective start</span><span class="s4">\n   </span><span class="s2">* time for the TTL calculation. Note that this must be a previous</span><span class="s4">\n   </span><span class="s2">* value of `performance.now()` if supported, or a previous value of</span><span class="s4">\n   </span><span class="s2">* `Date.now()` if not.</span><span class="s4">\n   </span><span class="s2">*</span><span class="s4">\n   </span><span class="s2">* Options object may also include `size`, which will prevent</span><span class="s4">\n   </span><span class="s2">* calling the `sizeCalculation` function and just use the specified</span><span class="s4">\n   </span><span class="s2">* number if it is a positive integer, and `noDisposeOnSet` which</span><span class="s4">\n   </span><span class="s2">* will prevent calling a `dispose` function in the case of</span><span class="s4">\n   </span><span class="s2">* overwrites.</span><span class="s4">\n   </span><span class="s2">*</span><span class="s4">\n   </span><span class="s2">* If the `size` (or return value of `sizeCalculation`) for a given</span><span class="s4">\n   </span><span class="s2">* entry is greater than `maxEntrySize`, then the item will not be</span><span class="s4">\n   </span><span class="s2">* added to the cache.</span><span class="s4">\n   </span><span class="s2">*</span><span class="s4">\n   </span><span class="s2">* Will update the recency of the entry.</span><span class="s4">\n   </span><span class="s2">*</span><span class="s4">\n   </span><span class="s2">* If the value is `undefined`, then this is an alias for</span><span class="s4">\n   </span><span class="s2">* `cache.delete(key)`. `undefined` is never stored in the cache.</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">set(</span><span class="s4">\n    </span><span class="s2">k: K,</span><span class="s4">\n    </span><span class="s2">v: V | BackgroundFetch&lt;V&gt; | undefined,</span><span class="s4">\n    </span><span class="s2">setOptions: LRUCache.SetOptions&lt;K, V, FC&gt; = {}</span><span class="s4">\n  </span><span class="s2">) {</span><span class="s4">\n    </span><span class="s2">if (v === undefined) {</span><span class="s4">\n      </span><span class="s2">this.delete(k)</span><span class="s4">\n      </span><span class="s2">return this</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n    </span><span class="s2">const {</span><span class="s4">\n      </span><span class="s2">ttl = this.ttl,</span><span class="s4">\n      </span><span class="s2">start,</span><span class="s4">\n      </span><span class="s2">noDisposeOnSet = this.noDisposeOnSet,</span><span class="s4">\n      </span><span class="s2">sizeCalculation = this.sizeCalculation,</span><span class="s4">\n      </span><span class="s2">status,</span><span class="s4">\n    </span><span class="s2">} = setOptions</span><span class="s4">\n    </span><span class="s2">let { noUpdateTTL = this.noUpdateTTL } = setOptions</span><span class="s4">\n\n    </span><span class="s2">const size = this.#requireSize(</span><span class="s4">\n      </span><span class="s2">k,</span><span class="s4">\n      </span><span class="s2">v,</span><span class="s4">\n      </span><span class="s2">setOptions.size || 0,</span><span class="s4">\n      </span><span class="s2">sizeCalculation</span><span class="s4">\n    </span><span class="s2">)</span><span class="s4">\n    </span><span class="s2">// if the item doesn't fit, don't do anything</span><span class="s4">\n    </span><span class="s2">// NB: maxEntrySize set to maxSize by default</span><span class="s4">\n    </span><span class="s2">if (this.maxEntrySize &amp;&amp; size &gt; this.maxEntrySize) {</span><span class="s4">\n      </span><span class="s2">if (status) {</span><span class="s4">\n        </span><span class="s2">status.set = 'miss'</span><span class="s4">\n        </span><span class="s2">status.maxEntrySizeExceeded = true</span><span class="s4">\n      </span><span class="s2">}</span><span class="s4">\n      </span><span class="s2">// have to delete, in case something is there already.</span><span class="s4">\n      </span><span class="s2">this.#delete(k, 'set')</span><span class="s4">\n      </span><span class="s2">return this</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n    </span><span class="s2">let index = this.#size === 0 ? undefined : this.#keyMap.get(k)</span><span class="s4">\n    </span><span class="s2">if (index === undefined) {</span><span class="s4">\n      </span><span class="s2">// addition</span><span class="s4">\n      </span><span class="s2">index = (</span><span class="s4">\n        </span><span class="s2">this.#size === 0</span><span class="s4">\n          </span><span class="s2">? this.#tail</span><span class="s4">\n          </span><span class="s2">: this.#free.length !== 0</span><span class="s4">\n          </span><span class="s2">? this.#free.pop()</span><span class="s4">\n          </span><span class="s2">: this.#size === this.#max</span><span class="s4">\n          </span><span class="s2">? this.#evict(false)</span><span class="s4">\n          </span><span class="s2">: this.#size</span><span class="s4">\n      </span><span class="s2">) as Index</span><span class="s4">\n      </span><span class="s2">this.#keyList[index] = k</span><span class="s4">\n      </span><span class="s2">this.#valList[index] = v</span><span class="s4">\n      </span><span class="s2">this.#keyMap.set(k, index)</span><span class="s4">\n      </span><span class="s2">this.#next[this.#tail] = index</span><span class="s4">\n      </span><span class="s2">this.#prev[index] = this.#tail</span><span class="s4">\n      </span><span class="s2">this.#tail = index</span><span class="s4">\n      </span><span class="s2">this.#size++</span><span class="s4">\n      </span><span class="s2">this.#addItemSize(index, size, status)</span><span class="s4">\n      </span><span class="s2">if (status) status.set = 'add'</span><span class="s4">\n      </span><span class="s2">noUpdateTTL = false</span><span class="s4">\n    </span><span class="s2">} else {</span><span class="s4">\n      </span><span class="s2">// update</span><span class="s4">\n      </span><span class="s2">this.#moveToTail(index)</span><span class="s4">\n      </span><span class="s2">const oldVal = this.#valList[index] as V | BackgroundFetch&lt;V&gt;</span><span class="s4">\n      </span><span class="s2">if (v !== oldVal) {</span><span class="s4">\n        </span><span class="s2">if (this.#hasFetchMethod &amp;&amp; this.#isBackgroundFetch(oldVal)) {</span><span class="s4">\n          </span><span class="s2">oldVal.__abortController.abort(new Error('replaced'))</span><span class="s4">\n          </span><span class="s2">const { __staleWhileFetching: s } = oldVal</span><span class="s4">\n          </span><span class="s2">if (s !== undefined &amp;&amp; !noDisposeOnSet) {</span><span class="s4">\n            </span><span class="s2">if (this.#hasDispose) {</span><span class="s4">\n              </span><span class="s2">this.#dispose?.(s as V, k, 'set')</span><span class="s4">\n            </span><span class="s2">}</span><span class="s4">\n            </span><span class="s2">if (this.#hasDisposeAfter) {</span><span class="s4">\n              </span><span class="s2">this.#disposed?.push([s as V, k, 'set'])</span><span class="s4">\n            </span><span class="s2">}</span><span class="s4">\n          </span><span class="s2">}</span><span class="s4">\n        </span><span class="s2">} else if (!noDisposeOnSet) {</span><span class="s4">\n          </span><span class="s2">if (this.#hasDispose) {</span><span class="s4">\n            </span><span class="s2">this.#dispose?.(oldVal as V, k, 'set')</span><span class="s4">\n          </span><span class="s2">}</span><span class="s4">\n          </span><span class="s2">if (this.#hasDisposeAfter) {</span><span class="s4">\n            </span><span class="s2">this.#disposed?.push([oldVal as V, k, 'set'])</span><span class="s4">\n          </span><span class="s2">}</span><span class="s4">\n        </span><span class="s2">}</span><span class="s4">\n        </span><span class="s2">this.#removeItemSize(index)</span><span class="s4">\n        </span><span class="s2">this.#addItemSize(index, size, status)</span><span class="s4">\n        </span><span class="s2">this.#valList[index] = v</span><span class="s4">\n        </span><span class="s2">if (status) {</span><span class="s4">\n          </span><span class="s2">status.set = 'replace'</span><span class="s4">\n          </span><span class="s2">const oldValue =</span><span class="s4">\n            </span><span class="s2">oldVal &amp;&amp; this.#isBackgroundFetch(oldVal)</span><span class="s4">\n              </span><span class="s2">? oldVal.__staleWhileFetching</span><span class="s4">\n              </span><span class="s2">: oldVal</span><span class="s4">\n          </span><span class="s2">if (oldValue !== undefined) status.oldValue = oldValue</span><span class="s4">\n        </span><span class="s2">}</span><span class="s4">\n      </span><span class="s2">} else if (status) {</span><span class="s4">\n        </span><span class="s2">status.set = 'update'</span><span class="s4">\n      </span><span class="s2">}</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n    </span><span class="s2">if (ttl !== 0 &amp;&amp; !this.#ttls) {</span><span class="s4">\n      </span><span class="s2">this.#initializeTTLTracking()</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n    </span><span class="s2">if (this.#ttls) {</span><span class="s4">\n      </span><span class="s2">if (!noUpdateTTL) {</span><span class="s4">\n        </span><span class="s2">this.#setItemTTL(index, ttl, start)</span><span class="s4">\n      </span><span class="s2">}</span><span class="s4">\n      </span><span class="s2">if (status) this.#statusTTL(status, index)</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n    </span><span class="s2">if (!noDisposeOnSet &amp;&amp; this.#hasDisposeAfter &amp;&amp; this.#disposed) {</span><span class="s4">\n      </span><span class="s2">const dt = this.#disposed</span><span class="s4">\n      </span><span class="s2">let task: DisposeTask&lt;K, V&gt; | undefined</span><span class="s4">\n      </span><span class="s2">while ((task = dt?.shift())) {</span><span class="s4">\n        </span><span class="s2">this.#disposeAfter?.(...task)</span><span class="s4">\n      </span><span class="s2">}</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n    </span><span class="s2">return this</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* Evict the least recently used item, returning its value or</span><span class="s4">\n   </span><span class="s2">* `undefined` if cache is empty.</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">pop(): V | undefined {</span><span class="s4">\n    </span><span class="s2">try {</span><span class="s4">\n      </span><span class="s2">while (this.#size) {</span><span class="s4">\n        </span><span class="s2">const val = this.#valList[this.#head]</span><span class="s4">\n        </span><span class="s2">this.#evict(true)</span><span class="s4">\n        </span><span class="s2">if (this.#isBackgroundFetch(val)) {</span><span class="s4">\n          </span><span class="s2">if (val.__staleWhileFetching) {</span><span class="s4">\n            </span><span class="s2">return val.__staleWhileFetching</span><span class="s4">\n          </span><span class="s2">}</span><span class="s4">\n        </span><span class="s2">} else if (val !== undefined) {</span><span class="s4">\n          </span><span class="s2">return val</span><span class="s4">\n        </span><span class="s2">}</span><span class="s4">\n      </span><span class="s2">}</span><span class="s4">\n    </span><span class="s2">} finally {</span><span class="s4">\n      </span><span class="s2">if (this.#hasDisposeAfter &amp;&amp; this.#disposed) {</span><span class="s4">\n        </span><span class="s2">const dt = this.#disposed</span><span class="s4">\n        </span><span class="s2">let task: DisposeTask&lt;K, V&gt; | undefined</span><span class="s4">\n        </span><span class="s2">while ((task = dt?.shift())) {</span><span class="s4">\n          </span><span class="s2">this.#disposeAfter?.(...task)</span><span class="s4">\n        </span><span class="s2">}</span><span class="s4">\n      </span><span class="s2">}</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n\n  </span><span class="s2">#evict(free: boolean) {</span><span class="s4">\n    </span><span class="s2">const head = this.#head</span><span class="s4">\n    </span><span class="s2">const k = this.#keyList[head] as K</span><span class="s4">\n    </span><span class="s2">const v = this.#valList[head] as V</span><span class="s4">\n    </span><span class="s2">if (this.#hasFetchMethod &amp;&amp; this.#isBackgroundFetch(v)) {</span><span class="s4">\n      </span><span class="s2">v.__abortController.abort(new Error('evicted'))</span><span class="s4">\n    </span><span class="s2">} else if (this.#hasDispose || this.#hasDisposeAfter) {</span><span class="s4">\n      </span><span class="s2">if (this.#hasDispose) {</span><span class="s4">\n        </span><span class="s2">this.#dispose?.(v, k, 'evict')</span><span class="s4">\n      </span><span class="s2">}</span><span class="s4">\n      </span><span class="s2">if (this.#hasDisposeAfter) {</span><span class="s4">\n        </span><span class="s2">this.#disposed?.push([v, k, 'evict'])</span><span class="s4">\n      </span><span class="s2">}</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n    </span><span class="s2">this.#removeItemSize(head)</span><span class="s4">\n    </span><span class="s2">// if we aren't about to use the index, then null these out</span><span class="s4">\n    </span><span class="s2">if (free) {</span><span class="s4">\n      </span><span class="s2">this.#keyList[head] = undefined</span><span class="s4">\n      </span><span class="s2">this.#valList[head] = undefined</span><span class="s4">\n      </span><span class="s2">this.#free.push(head)</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n    </span><span class="s2">if (this.#size === 1) {</span><span class="s4">\n      </span><span class="s2">this.#head = this.#tail = 0 as Index</span><span class="s4">\n      </span><span class="s2">this.#free.length = 0</span><span class="s4">\n    </span><span class="s2">} else {</span><span class="s4">\n      </span><span class="s2">this.#head = this.#next[head] as Index</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n    </span><span class="s2">this.#keyMap.delete(k)</span><span class="s4">\n    </span><span class="s2">this.#size--</span><span class="s4">\n    </span><span class="s2">return head</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* Check if a key is in the cache, without updating the recency of use.</span><span class="s4">\n   </span><span class="s2">* Will return false if the item is stale, even though it is technically</span><span class="s4">\n   </span><span class="s2">* in the cache.</span><span class="s4">\n   </span><span class="s2">*</span><span class="s4">\n   </span><span class="s2">* Check if a key is in the cache, without updating the recency of</span><span class="s4">\n   </span><span class="s2">* use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set</span><span class="s4">\n   </span><span class="s2">* to `true` in either the options or the constructor.</span><span class="s4">\n   </span><span class="s2">*</span><span class="s4">\n   </span><span class="s2">* Will return `false` if the item is stale, even though it is technically in</span><span class="s4">\n   </span><span class="s2">* the cache. The difference can be determined (if it matters) by using a</span><span class="s4">\n   </span><span class="s2">* `status` argument, and inspecting the `has` field.</span><span class="s4">\n   </span><span class="s2">*</span><span class="s4">\n   </span><span class="s2">* Will not update item age unless</span><span class="s4">\n   </span><span class="s2">* {@link LRUCache.OptionsBase.updateAgeOnHas} is set.</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">has(k: K, hasOptions: LRUCache.HasOptions&lt;K, V, FC&gt; = {}) {</span><span class="s4">\n    </span><span class="s2">const { updateAgeOnHas = this.updateAgeOnHas, status } =</span><span class="s4">\n      </span><span class="s2">hasOptions</span><span class="s4">\n    </span><span class="s2">const index = this.#keyMap.get(k)</span><span class="s4">\n    </span><span class="s2">if (index !== undefined) {</span><span class="s4">\n      </span><span class="s2">const v = this.#valList[index]</span><span class="s4">\n      </span><span class="s2">if (</span><span class="s4">\n        </span><span class="s2">this.#isBackgroundFetch(v) &amp;&amp;</span><span class="s4">\n        </span><span class="s2">v.__staleWhileFetching === undefined</span><span class="s4">\n      </span><span class="s2">) {</span><span class="s4">\n        </span><span class="s2">return false</span><span class="s4">\n      </span><span class="s2">}</span><span class="s4">\n      </span><span class="s2">if (!this.#isStale(index)) {</span><span class="s4">\n        </span><span class="s2">if (updateAgeOnHas) {</span><span class="s4">\n          </span><span class="s2">this.#updateItemAge(index)</span><span class="s4">\n        </span><span class="s2">}</span><span class="s4">\n        </span><span class="s2">if (status) {</span><span class="s4">\n          </span><span class="s2">status.has = 'hit'</span><span class="s4">\n          </span><span class="s2">this.#statusTTL(status, index)</span><span class="s4">\n        </span><span class="s2">}</span><span class="s4">\n        </span><span class="s2">return true</span><span class="s4">\n      </span><span class="s2">} else if (status) {</span><span class="s4">\n        </span><span class="s2">status.has = 'stale'</span><span class="s4">\n        </span><span class="s2">this.#statusTTL(status, index)</span><span class="s4">\n      </span><span class="s2">}</span><span class="s4">\n    </span><span class="s2">} else if (status) {</span><span class="s4">\n      </span><span class="s2">status.has = 'miss'</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n    </span><span class="s2">return false</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* Like {@link LRUCache#get} but doesn't update recency or delete stale</span><span class="s4">\n   </span><span class="s2">* items.</span><span class="s4">\n   </span><span class="s2">*</span><span class="s4">\n   </span><span class="s2">* Returns `undefined` if the item is stale, unless</span><span class="s4">\n   </span><span class="s2">* {@link LRUCache.OptionsBase.allowStale} is set.</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">peek(k: K, peekOptions: LRUCache.PeekOptions&lt;K, V, FC&gt; = {}) {</span><span class="s4">\n    </span><span class="s2">const { allowStale = this.allowStale } = peekOptions</span><span class="s4">\n    </span><span class="s2">const index = this.#keyMap.get(k)</span><span class="s4">\n    </span><span class="s2">if (</span><span class="s4">\n      </span><span class="s2">index === undefined ||</span><span class="s4">\n      </span><span class="s2">(!allowStale &amp;&amp; this.#isStale(index))</span><span class="s4">\n    </span><span class="s2">) {</span><span class="s4">\n      </span><span class="s2">return</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n    </span><span class="s2">const v = this.#valList[index]</span><span class="s4">\n    </span><span class="s2">// either stale and allowed, or forcing a refresh of non-stale value</span><span class="s4">\n    </span><span class="s2">return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n\n  </span><span class="s2">#backgroundFetch(</span><span class="s4">\n    </span><span class="s2">k: K,</span><span class="s4">\n    </span><span class="s2">index: Index | undefined,</span><span class="s4">\n    </span><span class="s2">options: LRUCache.FetchOptions&lt;K, V, FC&gt;,</span><span class="s4">\n    </span><span class="s2">context: any</span><span class="s4">\n  </span><span class="s2">): BackgroundFetch&lt;V&gt; {</span><span class="s4">\n    </span><span class="s2">const v = index === undefined ? undefined : this.#valList[index]</span><span class="s4">\n    </span><span class="s2">if (this.#isBackgroundFetch(v)) {</span><span class="s4">\n      </span><span class="s2">return v</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n\n    </span><span class="s2">const ac = new AC()</span><span class="s4">\n    </span><span class="s2">const { signal } = options</span><span class="s4">\n    </span><span class="s2">// when/if our AC signals, then stop listening to theirs.</span><span class="s4">\n    </span><span class="s2">signal?.addEventListener('abort', () =&gt; ac.abort(signal.reason), {</span><span class="s4">\n      </span><span class="s2">signal: ac.signal,</span><span class="s4">\n    </span><span class="s2">})</span><span class="s4">\n\n    </span><span class="s2">const fetchOpts = {</span><span class="s4">\n      </span><span class="s2">signal: ac.signal,</span><span class="s4">\n      </span><span class="s2">options,</span><span class="s4">\n      </span><span class="s2">context,</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n\n    </span><span class="s2">const cb = (</span><span class="s4">\n      </span><span class="s2">v: V | undefined,</span><span class="s4">\n      </span><span class="s2">updateCache = false</span><span class="s4">\n    </span><span class="s2">): V | undefined =&gt; {</span><span class="s4">\n      </span><span class="s2">const { aborted } = ac.signal</span><span class="s4">\n      </span><span class="s2">const ignoreAbort = options.ignoreFetchAbort &amp;&amp; v !== undefined</span><span class="s4">\n      </span><span class="s2">if (options.status) {</span><span class="s4">\n        </span><span class="s2">if (aborted &amp;&amp; !updateCache) {</span><span class="s4">\n          </span><span class="s2">options.status.fetchAborted = true</span><span class="s4">\n          </span><span class="s2">options.status.fetchError = ac.signal.reason</span><span class="s4">\n          </span><span class="s2">if (ignoreAbort) options.status.fetchAbortIgnored = true</span><span class="s4">\n        </span><span class="s2">} else {</span><span class="s4">\n          </span><span class="s2">options.status.fetchResolved = true</span><span class="s4">\n        </span><span class="s2">}</span><span class="s4">\n      </span><span class="s2">}</span><span class="s4">\n      </span><span class="s2">if (aborted &amp;&amp; !ignoreAbort &amp;&amp; !updateCache) {</span><span class="s4">\n        </span><span class="s2">return fetchFail(ac.signal.reason)</span><span class="s4">\n      </span><span class="s2">}</span><span class="s4">\n      </span><span class="s2">// either we didn't abort, and are still here, or we did, and ignored</span><span class="s4">\n      </span><span class="s2">const bf = p as BackgroundFetch&lt;V&gt;</span><span class="s4">\n      </span><span class="s2">if (this.#valList[index as Index] === p) {</span><span class="s4">\n        </span><span class="s2">if (v === undefined) {</span><span class="s4">\n          </span><span class="s2">if (bf.__staleWhileFetching) {</span><span class="s4">\n            </span><span class="s2">this.#valList[index as Index] = bf.__staleWhileFetching</span><span class="s4">\n          </span><span class="s2">} else {</span><span class="s4">\n            </span><span class="s2">this.#delete(k, 'fetch')</span><span class="s4">\n          </span><span class="s2">}</span><span class="s4">\n        </span><span class="s2">} else {</span><span class="s4">\n          </span><span class="s2">if (options.status) options.status.fetchUpdated = true</span><span class="s4">\n          </span><span class="s2">this.set(k, v, fetchOpts.options)</span><span class="s4">\n        </span><span class="s2">}</span><span class="s4">\n      </span><span class="s2">}</span><span class="s4">\n      </span><span class="s2">return v</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n\n    </span><span class="s2">const eb = (er: any) =&gt; {</span><span class="s4">\n      </span><span class="s2">if (options.status) {</span><span class="s4">\n        </span><span class="s2">options.status.fetchRejected = true</span><span class="s4">\n        </span><span class="s2">options.status.fetchError = er</span><span class="s4">\n      </span><span class="s2">}</span><span class="s4">\n      </span><span class="s2">return fetchFail(er)</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n\n    </span><span class="s2">const fetchFail = (er: any): V | undefined =&gt; {</span><span class="s4">\n      </span><span class="s2">const { aborted } = ac.signal</span><span class="s4">\n      </span><span class="s2">const allowStaleAborted =</span><span class="s4">\n        </span><span class="s2">aborted &amp;&amp; options.allowStaleOnFetchAbort</span><span class="s4">\n      </span><span class="s2">const allowStale =</span><span class="s4">\n        </span><span class="s2">allowStaleAborted || options.allowStaleOnFetchRejection</span><span class="s4">\n      </span><span class="s2">const noDelete = allowStale || options.noDeleteOnFetchRejection</span><span class="s4">\n      </span><span class="s2">const bf = p as BackgroundFetch&lt;V&gt;</span><span class="s4">\n      </span><span class="s2">if (this.#valList[index as Index] === p) {</span><span class="s4">\n        </span><span class="s2">// if we allow stale on fetch rejections, then we need to ensure that</span><span class="s4">\n        </span><span class="s2">// the stale value is not removed from the cache when the fetch fails.</span><span class="s4">\n        </span><span class="s2">const del = !noDelete || bf.__staleWhileFetching === undefined</span><span class="s4">\n        </span><span class="s2">if (del) {</span><span class="s4">\n          </span><span class="s2">this.#delete(k, 'fetch')</span><span class="s4">\n        </span><span class="s2">} else if (!allowStaleAborted) {</span><span class="s4">\n          </span><span class="s2">// still replace the *promise* with the stale value,</span><span class="s4">\n          </span><span class="s2">// since we are done with the promise at this point.</span><span class="s4">\n          </span><span class="s2">// leave it untouched if we're still waiting for an</span><span class="s4">\n          </span><span class="s2">// aborted background fetch that hasn't yet returned.</span><span class="s4">\n          </span><span class="s2">this.#valList[index as Index] = bf.__staleWhileFetching</span><span class="s4">\n        </span><span class="s2">}</span><span class="s4">\n      </span><span class="s2">}</span><span class="s4">\n      </span><span class="s2">if (allowStale) {</span><span class="s4">\n        </span><span class="s2">if (options.status &amp;&amp; bf.__staleWhileFetching !== undefined) {</span><span class="s4">\n          </span><span class="s2">options.status.returnedStale = true</span><span class="s4">\n        </span><span class="s2">}</span><span class="s4">\n        </span><span class="s2">return bf.__staleWhileFetching</span><span class="s4">\n      </span><span class="s2">} else if (bf.__returned === bf) {</span><span class="s4">\n        </span><span class="s2">throw er</span><span class="s4">\n      </span><span class="s2">}</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n\n    </span><span class="s2">const pcall = (</span><span class="s4">\n      </span><span class="s2">res: (v: V | undefined) =&gt; void,</span><span class="s4">\n      </span><span class="s2">rej: (e: any) =&gt; void</span><span class="s4">\n    </span><span class="s2">) =&gt; {</span><span class="s4">\n      </span><span class="s2">const fmp = this.#fetchMethod?.(k, v, fetchOpts)</span><span class="s4">\n      </span><span class="s2">if (fmp &amp;&amp; fmp instanceof Promise) {</span><span class="s4">\n        </span><span class="s2">fmp.then(v =&gt; res(v === undefined ? undefined : v), rej)</span><span class="s4">\n      </span><span class="s2">}</span><span class="s4">\n      </span><span class="s2">// ignored, we go until we finish, regardless.</span><span class="s4">\n      </span><span class="s2">// defer check until we are actually aborting,</span><span class="s4">\n      </span><span class="s2">// so fetchMethod can override.</span><span class="s4">\n      </span><span class="s2">ac.signal.addEventListener('abort', () =&gt; {</span><span class="s4">\n        </span><span class="s2">if (</span><span class="s4">\n          </span><span class="s2">!options.ignoreFetchAbort ||</span><span class="s4">\n          </span><span class="s2">options.allowStaleOnFetchAbort</span><span class="s4">\n        </span><span class="s2">) {</span><span class="s4">\n          </span><span class="s2">res(undefined)</span><span class="s4">\n          </span><span class="s2">// when it eventually resolves, update the cache.</span><span class="s4">\n          </span><span class="s2">if (options.allowStaleOnFetchAbort) {</span><span class="s4">\n            </span><span class="s2">res = v =&gt; cb(v, true)</span><span class="s4">\n          </span><span class="s2">}</span><span class="s4">\n        </span><span class="s2">}</span><span class="s4">\n      </span><span class="s2">})</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n\n    </span><span class="s2">if (options.status) options.status.fetchDispatched = true</span><span class="s4">\n    </span><span class="s2">const p = new Promise(pcall).then(cb, eb)</span><span class="s4">\n    </span><span class="s2">const bf: BackgroundFetch&lt;V&gt; = Object.assign(p, {</span><span class="s4">\n      </span><span class="s2">__abortController: ac,</span><span class="s4">\n      </span><span class="s2">__staleWhileFetching: v,</span><span class="s4">\n      </span><span class="s2">__returned: undefined,</span><span class="s4">\n    </span><span class="s2">})</span><span class="s4">\n\n    </span><span class="s2">if (index === undefined) {</span><span class="s4">\n      </span><span class="s2">// internal, don't expose status.</span><span class="s4">\n      </span><span class="s2">this.set(k, bf, { ...fetchOpts.options, status: undefined })</span><span class="s4">\n      </span><span class="s2">index = this.#keyMap.get(k)</span><span class="s4">\n    </span><span class="s2">} else {</span><span class="s4">\n      </span><span class="s2">this.#valList[index] = bf</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n    </span><span class="s2">return bf</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n\n  </span><span class="s2">#isBackgroundFetch(p: any): p is BackgroundFetch&lt;V&gt; {</span><span class="s4">\n    </span><span class="s2">if (!this.#hasFetchMethod) return false</span><span class="s4">\n    </span><span class="s2">const b = p as BackgroundFetch&lt;V&gt;</span><span class="s4">\n    </span><span class="s2">return (</span><span class="s4">\n      </span><span class="s2">!!b &amp;&amp;</span><span class="s4">\n      </span><span class="s2">b instanceof Promise &amp;&amp;</span><span class="s4">\n      </span><span class="s2">b.hasOwnProperty('__staleWhileFetching') &amp;&amp;</span><span class="s4">\n      </span><span class="s2">b.__abortController instanceof AC</span><span class="s4">\n    </span><span class="s2">)</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* Make an asynchronous cached fetch using the</span><span class="s4">\n   </span><span class="s2">* {@link LRUCache.OptionsBase.fetchMethod} function.</span><span class="s4">\n   </span><span class="s2">*</span><span class="s4">\n   </span><span class="s2">* If the value is in the cache and not stale, then the returned</span><span class="s4">\n   </span><span class="s2">* Promise resolves to the value.</span><span class="s4">\n   </span><span class="s2">*</span><span class="s4">\n   </span><span class="s2">* If not in the cache, or beyond its TTL staleness, then</span><span class="s4">\n   </span><span class="s2">* `fetchMethod(key, staleValue, { options, signal, context })` is</span><span class="s4">\n   </span><span class="s2">* called, and the value returned will be added to the cache once</span><span class="s4">\n   </span><span class="s2">* resolved.</span><span class="s4">\n   </span><span class="s2">*</span><span class="s4">\n   </span><span class="s2">* If called with `allowStale`, and an asynchronous fetch is</span><span class="s4">\n   </span><span class="s2">* currently in progress to reload a stale value, then the former</span><span class="s4">\n   </span><span class="s2">* stale value will be returned.</span><span class="s4">\n   </span><span class="s2">*</span><span class="s4">\n   </span><span class="s2">* If called with `forceRefresh`, then the cached item will be</span><span class="s4">\n   </span><span class="s2">* re-fetched, even if it is not stale. However, if `allowStale` is also</span><span class="s4">\n   </span><span class="s2">* set, then the old value will still be returned. This is useful</span><span class="s4">\n   </span><span class="s2">* in cases where you want to force a reload of a cached value. If</span><span class="s4">\n   </span><span class="s2">* a background fetch is already in progress, then `forceRefresh`</span><span class="s4">\n   </span><span class="s2">* has no effect.</span><span class="s4">\n   </span><span class="s2">*</span><span class="s4">\n   </span><span class="s2">* If multiple fetches for the same key are issued, then they will all be</span><span class="s4">\n   </span><span class="s2">* coalesced into a single call to fetchMethod.</span><span class="s4">\n   </span><span class="s2">*</span><span class="s4">\n   </span><span class="s2">* Note that this means that handling options such as</span><span class="s4">\n   </span><span class="s2">* {@link LRUCache.OptionsBase.allowStaleOnFetchAbort},</span><span class="s4">\n   </span><span class="s2">* {@link LRUCache.FetchOptions.signal},</span><span class="s4">\n   </span><span class="s2">* and {@link LRUCache.OptionsBase.allowStaleOnFetchRejection} will be</span><span class="s4">\n   </span><span class="s2">* determined by the FIRST fetch() call for a given key.</span><span class="s4">\n   </span><span class="s2">*</span><span class="s4">\n   </span><span class="s2">* This is a known (fixable) shortcoming which will be addresed on when</span><span class="s4">\n   </span><span class="s2">* someone complains about it, as the fix would involve added complexity and</span><span class="s4">\n   </span><span class="s2">* may not be worth the costs for this edge case.</span><span class="s4">\n   </span><span class="s2">*</span><span class="s4">\n   </span><span class="s2">* If {@link LRUCache.OptionsBase.fetchMethod} is not specified, then this is</span><span class="s4">\n   </span><span class="s2">* effectively an alias for `Promise.resolve(cache.get(key))`.</span><span class="s4">\n   </span><span class="s2">*</span><span class="s4">\n   </span><span class="s2">* When the fetch method resolves to a value, if the fetch has not</span><span class="s4">\n   </span><span class="s2">* been aborted due to deletion, eviction, or being overwritten,</span><span class="s4">\n   </span><span class="s2">* then it is added to the cache using the options provided.</span><span class="s4">\n   </span><span class="s2">*</span><span class="s4">\n   </span><span class="s2">* If the key is evicted or deleted before the `fetchMethod`</span><span class="s4">\n   </span><span class="s2">* resolves, then the AbortSignal passed to the `fetchMethod` will</span><span class="s4">\n   </span><span class="s2">* receive an `abort` event, and the promise returned by `fetch()`</span><span class="s4">\n   </span><span class="s2">* will reject with the reason for the abort.</span><span class="s4">\n   </span><span class="s2">*</span><span class="s4">\n   </span><span class="s2">* If a `signal` is passed to the `fetch()` call, then aborting the</span><span class="s4">\n   </span><span class="s2">* signal will abort the fetch and cause the `fetch()` promise to</span><span class="s4">\n   </span><span class="s2">* reject with the reason provided.</span><span class="s4">\n   </span><span class="s2">*</span><span class="s4">\n   </span><span class="s2">* **Setting `context`**</span><span class="s4">\n   </span><span class="s2">*</span><span class="s4">\n   </span><span class="s2">* If an `FC` type is set to a type other than `unknown`, `void`, or</span><span class="s4">\n   </span><span class="s2">* `undefined` in the {@link LRUCache} constructor, then all</span><span class="s4">\n   </span><span class="s2">* calls to `cache.fetch()` _must_ provide a `context` option. If</span><span class="s4">\n   </span><span class="s2">* set to `undefined` or `void`, then calls to fetch _must not_</span><span class="s4">\n   </span><span class="s2">* provide a `context` option.</span><span class="s4">\n   </span><span class="s2">*</span><span class="s4">\n   </span><span class="s2">* The `context` param allows you to provide arbitrary data that</span><span class="s4">\n   </span><span class="s2">* might be relevant in the course of fetching the data. It is only</span><span class="s4">\n   </span><span class="s2">* relevant for the course of a single `fetch()` operation, and</span><span class="s4">\n   </span><span class="s2">* discarded afterwards.</span><span class="s4">\n   </span><span class="s2">*</span><span class="s4">\n   </span><span class="s2">* **Note: `fetch()` calls are inflight-unique**</span><span class="s4">\n   </span><span class="s2">*</span><span class="s4">\n   </span><span class="s2">* If you call `fetch()` multiple times with the same key value,</span><span class="s4">\n   </span><span class="s2">* then every call after the first will resolve on the same</span><span class="s4">\n   </span><span class="s2">* promise&lt;sup&gt;1&lt;/sup&gt;,</span><span class="s4">\n   </span><span class="s2">* _even if they have different settings that would otherwise change</span><span class="s4">\n   </span><span class="s2">* the behavior of the fetch_, such as `noDeleteOnFetchRejection`</span><span class="s4">\n   </span><span class="s2">* or `ignoreFetchAbort`.</span><span class="s4">\n   </span><span class="s2">*</span><span class="s4">\n   </span><span class="s2">* In most cases, this is not a problem (in fact, only fetching</span><span class="s4">\n   </span><span class="s2">* something once is what you probably want, if you're caching in</span><span class="s4">\n   </span><span class="s2">* the first place). If you are changing the fetch() options</span><span class="s4">\n   </span><span class="s2">* dramatically between runs, there's a good chance that you might</span><span class="s4">\n   </span><span class="s2">* be trying to fit divergent semantics into a single object, and</span><span class="s4">\n   </span><span class="s2">* would be better off with multiple cache instances.</span><span class="s4">\n   </span><span class="s2">*</span><span class="s4">\n   </span><span class="s2">* **1**: Ie, they're not the </span><span class="s4">\&quot;</span><span class="s2">same Promise</span><span class="s4">\&quot;</span><span class="s2">, but they resolve at</span><span class="s4">\n   </span><span class="s2">* the same time, because they're both waiting on the same</span><span class="s4">\n   </span><span class="s2">* underlying fetchMethod response.</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n\n  </span><span class="s2">fetch(</span><span class="s4">\n    </span><span class="s2">k: K,</span><span class="s4">\n    </span><span class="s2">fetchOptions: unknown extends FC</span><span class="s4">\n      </span><span class="s2">? LRUCache.FetchOptions&lt;K, V, FC&gt;</span><span class="s4">\n      </span><span class="s2">: FC extends undefined | void</span><span class="s4">\n      </span><span class="s2">? LRUCache.FetchOptionsNoContext&lt;K, V&gt;</span><span class="s4">\n      </span><span class="s2">: LRUCache.FetchOptionsWithContext&lt;K, V, FC&gt;</span><span class="s4">\n  </span><span class="s2">): Promise&lt;undefined | V&gt;</span><span class="s4">\n\n  </span><span class="s2">// this overload not allowed if context is required</span><span class="s4">\n  </span><span class="s2">fetch(</span><span class="s4">\n    </span><span class="s2">k: unknown extends FC</span><span class="s4">\n      </span><span class="s2">? K</span><span class="s4">\n      </span><span class="s2">: FC extends undefined | void</span><span class="s4">\n      </span><span class="s2">? K</span><span class="s4">\n      </span><span class="s2">: never,</span><span class="s4">\n    </span><span class="s2">fetchOptions?: unknown extends FC</span><span class="s4">\n      </span><span class="s2">? LRUCache.FetchOptions&lt;K, V, FC&gt;</span><span class="s4">\n      </span><span class="s2">: FC extends undefined | void</span><span class="s4">\n      </span><span class="s2">? LRUCache.FetchOptionsNoContext&lt;K, V&gt;</span><span class="s4">\n      </span><span class="s2">: never</span><span class="s4">\n  </span><span class="s2">): Promise&lt;undefined | V&gt;</span><span class="s4">\n\n  </span><span class="s2">async fetch(</span><span class="s4">\n    </span><span class="s2">k: K,</span><span class="s4">\n    </span><span class="s2">fetchOptions: LRUCache.FetchOptions&lt;K, V, FC&gt; = {}</span><span class="s4">\n  </span><span class="s2">): Promise&lt;undefined | V&gt; {</span><span class="s4">\n    </span><span class="s2">const {</span><span class="s4">\n      </span><span class="s2">// get options</span><span class="s4">\n      </span><span class="s2">allowStale = this.allowStale,</span><span class="s4">\n      </span><span class="s2">updateAgeOnGet = this.updateAgeOnGet,</span><span class="s4">\n      </span><span class="s2">noDeleteOnStaleGet = this.noDeleteOnStaleGet,</span><span class="s4">\n      </span><span class="s2">// set options</span><span class="s4">\n      </span><span class="s2">ttl = this.ttl,</span><span class="s4">\n      </span><span class="s2">noDisposeOnSet = this.noDisposeOnSet,</span><span class="s4">\n      </span><span class="s2">size = 0,</span><span class="s4">\n      </span><span class="s2">sizeCalculation = this.sizeCalculation,</span><span class="s4">\n      </span><span class="s2">noUpdateTTL = this.noUpdateTTL,</span><span class="s4">\n      </span><span class="s2">// fetch exclusive options</span><span class="s4">\n      </span><span class="s2">noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,</span><span class="s4">\n      </span><span class="s2">allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,</span><span class="s4">\n      </span><span class="s2">ignoreFetchAbort = this.ignoreFetchAbort,</span><span class="s4">\n      </span><span class="s2">allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,</span><span class="s4">\n      </span><span class="s2">context,</span><span class="s4">\n      </span><span class="s2">forceRefresh = false,</span><span class="s4">\n      </span><span class="s2">status,</span><span class="s4">\n      </span><span class="s2">signal,</span><span class="s4">\n    </span><span class="s2">} = fetchOptions</span><span class="s4">\n\n    </span><span class="s2">if (!this.#hasFetchMethod) {</span><span class="s4">\n      </span><span class="s2">if (status) status.fetch = 'get'</span><span class="s4">\n      </span><span class="s2">return this.get(k, {</span><span class="s4">\n        </span><span class="s2">allowStale,</span><span class="s4">\n        </span><span class="s2">updateAgeOnGet,</span><span class="s4">\n        </span><span class="s2">noDeleteOnStaleGet,</span><span class="s4">\n        </span><span class="s2">status,</span><span class="s4">\n      </span><span class="s2">})</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n\n    </span><span class="s2">const options = {</span><span class="s4">\n      </span><span class="s2">allowStale,</span><span class="s4">\n      </span><span class="s2">updateAgeOnGet,</span><span class="s4">\n      </span><span class="s2">noDeleteOnStaleGet,</span><span class="s4">\n      </span><span class="s2">ttl,</span><span class="s4">\n      </span><span class="s2">noDisposeOnSet,</span><span class="s4">\n      </span><span class="s2">size,</span><span class="s4">\n      </span><span class="s2">sizeCalculation,</span><span class="s4">\n      </span><span class="s2">noUpdateTTL,</span><span class="s4">\n      </span><span class="s2">noDeleteOnFetchRejection,</span><span class="s4">\n      </span><span class="s2">allowStaleOnFetchRejection,</span><span class="s4">\n      </span><span class="s2">allowStaleOnFetchAbort,</span><span class="s4">\n      </span><span class="s2">ignoreFetchAbort,</span><span class="s4">\n      </span><span class="s2">status,</span><span class="s4">\n      </span><span class="s2">signal,</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n\n    </span><span class="s2">let index = this.#keyMap.get(k)</span><span class="s4">\n    </span><span class="s2">if (index === undefined) {</span><span class="s4">\n      </span><span class="s2">if (status) status.fetch = 'miss'</span><span class="s4">\n      </span><span class="s2">const p = this.#backgroundFetch(k, index, options, context)</span><span class="s4">\n      </span><span class="s2">return (p.__returned = p)</span><span class="s4">\n    </span><span class="s2">} else {</span><span class="s4">\n      </span><span class="s2">// in cache, maybe already fetching</span><span class="s4">\n      </span><span class="s2">const v = this.#valList[index]</span><span class="s4">\n      </span><span class="s2">if (this.#isBackgroundFetch(v)) {</span><span class="s4">\n        </span><span class="s2">const stale =</span><span class="s4">\n          </span><span class="s2">allowStale &amp;&amp; v.__staleWhileFetching !== undefined</span><span class="s4">\n        </span><span class="s2">if (status) {</span><span class="s4">\n          </span><span class="s2">status.fetch = 'inflight'</span><span class="s4">\n          </span><span class="s2">if (stale) status.returnedStale = true</span><span class="s4">\n        </span><span class="s2">}</span><span class="s4">\n        </span><span class="s2">return stale ? v.__staleWhileFetching : (v.__returned = v)</span><span class="s4">\n      </span><span class="s2">}</span><span class="s4">\n\n      </span><span class="s2">// if we force a refresh, that means do NOT serve the cached value,</span><span class="s4">\n      </span><span class="s2">// unless we are already in the process of refreshing the cache.</span><span class="s4">\n      </span><span class="s2">const isStale = this.#isStale(index)</span><span class="s4">\n      </span><span class="s2">if (!forceRefresh &amp;&amp; !isStale) {</span><span class="s4">\n        </span><span class="s2">if (status) status.fetch = 'hit'</span><span class="s4">\n        </span><span class="s2">this.#moveToTail(index)</span><span class="s4">\n        </span><span class="s2">if (updateAgeOnGet) {</span><span class="s4">\n          </span><span class="s2">this.#updateItemAge(index)</span><span class="s4">\n        </span><span class="s2">}</span><span class="s4">\n        </span><span class="s2">if (status) this.#statusTTL(status, index)</span><span class="s4">\n        </span><span class="s2">return v</span><span class="s4">\n      </span><span class="s2">}</span><span class="s4">\n\n      </span><span class="s2">// ok, it is stale or a forced refresh, and not already fetching.</span><span class="s4">\n      </span><span class="s2">// refresh the cache.</span><span class="s4">\n      </span><span class="s2">const p = this.#backgroundFetch(k, index, options, context)</span><span class="s4">\n      </span><span class="s2">const hasStale = p.__staleWhileFetching !== undefined</span><span class="s4">\n      </span><span class="s2">const staleVal = hasStale &amp;&amp; allowStale</span><span class="s4">\n      </span><span class="s2">if (status) {</span><span class="s4">\n        </span><span class="s2">status.fetch = isStale ? 'stale' : 'refresh'</span><span class="s4">\n        </span><span class="s2">if (staleVal &amp;&amp; isStale) status.returnedStale = true</span><span class="s4">\n      </span><span class="s2">}</span><span class="s4">\n      </span><span class="s2">return staleVal ? p.__staleWhileFetching : (p.__returned = p)</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* In some cases, `cache.fetch()` may resolve to `undefined`, either because</span><span class="s4">\n   </span><span class="s2">* a {@link LRUCache.OptionsBase#fetchMethod} was not provided (turning</span><span class="s4">\n   </span><span class="s2">* `cache.fetch(k)` into just an async wrapper around `cache.get(k)`) or</span><span class="s4">\n   </span><span class="s2">* because `ignoreFetchAbort` was specified (either to the constructor or</span><span class="s4">\n   </span><span class="s2">* in the {@link LRUCache.FetchOptions}). Also, the</span><span class="s4">\n   </span><span class="s2">* {@link OptionsBase.fetchMethod} may return `undefined` or `void`, making</span><span class="s4">\n   </span><span class="s2">* the test even more complicated.</span><span class="s4">\n   </span><span class="s2">*</span><span class="s4">\n   </span><span class="s2">* Because inferring the cases where `undefined` might be returned are so</span><span class="s4">\n   </span><span class="s2">* cumbersome, but testing for `undefined` can also be annoying, this method</span><span class="s4">\n   </span><span class="s2">* can be used, which will reject if `this.fetch()` resolves to undefined.</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">forceFetch(</span><span class="s4">\n    </span><span class="s2">k: K,</span><span class="s4">\n    </span><span class="s2">fetchOptions: unknown extends FC</span><span class="s4">\n      </span><span class="s2">? LRUCache.FetchOptions&lt;K, V, FC&gt;</span><span class="s4">\n      </span><span class="s2">: FC extends undefined | void</span><span class="s4">\n      </span><span class="s2">? LRUCache.FetchOptionsNoContext&lt;K, V&gt;</span><span class="s4">\n      </span><span class="s2">: LRUCache.FetchOptionsWithContext&lt;K, V, FC&gt;</span><span class="s4">\n  </span><span class="s2">): Promise&lt;V&gt;</span><span class="s4">\n  </span><span class="s2">// this overload not allowed if context is required</span><span class="s4">\n  </span><span class="s2">forceFetch(</span><span class="s4">\n    </span><span class="s2">k: unknown extends FC</span><span class="s4">\n      </span><span class="s2">? K</span><span class="s4">\n      </span><span class="s2">: FC extends undefined | void</span><span class="s4">\n      </span><span class="s2">? K</span><span class="s4">\n      </span><span class="s2">: never,</span><span class="s4">\n    </span><span class="s2">fetchOptions?: unknown extends FC</span><span class="s4">\n      </span><span class="s2">? LRUCache.FetchOptions&lt;K, V, FC&gt;</span><span class="s4">\n      </span><span class="s2">: FC extends undefined | void</span><span class="s4">\n      </span><span class="s2">? LRUCache.FetchOptionsNoContext&lt;K, V&gt;</span><span class="s4">\n      </span><span class="s2">: never</span><span class="s4">\n  </span><span class="s2">): Promise&lt;V&gt;</span><span class="s4">\n  </span><span class="s2">async forceFetch(</span><span class="s4">\n    </span><span class="s2">k: K,</span><span class="s4">\n    </span><span class="s2">fetchOptions: LRUCache.FetchOptions&lt;K, V, FC&gt; = {}</span><span class="s4">\n  </span><span class="s2">): Promise&lt;V&gt; {</span><span class="s4">\n    </span><span class="s2">const v = await this.fetch(</span><span class="s4">\n      </span><span class="s2">k,</span><span class="s4">\n      </span><span class="s2">fetchOptions as unknown extends FC</span><span class="s4">\n        </span><span class="s2">? LRUCache.FetchOptions&lt;K, V, FC&gt;</span><span class="s4">\n        </span><span class="s2">: FC extends undefined | void</span><span class="s4">\n        </span><span class="s2">? LRUCache.FetchOptionsNoContext&lt;K, V&gt;</span><span class="s4">\n        </span><span class="s2">: LRUCache.FetchOptionsWithContext&lt;K, V, FC&gt;</span><span class="s4">\n    </span><span class="s2">)</span><span class="s4">\n    </span><span class="s2">if (v === undefined) throw new Error('fetch() returned undefined')</span><span class="s4">\n    </span><span class="s2">return v</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* If the key is found in the cache, then this is equivalent to</span><span class="s4">\n   </span><span class="s2">* {@link LRUCache#get}. If not, in the cache, then calculate the value using</span><span class="s4">\n   </span><span class="s2">* the {@link LRUCache.OptionsBase.memoMethod}, and add it to the cache.</span><span class="s4">\n   </span><span class="s2">*</span><span class="s4">\n   </span><span class="s2">* If an `FC` type is set to a type other than `unknown`, `void`, or</span><span class="s4">\n   </span><span class="s2">* `undefined` in the LRUCache constructor, then all calls to `cache.memo()`</span><span class="s4">\n   </span><span class="s2">* _must_ provide a `context` option. If set to `undefined` or `void`, then</span><span class="s4">\n   </span><span class="s2">* calls to memo _must not_ provide a `context` option.</span><span class="s4">\n   </span><span class="s2">*</span><span class="s4">\n   </span><span class="s2">* The `context` param allows you to provide arbitrary data that might be</span><span class="s4">\n   </span><span class="s2">* relevant in the course of fetching the data. It is only relevant for the</span><span class="s4">\n   </span><span class="s2">* course of a single `memo()` operation, and discarded afterwards.</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">memo(</span><span class="s4">\n    </span><span class="s2">k: K,</span><span class="s4">\n    </span><span class="s2">memoOptions: unknown extends FC</span><span class="s4">\n      </span><span class="s2">? LRUCache.MemoOptions&lt;K, V, FC&gt;</span><span class="s4">\n      </span><span class="s2">: FC extends undefined | void</span><span class="s4">\n      </span><span class="s2">? LRUCache.MemoOptionsNoContext&lt;K, V&gt;</span><span class="s4">\n      </span><span class="s2">: LRUCache.MemoOptionsWithContext&lt;K, V, FC&gt;</span><span class="s4">\n  </span><span class="s2">): V</span><span class="s4">\n  </span><span class="s2">// this overload not allowed if context is required</span><span class="s4">\n  </span><span class="s2">memo(</span><span class="s4">\n    </span><span class="s2">k: unknown extends FC</span><span class="s4">\n      </span><span class="s2">? K</span><span class="s4">\n      </span><span class="s2">: FC extends undefined | void</span><span class="s4">\n      </span><span class="s2">? K</span><span class="s4">\n      </span><span class="s2">: never,</span><span class="s4">\n    </span><span class="s2">memoOptions?: unknown extends FC</span><span class="s4">\n      </span><span class="s2">? LRUCache.MemoOptions&lt;K, V, FC&gt;</span><span class="s4">\n      </span><span class="s2">: FC extends undefined | void</span><span class="s4">\n      </span><span class="s2">? LRUCache.MemoOptionsNoContext&lt;K, V&gt;</span><span class="s4">\n      </span><span class="s2">: never</span><span class="s4">\n  </span><span class="s2">): V</span><span class="s4">\n  </span><span class="s2">memo(k: K, memoOptions: LRUCache.MemoOptions&lt;K, V, FC&gt; = {}) {</span><span class="s4">\n    </span><span class="s2">const memoMethod = this.#memoMethod</span><span class="s4">\n    </span><span class="s2">if (!memoMethod) {</span><span class="s4">\n      </span><span class="s2">throw new Error('no memoMethod provided to constructor')</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n    </span><span class="s2">const { context, forceRefresh, ...options } = memoOptions</span><span class="s4">\n    </span><span class="s2">const v = this.get(k, options)</span><span class="s4">\n    </span><span class="s2">if (!forceRefresh &amp;&amp; v !== undefined) return v</span><span class="s4">\n    </span><span class="s2">const vv = memoMethod(k, v, {</span><span class="s4">\n      </span><span class="s2">options,</span><span class="s4">\n      </span><span class="s2">context,</span><span class="s4">\n    </span><span class="s2">} as LRUCache.MemoizerOptions&lt;K, V, FC&gt;)</span><span class="s4">\n    </span><span class="s2">this.set(k, vv, options)</span><span class="s4">\n    </span><span class="s2">return vv</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* Return a value from the cache. Will update the recency of the cache</span><span class="s4">\n   </span><span class="s2">* entry found.</span><span class="s4">\n   </span><span class="s2">*</span><span class="s4">\n   </span><span class="s2">* If the key is not found, get() will return `undefined`.</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">get(k: K, getOptions: LRUCache.GetOptions&lt;K, V, FC&gt; = {}) {</span><span class="s4">\n    </span><span class="s2">const {</span><span class="s4">\n      </span><span class="s2">allowStale = this.allowStale,</span><span class="s4">\n      </span><span class="s2">updateAgeOnGet = this.updateAgeOnGet,</span><span class="s4">\n      </span><span class="s2">noDeleteOnStaleGet = this.noDeleteOnStaleGet,</span><span class="s4">\n      </span><span class="s2">status,</span><span class="s4">\n    </span><span class="s2">} = getOptions</span><span class="s4">\n    </span><span class="s2">const index = this.#keyMap.get(k)</span><span class="s4">\n    </span><span class="s2">if (index !== undefined) {</span><span class="s4">\n      </span><span class="s2">const value = this.#valList[index]</span><span class="s4">\n      </span><span class="s2">const fetching = this.#isBackgroundFetch(value)</span><span class="s4">\n      </span><span class="s2">if (status) this.#statusTTL(status, index)</span><span class="s4">\n      </span><span class="s2">if (this.#isStale(index)) {</span><span class="s4">\n        </span><span class="s2">if (status) status.get = 'stale'</span><span class="s4">\n        </span><span class="s2">// delete only if not an in-flight background fetch</span><span class="s4">\n        </span><span class="s2">if (!fetching) {</span><span class="s4">\n          </span><span class="s2">if (!noDeleteOnStaleGet) {</span><span class="s4">\n            </span><span class="s2">this.#delete(k, 'expire')</span><span class="s4">\n          </span><span class="s2">}</span><span class="s4">\n          </span><span class="s2">if (status &amp;&amp; allowStale) status.returnedStale = true</span><span class="s4">\n          </span><span class="s2">return allowStale ? value : undefined</span><span class="s4">\n        </span><span class="s2">} else {</span><span class="s4">\n          </span><span class="s2">if (</span><span class="s4">\n            </span><span class="s2">status &amp;&amp;</span><span class="s4">\n            </span><span class="s2">allowStale &amp;&amp;</span><span class="s4">\n            </span><span class="s2">value.__staleWhileFetching !== undefined</span><span class="s4">\n          </span><span class="s2">) {</span><span class="s4">\n            </span><span class="s2">status.returnedStale = true</span><span class="s4">\n          </span><span class="s2">}</span><span class="s4">\n          </span><span class="s2">return allowStale ? value.__staleWhileFetching : undefined</span><span class="s4">\n        </span><span class="s2">}</span><span class="s4">\n      </span><span class="s2">} else {</span><span class="s4">\n        </span><span class="s2">if (status) status.get = 'hit'</span><span class="s4">\n        </span><span class="s2">// if we're currently fetching it, we don't actually have it yet</span><span class="s4">\n        </span><span class="s2">// it's not stale, which means this isn't a staleWhileRefetching.</span><span class="s4">\n        </span><span class="s2">// If it's not stale, and fetching, AND has a __staleWhileFetching</span><span class="s4">\n        </span><span class="s2">// value, then that means the user fetched with {forceRefresh:true},</span><span class="s4">\n        </span><span class="s2">// so it's safe to return that value.</span><span class="s4">\n        </span><span class="s2">if (fetching) {</span><span class="s4">\n          </span><span class="s2">return value.__staleWhileFetching</span><span class="s4">\n        </span><span class="s2">}</span><span class="s4">\n        </span><span class="s2">this.#moveToTail(index)</span><span class="s4">\n        </span><span class="s2">if (updateAgeOnGet) {</span><span class="s4">\n          </span><span class="s2">this.#updateItemAge(index)</span><span class="s4">\n        </span><span class="s2">}</span><span class="s4">\n        </span><span class="s2">return value</span><span class="s4">\n      </span><span class="s2">}</span><span class="s4">\n    </span><span class="s2">} else if (status) {</span><span class="s4">\n      </span><span class="s2">status.get = 'miss'</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n\n  </span><span class="s2">#connect(p: Index, n: Index) {</span><span class="s4">\n    </span><span class="s2">this.#prev[n] = p</span><span class="s4">\n    </span><span class="s2">this.#next[p] = n</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n\n  </span><span class="s2">#moveToTail(index: Index): void {</span><span class="s4">\n    </span><span class="s2">// if tail already, nothing to do</span><span class="s4">\n    </span><span class="s2">// if head, move head to next[index]</span><span class="s4">\n    </span><span class="s2">// else</span><span class="s4">\n    </span><span class="s2">//   move next[prev[index]] to next[index] (head has no prev)</span><span class="s4">\n    </span><span class="s2">//   move prev[next[index]] to prev[index]</span><span class="s4">\n    </span><span class="s2">// prev[index] = tail</span><span class="s4">\n    </span><span class="s2">// next[tail] = index</span><span class="s4">\n    </span><span class="s2">// tail = index</span><span class="s4">\n    </span><span class="s2">if (index !== this.#tail) {</span><span class="s4">\n      </span><span class="s2">if (index === this.#head) {</span><span class="s4">\n        </span><span class="s2">this.#head = this.#next[index] as Index</span><span class="s4">\n      </span><span class="s2">} else {</span><span class="s4">\n        </span><span class="s2">this.#connect(</span><span class="s4">\n          </span><span class="s2">this.#prev[index] as Index,</span><span class="s4">\n          </span><span class="s2">this.#next[index] as Index</span><span class="s4">\n        </span><span class="s2">)</span><span class="s4">\n      </span><span class="s2">}</span><span class="s4">\n      </span><span class="s2">this.#connect(this.#tail, index)</span><span class="s4">\n      </span><span class="s2">this.#tail = index</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* Deletes a key out of the cache.</span><span class="s4">\n   </span><span class="s2">*</span><span class="s4">\n   </span><span class="s2">* Returns true if the key was deleted, false otherwise.</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">delete(k: K) {</span><span class="s4">\n    </span><span class="s2">return this.#delete(k, 'delete')</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n\n  </span><span class="s2">#delete(k: K, reason: LRUCache.DisposeReason) {</span><span class="s4">\n    </span><span class="s2">let deleted = false</span><span class="s4">\n    </span><span class="s2">if (this.#size !== 0) {</span><span class="s4">\n      </span><span class="s2">const index = this.#keyMap.get(k)</span><span class="s4">\n      </span><span class="s2">if (index !== undefined) {</span><span class="s4">\n        </span><span class="s2">deleted = true</span><span class="s4">\n        </span><span class="s2">if (this.#size === 1) {</span><span class="s4">\n          </span><span class="s2">this.#clear(reason)</span><span class="s4">\n        </span><span class="s2">} else {</span><span class="s4">\n          </span><span class="s2">this.#removeItemSize(index)</span><span class="s4">\n          </span><span class="s2">const v = this.#valList[index]</span><span class="s4">\n          </span><span class="s2">if (this.#isBackgroundFetch(v)) {</span><span class="s4">\n            </span><span class="s2">v.__abortController.abort(new Error('deleted'))</span><span class="s4">\n          </span><span class="s2">} else if (this.#hasDispose || this.#hasDisposeAfter) {</span><span class="s4">\n            </span><span class="s2">if (this.#hasDispose) {</span><span class="s4">\n              </span><span class="s2">this.#dispose?.(v as V, k, reason)</span><span class="s4">\n            </span><span class="s2">}</span><span class="s4">\n            </span><span class="s2">if (this.#hasDisposeAfter) {</span><span class="s4">\n              </span><span class="s2">this.#disposed?.push([v as V, k, reason])</span><span class="s4">\n            </span><span class="s2">}</span><span class="s4">\n          </span><span class="s2">}</span><span class="s4">\n          </span><span class="s2">this.#keyMap.delete(k)</span><span class="s4">\n          </span><span class="s2">this.#keyList[index] = undefined</span><span class="s4">\n          </span><span class="s2">this.#valList[index] = undefined</span><span class="s4">\n          </span><span class="s2">if (index === this.#tail) {</span><span class="s4">\n            </span><span class="s2">this.#tail = this.#prev[index] as Index</span><span class="s4">\n          </span><span class="s2">} else if (index === this.#head) {</span><span class="s4">\n            </span><span class="s2">this.#head = this.#next[index] as Index</span><span class="s4">\n          </span><span class="s2">} else {</span><span class="s4">\n            </span><span class="s2">const pi = this.#prev[index] as number</span><span class="s4">\n            </span><span class="s2">this.#next[pi] = this.#next[index] as number</span><span class="s4">\n            </span><span class="s2">const ni = this.#next[index] as number</span><span class="s4">\n            </span><span class="s2">this.#prev[ni] = this.#prev[index] as number</span><span class="s4">\n          </span><span class="s2">}</span><span class="s4">\n          </span><span class="s2">this.#size--</span><span class="s4">\n          </span><span class="s2">this.#free.push(index)</span><span class="s4">\n        </span><span class="s2">}</span><span class="s4">\n      </span><span class="s2">}</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n    </span><span class="s2">if (this.#hasDisposeAfter &amp;&amp; this.#disposed?.length) {</span><span class="s4">\n      </span><span class="s2">const dt = this.#disposed</span><span class="s4">\n      </span><span class="s2">let task: DisposeTask&lt;K, V&gt; | undefined</span><span class="s4">\n      </span><span class="s2">while ((task = dt?.shift())) {</span><span class="s4">\n        </span><span class="s2">this.#disposeAfter?.(...task)</span><span class="s4">\n      </span><span class="s2">}</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n    </span><span class="s2">return deleted</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n\n  </span><span class="s2">/**</span><span class="s4">\n   </span><span class="s2">* Clear the cache entirely, throwing away all values.</span><span class="s4">\n   </span><span class="s2">*/</span><span class="s4">\n  </span><span class="s2">clear() {</span><span class="s4">\n    </span><span class="s2">return this.#clear('delete')</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n  </span><span class="s2">#clear(reason: LRUCache.DisposeReason) {</span><span class="s4">\n    </span><span class="s2">for (const index of this.#rindexes({ allowStale: true })) {</span><span class="s4">\n      </span><span class="s2">const v = this.#valList[index]</span><span class="s4">\n      </span><span class="s2">if (this.#isBackgroundFetch(v)) {</span><span class="s4">\n        </span><span class="s2">v.__abortController.abort(new Error('deleted'))</span><span class="s4">\n      </span><span class="s2">} else {</span><span class="s4">\n        </span><span class="s2">const k = this.#keyList[index]</span><span class="s4">\n        </span><span class="s2">if (this.#hasDispose) {</span><span class="s4">\n          </span><span class="s2">this.#dispose?.(v as V, k as K, reason)</span><span class="s4">\n        </span><span class="s2">}</span><span class="s4">\n        </span><span class="s2">if (this.#hasDisposeAfter) {</span><span class="s4">\n          </span><span class="s2">this.#disposed?.push([v as V, k as K, reason])</span><span class="s4">\n        </span><span class="s2">}</span><span class="s4">\n      </span><span class="s2">}</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n\n    </span><span class="s2">this.#keyMap.clear()</span><span class="s4">\n    </span><span class="s2">this.#valList.fill(undefined)</span><span class="s4">\n    </span><span class="s2">this.#keyList.fill(undefined)</span><span class="s4">\n    </span><span class="s2">if (this.#ttls &amp;&amp; this.#starts) {</span><span class="s4">\n      </span><span class="s2">this.#ttls.fill(0)</span><span class="s4">\n      </span><span class="s2">this.#starts.fill(0)</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n    </span><span class="s2">if (this.#sizes) {</span><span class="s4">\n      </span><span class="s2">this.#sizes.fill(0)</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n    </span><span class="s2">this.#head = 0 as Index</span><span class="s4">\n    </span><span class="s2">this.#tail = 0 as Index</span><span class="s4">\n    </span><span class="s2">this.#free.length = 0</span><span class="s4">\n    </span><span class="s2">this.#calculatedSize = 0</span><span class="s4">\n    </span><span class="s2">this.#size = 0</span><span class="s4">\n    </span><span class="s2">if (this.#hasDisposeAfter &amp;&amp; this.#disposed) {</span><span class="s4">\n      </span><span class="s2">const dt = this.#disposed</span><span class="s4">\n      </span><span class="s2">let task: DisposeTask&lt;K, V&gt; | undefined</span><span class="s4">\n      </span><span class="s2">while ((task = dt?.shift())) {</span><span class="s4">\n        </span><span class="s2">this.#disposeAfter?.(...task)</span><span class="s4">\n      </span><span class="s2">}</span><span class="s4">\n    </span><span class="s2">}</span><span class="s4">\n  </span><span class="s2">}</span><span class="s4">\n</span><span class="s2">}</span><span class="s4">\n</span><span class="s2">&quot;</span><span class="s0">],</span>
  <span class="s2">&quot;mappings&quot;</span><span class="s0">: </span><span class="s2">&quot;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&quot;</span><span class="s0">,</span>
  <span class="s2">&quot;names&quot;</span><span class="s0">: [</span><span class="s2">&quot;perf&quot;</span><span class="s0">, </span><span class="s2">&quot;warned&quot;</span><span class="s0">, </span><span class="s2">&quot;PROCESS&quot;</span><span class="s0">, </span><span class="s2">&quot;emitWarning&quot;</span><span class="s0">, </span><span class="s2">&quot;msg&quot;</span><span class="s0">, </span><span class="s2">&quot;type&quot;</span><span class="s0">, </span><span class="s2">&quot;code&quot;</span><span class="s0">, </span><span class="s2">&quot;fn&quot;</span><span class="s0">, </span><span class="s2">&quot;AC&quot;</span><span class="s0">, </span><span class="s2">&quot;AS&quot;</span><span class="s0">, </span><span class="s2">&quot;_&quot;</span><span class="s0">, </span><span class="s2">&quot;warnACPolyfill&quot;</span><span class="s0">, </span><span class="s2">&quot;reason&quot;</span><span class="s0">, </span><span class="s2">&quot;printACPolyfillWarning&quot;</span><span class="s0">, </span><span class="s2">&quot;shouldWarn&quot;</span><span class="s0">, </span><span class="s2">&quot;TYPE&quot;</span><span class="s0">, </span><span class="s2">&quot;isPosInt&quot;</span><span class="s0">, </span><span class="s2">&quot;n&quot;</span><span class="s0">, </span><span class="s2">&quot;getUintArray&quot;</span><span class="s0">, </span><span class="s2">&quot;max&quot;</span><span class="s0">, </span><span class="s2">&quot;ZeroArray&quot;</span><span class="s0">, </span><span class="s2">&quot;size&quot;</span><span class="s0">, </span><span class="s2">&quot;_Stack&quot;</span><span class="s0">, </span><span class="s2">&quot;HeapCls&quot;</span><span class="s0">, </span><span class="s2">&quot;__privateSet&quot;</span><span class="s0">, </span><span class="s2">&quot;_constructing&quot;</span><span class="s0">, </span><span class="s2">&quot;s&quot;</span><span class="s0">, </span><span class="s2">&quot;__privateGet&quot;</span><span class="s0">, </span><span class="s2">&quot;Stack&quot;</span><span class="s0">, </span><span class="s2">&quot;__privateAdd&quot;</span><span class="s0">, </span><span class="s2">&quot;LRUCache&quot;</span><span class="s0">, </span><span class="s2">&quot;#max&quot;</span><span class="s0">, </span><span class="s2">&quot;#maxSize&quot;</span><span class="s0">, </span><span class="s2">&quot;#dispose&quot;</span><span class="s0">, </span><span class="s2">&quot;#disposeAfter&quot;</span><span class="s0">, </span><span class="s2">&quot;#fetchMethod&quot;</span><span class="s0">, </span><span class="s2">&quot;#memoMethod&quot;</span><span class="s0">, </span><span class="s2">&quot;#size&quot;</span><span class="s0">, </span><span class="s2">&quot;#calculatedSize&quot;</span><span class="s0">, </span><span class="s2">&quot;#keyMap&quot;</span><span class="s0">, </span><span class="s2">&quot;#keyList&quot;</span><span class="s0">, </span><span class="s2">&quot;#valList&quot;</span><span class="s0">, </span><span class="s2">&quot;#next&quot;</span><span class="s0">, </span><span class="s2">&quot;#prev&quot;</span><span class="s0">, </span><span class="s2">&quot;#head&quot;</span><span class="s0">, </span><span class="s2">&quot;#tail&quot;</span><span class="s0">, </span><span class="s2">&quot;#free&quot;</span><span class="s0">, </span><span class="s2">&quot;#disposed&quot;</span><span class="s0">, </span><span class="s2">&quot;#sizes&quot;</span><span class="s0">, </span><span class="s2">&quot;#starts&quot;</span><span class="s0">, </span><span class="s2">&quot;#ttls&quot;</span><span class="s0">, </span><span class="s2">&quot;#hasDispose&quot;</span><span class="s0">, </span><span class="s2">&quot;#hasFetchMethod&quot;</span><span class="s0">, </span><span class="s2">&quot;#hasDisposeAfter&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s2">&quot;p&quot;</span><span class="s0">, </span><span class="s2">&quot;#isBackgroundFetch&quot;</span><span class="s0">, </span><span class="s2">&quot;k&quot;</span><span class="s0">, </span><span class="s2">&quot;index&quot;</span><span class="s0">, </span><span class="s2">&quot;options&quot;</span><span class="s0">, </span><span class="s2">&quot;context&quot;</span><span class="s0">, </span><span class="s2">&quot;#backgroundFetch&quot;</span><span class="s0">, </span><span class="s2">&quot;#moveToTail&quot;</span><span class="s0">, </span><span class="s2">&quot;#indexes&quot;</span><span class="s0">, </span><span class="s2">&quot;#rindexes&quot;</span><span class="s0">, </span><span class="s2">&quot;#isStale&quot;</span><span class="s0">, </span><span class="s2">&quot;ttl&quot;</span><span class="s0">, </span><span class="s2">&quot;ttlResolution&quot;</span><span class="s0">, </span><span class="s2">&quot;ttlAutopurge&quot;</span><span class="s0">, </span><span class="s2">&quot;updateAgeOnGet&quot;</span><span class="s0">, </span><span class="s2">&quot;updateAgeOnHas&quot;</span><span class="s0">, </span><span class="s2">&quot;allowStale&quot;</span><span class="s0">, </span><span class="s2">&quot;dispose&quot;</span><span class="s0">, </span><span class="s2">&quot;disposeAfter&quot;</span><span class="s0">, </span><span class="s2">&quot;noDisposeOnSet&quot;</span><span class="s0">, </span><span class="s2">&quot;noUpdateTTL&quot;</span><span class="s0">, </span><span class="s2">&quot;maxSize&quot;</span><span class="s0">, </span><span class="s2">&quot;maxEntrySize&quot;</span><span class="s0">, </span><span class="s2">&quot;sizeCalculation&quot;</span><span class="s0">, </span><span class="s2">&quot;fetchMethod&quot;</span><span class="s0">, </span><span class="s2">&quot;memoMethod&quot;</span><span class="s0">, </span><span class="s2">&quot;noDeleteOnFetchRejection&quot;</span><span class="s0">, </span><span class="s2">&quot;noDeleteOnStaleGet&quot;</span><span class="s0">, </span><span class="s2">&quot;allowStaleOnFetchRejection&quot;</span><span class="s0">, </span><span class="s2">&quot;allowStaleOnFetchAbort&quot;</span><span class="s0">, </span><span class="s2">&quot;ignoreFetchAbort&quot;</span><span class="s0">, </span><span class="s2">&quot;UintArray&quot;</span><span class="s0">, </span><span class="s2">&quot;#initializeSizeTracking&quot;</span><span class="s0">, </span><span class="s2">&quot;#initializeTTLTracking&quot;</span><span class="s0">, </span><span class="s2">&quot;key&quot;</span><span class="s0">, </span><span class="s2">&quot;ttls&quot;</span><span class="s0">, </span><span class="s2">&quot;starts&quot;</span><span class="s0">, </span><span class="s2">&quot;#setItemTTL&quot;</span><span class="s0">, </span><span class="s2">&quot;start&quot;</span><span class="s0">, </span><span class="s2">&quot;t&quot;</span><span class="s0">, </span><span class="s2">&quot;#delete&quot;</span><span class="s0">, </span><span class="s2">&quot;#updateItemAge&quot;</span><span class="s0">, </span><span class="s2">&quot;#statusTTL&quot;</span><span class="s0">, </span><span class="s2">&quot;status&quot;</span><span class="s0">, </span><span class="s2">&quot;cachedNow&quot;</span><span class="s0">, </span><span class="s2">&quot;getNow&quot;</span><span class="s0">, </span><span class="s2">&quot;age&quot;</span><span class="s0">, </span><span class="s2">&quot;sizes&quot;</span><span class="s0">, </span><span class="s2">&quot;#removeItemSize&quot;</span><span class="s0">, </span><span class="s2">&quot;#requireSize&quot;</span><span class="s0">, </span><span class="s2">&quot;v&quot;</span><span class="s0">, </span><span class="s2">&quot;#addItemSize&quot;</span><span class="s0">, </span><span class="s2">&quot;#evict&quot;</span><span class="s0">, </span><span class="s2">&quot;_i&quot;</span><span class="s0">, </span><span class="s2">&quot;_s&quot;</span><span class="s0">, </span><span class="s2">&quot;_st&quot;</span><span class="s0">, </span><span class="s2">&quot;_k&quot;</span><span class="s0">, </span><span class="s2">&quot;_v&quot;</span><span class="s0">, </span><span class="s2">&quot;i&quot;</span><span class="s0">, </span><span class="s2">&quot;#isValidIndex&quot;</span><span class="s0">, </span><span class="s2">&quot;getOptions&quot;</span><span class="s0">, </span><span class="s2">&quot;value&quot;</span><span class="s0">, </span><span class="s2">&quot;thisp&quot;</span><span class="s0">, </span><span class="s2">&quot;deleted&quot;</span><span class="s0">, </span><span class="s2">&quot;entry&quot;</span><span class="s0">, </span><span class="s2">&quot;remain&quot;</span><span class="s0">, </span><span class="s2">&quot;arr&quot;</span><span class="s0">, </span><span class="s2">&quot;setOptions&quot;</span><span class="s0">, </span><span class="s2">&quot;oldVal&quot;</span><span class="s0">, </span><span class="s2">&quot;oldValue&quot;</span><span class="s0">, </span><span class="s2">&quot;dt&quot;</span><span class="s0">, </span><span class="s2">&quot;task&quot;</span><span class="s0">, </span><span class="s2">&quot;val&quot;</span><span class="s0">, </span><span class="s2">&quot;free&quot;</span><span class="s0">, </span><span class="s2">&quot;head&quot;</span><span class="s0">, </span><span class="s2">&quot;hasOptions&quot;</span><span class="s0">, </span><span class="s2">&quot;peekOptions&quot;</span><span class="s0">, </span><span class="s2">&quot;ac&quot;</span><span class="s0">, </span><span class="s2">&quot;signal&quot;</span><span class="s0">, </span><span class="s2">&quot;fetchOpts&quot;</span><span class="s0">, </span><span class="s2">&quot;cb&quot;</span><span class="s0">, </span><span class="s2">&quot;updateCache&quot;</span><span class="s0">, </span><span class="s2">&quot;aborted&quot;</span><span class="s0">, </span><span class="s2">&quot;ignoreAbort&quot;</span><span class="s0">, </span><span class="s2">&quot;fetchFail&quot;</span><span class="s0">, </span><span class="s2">&quot;bf&quot;</span><span class="s0">, </span><span class="s2">&quot;eb&quot;</span><span class="s0">, </span><span class="s2">&quot;er&quot;</span><span class="s0">, </span><span class="s2">&quot;allowStaleAborted&quot;</span><span class="s0">, </span><span class="s2">&quot;noDelete&quot;</span><span class="s0">, </span><span class="s2">&quot;pcall&quot;</span><span class="s0">, </span><span class="s2">&quot;res&quot;</span><span class="s0">, </span><span class="s2">&quot;rej&quot;</span><span class="s0">, </span><span class="s2">&quot;fmp&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;fetchOptions&quot;</span><span class="s0">, </span><span class="s2">&quot;forceRefresh&quot;</span><span class="s0">, </span><span class="s2">&quot;stale&quot;</span><span class="s0">, </span><span class="s2">&quot;isStale&quot;</span><span class="s0">, </span><span class="s2">&quot;staleVal&quot;</span><span class="s0">, </span><span class="s2">&quot;memoOptions&quot;</span><span class="s0">, </span><span class="s2">&quot;vv&quot;</span><span class="s0">, </span><span class="s2">&quot;fetching&quot;</span><span class="s0">, </span><span class="s2">&quot;#connect&quot;</span><span class="s0">, </span><span class="s2">&quot;#clear&quot;</span><span class="s0">, </span><span class="s2">&quot;pi&quot;</span><span class="s0">, </span><span class="s2">&quot;ni&quot;</span><span class="s0">]</span>
<span class="s0">}</span>
</pre>
</body>
</html>