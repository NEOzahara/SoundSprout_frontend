<html>
<head>
<title>index.node.mjs.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
index.node.mjs.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;index.node.mjs&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../src/utils.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;../src/imports-injector.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;../src/debug-utils.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;../src/normalize-options.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;../src/visitors/usage.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;../src/visitors/entry.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;../src/node/dependencies.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;../src/meta-resolver.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;../src/index.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { types as t, template } from </span><span class="s3">\&quot;</span><span class="s1">@babel/core</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { NodePath } from </span><span class="s3">\&quot;</span><span class="s1">@babel/traverse</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { Utils } from </span><span class="s3">\&quot;</span><span class="s1">./types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type ImportsCachedInjector from </span><span class="s3">\&quot;</span><span class="s1">./imports-injector</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">export function intersection&lt;T&gt;(a: Set&lt;T&gt;, b: Set&lt;T&gt;): Set&lt;T&gt; {</span><span class="s3">\n  </span><span class="s1">const result = new Set&lt;T&gt;();</span><span class="s3">\n  </span><span class="s1">a.forEach(v =&gt; b.has(v) &amp;&amp; result.add(v));</span><span class="s3">\n  </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function has(object: any, key: string) {</span><span class="s3">\n  </span><span class="s1">return Object.prototype.hasOwnProperty.call(object, key);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function resolve(</span><span class="s3">\n  </span><span class="s1">path: NodePath,</span><span class="s3">\n  </span><span class="s1">resolved: Set&lt;NodePath&gt; = new Set(),</span><span class="s3">\n</span><span class="s1">): NodePath | undefined {</span><span class="s3">\n  </span><span class="s1">if (resolved.has(path)) return;</span><span class="s3">\n  </span><span class="s1">resolved.add(path);</span><span class="s3">\n\n  </span><span class="s1">if (path.isVariableDeclarator()) {</span><span class="s3">\n    </span><span class="s1">if (path.get(</span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">).isIdentifier()) {</span><span class="s3">\n      </span><span class="s1">return resolve(path.get(</span><span class="s3">\&quot;</span><span class="s1">init</span><span class="s3">\&quot;</span><span class="s1">), resolved);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else if (path.isReferencedIdentifier()) {</span><span class="s3">\n    </span><span class="s1">const binding = path.scope.getBinding(path.node.name);</span><span class="s3">\n    </span><span class="s1">if (!binding) return path;</span><span class="s3">\n    </span><span class="s1">if (!binding.constant) return;</span><span class="s3">\n    </span><span class="s1">return resolve(binding.path, resolved);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return path;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function resolveId(path: NodePath): string {</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">path.isIdentifier() &amp;&amp;</span><span class="s3">\n    </span><span class="s1">!path.scope.hasBinding(path.node.name, /* noGlobals */ true)</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return path.node.name;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const resolved = resolve(path);</span><span class="s3">\n  </span><span class="s1">if (resolved?.isIdentifier()) {</span><span class="s3">\n    </span><span class="s1">return resolved.node.name;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function resolveKey(</span><span class="s3">\n  </span><span class="s1">path: NodePath&lt;t.Expression | t.PrivateName&gt;,</span><span class="s3">\n  </span><span class="s1">computed: boolean = false,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const { scope } = path;</span><span class="s3">\n  </span><span class="s1">if (path.isStringLiteral()) return path.node.value;</span><span class="s3">\n  </span><span class="s1">const isIdentifier = path.isIdentifier();</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">isIdentifier &amp;&amp;</span><span class="s3">\n    </span><span class="s1">!(computed || (path.parent as t.MemberExpression).computed)</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return path.node.name;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">computed &amp;&amp;</span><span class="s3">\n    </span><span class="s1">path.isMemberExpression() &amp;&amp;</span><span class="s3">\n    </span><span class="s1">path.get(</span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">).isIdentifier({ name: </span><span class="s3">\&quot;</span><span class="s1">Symbol</span><span class="s3">\&quot; </span><span class="s1">}) &amp;&amp;</span><span class="s3">\n    </span><span class="s1">!scope.hasBinding(</span><span class="s3">\&quot;</span><span class="s1">Symbol</span><span class="s3">\&quot;</span><span class="s1">, /* noGlobals */ true)</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">const sym = resolveKey(path.get(</span><span class="s3">\&quot;</span><span class="s1">property</span><span class="s3">\&quot;</span><span class="s1">), path.node.computed);</span><span class="s3">\n    </span><span class="s1">if (sym) return </span><span class="s3">\&quot;</span><span class="s1">Symbol.</span><span class="s3">\&quot; </span><span class="s1">+ sym;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">isIdentifier</span><span class="s3">\n      </span><span class="s1">? scope.hasBinding(path.node.name, /* noGlobals */ true)</span><span class="s3">\n      </span><span class="s1">: path.isPure()</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">const { value } = path.evaluate();</span><span class="s3">\n    </span><span class="s1">if (typeof value === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">) return value;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function resolveSource(obj: NodePath): {</span><span class="s3">\n  </span><span class="s1">id: string | null;</span><span class="s3">\n  </span><span class="s1">placement: </span><span class="s3">\&quot;</span><span class="s1">prototype</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">static</span><span class="s3">\&quot; </span><span class="s1">| null;</span><span class="s3">\n</span><span class="s1">} {</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">obj.isMemberExpression() &amp;&amp;</span><span class="s3">\n    </span><span class="s1">obj.get(</span><span class="s3">\&quot;</span><span class="s1">property</span><span class="s3">\&quot;</span><span class="s1">).isIdentifier({ name: </span><span class="s3">\&quot;</span><span class="s1">prototype</span><span class="s3">\&quot; </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">const id = resolveId(obj.get(</span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n\n    </span><span class="s1">if (id) {</span><span class="s3">\n      </span><span class="s1">return { id, placement: </span><span class="s3">\&quot;</span><span class="s1">prototype</span><span class="s3">\&quot; </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return { id: null, placement: null };</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const id = resolveId(obj);</span><span class="s3">\n  </span><span class="s1">if (id) {</span><span class="s3">\n    </span><span class="s1">return { id, placement: </span><span class="s3">\&quot;</span><span class="s1">static</span><span class="s3">\&quot; </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const path = resolve(obj);</span><span class="s3">\n  </span><span class="s1">switch (path?.type) {</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">RegExpLiteral</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">return { id: </span><span class="s3">\&quot;</span><span class="s1">RegExp</span><span class="s3">\&quot;</span><span class="s1">, placement: </span><span class="s3">\&quot;</span><span class="s1">prototype</span><span class="s3">\&quot; </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">FunctionExpression</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">return { id: </span><span class="s3">\&quot;</span><span class="s1">Function</span><span class="s3">\&quot;</span><span class="s1">, placement: </span><span class="s3">\&quot;</span><span class="s1">prototype</span><span class="s3">\&quot; </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">StringLiteral</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">return { id: </span><span class="s3">\&quot;</span><span class="s1">String</span><span class="s3">\&quot;</span><span class="s1">, placement: </span><span class="s3">\&quot;</span><span class="s1">prototype</span><span class="s3">\&quot; </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">NumberLiteral</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">return { id: </span><span class="s3">\&quot;</span><span class="s1">Number</span><span class="s3">\&quot;</span><span class="s1">, placement: </span><span class="s3">\&quot;</span><span class="s1">prototype</span><span class="s3">\&quot; </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">BooleanLiteral</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">return { id: </span><span class="s3">\&quot;</span><span class="s1">Boolean</span><span class="s3">\&quot;</span><span class="s1">, placement: </span><span class="s3">\&quot;</span><span class="s1">prototype</span><span class="s3">\&quot; </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ObjectExpression</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">return { id: </span><span class="s3">\&quot;</span><span class="s1">Object</span><span class="s3">\&quot;</span><span class="s1">, placement: </span><span class="s3">\&quot;</span><span class="s1">prototype</span><span class="s3">\&quot; </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ArrayExpression</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">return { id: </span><span class="s3">\&quot;</span><span class="s1">Array</span><span class="s3">\&quot;</span><span class="s1">, placement: </span><span class="s3">\&quot;</span><span class="s1">prototype</span><span class="s3">\&quot; </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return { id: null, placement: null };</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getImportSource({ node }: NodePath&lt;t.ImportDeclaration&gt;) {</span><span class="s3">\n  </span><span class="s1">if (node.specifiers.length === 0) return node.source.value;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getRequireSource({ node }: NodePath&lt;t.Statement&gt;) {</span><span class="s3">\n  </span><span class="s1">if (!t.isExpressionStatement(node)) return;</span><span class="s3">\n  </span><span class="s1">const { expression } = node;</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">t.isCallExpression(expression) &amp;&amp;</span><span class="s3">\n    </span><span class="s1">t.isIdentifier(expression.callee) &amp;&amp;</span><span class="s3">\n    </span><span class="s1">expression.callee.name === </span><span class="s3">\&quot;</span><span class="s1">require</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n    </span><span class="s1">expression.arguments.length === 1 &amp;&amp;</span><span class="s3">\n    </span><span class="s1">t.isStringLiteral(expression.arguments[0])</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return expression.arguments[0].value;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function hoist(node: t.Node) {</span><span class="s3">\n  </span><span class="s1">// @ts-expect-error</span><span class="s3">\n  </span><span class="s1">node._blockHoist = 3;</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function createUtilsGetter(cache: ImportsCachedInjector) {</span><span class="s3">\n  </span><span class="s1">return (path: NodePath): Utils =&gt; {</span><span class="s3">\n    </span><span class="s1">const prog = path.findParent(p =&gt; p.isProgram()) as NodePath&lt;t.Program&gt;;</span><span class="s3">\n\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">injectGlobalImport(url, moduleName) {</span><span class="s3">\n        </span><span class="s1">cache.storeAnonymous(prog, url, moduleName, (isScript, source) =&gt; {</span><span class="s3">\n          </span><span class="s1">return isScript</span><span class="s3">\n            </span><span class="s1">? template.statement.ast`require(${source})`</span><span class="s3">\n            </span><span class="s1">: t.importDeclaration([], source);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">injectNamedImport(url, name, hint = name, moduleName) {</span><span class="s3">\n        </span><span class="s1">return cache.storeNamed(</span><span class="s3">\n          </span><span class="s1">prog,</span><span class="s3">\n          </span><span class="s1">url,</span><span class="s3">\n          </span><span class="s1">name,</span><span class="s3">\n          </span><span class="s1">moduleName,</span><span class="s3">\n          </span><span class="s1">(isScript, source, name) =&gt; {</span><span class="s3">\n            </span><span class="s1">const id = prog.scope.generateUidIdentifier(hint);</span><span class="s3">\n            </span><span class="s1">return {</span><span class="s3">\n              </span><span class="s1">node: isScript</span><span class="s3">\n                </span><span class="s1">? hoist(template.statement.ast`</span><span class="s3">\n                  </span><span class="s1">var ${id} = require(${source}).${name}</span><span class="s3">\n                </span><span class="s1">`)</span><span class="s3">\n                </span><span class="s1">: t.importDeclaration([t.importSpecifier(id, name)], source),</span><span class="s3">\n              </span><span class="s1">name: id.name,</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">injectDefaultImport(url, hint = url, moduleName) {</span><span class="s3">\n        </span><span class="s1">return cache.storeNamed(</span><span class="s3">\n          </span><span class="s1">prog,</span><span class="s3">\n          </span><span class="s1">url,</span><span class="s3">\n          \&quot;</span><span class="s1">default</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n          </span><span class="s1">moduleName,</span><span class="s3">\n          </span><span class="s1">(isScript, source) =&gt; {</span><span class="s3">\n            </span><span class="s1">const id = prog.scope.generateUidIdentifier(hint);</span><span class="s3">\n            </span><span class="s1">return {</span><span class="s3">\n              </span><span class="s1">node: isScript</span><span class="s3">\n                </span><span class="s1">? hoist(template.statement.ast`var ${id} = require(${source})`)</span><span class="s3">\n                </span><span class="s1">: t.importDeclaration([t.importDefaultSpecifier(id)], source),</span><span class="s3">\n              </span><span class="s1">name: id.name,</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { NodePath } from </span><span class="s3">\&quot;</span><span class="s1">@babel/traverse</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { types as t } from </span><span class="s3">\&quot;</span><span class="s1">@babel/core</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">type StrMap&lt;K&gt; = Map&lt;string, K&gt;;</span><span class="s3">\n\n</span><span class="s1">export default class ImportsCachedInjector {</span><span class="s3">\n  </span><span class="s1">_imports: WeakMap&lt;NodePath&lt;t.Program&gt;, StrMap&lt;string&gt;&gt;;</span><span class="s3">\n  </span><span class="s1">_anonymousImports: WeakMap&lt;NodePath&lt;t.Program&gt;, Set&lt;string&gt;&gt;;</span><span class="s3">\n  </span><span class="s1">_lastImports: WeakMap&lt;</span><span class="s3">\n    </span><span class="s1">NodePath&lt;t.Program&gt;,</span><span class="s3">\n    </span><span class="s1">Array&lt;{ path: NodePath&lt;t.Node&gt;; index: number }&gt;</span><span class="s3">\n  </span><span class="s1">&gt;;</span><span class="s3">\n  </span><span class="s1">_resolver: (url: string) =&gt; string;</span><span class="s3">\n  </span><span class="s1">_getPreferredIndex: (url: string) =&gt; number;</span><span class="s3">\n\n  </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">resolver: (url: string) =&gt; string,</span><span class="s3">\n    </span><span class="s1">getPreferredIndex: (url: string) =&gt; number,</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">this._imports = new WeakMap();</span><span class="s3">\n    </span><span class="s1">this._anonymousImports = new WeakMap();</span><span class="s3">\n    </span><span class="s1">this._lastImports = new WeakMap();</span><span class="s3">\n    </span><span class="s1">this._resolver = resolver;</span><span class="s3">\n    </span><span class="s1">this._getPreferredIndex = getPreferredIndex;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">storeAnonymous(</span><span class="s3">\n    </span><span class="s1">programPath: NodePath&lt;t.Program&gt;,</span><span class="s3">\n    </span><span class="s1">url: string,</span><span class="s3">\n    </span><span class="s1">moduleName: string,</span><span class="s3">\n    </span><span class="s1">getVal: (isScript: boolean, source: t.StringLiteral) =&gt; t.Node,</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">const key = this._normalizeKey(programPath, url);</span><span class="s3">\n    </span><span class="s1">const imports = this._ensure&lt;Set&lt;string&gt;&gt;(</span><span class="s3">\n      </span><span class="s1">this._anonymousImports,</span><span class="s3">\n      </span><span class="s1">programPath,</span><span class="s3">\n      </span><span class="s1">Set,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n\n    </span><span class="s1">if (imports.has(key)) return;</span><span class="s3">\n\n    </span><span class="s1">const node = getVal(</span><span class="s3">\n      </span><span class="s1">programPath.node.sourceType === </span><span class="s3">\&quot;</span><span class="s1">script</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">t.stringLiteral(this._resolver(url)),</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">imports.add(key);</span><span class="s3">\n    </span><span class="s1">this._injectImport(programPath, node, moduleName);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">storeNamed(</span><span class="s3">\n    </span><span class="s1">programPath: NodePath&lt;t.Program&gt;,</span><span class="s3">\n    </span><span class="s1">url: string,</span><span class="s3">\n    </span><span class="s1">name: string,</span><span class="s3">\n    </span><span class="s1">moduleName: string,</span><span class="s3">\n    </span><span class="s1">getVal: (</span><span class="s3">\n      </span><span class="s1">isScript: boolean,</span><span class="s3">\n      </span><span class="s1">// eslint-disable-next-line no-undef</span><span class="s3">\n      </span><span class="s1">source: t.StringLiteral,</span><span class="s3">\n      </span><span class="s1">// eslint-disable-next-line no-undef</span><span class="s3">\n      </span><span class="s1">name: t.Identifier,</span><span class="s3">\n    </span><span class="s1">) =&gt; { node: t.Node; name: string },</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">const key = this._normalizeKey(programPath, url, name);</span><span class="s3">\n    </span><span class="s1">const imports = this._ensure&lt;Map&lt;string, any&gt;&gt;(</span><span class="s3">\n      </span><span class="s1">this._imports,</span><span class="s3">\n      </span><span class="s1">programPath,</span><span class="s3">\n      </span><span class="s1">Map,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n\n    </span><span class="s1">if (!imports.has(key)) {</span><span class="s3">\n      </span><span class="s1">const { node, name: id } = getVal(</span><span class="s3">\n        </span><span class="s1">programPath.node.sourceType === </span><span class="s3">\&quot;</span><span class="s1">script</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">t.stringLiteral(this._resolver(url)),</span><span class="s3">\n        </span><span class="s1">t.identifier(name),</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">imports.set(key, id);</span><span class="s3">\n      </span><span class="s1">this._injectImport(programPath, node, moduleName);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return t.identifier(imports.get(key));</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_injectImport(</span><span class="s3">\n    </span><span class="s1">programPath: NodePath&lt;t.Program&gt;,</span><span class="s3">\n    </span><span class="s1">node: t.Node,</span><span class="s3">\n    </span><span class="s1">moduleName: string,</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">const newIndex = this._getPreferredIndex(moduleName);</span><span class="s3">\n    </span><span class="s1">const lastImports = this._lastImports.get(programPath) ?? [];</span><span class="s3">\n\n    </span><span class="s1">const isPathStillValid = (path: NodePath) =&gt;</span><span class="s3">\n      </span><span class="s1">path.node &amp;&amp;</span><span class="s3">\n      </span><span class="s1">// Sometimes the AST is modified and the </span><span class="s3">\&quot;</span><span class="s1">last import</span><span class="s3">\&quot;\n      </span><span class="s1">// we have has been replaced</span><span class="s3">\n      </span><span class="s1">path.parent === programPath.node &amp;&amp;</span><span class="s3">\n      </span><span class="s1">path.container === programPath.node.body;</span><span class="s3">\n\n    </span><span class="s1">let last: NodePath;</span><span class="s3">\n\n    </span><span class="s1">if (newIndex === Infinity) {</span><span class="s3">\n      </span><span class="s1">// Fast path: we can always just insert at the end if newIndex is `Infinity`</span><span class="s3">\n      </span><span class="s1">if (lastImports.length &gt; 0) {</span><span class="s3">\n        </span><span class="s1">last = lastImports[lastImports.length - 1].path;</span><span class="s3">\n        </span><span class="s1">if (!isPathStillValid(last)) last = undefined;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">for (const [i, data] of lastImports.entries()) {</span><span class="s3">\n        </span><span class="s1">const { path, index } = data;</span><span class="s3">\n        </span><span class="s1">if (isPathStillValid(path)) {</span><span class="s3">\n          </span><span class="s1">if (newIndex &lt; index) {</span><span class="s3">\n            </span><span class="s1">const [newPath] = path.insertBefore(node);</span><span class="s3">\n            </span><span class="s1">lastImports.splice(i, 0, { path: newPath, index: newIndex });</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">last = path;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (last) {</span><span class="s3">\n      </span><span class="s1">const [newPath] = last.insertAfter(node);</span><span class="s3">\n      </span><span class="s1">lastImports.push({ path: newPath, index: newIndex });</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">const [newPath] = programPath.unshiftContainer(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">, node);</span><span class="s3">\n      </span><span class="s1">this._lastImports.set(programPath, [{ path: newPath, index: newIndex }]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_ensure&lt;C extends Map&lt;string, any&gt; | Set&lt;string&gt;&gt;(</span><span class="s3">\n    </span><span class="s1">map: WeakMap&lt;NodePath&lt;t.Program&gt;, C&gt;,</span><span class="s3">\n    </span><span class="s1">programPath: NodePath&lt;t.Program&gt;,</span><span class="s3">\n    </span><span class="s1">Collection: { new (...args: any): C },</span><span class="s3">\n  </span><span class="s1">): C {</span><span class="s3">\n    </span><span class="s1">let collection = map.get(programPath);</span><span class="s3">\n    </span><span class="s1">if (!collection) {</span><span class="s3">\n      </span><span class="s1">collection = new Collection();</span><span class="s3">\n      </span><span class="s1">map.set(programPath, collection);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return collection;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_normalizeKey(</span><span class="s3">\n    </span><span class="s1">programPath: NodePath&lt;t.Program&gt;,</span><span class="s3">\n    </span><span class="s1">url: string,</span><span class="s3">\n    </span><span class="s1">name: string = </span><span class="s3">\&quot;\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">): string {</span><span class="s3">\n    </span><span class="s1">const { sourceType } = programPath.node;</span><span class="s3">\n\n    </span><span class="s1">// If we rely on the imported binding (the </span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot; </span><span class="s1">parameter), we also need to cache</span><span class="s3">\n    </span><span class="s1">// based on the sourceType. This is because the module transforms change the names</span><span class="s3">\n    </span><span class="s1">// of the import variables.</span><span class="s3">\n    </span><span class="s1">return `${name &amp;&amp; sourceType}::${url}::${name}`;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { prettifyTargets } from </span><span class="s3">\&quot;</span><span class="s1">@babel/helper-compilation-targets</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">import type { Targets } from </span><span class="s3">\&quot;</span><span class="s1">./types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">export const presetEnvSilentDebugHeader =</span><span class="s3">\n  \&quot;</span><span class="s1">#__secret_key__@babel/preset-env__don't_log_debug_header_and_resolved_targets</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">export function stringifyTargetsMultiline(targets: Targets): string {</span><span class="s3">\n  </span><span class="s1">return JSON.stringify(prettifyTargets(targets), null, 2);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function stringifyTargets(targets: Targets): string {</span><span class="s3">\n  </span><span class="s1">return JSON.stringify(targets)</span><span class="s3">\n    </span><span class="s1">.replace(/,/g, </span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">.replace(/^</span><span class="s3">\\</span><span class="s1">{</span><span class="s3">\&quot;</span><span class="s1">/, '{ </span><span class="s3">\&quot;</span><span class="s1">')</span><span class="s3">\n    </span><span class="s1">.replace(/</span><span class="s3">\&quot;\\</span><span class="s1">}$/, '</span><span class="s3">\&quot; </span><span class="s1">}');</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { intersection } from </span><span class="s3">\&quot;</span><span class="s1">./utils</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">Pattern,</span><span class="s3">\n  </span><span class="s1">PluginOptions,</span><span class="s3">\n  </span><span class="s1">MissingDependenciesOption,</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">./types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">function patternToRegExp(pattern: Pattern): RegExp | null {</span><span class="s3">\n  </span><span class="s1">if (pattern instanceof RegExp) return pattern;</span><span class="s3">\n\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">return new RegExp(`^${pattern}$`);</span><span class="s3">\n  </span><span class="s1">} catch {</span><span class="s3">\n    </span><span class="s1">return null;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function buildUnusedError(label, unused) {</span><span class="s3">\n  </span><span class="s1">if (!unused.length) return </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">`  - The following </span><span class="s3">\&quot;</span><span class="s1">${label}</span><span class="s3">\&quot; </span><span class="s1">patterns didn't match any polyfill:</span><span class="s3">\\</span><span class="s1">n` +</span><span class="s3">\n    </span><span class="s1">unused.map(original =&gt; `    ${String(original)}</span><span class="s3">\\</span><span class="s1">n`).join(</span><span class="s3">\&quot;\&quot;</span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function buldDuplicatesError(duplicates) {</span><span class="s3">\n  </span><span class="s1">if (!duplicates.size) return </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">`  - The following polyfills were matched both by </span><span class="s3">\&quot;</span><span class="s1">include</span><span class="s3">\&quot; </span><span class="s1">and </span><span class="s3">\&quot;</span><span class="s1">exclude</span><span class="s3">\&quot; </span><span class="s1">patterns:</span><span class="s3">\\</span><span class="s1">n` +</span><span class="s3">\n    </span><span class="s1">Array.from(duplicates, name =&gt; `    ${name}</span><span class="s3">\\</span><span class="s1">n`).join(</span><span class="s3">\&quot;\&quot;</span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function validateIncludeExclude(</span><span class="s3">\n  </span><span class="s1">provider: string,</span><span class="s3">\n  </span><span class="s1">polyfills: Map&lt;string, unknown&gt;,</span><span class="s3">\n  </span><span class="s1">includePatterns: Pattern[],</span><span class="s3">\n  </span><span class="s1">excludePatterns: Pattern[],</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">let current;</span><span class="s3">\n  </span><span class="s1">const filter = pattern =&gt; {</span><span class="s3">\n    </span><span class="s1">const regexp = patternToRegExp(pattern);</span><span class="s3">\n    </span><span class="s1">if (!regexp) return false;</span><span class="s3">\n\n    </span><span class="s1">let matched = false;</span><span class="s3">\n    </span><span class="s1">for (const polyfill of polyfills.keys()) {</span><span class="s3">\n      </span><span class="s1">if (regexp.test(polyfill)) {</span><span class="s3">\n        </span><span class="s1">matched = true;</span><span class="s3">\n        </span><span class="s1">current.add(polyfill);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return !matched;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">// prettier-ignore</span><span class="s3">\n  </span><span class="s1">const include = current = new Set&lt;string&gt; ();</span><span class="s3">\n  </span><span class="s1">const unusedInclude = Array.from(includePatterns).filter(filter);</span><span class="s3">\n\n  </span><span class="s1">// prettier-ignore</span><span class="s3">\n  </span><span class="s1">const exclude = current = new Set&lt;string&gt; ();</span><span class="s3">\n  </span><span class="s1">const unusedExclude = Array.from(excludePatterns).filter(filter);</span><span class="s3">\n\n  </span><span class="s1">const duplicates = intersection(include, exclude);</span><span class="s3">\n\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">duplicates.size &gt; 0 ||</span><span class="s3">\n    </span><span class="s1">unusedInclude.length &gt; 0 ||</span><span class="s3">\n    </span><span class="s1">unusedExclude.length &gt; 0</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">`Error while validating the </span><span class="s3">\&quot;</span><span class="s1">${provider}</span><span class="s3">\&quot; </span><span class="s1">provider options:</span><span class="s3">\\</span><span class="s1">n` +</span><span class="s3">\n        </span><span class="s1">buildUnusedError(</span><span class="s3">\&quot;</span><span class="s1">include</span><span class="s3">\&quot;</span><span class="s1">, unusedInclude) +</span><span class="s3">\n        </span><span class="s1">buildUnusedError(</span><span class="s3">\&quot;</span><span class="s1">exclude</span><span class="s3">\&quot;</span><span class="s1">, unusedExclude) +</span><span class="s3">\n        </span><span class="s1">buldDuplicatesError(duplicates),</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return { include, exclude };</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function applyMissingDependenciesDefaults(</span><span class="s3">\n  </span><span class="s1">options: PluginOptions,</span><span class="s3">\n  </span><span class="s1">babelApi: any,</span><span class="s3">\n</span><span class="s1">): MissingDependenciesOption {</span><span class="s3">\n  </span><span class="s1">const { missingDependencies = {} } = options;</span><span class="s3">\n  </span><span class="s1">if (missingDependencies === false) return false;</span><span class="s3">\n\n  </span><span class="s1">const caller = babelApi.caller(caller =&gt; caller?.name);</span><span class="s3">\n\n  </span><span class="s1">const {</span><span class="s3">\n    </span><span class="s1">log = </span><span class="s3">\&quot;</span><span class="s1">deferred</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">inject = caller === </span><span class="s3">\&quot;</span><span class="s1">rollup-plugin-babel</span><span class="s3">\&quot; </span><span class="s1">? </span><span class="s3">\&quot;</span><span class="s1">throw</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">import</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">all = false,</span><span class="s3">\n  </span><span class="s1">} = missingDependencies;</span><span class="s3">\n\n  </span><span class="s1">return { log, inject, all };</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { NodePath } from </span><span class="s3">\&quot;</span><span class="s1">@babel/traverse</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { types as t } from </span><span class="s3">\&quot;</span><span class="s1">@babel/core</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { CallProvider } from </span><span class="s3">\&quot;</span><span class="s1">./index</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">import { resolveKey, resolveSource } from </span><span class="s3">\&quot;</span><span class="s1">../utils</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">function isRemoved(path: NodePath) {</span><span class="s3">\n  </span><span class="s1">if (path.removed) return true;</span><span class="s3">\n  </span><span class="s1">if (!path.parentPath) return false;</span><span class="s3">\n  </span><span class="s1">if (path.listKey) {</span><span class="s3">\n    </span><span class="s1">if (!path.parentPath.node?.[path.listKey]?.includes(path.node)) return true;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">if (path.parentPath.node[path.key] !== path.node) return true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return isRemoved(path.parentPath);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default (callProvider: CallProvider) =&gt; {</span><span class="s3">\n  </span><span class="s1">function property(object, key, placement, path) {</span><span class="s3">\n    </span><span class="s1">return callProvider({ kind: </span><span class="s3">\&quot;</span><span class="s1">property</span><span class="s3">\&quot;</span><span class="s1">, object, key, placement }, path);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function handleReferencedIdentifier(path) {</span><span class="s3">\n    </span><span class="s1">const {</span><span class="s3">\n      </span><span class="s1">node: { name },</span><span class="s3">\n      </span><span class="s1">scope,</span><span class="s3">\n    </span><span class="s1">} = path;</span><span class="s3">\n    </span><span class="s1">if (scope.getBindingIdentifier(name)) return;</span><span class="s3">\n\n    </span><span class="s1">callProvider({ kind: </span><span class="s3">\&quot;</span><span class="s1">global</span><span class="s3">\&quot;</span><span class="s1">, name }, path);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function analyzeMemberExpression(</span><span class="s3">\n    </span><span class="s1">path: NodePath&lt;t.MemberExpression | t.OptionalMemberExpression&gt;,</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">const key = resolveKey(path.get(</span><span class="s3">\&quot;</span><span class="s1">property</span><span class="s3">\&quot;</span><span class="s1">), path.node.computed);</span><span class="s3">\n    </span><span class="s1">return { key, handleAsMemberExpression: !!key &amp;&amp; key !== </span><span class="s3">\&quot;</span><span class="s1">prototype</span><span class="s3">\&quot; </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">// Symbol(), new Promise</span><span class="s3">\n    </span><span class="s1">ReferencedIdentifier(path: NodePath&lt;t.Identifier&gt;) {</span><span class="s3">\n      </span><span class="s1">const { parentPath } = path;</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">parentPath.isMemberExpression({ object: path.node }) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">analyzeMemberExpression(parentPath).handleAsMemberExpression</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">handleReferencedIdentifier(path);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    \&quot;</span><span class="s1">MemberExpression|OptionalMemberExpression</span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\n      </span><span class="s1">path: NodePath&lt;t.MemberExpression | t.OptionalMemberExpression&gt;,</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">const { key, handleAsMemberExpression } = analyzeMemberExpression(path);</span><span class="s3">\n      </span><span class="s1">if (!handleAsMemberExpression) return;</span><span class="s3">\n\n      </span><span class="s1">const object = path.get(</span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">let objectIsGlobalIdentifier = object.isIdentifier();</span><span class="s3">\n      </span><span class="s1">if (objectIsGlobalIdentifier) {</span><span class="s3">\n        </span><span class="s1">const binding = object.scope.getBinding(</span><span class="s3">\n          </span><span class="s1">(object.node as t.Identifier).name,</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">if (binding) {</span><span class="s3">\n          </span><span class="s1">if (binding.path.isImportNamespaceSpecifier()) return;</span><span class="s3">\n          </span><span class="s1">objectIsGlobalIdentifier = false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const source = resolveSource(object);</span><span class="s3">\n      </span><span class="s1">let skipObject = property(source.id, key, source.placement, path);</span><span class="s3">\n      </span><span class="s1">skipObject ||=</span><span class="s3">\n        </span><span class="s1">!objectIsGlobalIdentifier ||</span><span class="s3">\n        </span><span class="s1">path.shouldSkip ||</span><span class="s3">\n        </span><span class="s1">object.shouldSkip ||</span><span class="s3">\n        </span><span class="s1">isRemoved(object);</span><span class="s3">\n\n      </span><span class="s1">if (!skipObject) handleReferencedIdentifier(object);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">ObjectPattern(path: NodePath&lt;t.ObjectPattern&gt;) {</span><span class="s3">\n      </span><span class="s1">const { parentPath, parent } = path;</span><span class="s3">\n      </span><span class="s1">let obj;</span><span class="s3">\n\n      </span><span class="s1">// const { keys, values } = Object</span><span class="s3">\n      </span><span class="s1">if (parentPath.isVariableDeclarator()) {</span><span class="s3">\n        </span><span class="s1">obj = parentPath.get(</span><span class="s3">\&quot;</span><span class="s1">init</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">// ({ keys, values } = Object)</span><span class="s3">\n      </span><span class="s1">} else if (parentPath.isAssignmentExpression()) {</span><span class="s3">\n        </span><span class="s1">obj = parentPath.get(</span><span class="s3">\&quot;</span><span class="s1">right</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">// !function ({ keys, values }) {...} (Object)</span><span class="s3">\n        </span><span class="s1">// resolution does not work after properties transform :-(</span><span class="s3">\n      </span><span class="s1">} else if (parentPath.isFunction()) {</span><span class="s3">\n        </span><span class="s1">const grand = parentPath.parentPath;</span><span class="s3">\n        </span><span class="s1">if (grand.isCallExpression() || grand.isNewExpression()) {</span><span class="s3">\n          </span><span class="s1">if (grand.node.callee === parent) {</span><span class="s3">\n            </span><span class="s1">obj = grand.get(</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">)[path.key];</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">let id = null;</span><span class="s3">\n      </span><span class="s1">let placement = null;</span><span class="s3">\n      </span><span class="s1">if (obj) ({ id, placement } = resolveSource(obj));</span><span class="s3">\n\n      </span><span class="s1">for (const prop of path.get(</span><span class="s3">\&quot;</span><span class="s1">properties</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n        </span><span class="s1">if (prop.isObjectProperty()) {</span><span class="s3">\n          </span><span class="s1">const key = resolveKey(prop.get(</span><span class="s3">\&quot;</span><span class="s1">key</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n          </span><span class="s1">if (key) property(id, key, placement, prop);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">BinaryExpression(path: NodePath&lt;t.BinaryExpression&gt;) {</span><span class="s3">\n      </span><span class="s1">if (path.node.operator !== </span><span class="s3">\&quot;</span><span class="s1">in</span><span class="s3">\&quot;</span><span class="s1">) return;</span><span class="s3">\n\n      </span><span class="s1">const source = resolveSource(path.get(</span><span class="s3">\&quot;</span><span class="s1">right</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n      </span><span class="s1">const key = resolveKey(path.get(</span><span class="s3">\&quot;</span><span class="s1">left</span><span class="s3">\&quot;</span><span class="s1">), true);</span><span class="s3">\n\n      </span><span class="s1">if (!key) return;</span><span class="s3">\n\n      </span><span class="s1">callProvider(</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n          </span><span class="s1">kind: </span><span class="s3">\&quot;</span><span class="s1">in</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n          </span><span class="s1">object: source.id,</span><span class="s3">\n          </span><span class="s1">key,</span><span class="s3">\n          </span><span class="s1">placement: source.placement,</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">path,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { NodePath } from </span><span class="s3">\&quot;</span><span class="s1">@babel/traverse</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { types as t } from </span><span class="s3">\&quot;</span><span class="s1">@babel/core</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { CallProvider } from </span><span class="s3">\&quot;</span><span class="s1">./index</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">import { getImportSource, getRequireSource } from </span><span class="s3">\&quot;</span><span class="s1">../utils</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">export default (callProvider: CallProvider) =&gt; ({</span><span class="s3">\n  </span><span class="s1">ImportDeclaration(path: NodePath&lt;t.ImportDeclaration&gt;) {</span><span class="s3">\n    </span><span class="s1">const source = getImportSource(path);</span><span class="s3">\n    </span><span class="s1">if (!source) return;</span><span class="s3">\n    </span><span class="s1">callProvider({ kind: </span><span class="s3">\&quot;</span><span class="s1">import</span><span class="s3">\&quot;</span><span class="s1">, source }, path);</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">Program(path: NodePath&lt;t.Program&gt;) {</span><span class="s3">\n    </span><span class="s1">path.get(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">).forEach(bodyPath =&gt; {</span><span class="s3">\n      </span><span class="s1">const source = getRequireSource(bodyPath);</span><span class="s3">\n      </span><span class="s1">if (!source) return;</span><span class="s3">\n      </span><span class="s1">callProvider({ kind: </span><span class="s3">\&quot;</span><span class="s1">import</span><span class="s3">\&quot;</span><span class="s1">, source }, bodyPath);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import path from </span><span class="s3">\&quot;</span><span class="s1">path</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import debounce from </span><span class="s3">\&quot;</span><span class="s1">lodash.debounce</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import requireResolve from </span><span class="s3">\&quot;</span><span class="s1">resolve</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">const nativeRequireResolve = parseFloat(process.versions.node) &gt;= 8.9;</span><span class="s3">\n\n</span><span class="s1">import { createRequire } from </span><span class="s3">\&quot;</span><span class="s1">module</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">const require = createRequire(import /*::(_)*/.meta.url); // eslint-disable-line</span><span class="s3">\n\n</span><span class="s1">function myResolve(name: string, basedir: string) {</span><span class="s3">\n  </span><span class="s1">if (nativeRequireResolve) {</span><span class="s3">\n    </span><span class="s1">return require</span><span class="s3">\n      </span><span class="s1">.resolve(name, {</span><span class="s3">\n        </span><span class="s1">paths: [basedir],</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">.replace(/</span><span class="s3">\\\\</span><span class="s1">/g, </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return requireResolve.sync(name, { basedir }).replace(/</span><span class="s3">\\\\</span><span class="s1">/g, </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function resolve(</span><span class="s3">\n  </span><span class="s1">dirname: string,</span><span class="s3">\n  </span><span class="s1">moduleName: string,</span><span class="s3">\n  </span><span class="s1">absoluteImports: boolean | string,</span><span class="s3">\n</span><span class="s1">): string {</span><span class="s3">\n  </span><span class="s1">if (absoluteImports === false) return moduleName;</span><span class="s3">\n\n  </span><span class="s1">let basedir = dirname;</span><span class="s3">\n  </span><span class="s1">if (typeof absoluteImports === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">basedir = path.resolve(basedir, absoluteImports);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">return myResolve(moduleName, basedir);</span><span class="s3">\n  </span><span class="s1">} catch (err) {</span><span class="s3">\n    </span><span class="s1">if (err.code !== </span><span class="s3">\&quot;</span><span class="s1">MODULE_NOT_FOUND</span><span class="s3">\&quot;</span><span class="s1">) throw err;</span><span class="s3">\n\n    </span><span class="s1">throw Object.assign(</span><span class="s3">\n      </span><span class="s1">new Error(`Failed to resolve </span><span class="s3">\&quot;</span><span class="s1">${moduleName}</span><span class="s3">\&quot; </span><span class="s1">relative to </span><span class="s3">\&quot;</span><span class="s1">${dirname}</span><span class="s3">\&quot;</span><span class="s1">`),</span><span class="s3">\n      </span><span class="s1">{</span><span class="s3">\n        </span><span class="s1">code: </span><span class="s3">\&quot;</span><span class="s1">BABEL_POLYFILL_NOT_FOUND</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">polyfill: moduleName,</span><span class="s3">\n        </span><span class="s1">dirname,</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function has(basedir: string, name: string) {</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">myResolve(name, basedir);</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n  </span><span class="s1">} catch {</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function logMissing(missingDeps: Set&lt;string&gt;) {</span><span class="s3">\n  </span><span class="s1">if (missingDeps.size === 0) return;</span><span class="s3">\n\n  </span><span class="s1">const deps = Array.from(missingDeps).sort().join(</span><span class="s3">\&quot; \&quot;</span><span class="s1">);</span><span class="s3">\n\n  </span><span class="s1">console.warn(</span><span class="s3">\n    \&quot;\\</span><span class="s1">nSome polyfills have been added but are not present in your dependencies.</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n      \&quot;</span><span class="s1">Please run one of the following commands:</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n      </span><span class="s1">`</span><span class="s3">\\</span><span class="s1">tnpm install --save ${deps}</span><span class="s3">\\</span><span class="s1">n` +</span><span class="s3">\n      </span><span class="s1">`</span><span class="s3">\\</span><span class="s1">tyarn add ${deps}</span><span class="s3">\\</span><span class="s1">n`,</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n\n  </span><span class="s1">process.exitCode = 1;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">let allMissingDeps = new Set&lt;string&gt;();</span><span class="s3">\n\n</span><span class="s1">const laterLogMissingDependencies = debounce(() =&gt; {</span><span class="s3">\n  </span><span class="s1">logMissing(allMissingDeps);</span><span class="s3">\n  </span><span class="s1">allMissingDeps = new Set&lt;string&gt;();</span><span class="s3">\n</span><span class="s1">}, 100);</span><span class="s3">\n\n</span><span class="s1">export function laterLogMissing(missingDeps: Set&lt;string&gt;) {</span><span class="s3">\n  </span><span class="s1">if (missingDeps.size === 0) return;</span><span class="s3">\n\n  </span><span class="s1">missingDeps.forEach(name =&gt; allMissingDeps.add(name));</span><span class="s3">\n  </span><span class="s1">laterLogMissingDependencies();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type {</span><span class="s3">\n  </span><span class="s1">MetaDescriptor,</span><span class="s3">\n  </span><span class="s1">ResolverPolyfills,</span><span class="s3">\n  </span><span class="s1">ResolvedPolyfill,</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">./types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">import { has } from </span><span class="s3">\&quot;</span><span class="s1">./utils</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">type ResolverFn&lt;T&gt; = (meta: MetaDescriptor) =&gt; void | ResolvedPolyfill&lt;T&gt;;</span><span class="s3">\n\n</span><span class="s1">const PossibleGlobalObjects = new Set&lt;string&gt;([</span><span class="s3">\n  \&quot;</span><span class="s1">global</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  \&quot;</span><span class="s1">globalThis</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  \&quot;</span><span class="s1">self</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  \&quot;</span><span class="s1">window</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n</span><span class="s1">]);</span><span class="s3">\n\n</span><span class="s1">export default function createMetaResolver&lt;T&gt;(</span><span class="s3">\n  </span><span class="s1">polyfills: ResolverPolyfills&lt;T&gt;,</span><span class="s3">\n</span><span class="s1">): ResolverFn&lt;T&gt; {</span><span class="s3">\n  </span><span class="s1">const { static: staticP, instance: instanceP, global: globalP } = polyfills;</span><span class="s3">\n\n  </span><span class="s1">return meta =&gt; {</span><span class="s3">\n    </span><span class="s1">if (meta.kind === </span><span class="s3">\&quot;</span><span class="s1">global</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; globalP &amp;&amp; has(globalP, meta.name)) {</span><span class="s3">\n      </span><span class="s1">return { kind: </span><span class="s3">\&quot;</span><span class="s1">global</span><span class="s3">\&quot;</span><span class="s1">, desc: globalP[meta.name], name: meta.name };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (meta.kind === </span><span class="s3">\&quot;</span><span class="s1">property</span><span class="s3">\&quot; </span><span class="s1">|| meta.kind === </span><span class="s3">\&quot;</span><span class="s1">in</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">const { placement, object, key } = meta;</span><span class="s3">\n\n      </span><span class="s1">if (object &amp;&amp; placement === </span><span class="s3">\&quot;</span><span class="s1">static</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">if (globalP &amp;&amp; PossibleGlobalObjects.has(object) &amp;&amp; has(globalP, key)) {</span><span class="s3">\n          </span><span class="s1">return { kind: </span><span class="s3">\&quot;</span><span class="s1">global</span><span class="s3">\&quot;</span><span class="s1">, desc: globalP[key], name: key };</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (staticP &amp;&amp; has(staticP, object) &amp;&amp; has(staticP[object], key)) {</span><span class="s3">\n          </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">kind: </span><span class="s3">\&quot;</span><span class="s1">static</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">desc: staticP[object][key],</span><span class="s3">\n            </span><span class="s1">name: `${object}$${key}`,</span><span class="s3">\n          </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (instanceP &amp;&amp; has(instanceP, key)) {</span><span class="s3">\n        </span><span class="s1">return { kind: </span><span class="s3">\&quot;</span><span class="s1">instance</span><span class="s3">\&quot;</span><span class="s1">, desc: instanceP[key], name: `${key}` };</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { declare } from </span><span class="s3">\&quot;</span><span class="s1">@babel/helper-plugin-utils</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { NodePath } from </span><span class="s3">\&quot;</span><span class="s1">@babel/traverse</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">import _getTargets, {</span><span class="s3">\n  </span><span class="s1">isRequired,</span><span class="s3">\n  </span><span class="s1">getInclusionReasons,</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">@babel/helper-compilation-targets</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">const getTargets = _getTargets.default || _getTargets;</span><span class="s3">\n\n</span><span class="s1">import { createUtilsGetter } from </span><span class="s3">\&quot;</span><span class="s1">./utils</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import ImportsCachedInjector from </span><span class="s3">\&quot;</span><span class="s1">./imports-injector</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">stringifyTargetsMultiline,</span><span class="s3">\n  </span><span class="s1">presetEnvSilentDebugHeader,</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">./debug-utils</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">validateIncludeExclude,</span><span class="s3">\n  </span><span class="s1">applyMissingDependenciesDefaults,</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">./normalize-options</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">ProviderApi,</span><span class="s3">\n  </span><span class="s1">MethodString,</span><span class="s3">\n  </span><span class="s1">Targets,</span><span class="s3">\n  </span><span class="s1">MetaDescriptor,</span><span class="s3">\n  </span><span class="s1">PolyfillProvider,</span><span class="s3">\n  </span><span class="s1">PluginOptions,</span><span class="s3">\n  </span><span class="s1">ProviderOptions,</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">./types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">import * as v from </span><span class="s3">\&quot;</span><span class="s1">./visitors</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import * as deps from </span><span class="s3">\&quot;</span><span class="s1">./node/dependencies</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">import createMetaResolver from </span><span class="s3">\&quot;</span><span class="s1">./meta-resolver</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">export type { PolyfillProvider, MetaDescriptor, Utils, Targets } from </span><span class="s3">\&quot;</span><span class="s1">./types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">function resolveOptions&lt;Options&gt;(</span><span class="s3">\n  </span><span class="s1">options: PluginOptions,</span><span class="s3">\n  </span><span class="s1">babelApi,</span><span class="s3">\n</span><span class="s1">): {</span><span class="s3">\n  </span><span class="s1">method: MethodString;</span><span class="s3">\n  </span><span class="s1">methodName: </span><span class="s3">\&quot;</span><span class="s1">usageGlobal</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">entryGlobal</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">usagePure</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">targets: Targets;</span><span class="s3">\n  </span><span class="s1">debug: boolean | typeof presetEnvSilentDebugHeader;</span><span class="s3">\n  </span><span class="s1">shouldInjectPolyfill:</span><span class="s3">\n    </span><span class="s1">| ((name: string, shouldInject: boolean) =&gt; boolean)</span><span class="s3">\n    </span><span class="s1">| undefined;</span><span class="s3">\n  </span><span class="s1">providerOptions: ProviderOptions&lt;Options&gt;;</span><span class="s3">\n  </span><span class="s1">absoluteImports: string | boolean;</span><span class="s3">\n</span><span class="s1">} {</span><span class="s3">\n  </span><span class="s1">const {</span><span class="s3">\n    </span><span class="s1">method,</span><span class="s3">\n    </span><span class="s1">targets: targetsOption,</span><span class="s3">\n    </span><span class="s1">ignoreBrowserslistConfig,</span><span class="s3">\n    </span><span class="s1">configPath,</span><span class="s3">\n    </span><span class="s1">debug,</span><span class="s3">\n    </span><span class="s1">shouldInjectPolyfill,</span><span class="s3">\n    </span><span class="s1">absoluteImports,</span><span class="s3">\n    </span><span class="s1">...providerOptions</span><span class="s3">\n  </span><span class="s1">} = options;</span><span class="s3">\n\n  </span><span class="s1">if (isEmpty(options)) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">`</span><span class="s3">\\\n</span><span class="s1">This plugin requires options, for example:</span><span class="s3">\n    </span><span class="s1">{</span><span class="s3">\n      \&quot;</span><span class="s1">plugins</span><span class="s3">\&quot;</span><span class="s1">: [</span><span class="s3">\n        </span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">&lt;plugin name&gt;</span><span class="s3">\&quot;</span><span class="s1">, { method: </span><span class="s3">\&quot;</span><span class="s1">usage-pure</span><span class="s3">\&quot; </span><span class="s1">}]</span><span class="s3">\n      </span><span class="s1">]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">See more options at https://github.com/babel/babel-polyfills/blob/main/docs/usage.md`,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let methodName;</span><span class="s3">\n  </span><span class="s1">if (method === </span><span class="s3">\&quot;</span><span class="s1">usage-global</span><span class="s3">\&quot;</span><span class="s1">) methodName = </span><span class="s3">\&quot;</span><span class="s1">usageGlobal</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">else if (method === </span><span class="s3">\&quot;</span><span class="s1">entry-global</span><span class="s3">\&quot;</span><span class="s1">) methodName = </span><span class="s3">\&quot;</span><span class="s1">entryGlobal</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">else if (method === </span><span class="s3">\&quot;</span><span class="s1">usage-pure</span><span class="s3">\&quot;</span><span class="s1">) methodName = </span><span class="s3">\&quot;</span><span class="s1">usagePure</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">else if (typeof method !== </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">.method must be a string</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">`.method must be one of </span><span class="s3">\&quot;</span><span class="s1">entry-global</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">usage-global</span><span class="s3">\&quot;</span><span class="s1">` +</span><span class="s3">\n        </span><span class="s1">` or </span><span class="s3">\&quot;</span><span class="s1">usage-pure</span><span class="s3">\&quot; </span><span class="s1">(received ${JSON.stringify(method)})`,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (typeof shouldInjectPolyfill === </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">if (options.include || options.exclude) {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\n        </span><span class="s1">`.include and .exclude are not supported when using the` +</span><span class="s3">\n          </span><span class="s1">` .shouldInjectPolyfill function.`,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else if (shouldInjectPolyfill != null) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">`.shouldInjectPolyfill must be a function, or undefined` +</span><span class="s3">\n        </span><span class="s1">` (received ${JSON.stringify(shouldInjectPolyfill)})`,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">absoluteImports != null &amp;&amp;</span><span class="s3">\n    </span><span class="s1">typeof absoluteImports !== </span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n    </span><span class="s1">typeof absoluteImports !== </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">`.absoluteImports must be a boolean, a string, or undefined` +</span><span class="s3">\n        </span><span class="s1">` (received ${JSON.stringify(absoluteImports)})`,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let targets;</span><span class="s3">\n\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">// If any browserslist-related option is specified, fallback to the old</span><span class="s3">\n    </span><span class="s1">// behavior of not using the targets specified in the top-level options.</span><span class="s3">\n    </span><span class="s1">targetsOption ||</span><span class="s3">\n    </span><span class="s1">configPath ||</span><span class="s3">\n    </span><span class="s1">ignoreBrowserslistConfig</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">const targetsObj =</span><span class="s3">\n      </span><span class="s1">typeof targetsOption === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">|| Array.isArray(targetsOption)</span><span class="s3">\n        </span><span class="s1">? { browsers: targetsOption }</span><span class="s3">\n        </span><span class="s1">: targetsOption;</span><span class="s3">\n\n    </span><span class="s1">targets = getTargets(targetsObj, {</span><span class="s3">\n      </span><span class="s1">ignoreBrowserslistConfig,</span><span class="s3">\n      </span><span class="s1">configPath,</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">targets = babelApi.targets();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">method,</span><span class="s3">\n    </span><span class="s1">methodName,</span><span class="s3">\n    </span><span class="s1">targets,</span><span class="s3">\n    </span><span class="s1">absoluteImports: absoluteImports ?? false,</span><span class="s3">\n    </span><span class="s1">shouldInjectPolyfill,</span><span class="s3">\n    </span><span class="s1">debug: !!debug,</span><span class="s3">\n    </span><span class="s1">providerOptions: providerOptions as any as ProviderOptions&lt;Options&gt;,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function instantiateProvider&lt;Options&gt;(</span><span class="s3">\n  </span><span class="s1">factory: PolyfillProvider&lt;Options&gt;,</span><span class="s3">\n  </span><span class="s1">options: PluginOptions,</span><span class="s3">\n  </span><span class="s1">missingDependencies,</span><span class="s3">\n  </span><span class="s1">dirname,</span><span class="s3">\n  </span><span class="s1">debugLog,</span><span class="s3">\n  </span><span class="s1">babelApi,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const {</span><span class="s3">\n    </span><span class="s1">method,</span><span class="s3">\n    </span><span class="s1">methodName,</span><span class="s3">\n    </span><span class="s1">targets,</span><span class="s3">\n    </span><span class="s1">debug,</span><span class="s3">\n    </span><span class="s1">shouldInjectPolyfill,</span><span class="s3">\n    </span><span class="s1">providerOptions,</span><span class="s3">\n    </span><span class="s1">absoluteImports,</span><span class="s3">\n  </span><span class="s1">} = resolveOptions&lt;Options&gt;(options, babelApi);</span><span class="s3">\n\n  </span><span class="s1">// eslint-disable-next-line prefer-const</span><span class="s3">\n  </span><span class="s1">let include, exclude;</span><span class="s3">\n  </span><span class="s1">let polyfillsSupport;</span><span class="s3">\n  </span><span class="s1">let polyfillsNames: Map&lt;string, number&gt; | undefined;</span><span class="s3">\n  </span><span class="s1">let filterPolyfills;</span><span class="s3">\n\n  </span><span class="s1">const getUtils = createUtilsGetter(</span><span class="s3">\n    </span><span class="s1">new ImportsCachedInjector(</span><span class="s3">\n      </span><span class="s1">moduleName =&gt; deps.resolve(dirname, moduleName, absoluteImports),</span><span class="s3">\n      </span><span class="s1">(name: string) =&gt; polyfillsNames?.get(name) ?? Infinity,</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n\n  </span><span class="s1">const depsCache = new Map();</span><span class="s3">\n\n  </span><span class="s1">const api: ProviderApi = {</span><span class="s3">\n    </span><span class="s1">babel: babelApi,</span><span class="s3">\n    </span><span class="s1">getUtils,</span><span class="s3">\n    </span><span class="s1">method: options.method,</span><span class="s3">\n    </span><span class="s1">targets,</span><span class="s3">\n    </span><span class="s1">createMetaResolver,</span><span class="s3">\n    </span><span class="s1">shouldInjectPolyfill(name) {</span><span class="s3">\n      </span><span class="s1">if (polyfillsNames === undefined) {</span><span class="s3">\n        </span><span class="s1">throw new Error(</span><span class="s3">\n          </span><span class="s1">`Internal error in the ${factory.name} provider: ` +</span><span class="s3">\n            </span><span class="s1">`shouldInjectPolyfill() can't be called during initialization.`,</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (!polyfillsNames.has(name)) {</span><span class="s3">\n        </span><span class="s1">console.warn(</span><span class="s3">\n          </span><span class="s1">`Internal error in the ${providerName} provider: ` +</span><span class="s3">\n            </span><span class="s1">`unknown polyfill </span><span class="s3">\&quot;</span><span class="s1">${name}</span><span class="s3">\&quot;</span><span class="s1">.`,</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (filterPolyfills &amp;&amp; !filterPolyfills(name)) return false;</span><span class="s3">\n\n      </span><span class="s1">let shouldInject = isRequired(name, targets, {</span><span class="s3">\n        </span><span class="s1">compatData: polyfillsSupport,</span><span class="s3">\n        </span><span class="s1">includes: include,</span><span class="s3">\n        </span><span class="s1">excludes: exclude,</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n\n      </span><span class="s1">if (shouldInjectPolyfill) {</span><span class="s3">\n        </span><span class="s1">shouldInject = shouldInjectPolyfill(name, shouldInject);</span><span class="s3">\n        </span><span class="s1">if (typeof shouldInject !== </span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">throw new Error(`.shouldInjectPolyfill must return a boolean.`);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return shouldInject;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">debug(name) {</span><span class="s3">\n      </span><span class="s1">debugLog().found = true;</span><span class="s3">\n\n      </span><span class="s1">if (!debug || !name) return;</span><span class="s3">\n\n      </span><span class="s1">if (debugLog().polyfills.has(providerName)) return;</span><span class="s3">\n      </span><span class="s1">debugLog().polyfills.add(name);</span><span class="s3">\n      </span><span class="s1">debugLog().polyfillsSupport ??= polyfillsSupport;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">assertDependency(name, version = </span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">if (missingDependencies === false) return;</span><span class="s3">\n      </span><span class="s1">if (absoluteImports) {</span><span class="s3">\n        </span><span class="s1">// If absoluteImports is not false, we will try resolving</span><span class="s3">\n        </span><span class="s1">// the dependency and throw if it's not possible. We can</span><span class="s3">\n        </span><span class="s1">// skip the check here.</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const dep = version === </span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot; </span><span class="s1">? name : `${name}@^${version}`;</span><span class="s3">\n\n      </span><span class="s1">const found = missingDependencies.all</span><span class="s3">\n        </span><span class="s1">? false</span><span class="s3">\n        </span><span class="s1">: mapGetOr(depsCache, `${name} :: ${dirname}`, () =&gt;</span><span class="s3">\n            </span><span class="s1">deps.has(dirname, name),</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n\n      </span><span class="s1">if (!found) {</span><span class="s3">\n        </span><span class="s1">debugLog().missingDeps.add(dep);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">const provider = factory(api, providerOptions, dirname);</span><span class="s3">\n  </span><span class="s1">const providerName = provider.name || factory.name;</span><span class="s3">\n\n  </span><span class="s1">if (typeof provider[methodName] !== </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">`The </span><span class="s3">\&quot;</span><span class="s1">${providerName}</span><span class="s3">\&quot; </span><span class="s1">provider doesn't support the </span><span class="s3">\&quot;</span><span class="s1">${method}</span><span class="s3">\&quot; </span><span class="s1">polyfilling method.`,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (Array.isArray(provider.polyfills)) {</span><span class="s3">\n    </span><span class="s1">polyfillsNames = new Map(</span><span class="s3">\n      </span><span class="s1">provider.polyfills.map((name, index) =&gt; [name, index]),</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">filterPolyfills = provider.filterPolyfills;</span><span class="s3">\n  </span><span class="s1">} else if (provider.polyfills) {</span><span class="s3">\n    </span><span class="s1">polyfillsNames = new Map(</span><span class="s3">\n      </span><span class="s1">Object.keys(provider.polyfills).map((name, index) =&gt; [name, index]),</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">polyfillsSupport = provider.polyfills;</span><span class="s3">\n    </span><span class="s1">filterPolyfills = provider.filterPolyfills;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">polyfillsNames = new Map();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">({ include, exclude } = validateIncludeExclude(</span><span class="s3">\n    </span><span class="s1">providerName,</span><span class="s3">\n    </span><span class="s1">polyfillsNames,</span><span class="s3">\n    </span><span class="s1">providerOptions.include || [],</span><span class="s3">\n    </span><span class="s1">providerOptions.exclude || [],</span><span class="s3">\n  </span><span class="s1">));</span><span class="s3">\n\n  </span><span class="s1">let callProvider: (payload: MetaDescriptor, path: NodePath) =&gt; boolean;</span><span class="s3">\n  </span><span class="s1">if (methodName === </span><span class="s3">\&quot;</span><span class="s1">usageGlobal</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">callProvider = (payload, path) =&gt; {</span><span class="s3">\n      </span><span class="s1">const utils = getUtils(path);</span><span class="s3">\n      </span><span class="s1">return (</span><span class="s3">\n        </span><span class="s1">(provider[methodName](payload, utils, path) satisfies boolean) ?? false</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">callProvider = (payload, path) =&gt; {</span><span class="s3">\n      </span><span class="s1">const utils = getUtils(path);</span><span class="s3">\n      </span><span class="s1">provider[methodName](payload, utils, path) satisfies void;</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">debug,</span><span class="s3">\n    </span><span class="s1">method,</span><span class="s3">\n    </span><span class="s1">targets,</span><span class="s3">\n    </span><span class="s1">provider,</span><span class="s3">\n    </span><span class="s1">providerName,</span><span class="s3">\n    </span><span class="s1">callProvider,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default function definePolyfillProvider&lt;Options&gt;(</span><span class="s3">\n  </span><span class="s1">factory: PolyfillProvider&lt;Options&gt;,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">return declare((babelApi, options: PluginOptions, dirname: string) =&gt; {</span><span class="s3">\n    </span><span class="s1">babelApi.assertVersion(</span><span class="s3">\&quot;</span><span class="s1">^7.0.0 || ^8.0.0-alpha.0</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">const { traverse } = babelApi;</span><span class="s3">\n\n    </span><span class="s1">let debugLog;</span><span class="s3">\n\n    </span><span class="s1">const missingDependencies = applyMissingDependenciesDefaults(</span><span class="s3">\n      </span><span class="s1">options,</span><span class="s3">\n      </span><span class="s1">babelApi,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n\n    </span><span class="s1">const { debug, method, targets, provider, providerName, callProvider } =</span><span class="s3">\n      </span><span class="s1">instantiateProvider&lt;Options&gt;(</span><span class="s3">\n        </span><span class="s1">factory,</span><span class="s3">\n        </span><span class="s1">options,</span><span class="s3">\n        </span><span class="s1">missingDependencies,</span><span class="s3">\n        </span><span class="s1">dirname,</span><span class="s3">\n        </span><span class="s1">() =&gt; debugLog,</span><span class="s3">\n        </span><span class="s1">babelApi,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n\n    </span><span class="s1">const createVisitor = method === </span><span class="s3">\&quot;</span><span class="s1">entry-global</span><span class="s3">\&quot; </span><span class="s1">? v.entry : v.usage;</span><span class="s3">\n\n    </span><span class="s1">const visitor = provider.visitor</span><span class="s3">\n      </span><span class="s1">? traverse.visitors.merge([createVisitor(callProvider), provider.visitor])</span><span class="s3">\n      </span><span class="s1">: createVisitor(callProvider);</span><span class="s3">\n\n    </span><span class="s1">if (debug &amp;&amp; debug !== presetEnvSilentDebugHeader) {</span><span class="s3">\n      </span><span class="s1">console.log(`${providerName}: </span><span class="s3">\\</span><span class="s1">`DEBUG</span><span class="s3">\\</span><span class="s1">` option`);</span><span class="s3">\n      </span><span class="s1">console.log(`</span><span class="s3">\\</span><span class="s1">nUsing targets: ${stringifyTargetsMultiline(targets)}`);</span><span class="s3">\n      </span><span class="s1">console.log(`</span><span class="s3">\\</span><span class="s1">nUsing polyfills with </span><span class="s3">\\</span><span class="s1">`${method}</span><span class="s3">\\</span><span class="s1">` method:`);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const { runtimeName } = provider;</span><span class="s3">\n\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">name: </span><span class="s3">\&quot;</span><span class="s1">inject-polyfills</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">visitor,</span><span class="s3">\n\n      </span><span class="s1">pre(file) {</span><span class="s3">\n        </span><span class="s1">if (runtimeName) {</span><span class="s3">\n          </span><span class="s1">if (</span><span class="s3">\n            </span><span class="s1">file.get(</span><span class="s3">\&quot;</span><span class="s1">runtimeHelpersModuleName</span><span class="s3">\&quot;</span><span class="s1">) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">file.get(</span><span class="s3">\&quot;</span><span class="s1">runtimeHelpersModuleName</span><span class="s3">\&quot;</span><span class="s1">) !== runtimeName</span><span class="s3">\n          </span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">console.warn(</span><span class="s3">\n              </span><span class="s1">`Two different polyfill providers` +</span><span class="s3">\n                </span><span class="s1">` (${file.get(</span><span class="s3">\&quot;</span><span class="s1">runtimeHelpersModuleProvider</span><span class="s3">\&quot;</span><span class="s1">)}` +</span><span class="s3">\n                </span><span class="s1">` and ${providerName}) are trying to define two` +</span><span class="s3">\n                </span><span class="s1">` conflicting @babel/runtime alternatives:` +</span><span class="s3">\n                </span><span class="s1">` ${file.get(</span><span class="s3">\&quot;</span><span class="s1">runtimeHelpersModuleName</span><span class="s3">\&quot;</span><span class="s1">)} and ${runtimeName}.` +</span><span class="s3">\n                </span><span class="s1">` The second one will be ignored.`,</span><span class="s3">\n            </span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">file.set(</span><span class="s3">\&quot;</span><span class="s1">runtimeHelpersModuleName</span><span class="s3">\&quot;</span><span class="s1">, runtimeName);</span><span class="s3">\n            </span><span class="s1">file.set(</span><span class="s3">\&quot;</span><span class="s1">runtimeHelpersModuleProvider</span><span class="s3">\&quot;</span><span class="s1">, providerName);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">debugLog = {</span><span class="s3">\n          </span><span class="s1">polyfills: new Set(),</span><span class="s3">\n          </span><span class="s1">polyfillsSupport: undefined,</span><span class="s3">\n          </span><span class="s1">found: false,</span><span class="s3">\n          </span><span class="s1">providers: new Set(),</span><span class="s3">\n          </span><span class="s1">missingDeps: new Set(),</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n\n        </span><span class="s1">provider.pre?.apply(this, arguments);</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">post() {</span><span class="s3">\n        </span><span class="s1">provider.post?.apply(this, arguments);</span><span class="s3">\n\n        </span><span class="s1">if (missingDependencies !== false) {</span><span class="s3">\n          </span><span class="s1">if (missingDependencies.log === </span><span class="s3">\&quot;</span><span class="s1">per-file</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">deps.logMissing(debugLog.missingDeps);</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">deps.laterLogMissing(debugLog.missingDeps);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (!debug) return;</span><span class="s3">\n\n        </span><span class="s1">if (this.filename) console.log(`</span><span class="s3">\\</span><span class="s1">n[${this.filename}]`);</span><span class="s3">\n\n        </span><span class="s1">if (debugLog.polyfills.size === 0) {</span><span class="s3">\n          </span><span class="s1">console.log(</span><span class="s3">\n            </span><span class="s1">method === </span><span class="s3">\&quot;</span><span class="s1">entry-global</span><span class="s3">\&quot;\n              </span><span class="s1">? debugLog.found</span><span class="s3">\n                </span><span class="s1">? `Based on your targets, the ${providerName} polyfill did not add any polyfill.`</span><span class="s3">\n                </span><span class="s1">: `The entry point for the ${providerName} polyfill has not been found.`</span><span class="s3">\n              </span><span class="s1">: `Based on your code and targets, the ${providerName} polyfill did not add any polyfill.`,</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n\n          </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (method === </span><span class="s3">\&quot;</span><span class="s1">entry-global</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">console.log(</span><span class="s3">\n            </span><span class="s1">`The ${providerName} polyfill entry has been replaced with ` +</span><span class="s3">\n              </span><span class="s1">`the following polyfills:`,</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">console.log(</span><span class="s3">\n            </span><span class="s1">`The ${providerName} polyfill added the following polyfills:`,</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">for (const name of debugLog.polyfills) {</span><span class="s3">\n          </span><span class="s1">if (debugLog.polyfillsSupport?.[name]) {</span><span class="s3">\n            </span><span class="s1">const filteredTargets = getInclusionReasons(</span><span class="s3">\n              </span><span class="s1">name,</span><span class="s3">\n              </span><span class="s1">targets,</span><span class="s3">\n              </span><span class="s1">debugLog.polyfillsSupport,</span><span class="s3">\n            </span><span class="s1">);</span><span class="s3">\n\n            </span><span class="s1">const formattedTargets = JSON.stringify(filteredTargets)</span><span class="s3">\n              </span><span class="s1">.replace(/,/g, </span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n              </span><span class="s1">.replace(/^</span><span class="s3">\\</span><span class="s1">{</span><span class="s3">\&quot;</span><span class="s1">/, '{ </span><span class="s3">\&quot;</span><span class="s1">')</span><span class="s3">\n              </span><span class="s1">.replace(/</span><span class="s3">\&quot;\\</span><span class="s1">}$/, '</span><span class="s3">\&quot; </span><span class="s1">}');</span><span class="s3">\n\n            </span><span class="s1">console.log(`  ${name} ${formattedTargets}`);</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">console.log(`  ${name}`);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function mapGetOr(map, key, getDefault) {</span><span class="s3">\n  </span><span class="s1">let val = map.get(key);</span><span class="s3">\n  </span><span class="s1">if (val === undefined) {</span><span class="s3">\n    </span><span class="s1">val = getDefault();</span><span class="s3">\n    </span><span class="s1">map.set(key, val);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return val;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function isEmpty(obj) {</span><span class="s3">\n  </span><span class="s1">return Object.keys(obj).length === 0;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;types&quot;</span><span class="s0">,</span><span class="s1">&quot;t&quot;</span><span class="s0">,</span><span class="s1">&quot;template&quot;</span><span class="s0">,</span><span class="s1">&quot;_babel&quot;</span><span class="s0">,</span><span class="s1">&quot;default&quot;</span><span class="s0">,</span><span class="s1">&quot;intersection&quot;</span><span class="s0">,</span><span class="s1">&quot;a&quot;</span><span class="s0">,</span><span class="s1">&quot;b&quot;</span><span class="s0">,</span><span class="s1">&quot;result&quot;</span><span class="s0">,</span><span class="s1">&quot;Set&quot;</span><span class="s0">,</span><span class="s1">&quot;forEach&quot;</span><span class="s0">,</span><span class="s1">&quot;v&quot;</span><span class="s0">,</span><span class="s1">&quot;has&quot;</span><span class="s0">,</span><span class="s1">&quot;add&quot;</span><span class="s0">,</span><span class="s1">&quot;object&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;prototype&quot;</span><span class="s0">,</span><span class="s1">&quot;hasOwnProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;call&quot;</span><span class="s0">,</span><span class="s1">&quot;resolve&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;resolved&quot;</span><span class="s0">,</span><span class="s1">&quot;isVariableDeclarator&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;isIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;isReferencedIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;binding&quot;</span><span class="s0">,</span><span class="s1">&quot;scope&quot;</span><span class="s0">,</span><span class="s1">&quot;getBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;constant&quot;</span><span class="s0">,</span><span class="s1">&quot;resolveId&quot;</span><span class="s0">,</span><span class="s1">&quot;hasBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;resolveKey&quot;</span><span class="s0">,</span><span class="s1">&quot;computed&quot;</span><span class="s0">,</span><span class="s1">&quot;isStringLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;parent&quot;</span><span class="s0">,</span><span class="s1">&quot;isMemberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;sym&quot;</span><span class="s0">,</span><span class="s1">&quot;isPure&quot;</span><span class="s0">,</span><span class="s1">&quot;evaluate&quot;</span><span class="s0">,</span><span class="s1">&quot;resolveSource&quot;</span><span class="s0">,</span><span class="s1">&quot;obj&quot;</span><span class="s0">,</span><span class="s1">&quot;id&quot;</span><span class="s0">,</span><span class="s1">&quot;placement&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;getImportSource&quot;</span><span class="s0">,</span><span class="s1">&quot;specifiers&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;source&quot;</span><span class="s0">,</span><span class="s1">&quot;getRequireSource&quot;</span><span class="s0">,</span><span class="s1">&quot;isExpressionStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;expression&quot;</span><span class="s0">,</span><span class="s1">&quot;isCallExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;callee&quot;</span><span class="s0">,</span><span class="s1">&quot;arguments&quot;</span><span class="s0">,</span><span class="s1">&quot;hoist&quot;</span><span class="s0">,</span><span class="s1">&quot;_blockHoist&quot;</span><span class="s0">,</span><span class="s1">&quot;createUtilsGetter&quot;</span><span class="s0">,</span><span class="s1">&quot;cache&quot;</span><span class="s0">,</span><span class="s1">&quot;prog&quot;</span><span class="s0">,</span><span class="s1">&quot;findParent&quot;</span><span class="s0">,</span><span class="s1">&quot;p&quot;</span><span class="s0">,</span><span class="s1">&quot;isProgram&quot;</span><span class="s0">,</span><span class="s1">&quot;injectGlobalImport&quot;</span><span class="s0">,</span><span class="s1">&quot;url&quot;</span><span class="s0">,</span><span class="s1">&quot;moduleName&quot;</span><span class="s0">,</span><span class="s1">&quot;storeAnonymous&quot;</span><span class="s0">,</span><span class="s1">&quot;isScript&quot;</span><span class="s0">,</span><span class="s1">&quot;statement&quot;</span><span class="s0">,</span><span class="s1">&quot;ast&quot;</span><span class="s0">,</span><span class="s1">&quot;importDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;injectNamedImport&quot;</span><span class="s0">,</span><span class="s1">&quot;hint&quot;</span><span class="s0">,</span><span class="s1">&quot;storeNamed&quot;</span><span class="s0">,</span><span class="s1">&quot;generateUidIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;importSpecifier&quot;</span><span class="s0">,</span><span class="s1">&quot;injectDefaultImport&quot;</span><span class="s0">,</span><span class="s1">&quot;importDefaultSpecifier&quot;</span><span class="s0">,</span><span class="s1">&quot;ImportsCachedInjector&quot;</span><span class="s0">,</span><span class="s1">&quot;constructor&quot;</span><span class="s0">,</span><span class="s1">&quot;resolver&quot;</span><span class="s0">,</span><span class="s1">&quot;getPreferredIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;_imports&quot;</span><span class="s0">,</span><span class="s1">&quot;WeakMap&quot;</span><span class="s0">,</span><span class="s1">&quot;_anonymousImports&quot;</span><span class="s0">,</span><span class="s1">&quot;_lastImports&quot;</span><span class="s0">,</span><span class="s1">&quot;_resolver&quot;</span><span class="s0">,</span><span class="s1">&quot;_getPreferredIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;programPath&quot;</span><span class="s0">,</span><span class="s1">&quot;getVal&quot;</span><span class="s0">,</span><span class="s1">&quot;_normalizeKey&quot;</span><span class="s0">,</span><span class="s1">&quot;imports&quot;</span><span class="s0">,</span><span class="s1">&quot;_ensure&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceType&quot;</span><span class="s0">,</span><span class="s1">&quot;stringLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;_injectImport&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;identifier&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;_this$_lastImports$ge&quot;</span><span class="s0">,</span><span class="s1">&quot;newIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;lastImports&quot;</span><span class="s0">,</span><span class="s1">&quot;isPathStillValid&quot;</span><span class="s0">,</span><span class="s1">&quot;container&quot;</span><span class="s0">,</span><span class="s1">&quot;body&quot;</span><span class="s0">,</span><span class="s1">&quot;last&quot;</span><span class="s0">,</span><span class="s1">&quot;Infinity&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;data&quot;</span><span class="s0">,</span><span class="s1">&quot;entries&quot;</span><span class="s0">,</span><span class="s1">&quot;index&quot;</span><span class="s0">,</span><span class="s1">&quot;newPath&quot;</span><span class="s0">,</span><span class="s1">&quot;insertBefore&quot;</span><span class="s0">,</span><span class="s1">&quot;splice&quot;</span><span class="s0">,</span><span class="s1">&quot;insertAfter&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;unshiftContainer&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;Collection&quot;</span><span class="s0">,</span><span class="s1">&quot;collection&quot;</span><span class="s0">,</span><span class="s1">&quot;presetEnvSilentDebugHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;stringifyTargetsMultiline&quot;</span><span class="s0">,</span><span class="s1">&quot;targets&quot;</span><span class="s0">,</span><span class="s1">&quot;JSON&quot;</span><span class="s0">,</span><span class="s1">&quot;stringify&quot;</span><span class="s0">,</span><span class="s1">&quot;prettifyTargets&quot;</span><span class="s0">,</span><span class="s1">&quot;patternToRegExp&quot;</span><span class="s0">,</span><span class="s1">&quot;pattern&quot;</span><span class="s0">,</span><span class="s1">&quot;RegExp&quot;</span><span class="s0">,</span><span class="s1">&quot;buildUnusedError&quot;</span><span class="s0">,</span><span class="s1">&quot;label&quot;</span><span class="s0">,</span><span class="s1">&quot;unused&quot;</span><span class="s0">,</span><span class="s1">&quot;original&quot;</span><span class="s0">,</span><span class="s1">&quot;String&quot;</span><span class="s0">,</span><span class="s1">&quot;join&quot;</span><span class="s0">,</span><span class="s1">&quot;buldDuplicatesError&quot;</span><span class="s0">,</span><span class="s1">&quot;duplicates&quot;</span><span class="s0">,</span><span class="s1">&quot;size&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;from&quot;</span><span class="s0">,</span><span class="s1">&quot;validateIncludeExclude&quot;</span><span class="s0">,</span><span class="s1">&quot;provider&quot;</span><span class="s0">,</span><span class="s1">&quot;polyfills&quot;</span><span class="s0">,</span><span class="s1">&quot;includePatterns&quot;</span><span class="s0">,</span><span class="s1">&quot;excludePatterns&quot;</span><span class="s0">,</span><span class="s1">&quot;current&quot;</span><span class="s0">,</span><span class="s1">&quot;filter&quot;</span><span class="s0">,</span><span class="s1">&quot;regexp&quot;</span><span class="s0">,</span><span class="s1">&quot;matched&quot;</span><span class="s0">,</span><span class="s1">&quot;polyfill&quot;</span><span class="s0">,</span><span class="s1">&quot;keys&quot;</span><span class="s0">,</span><span class="s1">&quot;test&quot;</span><span class="s0">,</span><span class="s1">&quot;include&quot;</span><span class="s0">,</span><span class="s1">&quot;unusedInclude&quot;</span><span class="s0">,</span><span class="s1">&quot;exclude&quot;</span><span class="s0">,</span><span class="s1">&quot;unusedExclude&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;applyMissingDependenciesDefaults&quot;</span><span class="s0">,</span><span class="s1">&quot;options&quot;</span><span class="s0">,</span><span class="s1">&quot;babelApi&quot;</span><span class="s0">,</span><span class="s1">&quot;missingDependencies&quot;</span><span class="s0">,</span><span class="s1">&quot;caller&quot;</span><span class="s0">,</span><span class="s1">&quot;log&quot;</span><span class="s0">,</span><span class="s1">&quot;inject&quot;</span><span class="s0">,</span><span class="s1">&quot;all&quot;</span><span class="s0">,</span><span class="s1">&quot;isRemoved&quot;</span><span class="s0">,</span><span class="s1">&quot;removed&quot;</span><span class="s0">,</span><span class="s1">&quot;parentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;listKey&quot;</span><span class="s0">,</span><span class="s1">&quot;_path$parentPath$node&quot;</span><span class="s0">,</span><span class="s1">&quot;includes&quot;</span><span class="s0">,</span><span class="s1">&quot;callProvider&quot;</span><span class="s0">,</span><span class="s1">&quot;property&quot;</span><span class="s0">,</span><span class="s1">&quot;kind&quot;</span><span class="s0">,</span><span class="s1">&quot;handleReferencedIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;getBindingIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;analyzeMemberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;handleAsMemberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;ReferencedIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;MemberExpression|OptionalMemberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;objectIsGlobalIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;isImportNamespaceSpecifier&quot;</span><span class="s0">,</span><span class="s1">&quot;skipObject&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldSkip&quot;</span><span class="s0">,</span><span class="s1">&quot;ObjectPattern&quot;</span><span class="s0">,</span><span class="s1">&quot;isAssignmentExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isFunction&quot;</span><span class="s0">,</span><span class="s1">&quot;grand&quot;</span><span class="s0">,</span><span class="s1">&quot;isNewExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;prop&quot;</span><span class="s0">,</span><span class="s1">&quot;isObjectProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;BinaryExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;operator&quot;</span><span class="s0">,</span><span class="s1">&quot;ImportDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;Program&quot;</span><span class="s0">,</span><span class="s1">&quot;bodyPath&quot;</span><span class="s0">,</span><span class="s1">&quot;nativeRequireResolve&quot;</span><span class="s0">,</span><span class="s1">&quot;parseFloat&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;versions&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;createRequire&quot;</span><span class="s0">,</span><span class="s1">&quot;import&quot;</span><span class="s0">,</span><span class="s1">&quot;meta&quot;</span><span class="s0">,</span><span class="s1">&quot;myResolve&quot;</span><span class="s0">,</span><span class="s1">&quot;basedir&quot;</span><span class="s0">,</span><span class="s1">&quot;paths&quot;</span><span class="s0">,</span><span class="s1">&quot;replace&quot;</span><span class="s0">,</span><span class="s1">&quot;requireResolve&quot;</span><span class="s0">,</span><span class="s1">&quot;sync&quot;</span><span class="s0">,</span><span class="s1">&quot;dirname&quot;</span><span class="s0">,</span><span class="s1">&quot;absoluteImports&quot;</span><span class="s0">,</span><span class="s1">&quot;err&quot;</span><span class="s0">,</span><span class="s1">&quot;code&quot;</span><span class="s0">,</span><span class="s1">&quot;assign&quot;</span><span class="s0">,</span><span class="s1">&quot;logMissing&quot;</span><span class="s0">,</span><span class="s1">&quot;missingDeps&quot;</span><span class="s0">,</span><span class="s1">&quot;deps&quot;</span><span class="s0">,</span><span class="s1">&quot;sort&quot;</span><span class="s0">,</span><span class="s1">&quot;console&quot;</span><span class="s0">,</span><span class="s1">&quot;warn&quot;</span><span class="s0">,</span><span class="s1">&quot;exitCode&quot;</span><span class="s0">,</span><span class="s1">&quot;allMissingDeps&quot;</span><span class="s0">,</span><span class="s1">&quot;laterLogMissingDependencies&quot;</span><span class="s0">,</span><span class="s1">&quot;debounce&quot;</span><span class="s0">,</span><span class="s1">&quot;laterLogMissing&quot;</span><span class="s0">,</span><span class="s1">&quot;PossibleGlobalObjects&quot;</span><span class="s0">,</span><span class="s1">&quot;createMetaResolver&quot;</span><span class="s0">,</span><span class="s1">&quot;static&quot;</span><span class="s0">,</span><span class="s1">&quot;staticP&quot;</span><span class="s0">,</span><span class="s1">&quot;instance&quot;</span><span class="s0">,</span><span class="s1">&quot;instanceP&quot;</span><span class="s0">,</span><span class="s1">&quot;global&quot;</span><span class="s0">,</span><span class="s1">&quot;globalP&quot;</span><span class="s0">,</span><span class="s1">&quot;desc&quot;</span><span class="s0">,</span><span class="s1">&quot;getTargets&quot;</span><span class="s0">,</span><span class="s1">&quot;_getTargets&quot;</span><span class="s0">,</span><span class="s1">&quot;resolveOptions&quot;</span><span class="s0">,</span><span class="s1">&quot;method&quot;</span><span class="s0">,</span><span class="s1">&quot;targetsOption&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreBrowserslistConfig&quot;</span><span class="s0">,</span><span class="s1">&quot;configPath&quot;</span><span class="s0">,</span><span class="s1">&quot;debug&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldInjectPolyfill&quot;</span><span class="s0">,</span><span class="s1">&quot;providerOptions&quot;</span><span class="s0">,</span><span class="s1">&quot;isEmpty&quot;</span><span class="s0">,</span><span class="s1">&quot;methodName&quot;</span><span class="s0">,</span><span class="s1">&quot;targetsObj&quot;</span><span class="s0">,</span><span class="s1">&quot;isArray&quot;</span><span class="s0">,</span><span class="s1">&quot;browsers&quot;</span><span class="s0">,</span><span class="s1">&quot;instantiateProvider&quot;</span><span class="s0">,</span><span class="s1">&quot;factory&quot;</span><span class="s0">,</span><span class="s1">&quot;debugLog&quot;</span><span class="s0">,</span><span class="s1">&quot;polyfillsSupport&quot;</span><span class="s0">,</span><span class="s1">&quot;polyfillsNames&quot;</span><span class="s0">,</span><span class="s1">&quot;filterPolyfills&quot;</span><span class="s0">,</span><span class="s1">&quot;getUtils&quot;</span><span class="s0">,</span><span class="s1">&quot;_polyfillsNames$get&quot;</span><span class="s0">,</span><span class="s1">&quot;_polyfillsNames&quot;</span><span class="s0">,</span><span class="s1">&quot;depsCache&quot;</span><span class="s0">,</span><span class="s1">&quot;api&quot;</span><span class="s0">,</span><span class="s1">&quot;babel&quot;</span><span class="s0">,</span><span class="s1">&quot;providerName&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldInject&quot;</span><span class="s0">,</span><span class="s1">&quot;isRequired&quot;</span><span class="s0">,</span><span class="s1">&quot;compatData&quot;</span><span class="s0">,</span><span class="s1">&quot;excludes&quot;</span><span class="s0">,</span><span class="s1">&quot;_debugLog&quot;</span><span class="s0">,</span><span class="s1">&quot;_debugLog$polyfillsSu&quot;</span><span class="s0">,</span><span class="s1">&quot;found&quot;</span><span class="s0">,</span><span class="s1">&quot;assertDependency&quot;</span><span class="s0">,</span><span class="s1">&quot;version&quot;</span><span class="s0">,</span><span class="s1">&quot;dep&quot;</span><span class="s0">,</span><span class="s1">&quot;mapGetOr&quot;</span><span class="s0">,</span><span class="s1">&quot;payload&quot;</span><span class="s0">,</span><span class="s1">&quot;_ref&quot;</span><span class="s0">,</span><span class="s1">&quot;utils&quot;</span><span class="s0">,</span><span class="s1">&quot;definePolyfillProvider&quot;</span><span class="s0">,</span><span class="s1">&quot;declare&quot;</span><span class="s0">,</span><span class="s1">&quot;assertVersion&quot;</span><span class="s0">,</span><span class="s1">&quot;traverse&quot;</span><span class="s0">,</span><span class="s1">&quot;createVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;visitor&quot;</span><span class="s0">,</span><span class="s1">&quot;visitors&quot;</span><span class="s0">,</span><span class="s1">&quot;merge&quot;</span><span class="s0">,</span><span class="s1">&quot;runtimeName&quot;</span><span class="s0">,</span><span class="s1">&quot;pre&quot;</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">,</span><span class="s1">&quot;_provider$pre&quot;</span><span class="s0">,</span><span class="s1">&quot;providers&quot;</span><span class="s0">,</span><span class="s1">&quot;apply&quot;</span><span class="s0">,</span><span class="s1">&quot;post&quot;</span><span class="s0">,</span><span class="s1">&quot;_provider$post&quot;</span><span class="s0">,</span><span class="s1">&quot;filename&quot;</span><span class="s0">,</span><span class="s1">&quot;_debugLog$polyfillsSu2&quot;</span><span class="s0">,</span><span class="s1">&quot;filteredTargets&quot;</span><span class="s0">,</span><span class="s1">&quot;getInclusionReasons&quot;</span><span class="s0">,</span><span class="s1">&quot;formattedTargets&quot;</span><span class="s0">,</span><span class="s1">&quot;getDefault&quot;</span><span class="s0">,</span><span class="s1">&quot;val&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">}</span></pre>
</body>
</html>