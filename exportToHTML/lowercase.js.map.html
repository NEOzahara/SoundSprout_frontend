<html>
<head>
<title>lowercase.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
lowercase.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_validate&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;_deprecationWarning&quot;</span><span class="s0">,</span><span class="s1">&quot;utils&quot;</span><span class="s0">,</span><span class="s1">&quot;validateInternal&quot;</span><span class="s0">,</span><span class="s1">&quot;validate&quot;</span><span class="s0">,</span><span class="s1">&quot;NODE_FIELDS&quot;</span><span class="s0">,</span><span class="s1">&quot;arrayExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;elements&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;defs&quot;</span><span class="s0">,</span><span class="s1">&quot;ArrayExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;assignmentExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;operator&quot;</span><span class="s0">,</span><span class="s1">&quot;left&quot;</span><span class="s0">,</span><span class="s1">&quot;right&quot;</span><span class="s0">,</span><span class="s1">&quot;AssignmentExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;binaryExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;BinaryExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;interpreterDirective&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;InterpreterDirective&quot;</span><span class="s0">,</span><span class="s1">&quot;directive&quot;</span><span class="s0">,</span><span class="s1">&quot;Directive&quot;</span><span class="s0">,</span><span class="s1">&quot;directiveLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;DirectiveLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;blockStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;body&quot;</span><span class="s0">,</span><span class="s1">&quot;directives&quot;</span><span class="s0">,</span><span class="s1">&quot;BlockStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;breakStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;label&quot;</span><span class="s0">,</span><span class="s1">&quot;BreakStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;callExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;callee&quot;</span><span class="s0">,</span><span class="s1">&quot;_arguments&quot;</span><span class="s0">,</span><span class="s1">&quot;arguments&quot;</span><span class="s0">,</span><span class="s1">&quot;CallExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;catchClause&quot;</span><span class="s0">,</span><span class="s1">&quot;param&quot;</span><span class="s0">,</span><span class="s1">&quot;CatchClause&quot;</span><span class="s0">,</span><span class="s1">&quot;conditionalExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;test&quot;</span><span class="s0">,</span><span class="s1">&quot;consequent&quot;</span><span class="s0">,</span><span class="s1">&quot;alternate&quot;</span><span class="s0">,</span><span class="s1">&quot;ConditionalExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;continueStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;ContinueStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;debuggerStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;doWhileStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;DoWhileStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;emptyStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;expressionStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;expression&quot;</span><span class="s0">,</span><span class="s1">&quot;ExpressionStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">,</span><span class="s1">&quot;program&quot;</span><span class="s0">,</span><span class="s1">&quot;comments&quot;</span><span class="s0">,</span><span class="s1">&quot;tokens&quot;</span><span class="s0">,</span><span class="s1">&quot;File&quot;</span><span class="s0">,</span><span class="s1">&quot;forInStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;ForInStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;forStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;init&quot;</span><span class="s0">,</span><span class="s1">&quot;update&quot;</span><span class="s0">,</span><span class="s1">&quot;ForStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;functionDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;id&quot;</span><span class="s0">,</span><span class="s1">&quot;params&quot;</span><span class="s0">,</span><span class="s1">&quot;generator&quot;</span><span class="s0">,</span><span class="s1">&quot;async&quot;</span><span class="s0">,</span><span class="s1">&quot;FunctionDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;functionExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;FunctionExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;identifier&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;Identifier&quot;</span><span class="s0">,</span><span class="s1">&quot;ifStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;IfStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;labeledStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;LabeledStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;stringLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;StringLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;numericLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;NumericLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;nullLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;booleanLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;BooleanLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;regExpLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;pattern&quot;</span><span class="s0">,</span><span class="s1">&quot;flags&quot;</span><span class="s0">,</span><span class="s1">&quot;RegExpLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;logicalExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;LogicalExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;memberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;object&quot;</span><span class="s0">,</span><span class="s1">&quot;property&quot;</span><span class="s0">,</span><span class="s1">&quot;computed&quot;</span><span class="s0">,</span><span class="s1">&quot;optional&quot;</span><span class="s0">,</span><span class="s1">&quot;MemberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;newExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;NewExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceType&quot;</span><span class="s0">,</span><span class="s1">&quot;interpreter&quot;</span><span class="s0">,</span><span class="s1">&quot;Program&quot;</span><span class="s0">,</span><span class="s1">&quot;objectExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;properties&quot;</span><span class="s0">,</span><span class="s1">&quot;ObjectExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;objectMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;kind&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;ObjectMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;objectProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;shorthand&quot;</span><span class="s0">,</span><span class="s1">&quot;decorators&quot;</span><span class="s0">,</span><span class="s1">&quot;ObjectProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;restElement&quot;</span><span class="s0">,</span><span class="s1">&quot;argument&quot;</span><span class="s0">,</span><span class="s1">&quot;RestElement&quot;</span><span class="s0">,</span><span class="s1">&quot;returnStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;ReturnStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;sequenceExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;expressions&quot;</span><span class="s0">,</span><span class="s1">&quot;SequenceExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;parenthesizedExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;ParenthesizedExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;switchCase&quot;</span><span class="s0">,</span><span class="s1">&quot;SwitchCase&quot;</span><span class="s0">,</span><span class="s1">&quot;switchStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;discriminant&quot;</span><span class="s0">,</span><span class="s1">&quot;cases&quot;</span><span class="s0">,</span><span class="s1">&quot;SwitchStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;thisExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;throwStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;ThrowStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;tryStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;block&quot;</span><span class="s0">,</span><span class="s1">&quot;handler&quot;</span><span class="s0">,</span><span class="s1">&quot;finalizer&quot;</span><span class="s0">,</span><span class="s1">&quot;TryStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;unaryExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;prefix&quot;</span><span class="s0">,</span><span class="s1">&quot;UnaryExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;updateExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;UpdateExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;variableDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;declarations&quot;</span><span class="s0">,</span><span class="s1">&quot;VariableDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;variableDeclarator&quot;</span><span class="s0">,</span><span class="s1">&quot;VariableDeclarator&quot;</span><span class="s0">,</span><span class="s1">&quot;whileStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;WhileStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;withStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;WithStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;assignmentPattern&quot;</span><span class="s0">,</span><span class="s1">&quot;AssignmentPattern&quot;</span><span class="s0">,</span><span class="s1">&quot;arrayPattern&quot;</span><span class="s0">,</span><span class="s1">&quot;ArrayPattern&quot;</span><span class="s0">,</span><span class="s1">&quot;arrowFunctionExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;ArrowFunctionExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;classBody&quot;</span><span class="s0">,</span><span class="s1">&quot;ClassBody&quot;</span><span class="s0">,</span><span class="s1">&quot;classExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;superClass&quot;</span><span class="s0">,</span><span class="s1">&quot;ClassExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;classDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;ClassDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;exportAllDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;source&quot;</span><span class="s0">,</span><span class="s1">&quot;ExportAllDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;exportDefaultDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;declaration&quot;</span><span class="s0">,</span><span class="s1">&quot;ExportDefaultDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;exportNamedDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;specifiers&quot;</span><span class="s0">,</span><span class="s1">&quot;ExportNamedDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;exportSpecifier&quot;</span><span class="s0">,</span><span class="s1">&quot;local&quot;</span><span class="s0">,</span><span class="s1">&quot;exported&quot;</span><span class="s0">,</span><span class="s1">&quot;ExportSpecifier&quot;</span><span class="s0">,</span><span class="s1">&quot;forOfStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;_await&quot;</span><span class="s0">,</span><span class="s1">&quot;await&quot;</span><span class="s0">,</span><span class="s1">&quot;ForOfStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;importDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;ImportDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;importDefaultSpecifier&quot;</span><span class="s0">,</span><span class="s1">&quot;ImportDefaultSpecifier&quot;</span><span class="s0">,</span><span class="s1">&quot;importNamespaceSpecifier&quot;</span><span class="s0">,</span><span class="s1">&quot;ImportNamespaceSpecifier&quot;</span><span class="s0">,</span><span class="s1">&quot;importSpecifier&quot;</span><span class="s0">,</span><span class="s1">&quot;imported&quot;</span><span class="s0">,</span><span class="s1">&quot;ImportSpecifier&quot;</span><span class="s0">,</span><span class="s1">&quot;importExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;options&quot;</span><span class="s0">,</span><span class="s1">&quot;ImportExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;metaProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;meta&quot;</span><span class="s0">,</span><span class="s1">&quot;MetaProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;classMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;_static&quot;</span><span class="s0">,</span><span class="s1">&quot;static&quot;</span><span class="s0">,</span><span class="s1">&quot;ClassMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;objectPattern&quot;</span><span class="s0">,</span><span class="s1">&quot;ObjectPattern&quot;</span><span class="s0">,</span><span class="s1">&quot;spreadElement&quot;</span><span class="s0">,</span><span class="s1">&quot;SpreadElement&quot;</span><span class="s0">,</span><span class="s1">&quot;_super&quot;</span><span class="s0">,</span><span class="s1">&quot;taggedTemplateExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;tag&quot;</span><span class="s0">,</span><span class="s1">&quot;quasi&quot;</span><span class="s0">,</span><span class="s1">&quot;TaggedTemplateExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;templateElement&quot;</span><span class="s0">,</span><span class="s1">&quot;tail&quot;</span><span class="s0">,</span><span class="s1">&quot;TemplateElement&quot;</span><span class="s0">,</span><span class="s1">&quot;templateLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;quasis&quot;</span><span class="s0">,</span><span class="s1">&quot;TemplateLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;yieldExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;delegate&quot;</span><span class="s0">,</span><span class="s1">&quot;YieldExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;awaitExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;AwaitExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;_import&quot;</span><span class="s0">,</span><span class="s1">&quot;bigIntLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;BigIntLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;exportNamespaceSpecifier&quot;</span><span class="s0">,</span><span class="s1">&quot;ExportNamespaceSpecifier&quot;</span><span class="s0">,</span><span class="s1">&quot;optionalMemberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;OptionalMemberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;optionalCallExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;OptionalCallExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;classProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;typeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;ClassProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;classAccessorProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;ClassAccessorProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;classPrivateProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;ClassPrivateProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;classPrivateMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;ClassPrivateMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;privateName&quot;</span><span class="s0">,</span><span class="s1">&quot;PrivateName&quot;</span><span class="s0">,</span><span class="s1">&quot;staticBlock&quot;</span><span class="s0">,</span><span class="s1">&quot;StaticBlock&quot;</span><span class="s0">,</span><span class="s1">&quot;importAttribute&quot;</span><span class="s0">,</span><span class="s1">&quot;ImportAttribute&quot;</span><span class="s0">,</span><span class="s1">&quot;anyTypeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;arrayTypeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;elementType&quot;</span><span class="s0">,</span><span class="s1">&quot;ArrayTypeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;booleanTypeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;booleanLiteralTypeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;BooleanLiteralTypeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;nullLiteralTypeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;classImplements&quot;</span><span class="s0">,</span><span class="s1">&quot;typeParameters&quot;</span><span class="s0">,</span><span class="s1">&quot;ClassImplements&quot;</span><span class="s0">,</span><span class="s1">&quot;declareClass&quot;</span><span class="s0">,</span><span class="s1">&quot;_extends&quot;</span><span class="s0">,</span><span class="s1">&quot;extends&quot;</span><span class="s0">,</span><span class="s1">&quot;DeclareClass&quot;</span><span class="s0">,</span><span class="s1">&quot;declareFunction&quot;</span><span class="s0">,</span><span class="s1">&quot;DeclareFunction&quot;</span><span class="s0">,</span><span class="s1">&quot;declareInterface&quot;</span><span class="s0">,</span><span class="s1">&quot;DeclareInterface&quot;</span><span class="s0">,</span><span class="s1">&quot;declareModule&quot;</span><span class="s0">,</span><span class="s1">&quot;DeclareModule&quot;</span><span class="s0">,</span><span class="s1">&quot;declareModuleExports&quot;</span><span class="s0">,</span><span class="s1">&quot;DeclareModuleExports&quot;</span><span class="s0">,</span><span class="s1">&quot;declareTypeAlias&quot;</span><span class="s0">,</span><span class="s1">&quot;DeclareTypeAlias&quot;</span><span class="s0">,</span><span class="s1">&quot;declareOpaqueType&quot;</span><span class="s0">,</span><span class="s1">&quot;supertype&quot;</span><span class="s0">,</span><span class="s1">&quot;DeclareOpaqueType&quot;</span><span class="s0">,</span><span class="s1">&quot;declareVariable&quot;</span><span class="s0">,</span><span class="s1">&quot;DeclareVariable&quot;</span><span class="s0">,</span><span class="s1">&quot;declareExportDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;attributes&quot;</span><span class="s0">,</span><span class="s1">&quot;DeclareExportDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;declareExportAllDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;DeclareExportAllDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;declaredPredicate&quot;</span><span class="s0">,</span><span class="s1">&quot;DeclaredPredicate&quot;</span><span class="s0">,</span><span class="s1">&quot;existsTypeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;functionTypeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;rest&quot;</span><span class="s0">,</span><span class="s1">&quot;returnType&quot;</span><span class="s0">,</span><span class="s1">&quot;FunctionTypeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;functionTypeParam&quot;</span><span class="s0">,</span><span class="s1">&quot;FunctionTypeParam&quot;</span><span class="s0">,</span><span class="s1">&quot;genericTypeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;GenericTypeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;inferredPredicate&quot;</span><span class="s0">,</span><span class="s1">&quot;interfaceExtends&quot;</span><span class="s0">,</span><span class="s1">&quot;InterfaceExtends&quot;</span><span class="s0">,</span><span class="s1">&quot;interfaceDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;InterfaceDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;interfaceTypeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;InterfaceTypeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;intersectionTypeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;types&quot;</span><span class="s0">,</span><span class="s1">&quot;IntersectionTypeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;mixedTypeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;emptyTypeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;nullableTypeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;NullableTypeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;numberLiteralTypeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;NumberLiteralTypeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;numberTypeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;objectTypeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;indexers&quot;</span><span class="s0">,</span><span class="s1">&quot;callProperties&quot;</span><span class="s0">,</span><span class="s1">&quot;internalSlots&quot;</span><span class="s0">,</span><span class="s1">&quot;exact&quot;</span><span class="s0">,</span><span class="s1">&quot;ObjectTypeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;objectTypeInternalSlot&quot;</span><span class="s0">,</span><span class="s1">&quot;method&quot;</span><span class="s0">,</span><span class="s1">&quot;ObjectTypeInternalSlot&quot;</span><span class="s0">,</span><span class="s1">&quot;objectTypeCallProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;ObjectTypeCallProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;objectTypeIndexer&quot;</span><span class="s0">,</span><span class="s1">&quot;variance&quot;</span><span class="s0">,</span><span class="s1">&quot;ObjectTypeIndexer&quot;</span><span class="s0">,</span><span class="s1">&quot;objectTypeProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;proto&quot;</span><span class="s0">,</span><span class="s1">&quot;ObjectTypeProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;objectTypeSpreadProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;ObjectTypeSpreadProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;opaqueType&quot;</span><span class="s0">,</span><span class="s1">&quot;impltype&quot;</span><span class="s0">,</span><span class="s1">&quot;OpaqueType&quot;</span><span class="s0">,</span><span class="s1">&quot;qualifiedTypeIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;qualification&quot;</span><span class="s0">,</span><span class="s1">&quot;QualifiedTypeIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;stringLiteralTypeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;StringLiteralTypeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;stringTypeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;symbolTypeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;thisTypeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;tupleTypeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;TupleTypeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;typeofTypeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;TypeofTypeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;typeAlias&quot;</span><span class="s0">,</span><span class="s1">&quot;TypeAlias&quot;</span><span class="s0">,</span><span class="s1">&quot;TypeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;typeCastExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;TypeCastExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;typeParameter&quot;</span><span class="s0">,</span><span class="s1">&quot;bound&quot;</span><span class="s0">,</span><span class="s1">&quot;_default&quot;</span><span class="s0">,</span><span class="s1">&quot;default&quot;</span><span class="s0">,</span><span class="s1">&quot;TypeParameter&quot;</span><span class="s0">,</span><span class="s1">&quot;typeParameterDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;TypeParameterDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;typeParameterInstantiation&quot;</span><span class="s0">,</span><span class="s1">&quot;TypeParameterInstantiation&quot;</span><span class="s0">,</span><span class="s1">&quot;unionTypeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;UnionTypeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;Variance&quot;</span><span class="s0">,</span><span class="s1">&quot;voidTypeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;enumDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;EnumDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;enumBooleanBody&quot;</span><span class="s0">,</span><span class="s1">&quot;members&quot;</span><span class="s0">,</span><span class="s1">&quot;explicitType&quot;</span><span class="s0">,</span><span class="s1">&quot;hasUnknownMembers&quot;</span><span class="s0">,</span><span class="s1">&quot;EnumBooleanBody&quot;</span><span class="s0">,</span><span class="s1">&quot;enumNumberBody&quot;</span><span class="s0">,</span><span class="s1">&quot;EnumNumberBody&quot;</span><span class="s0">,</span><span class="s1">&quot;enumStringBody&quot;</span><span class="s0">,</span><span class="s1">&quot;EnumStringBody&quot;</span><span class="s0">,</span><span class="s1">&quot;enumSymbolBody&quot;</span><span class="s0">,</span><span class="s1">&quot;EnumSymbolBody&quot;</span><span class="s0">,</span><span class="s1">&quot;enumBooleanMember&quot;</span><span class="s0">,</span><span class="s1">&quot;EnumBooleanMember&quot;</span><span class="s0">,</span><span class="s1">&quot;enumNumberMember&quot;</span><span class="s0">,</span><span class="s1">&quot;EnumNumberMember&quot;</span><span class="s0">,</span><span class="s1">&quot;enumStringMember&quot;</span><span class="s0">,</span><span class="s1">&quot;EnumStringMember&quot;</span><span class="s0">,</span><span class="s1">&quot;enumDefaultedMember&quot;</span><span class="s0">,</span><span class="s1">&quot;EnumDefaultedMember&quot;</span><span class="s0">,</span><span class="s1">&quot;indexedAccessType&quot;</span><span class="s0">,</span><span class="s1">&quot;objectType&quot;</span><span class="s0">,</span><span class="s1">&quot;indexType&quot;</span><span class="s0">,</span><span class="s1">&quot;IndexedAccessType&quot;</span><span class="s0">,</span><span class="s1">&quot;optionalIndexedAccessType&quot;</span><span class="s0">,</span><span class="s1">&quot;OptionalIndexedAccessType&quot;</span><span class="s0">,</span><span class="s1">&quot;jsxAttribute&quot;</span><span class="s0">,</span><span class="s1">&quot;JSXAttribute&quot;</span><span class="s0">,</span><span class="s1">&quot;jsxClosingElement&quot;</span><span class="s0">,</span><span class="s1">&quot;JSXClosingElement&quot;</span><span class="s0">,</span><span class="s1">&quot;jsxElement&quot;</span><span class="s0">,</span><span class="s1">&quot;openingElement&quot;</span><span class="s0">,</span><span class="s1">&quot;closingElement&quot;</span><span class="s0">,</span><span class="s1">&quot;children&quot;</span><span class="s0">,</span><span class="s1">&quot;selfClosing&quot;</span><span class="s0">,</span><span class="s1">&quot;JSXElement&quot;</span><span class="s0">,</span><span class="s1">&quot;jsxEmptyExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;jsxExpressionContainer&quot;</span><span class="s0">,</span><span class="s1">&quot;JSXExpressionContainer&quot;</span><span class="s0">,</span><span class="s1">&quot;jsxSpreadChild&quot;</span><span class="s0">,</span><span class="s1">&quot;JSXSpreadChild&quot;</span><span class="s0">,</span><span class="s1">&quot;jsxIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;JSXIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;jsxMemberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;JSXMemberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;jsxNamespacedName&quot;</span><span class="s0">,</span><span class="s1">&quot;namespace&quot;</span><span class="s0">,</span><span class="s1">&quot;JSXNamespacedName&quot;</span><span class="s0">,</span><span class="s1">&quot;jsxOpeningElement&quot;</span><span class="s0">,</span><span class="s1">&quot;JSXOpeningElement&quot;</span><span class="s0">,</span><span class="s1">&quot;jsxSpreadAttribute&quot;</span><span class="s0">,</span><span class="s1">&quot;JSXSpreadAttribute&quot;</span><span class="s0">,</span><span class="s1">&quot;jsxText&quot;</span><span class="s0">,</span><span class="s1">&quot;JSXText&quot;</span><span class="s0">,</span><span class="s1">&quot;jsxFragment&quot;</span><span class="s0">,</span><span class="s1">&quot;openingFragment&quot;</span><span class="s0">,</span><span class="s1">&quot;closingFragment&quot;</span><span class="s0">,</span><span class="s1">&quot;JSXFragment&quot;</span><span class="s0">,</span><span class="s1">&quot;jsxOpeningFragment&quot;</span><span class="s0">,</span><span class="s1">&quot;jsxClosingFragment&quot;</span><span class="s0">,</span><span class="s1">&quot;noop&quot;</span><span class="s0">,</span><span class="s1">&quot;placeholder&quot;</span><span class="s0">,</span><span class="s1">&quot;expectedNode&quot;</span><span class="s0">,</span><span class="s1">&quot;Placeholder&quot;</span><span class="s0">,</span><span class="s1">&quot;v8IntrinsicIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;V8IntrinsicIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;argumentPlaceholder&quot;</span><span class="s0">,</span><span class="s1">&quot;bindExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;BindExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;decorator&quot;</span><span class="s0">,</span><span class="s1">&quot;Decorator&quot;</span><span class="s0">,</span><span class="s1">&quot;doExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;DoExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;exportDefaultSpecifier&quot;</span><span class="s0">,</span><span class="s1">&quot;ExportDefaultSpecifier&quot;</span><span class="s0">,</span><span class="s1">&quot;recordExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;RecordExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;tupleExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;TupleExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;decimalLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;DecimalLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;moduleExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;ModuleExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;topicReference&quot;</span><span class="s0">,</span><span class="s1">&quot;pipelineTopicExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;PipelineTopicExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;pipelineBareFunction&quot;</span><span class="s0">,</span><span class="s1">&quot;PipelineBareFunction&quot;</span><span class="s0">,</span><span class="s1">&quot;pipelinePrimaryTopicReference&quot;</span><span class="s0">,</span><span class="s1">&quot;tsParameterProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;parameter&quot;</span><span class="s0">,</span><span class="s1">&quot;TSParameterProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;tsDeclareFunction&quot;</span><span class="s0">,</span><span class="s1">&quot;TSDeclareFunction&quot;</span><span class="s0">,</span><span class="s1">&quot;tsDeclareMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;TSDeclareMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;tsQualifiedName&quot;</span><span class="s0">,</span><span class="s1">&quot;TSQualifiedName&quot;</span><span class="s0">,</span><span class="s1">&quot;tsCallSignatureDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;parameters&quot;</span><span class="s0">,</span><span class="s1">&quot;TSCallSignatureDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;tsConstructSignatureDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;TSConstructSignatureDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;tsPropertySignature&quot;</span><span class="s0">,</span><span class="s1">&quot;TSPropertySignature&quot;</span><span class="s0">,</span><span class="s1">&quot;tsMethodSignature&quot;</span><span class="s0">,</span><span class="s1">&quot;TSMethodSignature&quot;</span><span class="s0">,</span><span class="s1">&quot;tsIndexSignature&quot;</span><span class="s0">,</span><span class="s1">&quot;TSIndexSignature&quot;</span><span class="s0">,</span><span class="s1">&quot;tsAnyKeyword&quot;</span><span class="s0">,</span><span class="s1">&quot;tsBooleanKeyword&quot;</span><span class="s0">,</span><span class="s1">&quot;tsBigIntKeyword&quot;</span><span class="s0">,</span><span class="s1">&quot;tsIntrinsicKeyword&quot;</span><span class="s0">,</span><span class="s1">&quot;tsNeverKeyword&quot;</span><span class="s0">,</span><span class="s1">&quot;tsNullKeyword&quot;</span><span class="s0">,</span><span class="s1">&quot;tsNumberKeyword&quot;</span><span class="s0">,</span><span class="s1">&quot;tsObjectKeyword&quot;</span><span class="s0">,</span><span class="s1">&quot;tsStringKeyword&quot;</span><span class="s0">,</span><span class="s1">&quot;tsSymbolKeyword&quot;</span><span class="s0">,</span><span class="s1">&quot;tsUndefinedKeyword&quot;</span><span class="s0">,</span><span class="s1">&quot;tsUnknownKeyword&quot;</span><span class="s0">,</span><span class="s1">&quot;tsVoidKeyword&quot;</span><span class="s0">,</span><span class="s1">&quot;tsThisType&quot;</span><span class="s0">,</span><span class="s1">&quot;tsFunctionType&quot;</span><span class="s0">,</span><span class="s1">&quot;TSFunctionType&quot;</span><span class="s0">,</span><span class="s1">&quot;tsConstructorType&quot;</span><span class="s0">,</span><span class="s1">&quot;TSConstructorType&quot;</span><span class="s0">,</span><span class="s1">&quot;tsTypeReference&quot;</span><span class="s0">,</span><span class="s1">&quot;typeName&quot;</span><span class="s0">,</span><span class="s1">&quot;TSTypeReference&quot;</span><span class="s0">,</span><span class="s1">&quot;tsTypePredicate&quot;</span><span class="s0">,</span><span class="s1">&quot;parameterName&quot;</span><span class="s0">,</span><span class="s1">&quot;asserts&quot;</span><span class="s0">,</span><span class="s1">&quot;TSTypePredicate&quot;</span><span class="s0">,</span><span class="s1">&quot;tsTypeQuery&quot;</span><span class="s0">,</span><span class="s1">&quot;exprName&quot;</span><span class="s0">,</span><span class="s1">&quot;TSTypeQuery&quot;</span><span class="s0">,</span><span class="s1">&quot;tsTypeLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;TSTypeLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;tsArrayType&quot;</span><span class="s0">,</span><span class="s1">&quot;TSArrayType&quot;</span><span class="s0">,</span><span class="s1">&quot;tsTupleType&quot;</span><span class="s0">,</span><span class="s1">&quot;elementTypes&quot;</span><span class="s0">,</span><span class="s1">&quot;TSTupleType&quot;</span><span class="s0">,</span><span class="s1">&quot;tsOptionalType&quot;</span><span class="s0">,</span><span class="s1">&quot;TSOptionalType&quot;</span><span class="s0">,</span><span class="s1">&quot;tsRestType&quot;</span><span class="s0">,</span><span class="s1">&quot;TSRestType&quot;</span><span class="s0">,</span><span class="s1">&quot;tsNamedTupleMember&quot;</span><span class="s0">,</span><span class="s1">&quot;TSNamedTupleMember&quot;</span><span class="s0">,</span><span class="s1">&quot;tsUnionType&quot;</span><span class="s0">,</span><span class="s1">&quot;TSUnionType&quot;</span><span class="s0">,</span><span class="s1">&quot;tsIntersectionType&quot;</span><span class="s0">,</span><span class="s1">&quot;TSIntersectionType&quot;</span><span class="s0">,</span><span class="s1">&quot;tsConditionalType&quot;</span><span class="s0">,</span><span class="s1">&quot;checkType&quot;</span><span class="s0">,</span><span class="s1">&quot;extendsType&quot;</span><span class="s0">,</span><span class="s1">&quot;trueType&quot;</span><span class="s0">,</span><span class="s1">&quot;falseType&quot;</span><span class="s0">,</span><span class="s1">&quot;TSConditionalType&quot;</span><span class="s0">,</span><span class="s1">&quot;tsInferType&quot;</span><span class="s0">,</span><span class="s1">&quot;TSInferType&quot;</span><span class="s0">,</span><span class="s1">&quot;tsParenthesizedType&quot;</span><span class="s0">,</span><span class="s1">&quot;TSParenthesizedType&quot;</span><span class="s0">,</span><span class="s1">&quot;tsTypeOperator&quot;</span><span class="s0">,</span><span class="s1">&quot;TSTypeOperator&quot;</span><span class="s0">,</span><span class="s1">&quot;tsIndexedAccessType&quot;</span><span class="s0">,</span><span class="s1">&quot;TSIndexedAccessType&quot;</span><span class="s0">,</span><span class="s1">&quot;tsMappedType&quot;</span><span class="s0">,</span><span class="s1">&quot;nameType&quot;</span><span class="s0">,</span><span class="s1">&quot;TSMappedType&quot;</span><span class="s0">,</span><span class="s1">&quot;tsTemplateLiteralType&quot;</span><span class="s0">,</span><span class="s1">&quot;TSTemplateLiteralType&quot;</span><span class="s0">,</span><span class="s1">&quot;tsLiteralType&quot;</span><span class="s0">,</span><span class="s1">&quot;literal&quot;</span><span class="s0">,</span><span class="s1">&quot;TSLiteralType&quot;</span><span class="s0">,</span><span class="s1">&quot;tsExpressionWithTypeArguments&quot;</span><span class="s0">,</span><span class="s1">&quot;TSExpressionWithTypeArguments&quot;</span><span class="s0">,</span><span class="s1">&quot;tsInterfaceDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;TSInterfaceDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;tsInterfaceBody&quot;</span><span class="s0">,</span><span class="s1">&quot;TSInterfaceBody&quot;</span><span class="s0">,</span><span class="s1">&quot;tsTypeAliasDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;TSTypeAliasDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;tsInstantiationExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;TSInstantiationExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;tsAsExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;TSAsExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;tsSatisfiesExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;TSSatisfiesExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;tsTypeAssertion&quot;</span><span class="s0">,</span><span class="s1">&quot;TSTypeAssertion&quot;</span><span class="s0">,</span><span class="s1">&quot;tsEnumBody&quot;</span><span class="s0">,</span><span class="s1">&quot;TSEnumBody&quot;</span><span class="s0">,</span><span class="s1">&quot;tsEnumDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;TSEnumDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;tsEnumMember&quot;</span><span class="s0">,</span><span class="s1">&quot;initializer&quot;</span><span class="s0">,</span><span class="s1">&quot;TSEnumMember&quot;</span><span class="s0">,</span><span class="s1">&quot;tsModuleDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;TSModuleDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;tsModuleBlock&quot;</span><span class="s0">,</span><span class="s1">&quot;TSModuleBlock&quot;</span><span class="s0">,</span><span class="s1">&quot;tsImportType&quot;</span><span class="s0">,</span><span class="s1">&quot;qualifier&quot;</span><span class="s0">,</span><span class="s1">&quot;TSImportType&quot;</span><span class="s0">,</span><span class="s1">&quot;tsImportEqualsDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;moduleReference&quot;</span><span class="s0">,</span><span class="s1">&quot;isExport&quot;</span><span class="s0">,</span><span class="s1">&quot;TSImportEqualsDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;tsExternalModuleReference&quot;</span><span class="s0">,</span><span class="s1">&quot;TSExternalModuleReference&quot;</span><span class="s0">,</span><span class="s1">&quot;tsNonNullExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;TSNonNullExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;tsExportAssignment&quot;</span><span class="s0">,</span><span class="s1">&quot;TSExportAssignment&quot;</span><span class="s0">,</span><span class="s1">&quot;tsNamespaceExportDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;TSNamespaceExportDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;tsTypeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;TSTypeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;tsTypeParameterInstantiation&quot;</span><span class="s0">,</span><span class="s1">&quot;TSTypeParameterInstantiation&quot;</span><span class="s0">,</span><span class="s1">&quot;tsTypeParameterDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;TSTypeParameterDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;tsTypeParameter&quot;</span><span class="s0">,</span><span class="s1">&quot;constraint&quot;</span><span class="s0">,</span><span class="s1">&quot;TSTypeParameter&quot;</span><span class="s0">,</span><span class="s1">&quot;NumberLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;deprecationWarning&quot;</span><span class="s0">,</span><span class="s1">&quot;RegexLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;RestProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;SpreadProperty&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../src/builders/generated/lowercase.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;/*</span><span class="s3">\n </span><span class="s1">* This file is auto-generated! Do not modify it directly.</span><span class="s3">\n </span><span class="s1">* To re-generate run 'make build'</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">import * as _validate from </span><span class="s3">\&quot;</span><span class="s1">../../validators/validate.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type * as t from </span><span class="s3">\&quot;</span><span class="s1">../../ast-types/generated/index.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import deprecationWarning from </span><span class="s3">\&quot;</span><span class="s1">../../utils/deprecationWarning.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import * as utils from </span><span class="s3">\&quot;</span><span class="s1">../../definitions/utils.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">const { validateInternal: validate } = _validate;</span><span class="s3">\n</span><span class="s1">const { NODE_FIELDS } = utils;</span><span class="s3">\n\n</span><span class="s1">export function arrayExpression(</span><span class="s3">\n  </span><span class="s1">elements: Array&lt;null | t.Expression | t.SpreadElement&gt; = [],</span><span class="s3">\n</span><span class="s1">): t.ArrayExpression {</span><span class="s3">\n  </span><span class="s1">const node: t.ArrayExpression = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">ArrayExpression</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">elements,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.ArrayExpression;</span><span class="s3">\n  </span><span class="s1">validate(defs.elements, node, </span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">, elements, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function assignmentExpression(</span><span class="s3">\n  </span><span class="s1">operator: string,</span><span class="s3">\n  </span><span class="s1">left: t.LVal | t.OptionalMemberExpression,</span><span class="s3">\n  </span><span class="s1">right: t.Expression,</span><span class="s3">\n</span><span class="s1">): t.AssignmentExpression {</span><span class="s3">\n  </span><span class="s1">const node: t.AssignmentExpression = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">AssignmentExpression</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">operator,</span><span class="s3">\n    </span><span class="s1">left,</span><span class="s3">\n    </span><span class="s1">right,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.AssignmentExpression;</span><span class="s3">\n  </span><span class="s1">validate(defs.operator, node, </span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">, operator);</span><span class="s3">\n  </span><span class="s1">validate(defs.left, node, </span><span class="s3">\&quot;</span><span class="s1">left</span><span class="s3">\&quot;</span><span class="s1">, left, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.right, node, </span><span class="s3">\&quot;</span><span class="s1">right</span><span class="s3">\&quot;</span><span class="s1">, right, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function binaryExpression(</span><span class="s3">\n  </span><span class="s1">operator:</span><span class="s3">\n    </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;\n    </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">-</span><span class="s3">\&quot;\n    </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;\n    </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">%</span><span class="s3">\&quot;\n    </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;\n    </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">**</span><span class="s3">\&quot;\n    </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">&amp;</span><span class="s3">\&quot;\n    </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot;\n    </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">&gt;&gt;</span><span class="s3">\&quot;\n    </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">&gt;&gt;&gt;</span><span class="s3">\&quot;\n    </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">&lt;&lt;</span><span class="s3">\&quot;\n    </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">^</span><span class="s3">\&quot;\n    </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">==</span><span class="s3">\&quot;\n    </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">===</span><span class="s3">\&quot;\n    </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">!=</span><span class="s3">\&quot;\n    </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">!==</span><span class="s3">\&quot;\n    </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">in</span><span class="s3">\&quot;\n    </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">instanceof</span><span class="s3">\&quot;\n    </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">&gt;</span><span class="s3">\&quot;\n    </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">&lt;</span><span class="s3">\&quot;\n    </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">&gt;=</span><span class="s3">\&quot;\n    </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">&lt;=</span><span class="s3">\&quot;\n    </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">|&gt;</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">left: t.Expression | t.PrivateName,</span><span class="s3">\n  </span><span class="s1">right: t.Expression,</span><span class="s3">\n</span><span class="s1">): t.BinaryExpression {</span><span class="s3">\n  </span><span class="s1">const node: t.BinaryExpression = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">BinaryExpression</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">operator,</span><span class="s3">\n    </span><span class="s1">left,</span><span class="s3">\n    </span><span class="s1">right,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.BinaryExpression;</span><span class="s3">\n  </span><span class="s1">validate(defs.operator, node, </span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">, operator);</span><span class="s3">\n  </span><span class="s1">validate(defs.left, node, </span><span class="s3">\&quot;</span><span class="s1">left</span><span class="s3">\&quot;</span><span class="s1">, left, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.right, node, </span><span class="s3">\&quot;</span><span class="s1">right</span><span class="s3">\&quot;</span><span class="s1">, right, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function interpreterDirective(value: string): t.InterpreterDirective {</span><span class="s3">\n  </span><span class="s1">const node: t.InterpreterDirective = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">InterpreterDirective</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.InterpreterDirective;</span><span class="s3">\n  </span><span class="s1">validate(defs.value, node, </span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">, value);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function directive(value: t.DirectiveLiteral): t.Directive {</span><span class="s3">\n  </span><span class="s1">const node: t.Directive = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">Directive</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.Directive;</span><span class="s3">\n  </span><span class="s1">validate(defs.value, node, </span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">, value, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function directiveLiteral(value: string): t.DirectiveLiteral {</span><span class="s3">\n  </span><span class="s1">const node: t.DirectiveLiteral = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">DirectiveLiteral</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.DirectiveLiteral;</span><span class="s3">\n  </span><span class="s1">validate(defs.value, node, </span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">, value);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function blockStatement(</span><span class="s3">\n  </span><span class="s1">body: Array&lt;t.Statement&gt;,</span><span class="s3">\n  </span><span class="s1">directives: Array&lt;t.Directive&gt; = [],</span><span class="s3">\n</span><span class="s1">): t.BlockStatement {</span><span class="s3">\n  </span><span class="s1">const node: t.BlockStatement = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">BlockStatement</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">body,</span><span class="s3">\n    </span><span class="s1">directives,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.BlockStatement;</span><span class="s3">\n  </span><span class="s1">validate(defs.body, node, </span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">, body, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.directives, node, </span><span class="s3">\&quot;</span><span class="s1">directives</span><span class="s3">\&quot;</span><span class="s1">, directives, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function breakStatement(</span><span class="s3">\n  </span><span class="s1">label: t.Identifier | null = null,</span><span class="s3">\n</span><span class="s1">): t.BreakStatement {</span><span class="s3">\n  </span><span class="s1">const node: t.BreakStatement = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">BreakStatement</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">label,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.BreakStatement;</span><span class="s3">\n  </span><span class="s1">validate(defs.label, node, </span><span class="s3">\&quot;</span><span class="s1">label</span><span class="s3">\&quot;</span><span class="s1">, label, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function callExpression(</span><span class="s3">\n  </span><span class="s1">callee: t.Expression | t.Super | t.V8IntrinsicIdentifier,</span><span class="s3">\n  </span><span class="s1">_arguments: Array&lt;t.Expression | t.SpreadElement | t.ArgumentPlaceholder&gt;,</span><span class="s3">\n</span><span class="s1">): t.CallExpression {</span><span class="s3">\n  </span><span class="s1">const node: t.CallExpression = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">CallExpression</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">callee,</span><span class="s3">\n    </span><span class="s1">arguments: _arguments,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.CallExpression;</span><span class="s3">\n  </span><span class="s1">validate(defs.callee, node, </span><span class="s3">\&quot;</span><span class="s1">callee</span><span class="s3">\&quot;</span><span class="s1">, callee, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.arguments, node, </span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">, _arguments, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function catchClause(</span><span class="s3">\n  </span><span class="s1">param:</span><span class="s3">\n    </span><span class="s1">| t.Identifier</span><span class="s3">\n    </span><span class="s1">| t.ArrayPattern</span><span class="s3">\n    </span><span class="s1">| t.ObjectPattern</span><span class="s3">\n    </span><span class="s1">| null</span><span class="s3">\n    </span><span class="s1">| undefined = null,</span><span class="s3">\n  </span><span class="s1">body: t.BlockStatement,</span><span class="s3">\n</span><span class="s1">): t.CatchClause {</span><span class="s3">\n  </span><span class="s1">const node: t.CatchClause = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">CatchClause</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">param,</span><span class="s3">\n    </span><span class="s1">body,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.CatchClause;</span><span class="s3">\n  </span><span class="s1">validate(defs.param, node, </span><span class="s3">\&quot;</span><span class="s1">param</span><span class="s3">\&quot;</span><span class="s1">, param, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.body, node, </span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">, body, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function conditionalExpression(</span><span class="s3">\n  </span><span class="s1">test: t.Expression,</span><span class="s3">\n  </span><span class="s1">consequent: t.Expression,</span><span class="s3">\n  </span><span class="s1">alternate: t.Expression,</span><span class="s3">\n</span><span class="s1">): t.ConditionalExpression {</span><span class="s3">\n  </span><span class="s1">const node: t.ConditionalExpression = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">ConditionalExpression</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">test,</span><span class="s3">\n    </span><span class="s1">consequent,</span><span class="s3">\n    </span><span class="s1">alternate,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.ConditionalExpression;</span><span class="s3">\n  </span><span class="s1">validate(defs.test, node, </span><span class="s3">\&quot;</span><span class="s1">test</span><span class="s3">\&quot;</span><span class="s1">, test, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.consequent, node, </span><span class="s3">\&quot;</span><span class="s1">consequent</span><span class="s3">\&quot;</span><span class="s1">, consequent, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.alternate, node, </span><span class="s3">\&quot;</span><span class="s1">alternate</span><span class="s3">\&quot;</span><span class="s1">, alternate, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function continueStatement(</span><span class="s3">\n  </span><span class="s1">label: t.Identifier | null = null,</span><span class="s3">\n</span><span class="s1">): t.ContinueStatement {</span><span class="s3">\n  </span><span class="s1">const node: t.ContinueStatement = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">ContinueStatement</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">label,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.ContinueStatement;</span><span class="s3">\n  </span><span class="s1">validate(defs.label, node, </span><span class="s3">\&quot;</span><span class="s1">label</span><span class="s3">\&quot;</span><span class="s1">, label, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function debuggerStatement(): t.DebuggerStatement {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">DebuggerStatement</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function doWhileStatement(</span><span class="s3">\n  </span><span class="s1">test: t.Expression,</span><span class="s3">\n  </span><span class="s1">body: t.Statement,</span><span class="s3">\n</span><span class="s1">): t.DoWhileStatement {</span><span class="s3">\n  </span><span class="s1">const node: t.DoWhileStatement = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">DoWhileStatement</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">test,</span><span class="s3">\n    </span><span class="s1">body,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.DoWhileStatement;</span><span class="s3">\n  </span><span class="s1">validate(defs.test, node, </span><span class="s3">\&quot;</span><span class="s1">test</span><span class="s3">\&quot;</span><span class="s1">, test, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.body, node, </span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">, body, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function emptyStatement(): t.EmptyStatement {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">EmptyStatement</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function expressionStatement(</span><span class="s3">\n  </span><span class="s1">expression: t.Expression,</span><span class="s3">\n</span><span class="s1">): t.ExpressionStatement {</span><span class="s3">\n  </span><span class="s1">const node: t.ExpressionStatement = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">ExpressionStatement</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">expression,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.ExpressionStatement;</span><span class="s3">\n  </span><span class="s1">validate(defs.expression, node, </span><span class="s3">\&quot;</span><span class="s1">expression</span><span class="s3">\&quot;</span><span class="s1">, expression, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function file(</span><span class="s3">\n  </span><span class="s1">program: t.Program,</span><span class="s3">\n  </span><span class="s1">comments: Array&lt;t.CommentBlock | t.CommentLine&gt; | null = null,</span><span class="s3">\n  </span><span class="s1">tokens: Array&lt;any&gt; | null = null,</span><span class="s3">\n</span><span class="s1">): t.File {</span><span class="s3">\n  </span><span class="s1">const node: t.File = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">File</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">program,</span><span class="s3">\n    </span><span class="s1">comments,</span><span class="s3">\n    </span><span class="s1">tokens,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.File;</span><span class="s3">\n  </span><span class="s1">validate(defs.program, node, </span><span class="s3">\&quot;</span><span class="s1">program</span><span class="s3">\&quot;</span><span class="s1">, program, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.comments, node, </span><span class="s3">\&quot;</span><span class="s1">comments</span><span class="s3">\&quot;</span><span class="s1">, comments, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.tokens, node, </span><span class="s3">\&quot;</span><span class="s1">tokens</span><span class="s3">\&quot;</span><span class="s1">, tokens);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function forInStatement(</span><span class="s3">\n  </span><span class="s1">left: t.VariableDeclaration | t.LVal,</span><span class="s3">\n  </span><span class="s1">right: t.Expression,</span><span class="s3">\n  </span><span class="s1">body: t.Statement,</span><span class="s3">\n</span><span class="s1">): t.ForInStatement {</span><span class="s3">\n  </span><span class="s1">const node: t.ForInStatement = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">ForInStatement</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">left,</span><span class="s3">\n    </span><span class="s1">right,</span><span class="s3">\n    </span><span class="s1">body,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.ForInStatement;</span><span class="s3">\n  </span><span class="s1">validate(defs.left, node, </span><span class="s3">\&quot;</span><span class="s1">left</span><span class="s3">\&quot;</span><span class="s1">, left, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.right, node, </span><span class="s3">\&quot;</span><span class="s1">right</span><span class="s3">\&quot;</span><span class="s1">, right, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.body, node, </span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">, body, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function forStatement(</span><span class="s3">\n  </span><span class="s1">init: t.VariableDeclaration | t.Expression | null | undefined = null,</span><span class="s3">\n  </span><span class="s1">test: t.Expression | null | undefined = null,</span><span class="s3">\n  </span><span class="s1">update: t.Expression | null | undefined = null,</span><span class="s3">\n  </span><span class="s1">body: t.Statement,</span><span class="s3">\n</span><span class="s1">): t.ForStatement {</span><span class="s3">\n  </span><span class="s1">const node: t.ForStatement = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">ForStatement</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">init,</span><span class="s3">\n    </span><span class="s1">test,</span><span class="s3">\n    </span><span class="s1">update,</span><span class="s3">\n    </span><span class="s1">body,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.ForStatement;</span><span class="s3">\n  </span><span class="s1">validate(defs.init, node, </span><span class="s3">\&quot;</span><span class="s1">init</span><span class="s3">\&quot;</span><span class="s1">, init, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.test, node, </span><span class="s3">\&quot;</span><span class="s1">test</span><span class="s3">\&quot;</span><span class="s1">, test, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.update, node, </span><span class="s3">\&quot;</span><span class="s1">update</span><span class="s3">\&quot;</span><span class="s1">, update, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.body, node, </span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">, body, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function functionDeclaration(</span><span class="s3">\n  </span><span class="s1">id: t.Identifier | null | undefined = null,</span><span class="s3">\n  </span><span class="s1">params: Array&lt;t.Identifier | t.Pattern | t.RestElement&gt;,</span><span class="s3">\n  </span><span class="s1">body: t.BlockStatement,</span><span class="s3">\n  </span><span class="s1">generator: boolean = false,</span><span class="s3">\n  </span><span class="s1">async: boolean = false,</span><span class="s3">\n</span><span class="s1">): t.FunctionDeclaration {</span><span class="s3">\n  </span><span class="s1">const node: t.FunctionDeclaration = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">FunctionDeclaration</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">id,</span><span class="s3">\n    </span><span class="s1">params,</span><span class="s3">\n    </span><span class="s1">body,</span><span class="s3">\n    </span><span class="s1">generator,</span><span class="s3">\n    </span><span class="s1">async,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.FunctionDeclaration;</span><span class="s3">\n  </span><span class="s1">validate(defs.id, node, </span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">, id, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.params, node, </span><span class="s3">\&quot;</span><span class="s1">params</span><span class="s3">\&quot;</span><span class="s1">, params, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.body, node, </span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">, body, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.generator, node, </span><span class="s3">\&quot;</span><span class="s1">generator</span><span class="s3">\&quot;</span><span class="s1">, generator);</span><span class="s3">\n  </span><span class="s1">validate(defs.async, node, </span><span class="s3">\&quot;</span><span class="s1">async</span><span class="s3">\&quot;</span><span class="s1">, async);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function functionExpression(</span><span class="s3">\n  </span><span class="s1">id: t.Identifier | null | undefined = null,</span><span class="s3">\n  </span><span class="s1">params: Array&lt;t.Identifier | t.Pattern | t.RestElement&gt;,</span><span class="s3">\n  </span><span class="s1">body: t.BlockStatement,</span><span class="s3">\n  </span><span class="s1">generator: boolean = false,</span><span class="s3">\n  </span><span class="s1">async: boolean = false,</span><span class="s3">\n</span><span class="s1">): t.FunctionExpression {</span><span class="s3">\n  </span><span class="s1">const node: t.FunctionExpression = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">FunctionExpression</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">id,</span><span class="s3">\n    </span><span class="s1">params,</span><span class="s3">\n    </span><span class="s1">body,</span><span class="s3">\n    </span><span class="s1">generator,</span><span class="s3">\n    </span><span class="s1">async,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.FunctionExpression;</span><span class="s3">\n  </span><span class="s1">validate(defs.id, node, </span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">, id, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.params, node, </span><span class="s3">\&quot;</span><span class="s1">params</span><span class="s3">\&quot;</span><span class="s1">, params, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.body, node, </span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">, body, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.generator, node, </span><span class="s3">\&quot;</span><span class="s1">generator</span><span class="s3">\&quot;</span><span class="s1">, generator);</span><span class="s3">\n  </span><span class="s1">validate(defs.async, node, </span><span class="s3">\&quot;</span><span class="s1">async</span><span class="s3">\&quot;</span><span class="s1">, async);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function identifier(name: string): t.Identifier {</span><span class="s3">\n  </span><span class="s1">const node: t.Identifier = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">Identifier</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">name,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.Identifier;</span><span class="s3">\n  </span><span class="s1">validate(defs.name, node, </span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">, name);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function ifStatement(</span><span class="s3">\n  </span><span class="s1">test: t.Expression,</span><span class="s3">\n  </span><span class="s1">consequent: t.Statement,</span><span class="s3">\n  </span><span class="s1">alternate: t.Statement | null = null,</span><span class="s3">\n</span><span class="s1">): t.IfStatement {</span><span class="s3">\n  </span><span class="s1">const node: t.IfStatement = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">IfStatement</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">test,</span><span class="s3">\n    </span><span class="s1">consequent,</span><span class="s3">\n    </span><span class="s1">alternate,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.IfStatement;</span><span class="s3">\n  </span><span class="s1">validate(defs.test, node, </span><span class="s3">\&quot;</span><span class="s1">test</span><span class="s3">\&quot;</span><span class="s1">, test, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.consequent, node, </span><span class="s3">\&quot;</span><span class="s1">consequent</span><span class="s3">\&quot;</span><span class="s1">, consequent, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.alternate, node, </span><span class="s3">\&quot;</span><span class="s1">alternate</span><span class="s3">\&quot;</span><span class="s1">, alternate, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function labeledStatement(</span><span class="s3">\n  </span><span class="s1">label: t.Identifier,</span><span class="s3">\n  </span><span class="s1">body: t.Statement,</span><span class="s3">\n</span><span class="s1">): t.LabeledStatement {</span><span class="s3">\n  </span><span class="s1">const node: t.LabeledStatement = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">LabeledStatement</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">label,</span><span class="s3">\n    </span><span class="s1">body,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.LabeledStatement;</span><span class="s3">\n  </span><span class="s1">validate(defs.label, node, </span><span class="s3">\&quot;</span><span class="s1">label</span><span class="s3">\&quot;</span><span class="s1">, label, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.body, node, </span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">, body, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function stringLiteral(value: string): t.StringLiteral {</span><span class="s3">\n  </span><span class="s1">const node: t.StringLiteral = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">StringLiteral</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.StringLiteral;</span><span class="s3">\n  </span><span class="s1">validate(defs.value, node, </span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">, value);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function numericLiteral(value: number): t.NumericLiteral {</span><span class="s3">\n  </span><span class="s1">const node: t.NumericLiteral = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">NumericLiteral</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.NumericLiteral;</span><span class="s3">\n  </span><span class="s1">validate(defs.value, node, </span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">, value);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function nullLiteral(): t.NullLiteral {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">NullLiteral</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function booleanLiteral(value: boolean): t.BooleanLiteral {</span><span class="s3">\n  </span><span class="s1">const node: t.BooleanLiteral = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">BooleanLiteral</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.BooleanLiteral;</span><span class="s3">\n  </span><span class="s1">validate(defs.value, node, </span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">, value);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function regExpLiteral(</span><span class="s3">\n  </span><span class="s1">pattern: string,</span><span class="s3">\n  </span><span class="s1">flags: string = </span><span class="s3">\&quot;\&quot;</span><span class="s1">,</span><span class="s3">\n</span><span class="s1">): t.RegExpLiteral {</span><span class="s3">\n  </span><span class="s1">const node: t.RegExpLiteral = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">RegExpLiteral</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">pattern,</span><span class="s3">\n    </span><span class="s1">flags,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.RegExpLiteral;</span><span class="s3">\n  </span><span class="s1">validate(defs.pattern, node, </span><span class="s3">\&quot;</span><span class="s1">pattern</span><span class="s3">\&quot;</span><span class="s1">, pattern);</span><span class="s3">\n  </span><span class="s1">validate(defs.flags, node, </span><span class="s3">\&quot;</span><span class="s1">flags</span><span class="s3">\&quot;</span><span class="s1">, flags);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function logicalExpression(</span><span class="s3">\n  </span><span class="s1">operator: </span><span class="s3">\&quot;</span><span class="s1">||</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">&amp;&amp;</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">??</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">left: t.Expression,</span><span class="s3">\n  </span><span class="s1">right: t.Expression,</span><span class="s3">\n</span><span class="s1">): t.LogicalExpression {</span><span class="s3">\n  </span><span class="s1">const node: t.LogicalExpression = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">LogicalExpression</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">operator,</span><span class="s3">\n    </span><span class="s1">left,</span><span class="s3">\n    </span><span class="s1">right,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.LogicalExpression;</span><span class="s3">\n  </span><span class="s1">validate(defs.operator, node, </span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">, operator);</span><span class="s3">\n  </span><span class="s1">validate(defs.left, node, </span><span class="s3">\&quot;</span><span class="s1">left</span><span class="s3">\&quot;</span><span class="s1">, left, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.right, node, </span><span class="s3">\&quot;</span><span class="s1">right</span><span class="s3">\&quot;</span><span class="s1">, right, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function memberExpression(</span><span class="s3">\n  </span><span class="s1">object: t.Expression | t.Super,</span><span class="s3">\n  </span><span class="s1">property: t.Expression | t.Identifier | t.PrivateName,</span><span class="s3">\n  </span><span class="s1">computed: boolean = false,</span><span class="s3">\n  </span><span class="s1">optional: boolean | null = null,</span><span class="s3">\n</span><span class="s1">): t.MemberExpression {</span><span class="s3">\n  </span><span class="s1">const node: t.MemberExpression = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">MemberExpression</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">object,</span><span class="s3">\n    </span><span class="s1">property,</span><span class="s3">\n    </span><span class="s1">computed,</span><span class="s3">\n    </span><span class="s1">optional,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.MemberExpression;</span><span class="s3">\n  </span><span class="s1">validate(defs.object, node, </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">, object, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.property, node, </span><span class="s3">\&quot;</span><span class="s1">property</span><span class="s3">\&quot;</span><span class="s1">, property, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.computed, node, </span><span class="s3">\&quot;</span><span class="s1">computed</span><span class="s3">\&quot;</span><span class="s1">, computed);</span><span class="s3">\n  </span><span class="s1">validate(defs.optional, node, </span><span class="s3">\&quot;</span><span class="s1">optional</span><span class="s3">\&quot;</span><span class="s1">, optional);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function newExpression(</span><span class="s3">\n  </span><span class="s1">callee: t.Expression | t.Super | t.V8IntrinsicIdentifier,</span><span class="s3">\n  </span><span class="s1">_arguments: Array&lt;t.Expression | t.SpreadElement | t.ArgumentPlaceholder&gt;,</span><span class="s3">\n</span><span class="s1">): t.NewExpression {</span><span class="s3">\n  </span><span class="s1">const node: t.NewExpression = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">NewExpression</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">callee,</span><span class="s3">\n    </span><span class="s1">arguments: _arguments,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.NewExpression;</span><span class="s3">\n  </span><span class="s1">validate(defs.callee, node, </span><span class="s3">\&quot;</span><span class="s1">callee</span><span class="s3">\&quot;</span><span class="s1">, callee, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.arguments, node, </span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">, _arguments, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function program(</span><span class="s3">\n  </span><span class="s1">body: Array&lt;t.Statement&gt;,</span><span class="s3">\n  </span><span class="s1">directives: Array&lt;t.Directive&gt; = [],</span><span class="s3">\n  </span><span class="s1">sourceType: </span><span class="s3">\&quot;</span><span class="s1">script</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">module</span><span class="s3">\&quot; </span><span class="s1">= </span><span class="s3">\&quot;</span><span class="s1">script</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">interpreter: t.InterpreterDirective | null = null,</span><span class="s3">\n</span><span class="s1">): t.Program {</span><span class="s3">\n  </span><span class="s1">const node: t.Program = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">Program</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">body,</span><span class="s3">\n    </span><span class="s1">directives,</span><span class="s3">\n    </span><span class="s1">sourceType,</span><span class="s3">\n    </span><span class="s1">interpreter,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.Program;</span><span class="s3">\n  </span><span class="s1">validate(defs.body, node, </span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">, body, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.directives, node, </span><span class="s3">\&quot;</span><span class="s1">directives</span><span class="s3">\&quot;</span><span class="s1">, directives, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.sourceType, node, </span><span class="s3">\&quot;</span><span class="s1">sourceType</span><span class="s3">\&quot;</span><span class="s1">, sourceType);</span><span class="s3">\n  </span><span class="s1">validate(defs.interpreter, node, </span><span class="s3">\&quot;</span><span class="s1">interpreter</span><span class="s3">\&quot;</span><span class="s1">, interpreter, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function objectExpression(</span><span class="s3">\n  </span><span class="s1">properties: Array&lt;t.ObjectMethod | t.ObjectProperty | t.SpreadElement&gt;,</span><span class="s3">\n</span><span class="s1">): t.ObjectExpression {</span><span class="s3">\n  </span><span class="s1">const node: t.ObjectExpression = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">ObjectExpression</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">properties,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.ObjectExpression;</span><span class="s3">\n  </span><span class="s1">validate(defs.properties, node, </span><span class="s3">\&quot;</span><span class="s1">properties</span><span class="s3">\&quot;</span><span class="s1">, properties, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function objectMethod(</span><span class="s3">\n  </span><span class="s1">kind: </span><span class="s3">\&quot;</span><span class="s1">method</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">get</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">set</span><span class="s3">\&quot; </span><span class="s1">| undefined = </span><span class="s3">\&quot;</span><span class="s1">method</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">key:</span><span class="s3">\n    </span><span class="s1">| t.Expression</span><span class="s3">\n    </span><span class="s1">| t.Identifier</span><span class="s3">\n    </span><span class="s1">| t.StringLiteral</span><span class="s3">\n    </span><span class="s1">| t.NumericLiteral</span><span class="s3">\n    </span><span class="s1">| t.BigIntLiteral,</span><span class="s3">\n  </span><span class="s1">params: Array&lt;t.Identifier | t.Pattern | t.RestElement&gt;,</span><span class="s3">\n  </span><span class="s1">body: t.BlockStatement,</span><span class="s3">\n  </span><span class="s1">computed: boolean = false,</span><span class="s3">\n  </span><span class="s1">generator: boolean = false,</span><span class="s3">\n  </span><span class="s1">async: boolean = false,</span><span class="s3">\n</span><span class="s1">): t.ObjectMethod {</span><span class="s3">\n  </span><span class="s1">const node: t.ObjectMethod = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">ObjectMethod</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">kind,</span><span class="s3">\n    </span><span class="s1">key,</span><span class="s3">\n    </span><span class="s1">params,</span><span class="s3">\n    </span><span class="s1">body,</span><span class="s3">\n    </span><span class="s1">computed,</span><span class="s3">\n    </span><span class="s1">generator,</span><span class="s3">\n    </span><span class="s1">async,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.ObjectMethod;</span><span class="s3">\n  </span><span class="s1">validate(defs.kind, node, </span><span class="s3">\&quot;</span><span class="s1">kind</span><span class="s3">\&quot;</span><span class="s1">, kind);</span><span class="s3">\n  </span><span class="s1">validate(defs.key, node, </span><span class="s3">\&quot;</span><span class="s1">key</span><span class="s3">\&quot;</span><span class="s1">, key, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.params, node, </span><span class="s3">\&quot;</span><span class="s1">params</span><span class="s3">\&quot;</span><span class="s1">, params, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.body, node, </span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">, body, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.computed, node, </span><span class="s3">\&quot;</span><span class="s1">computed</span><span class="s3">\&quot;</span><span class="s1">, computed);</span><span class="s3">\n  </span><span class="s1">validate(defs.generator, node, </span><span class="s3">\&quot;</span><span class="s1">generator</span><span class="s3">\&quot;</span><span class="s1">, generator);</span><span class="s3">\n  </span><span class="s1">validate(defs.async, node, </span><span class="s3">\&quot;</span><span class="s1">async</span><span class="s3">\&quot;</span><span class="s1">, async);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function objectProperty(</span><span class="s3">\n  </span><span class="s1">key:</span><span class="s3">\n    </span><span class="s1">| t.Expression</span><span class="s3">\n    </span><span class="s1">| t.Identifier</span><span class="s3">\n    </span><span class="s1">| t.StringLiteral</span><span class="s3">\n    </span><span class="s1">| t.NumericLiteral</span><span class="s3">\n    </span><span class="s1">| t.BigIntLiteral</span><span class="s3">\n    </span><span class="s1">| t.DecimalLiteral</span><span class="s3">\n    </span><span class="s1">| t.PrivateName,</span><span class="s3">\n  </span><span class="s1">value: t.Expression | t.PatternLike,</span><span class="s3">\n  </span><span class="s1">computed: boolean = false,</span><span class="s3">\n  </span><span class="s1">shorthand: boolean = false,</span><span class="s3">\n  </span><span class="s1">decorators: Array&lt;t.Decorator&gt; | null = null,</span><span class="s3">\n</span><span class="s1">): t.ObjectProperty {</span><span class="s3">\n  </span><span class="s1">const node: t.ObjectProperty = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">ObjectProperty</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">key,</span><span class="s3">\n    </span><span class="s1">value,</span><span class="s3">\n    </span><span class="s1">computed,</span><span class="s3">\n    </span><span class="s1">shorthand,</span><span class="s3">\n    </span><span class="s1">decorators,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.ObjectProperty;</span><span class="s3">\n  </span><span class="s1">validate(defs.key, node, </span><span class="s3">\&quot;</span><span class="s1">key</span><span class="s3">\&quot;</span><span class="s1">, key, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.value, node, </span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">, value, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.computed, node, </span><span class="s3">\&quot;</span><span class="s1">computed</span><span class="s3">\&quot;</span><span class="s1">, computed);</span><span class="s3">\n  </span><span class="s1">validate(defs.shorthand, node, </span><span class="s3">\&quot;</span><span class="s1">shorthand</span><span class="s3">\&quot;</span><span class="s1">, shorthand);</span><span class="s3">\n  </span><span class="s1">validate(defs.decorators, node, </span><span class="s3">\&quot;</span><span class="s1">decorators</span><span class="s3">\&quot;</span><span class="s1">, decorators, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function restElement(argument: t.LVal): t.RestElement {</span><span class="s3">\n  </span><span class="s1">const node: t.RestElement = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">RestElement</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">argument,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.RestElement;</span><span class="s3">\n  </span><span class="s1">validate(defs.argument, node, </span><span class="s3">\&quot;</span><span class="s1">argument</span><span class="s3">\&quot;</span><span class="s1">, argument, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function returnStatement(</span><span class="s3">\n  </span><span class="s1">argument: t.Expression | null = null,</span><span class="s3">\n</span><span class="s1">): t.ReturnStatement {</span><span class="s3">\n  </span><span class="s1">const node: t.ReturnStatement = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">ReturnStatement</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">argument,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.ReturnStatement;</span><span class="s3">\n  </span><span class="s1">validate(defs.argument, node, </span><span class="s3">\&quot;</span><span class="s1">argument</span><span class="s3">\&quot;</span><span class="s1">, argument, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function sequenceExpression(</span><span class="s3">\n  </span><span class="s1">expressions: Array&lt;t.Expression&gt;,</span><span class="s3">\n</span><span class="s1">): t.SequenceExpression {</span><span class="s3">\n  </span><span class="s1">const node: t.SequenceExpression = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">SequenceExpression</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">expressions,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.SequenceExpression;</span><span class="s3">\n  </span><span class="s1">validate(defs.expressions, node, </span><span class="s3">\&quot;</span><span class="s1">expressions</span><span class="s3">\&quot;</span><span class="s1">, expressions, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function parenthesizedExpression(</span><span class="s3">\n  </span><span class="s1">expression: t.Expression,</span><span class="s3">\n</span><span class="s1">): t.ParenthesizedExpression {</span><span class="s3">\n  </span><span class="s1">const node: t.ParenthesizedExpression = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">ParenthesizedExpression</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">expression,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.ParenthesizedExpression;</span><span class="s3">\n  </span><span class="s1">validate(defs.expression, node, </span><span class="s3">\&quot;</span><span class="s1">expression</span><span class="s3">\&quot;</span><span class="s1">, expression, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function switchCase(</span><span class="s3">\n  </span><span class="s1">test: t.Expression | null | undefined = null,</span><span class="s3">\n  </span><span class="s1">consequent: Array&lt;t.Statement&gt;,</span><span class="s3">\n</span><span class="s1">): t.SwitchCase {</span><span class="s3">\n  </span><span class="s1">const node: t.SwitchCase = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">SwitchCase</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">test,</span><span class="s3">\n    </span><span class="s1">consequent,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.SwitchCase;</span><span class="s3">\n  </span><span class="s1">validate(defs.test, node, </span><span class="s3">\&quot;</span><span class="s1">test</span><span class="s3">\&quot;</span><span class="s1">, test, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.consequent, node, </span><span class="s3">\&quot;</span><span class="s1">consequent</span><span class="s3">\&quot;</span><span class="s1">, consequent, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function switchStatement(</span><span class="s3">\n  </span><span class="s1">discriminant: t.Expression,</span><span class="s3">\n  </span><span class="s1">cases: Array&lt;t.SwitchCase&gt;,</span><span class="s3">\n</span><span class="s1">): t.SwitchStatement {</span><span class="s3">\n  </span><span class="s1">const node: t.SwitchStatement = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">SwitchStatement</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">discriminant,</span><span class="s3">\n    </span><span class="s1">cases,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.SwitchStatement;</span><span class="s3">\n  </span><span class="s1">validate(defs.discriminant, node, </span><span class="s3">\&quot;</span><span class="s1">discriminant</span><span class="s3">\&quot;</span><span class="s1">, discriminant, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.cases, node, </span><span class="s3">\&quot;</span><span class="s1">cases</span><span class="s3">\&quot;</span><span class="s1">, cases, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function thisExpression(): t.ThisExpression {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">ThisExpression</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function throwStatement(argument: t.Expression): t.ThrowStatement {</span><span class="s3">\n  </span><span class="s1">const node: t.ThrowStatement = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">ThrowStatement</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">argument,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.ThrowStatement;</span><span class="s3">\n  </span><span class="s1">validate(defs.argument, node, </span><span class="s3">\&quot;</span><span class="s1">argument</span><span class="s3">\&quot;</span><span class="s1">, argument, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function tryStatement(</span><span class="s3">\n  </span><span class="s1">block: t.BlockStatement,</span><span class="s3">\n  </span><span class="s1">handler: t.CatchClause | null = null,</span><span class="s3">\n  </span><span class="s1">finalizer: t.BlockStatement | null = null,</span><span class="s3">\n</span><span class="s1">): t.TryStatement {</span><span class="s3">\n  </span><span class="s1">const node: t.TryStatement = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TryStatement</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">block,</span><span class="s3">\n    </span><span class="s1">handler,</span><span class="s3">\n    </span><span class="s1">finalizer,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.TryStatement;</span><span class="s3">\n  </span><span class="s1">validate(defs.block, node, </span><span class="s3">\&quot;</span><span class="s1">block</span><span class="s3">\&quot;</span><span class="s1">, block, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.handler, node, </span><span class="s3">\&quot;</span><span class="s1">handler</span><span class="s3">\&quot;</span><span class="s1">, handler, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.finalizer, node, </span><span class="s3">\&quot;</span><span class="s1">finalizer</span><span class="s3">\&quot;</span><span class="s1">, finalizer, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function unaryExpression(</span><span class="s3">\n  </span><span class="s1">operator: </span><span class="s3">\&quot;</span><span class="s1">void</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">throw</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">delete</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">!</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">-</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">~</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">typeof</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">argument: t.Expression,</span><span class="s3">\n  </span><span class="s1">prefix: boolean = true,</span><span class="s3">\n</span><span class="s1">): t.UnaryExpression {</span><span class="s3">\n  </span><span class="s1">const node: t.UnaryExpression = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">UnaryExpression</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">operator,</span><span class="s3">\n    </span><span class="s1">argument,</span><span class="s3">\n    </span><span class="s1">prefix,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.UnaryExpression;</span><span class="s3">\n  </span><span class="s1">validate(defs.operator, node, </span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">, operator);</span><span class="s3">\n  </span><span class="s1">validate(defs.argument, node, </span><span class="s3">\&quot;</span><span class="s1">argument</span><span class="s3">\&quot;</span><span class="s1">, argument, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.prefix, node, </span><span class="s3">\&quot;</span><span class="s1">prefix</span><span class="s3">\&quot;</span><span class="s1">, prefix);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function updateExpression(</span><span class="s3">\n  </span><span class="s1">operator: </span><span class="s3">\&quot;</span><span class="s1">++</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">--</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">argument: t.Expression,</span><span class="s3">\n  </span><span class="s1">prefix: boolean = false,</span><span class="s3">\n</span><span class="s1">): t.UpdateExpression {</span><span class="s3">\n  </span><span class="s1">const node: t.UpdateExpression = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">UpdateExpression</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">operator,</span><span class="s3">\n    </span><span class="s1">argument,</span><span class="s3">\n    </span><span class="s1">prefix,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.UpdateExpression;</span><span class="s3">\n  </span><span class="s1">validate(defs.operator, node, </span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">, operator);</span><span class="s3">\n  </span><span class="s1">validate(defs.argument, node, </span><span class="s3">\&quot;</span><span class="s1">argument</span><span class="s3">\&quot;</span><span class="s1">, argument, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.prefix, node, </span><span class="s3">\&quot;</span><span class="s1">prefix</span><span class="s3">\&quot;</span><span class="s1">, prefix);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function variableDeclaration(</span><span class="s3">\n  </span><span class="s1">kind: </span><span class="s3">\&quot;</span><span class="s1">var</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">let</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">const</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">using</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">await using</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">declarations: Array&lt;t.VariableDeclarator&gt;,</span><span class="s3">\n</span><span class="s1">): t.VariableDeclaration {</span><span class="s3">\n  </span><span class="s1">const node: t.VariableDeclaration = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">VariableDeclaration</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">kind,</span><span class="s3">\n    </span><span class="s1">declarations,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.VariableDeclaration;</span><span class="s3">\n  </span><span class="s1">validate(defs.kind, node, </span><span class="s3">\&quot;</span><span class="s1">kind</span><span class="s3">\&quot;</span><span class="s1">, kind);</span><span class="s3">\n  </span><span class="s1">validate(defs.declarations, node, </span><span class="s3">\&quot;</span><span class="s1">declarations</span><span class="s3">\&quot;</span><span class="s1">, declarations, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function variableDeclarator(</span><span class="s3">\n  </span><span class="s1">id: t.LVal,</span><span class="s3">\n  </span><span class="s1">init: t.Expression | null = null,</span><span class="s3">\n</span><span class="s1">): t.VariableDeclarator {</span><span class="s3">\n  </span><span class="s1">const node: t.VariableDeclarator = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">VariableDeclarator</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">id,</span><span class="s3">\n    </span><span class="s1">init,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.VariableDeclarator;</span><span class="s3">\n  </span><span class="s1">validate(defs.id, node, </span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">, id, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.init, node, </span><span class="s3">\&quot;</span><span class="s1">init</span><span class="s3">\&quot;</span><span class="s1">, init, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function whileStatement(</span><span class="s3">\n  </span><span class="s1">test: t.Expression,</span><span class="s3">\n  </span><span class="s1">body: t.Statement,</span><span class="s3">\n</span><span class="s1">): t.WhileStatement {</span><span class="s3">\n  </span><span class="s1">const node: t.WhileStatement = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">WhileStatement</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">test,</span><span class="s3">\n    </span><span class="s1">body,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.WhileStatement;</span><span class="s3">\n  </span><span class="s1">validate(defs.test, node, </span><span class="s3">\&quot;</span><span class="s1">test</span><span class="s3">\&quot;</span><span class="s1">, test, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.body, node, </span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">, body, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function withStatement(</span><span class="s3">\n  </span><span class="s1">object: t.Expression,</span><span class="s3">\n  </span><span class="s1">body: t.Statement,</span><span class="s3">\n</span><span class="s1">): t.WithStatement {</span><span class="s3">\n  </span><span class="s1">const node: t.WithStatement = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">WithStatement</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">object,</span><span class="s3">\n    </span><span class="s1">body,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.WithStatement;</span><span class="s3">\n  </span><span class="s1">validate(defs.object, node, </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">, object, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.body, node, </span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">, body, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function assignmentPattern(</span><span class="s3">\n  </span><span class="s1">left:</span><span class="s3">\n    </span><span class="s1">| t.Identifier</span><span class="s3">\n    </span><span class="s1">| t.ObjectPattern</span><span class="s3">\n    </span><span class="s1">| t.ArrayPattern</span><span class="s3">\n    </span><span class="s1">| t.MemberExpression</span><span class="s3">\n    </span><span class="s1">| t.TSAsExpression</span><span class="s3">\n    </span><span class="s1">| t.TSSatisfiesExpression</span><span class="s3">\n    </span><span class="s1">| t.TSTypeAssertion</span><span class="s3">\n    </span><span class="s1">| t.TSNonNullExpression,</span><span class="s3">\n  </span><span class="s1">right: t.Expression,</span><span class="s3">\n</span><span class="s1">): t.AssignmentPattern {</span><span class="s3">\n  </span><span class="s1">const node: t.AssignmentPattern = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">AssignmentPattern</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">left,</span><span class="s3">\n    </span><span class="s1">right,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.AssignmentPattern;</span><span class="s3">\n  </span><span class="s1">validate(defs.left, node, </span><span class="s3">\&quot;</span><span class="s1">left</span><span class="s3">\&quot;</span><span class="s1">, left, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.right, node, </span><span class="s3">\&quot;</span><span class="s1">right</span><span class="s3">\&quot;</span><span class="s1">, right, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function arrayPattern(</span><span class="s3">\n  </span><span class="s1">elements: Array&lt;null | t.PatternLike | t.LVal&gt;,</span><span class="s3">\n</span><span class="s1">): t.ArrayPattern {</span><span class="s3">\n  </span><span class="s1">const node: t.ArrayPattern = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">ArrayPattern</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">elements,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.ArrayPattern;</span><span class="s3">\n  </span><span class="s1">validate(defs.elements, node, </span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">, elements, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function arrowFunctionExpression(</span><span class="s3">\n  </span><span class="s1">params: Array&lt;t.Identifier | t.Pattern | t.RestElement&gt;,</span><span class="s3">\n  </span><span class="s1">body: t.BlockStatement | t.Expression,</span><span class="s3">\n  </span><span class="s1">async: boolean = false,</span><span class="s3">\n</span><span class="s1">): t.ArrowFunctionExpression {</span><span class="s3">\n  </span><span class="s1">const node: t.ArrowFunctionExpression = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">ArrowFunctionExpression</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">params,</span><span class="s3">\n    </span><span class="s1">body,</span><span class="s3">\n    </span><span class="s1">async,</span><span class="s3">\n    </span><span class="s1">expression: null,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.ArrowFunctionExpression;</span><span class="s3">\n  </span><span class="s1">validate(defs.params, node, </span><span class="s3">\&quot;</span><span class="s1">params</span><span class="s3">\&quot;</span><span class="s1">, params, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.body, node, </span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">, body, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.async, node, </span><span class="s3">\&quot;</span><span class="s1">async</span><span class="s3">\&quot;</span><span class="s1">, async);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function classBody(</span><span class="s3">\n  </span><span class="s1">body: Array&lt;</span><span class="s3">\n    </span><span class="s1">| t.ClassMethod</span><span class="s3">\n    </span><span class="s1">| t.ClassPrivateMethod</span><span class="s3">\n    </span><span class="s1">| t.ClassProperty</span><span class="s3">\n    </span><span class="s1">| t.ClassPrivateProperty</span><span class="s3">\n    </span><span class="s1">| t.ClassAccessorProperty</span><span class="s3">\n    </span><span class="s1">| t.TSDeclareMethod</span><span class="s3">\n    </span><span class="s1">| t.TSIndexSignature</span><span class="s3">\n    </span><span class="s1">| t.StaticBlock</span><span class="s3">\n  </span><span class="s1">&gt;,</span><span class="s3">\n</span><span class="s1">): t.ClassBody {</span><span class="s3">\n  </span><span class="s1">const node: t.ClassBody = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">ClassBody</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">body,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.ClassBody;</span><span class="s3">\n  </span><span class="s1">validate(defs.body, node, </span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">, body, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function classExpression(</span><span class="s3">\n  </span><span class="s1">id: t.Identifier | null | undefined = null,</span><span class="s3">\n  </span><span class="s1">superClass: t.Expression | null | undefined = null,</span><span class="s3">\n  </span><span class="s1">body: t.ClassBody,</span><span class="s3">\n  </span><span class="s1">decorators: Array&lt;t.Decorator&gt; | null = null,</span><span class="s3">\n</span><span class="s1">): t.ClassExpression {</span><span class="s3">\n  </span><span class="s1">const node: t.ClassExpression = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">ClassExpression</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">id,</span><span class="s3">\n    </span><span class="s1">superClass,</span><span class="s3">\n    </span><span class="s1">body,</span><span class="s3">\n    </span><span class="s1">decorators,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.ClassExpression;</span><span class="s3">\n  </span><span class="s1">validate(defs.id, node, </span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">, id, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.superClass, node, </span><span class="s3">\&quot;</span><span class="s1">superClass</span><span class="s3">\&quot;</span><span class="s1">, superClass, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.body, node, </span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">, body, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.decorators, node, </span><span class="s3">\&quot;</span><span class="s1">decorators</span><span class="s3">\&quot;</span><span class="s1">, decorators, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function classDeclaration(</span><span class="s3">\n  </span><span class="s1">id: t.Identifier | null | undefined = null,</span><span class="s3">\n  </span><span class="s1">superClass: t.Expression | null | undefined = null,</span><span class="s3">\n  </span><span class="s1">body: t.ClassBody,</span><span class="s3">\n  </span><span class="s1">decorators: Array&lt;t.Decorator&gt; | null = null,</span><span class="s3">\n</span><span class="s1">): t.ClassDeclaration {</span><span class="s3">\n  </span><span class="s1">const node: t.ClassDeclaration = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">ClassDeclaration</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">id,</span><span class="s3">\n    </span><span class="s1">superClass,</span><span class="s3">\n    </span><span class="s1">body,</span><span class="s3">\n    </span><span class="s1">decorators,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.ClassDeclaration;</span><span class="s3">\n  </span><span class="s1">validate(defs.id, node, </span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">, id, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.superClass, node, </span><span class="s3">\&quot;</span><span class="s1">superClass</span><span class="s3">\&quot;</span><span class="s1">, superClass, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.body, node, </span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">, body, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.decorators, node, </span><span class="s3">\&quot;</span><span class="s1">decorators</span><span class="s3">\&quot;</span><span class="s1">, decorators, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function exportAllDeclaration(</span><span class="s3">\n  </span><span class="s1">source: t.StringLiteral,</span><span class="s3">\n</span><span class="s1">): t.ExportAllDeclaration {</span><span class="s3">\n  </span><span class="s1">const node: t.ExportAllDeclaration = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">ExportAllDeclaration</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">source,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.ExportAllDeclaration;</span><span class="s3">\n  </span><span class="s1">validate(defs.source, node, </span><span class="s3">\&quot;</span><span class="s1">source</span><span class="s3">\&quot;</span><span class="s1">, source, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function exportDefaultDeclaration(</span><span class="s3">\n  </span><span class="s1">declaration:</span><span class="s3">\n    </span><span class="s1">| t.TSDeclareFunction</span><span class="s3">\n    </span><span class="s1">| t.FunctionDeclaration</span><span class="s3">\n    </span><span class="s1">| t.ClassDeclaration</span><span class="s3">\n    </span><span class="s1">| t.Expression,</span><span class="s3">\n</span><span class="s1">): t.ExportDefaultDeclaration {</span><span class="s3">\n  </span><span class="s1">const node: t.ExportDefaultDeclaration = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">ExportDefaultDeclaration</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">declaration,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.ExportDefaultDeclaration;</span><span class="s3">\n  </span><span class="s1">validate(defs.declaration, node, </span><span class="s3">\&quot;</span><span class="s1">declaration</span><span class="s3">\&quot;</span><span class="s1">, declaration, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function exportNamedDeclaration(</span><span class="s3">\n  </span><span class="s1">declaration: t.Declaration | null = null,</span><span class="s3">\n  </span><span class="s1">specifiers: Array&lt;</span><span class="s3">\n    </span><span class="s1">t.ExportSpecifier | t.ExportDefaultSpecifier | t.ExportNamespaceSpecifier</span><span class="s3">\n  </span><span class="s1">&gt; = [],</span><span class="s3">\n  </span><span class="s1">source: t.StringLiteral | null = null,</span><span class="s3">\n</span><span class="s1">): t.ExportNamedDeclaration {</span><span class="s3">\n  </span><span class="s1">const node: t.ExportNamedDeclaration = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">ExportNamedDeclaration</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">declaration,</span><span class="s3">\n    </span><span class="s1">specifiers,</span><span class="s3">\n    </span><span class="s1">source,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.ExportNamedDeclaration;</span><span class="s3">\n  </span><span class="s1">validate(defs.declaration, node, </span><span class="s3">\&quot;</span><span class="s1">declaration</span><span class="s3">\&quot;</span><span class="s1">, declaration, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.specifiers, node, </span><span class="s3">\&quot;</span><span class="s1">specifiers</span><span class="s3">\&quot;</span><span class="s1">, specifiers, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.source, node, </span><span class="s3">\&quot;</span><span class="s1">source</span><span class="s3">\&quot;</span><span class="s1">, source, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function exportSpecifier(</span><span class="s3">\n  </span><span class="s1">local: t.Identifier,</span><span class="s3">\n  </span><span class="s1">exported: t.Identifier | t.StringLiteral,</span><span class="s3">\n</span><span class="s1">): t.ExportSpecifier {</span><span class="s3">\n  </span><span class="s1">const node: t.ExportSpecifier = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">ExportSpecifier</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">local,</span><span class="s3">\n    </span><span class="s1">exported,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.ExportSpecifier;</span><span class="s3">\n  </span><span class="s1">validate(defs.local, node, </span><span class="s3">\&quot;</span><span class="s1">local</span><span class="s3">\&quot;</span><span class="s1">, local, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.exported, node, </span><span class="s3">\&quot;</span><span class="s1">exported</span><span class="s3">\&quot;</span><span class="s1">, exported, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function forOfStatement(</span><span class="s3">\n  </span><span class="s1">left: t.VariableDeclaration | t.LVal,</span><span class="s3">\n  </span><span class="s1">right: t.Expression,</span><span class="s3">\n  </span><span class="s1">body: t.Statement,</span><span class="s3">\n  </span><span class="s1">_await: boolean = false,</span><span class="s3">\n</span><span class="s1">): t.ForOfStatement {</span><span class="s3">\n  </span><span class="s1">const node: t.ForOfStatement = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">ForOfStatement</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">left,</span><span class="s3">\n    </span><span class="s1">right,</span><span class="s3">\n    </span><span class="s1">body,</span><span class="s3">\n    </span><span class="s1">await: _await,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.ForOfStatement;</span><span class="s3">\n  </span><span class="s1">validate(defs.left, node, </span><span class="s3">\&quot;</span><span class="s1">left</span><span class="s3">\&quot;</span><span class="s1">, left, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.right, node, </span><span class="s3">\&quot;</span><span class="s1">right</span><span class="s3">\&quot;</span><span class="s1">, right, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.body, node, </span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">, body, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.await, node, </span><span class="s3">\&quot;</span><span class="s1">await</span><span class="s3">\&quot;</span><span class="s1">, _await);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function importDeclaration(</span><span class="s3">\n  </span><span class="s1">specifiers: Array&lt;</span><span class="s3">\n    </span><span class="s1">t.ImportSpecifier | t.ImportDefaultSpecifier | t.ImportNamespaceSpecifier</span><span class="s3">\n  </span><span class="s1">&gt;,</span><span class="s3">\n  </span><span class="s1">source: t.StringLiteral,</span><span class="s3">\n</span><span class="s1">): t.ImportDeclaration {</span><span class="s3">\n  </span><span class="s1">const node: t.ImportDeclaration = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">ImportDeclaration</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">specifiers,</span><span class="s3">\n    </span><span class="s1">source,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.ImportDeclaration;</span><span class="s3">\n  </span><span class="s1">validate(defs.specifiers, node, </span><span class="s3">\&quot;</span><span class="s1">specifiers</span><span class="s3">\&quot;</span><span class="s1">, specifiers, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.source, node, </span><span class="s3">\&quot;</span><span class="s1">source</span><span class="s3">\&quot;</span><span class="s1">, source, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function importDefaultSpecifier(</span><span class="s3">\n  </span><span class="s1">local: t.Identifier,</span><span class="s3">\n</span><span class="s1">): t.ImportDefaultSpecifier {</span><span class="s3">\n  </span><span class="s1">const node: t.ImportDefaultSpecifier = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">ImportDefaultSpecifier</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">local,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.ImportDefaultSpecifier;</span><span class="s3">\n  </span><span class="s1">validate(defs.local, node, </span><span class="s3">\&quot;</span><span class="s1">local</span><span class="s3">\&quot;</span><span class="s1">, local, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function importNamespaceSpecifier(</span><span class="s3">\n  </span><span class="s1">local: t.Identifier,</span><span class="s3">\n</span><span class="s1">): t.ImportNamespaceSpecifier {</span><span class="s3">\n  </span><span class="s1">const node: t.ImportNamespaceSpecifier = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">ImportNamespaceSpecifier</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">local,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.ImportNamespaceSpecifier;</span><span class="s3">\n  </span><span class="s1">validate(defs.local, node, </span><span class="s3">\&quot;</span><span class="s1">local</span><span class="s3">\&quot;</span><span class="s1">, local, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function importSpecifier(</span><span class="s3">\n  </span><span class="s1">local: t.Identifier,</span><span class="s3">\n  </span><span class="s1">imported: t.Identifier | t.StringLiteral,</span><span class="s3">\n</span><span class="s1">): t.ImportSpecifier {</span><span class="s3">\n  </span><span class="s1">const node: t.ImportSpecifier = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">ImportSpecifier</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">local,</span><span class="s3">\n    </span><span class="s1">imported,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.ImportSpecifier;</span><span class="s3">\n  </span><span class="s1">validate(defs.local, node, </span><span class="s3">\&quot;</span><span class="s1">local</span><span class="s3">\&quot;</span><span class="s1">, local, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.imported, node, </span><span class="s3">\&quot;</span><span class="s1">imported</span><span class="s3">\&quot;</span><span class="s1">, imported, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function importExpression(</span><span class="s3">\n  </span><span class="s1">source: t.Expression,</span><span class="s3">\n  </span><span class="s1">options: t.Expression | null = null,</span><span class="s3">\n</span><span class="s1">): t.ImportExpression {</span><span class="s3">\n  </span><span class="s1">const node: t.ImportExpression = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">ImportExpression</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">source,</span><span class="s3">\n    </span><span class="s1">options,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.ImportExpression;</span><span class="s3">\n  </span><span class="s1">validate(defs.source, node, </span><span class="s3">\&quot;</span><span class="s1">source</span><span class="s3">\&quot;</span><span class="s1">, source, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.options, node, </span><span class="s3">\&quot;</span><span class="s1">options</span><span class="s3">\&quot;</span><span class="s1">, options, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function metaProperty(</span><span class="s3">\n  </span><span class="s1">meta: t.Identifier,</span><span class="s3">\n  </span><span class="s1">property: t.Identifier,</span><span class="s3">\n</span><span class="s1">): t.MetaProperty {</span><span class="s3">\n  </span><span class="s1">const node: t.MetaProperty = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">MetaProperty</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">meta,</span><span class="s3">\n    </span><span class="s1">property,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.MetaProperty;</span><span class="s3">\n  </span><span class="s1">validate(defs.meta, node, </span><span class="s3">\&quot;</span><span class="s1">meta</span><span class="s3">\&quot;</span><span class="s1">, meta, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.property, node, </span><span class="s3">\&quot;</span><span class="s1">property</span><span class="s3">\&quot;</span><span class="s1">, property, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function classMethod(</span><span class="s3">\n  </span><span class="s1">kind: </span><span class="s3">\&quot;</span><span class="s1">get</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">set</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">method</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">constructor</span><span class="s3">\&quot; </span><span class="s1">| undefined = </span><span class="s3">\&quot;</span><span class="s1">method</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">key:</span><span class="s3">\n    </span><span class="s1">| t.Identifier</span><span class="s3">\n    </span><span class="s1">| t.StringLiteral</span><span class="s3">\n    </span><span class="s1">| t.NumericLiteral</span><span class="s3">\n    </span><span class="s1">| t.BigIntLiteral</span><span class="s3">\n    </span><span class="s1">| t.Expression,</span><span class="s3">\n  </span><span class="s1">params: Array&lt;</span><span class="s3">\n    </span><span class="s1">t.Identifier | t.Pattern | t.RestElement | t.TSParameterProperty</span><span class="s3">\n  </span><span class="s1">&gt;,</span><span class="s3">\n  </span><span class="s1">body: t.BlockStatement,</span><span class="s3">\n  </span><span class="s1">computed: boolean = false,</span><span class="s3">\n  </span><span class="s1">_static: boolean = false,</span><span class="s3">\n  </span><span class="s1">generator: boolean = false,</span><span class="s3">\n  </span><span class="s1">async: boolean = false,</span><span class="s3">\n</span><span class="s1">): t.ClassMethod {</span><span class="s3">\n  </span><span class="s1">const node: t.ClassMethod = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">ClassMethod</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">kind,</span><span class="s3">\n    </span><span class="s1">key,</span><span class="s3">\n    </span><span class="s1">params,</span><span class="s3">\n    </span><span class="s1">body,</span><span class="s3">\n    </span><span class="s1">computed,</span><span class="s3">\n    </span><span class="s1">static: _static,</span><span class="s3">\n    </span><span class="s1">generator,</span><span class="s3">\n    </span><span class="s1">async,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.ClassMethod;</span><span class="s3">\n  </span><span class="s1">validate(defs.kind, node, </span><span class="s3">\&quot;</span><span class="s1">kind</span><span class="s3">\&quot;</span><span class="s1">, kind);</span><span class="s3">\n  </span><span class="s1">validate(defs.key, node, </span><span class="s3">\&quot;</span><span class="s1">key</span><span class="s3">\&quot;</span><span class="s1">, key, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.params, node, </span><span class="s3">\&quot;</span><span class="s1">params</span><span class="s3">\&quot;</span><span class="s1">, params, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.body, node, </span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">, body, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.computed, node, </span><span class="s3">\&quot;</span><span class="s1">computed</span><span class="s3">\&quot;</span><span class="s1">, computed);</span><span class="s3">\n  </span><span class="s1">validate(defs.static, node, </span><span class="s3">\&quot;</span><span class="s1">static</span><span class="s3">\&quot;</span><span class="s1">, _static);</span><span class="s3">\n  </span><span class="s1">validate(defs.generator, node, </span><span class="s3">\&quot;</span><span class="s1">generator</span><span class="s3">\&quot;</span><span class="s1">, generator);</span><span class="s3">\n  </span><span class="s1">validate(defs.async, node, </span><span class="s3">\&quot;</span><span class="s1">async</span><span class="s3">\&quot;</span><span class="s1">, async);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function objectPattern(</span><span class="s3">\n  </span><span class="s1">properties: Array&lt;t.RestElement | t.ObjectProperty&gt;,</span><span class="s3">\n</span><span class="s1">): t.ObjectPattern {</span><span class="s3">\n  </span><span class="s1">const node: t.ObjectPattern = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">ObjectPattern</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">properties,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.ObjectPattern;</span><span class="s3">\n  </span><span class="s1">validate(defs.properties, node, </span><span class="s3">\&quot;</span><span class="s1">properties</span><span class="s3">\&quot;</span><span class="s1">, properties, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function spreadElement(argument: t.Expression): t.SpreadElement {</span><span class="s3">\n  </span><span class="s1">const node: t.SpreadElement = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">SpreadElement</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">argument,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.SpreadElement;</span><span class="s3">\n  </span><span class="s1">validate(defs.argument, node, </span><span class="s3">\&quot;</span><span class="s1">argument</span><span class="s3">\&quot;</span><span class="s1">, argument, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function _super(): t.Super {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">Super</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { _super as super };</span><span class="s3">\n</span><span class="s1">export function taggedTemplateExpression(</span><span class="s3">\n  </span><span class="s1">tag: t.Expression,</span><span class="s3">\n  </span><span class="s1">quasi: t.TemplateLiteral,</span><span class="s3">\n</span><span class="s1">): t.TaggedTemplateExpression {</span><span class="s3">\n  </span><span class="s1">const node: t.TaggedTemplateExpression = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TaggedTemplateExpression</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">tag,</span><span class="s3">\n    </span><span class="s1">quasi,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.TaggedTemplateExpression;</span><span class="s3">\n  </span><span class="s1">validate(defs.tag, node, </span><span class="s3">\&quot;</span><span class="s1">tag</span><span class="s3">\&quot;</span><span class="s1">, tag, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.quasi, node, </span><span class="s3">\&quot;</span><span class="s1">quasi</span><span class="s3">\&quot;</span><span class="s1">, quasi, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function templateElement(</span><span class="s3">\n  </span><span class="s1">value: { raw: string; cooked?: string },</span><span class="s3">\n  </span><span class="s1">tail: boolean = false,</span><span class="s3">\n</span><span class="s1">): t.TemplateElement {</span><span class="s3">\n  </span><span class="s1">const node: t.TemplateElement = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TemplateElement</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value,</span><span class="s3">\n    </span><span class="s1">tail,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.TemplateElement;</span><span class="s3">\n  </span><span class="s1">validate(defs.value, node, </span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">, value);</span><span class="s3">\n  </span><span class="s1">validate(defs.tail, node, </span><span class="s3">\&quot;</span><span class="s1">tail</span><span class="s3">\&quot;</span><span class="s1">, tail);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function templateLiteral(</span><span class="s3">\n  </span><span class="s1">quasis: Array&lt;t.TemplateElement&gt;,</span><span class="s3">\n  </span><span class="s1">expressions: Array&lt;t.Expression | t.TSType&gt;,</span><span class="s3">\n</span><span class="s1">): t.TemplateLiteral {</span><span class="s3">\n  </span><span class="s1">const node: t.TemplateLiteral = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TemplateLiteral</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">quasis,</span><span class="s3">\n    </span><span class="s1">expressions,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.TemplateLiteral;</span><span class="s3">\n  </span><span class="s1">validate(defs.quasis, node, </span><span class="s3">\&quot;</span><span class="s1">quasis</span><span class="s3">\&quot;</span><span class="s1">, quasis, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.expressions, node, </span><span class="s3">\&quot;</span><span class="s1">expressions</span><span class="s3">\&quot;</span><span class="s1">, expressions, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function yieldExpression(</span><span class="s3">\n  </span><span class="s1">argument: t.Expression | null = null,</span><span class="s3">\n  </span><span class="s1">delegate: boolean = false,</span><span class="s3">\n</span><span class="s1">): t.YieldExpression {</span><span class="s3">\n  </span><span class="s1">const node: t.YieldExpression = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">YieldExpression</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">argument,</span><span class="s3">\n    </span><span class="s1">delegate,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.YieldExpression;</span><span class="s3">\n  </span><span class="s1">validate(defs.argument, node, </span><span class="s3">\&quot;</span><span class="s1">argument</span><span class="s3">\&quot;</span><span class="s1">, argument, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.delegate, node, </span><span class="s3">\&quot;</span><span class="s1">delegate</span><span class="s3">\&quot;</span><span class="s1">, delegate);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function awaitExpression(argument: t.Expression): t.AwaitExpression {</span><span class="s3">\n  </span><span class="s1">const node: t.AwaitExpression = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">AwaitExpression</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">argument,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.AwaitExpression;</span><span class="s3">\n  </span><span class="s1">validate(defs.argument, node, </span><span class="s3">\&quot;</span><span class="s1">argument</span><span class="s3">\&quot;</span><span class="s1">, argument, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function _import(): t.Import {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">Import</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { _import as import };</span><span class="s3">\n</span><span class="s1">export function bigIntLiteral(value: string): t.BigIntLiteral {</span><span class="s3">\n  </span><span class="s1">const node: t.BigIntLiteral = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">BigIntLiteral</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.BigIntLiteral;</span><span class="s3">\n  </span><span class="s1">validate(defs.value, node, </span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">, value);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function exportNamespaceSpecifier(</span><span class="s3">\n  </span><span class="s1">exported: t.Identifier,</span><span class="s3">\n</span><span class="s1">): t.ExportNamespaceSpecifier {</span><span class="s3">\n  </span><span class="s1">const node: t.ExportNamespaceSpecifier = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">ExportNamespaceSpecifier</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">exported,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.ExportNamespaceSpecifier;</span><span class="s3">\n  </span><span class="s1">validate(defs.exported, node, </span><span class="s3">\&quot;</span><span class="s1">exported</span><span class="s3">\&quot;</span><span class="s1">, exported, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function optionalMemberExpression(</span><span class="s3">\n  </span><span class="s1">object: t.Expression,</span><span class="s3">\n  </span><span class="s1">property: t.Expression | t.Identifier,</span><span class="s3">\n  </span><span class="s1">computed: boolean | undefined = false,</span><span class="s3">\n  </span><span class="s1">optional: boolean,</span><span class="s3">\n</span><span class="s1">): t.OptionalMemberExpression {</span><span class="s3">\n  </span><span class="s1">const node: t.OptionalMemberExpression = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">OptionalMemberExpression</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">object,</span><span class="s3">\n    </span><span class="s1">property,</span><span class="s3">\n    </span><span class="s1">computed,</span><span class="s3">\n    </span><span class="s1">optional,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.OptionalMemberExpression;</span><span class="s3">\n  </span><span class="s1">validate(defs.object, node, </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">, object, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.property, node, </span><span class="s3">\&quot;</span><span class="s1">property</span><span class="s3">\&quot;</span><span class="s1">, property, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.computed, node, </span><span class="s3">\&quot;</span><span class="s1">computed</span><span class="s3">\&quot;</span><span class="s1">, computed);</span><span class="s3">\n  </span><span class="s1">validate(defs.optional, node, </span><span class="s3">\&quot;</span><span class="s1">optional</span><span class="s3">\&quot;</span><span class="s1">, optional);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function optionalCallExpression(</span><span class="s3">\n  </span><span class="s1">callee: t.Expression,</span><span class="s3">\n  </span><span class="s1">_arguments: Array&lt;t.Expression | t.SpreadElement | t.ArgumentPlaceholder&gt;,</span><span class="s3">\n  </span><span class="s1">optional: boolean,</span><span class="s3">\n</span><span class="s1">): t.OptionalCallExpression {</span><span class="s3">\n  </span><span class="s1">const node: t.OptionalCallExpression = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">OptionalCallExpression</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">callee,</span><span class="s3">\n    </span><span class="s1">arguments: _arguments,</span><span class="s3">\n    </span><span class="s1">optional,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.OptionalCallExpression;</span><span class="s3">\n  </span><span class="s1">validate(defs.callee, node, </span><span class="s3">\&quot;</span><span class="s1">callee</span><span class="s3">\&quot;</span><span class="s1">, callee, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.arguments, node, </span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">, _arguments, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.optional, node, </span><span class="s3">\&quot;</span><span class="s1">optional</span><span class="s3">\&quot;</span><span class="s1">, optional);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function classProperty(</span><span class="s3">\n  </span><span class="s1">key:</span><span class="s3">\n    </span><span class="s1">| t.Identifier</span><span class="s3">\n    </span><span class="s1">| t.StringLiteral</span><span class="s3">\n    </span><span class="s1">| t.NumericLiteral</span><span class="s3">\n    </span><span class="s1">| t.BigIntLiteral</span><span class="s3">\n    </span><span class="s1">| t.Expression,</span><span class="s3">\n  </span><span class="s1">value: t.Expression | null = null,</span><span class="s3">\n  </span><span class="s1">typeAnnotation: t.TypeAnnotation | t.TSTypeAnnotation | t.Noop | null = null,</span><span class="s3">\n  </span><span class="s1">decorators: Array&lt;t.Decorator&gt; | null = null,</span><span class="s3">\n  </span><span class="s1">computed: boolean = false,</span><span class="s3">\n  </span><span class="s1">_static: boolean = false,</span><span class="s3">\n</span><span class="s1">): t.ClassProperty {</span><span class="s3">\n  </span><span class="s1">const node: t.ClassProperty = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">ClassProperty</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">key,</span><span class="s3">\n    </span><span class="s1">value,</span><span class="s3">\n    </span><span class="s1">typeAnnotation,</span><span class="s3">\n    </span><span class="s1">decorators,</span><span class="s3">\n    </span><span class="s1">computed,</span><span class="s3">\n    </span><span class="s1">static: _static,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.ClassProperty;</span><span class="s3">\n  </span><span class="s1">validate(defs.key, node, </span><span class="s3">\&quot;</span><span class="s1">key</span><span class="s3">\&quot;</span><span class="s1">, key, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.value, node, </span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">, value, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.typeAnnotation, node, </span><span class="s3">\&quot;</span><span class="s1">typeAnnotation</span><span class="s3">\&quot;</span><span class="s1">, typeAnnotation, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.decorators, node, </span><span class="s3">\&quot;</span><span class="s1">decorators</span><span class="s3">\&quot;</span><span class="s1">, decorators, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.computed, node, </span><span class="s3">\&quot;</span><span class="s1">computed</span><span class="s3">\&quot;</span><span class="s1">, computed);</span><span class="s3">\n  </span><span class="s1">validate(defs.static, node, </span><span class="s3">\&quot;</span><span class="s1">static</span><span class="s3">\&quot;</span><span class="s1">, _static);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function classAccessorProperty(</span><span class="s3">\n  </span><span class="s1">key:</span><span class="s3">\n    </span><span class="s1">| t.Identifier</span><span class="s3">\n    </span><span class="s1">| t.StringLiteral</span><span class="s3">\n    </span><span class="s1">| t.NumericLiteral</span><span class="s3">\n    </span><span class="s1">| t.BigIntLiteral</span><span class="s3">\n    </span><span class="s1">| t.Expression</span><span class="s3">\n    </span><span class="s1">| t.PrivateName,</span><span class="s3">\n  </span><span class="s1">value: t.Expression | null = null,</span><span class="s3">\n  </span><span class="s1">typeAnnotation: t.TypeAnnotation | t.TSTypeAnnotation | t.Noop | null = null,</span><span class="s3">\n  </span><span class="s1">decorators: Array&lt;t.Decorator&gt; | null = null,</span><span class="s3">\n  </span><span class="s1">computed: boolean = false,</span><span class="s3">\n  </span><span class="s1">_static: boolean = false,</span><span class="s3">\n</span><span class="s1">): t.ClassAccessorProperty {</span><span class="s3">\n  </span><span class="s1">const node: t.ClassAccessorProperty = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">ClassAccessorProperty</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">key,</span><span class="s3">\n    </span><span class="s1">value,</span><span class="s3">\n    </span><span class="s1">typeAnnotation,</span><span class="s3">\n    </span><span class="s1">decorators,</span><span class="s3">\n    </span><span class="s1">computed,</span><span class="s3">\n    </span><span class="s1">static: _static,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.ClassAccessorProperty;</span><span class="s3">\n  </span><span class="s1">validate(defs.key, node, </span><span class="s3">\&quot;</span><span class="s1">key</span><span class="s3">\&quot;</span><span class="s1">, key, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.value, node, </span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">, value, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.typeAnnotation, node, </span><span class="s3">\&quot;</span><span class="s1">typeAnnotation</span><span class="s3">\&quot;</span><span class="s1">, typeAnnotation, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.decorators, node, </span><span class="s3">\&quot;</span><span class="s1">decorators</span><span class="s3">\&quot;</span><span class="s1">, decorators, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.computed, node, </span><span class="s3">\&quot;</span><span class="s1">computed</span><span class="s3">\&quot;</span><span class="s1">, computed);</span><span class="s3">\n  </span><span class="s1">validate(defs.static, node, </span><span class="s3">\&quot;</span><span class="s1">static</span><span class="s3">\&quot;</span><span class="s1">, _static);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function classPrivateProperty(</span><span class="s3">\n  </span><span class="s1">key: t.PrivateName,</span><span class="s3">\n  </span><span class="s1">value: t.Expression | null = null,</span><span class="s3">\n  </span><span class="s1">decorators: Array&lt;t.Decorator&gt; | null = null,</span><span class="s3">\n  </span><span class="s1">_static: boolean = false,</span><span class="s3">\n</span><span class="s1">): t.ClassPrivateProperty {</span><span class="s3">\n  </span><span class="s1">const node: t.ClassPrivateProperty = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">ClassPrivateProperty</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">key,</span><span class="s3">\n    </span><span class="s1">value,</span><span class="s3">\n    </span><span class="s1">decorators,</span><span class="s3">\n    </span><span class="s1">static: _static,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.ClassPrivateProperty;</span><span class="s3">\n  </span><span class="s1">validate(defs.key, node, </span><span class="s3">\&quot;</span><span class="s1">key</span><span class="s3">\&quot;</span><span class="s1">, key, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.value, node, </span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">, value, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.decorators, node, </span><span class="s3">\&quot;</span><span class="s1">decorators</span><span class="s3">\&quot;</span><span class="s1">, decorators, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.static, node, </span><span class="s3">\&quot;</span><span class="s1">static</span><span class="s3">\&quot;</span><span class="s1">, _static);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function classPrivateMethod(</span><span class="s3">\n  </span><span class="s1">kind: </span><span class="s3">\&quot;</span><span class="s1">get</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">set</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">method</span><span class="s3">\&quot; </span><span class="s1">| undefined = </span><span class="s3">\&quot;</span><span class="s1">method</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">key: t.PrivateName,</span><span class="s3">\n  </span><span class="s1">params: Array&lt;</span><span class="s3">\n    </span><span class="s1">t.Identifier | t.Pattern | t.RestElement | t.TSParameterProperty</span><span class="s3">\n  </span><span class="s1">&gt;,</span><span class="s3">\n  </span><span class="s1">body: t.BlockStatement,</span><span class="s3">\n  </span><span class="s1">_static: boolean = false,</span><span class="s3">\n</span><span class="s1">): t.ClassPrivateMethod {</span><span class="s3">\n  </span><span class="s1">const node: t.ClassPrivateMethod = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">ClassPrivateMethod</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">kind,</span><span class="s3">\n    </span><span class="s1">key,</span><span class="s3">\n    </span><span class="s1">params,</span><span class="s3">\n    </span><span class="s1">body,</span><span class="s3">\n    </span><span class="s1">static: _static,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.ClassPrivateMethod;</span><span class="s3">\n  </span><span class="s1">validate(defs.kind, node, </span><span class="s3">\&quot;</span><span class="s1">kind</span><span class="s3">\&quot;</span><span class="s1">, kind);</span><span class="s3">\n  </span><span class="s1">validate(defs.key, node, </span><span class="s3">\&quot;</span><span class="s1">key</span><span class="s3">\&quot;</span><span class="s1">, key, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.params, node, </span><span class="s3">\&quot;</span><span class="s1">params</span><span class="s3">\&quot;</span><span class="s1">, params, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.body, node, </span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">, body, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.static, node, </span><span class="s3">\&quot;</span><span class="s1">static</span><span class="s3">\&quot;</span><span class="s1">, _static);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function privateName(id: t.Identifier): t.PrivateName {</span><span class="s3">\n  </span><span class="s1">const node: t.PrivateName = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">PrivateName</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">id,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.PrivateName;</span><span class="s3">\n  </span><span class="s1">validate(defs.id, node, </span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">, id, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function staticBlock(body: Array&lt;t.Statement&gt;): t.StaticBlock {</span><span class="s3">\n  </span><span class="s1">const node: t.StaticBlock = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">StaticBlock</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">body,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.StaticBlock;</span><span class="s3">\n  </span><span class="s1">validate(defs.body, node, </span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">, body, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function importAttribute(</span><span class="s3">\n  </span><span class="s1">key: t.Identifier | t.StringLiteral,</span><span class="s3">\n  </span><span class="s1">value: t.StringLiteral,</span><span class="s3">\n</span><span class="s1">): t.ImportAttribute {</span><span class="s3">\n  </span><span class="s1">const node: t.ImportAttribute = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">ImportAttribute</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">key,</span><span class="s3">\n    </span><span class="s1">value,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.ImportAttribute;</span><span class="s3">\n  </span><span class="s1">validate(defs.key, node, </span><span class="s3">\&quot;</span><span class="s1">key</span><span class="s3">\&quot;</span><span class="s1">, key, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.value, node, </span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">, value, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function anyTypeAnnotation(): t.AnyTypeAnnotation {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">AnyTypeAnnotation</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function arrayTypeAnnotation(</span><span class="s3">\n  </span><span class="s1">elementType: t.FlowType,</span><span class="s3">\n</span><span class="s1">): t.ArrayTypeAnnotation {</span><span class="s3">\n  </span><span class="s1">const node: t.ArrayTypeAnnotation = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">ArrayTypeAnnotation</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">elementType,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.ArrayTypeAnnotation;</span><span class="s3">\n  </span><span class="s1">validate(defs.elementType, node, </span><span class="s3">\&quot;</span><span class="s1">elementType</span><span class="s3">\&quot;</span><span class="s1">, elementType, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function booleanTypeAnnotation(): t.BooleanTypeAnnotation {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">BooleanTypeAnnotation</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function booleanLiteralTypeAnnotation(</span><span class="s3">\n  </span><span class="s1">value: boolean,</span><span class="s3">\n</span><span class="s1">): t.BooleanLiteralTypeAnnotation {</span><span class="s3">\n  </span><span class="s1">const node: t.BooleanLiteralTypeAnnotation = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">BooleanLiteralTypeAnnotation</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.BooleanLiteralTypeAnnotation;</span><span class="s3">\n  </span><span class="s1">validate(defs.value, node, </span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">, value);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function nullLiteralTypeAnnotation(): t.NullLiteralTypeAnnotation {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">NullLiteralTypeAnnotation</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function classImplements(</span><span class="s3">\n  </span><span class="s1">id: t.Identifier,</span><span class="s3">\n  </span><span class="s1">typeParameters: t.TypeParameterInstantiation | null = null,</span><span class="s3">\n</span><span class="s1">): t.ClassImplements {</span><span class="s3">\n  </span><span class="s1">const node: t.ClassImplements = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">ClassImplements</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">id,</span><span class="s3">\n    </span><span class="s1">typeParameters,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.ClassImplements;</span><span class="s3">\n  </span><span class="s1">validate(defs.id, node, </span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">, id, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.typeParameters, node, </span><span class="s3">\&quot;</span><span class="s1">typeParameters</span><span class="s3">\&quot;</span><span class="s1">, typeParameters, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function declareClass(</span><span class="s3">\n  </span><span class="s1">id: t.Identifier,</span><span class="s3">\n  </span><span class="s1">typeParameters: t.TypeParameterDeclaration | null | undefined = null,</span><span class="s3">\n  </span><span class="s1">_extends: Array&lt;t.InterfaceExtends&gt; | null | undefined = null,</span><span class="s3">\n  </span><span class="s1">body: t.ObjectTypeAnnotation,</span><span class="s3">\n</span><span class="s1">): t.DeclareClass {</span><span class="s3">\n  </span><span class="s1">const node: t.DeclareClass = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">DeclareClass</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">id,</span><span class="s3">\n    </span><span class="s1">typeParameters,</span><span class="s3">\n    </span><span class="s1">extends: _extends,</span><span class="s3">\n    </span><span class="s1">body,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.DeclareClass;</span><span class="s3">\n  </span><span class="s1">validate(defs.id, node, </span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">, id, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.typeParameters, node, </span><span class="s3">\&quot;</span><span class="s1">typeParameters</span><span class="s3">\&quot;</span><span class="s1">, typeParameters, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.extends, node, </span><span class="s3">\&quot;</span><span class="s1">extends</span><span class="s3">\&quot;</span><span class="s1">, _extends, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.body, node, </span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">, body, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function declareFunction(id: t.Identifier): t.DeclareFunction {</span><span class="s3">\n  </span><span class="s1">const node: t.DeclareFunction = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">DeclareFunction</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">id,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.DeclareFunction;</span><span class="s3">\n  </span><span class="s1">validate(defs.id, node, </span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">, id, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function declareInterface(</span><span class="s3">\n  </span><span class="s1">id: t.Identifier,</span><span class="s3">\n  </span><span class="s1">typeParameters: t.TypeParameterDeclaration | null | undefined = null,</span><span class="s3">\n  </span><span class="s1">_extends: Array&lt;t.InterfaceExtends&gt; | null | undefined = null,</span><span class="s3">\n  </span><span class="s1">body: t.ObjectTypeAnnotation,</span><span class="s3">\n</span><span class="s1">): t.DeclareInterface {</span><span class="s3">\n  </span><span class="s1">const node: t.DeclareInterface = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">DeclareInterface</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">id,</span><span class="s3">\n    </span><span class="s1">typeParameters,</span><span class="s3">\n    </span><span class="s1">extends: _extends,</span><span class="s3">\n    </span><span class="s1">body,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.DeclareInterface;</span><span class="s3">\n  </span><span class="s1">validate(defs.id, node, </span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">, id, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.typeParameters, node, </span><span class="s3">\&quot;</span><span class="s1">typeParameters</span><span class="s3">\&quot;</span><span class="s1">, typeParameters, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.extends, node, </span><span class="s3">\&quot;</span><span class="s1">extends</span><span class="s3">\&quot;</span><span class="s1">, _extends, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.body, node, </span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">, body, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function declareModule(</span><span class="s3">\n  </span><span class="s1">id: t.Identifier | t.StringLiteral,</span><span class="s3">\n  </span><span class="s1">body: t.BlockStatement,</span><span class="s3">\n  </span><span class="s1">kind: </span><span class="s3">\&quot;</span><span class="s1">CommonJS</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">ES</span><span class="s3">\&quot; </span><span class="s1">| null = null,</span><span class="s3">\n</span><span class="s1">): t.DeclareModule {</span><span class="s3">\n  </span><span class="s1">const node: t.DeclareModule = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">DeclareModule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">id,</span><span class="s3">\n    </span><span class="s1">body,</span><span class="s3">\n    </span><span class="s1">kind,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.DeclareModule;</span><span class="s3">\n  </span><span class="s1">validate(defs.id, node, </span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">, id, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.body, node, </span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">, body, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.kind, node, </span><span class="s3">\&quot;</span><span class="s1">kind</span><span class="s3">\&quot;</span><span class="s1">, kind);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function declareModuleExports(</span><span class="s3">\n  </span><span class="s1">typeAnnotation: t.TypeAnnotation,</span><span class="s3">\n</span><span class="s1">): t.DeclareModuleExports {</span><span class="s3">\n  </span><span class="s1">const node: t.DeclareModuleExports = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">DeclareModuleExports</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">typeAnnotation,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.DeclareModuleExports;</span><span class="s3">\n  </span><span class="s1">validate(defs.typeAnnotation, node, </span><span class="s3">\&quot;</span><span class="s1">typeAnnotation</span><span class="s3">\&quot;</span><span class="s1">, typeAnnotation, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function declareTypeAlias(</span><span class="s3">\n  </span><span class="s1">id: t.Identifier,</span><span class="s3">\n  </span><span class="s1">typeParameters: t.TypeParameterDeclaration | null | undefined = null,</span><span class="s3">\n  </span><span class="s1">right: t.FlowType,</span><span class="s3">\n</span><span class="s1">): t.DeclareTypeAlias {</span><span class="s3">\n  </span><span class="s1">const node: t.DeclareTypeAlias = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">DeclareTypeAlias</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">id,</span><span class="s3">\n    </span><span class="s1">typeParameters,</span><span class="s3">\n    </span><span class="s1">right,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.DeclareTypeAlias;</span><span class="s3">\n  </span><span class="s1">validate(defs.id, node, </span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">, id, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.typeParameters, node, </span><span class="s3">\&quot;</span><span class="s1">typeParameters</span><span class="s3">\&quot;</span><span class="s1">, typeParameters, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.right, node, </span><span class="s3">\&quot;</span><span class="s1">right</span><span class="s3">\&quot;</span><span class="s1">, right, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function declareOpaqueType(</span><span class="s3">\n  </span><span class="s1">id: t.Identifier,</span><span class="s3">\n  </span><span class="s1">typeParameters: t.TypeParameterDeclaration | null = null,</span><span class="s3">\n  </span><span class="s1">supertype: t.FlowType | null = null,</span><span class="s3">\n</span><span class="s1">): t.DeclareOpaqueType {</span><span class="s3">\n  </span><span class="s1">const node: t.DeclareOpaqueType = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">DeclareOpaqueType</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">id,</span><span class="s3">\n    </span><span class="s1">typeParameters,</span><span class="s3">\n    </span><span class="s1">supertype,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.DeclareOpaqueType;</span><span class="s3">\n  </span><span class="s1">validate(defs.id, node, </span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">, id, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.typeParameters, node, </span><span class="s3">\&quot;</span><span class="s1">typeParameters</span><span class="s3">\&quot;</span><span class="s1">, typeParameters, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.supertype, node, </span><span class="s3">\&quot;</span><span class="s1">supertype</span><span class="s3">\&quot;</span><span class="s1">, supertype, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function declareVariable(id: t.Identifier): t.DeclareVariable {</span><span class="s3">\n  </span><span class="s1">const node: t.DeclareVariable = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">DeclareVariable</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">id,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.DeclareVariable;</span><span class="s3">\n  </span><span class="s1">validate(defs.id, node, </span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">, id, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function declareExportDeclaration(</span><span class="s3">\n  </span><span class="s1">declaration: t.Flow | null = null,</span><span class="s3">\n  </span><span class="s1">specifiers: Array&lt;</span><span class="s3">\n    </span><span class="s1">t.ExportSpecifier | t.ExportNamespaceSpecifier</span><span class="s3">\n  </span><span class="s1">&gt; | null = null,</span><span class="s3">\n  </span><span class="s1">source: t.StringLiteral | null = null,</span><span class="s3">\n  </span><span class="s1">attributes: Array&lt;t.ImportAttribute&gt; | null = null,</span><span class="s3">\n</span><span class="s1">): t.DeclareExportDeclaration {</span><span class="s3">\n  </span><span class="s1">const node: t.DeclareExportDeclaration = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">DeclareExportDeclaration</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">declaration,</span><span class="s3">\n    </span><span class="s1">specifiers,</span><span class="s3">\n    </span><span class="s1">source,</span><span class="s3">\n    </span><span class="s1">attributes,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.DeclareExportDeclaration;</span><span class="s3">\n  </span><span class="s1">validate(defs.declaration, node, </span><span class="s3">\&quot;</span><span class="s1">declaration</span><span class="s3">\&quot;</span><span class="s1">, declaration, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.specifiers, node, </span><span class="s3">\&quot;</span><span class="s1">specifiers</span><span class="s3">\&quot;</span><span class="s1">, specifiers, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.source, node, </span><span class="s3">\&quot;</span><span class="s1">source</span><span class="s3">\&quot;</span><span class="s1">, source, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.attributes, node, </span><span class="s3">\&quot;</span><span class="s1">attributes</span><span class="s3">\&quot;</span><span class="s1">, attributes, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function declareExportAllDeclaration(</span><span class="s3">\n  </span><span class="s1">source: t.StringLiteral,</span><span class="s3">\n  </span><span class="s1">attributes: Array&lt;t.ImportAttribute&gt; | null = null,</span><span class="s3">\n</span><span class="s1">): t.DeclareExportAllDeclaration {</span><span class="s3">\n  </span><span class="s1">const node: t.DeclareExportAllDeclaration = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">DeclareExportAllDeclaration</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">source,</span><span class="s3">\n    </span><span class="s1">attributes,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.DeclareExportAllDeclaration;</span><span class="s3">\n  </span><span class="s1">validate(defs.source, node, </span><span class="s3">\&quot;</span><span class="s1">source</span><span class="s3">\&quot;</span><span class="s1">, source, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.attributes, node, </span><span class="s3">\&quot;</span><span class="s1">attributes</span><span class="s3">\&quot;</span><span class="s1">, attributes, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function declaredPredicate(value: t.Flow): t.DeclaredPredicate {</span><span class="s3">\n  </span><span class="s1">const node: t.DeclaredPredicate = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">DeclaredPredicate</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.DeclaredPredicate;</span><span class="s3">\n  </span><span class="s1">validate(defs.value, node, </span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">, value, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function existsTypeAnnotation(): t.ExistsTypeAnnotation {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">ExistsTypeAnnotation</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function functionTypeAnnotation(</span><span class="s3">\n  </span><span class="s1">typeParameters: t.TypeParameterDeclaration | null | undefined = null,</span><span class="s3">\n  </span><span class="s1">params: Array&lt;t.FunctionTypeParam&gt;,</span><span class="s3">\n  </span><span class="s1">rest: t.FunctionTypeParam | null | undefined = null,</span><span class="s3">\n  </span><span class="s1">returnType: t.FlowType,</span><span class="s3">\n</span><span class="s1">): t.FunctionTypeAnnotation {</span><span class="s3">\n  </span><span class="s1">const node: t.FunctionTypeAnnotation = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">FunctionTypeAnnotation</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">typeParameters,</span><span class="s3">\n    </span><span class="s1">params,</span><span class="s3">\n    </span><span class="s1">rest,</span><span class="s3">\n    </span><span class="s1">returnType,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.FunctionTypeAnnotation;</span><span class="s3">\n  </span><span class="s1">validate(defs.typeParameters, node, </span><span class="s3">\&quot;</span><span class="s1">typeParameters</span><span class="s3">\&quot;</span><span class="s1">, typeParameters, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.params, node, </span><span class="s3">\&quot;</span><span class="s1">params</span><span class="s3">\&quot;</span><span class="s1">, params, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.rest, node, </span><span class="s3">\&quot;</span><span class="s1">rest</span><span class="s3">\&quot;</span><span class="s1">, rest, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.returnType, node, </span><span class="s3">\&quot;</span><span class="s1">returnType</span><span class="s3">\&quot;</span><span class="s1">, returnType, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function functionTypeParam(</span><span class="s3">\n  </span><span class="s1">name: t.Identifier | null | undefined = null,</span><span class="s3">\n  </span><span class="s1">typeAnnotation: t.FlowType,</span><span class="s3">\n</span><span class="s1">): t.FunctionTypeParam {</span><span class="s3">\n  </span><span class="s1">const node: t.FunctionTypeParam = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">FunctionTypeParam</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">name,</span><span class="s3">\n    </span><span class="s1">typeAnnotation,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.FunctionTypeParam;</span><span class="s3">\n  </span><span class="s1">validate(defs.name, node, </span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">, name, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.typeAnnotation, node, </span><span class="s3">\&quot;</span><span class="s1">typeAnnotation</span><span class="s3">\&quot;</span><span class="s1">, typeAnnotation, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function genericTypeAnnotation(</span><span class="s3">\n  </span><span class="s1">id: t.Identifier | t.QualifiedTypeIdentifier,</span><span class="s3">\n  </span><span class="s1">typeParameters: t.TypeParameterInstantiation | null = null,</span><span class="s3">\n</span><span class="s1">): t.GenericTypeAnnotation {</span><span class="s3">\n  </span><span class="s1">const node: t.GenericTypeAnnotation = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">GenericTypeAnnotation</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">id,</span><span class="s3">\n    </span><span class="s1">typeParameters,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.GenericTypeAnnotation;</span><span class="s3">\n  </span><span class="s1">validate(defs.id, node, </span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">, id, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.typeParameters, node, </span><span class="s3">\&quot;</span><span class="s1">typeParameters</span><span class="s3">\&quot;</span><span class="s1">, typeParameters, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function inferredPredicate(): t.InferredPredicate {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">InferredPredicate</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function interfaceExtends(</span><span class="s3">\n  </span><span class="s1">id: t.Identifier | t.QualifiedTypeIdentifier,</span><span class="s3">\n  </span><span class="s1">typeParameters: t.TypeParameterInstantiation | null = null,</span><span class="s3">\n</span><span class="s1">): t.InterfaceExtends {</span><span class="s3">\n  </span><span class="s1">const node: t.InterfaceExtends = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">InterfaceExtends</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">id,</span><span class="s3">\n    </span><span class="s1">typeParameters,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.InterfaceExtends;</span><span class="s3">\n  </span><span class="s1">validate(defs.id, node, </span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">, id, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.typeParameters, node, </span><span class="s3">\&quot;</span><span class="s1">typeParameters</span><span class="s3">\&quot;</span><span class="s1">, typeParameters, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function interfaceDeclaration(</span><span class="s3">\n  </span><span class="s1">id: t.Identifier,</span><span class="s3">\n  </span><span class="s1">typeParameters: t.TypeParameterDeclaration | null | undefined = null,</span><span class="s3">\n  </span><span class="s1">_extends: Array&lt;t.InterfaceExtends&gt; | null | undefined = null,</span><span class="s3">\n  </span><span class="s1">body: t.ObjectTypeAnnotation,</span><span class="s3">\n</span><span class="s1">): t.InterfaceDeclaration {</span><span class="s3">\n  </span><span class="s1">const node: t.InterfaceDeclaration = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">InterfaceDeclaration</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">id,</span><span class="s3">\n    </span><span class="s1">typeParameters,</span><span class="s3">\n    </span><span class="s1">extends: _extends,</span><span class="s3">\n    </span><span class="s1">body,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.InterfaceDeclaration;</span><span class="s3">\n  </span><span class="s1">validate(defs.id, node, </span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">, id, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.typeParameters, node, </span><span class="s3">\&quot;</span><span class="s1">typeParameters</span><span class="s3">\&quot;</span><span class="s1">, typeParameters, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.extends, node, </span><span class="s3">\&quot;</span><span class="s1">extends</span><span class="s3">\&quot;</span><span class="s1">, _extends, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.body, node, </span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">, body, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function interfaceTypeAnnotation(</span><span class="s3">\n  </span><span class="s1">_extends: Array&lt;t.InterfaceExtends&gt; | null | undefined = null,</span><span class="s3">\n  </span><span class="s1">body: t.ObjectTypeAnnotation,</span><span class="s3">\n</span><span class="s1">): t.InterfaceTypeAnnotation {</span><span class="s3">\n  </span><span class="s1">const node: t.InterfaceTypeAnnotation = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">InterfaceTypeAnnotation</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">extends: _extends,</span><span class="s3">\n    </span><span class="s1">body,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.InterfaceTypeAnnotation;</span><span class="s3">\n  </span><span class="s1">validate(defs.extends, node, </span><span class="s3">\&quot;</span><span class="s1">extends</span><span class="s3">\&quot;</span><span class="s1">, _extends, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.body, node, </span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">, body, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function intersectionTypeAnnotation(</span><span class="s3">\n  </span><span class="s1">types: Array&lt;t.FlowType&gt;,</span><span class="s3">\n</span><span class="s1">): t.IntersectionTypeAnnotation {</span><span class="s3">\n  </span><span class="s1">const node: t.IntersectionTypeAnnotation = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">IntersectionTypeAnnotation</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">types,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.IntersectionTypeAnnotation;</span><span class="s3">\n  </span><span class="s1">validate(defs.types, node, </span><span class="s3">\&quot;</span><span class="s1">types</span><span class="s3">\&quot;</span><span class="s1">, types, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function mixedTypeAnnotation(): t.MixedTypeAnnotation {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">MixedTypeAnnotation</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function emptyTypeAnnotation(): t.EmptyTypeAnnotation {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">EmptyTypeAnnotation</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function nullableTypeAnnotation(</span><span class="s3">\n  </span><span class="s1">typeAnnotation: t.FlowType,</span><span class="s3">\n</span><span class="s1">): t.NullableTypeAnnotation {</span><span class="s3">\n  </span><span class="s1">const node: t.NullableTypeAnnotation = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">NullableTypeAnnotation</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">typeAnnotation,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.NullableTypeAnnotation;</span><span class="s3">\n  </span><span class="s1">validate(defs.typeAnnotation, node, </span><span class="s3">\&quot;</span><span class="s1">typeAnnotation</span><span class="s3">\&quot;</span><span class="s1">, typeAnnotation, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function numberLiteralTypeAnnotation(</span><span class="s3">\n  </span><span class="s1">value: number,</span><span class="s3">\n</span><span class="s1">): t.NumberLiteralTypeAnnotation {</span><span class="s3">\n  </span><span class="s1">const node: t.NumberLiteralTypeAnnotation = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">NumberLiteralTypeAnnotation</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.NumberLiteralTypeAnnotation;</span><span class="s3">\n  </span><span class="s1">validate(defs.value, node, </span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">, value);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function numberTypeAnnotation(): t.NumberTypeAnnotation {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">NumberTypeAnnotation</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function objectTypeAnnotation(</span><span class="s3">\n  </span><span class="s1">properties: Array&lt;t.ObjectTypeProperty | t.ObjectTypeSpreadProperty&gt;,</span><span class="s3">\n  </span><span class="s1">indexers: Array&lt;t.ObjectTypeIndexer&gt; = [],</span><span class="s3">\n  </span><span class="s1">callProperties: Array&lt;t.ObjectTypeCallProperty&gt; = [],</span><span class="s3">\n  </span><span class="s1">internalSlots: Array&lt;t.ObjectTypeInternalSlot&gt; = [],</span><span class="s3">\n  </span><span class="s1">exact: boolean = false,</span><span class="s3">\n</span><span class="s1">): t.ObjectTypeAnnotation {</span><span class="s3">\n  </span><span class="s1">const node: t.ObjectTypeAnnotation = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">ObjectTypeAnnotation</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">properties,</span><span class="s3">\n    </span><span class="s1">indexers,</span><span class="s3">\n    </span><span class="s1">callProperties,</span><span class="s3">\n    </span><span class="s1">internalSlots,</span><span class="s3">\n    </span><span class="s1">exact,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.ObjectTypeAnnotation;</span><span class="s3">\n  </span><span class="s1">validate(defs.properties, node, </span><span class="s3">\&quot;</span><span class="s1">properties</span><span class="s3">\&quot;</span><span class="s1">, properties, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.indexers, node, </span><span class="s3">\&quot;</span><span class="s1">indexers</span><span class="s3">\&quot;</span><span class="s1">, indexers, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.callProperties, node, </span><span class="s3">\&quot;</span><span class="s1">callProperties</span><span class="s3">\&quot;</span><span class="s1">, callProperties, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.internalSlots, node, </span><span class="s3">\&quot;</span><span class="s1">internalSlots</span><span class="s3">\&quot;</span><span class="s1">, internalSlots, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.exact, node, </span><span class="s3">\&quot;</span><span class="s1">exact</span><span class="s3">\&quot;</span><span class="s1">, exact);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function objectTypeInternalSlot(</span><span class="s3">\n  </span><span class="s1">id: t.Identifier,</span><span class="s3">\n  </span><span class="s1">value: t.FlowType,</span><span class="s3">\n  </span><span class="s1">optional: boolean,</span><span class="s3">\n  </span><span class="s1">_static: boolean,</span><span class="s3">\n  </span><span class="s1">method: boolean,</span><span class="s3">\n</span><span class="s1">): t.ObjectTypeInternalSlot {</span><span class="s3">\n  </span><span class="s1">const node: t.ObjectTypeInternalSlot = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">ObjectTypeInternalSlot</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">id,</span><span class="s3">\n    </span><span class="s1">value,</span><span class="s3">\n    </span><span class="s1">optional,</span><span class="s3">\n    </span><span class="s1">static: _static,</span><span class="s3">\n    </span><span class="s1">method,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.ObjectTypeInternalSlot;</span><span class="s3">\n  </span><span class="s1">validate(defs.id, node, </span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">, id, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.value, node, </span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">, value, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.optional, node, </span><span class="s3">\&quot;</span><span class="s1">optional</span><span class="s3">\&quot;</span><span class="s1">, optional);</span><span class="s3">\n  </span><span class="s1">validate(defs.static, node, </span><span class="s3">\&quot;</span><span class="s1">static</span><span class="s3">\&quot;</span><span class="s1">, _static);</span><span class="s3">\n  </span><span class="s1">validate(defs.method, node, </span><span class="s3">\&quot;</span><span class="s1">method</span><span class="s3">\&quot;</span><span class="s1">, method);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function objectTypeCallProperty(</span><span class="s3">\n  </span><span class="s1">value: t.FlowType,</span><span class="s3">\n</span><span class="s1">): t.ObjectTypeCallProperty {</span><span class="s3">\n  </span><span class="s1">const node: t.ObjectTypeCallProperty = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">ObjectTypeCallProperty</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value,</span><span class="s3">\n    </span><span class="s1">static: null,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.ObjectTypeCallProperty;</span><span class="s3">\n  </span><span class="s1">validate(defs.value, node, </span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">, value, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function objectTypeIndexer(</span><span class="s3">\n  </span><span class="s1">id: t.Identifier | null | undefined = null,</span><span class="s3">\n  </span><span class="s1">key: t.FlowType,</span><span class="s3">\n  </span><span class="s1">value: t.FlowType,</span><span class="s3">\n  </span><span class="s1">variance: t.Variance | null = null,</span><span class="s3">\n</span><span class="s1">): t.ObjectTypeIndexer {</span><span class="s3">\n  </span><span class="s1">const node: t.ObjectTypeIndexer = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">ObjectTypeIndexer</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">id,</span><span class="s3">\n    </span><span class="s1">key,</span><span class="s3">\n    </span><span class="s1">value,</span><span class="s3">\n    </span><span class="s1">variance,</span><span class="s3">\n    </span><span class="s1">static: null,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.ObjectTypeIndexer;</span><span class="s3">\n  </span><span class="s1">validate(defs.id, node, </span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">, id, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.key, node, </span><span class="s3">\&quot;</span><span class="s1">key</span><span class="s3">\&quot;</span><span class="s1">, key, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.value, node, </span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">, value, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.variance, node, </span><span class="s3">\&quot;</span><span class="s1">variance</span><span class="s3">\&quot;</span><span class="s1">, variance, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function objectTypeProperty(</span><span class="s3">\n  </span><span class="s1">key: t.Identifier | t.StringLiteral,</span><span class="s3">\n  </span><span class="s1">value: t.FlowType,</span><span class="s3">\n  </span><span class="s1">variance: t.Variance | null = null,</span><span class="s3">\n</span><span class="s1">): t.ObjectTypeProperty {</span><span class="s3">\n  </span><span class="s1">const node: t.ObjectTypeProperty = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">ObjectTypeProperty</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">key,</span><span class="s3">\n    </span><span class="s1">value,</span><span class="s3">\n    </span><span class="s1">variance,</span><span class="s3">\n    </span><span class="s1">kind: null,</span><span class="s3">\n    </span><span class="s1">method: null,</span><span class="s3">\n    </span><span class="s1">optional: null,</span><span class="s3">\n    </span><span class="s1">proto: null,</span><span class="s3">\n    </span><span class="s1">static: null,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.ObjectTypeProperty;</span><span class="s3">\n  </span><span class="s1">validate(defs.key, node, </span><span class="s3">\&quot;</span><span class="s1">key</span><span class="s3">\&quot;</span><span class="s1">, key, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.value, node, </span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">, value, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.variance, node, </span><span class="s3">\&quot;</span><span class="s1">variance</span><span class="s3">\&quot;</span><span class="s1">, variance, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function objectTypeSpreadProperty(</span><span class="s3">\n  </span><span class="s1">argument: t.FlowType,</span><span class="s3">\n</span><span class="s1">): t.ObjectTypeSpreadProperty {</span><span class="s3">\n  </span><span class="s1">const node: t.ObjectTypeSpreadProperty = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">ObjectTypeSpreadProperty</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">argument,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.ObjectTypeSpreadProperty;</span><span class="s3">\n  </span><span class="s1">validate(defs.argument, node, </span><span class="s3">\&quot;</span><span class="s1">argument</span><span class="s3">\&quot;</span><span class="s1">, argument, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function opaqueType(</span><span class="s3">\n  </span><span class="s1">id: t.Identifier,</span><span class="s3">\n  </span><span class="s1">typeParameters: t.TypeParameterDeclaration | null | undefined = null,</span><span class="s3">\n  </span><span class="s1">supertype: t.FlowType | null | undefined = null,</span><span class="s3">\n  </span><span class="s1">impltype: t.FlowType,</span><span class="s3">\n</span><span class="s1">): t.OpaqueType {</span><span class="s3">\n  </span><span class="s1">const node: t.OpaqueType = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">OpaqueType</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">id,</span><span class="s3">\n    </span><span class="s1">typeParameters,</span><span class="s3">\n    </span><span class="s1">supertype,</span><span class="s3">\n    </span><span class="s1">impltype,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.OpaqueType;</span><span class="s3">\n  </span><span class="s1">validate(defs.id, node, </span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">, id, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.typeParameters, node, </span><span class="s3">\&quot;</span><span class="s1">typeParameters</span><span class="s3">\&quot;</span><span class="s1">, typeParameters, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.supertype, node, </span><span class="s3">\&quot;</span><span class="s1">supertype</span><span class="s3">\&quot;</span><span class="s1">, supertype, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.impltype, node, </span><span class="s3">\&quot;</span><span class="s1">impltype</span><span class="s3">\&quot;</span><span class="s1">, impltype, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function qualifiedTypeIdentifier(</span><span class="s3">\n  </span><span class="s1">id: t.Identifier,</span><span class="s3">\n  </span><span class="s1">qualification: t.Identifier | t.QualifiedTypeIdentifier,</span><span class="s3">\n</span><span class="s1">): t.QualifiedTypeIdentifier {</span><span class="s3">\n  </span><span class="s1">const node: t.QualifiedTypeIdentifier = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">QualifiedTypeIdentifier</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">id,</span><span class="s3">\n    </span><span class="s1">qualification,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.QualifiedTypeIdentifier;</span><span class="s3">\n  </span><span class="s1">validate(defs.id, node, </span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">, id, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.qualification, node, </span><span class="s3">\&quot;</span><span class="s1">qualification</span><span class="s3">\&quot;</span><span class="s1">, qualification, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function stringLiteralTypeAnnotation(</span><span class="s3">\n  </span><span class="s1">value: string,</span><span class="s3">\n</span><span class="s1">): t.StringLiteralTypeAnnotation {</span><span class="s3">\n  </span><span class="s1">const node: t.StringLiteralTypeAnnotation = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">StringLiteralTypeAnnotation</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.StringLiteralTypeAnnotation;</span><span class="s3">\n  </span><span class="s1">validate(defs.value, node, </span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">, value);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function stringTypeAnnotation(): t.StringTypeAnnotation {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">StringTypeAnnotation</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function symbolTypeAnnotation(): t.SymbolTypeAnnotation {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">SymbolTypeAnnotation</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function thisTypeAnnotation(): t.ThisTypeAnnotation {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">ThisTypeAnnotation</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function tupleTypeAnnotation(</span><span class="s3">\n  </span><span class="s1">types: Array&lt;t.FlowType&gt;,</span><span class="s3">\n</span><span class="s1">): t.TupleTypeAnnotation {</span><span class="s3">\n  </span><span class="s1">const node: t.TupleTypeAnnotation = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TupleTypeAnnotation</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">types,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.TupleTypeAnnotation;</span><span class="s3">\n  </span><span class="s1">validate(defs.types, node, </span><span class="s3">\&quot;</span><span class="s1">types</span><span class="s3">\&quot;</span><span class="s1">, types, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function typeofTypeAnnotation(</span><span class="s3">\n  </span><span class="s1">argument: t.FlowType,</span><span class="s3">\n</span><span class="s1">): t.TypeofTypeAnnotation {</span><span class="s3">\n  </span><span class="s1">const node: t.TypeofTypeAnnotation = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TypeofTypeAnnotation</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">argument,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.TypeofTypeAnnotation;</span><span class="s3">\n  </span><span class="s1">validate(defs.argument, node, </span><span class="s3">\&quot;</span><span class="s1">argument</span><span class="s3">\&quot;</span><span class="s1">, argument, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function typeAlias(</span><span class="s3">\n  </span><span class="s1">id: t.Identifier,</span><span class="s3">\n  </span><span class="s1">typeParameters: t.TypeParameterDeclaration | null | undefined = null,</span><span class="s3">\n  </span><span class="s1">right: t.FlowType,</span><span class="s3">\n</span><span class="s1">): t.TypeAlias {</span><span class="s3">\n  </span><span class="s1">const node: t.TypeAlias = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TypeAlias</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">id,</span><span class="s3">\n    </span><span class="s1">typeParameters,</span><span class="s3">\n    </span><span class="s1">right,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.TypeAlias;</span><span class="s3">\n  </span><span class="s1">validate(defs.id, node, </span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">, id, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.typeParameters, node, </span><span class="s3">\&quot;</span><span class="s1">typeParameters</span><span class="s3">\&quot;</span><span class="s1">, typeParameters, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.right, node, </span><span class="s3">\&quot;</span><span class="s1">right</span><span class="s3">\&quot;</span><span class="s1">, right, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function typeAnnotation(typeAnnotation: t.FlowType): t.TypeAnnotation {</span><span class="s3">\n  </span><span class="s1">const node: t.TypeAnnotation = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TypeAnnotation</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">typeAnnotation,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.TypeAnnotation;</span><span class="s3">\n  </span><span class="s1">validate(defs.typeAnnotation, node, </span><span class="s3">\&quot;</span><span class="s1">typeAnnotation</span><span class="s3">\&quot;</span><span class="s1">, typeAnnotation, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function typeCastExpression(</span><span class="s3">\n  </span><span class="s1">expression: t.Expression,</span><span class="s3">\n  </span><span class="s1">typeAnnotation: t.TypeAnnotation,</span><span class="s3">\n</span><span class="s1">): t.TypeCastExpression {</span><span class="s3">\n  </span><span class="s1">const node: t.TypeCastExpression = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TypeCastExpression</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">expression,</span><span class="s3">\n    </span><span class="s1">typeAnnotation,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.TypeCastExpression;</span><span class="s3">\n  </span><span class="s1">validate(defs.expression, node, </span><span class="s3">\&quot;</span><span class="s1">expression</span><span class="s3">\&quot;</span><span class="s1">, expression, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.typeAnnotation, node, </span><span class="s3">\&quot;</span><span class="s1">typeAnnotation</span><span class="s3">\&quot;</span><span class="s1">, typeAnnotation, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function typeParameter(</span><span class="s3">\n  </span><span class="s1">bound: t.TypeAnnotation | null = null,</span><span class="s3">\n  </span><span class="s1">_default: t.FlowType | null = null,</span><span class="s3">\n  </span><span class="s1">variance: t.Variance | null = null,</span><span class="s3">\n</span><span class="s1">): t.TypeParameter {</span><span class="s3">\n  </span><span class="s1">const node: t.TypeParameter = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TypeParameter</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">bound,</span><span class="s3">\n    </span><span class="s1">default: _default,</span><span class="s3">\n    </span><span class="s1">variance,</span><span class="s3">\n    </span><span class="s1">name: null,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.TypeParameter;</span><span class="s3">\n  </span><span class="s1">validate(defs.bound, node, </span><span class="s3">\&quot;</span><span class="s1">bound</span><span class="s3">\&quot;</span><span class="s1">, bound, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.default, node, </span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot;</span><span class="s1">, _default, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.variance, node, </span><span class="s3">\&quot;</span><span class="s1">variance</span><span class="s3">\&quot;</span><span class="s1">, variance, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function typeParameterDeclaration(</span><span class="s3">\n  </span><span class="s1">params: Array&lt;t.TypeParameter&gt;,</span><span class="s3">\n</span><span class="s1">): t.TypeParameterDeclaration {</span><span class="s3">\n  </span><span class="s1">const node: t.TypeParameterDeclaration = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TypeParameterDeclaration</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">params,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.TypeParameterDeclaration;</span><span class="s3">\n  </span><span class="s1">validate(defs.params, node, </span><span class="s3">\&quot;</span><span class="s1">params</span><span class="s3">\&quot;</span><span class="s1">, params, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function typeParameterInstantiation(</span><span class="s3">\n  </span><span class="s1">params: Array&lt;t.FlowType&gt;,</span><span class="s3">\n</span><span class="s1">): t.TypeParameterInstantiation {</span><span class="s3">\n  </span><span class="s1">const node: t.TypeParameterInstantiation = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TypeParameterInstantiation</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">params,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.TypeParameterInstantiation;</span><span class="s3">\n  </span><span class="s1">validate(defs.params, node, </span><span class="s3">\&quot;</span><span class="s1">params</span><span class="s3">\&quot;</span><span class="s1">, params, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function unionTypeAnnotation(</span><span class="s3">\n  </span><span class="s1">types: Array&lt;t.FlowType&gt;,</span><span class="s3">\n</span><span class="s1">): t.UnionTypeAnnotation {</span><span class="s3">\n  </span><span class="s1">const node: t.UnionTypeAnnotation = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">UnionTypeAnnotation</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">types,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.UnionTypeAnnotation;</span><span class="s3">\n  </span><span class="s1">validate(defs.types, node, </span><span class="s3">\&quot;</span><span class="s1">types</span><span class="s3">\&quot;</span><span class="s1">, types, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function variance(kind: </span><span class="s3">\&quot;</span><span class="s1">minus</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">plus</span><span class="s3">\&quot;</span><span class="s1">): t.Variance {</span><span class="s3">\n  </span><span class="s1">const node: t.Variance = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">Variance</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">kind,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.Variance;</span><span class="s3">\n  </span><span class="s1">validate(defs.kind, node, </span><span class="s3">\&quot;</span><span class="s1">kind</span><span class="s3">\&quot;</span><span class="s1">, kind);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function voidTypeAnnotation(): t.VoidTypeAnnotation {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">VoidTypeAnnotation</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function enumDeclaration(</span><span class="s3">\n  </span><span class="s1">id: t.Identifier,</span><span class="s3">\n  </span><span class="s1">body:</span><span class="s3">\n    </span><span class="s1">| t.EnumBooleanBody</span><span class="s3">\n    </span><span class="s1">| t.EnumNumberBody</span><span class="s3">\n    </span><span class="s1">| t.EnumStringBody</span><span class="s3">\n    </span><span class="s1">| t.EnumSymbolBody,</span><span class="s3">\n</span><span class="s1">): t.EnumDeclaration {</span><span class="s3">\n  </span><span class="s1">const node: t.EnumDeclaration = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">EnumDeclaration</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">id,</span><span class="s3">\n    </span><span class="s1">body,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.EnumDeclaration;</span><span class="s3">\n  </span><span class="s1">validate(defs.id, node, </span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">, id, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.body, node, </span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">, body, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function enumBooleanBody(</span><span class="s3">\n  </span><span class="s1">members: Array&lt;t.EnumBooleanMember&gt;,</span><span class="s3">\n</span><span class="s1">): t.EnumBooleanBody {</span><span class="s3">\n  </span><span class="s1">const node: t.EnumBooleanBody = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">EnumBooleanBody</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">members,</span><span class="s3">\n    </span><span class="s1">explicitType: null,</span><span class="s3">\n    </span><span class="s1">hasUnknownMembers: null,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.EnumBooleanBody;</span><span class="s3">\n  </span><span class="s1">validate(defs.members, node, </span><span class="s3">\&quot;</span><span class="s1">members</span><span class="s3">\&quot;</span><span class="s1">, members, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function enumNumberBody(</span><span class="s3">\n  </span><span class="s1">members: Array&lt;t.EnumNumberMember&gt;,</span><span class="s3">\n</span><span class="s1">): t.EnumNumberBody {</span><span class="s3">\n  </span><span class="s1">const node: t.EnumNumberBody = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">EnumNumberBody</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">members,</span><span class="s3">\n    </span><span class="s1">explicitType: null,</span><span class="s3">\n    </span><span class="s1">hasUnknownMembers: null,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.EnumNumberBody;</span><span class="s3">\n  </span><span class="s1">validate(defs.members, node, </span><span class="s3">\&quot;</span><span class="s1">members</span><span class="s3">\&quot;</span><span class="s1">, members, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function enumStringBody(</span><span class="s3">\n  </span><span class="s1">members: Array&lt;t.EnumStringMember | t.EnumDefaultedMember&gt;,</span><span class="s3">\n</span><span class="s1">): t.EnumStringBody {</span><span class="s3">\n  </span><span class="s1">const node: t.EnumStringBody = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">EnumStringBody</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">members,</span><span class="s3">\n    </span><span class="s1">explicitType: null,</span><span class="s3">\n    </span><span class="s1">hasUnknownMembers: null,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.EnumStringBody;</span><span class="s3">\n  </span><span class="s1">validate(defs.members, node, </span><span class="s3">\&quot;</span><span class="s1">members</span><span class="s3">\&quot;</span><span class="s1">, members, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function enumSymbolBody(</span><span class="s3">\n  </span><span class="s1">members: Array&lt;t.EnumDefaultedMember&gt;,</span><span class="s3">\n</span><span class="s1">): t.EnumSymbolBody {</span><span class="s3">\n  </span><span class="s1">const node: t.EnumSymbolBody = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">EnumSymbolBody</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">members,</span><span class="s3">\n    </span><span class="s1">hasUnknownMembers: null,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.EnumSymbolBody;</span><span class="s3">\n  </span><span class="s1">validate(defs.members, node, </span><span class="s3">\&quot;</span><span class="s1">members</span><span class="s3">\&quot;</span><span class="s1">, members, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function enumBooleanMember(id: t.Identifier): t.EnumBooleanMember {</span><span class="s3">\n  </span><span class="s1">const node: t.EnumBooleanMember = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">EnumBooleanMember</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">id,</span><span class="s3">\n    </span><span class="s1">init: null,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.EnumBooleanMember;</span><span class="s3">\n  </span><span class="s1">validate(defs.id, node, </span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">, id, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function enumNumberMember(</span><span class="s3">\n  </span><span class="s1">id: t.Identifier,</span><span class="s3">\n  </span><span class="s1">init: t.NumericLiteral,</span><span class="s3">\n</span><span class="s1">): t.EnumNumberMember {</span><span class="s3">\n  </span><span class="s1">const node: t.EnumNumberMember = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">EnumNumberMember</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">id,</span><span class="s3">\n    </span><span class="s1">init,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.EnumNumberMember;</span><span class="s3">\n  </span><span class="s1">validate(defs.id, node, </span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">, id, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.init, node, </span><span class="s3">\&quot;</span><span class="s1">init</span><span class="s3">\&quot;</span><span class="s1">, init, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function enumStringMember(</span><span class="s3">\n  </span><span class="s1">id: t.Identifier,</span><span class="s3">\n  </span><span class="s1">init: t.StringLiteral,</span><span class="s3">\n</span><span class="s1">): t.EnumStringMember {</span><span class="s3">\n  </span><span class="s1">const node: t.EnumStringMember = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">EnumStringMember</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">id,</span><span class="s3">\n    </span><span class="s1">init,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.EnumStringMember;</span><span class="s3">\n  </span><span class="s1">validate(defs.id, node, </span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">, id, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.init, node, </span><span class="s3">\&quot;</span><span class="s1">init</span><span class="s3">\&quot;</span><span class="s1">, init, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function enumDefaultedMember(id: t.Identifier): t.EnumDefaultedMember {</span><span class="s3">\n  </span><span class="s1">const node: t.EnumDefaultedMember = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">EnumDefaultedMember</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">id,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.EnumDefaultedMember;</span><span class="s3">\n  </span><span class="s1">validate(defs.id, node, </span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">, id, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function indexedAccessType(</span><span class="s3">\n  </span><span class="s1">objectType: t.FlowType,</span><span class="s3">\n  </span><span class="s1">indexType: t.FlowType,</span><span class="s3">\n</span><span class="s1">): t.IndexedAccessType {</span><span class="s3">\n  </span><span class="s1">const node: t.IndexedAccessType = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">IndexedAccessType</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">objectType,</span><span class="s3">\n    </span><span class="s1">indexType,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.IndexedAccessType;</span><span class="s3">\n  </span><span class="s1">validate(defs.objectType, node, </span><span class="s3">\&quot;</span><span class="s1">objectType</span><span class="s3">\&quot;</span><span class="s1">, objectType, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.indexType, node, </span><span class="s3">\&quot;</span><span class="s1">indexType</span><span class="s3">\&quot;</span><span class="s1">, indexType, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function optionalIndexedAccessType(</span><span class="s3">\n  </span><span class="s1">objectType: t.FlowType,</span><span class="s3">\n  </span><span class="s1">indexType: t.FlowType,</span><span class="s3">\n</span><span class="s1">): t.OptionalIndexedAccessType {</span><span class="s3">\n  </span><span class="s1">const node: t.OptionalIndexedAccessType = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">OptionalIndexedAccessType</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">objectType,</span><span class="s3">\n    </span><span class="s1">indexType,</span><span class="s3">\n    </span><span class="s1">optional: null,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.OptionalIndexedAccessType;</span><span class="s3">\n  </span><span class="s1">validate(defs.objectType, node, </span><span class="s3">\&quot;</span><span class="s1">objectType</span><span class="s3">\&quot;</span><span class="s1">, objectType, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.indexType, node, </span><span class="s3">\&quot;</span><span class="s1">indexType</span><span class="s3">\&quot;</span><span class="s1">, indexType, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function jsxAttribute(</span><span class="s3">\n  </span><span class="s1">name: t.JSXIdentifier | t.JSXNamespacedName,</span><span class="s3">\n  </span><span class="s1">value:</span><span class="s3">\n    </span><span class="s1">| t.JSXElement</span><span class="s3">\n    </span><span class="s1">| t.JSXFragment</span><span class="s3">\n    </span><span class="s1">| t.StringLiteral</span><span class="s3">\n    </span><span class="s1">| t.JSXExpressionContainer</span><span class="s3">\n    </span><span class="s1">| null = null,</span><span class="s3">\n</span><span class="s1">): t.JSXAttribute {</span><span class="s3">\n  </span><span class="s1">const node: t.JSXAttribute = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">JSXAttribute</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">name,</span><span class="s3">\n    </span><span class="s1">value,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.JSXAttribute;</span><span class="s3">\n  </span><span class="s1">validate(defs.name, node, </span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">, name, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.value, node, </span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">, value, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { jsxAttribute as jSXAttribute };</span><span class="s3">\n</span><span class="s1">export function jsxClosingElement(</span><span class="s3">\n  </span><span class="s1">name: t.JSXIdentifier | t.JSXMemberExpression | t.JSXNamespacedName,</span><span class="s3">\n</span><span class="s1">): t.JSXClosingElement {</span><span class="s3">\n  </span><span class="s1">const node: t.JSXClosingElement = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">JSXClosingElement</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">name,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.JSXClosingElement;</span><span class="s3">\n  </span><span class="s1">validate(defs.name, node, </span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">, name, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { jsxClosingElement as jSXClosingElement };</span><span class="s3">\n</span><span class="s1">export function jsxElement(</span><span class="s3">\n  </span><span class="s1">openingElement: t.JSXOpeningElement,</span><span class="s3">\n  </span><span class="s1">closingElement: t.JSXClosingElement | null | undefined = null,</span><span class="s3">\n  </span><span class="s1">children: Array&lt;</span><span class="s3">\n    </span><span class="s1">| t.JSXText</span><span class="s3">\n    </span><span class="s1">| t.JSXExpressionContainer</span><span class="s3">\n    </span><span class="s1">| t.JSXSpreadChild</span><span class="s3">\n    </span><span class="s1">| t.JSXElement</span><span class="s3">\n    </span><span class="s1">| t.JSXFragment</span><span class="s3">\n  </span><span class="s1">&gt;,</span><span class="s3">\n  </span><span class="s1">selfClosing: boolean | null = null,</span><span class="s3">\n</span><span class="s1">): t.JSXElement {</span><span class="s3">\n  </span><span class="s1">const node: t.JSXElement = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">JSXElement</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">openingElement,</span><span class="s3">\n    </span><span class="s1">closingElement,</span><span class="s3">\n    </span><span class="s1">children,</span><span class="s3">\n    </span><span class="s1">selfClosing,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.JSXElement;</span><span class="s3">\n  </span><span class="s1">validate(defs.openingElement, node, </span><span class="s3">\&quot;</span><span class="s1">openingElement</span><span class="s3">\&quot;</span><span class="s1">, openingElement, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.closingElement, node, </span><span class="s3">\&quot;</span><span class="s1">closingElement</span><span class="s3">\&quot;</span><span class="s1">, closingElement, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.children, node, </span><span class="s3">\&quot;</span><span class="s1">children</span><span class="s3">\&quot;</span><span class="s1">, children, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.selfClosing, node, </span><span class="s3">\&quot;</span><span class="s1">selfClosing</span><span class="s3">\&quot;</span><span class="s1">, selfClosing);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { jsxElement as jSXElement };</span><span class="s3">\n</span><span class="s1">export function jsxEmptyExpression(): t.JSXEmptyExpression {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">JSXEmptyExpression</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { jsxEmptyExpression as jSXEmptyExpression };</span><span class="s3">\n</span><span class="s1">export function jsxExpressionContainer(</span><span class="s3">\n  </span><span class="s1">expression: t.Expression | t.JSXEmptyExpression,</span><span class="s3">\n</span><span class="s1">): t.JSXExpressionContainer {</span><span class="s3">\n  </span><span class="s1">const node: t.JSXExpressionContainer = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">JSXExpressionContainer</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">expression,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.JSXExpressionContainer;</span><span class="s3">\n  </span><span class="s1">validate(defs.expression, node, </span><span class="s3">\&quot;</span><span class="s1">expression</span><span class="s3">\&quot;</span><span class="s1">, expression, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { jsxExpressionContainer as jSXExpressionContainer };</span><span class="s3">\n</span><span class="s1">export function jsxSpreadChild(expression: t.Expression): t.JSXSpreadChild {</span><span class="s3">\n  </span><span class="s1">const node: t.JSXSpreadChild = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">JSXSpreadChild</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">expression,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.JSXSpreadChild;</span><span class="s3">\n  </span><span class="s1">validate(defs.expression, node, </span><span class="s3">\&quot;</span><span class="s1">expression</span><span class="s3">\&quot;</span><span class="s1">, expression, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { jsxSpreadChild as jSXSpreadChild };</span><span class="s3">\n</span><span class="s1">export function jsxIdentifier(name: string): t.JSXIdentifier {</span><span class="s3">\n  </span><span class="s1">const node: t.JSXIdentifier = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">JSXIdentifier</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">name,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.JSXIdentifier;</span><span class="s3">\n  </span><span class="s1">validate(defs.name, node, </span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">, name);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { jsxIdentifier as jSXIdentifier };</span><span class="s3">\n</span><span class="s1">export function jsxMemberExpression(</span><span class="s3">\n  </span><span class="s1">object: t.JSXMemberExpression | t.JSXIdentifier,</span><span class="s3">\n  </span><span class="s1">property: t.JSXIdentifier,</span><span class="s3">\n</span><span class="s1">): t.JSXMemberExpression {</span><span class="s3">\n  </span><span class="s1">const node: t.JSXMemberExpression = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">JSXMemberExpression</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">object,</span><span class="s3">\n    </span><span class="s1">property,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.JSXMemberExpression;</span><span class="s3">\n  </span><span class="s1">validate(defs.object, node, </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">, object, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.property, node, </span><span class="s3">\&quot;</span><span class="s1">property</span><span class="s3">\&quot;</span><span class="s1">, property, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { jsxMemberExpression as jSXMemberExpression };</span><span class="s3">\n</span><span class="s1">export function jsxNamespacedName(</span><span class="s3">\n  </span><span class="s1">namespace: t.JSXIdentifier,</span><span class="s3">\n  </span><span class="s1">name: t.JSXIdentifier,</span><span class="s3">\n</span><span class="s1">): t.JSXNamespacedName {</span><span class="s3">\n  </span><span class="s1">const node: t.JSXNamespacedName = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">JSXNamespacedName</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">namespace,</span><span class="s3">\n    </span><span class="s1">name,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.JSXNamespacedName;</span><span class="s3">\n  </span><span class="s1">validate(defs.namespace, node, </span><span class="s3">\&quot;</span><span class="s1">namespace</span><span class="s3">\&quot;</span><span class="s1">, namespace, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.name, node, </span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">, name, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { jsxNamespacedName as jSXNamespacedName };</span><span class="s3">\n</span><span class="s1">export function jsxOpeningElement(</span><span class="s3">\n  </span><span class="s1">name: t.JSXIdentifier | t.JSXMemberExpression | t.JSXNamespacedName,</span><span class="s3">\n  </span><span class="s1">attributes: Array&lt;t.JSXAttribute | t.JSXSpreadAttribute&gt;,</span><span class="s3">\n  </span><span class="s1">selfClosing: boolean = false,</span><span class="s3">\n</span><span class="s1">): t.JSXOpeningElement {</span><span class="s3">\n  </span><span class="s1">const node: t.JSXOpeningElement = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">JSXOpeningElement</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">name,</span><span class="s3">\n    </span><span class="s1">attributes,</span><span class="s3">\n    </span><span class="s1">selfClosing,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.JSXOpeningElement;</span><span class="s3">\n  </span><span class="s1">validate(defs.name, node, </span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">, name, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.attributes, node, </span><span class="s3">\&quot;</span><span class="s1">attributes</span><span class="s3">\&quot;</span><span class="s1">, attributes, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.selfClosing, node, </span><span class="s3">\&quot;</span><span class="s1">selfClosing</span><span class="s3">\&quot;</span><span class="s1">, selfClosing);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { jsxOpeningElement as jSXOpeningElement };</span><span class="s3">\n</span><span class="s1">export function jsxSpreadAttribute(</span><span class="s3">\n  </span><span class="s1">argument: t.Expression,</span><span class="s3">\n</span><span class="s1">): t.JSXSpreadAttribute {</span><span class="s3">\n  </span><span class="s1">const node: t.JSXSpreadAttribute = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">JSXSpreadAttribute</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">argument,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.JSXSpreadAttribute;</span><span class="s3">\n  </span><span class="s1">validate(defs.argument, node, </span><span class="s3">\&quot;</span><span class="s1">argument</span><span class="s3">\&quot;</span><span class="s1">, argument, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { jsxSpreadAttribute as jSXSpreadAttribute };</span><span class="s3">\n</span><span class="s1">export function jsxText(value: string): t.JSXText {</span><span class="s3">\n  </span><span class="s1">const node: t.JSXText = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">JSXText</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.JSXText;</span><span class="s3">\n  </span><span class="s1">validate(defs.value, node, </span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">, value);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { jsxText as jSXText };</span><span class="s3">\n</span><span class="s1">export function jsxFragment(</span><span class="s3">\n  </span><span class="s1">openingFragment: t.JSXOpeningFragment,</span><span class="s3">\n  </span><span class="s1">closingFragment: t.JSXClosingFragment,</span><span class="s3">\n  </span><span class="s1">children: Array&lt;</span><span class="s3">\n    </span><span class="s1">| t.JSXText</span><span class="s3">\n    </span><span class="s1">| t.JSXExpressionContainer</span><span class="s3">\n    </span><span class="s1">| t.JSXSpreadChild</span><span class="s3">\n    </span><span class="s1">| t.JSXElement</span><span class="s3">\n    </span><span class="s1">| t.JSXFragment</span><span class="s3">\n  </span><span class="s1">&gt;,</span><span class="s3">\n</span><span class="s1">): t.JSXFragment {</span><span class="s3">\n  </span><span class="s1">const node: t.JSXFragment = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">JSXFragment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">openingFragment,</span><span class="s3">\n    </span><span class="s1">closingFragment,</span><span class="s3">\n    </span><span class="s1">children,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.JSXFragment;</span><span class="s3">\n  </span><span class="s1">validate(defs.openingFragment, node, </span><span class="s3">\&quot;</span><span class="s1">openingFragment</span><span class="s3">\&quot;</span><span class="s1">, openingFragment, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.closingFragment, node, </span><span class="s3">\&quot;</span><span class="s1">closingFragment</span><span class="s3">\&quot;</span><span class="s1">, closingFragment, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.children, node, </span><span class="s3">\&quot;</span><span class="s1">children</span><span class="s3">\&quot;</span><span class="s1">, children, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { jsxFragment as jSXFragment };</span><span class="s3">\n</span><span class="s1">export function jsxOpeningFragment(): t.JSXOpeningFragment {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">JSXOpeningFragment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { jsxOpeningFragment as jSXOpeningFragment };</span><span class="s3">\n</span><span class="s1">export function jsxClosingFragment(): t.JSXClosingFragment {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">JSXClosingFragment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { jsxClosingFragment as jSXClosingFragment };</span><span class="s3">\n</span><span class="s1">export function noop(): t.Noop {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">Noop</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function placeholder(</span><span class="s3">\n  </span><span class="s1">expectedNode:</span><span class="s3">\n    </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">Identifier</span><span class="s3">\&quot;\n    </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">StringLiteral</span><span class="s3">\&quot;\n    </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">Expression</span><span class="s3">\&quot;\n    </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">Statement</span><span class="s3">\&quot;\n    </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">Declaration</span><span class="s3">\&quot;\n    </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">BlockStatement</span><span class="s3">\&quot;\n    </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">ClassBody</span><span class="s3">\&quot;\n    </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">Pattern</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">name: t.Identifier,</span><span class="s3">\n</span><span class="s1">): t.Placeholder {</span><span class="s3">\n  </span><span class="s1">const node: t.Placeholder = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">Placeholder</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">expectedNode,</span><span class="s3">\n    </span><span class="s1">name,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.Placeholder;</span><span class="s3">\n  </span><span class="s1">validate(defs.expectedNode, node, </span><span class="s3">\&quot;</span><span class="s1">expectedNode</span><span class="s3">\&quot;</span><span class="s1">, expectedNode);</span><span class="s3">\n  </span><span class="s1">validate(defs.name, node, </span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">, name, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function v8IntrinsicIdentifier(name: string): t.V8IntrinsicIdentifier {</span><span class="s3">\n  </span><span class="s1">const node: t.V8IntrinsicIdentifier = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">V8IntrinsicIdentifier</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">name,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.V8IntrinsicIdentifier;</span><span class="s3">\n  </span><span class="s1">validate(defs.name, node, </span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">, name);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function argumentPlaceholder(): t.ArgumentPlaceholder {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">ArgumentPlaceholder</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function bindExpression(</span><span class="s3">\n  </span><span class="s1">object: t.Expression,</span><span class="s3">\n  </span><span class="s1">callee: t.Expression,</span><span class="s3">\n</span><span class="s1">): t.BindExpression {</span><span class="s3">\n  </span><span class="s1">const node: t.BindExpression = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">BindExpression</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">object,</span><span class="s3">\n    </span><span class="s1">callee,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.BindExpression;</span><span class="s3">\n  </span><span class="s1">validate(defs.object, node, </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">, object, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.callee, node, </span><span class="s3">\&quot;</span><span class="s1">callee</span><span class="s3">\&quot;</span><span class="s1">, callee, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function decorator(expression: t.Expression): t.Decorator {</span><span class="s3">\n  </span><span class="s1">const node: t.Decorator = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">Decorator</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">expression,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.Decorator;</span><span class="s3">\n  </span><span class="s1">validate(defs.expression, node, </span><span class="s3">\&quot;</span><span class="s1">expression</span><span class="s3">\&quot;</span><span class="s1">, expression, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function doExpression(</span><span class="s3">\n  </span><span class="s1">body: t.BlockStatement,</span><span class="s3">\n  </span><span class="s1">async: boolean = false,</span><span class="s3">\n</span><span class="s1">): t.DoExpression {</span><span class="s3">\n  </span><span class="s1">const node: t.DoExpression = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">DoExpression</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">body,</span><span class="s3">\n    </span><span class="s1">async,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.DoExpression;</span><span class="s3">\n  </span><span class="s1">validate(defs.body, node, </span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">, body, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.async, node, </span><span class="s3">\&quot;</span><span class="s1">async</span><span class="s3">\&quot;</span><span class="s1">, async);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function exportDefaultSpecifier(</span><span class="s3">\n  </span><span class="s1">exported: t.Identifier,</span><span class="s3">\n</span><span class="s1">): t.ExportDefaultSpecifier {</span><span class="s3">\n  </span><span class="s1">const node: t.ExportDefaultSpecifier = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">ExportDefaultSpecifier</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">exported,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.ExportDefaultSpecifier;</span><span class="s3">\n  </span><span class="s1">validate(defs.exported, node, </span><span class="s3">\&quot;</span><span class="s1">exported</span><span class="s3">\&quot;</span><span class="s1">, exported, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function recordExpression(</span><span class="s3">\n  </span><span class="s1">properties: Array&lt;t.ObjectProperty | t.SpreadElement&gt;,</span><span class="s3">\n</span><span class="s1">): t.RecordExpression {</span><span class="s3">\n  </span><span class="s1">const node: t.RecordExpression = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">RecordExpression</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">properties,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.RecordExpression;</span><span class="s3">\n  </span><span class="s1">validate(defs.properties, node, </span><span class="s3">\&quot;</span><span class="s1">properties</span><span class="s3">\&quot;</span><span class="s1">, properties, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function tupleExpression(</span><span class="s3">\n  </span><span class="s1">elements: Array&lt;t.Expression | t.SpreadElement&gt; = [],</span><span class="s3">\n</span><span class="s1">): t.TupleExpression {</span><span class="s3">\n  </span><span class="s1">const node: t.TupleExpression = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TupleExpression</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">elements,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.TupleExpression;</span><span class="s3">\n  </span><span class="s1">validate(defs.elements, node, </span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">, elements, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function decimalLiteral(value: string): t.DecimalLiteral {</span><span class="s3">\n  </span><span class="s1">const node: t.DecimalLiteral = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">DecimalLiteral</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.DecimalLiteral;</span><span class="s3">\n  </span><span class="s1">validate(defs.value, node, </span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">, value);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function moduleExpression(body: t.Program): t.ModuleExpression {</span><span class="s3">\n  </span><span class="s1">const node: t.ModuleExpression = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">ModuleExpression</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">body,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.ModuleExpression;</span><span class="s3">\n  </span><span class="s1">validate(defs.body, node, </span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">, body, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function topicReference(): t.TopicReference {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TopicReference</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function pipelineTopicExpression(</span><span class="s3">\n  </span><span class="s1">expression: t.Expression,</span><span class="s3">\n</span><span class="s1">): t.PipelineTopicExpression {</span><span class="s3">\n  </span><span class="s1">const node: t.PipelineTopicExpression = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">PipelineTopicExpression</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">expression,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.PipelineTopicExpression;</span><span class="s3">\n  </span><span class="s1">validate(defs.expression, node, </span><span class="s3">\&quot;</span><span class="s1">expression</span><span class="s3">\&quot;</span><span class="s1">, expression, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function pipelineBareFunction(</span><span class="s3">\n  </span><span class="s1">callee: t.Expression,</span><span class="s3">\n</span><span class="s1">): t.PipelineBareFunction {</span><span class="s3">\n  </span><span class="s1">const node: t.PipelineBareFunction = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">PipelineBareFunction</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">callee,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.PipelineBareFunction;</span><span class="s3">\n  </span><span class="s1">validate(defs.callee, node, </span><span class="s3">\&quot;</span><span class="s1">callee</span><span class="s3">\&quot;</span><span class="s1">, callee, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function pipelinePrimaryTopicReference(): t.PipelinePrimaryTopicReference {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">PipelinePrimaryTopicReference</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function tsParameterProperty(</span><span class="s3">\n  </span><span class="s1">parameter: t.Identifier | t.AssignmentPattern,</span><span class="s3">\n</span><span class="s1">): t.TSParameterProperty {</span><span class="s3">\n  </span><span class="s1">const node: t.TSParameterProperty = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TSParameterProperty</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">parameter,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.TSParameterProperty;</span><span class="s3">\n  </span><span class="s1">validate(defs.parameter, node, </span><span class="s3">\&quot;</span><span class="s1">parameter</span><span class="s3">\&quot;</span><span class="s1">, parameter, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { tsParameterProperty as tSParameterProperty };</span><span class="s3">\n</span><span class="s1">export function tsDeclareFunction(</span><span class="s3">\n  </span><span class="s1">id: t.Identifier | null | undefined = null,</span><span class="s3">\n  </span><span class="s1">typeParameters:</span><span class="s3">\n    </span><span class="s1">| t.TSTypeParameterDeclaration</span><span class="s3">\n    </span><span class="s1">| t.Noop</span><span class="s3">\n    </span><span class="s1">| null</span><span class="s3">\n    </span><span class="s1">| undefined = null,</span><span class="s3">\n  </span><span class="s1">params: Array&lt;t.Identifier | t.Pattern | t.RestElement&gt;,</span><span class="s3">\n  </span><span class="s1">returnType: t.TSTypeAnnotation | t.Noop | null = null,</span><span class="s3">\n</span><span class="s1">): t.TSDeclareFunction {</span><span class="s3">\n  </span><span class="s1">const node: t.TSDeclareFunction = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TSDeclareFunction</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">id,</span><span class="s3">\n    </span><span class="s1">typeParameters,</span><span class="s3">\n    </span><span class="s1">params,</span><span class="s3">\n    </span><span class="s1">returnType,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.TSDeclareFunction;</span><span class="s3">\n  </span><span class="s1">validate(defs.id, node, </span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">, id, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.typeParameters, node, </span><span class="s3">\&quot;</span><span class="s1">typeParameters</span><span class="s3">\&quot;</span><span class="s1">, typeParameters, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.params, node, </span><span class="s3">\&quot;</span><span class="s1">params</span><span class="s3">\&quot;</span><span class="s1">, params, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.returnType, node, </span><span class="s3">\&quot;</span><span class="s1">returnType</span><span class="s3">\&quot;</span><span class="s1">, returnType, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { tsDeclareFunction as tSDeclareFunction };</span><span class="s3">\n</span><span class="s1">export function tsDeclareMethod(</span><span class="s3">\n  </span><span class="s1">decorators: Array&lt;t.Decorator&gt; | null | undefined = null,</span><span class="s3">\n  </span><span class="s1">key:</span><span class="s3">\n    </span><span class="s1">| t.Identifier</span><span class="s3">\n    </span><span class="s1">| t.StringLiteral</span><span class="s3">\n    </span><span class="s1">| t.NumericLiteral</span><span class="s3">\n    </span><span class="s1">| t.BigIntLiteral</span><span class="s3">\n    </span><span class="s1">| t.Expression,</span><span class="s3">\n  </span><span class="s1">typeParameters:</span><span class="s3">\n    </span><span class="s1">| t.TSTypeParameterDeclaration</span><span class="s3">\n    </span><span class="s1">| t.Noop</span><span class="s3">\n    </span><span class="s1">| null</span><span class="s3">\n    </span><span class="s1">| undefined = null,</span><span class="s3">\n  </span><span class="s1">params: Array&lt;</span><span class="s3">\n    </span><span class="s1">t.Identifier | t.Pattern | t.RestElement | t.TSParameterProperty</span><span class="s3">\n  </span><span class="s1">&gt;,</span><span class="s3">\n  </span><span class="s1">returnType: t.TSTypeAnnotation | t.Noop | null = null,</span><span class="s3">\n</span><span class="s1">): t.TSDeclareMethod {</span><span class="s3">\n  </span><span class="s1">const node: t.TSDeclareMethod = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TSDeclareMethod</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">decorators,</span><span class="s3">\n    </span><span class="s1">key,</span><span class="s3">\n    </span><span class="s1">typeParameters,</span><span class="s3">\n    </span><span class="s1">params,</span><span class="s3">\n    </span><span class="s1">returnType,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.TSDeclareMethod;</span><span class="s3">\n  </span><span class="s1">validate(defs.decorators, node, </span><span class="s3">\&quot;</span><span class="s1">decorators</span><span class="s3">\&quot;</span><span class="s1">, decorators, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.key, node, </span><span class="s3">\&quot;</span><span class="s1">key</span><span class="s3">\&quot;</span><span class="s1">, key, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.typeParameters, node, </span><span class="s3">\&quot;</span><span class="s1">typeParameters</span><span class="s3">\&quot;</span><span class="s1">, typeParameters, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.params, node, </span><span class="s3">\&quot;</span><span class="s1">params</span><span class="s3">\&quot;</span><span class="s1">, params, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.returnType, node, </span><span class="s3">\&quot;</span><span class="s1">returnType</span><span class="s3">\&quot;</span><span class="s1">, returnType, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { tsDeclareMethod as tSDeclareMethod };</span><span class="s3">\n</span><span class="s1">export function tsQualifiedName(</span><span class="s3">\n  </span><span class="s1">left: t.TSEntityName,</span><span class="s3">\n  </span><span class="s1">right: t.Identifier,</span><span class="s3">\n</span><span class="s1">): t.TSQualifiedName {</span><span class="s3">\n  </span><span class="s1">const node: t.TSQualifiedName = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TSQualifiedName</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">left,</span><span class="s3">\n    </span><span class="s1">right,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.TSQualifiedName;</span><span class="s3">\n  </span><span class="s1">validate(defs.left, node, </span><span class="s3">\&quot;</span><span class="s1">left</span><span class="s3">\&quot;</span><span class="s1">, left, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.right, node, </span><span class="s3">\&quot;</span><span class="s1">right</span><span class="s3">\&quot;</span><span class="s1">, right, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { tsQualifiedName as tSQualifiedName };</span><span class="s3">\n</span><span class="s1">export function tsCallSignatureDeclaration(</span><span class="s3">\n  </span><span class="s1">typeParameters: t.TSTypeParameterDeclaration | null | undefined = null,</span><span class="s3">\n  </span><span class="s1">parameters: Array&lt;</span><span class="s3">\n    </span><span class="s1">t.ArrayPattern | t.Identifier | t.ObjectPattern | t.RestElement</span><span class="s3">\n  </span><span class="s1">&gt;,</span><span class="s3">\n  </span><span class="s1">typeAnnotation: t.TSTypeAnnotation | null = null,</span><span class="s3">\n</span><span class="s1">): t.TSCallSignatureDeclaration {</span><span class="s3">\n  </span><span class="s1">const node: t.TSCallSignatureDeclaration = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TSCallSignatureDeclaration</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">typeParameters,</span><span class="s3">\n    </span><span class="s1">parameters,</span><span class="s3">\n    </span><span class="s1">typeAnnotation,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.TSCallSignatureDeclaration;</span><span class="s3">\n  </span><span class="s1">validate(defs.typeParameters, node, </span><span class="s3">\&quot;</span><span class="s1">typeParameters</span><span class="s3">\&quot;</span><span class="s1">, typeParameters, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.parameters, node, </span><span class="s3">\&quot;</span><span class="s1">parameters</span><span class="s3">\&quot;</span><span class="s1">, parameters, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.typeAnnotation, node, </span><span class="s3">\&quot;</span><span class="s1">typeAnnotation</span><span class="s3">\&quot;</span><span class="s1">, typeAnnotation, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { tsCallSignatureDeclaration as tSCallSignatureDeclaration };</span><span class="s3">\n</span><span class="s1">export function tsConstructSignatureDeclaration(</span><span class="s3">\n  </span><span class="s1">typeParameters: t.TSTypeParameterDeclaration | null | undefined = null,</span><span class="s3">\n  </span><span class="s1">parameters: Array&lt;</span><span class="s3">\n    </span><span class="s1">t.ArrayPattern | t.Identifier | t.ObjectPattern | t.RestElement</span><span class="s3">\n  </span><span class="s1">&gt;,</span><span class="s3">\n  </span><span class="s1">typeAnnotation: t.TSTypeAnnotation | null = null,</span><span class="s3">\n</span><span class="s1">): t.TSConstructSignatureDeclaration {</span><span class="s3">\n  </span><span class="s1">const node: t.TSConstructSignatureDeclaration = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TSConstructSignatureDeclaration</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">typeParameters,</span><span class="s3">\n    </span><span class="s1">parameters,</span><span class="s3">\n    </span><span class="s1">typeAnnotation,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.TSConstructSignatureDeclaration;</span><span class="s3">\n  </span><span class="s1">validate(defs.typeParameters, node, </span><span class="s3">\&quot;</span><span class="s1">typeParameters</span><span class="s3">\&quot;</span><span class="s1">, typeParameters, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.parameters, node, </span><span class="s3">\&quot;</span><span class="s1">parameters</span><span class="s3">\&quot;</span><span class="s1">, parameters, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.typeAnnotation, node, </span><span class="s3">\&quot;</span><span class="s1">typeAnnotation</span><span class="s3">\&quot;</span><span class="s1">, typeAnnotation, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { tsConstructSignatureDeclaration as tSConstructSignatureDeclaration };</span><span class="s3">\n</span><span class="s1">export function tsPropertySignature(</span><span class="s3">\n  </span><span class="s1">key: t.Expression,</span><span class="s3">\n  </span><span class="s1">typeAnnotation: t.TSTypeAnnotation | null = null,</span><span class="s3">\n</span><span class="s1">): t.TSPropertySignature {</span><span class="s3">\n  </span><span class="s1">const node: t.TSPropertySignature = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TSPropertySignature</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">key,</span><span class="s3">\n    </span><span class="s1">typeAnnotation,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.TSPropertySignature;</span><span class="s3">\n  </span><span class="s1">validate(defs.key, node, </span><span class="s3">\&quot;</span><span class="s1">key</span><span class="s3">\&quot;</span><span class="s1">, key, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.typeAnnotation, node, </span><span class="s3">\&quot;</span><span class="s1">typeAnnotation</span><span class="s3">\&quot;</span><span class="s1">, typeAnnotation, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { tsPropertySignature as tSPropertySignature };</span><span class="s3">\n</span><span class="s1">export function tsMethodSignature(</span><span class="s3">\n  </span><span class="s1">key: t.Expression,</span><span class="s3">\n  </span><span class="s1">typeParameters: t.TSTypeParameterDeclaration | null | undefined = null,</span><span class="s3">\n  </span><span class="s1">parameters: Array&lt;</span><span class="s3">\n    </span><span class="s1">t.ArrayPattern | t.Identifier | t.ObjectPattern | t.RestElement</span><span class="s3">\n  </span><span class="s1">&gt;,</span><span class="s3">\n  </span><span class="s1">typeAnnotation: t.TSTypeAnnotation | null = null,</span><span class="s3">\n</span><span class="s1">): t.TSMethodSignature {</span><span class="s3">\n  </span><span class="s1">const node: t.TSMethodSignature = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TSMethodSignature</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">key,</span><span class="s3">\n    </span><span class="s1">typeParameters,</span><span class="s3">\n    </span><span class="s1">parameters,</span><span class="s3">\n    </span><span class="s1">typeAnnotation,</span><span class="s3">\n    </span><span class="s1">kind: null,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.TSMethodSignature;</span><span class="s3">\n  </span><span class="s1">validate(defs.key, node, </span><span class="s3">\&quot;</span><span class="s1">key</span><span class="s3">\&quot;</span><span class="s1">, key, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.typeParameters, node, </span><span class="s3">\&quot;</span><span class="s1">typeParameters</span><span class="s3">\&quot;</span><span class="s1">, typeParameters, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.parameters, node, </span><span class="s3">\&quot;</span><span class="s1">parameters</span><span class="s3">\&quot;</span><span class="s1">, parameters, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.typeAnnotation, node, </span><span class="s3">\&quot;</span><span class="s1">typeAnnotation</span><span class="s3">\&quot;</span><span class="s1">, typeAnnotation, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { tsMethodSignature as tSMethodSignature };</span><span class="s3">\n</span><span class="s1">export function tsIndexSignature(</span><span class="s3">\n  </span><span class="s1">parameters: Array&lt;t.Identifier&gt;,</span><span class="s3">\n  </span><span class="s1">typeAnnotation: t.TSTypeAnnotation | null = null,</span><span class="s3">\n</span><span class="s1">): t.TSIndexSignature {</span><span class="s3">\n  </span><span class="s1">const node: t.TSIndexSignature = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TSIndexSignature</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">parameters,</span><span class="s3">\n    </span><span class="s1">typeAnnotation,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.TSIndexSignature;</span><span class="s3">\n  </span><span class="s1">validate(defs.parameters, node, </span><span class="s3">\&quot;</span><span class="s1">parameters</span><span class="s3">\&quot;</span><span class="s1">, parameters, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.typeAnnotation, node, </span><span class="s3">\&quot;</span><span class="s1">typeAnnotation</span><span class="s3">\&quot;</span><span class="s1">, typeAnnotation, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { tsIndexSignature as tSIndexSignature };</span><span class="s3">\n</span><span class="s1">export function tsAnyKeyword(): t.TSAnyKeyword {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TSAnyKeyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { tsAnyKeyword as tSAnyKeyword };</span><span class="s3">\n</span><span class="s1">export function tsBooleanKeyword(): t.TSBooleanKeyword {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TSBooleanKeyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { tsBooleanKeyword as tSBooleanKeyword };</span><span class="s3">\n</span><span class="s1">export function tsBigIntKeyword(): t.TSBigIntKeyword {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TSBigIntKeyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { tsBigIntKeyword as tSBigIntKeyword };</span><span class="s3">\n</span><span class="s1">export function tsIntrinsicKeyword(): t.TSIntrinsicKeyword {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TSIntrinsicKeyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { tsIntrinsicKeyword as tSIntrinsicKeyword };</span><span class="s3">\n</span><span class="s1">export function tsNeverKeyword(): t.TSNeverKeyword {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TSNeverKeyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { tsNeverKeyword as tSNeverKeyword };</span><span class="s3">\n</span><span class="s1">export function tsNullKeyword(): t.TSNullKeyword {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TSNullKeyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { tsNullKeyword as tSNullKeyword };</span><span class="s3">\n</span><span class="s1">export function tsNumberKeyword(): t.TSNumberKeyword {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TSNumberKeyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { tsNumberKeyword as tSNumberKeyword };</span><span class="s3">\n</span><span class="s1">export function tsObjectKeyword(): t.TSObjectKeyword {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TSObjectKeyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { tsObjectKeyword as tSObjectKeyword };</span><span class="s3">\n</span><span class="s1">export function tsStringKeyword(): t.TSStringKeyword {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TSStringKeyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { tsStringKeyword as tSStringKeyword };</span><span class="s3">\n</span><span class="s1">export function tsSymbolKeyword(): t.TSSymbolKeyword {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TSSymbolKeyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { tsSymbolKeyword as tSSymbolKeyword };</span><span class="s3">\n</span><span class="s1">export function tsUndefinedKeyword(): t.TSUndefinedKeyword {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TSUndefinedKeyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { tsUndefinedKeyword as tSUndefinedKeyword };</span><span class="s3">\n</span><span class="s1">export function tsUnknownKeyword(): t.TSUnknownKeyword {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TSUnknownKeyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { tsUnknownKeyword as tSUnknownKeyword };</span><span class="s3">\n</span><span class="s1">export function tsVoidKeyword(): t.TSVoidKeyword {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TSVoidKeyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { tsVoidKeyword as tSVoidKeyword };</span><span class="s3">\n</span><span class="s1">export function tsThisType(): t.TSThisType {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TSThisType</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { tsThisType as tSThisType };</span><span class="s3">\n</span><span class="s1">export function tsFunctionType(</span><span class="s3">\n  </span><span class="s1">typeParameters: t.TSTypeParameterDeclaration | null | undefined = null,</span><span class="s3">\n  </span><span class="s1">parameters: Array&lt;</span><span class="s3">\n    </span><span class="s1">t.ArrayPattern | t.Identifier | t.ObjectPattern | t.RestElement</span><span class="s3">\n  </span><span class="s1">&gt;,</span><span class="s3">\n  </span><span class="s1">typeAnnotation: t.TSTypeAnnotation | null = null,</span><span class="s3">\n</span><span class="s1">): t.TSFunctionType {</span><span class="s3">\n  </span><span class="s1">const node: t.TSFunctionType = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TSFunctionType</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">typeParameters,</span><span class="s3">\n    </span><span class="s1">parameters,</span><span class="s3">\n    </span><span class="s1">typeAnnotation,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.TSFunctionType;</span><span class="s3">\n  </span><span class="s1">validate(defs.typeParameters, node, </span><span class="s3">\&quot;</span><span class="s1">typeParameters</span><span class="s3">\&quot;</span><span class="s1">, typeParameters, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.parameters, node, </span><span class="s3">\&quot;</span><span class="s1">parameters</span><span class="s3">\&quot;</span><span class="s1">, parameters, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.typeAnnotation, node, </span><span class="s3">\&quot;</span><span class="s1">typeAnnotation</span><span class="s3">\&quot;</span><span class="s1">, typeAnnotation, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { tsFunctionType as tSFunctionType };</span><span class="s3">\n</span><span class="s1">export function tsConstructorType(</span><span class="s3">\n  </span><span class="s1">typeParameters: t.TSTypeParameterDeclaration | null | undefined = null,</span><span class="s3">\n  </span><span class="s1">parameters: Array&lt;</span><span class="s3">\n    </span><span class="s1">t.ArrayPattern | t.Identifier | t.ObjectPattern | t.RestElement</span><span class="s3">\n  </span><span class="s1">&gt;,</span><span class="s3">\n  </span><span class="s1">typeAnnotation: t.TSTypeAnnotation | null = null,</span><span class="s3">\n</span><span class="s1">): t.TSConstructorType {</span><span class="s3">\n  </span><span class="s1">const node: t.TSConstructorType = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TSConstructorType</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">typeParameters,</span><span class="s3">\n    </span><span class="s1">parameters,</span><span class="s3">\n    </span><span class="s1">typeAnnotation,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.TSConstructorType;</span><span class="s3">\n  </span><span class="s1">validate(defs.typeParameters, node, </span><span class="s3">\&quot;</span><span class="s1">typeParameters</span><span class="s3">\&quot;</span><span class="s1">, typeParameters, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.parameters, node, </span><span class="s3">\&quot;</span><span class="s1">parameters</span><span class="s3">\&quot;</span><span class="s1">, parameters, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.typeAnnotation, node, </span><span class="s3">\&quot;</span><span class="s1">typeAnnotation</span><span class="s3">\&quot;</span><span class="s1">, typeAnnotation, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { tsConstructorType as tSConstructorType };</span><span class="s3">\n</span><span class="s1">export function tsTypeReference(</span><span class="s3">\n  </span><span class="s1">typeName: t.TSEntityName,</span><span class="s3">\n  </span><span class="s1">typeParameters: t.TSTypeParameterInstantiation | null = null,</span><span class="s3">\n</span><span class="s1">): t.TSTypeReference {</span><span class="s3">\n  </span><span class="s1">const node: t.TSTypeReference = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TSTypeReference</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">typeName,</span><span class="s3">\n    </span><span class="s1">typeParameters,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.TSTypeReference;</span><span class="s3">\n  </span><span class="s1">validate(defs.typeName, node, </span><span class="s3">\&quot;</span><span class="s1">typeName</span><span class="s3">\&quot;</span><span class="s1">, typeName, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.typeParameters, node, </span><span class="s3">\&quot;</span><span class="s1">typeParameters</span><span class="s3">\&quot;</span><span class="s1">, typeParameters, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { tsTypeReference as tSTypeReference };</span><span class="s3">\n</span><span class="s1">export function tsTypePredicate(</span><span class="s3">\n  </span><span class="s1">parameterName: t.Identifier | t.TSThisType,</span><span class="s3">\n  </span><span class="s1">typeAnnotation: t.TSTypeAnnotation | null = null,</span><span class="s3">\n  </span><span class="s1">asserts: boolean | null = null,</span><span class="s3">\n</span><span class="s1">): t.TSTypePredicate {</span><span class="s3">\n  </span><span class="s1">const node: t.TSTypePredicate = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TSTypePredicate</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">parameterName,</span><span class="s3">\n    </span><span class="s1">typeAnnotation,</span><span class="s3">\n    </span><span class="s1">asserts,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.TSTypePredicate;</span><span class="s3">\n  </span><span class="s1">validate(defs.parameterName, node, </span><span class="s3">\&quot;</span><span class="s1">parameterName</span><span class="s3">\&quot;</span><span class="s1">, parameterName, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.typeAnnotation, node, </span><span class="s3">\&quot;</span><span class="s1">typeAnnotation</span><span class="s3">\&quot;</span><span class="s1">, typeAnnotation, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.asserts, node, </span><span class="s3">\&quot;</span><span class="s1">asserts</span><span class="s3">\&quot;</span><span class="s1">, asserts);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { tsTypePredicate as tSTypePredicate };</span><span class="s3">\n</span><span class="s1">export function tsTypeQuery(</span><span class="s3">\n  </span><span class="s1">exprName: t.TSEntityName | t.TSImportType,</span><span class="s3">\n  </span><span class="s1">typeParameters: t.TSTypeParameterInstantiation | null = null,</span><span class="s3">\n</span><span class="s1">): t.TSTypeQuery {</span><span class="s3">\n  </span><span class="s1">const node: t.TSTypeQuery = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TSTypeQuery</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">exprName,</span><span class="s3">\n    </span><span class="s1">typeParameters,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.TSTypeQuery;</span><span class="s3">\n  </span><span class="s1">validate(defs.exprName, node, </span><span class="s3">\&quot;</span><span class="s1">exprName</span><span class="s3">\&quot;</span><span class="s1">, exprName, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.typeParameters, node, </span><span class="s3">\&quot;</span><span class="s1">typeParameters</span><span class="s3">\&quot;</span><span class="s1">, typeParameters, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { tsTypeQuery as tSTypeQuery };</span><span class="s3">\n</span><span class="s1">export function tsTypeLiteral(</span><span class="s3">\n  </span><span class="s1">members: Array&lt;t.TSTypeElement&gt;,</span><span class="s3">\n</span><span class="s1">): t.TSTypeLiteral {</span><span class="s3">\n  </span><span class="s1">const node: t.TSTypeLiteral = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TSTypeLiteral</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">members,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.TSTypeLiteral;</span><span class="s3">\n  </span><span class="s1">validate(defs.members, node, </span><span class="s3">\&quot;</span><span class="s1">members</span><span class="s3">\&quot;</span><span class="s1">, members, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { tsTypeLiteral as tSTypeLiteral };</span><span class="s3">\n</span><span class="s1">export function tsArrayType(elementType: t.TSType): t.TSArrayType {</span><span class="s3">\n  </span><span class="s1">const node: t.TSArrayType = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TSArrayType</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">elementType,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.TSArrayType;</span><span class="s3">\n  </span><span class="s1">validate(defs.elementType, node, </span><span class="s3">\&quot;</span><span class="s1">elementType</span><span class="s3">\&quot;</span><span class="s1">, elementType, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { tsArrayType as tSArrayType };</span><span class="s3">\n</span><span class="s1">export function tsTupleType(</span><span class="s3">\n  </span><span class="s1">elementTypes: Array&lt;t.TSType | t.TSNamedTupleMember&gt;,</span><span class="s3">\n</span><span class="s1">): t.TSTupleType {</span><span class="s3">\n  </span><span class="s1">const node: t.TSTupleType = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TSTupleType</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">elementTypes,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.TSTupleType;</span><span class="s3">\n  </span><span class="s1">validate(defs.elementTypes, node, </span><span class="s3">\&quot;</span><span class="s1">elementTypes</span><span class="s3">\&quot;</span><span class="s1">, elementTypes, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { tsTupleType as tSTupleType };</span><span class="s3">\n</span><span class="s1">export function tsOptionalType(typeAnnotation: t.TSType): t.TSOptionalType {</span><span class="s3">\n  </span><span class="s1">const node: t.TSOptionalType = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TSOptionalType</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">typeAnnotation,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.TSOptionalType;</span><span class="s3">\n  </span><span class="s1">validate(defs.typeAnnotation, node, </span><span class="s3">\&quot;</span><span class="s1">typeAnnotation</span><span class="s3">\&quot;</span><span class="s1">, typeAnnotation, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { tsOptionalType as tSOptionalType };</span><span class="s3">\n</span><span class="s1">export function tsRestType(typeAnnotation: t.TSType): t.TSRestType {</span><span class="s3">\n  </span><span class="s1">const node: t.TSRestType = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TSRestType</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">typeAnnotation,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.TSRestType;</span><span class="s3">\n  </span><span class="s1">validate(defs.typeAnnotation, node, </span><span class="s3">\&quot;</span><span class="s1">typeAnnotation</span><span class="s3">\&quot;</span><span class="s1">, typeAnnotation, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { tsRestType as tSRestType };</span><span class="s3">\n</span><span class="s1">export function tsNamedTupleMember(</span><span class="s3">\n  </span><span class="s1">label: t.Identifier,</span><span class="s3">\n  </span><span class="s1">elementType: t.TSType,</span><span class="s3">\n  </span><span class="s1">optional: boolean = false,</span><span class="s3">\n</span><span class="s1">): t.TSNamedTupleMember {</span><span class="s3">\n  </span><span class="s1">const node: t.TSNamedTupleMember = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TSNamedTupleMember</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">label,</span><span class="s3">\n    </span><span class="s1">elementType,</span><span class="s3">\n    </span><span class="s1">optional,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.TSNamedTupleMember;</span><span class="s3">\n  </span><span class="s1">validate(defs.label, node, </span><span class="s3">\&quot;</span><span class="s1">label</span><span class="s3">\&quot;</span><span class="s1">, label, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.elementType, node, </span><span class="s3">\&quot;</span><span class="s1">elementType</span><span class="s3">\&quot;</span><span class="s1">, elementType, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.optional, node, </span><span class="s3">\&quot;</span><span class="s1">optional</span><span class="s3">\&quot;</span><span class="s1">, optional);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { tsNamedTupleMember as tSNamedTupleMember };</span><span class="s3">\n</span><span class="s1">export function tsUnionType(types: Array&lt;t.TSType&gt;): t.TSUnionType {</span><span class="s3">\n  </span><span class="s1">const node: t.TSUnionType = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TSUnionType</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">types,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.TSUnionType;</span><span class="s3">\n  </span><span class="s1">validate(defs.types, node, </span><span class="s3">\&quot;</span><span class="s1">types</span><span class="s3">\&quot;</span><span class="s1">, types, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { tsUnionType as tSUnionType };</span><span class="s3">\n</span><span class="s1">export function tsIntersectionType(</span><span class="s3">\n  </span><span class="s1">types: Array&lt;t.TSType&gt;,</span><span class="s3">\n</span><span class="s1">): t.TSIntersectionType {</span><span class="s3">\n  </span><span class="s1">const node: t.TSIntersectionType = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TSIntersectionType</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">types,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.TSIntersectionType;</span><span class="s3">\n  </span><span class="s1">validate(defs.types, node, </span><span class="s3">\&quot;</span><span class="s1">types</span><span class="s3">\&quot;</span><span class="s1">, types, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { tsIntersectionType as tSIntersectionType };</span><span class="s3">\n</span><span class="s1">export function tsConditionalType(</span><span class="s3">\n  </span><span class="s1">checkType: t.TSType,</span><span class="s3">\n  </span><span class="s1">extendsType: t.TSType,</span><span class="s3">\n  </span><span class="s1">trueType: t.TSType,</span><span class="s3">\n  </span><span class="s1">falseType: t.TSType,</span><span class="s3">\n</span><span class="s1">): t.TSConditionalType {</span><span class="s3">\n  </span><span class="s1">const node: t.TSConditionalType = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TSConditionalType</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">checkType,</span><span class="s3">\n    </span><span class="s1">extendsType,</span><span class="s3">\n    </span><span class="s1">trueType,</span><span class="s3">\n    </span><span class="s1">falseType,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.TSConditionalType;</span><span class="s3">\n  </span><span class="s1">validate(defs.checkType, node, </span><span class="s3">\&quot;</span><span class="s1">checkType</span><span class="s3">\&quot;</span><span class="s1">, checkType, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.extendsType, node, </span><span class="s3">\&quot;</span><span class="s1">extendsType</span><span class="s3">\&quot;</span><span class="s1">, extendsType, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.trueType, node, </span><span class="s3">\&quot;</span><span class="s1">trueType</span><span class="s3">\&quot;</span><span class="s1">, trueType, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.falseType, node, </span><span class="s3">\&quot;</span><span class="s1">falseType</span><span class="s3">\&quot;</span><span class="s1">, falseType, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { tsConditionalType as tSConditionalType };</span><span class="s3">\n</span><span class="s1">export function tsInferType(typeParameter: t.TSTypeParameter): t.TSInferType {</span><span class="s3">\n  </span><span class="s1">const node: t.TSInferType = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TSInferType</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">typeParameter,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.TSInferType;</span><span class="s3">\n  </span><span class="s1">validate(defs.typeParameter, node, </span><span class="s3">\&quot;</span><span class="s1">typeParameter</span><span class="s3">\&quot;</span><span class="s1">, typeParameter, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { tsInferType as tSInferType };</span><span class="s3">\n</span><span class="s1">export function tsParenthesizedType(</span><span class="s3">\n  </span><span class="s1">typeAnnotation: t.TSType,</span><span class="s3">\n</span><span class="s1">): t.TSParenthesizedType {</span><span class="s3">\n  </span><span class="s1">const node: t.TSParenthesizedType = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TSParenthesizedType</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">typeAnnotation,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.TSParenthesizedType;</span><span class="s3">\n  </span><span class="s1">validate(defs.typeAnnotation, node, </span><span class="s3">\&quot;</span><span class="s1">typeAnnotation</span><span class="s3">\&quot;</span><span class="s1">, typeAnnotation, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { tsParenthesizedType as tSParenthesizedType };</span><span class="s3">\n</span><span class="s1">export function tsTypeOperator(typeAnnotation: t.TSType): t.TSTypeOperator {</span><span class="s3">\n  </span><span class="s1">const node: t.TSTypeOperator = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TSTypeOperator</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">typeAnnotation,</span><span class="s3">\n    </span><span class="s1">operator: null,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.TSTypeOperator;</span><span class="s3">\n  </span><span class="s1">validate(defs.typeAnnotation, node, </span><span class="s3">\&quot;</span><span class="s1">typeAnnotation</span><span class="s3">\&quot;</span><span class="s1">, typeAnnotation, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { tsTypeOperator as tSTypeOperator };</span><span class="s3">\n</span><span class="s1">export function tsIndexedAccessType(</span><span class="s3">\n  </span><span class="s1">objectType: t.TSType,</span><span class="s3">\n  </span><span class="s1">indexType: t.TSType,</span><span class="s3">\n</span><span class="s1">): t.TSIndexedAccessType {</span><span class="s3">\n  </span><span class="s1">const node: t.TSIndexedAccessType = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TSIndexedAccessType</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">objectType,</span><span class="s3">\n    </span><span class="s1">indexType,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.TSIndexedAccessType;</span><span class="s3">\n  </span><span class="s1">validate(defs.objectType, node, </span><span class="s3">\&quot;</span><span class="s1">objectType</span><span class="s3">\&quot;</span><span class="s1">, objectType, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.indexType, node, </span><span class="s3">\&quot;</span><span class="s1">indexType</span><span class="s3">\&quot;</span><span class="s1">, indexType, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { tsIndexedAccessType as tSIndexedAccessType };</span><span class="s3">\n</span><span class="s1">export function tsMappedType(</span><span class="s3">\n  </span><span class="s1">typeParameter: t.TSTypeParameter,</span><span class="s3">\n  </span><span class="s1">typeAnnotation: t.TSType | null = null,</span><span class="s3">\n  </span><span class="s1">nameType: t.TSType | null = null,</span><span class="s3">\n</span><span class="s1">): t.TSMappedType {</span><span class="s3">\n  </span><span class="s1">const node: t.TSMappedType = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TSMappedType</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">typeParameter,</span><span class="s3">\n    </span><span class="s1">typeAnnotation,</span><span class="s3">\n    </span><span class="s1">nameType,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.TSMappedType;</span><span class="s3">\n  </span><span class="s1">validate(defs.typeParameter, node, </span><span class="s3">\&quot;</span><span class="s1">typeParameter</span><span class="s3">\&quot;</span><span class="s1">, typeParameter, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.typeAnnotation, node, </span><span class="s3">\&quot;</span><span class="s1">typeAnnotation</span><span class="s3">\&quot;</span><span class="s1">, typeAnnotation, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.nameType, node, </span><span class="s3">\&quot;</span><span class="s1">nameType</span><span class="s3">\&quot;</span><span class="s1">, nameType, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { tsMappedType as tSMappedType };</span><span class="s3">\n</span><span class="s1">export function tsTemplateLiteralType(</span><span class="s3">\n  </span><span class="s1">quasis: Array&lt;t.TemplateElement&gt;,</span><span class="s3">\n  </span><span class="s1">types: Array&lt;t.TSType&gt;,</span><span class="s3">\n</span><span class="s1">): t.TSTemplateLiteralType {</span><span class="s3">\n  </span><span class="s1">const node: t.TSTemplateLiteralType = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TSTemplateLiteralType</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">quasis,</span><span class="s3">\n    </span><span class="s1">types,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.TSTemplateLiteralType;</span><span class="s3">\n  </span><span class="s1">validate(defs.quasis, node, </span><span class="s3">\&quot;</span><span class="s1">quasis</span><span class="s3">\&quot;</span><span class="s1">, quasis, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.types, node, </span><span class="s3">\&quot;</span><span class="s1">types</span><span class="s3">\&quot;</span><span class="s1">, types, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { tsTemplateLiteralType as tSTemplateLiteralType };</span><span class="s3">\n</span><span class="s1">export function tsLiteralType(</span><span class="s3">\n  </span><span class="s1">literal:</span><span class="s3">\n    </span><span class="s1">| t.NumericLiteral</span><span class="s3">\n    </span><span class="s1">| t.StringLiteral</span><span class="s3">\n    </span><span class="s1">| t.BooleanLiteral</span><span class="s3">\n    </span><span class="s1">| t.BigIntLiteral</span><span class="s3">\n    </span><span class="s1">| t.TemplateLiteral</span><span class="s3">\n    </span><span class="s1">| t.UnaryExpression,</span><span class="s3">\n</span><span class="s1">): t.TSLiteralType {</span><span class="s3">\n  </span><span class="s1">const node: t.TSLiteralType = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TSLiteralType</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">literal,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.TSLiteralType;</span><span class="s3">\n  </span><span class="s1">validate(defs.literal, node, </span><span class="s3">\&quot;</span><span class="s1">literal</span><span class="s3">\&quot;</span><span class="s1">, literal, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { tsLiteralType as tSLiteralType };</span><span class="s3">\n</span><span class="s1">export function tsExpressionWithTypeArguments(</span><span class="s3">\n  </span><span class="s1">expression: t.TSEntityName,</span><span class="s3">\n  </span><span class="s1">typeParameters: t.TSTypeParameterInstantiation | null = null,</span><span class="s3">\n</span><span class="s1">): t.TSExpressionWithTypeArguments {</span><span class="s3">\n  </span><span class="s1">const node: t.TSExpressionWithTypeArguments = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TSExpressionWithTypeArguments</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">expression,</span><span class="s3">\n    </span><span class="s1">typeParameters,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.TSExpressionWithTypeArguments;</span><span class="s3">\n  </span><span class="s1">validate(defs.expression, node, </span><span class="s3">\&quot;</span><span class="s1">expression</span><span class="s3">\&quot;</span><span class="s1">, expression, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.typeParameters, node, </span><span class="s3">\&quot;</span><span class="s1">typeParameters</span><span class="s3">\&quot;</span><span class="s1">, typeParameters, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { tsExpressionWithTypeArguments as tSExpressionWithTypeArguments };</span><span class="s3">\n</span><span class="s1">export function tsInterfaceDeclaration(</span><span class="s3">\n  </span><span class="s1">id: t.Identifier,</span><span class="s3">\n  </span><span class="s1">typeParameters: t.TSTypeParameterDeclaration | null | undefined = null,</span><span class="s3">\n  </span><span class="s1">_extends: Array&lt;t.TSExpressionWithTypeArguments&gt; | null | undefined = null,</span><span class="s3">\n  </span><span class="s1">body: t.TSInterfaceBody,</span><span class="s3">\n</span><span class="s1">): t.TSInterfaceDeclaration {</span><span class="s3">\n  </span><span class="s1">const node: t.TSInterfaceDeclaration = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TSInterfaceDeclaration</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">id,</span><span class="s3">\n    </span><span class="s1">typeParameters,</span><span class="s3">\n    </span><span class="s1">extends: _extends,</span><span class="s3">\n    </span><span class="s1">body,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.TSInterfaceDeclaration;</span><span class="s3">\n  </span><span class="s1">validate(defs.id, node, </span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">, id, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.typeParameters, node, </span><span class="s3">\&quot;</span><span class="s1">typeParameters</span><span class="s3">\&quot;</span><span class="s1">, typeParameters, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.extends, node, </span><span class="s3">\&quot;</span><span class="s1">extends</span><span class="s3">\&quot;</span><span class="s1">, _extends, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.body, node, </span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">, body, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { tsInterfaceDeclaration as tSInterfaceDeclaration };</span><span class="s3">\n</span><span class="s1">export function tsInterfaceBody(</span><span class="s3">\n  </span><span class="s1">body: Array&lt;t.TSTypeElement&gt;,</span><span class="s3">\n</span><span class="s1">): t.TSInterfaceBody {</span><span class="s3">\n  </span><span class="s1">const node: t.TSInterfaceBody = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TSInterfaceBody</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">body,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.TSInterfaceBody;</span><span class="s3">\n  </span><span class="s1">validate(defs.body, node, </span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">, body, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { tsInterfaceBody as tSInterfaceBody };</span><span class="s3">\n</span><span class="s1">export function tsTypeAliasDeclaration(</span><span class="s3">\n  </span><span class="s1">id: t.Identifier,</span><span class="s3">\n  </span><span class="s1">typeParameters: t.TSTypeParameterDeclaration | null | undefined = null,</span><span class="s3">\n  </span><span class="s1">typeAnnotation: t.TSType,</span><span class="s3">\n</span><span class="s1">): t.TSTypeAliasDeclaration {</span><span class="s3">\n  </span><span class="s1">const node: t.TSTypeAliasDeclaration = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TSTypeAliasDeclaration</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">id,</span><span class="s3">\n    </span><span class="s1">typeParameters,</span><span class="s3">\n    </span><span class="s1">typeAnnotation,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.TSTypeAliasDeclaration;</span><span class="s3">\n  </span><span class="s1">validate(defs.id, node, </span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">, id, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.typeParameters, node, </span><span class="s3">\&quot;</span><span class="s1">typeParameters</span><span class="s3">\&quot;</span><span class="s1">, typeParameters, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.typeAnnotation, node, </span><span class="s3">\&quot;</span><span class="s1">typeAnnotation</span><span class="s3">\&quot;</span><span class="s1">, typeAnnotation, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { tsTypeAliasDeclaration as tSTypeAliasDeclaration };</span><span class="s3">\n</span><span class="s1">export function tsInstantiationExpression(</span><span class="s3">\n  </span><span class="s1">expression: t.Expression,</span><span class="s3">\n  </span><span class="s1">typeParameters: t.TSTypeParameterInstantiation | null = null,</span><span class="s3">\n</span><span class="s1">): t.TSInstantiationExpression {</span><span class="s3">\n  </span><span class="s1">const node: t.TSInstantiationExpression = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TSInstantiationExpression</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">expression,</span><span class="s3">\n    </span><span class="s1">typeParameters,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.TSInstantiationExpression;</span><span class="s3">\n  </span><span class="s1">validate(defs.expression, node, </span><span class="s3">\&quot;</span><span class="s1">expression</span><span class="s3">\&quot;</span><span class="s1">, expression, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.typeParameters, node, </span><span class="s3">\&quot;</span><span class="s1">typeParameters</span><span class="s3">\&quot;</span><span class="s1">, typeParameters, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { tsInstantiationExpression as tSInstantiationExpression };</span><span class="s3">\n</span><span class="s1">export function tsAsExpression(</span><span class="s3">\n  </span><span class="s1">expression: t.Expression,</span><span class="s3">\n  </span><span class="s1">typeAnnotation: t.TSType,</span><span class="s3">\n</span><span class="s1">): t.TSAsExpression {</span><span class="s3">\n  </span><span class="s1">const node: t.TSAsExpression = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TSAsExpression</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">expression,</span><span class="s3">\n    </span><span class="s1">typeAnnotation,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.TSAsExpression;</span><span class="s3">\n  </span><span class="s1">validate(defs.expression, node, </span><span class="s3">\&quot;</span><span class="s1">expression</span><span class="s3">\&quot;</span><span class="s1">, expression, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.typeAnnotation, node, </span><span class="s3">\&quot;</span><span class="s1">typeAnnotation</span><span class="s3">\&quot;</span><span class="s1">, typeAnnotation, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { tsAsExpression as tSAsExpression };</span><span class="s3">\n</span><span class="s1">export function tsSatisfiesExpression(</span><span class="s3">\n  </span><span class="s1">expression: t.Expression,</span><span class="s3">\n  </span><span class="s1">typeAnnotation: t.TSType,</span><span class="s3">\n</span><span class="s1">): t.TSSatisfiesExpression {</span><span class="s3">\n  </span><span class="s1">const node: t.TSSatisfiesExpression = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TSSatisfiesExpression</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">expression,</span><span class="s3">\n    </span><span class="s1">typeAnnotation,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.TSSatisfiesExpression;</span><span class="s3">\n  </span><span class="s1">validate(defs.expression, node, </span><span class="s3">\&quot;</span><span class="s1">expression</span><span class="s3">\&quot;</span><span class="s1">, expression, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.typeAnnotation, node, </span><span class="s3">\&quot;</span><span class="s1">typeAnnotation</span><span class="s3">\&quot;</span><span class="s1">, typeAnnotation, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { tsSatisfiesExpression as tSSatisfiesExpression };</span><span class="s3">\n</span><span class="s1">export function tsTypeAssertion(</span><span class="s3">\n  </span><span class="s1">typeAnnotation: t.TSType,</span><span class="s3">\n  </span><span class="s1">expression: t.Expression,</span><span class="s3">\n</span><span class="s1">): t.TSTypeAssertion {</span><span class="s3">\n  </span><span class="s1">const node: t.TSTypeAssertion = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TSTypeAssertion</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">typeAnnotation,</span><span class="s3">\n    </span><span class="s1">expression,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.TSTypeAssertion;</span><span class="s3">\n  </span><span class="s1">validate(defs.typeAnnotation, node, </span><span class="s3">\&quot;</span><span class="s1">typeAnnotation</span><span class="s3">\&quot;</span><span class="s1">, typeAnnotation, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.expression, node, </span><span class="s3">\&quot;</span><span class="s1">expression</span><span class="s3">\&quot;</span><span class="s1">, expression, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { tsTypeAssertion as tSTypeAssertion };</span><span class="s3">\n</span><span class="s1">export function tsEnumBody(members: Array&lt;t.TSEnumMember&gt;): t.TSEnumBody {</span><span class="s3">\n  </span><span class="s1">const node: t.TSEnumBody = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TSEnumBody</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">members,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.TSEnumBody;</span><span class="s3">\n  </span><span class="s1">validate(defs.members, node, </span><span class="s3">\&quot;</span><span class="s1">members</span><span class="s3">\&quot;</span><span class="s1">, members, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { tsEnumBody as tSEnumBody };</span><span class="s3">\n</span><span class="s1">export function tsEnumDeclaration(</span><span class="s3">\n  </span><span class="s1">id: t.Identifier,</span><span class="s3">\n  </span><span class="s1">members: Array&lt;t.TSEnumMember&gt;,</span><span class="s3">\n</span><span class="s1">): t.TSEnumDeclaration {</span><span class="s3">\n  </span><span class="s1">const node: t.TSEnumDeclaration = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TSEnumDeclaration</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">id,</span><span class="s3">\n    </span><span class="s1">members,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.TSEnumDeclaration;</span><span class="s3">\n  </span><span class="s1">validate(defs.id, node, </span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">, id, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.members, node, </span><span class="s3">\&quot;</span><span class="s1">members</span><span class="s3">\&quot;</span><span class="s1">, members, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { tsEnumDeclaration as tSEnumDeclaration };</span><span class="s3">\n</span><span class="s1">export function tsEnumMember(</span><span class="s3">\n  </span><span class="s1">id: t.Identifier | t.StringLiteral,</span><span class="s3">\n  </span><span class="s1">initializer: t.Expression | null = null,</span><span class="s3">\n</span><span class="s1">): t.TSEnumMember {</span><span class="s3">\n  </span><span class="s1">const node: t.TSEnumMember = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TSEnumMember</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">id,</span><span class="s3">\n    </span><span class="s1">initializer,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.TSEnumMember;</span><span class="s3">\n  </span><span class="s1">validate(defs.id, node, </span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">, id, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.initializer, node, </span><span class="s3">\&quot;</span><span class="s1">initializer</span><span class="s3">\&quot;</span><span class="s1">, initializer, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { tsEnumMember as tSEnumMember };</span><span class="s3">\n</span><span class="s1">export function tsModuleDeclaration(</span><span class="s3">\n  </span><span class="s1">id: t.Identifier | t.StringLiteral,</span><span class="s3">\n  </span><span class="s1">body: t.TSModuleBlock | t.TSModuleDeclaration,</span><span class="s3">\n</span><span class="s1">): t.TSModuleDeclaration {</span><span class="s3">\n  </span><span class="s1">const node: t.TSModuleDeclaration = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TSModuleDeclaration</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">id,</span><span class="s3">\n    </span><span class="s1">body,</span><span class="s3">\n    </span><span class="s1">kind: null,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.TSModuleDeclaration;</span><span class="s3">\n  </span><span class="s1">validate(defs.id, node, </span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">, id, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.body, node, </span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">, body, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { tsModuleDeclaration as tSModuleDeclaration };</span><span class="s3">\n</span><span class="s1">export function tsModuleBlock(body: Array&lt;t.Statement&gt;): t.TSModuleBlock {</span><span class="s3">\n  </span><span class="s1">const node: t.TSModuleBlock = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TSModuleBlock</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">body,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.TSModuleBlock;</span><span class="s3">\n  </span><span class="s1">validate(defs.body, node, </span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">, body, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { tsModuleBlock as tSModuleBlock };</span><span class="s3">\n</span><span class="s1">export function tsImportType(</span><span class="s3">\n  </span><span class="s1">argument: t.StringLiteral,</span><span class="s3">\n  </span><span class="s1">qualifier: t.TSEntityName | null = null,</span><span class="s3">\n  </span><span class="s1">typeParameters: t.TSTypeParameterInstantiation | null = null,</span><span class="s3">\n</span><span class="s1">): t.TSImportType {</span><span class="s3">\n  </span><span class="s1">const node: t.TSImportType = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TSImportType</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">argument,</span><span class="s3">\n    </span><span class="s1">qualifier,</span><span class="s3">\n    </span><span class="s1">typeParameters,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.TSImportType;</span><span class="s3">\n  </span><span class="s1">validate(defs.argument, node, </span><span class="s3">\&quot;</span><span class="s1">argument</span><span class="s3">\&quot;</span><span class="s1">, argument, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.qualifier, node, </span><span class="s3">\&quot;</span><span class="s1">qualifier</span><span class="s3">\&quot;</span><span class="s1">, qualifier, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.typeParameters, node, </span><span class="s3">\&quot;</span><span class="s1">typeParameters</span><span class="s3">\&quot;</span><span class="s1">, typeParameters, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { tsImportType as tSImportType };</span><span class="s3">\n</span><span class="s1">export function tsImportEqualsDeclaration(</span><span class="s3">\n  </span><span class="s1">id: t.Identifier,</span><span class="s3">\n  </span><span class="s1">moduleReference: t.TSEntityName | t.TSExternalModuleReference,</span><span class="s3">\n</span><span class="s1">): t.TSImportEqualsDeclaration {</span><span class="s3">\n  </span><span class="s1">const node: t.TSImportEqualsDeclaration = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TSImportEqualsDeclaration</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">id,</span><span class="s3">\n    </span><span class="s1">moduleReference,</span><span class="s3">\n    </span><span class="s1">isExport: null,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.TSImportEqualsDeclaration;</span><span class="s3">\n  </span><span class="s1">validate(defs.id, node, </span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">, id, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.moduleReference, node, </span><span class="s3">\&quot;</span><span class="s1">moduleReference</span><span class="s3">\&quot;</span><span class="s1">, moduleReference, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { tsImportEqualsDeclaration as tSImportEqualsDeclaration };</span><span class="s3">\n</span><span class="s1">export function tsExternalModuleReference(</span><span class="s3">\n  </span><span class="s1">expression: t.StringLiteral,</span><span class="s3">\n</span><span class="s1">): t.TSExternalModuleReference {</span><span class="s3">\n  </span><span class="s1">const node: t.TSExternalModuleReference = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TSExternalModuleReference</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">expression,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.TSExternalModuleReference;</span><span class="s3">\n  </span><span class="s1">validate(defs.expression, node, </span><span class="s3">\&quot;</span><span class="s1">expression</span><span class="s3">\&quot;</span><span class="s1">, expression, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { tsExternalModuleReference as tSExternalModuleReference };</span><span class="s3">\n</span><span class="s1">export function tsNonNullExpression(</span><span class="s3">\n  </span><span class="s1">expression: t.Expression,</span><span class="s3">\n</span><span class="s1">): t.TSNonNullExpression {</span><span class="s3">\n  </span><span class="s1">const node: t.TSNonNullExpression = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TSNonNullExpression</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">expression,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.TSNonNullExpression;</span><span class="s3">\n  </span><span class="s1">validate(defs.expression, node, </span><span class="s3">\&quot;</span><span class="s1">expression</span><span class="s3">\&quot;</span><span class="s1">, expression, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { tsNonNullExpression as tSNonNullExpression };</span><span class="s3">\n</span><span class="s1">export function tsExportAssignment(</span><span class="s3">\n  </span><span class="s1">expression: t.Expression,</span><span class="s3">\n</span><span class="s1">): t.TSExportAssignment {</span><span class="s3">\n  </span><span class="s1">const node: t.TSExportAssignment = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TSExportAssignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">expression,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.TSExportAssignment;</span><span class="s3">\n  </span><span class="s1">validate(defs.expression, node, </span><span class="s3">\&quot;</span><span class="s1">expression</span><span class="s3">\&quot;</span><span class="s1">, expression, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { tsExportAssignment as tSExportAssignment };</span><span class="s3">\n</span><span class="s1">export function tsNamespaceExportDeclaration(</span><span class="s3">\n  </span><span class="s1">id: t.Identifier,</span><span class="s3">\n</span><span class="s1">): t.TSNamespaceExportDeclaration {</span><span class="s3">\n  </span><span class="s1">const node: t.TSNamespaceExportDeclaration = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TSNamespaceExportDeclaration</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">id,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.TSNamespaceExportDeclaration;</span><span class="s3">\n  </span><span class="s1">validate(defs.id, node, </span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">, id, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { tsNamespaceExportDeclaration as tSNamespaceExportDeclaration };</span><span class="s3">\n</span><span class="s1">export function tsTypeAnnotation(typeAnnotation: t.TSType): t.TSTypeAnnotation {</span><span class="s3">\n  </span><span class="s1">const node: t.TSTypeAnnotation = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TSTypeAnnotation</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">typeAnnotation,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.TSTypeAnnotation;</span><span class="s3">\n  </span><span class="s1">validate(defs.typeAnnotation, node, </span><span class="s3">\&quot;</span><span class="s1">typeAnnotation</span><span class="s3">\&quot;</span><span class="s1">, typeAnnotation, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { tsTypeAnnotation as tSTypeAnnotation };</span><span class="s3">\n</span><span class="s1">export function tsTypeParameterInstantiation(</span><span class="s3">\n  </span><span class="s1">params: Array&lt;t.TSType&gt;,</span><span class="s3">\n</span><span class="s1">): t.TSTypeParameterInstantiation {</span><span class="s3">\n  </span><span class="s1">const node: t.TSTypeParameterInstantiation = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TSTypeParameterInstantiation</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">params,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.TSTypeParameterInstantiation;</span><span class="s3">\n  </span><span class="s1">validate(defs.params, node, </span><span class="s3">\&quot;</span><span class="s1">params</span><span class="s3">\&quot;</span><span class="s1">, params, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { tsTypeParameterInstantiation as tSTypeParameterInstantiation };</span><span class="s3">\n</span><span class="s1">export function tsTypeParameterDeclaration(</span><span class="s3">\n  </span><span class="s1">params: Array&lt;t.TSTypeParameter&gt;,</span><span class="s3">\n</span><span class="s1">): t.TSTypeParameterDeclaration {</span><span class="s3">\n  </span><span class="s1">const node: t.TSTypeParameterDeclaration = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TSTypeParameterDeclaration</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">params,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.TSTypeParameterDeclaration;</span><span class="s3">\n  </span><span class="s1">validate(defs.params, node, </span><span class="s3">\&quot;</span><span class="s1">params</span><span class="s3">\&quot;</span><span class="s1">, params, 1);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { tsTypeParameterDeclaration as tSTypeParameterDeclaration };</span><span class="s3">\n</span><span class="s1">export function tsTypeParameter(</span><span class="s3">\n  </span><span class="s1">constraint: t.TSType | null | undefined = null,</span><span class="s3">\n  </span><span class="s1">_default: t.TSType | null | undefined = null,</span><span class="s3">\n  </span><span class="s1">name: string,</span><span class="s3">\n</span><span class="s1">): t.TSTypeParameter {</span><span class="s3">\n  </span><span class="s1">const node: t.TSTypeParameter = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">TSTypeParameter</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">constraint,</span><span class="s3">\n    </span><span class="s1">default: _default,</span><span class="s3">\n    </span><span class="s1">name,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const defs = NODE_FIELDS.TSTypeParameter;</span><span class="s3">\n  </span><span class="s1">validate(defs.constraint, node, </span><span class="s3">\&quot;</span><span class="s1">constraint</span><span class="s3">\&quot;</span><span class="s1">, constraint, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.default, node, </span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot;</span><span class="s1">, _default, 1);</span><span class="s3">\n  </span><span class="s1">validate(defs.name, node, </span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">, name);</span><span class="s3">\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { tsTypeParameter as tSTypeParameter };</span><span class="s3">\n</span><span class="s1">/** @deprecated */</span><span class="s3">\n</span><span class="s1">function NumberLiteral(value: number) {</span><span class="s3">\n  </span><span class="s1">deprecationWarning(</span><span class="s3">\&quot;</span><span class="s1">NumberLiteral</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">NumericLiteral</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">The node type </span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">return numericLiteral(value);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { NumberLiteral as numberLiteral };</span><span class="s3">\n</span><span class="s1">/** @deprecated */</span><span class="s3">\n</span><span class="s1">function RegexLiteral(pattern: string, flags: string = </span><span class="s3">\&quot;\&quot;</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">deprecationWarning(</span><span class="s3">\&quot;</span><span class="s1">RegexLiteral</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">RegExpLiteral</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">The node type </span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">return regExpLiteral(pattern, flags);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { RegexLiteral as regexLiteral };</span><span class="s3">\n</span><span class="s1">/** @deprecated */</span><span class="s3">\n</span><span class="s1">function RestProperty(argument: t.LVal) {</span><span class="s3">\n  </span><span class="s1">deprecationWarning(</span><span class="s3">\&quot;</span><span class="s1">RestProperty</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">RestElement</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">The node type </span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">return restElement(argument);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { RestProperty as restProperty };</span><span class="s3">\n</span><span class="s1">/** @deprecated */</span><span class="s3">\n</span><span class="s1">function SpreadProperty(argument: t.Expression) {</span><span class="s3">\n  </span><span class="s1">deprecationWarning(</span><span class="s3">\&quot;</span><span class="s1">SpreadProperty</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">SpreadElement</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">The node type </span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">return spreadElement(argument);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { SpreadProperty as spreadProperty };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[]}</span></pre>
</body>
</html>