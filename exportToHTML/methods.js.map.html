<html>
<head>
<title>methods.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
methods.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_t&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;_index&quot;</span><span class="s0">,</span><span class="s1">&quot;isIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;_params&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;idNode&quot;</span><span class="s0">,</span><span class="s1">&quot;parentNode&quot;</span><span class="s0">,</span><span class="s1">&quot;print&quot;</span><span class="s0">,</span><span class="s1">&quot;typeParameters&quot;</span><span class="s0">,</span><span class="s1">&quot;nameInfo&quot;</span><span class="s0">,</span><span class="s1">&quot;_getFuncIdName&quot;</span><span class="s0">,</span><span class="s1">&quot;call&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceIdentifierName&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;pos&quot;</span><span class="s0">,</span><span class="s1">&quot;token&quot;</span><span class="s0">,</span><span class="s1">&quot;_parameters&quot;</span><span class="s0">,</span><span class="s1">&quot;params&quot;</span><span class="s0">,</span><span class="s1">&quot;noLineTerminator&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;returnType&quot;</span><span class="s0">,</span><span class="s1">&quot;_noLineTerminator&quot;</span><span class="s0">,</span><span class="s1">&quot;parameters&quot;</span><span class="s0">,</span><span class="s1">&quot;endToken&quot;</span><span class="s0">,</span><span class="s1">&quot;exit&quot;</span><span class="s0">,</span><span class="s1">&quot;enterDelimited&quot;</span><span class="s0">,</span><span class="s1">&quot;trailingComma&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldPrintTrailingComma&quot;</span><span class="s0">,</span><span class="s1">&quot;paramLength&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;_param&quot;</span><span class="s0">,</span><span class="s1">&quot;space&quot;</span><span class="s0">,</span><span class="s1">&quot;parameter&quot;</span><span class="s0">,</span><span class="s1">&quot;printJoin&quot;</span><span class="s0">,</span><span class="s1">&quot;decorators&quot;</span><span class="s0">,</span><span class="s1">&quot;optional&quot;</span><span class="s0">,</span><span class="s1">&quot;typeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;_methodHead&quot;</span><span class="s0">,</span><span class="s1">&quot;kind&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;word&quot;</span><span class="s0">,</span><span class="s1">&quot;async&quot;</span><span class="s0">,</span><span class="s1">&quot;generator&quot;</span><span class="s0">,</span><span class="s1">&quot;computed&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;_predicate&quot;</span><span class="s0">,</span><span class="s1">&quot;noLineTerminatorAfter&quot;</span><span class="s0">,</span><span class="s1">&quot;predicate&quot;</span><span class="s0">,</span><span class="s1">&quot;_functionHead&quot;</span><span class="s0">,</span><span class="s1">&quot;parent&quot;</span><span class="s0">,</span><span class="s1">&quot;format&quot;</span><span class="s0">,</span><span class="s1">&quot;preserveFormat&quot;</span><span class="s0">,</span><span class="s1">&quot;_endsWithInnerRaw&quot;</span><span class="s0">,</span><span class="s1">&quot;id&quot;</span><span class="s0">,</span><span class="s1">&quot;FunctionExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;body&quot;</span><span class="s0">,</span><span class="s1">&quot;ArrowFunctionExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;_shouldPrintArrowParamsParens&quot;</span><span class="s0">,</span><span class="s1">&quot;printInnerComments&quot;</span><span class="s0">,</span><span class="s1">&quot;tokenContext&quot;</span><span class="s0">,</span><span class="s1">&quot;TokenContext&quot;</span><span class="s0">,</span><span class="s1">&quot;arrowBody&quot;</span><span class="s0">,</span><span class="s1">&quot;_firstParam$leadingCo&quot;</span><span class="s0">,</span><span class="s1">&quot;_firstParam$trailingC&quot;</span><span class="s0">,</span><span class="s1">&quot;firstParam&quot;</span><span class="s0">,</span><span class="s1">&quot;leadingComments&quot;</span><span class="s0">,</span><span class="s1">&quot;trailingComments&quot;</span><span class="s0">,</span><span class="s1">&quot;tokenMap&quot;</span><span class="s0">,</span><span class="s1">&quot;loc&quot;</span><span class="s0">,</span><span class="s1">&quot;findMatching&quot;</span><span class="s0">,</span><span class="s1">&quot;arrowToken&quot;</span><span class="s0">,</span><span class="s1">&quot;start&quot;</span><span class="s0">,</span><span class="s1">&quot;line&quot;</span><span class="s0">,</span><span class="s1">&quot;retainLines&quot;</span><span class="s0">,</span><span class="s1">&quot;parentType&quot;</span><span class="s0">,</span><span class="s1">&quot;left&quot;</span><span class="s0">,</span><span class="s1">&quot;_id$loc&quot;</span><span class="s0">,</span><span class="s1">&quot;_id$loc2&quot;</span><span class="s0">,</span><span class="s1">&quot;identifierName&quot;</span><span class="s0">,</span><span class="s1">&quot;_id$loc3&quot;</span><span class="s0">,</span><span class="s1">&quot;_id$loc4&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../src/generators/methods.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type Printer from </span><span class="s3">\&quot;</span><span class="s1">../printer.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type * as t from </span><span class="s3">\&quot;</span><span class="s1">@babel/types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { isIdentifier, type ParentMaps } from </span><span class="s3">\&quot;</span><span class="s1">@babel/types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { TokenContext } from </span><span class="s3">\&quot;</span><span class="s1">../node/index.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">type ParentsOf&lt;T extends t.Node&gt; = ParentMaps[T[</span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">]];</span><span class="s3">\n\n</span><span class="s1">export function _params(</span><span class="s3">\n  </span><span class="s1">this: Printer,</span><span class="s3">\n  </span><span class="s1">node: t.Function | t.TSDeclareMethod | t.TSDeclareFunction,</span><span class="s3">\n  </span><span class="s1">idNode: t.Expression | t.PrivateName,</span><span class="s3">\n  </span><span class="s1">parentNode: ParentsOf&lt;typeof node&gt;,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">this.print(node.typeParameters);</span><span class="s3">\n\n  </span><span class="s1">const nameInfo = _getFuncIdName.call(this, idNode, parentNode);</span><span class="s3">\n  </span><span class="s1">if (nameInfo) {</span><span class="s3">\n    </span><span class="s1">this.sourceIdentifierName(nameInfo.name, nameInfo.pos);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">this._parameters(node.params, </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n  </span><span class="s1">const noLineTerminator = node.type === </span><span class="s3">\&quot;</span><span class="s1">ArrowFunctionExpression</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">this.print(node.returnType, noLineTerminator);</span><span class="s3">\n\n  </span><span class="s1">this._noLineTerminator = noLineTerminator;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function _parameters(</span><span class="s3">\n  </span><span class="s1">this: Printer,</span><span class="s3">\n  </span><span class="s1">parameters: t.Function[</span><span class="s3">\&quot;</span><span class="s1">params</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n  </span><span class="s1">endToken: string,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const exit = this.enterDelimited();</span><span class="s3">\n\n  </span><span class="s1">const trailingComma = this.shouldPrintTrailingComma(endToken);</span><span class="s3">\n\n  </span><span class="s1">const paramLength = parameters.length;</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; paramLength; i++) {</span><span class="s3">\n    </span><span class="s1">this._param(parameters[i]);</span><span class="s3">\n\n    </span><span class="s1">if (trailingComma || i &lt; paramLength - 1) {</span><span class="s3">\n      </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">, null, i);</span><span class="s3">\n      </span><span class="s1">this.space();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">this.token(endToken);</span><span class="s3">\n  </span><span class="s1">exit();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function _param(</span><span class="s3">\n  </span><span class="s1">this: Printer,</span><span class="s3">\n  </span><span class="s1">parameter: t.Identifier | t.RestElement | t.Pattern | t.TSParameterProperty,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">this.printJoin(parameter.decorators);</span><span class="s3">\n  </span><span class="s1">this.print(parameter);</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">// @ts-expect-error optional is not in TSParameterProperty</span><span class="s3">\n    </span><span class="s1">parameter.optional</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">); // TS / flow</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">this.print(</span><span class="s3">\n    </span><span class="s1">// @ts-expect-error typeAnnotation is not in TSParameterProperty</span><span class="s3">\n    </span><span class="s1">parameter.typeAnnotation,</span><span class="s3">\n  </span><span class="s1">); // TS / flow</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function _methodHead(this: Printer, node: t.Method | t.TSDeclareMethod) {</span><span class="s3">\n  </span><span class="s1">const kind = node.kind;</span><span class="s3">\n  </span><span class="s1">const key = node.key;</span><span class="s3">\n\n  </span><span class="s1">if (kind === </span><span class="s3">\&quot;</span><span class="s1">get</span><span class="s3">\&quot; </span><span class="s1">|| kind === </span><span class="s3">\&quot;</span><span class="s1">set</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">this.word(kind);</span><span class="s3">\n    </span><span class="s1">this.space();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (node.async) {</span><span class="s3">\n    </span><span class="s1">this.word(</span><span class="s3">\&quot;</span><span class="s1">async</span><span class="s3">\&quot;</span><span class="s1">, true);</span><span class="s3">\n    </span><span class="s1">this.space();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">kind === </span><span class="s3">\&quot;</span><span class="s1">method</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n    </span><span class="s1">// @ts-expect-error Fixme: kind: </span><span class="s3">\&quot;</span><span class="s1">init</span><span class="s3">\&quot; </span><span class="s1">is not defined</span><span class="s3">\n    </span><span class="s1">kind === </span><span class="s3">\&quot;</span><span class="s1">init</span><span class="s3">\&quot;\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">if (node.generator) {</span><span class="s3">\n      </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (node.computed) {</span><span class="s3">\n    </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">this.print(key);</span><span class="s3">\n    </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">this.print(key);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">// @ts-expect-error optional is not in ObjectMethod</span><span class="s3">\n    </span><span class="s1">node.optional</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">// TS</span><span class="s3">\n    </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">this._params(</span><span class="s3">\n    </span><span class="s1">node,</span><span class="s3">\n    </span><span class="s1">node.computed &amp;&amp; node.key.type !== </span><span class="s3">\&quot;</span><span class="s1">StringLiteral</span><span class="s3">\&quot; </span><span class="s1">? undefined : node.key,</span><span class="s3">\n    </span><span class="s1">undefined,</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function _predicate(</span><span class="s3">\n  </span><span class="s1">this: Printer,</span><span class="s3">\n  </span><span class="s1">node:</span><span class="s3">\n    </span><span class="s1">| t.FunctionDeclaration</span><span class="s3">\n    </span><span class="s1">| t.FunctionExpression</span><span class="s3">\n    </span><span class="s1">| t.ArrowFunctionExpression,</span><span class="s3">\n  </span><span class="s1">noLineTerminatorAfter?: boolean,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">if (node.predicate) {</span><span class="s3">\n    </span><span class="s1">if (!node.returnType) {</span><span class="s3">\n      </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.space();</span><span class="s3">\n    </span><span class="s1">this.print(node.predicate, noLineTerminatorAfter);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function _functionHead(</span><span class="s3">\n  </span><span class="s1">this: Printer,</span><span class="s3">\n  </span><span class="s1">node: t.FunctionDeclaration | t.FunctionExpression | t.TSDeclareFunction,</span><span class="s3">\n  </span><span class="s1">parent: ParentsOf&lt;typeof node&gt;,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">if (node.async) {</span><span class="s3">\n    </span><span class="s1">this.word(</span><span class="s3">\&quot;</span><span class="s1">async</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">if (!this.format.preserveFormat) {</span><span class="s3">\n      </span><span class="s1">// We prevent inner comments from being printed here,</span><span class="s3">\n      </span><span class="s1">// so that they are always consistently printed in the</span><span class="s3">\n      </span><span class="s1">// same place regardless of the function type.</span><span class="s3">\n      </span><span class="s1">this._endsWithInnerRaw = false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.space();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">this.word(</span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">if (node.generator) {</span><span class="s3">\n    </span><span class="s1">if (!this.format.preserveFormat) {</span><span class="s3">\n      </span><span class="s1">// We prevent inner comments from being printed here,</span><span class="s3">\n      </span><span class="s1">// so that they are always consistently printed in the</span><span class="s3">\n      </span><span class="s1">// same place regardless of the function type.</span><span class="s3">\n      </span><span class="s1">this._endsWithInnerRaw = false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">this.space();</span><span class="s3">\n  </span><span class="s1">if (node.id) {</span><span class="s3">\n    </span><span class="s1">this.print(node.id);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">this._params(node, node.id, parent);</span><span class="s3">\n  </span><span class="s1">if (node.type !== </span><span class="s3">\&quot;</span><span class="s1">TSDeclareFunction</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">this._predicate(node);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function FunctionExpression(</span><span class="s3">\n  </span><span class="s1">this: Printer,</span><span class="s3">\n  </span><span class="s1">node: t.FunctionExpression,</span><span class="s3">\n  </span><span class="s1">parent: ParentsOf&lt;typeof node&gt;,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">this._functionHead(node, parent);</span><span class="s3">\n  </span><span class="s1">this.space();</span><span class="s3">\n  </span><span class="s1">this.print(node.body);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { FunctionExpression as FunctionDeclaration };</span><span class="s3">\n\n</span><span class="s1">export function ArrowFunctionExpression(</span><span class="s3">\n  </span><span class="s1">this: Printer,</span><span class="s3">\n  </span><span class="s1">node: t.ArrowFunctionExpression,</span><span class="s3">\n  </span><span class="s1">parent: ParentsOf&lt;typeof node&gt;,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">if (node.async) {</span><span class="s3">\n    </span><span class="s1">this.word(</span><span class="s3">\&quot;</span><span class="s1">async</span><span class="s3">\&quot;</span><span class="s1">, true);</span><span class="s3">\n    </span><span class="s1">this.space();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (this._shouldPrintArrowParamsParens(node)) {</span><span class="s3">\n    </span><span class="s1">this._params(node, undefined, parent);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">this.print(node.params[0], true);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">this._predicate(node, true);</span><span class="s3">\n  </span><span class="s1">this.space();</span><span class="s3">\n  </span><span class="s1">// When printing (x)/*1*/=&gt;{}, we remove the parentheses</span><span class="s3">\n  </span><span class="s1">// and thus there aren't two contiguous inner tokens.</span><span class="s3">\n  </span><span class="s1">// We forcefully print inner comments here.</span><span class="s3">\n  </span><span class="s1">this.printInnerComments();</span><span class="s3">\n  </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">=&gt;</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n  </span><span class="s1">this.space();</span><span class="s3">\n\n  </span><span class="s1">this.tokenContext |= TokenContext.arrowBody;</span><span class="s3">\n  </span><span class="s1">this.print(node.body);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Try to avoid printing parens in simple cases, but only if we're pretty</span><span class="s3">\n</span><span class="s1">// sure that they aren't needed by type annotations or potential newlines.</span><span class="s3">\n</span><span class="s1">export function _shouldPrintArrowParamsParens(</span><span class="s3">\n  </span><span class="s1">this: Printer,</span><span class="s3">\n  </span><span class="s1">node: t.ArrowFunctionExpression,</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">if (node.params.length !== 1) return true;</span><span class="s3">\n\n  </span><span class="s1">if (node.typeParameters || node.returnType || node.predicate) {</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const firstParam = node.params[0];</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">!isIdentifier(firstParam) ||</span><span class="s3">\n    </span><span class="s1">firstParam.typeAnnotation ||</span><span class="s3">\n    </span><span class="s1">firstParam.optional ||</span><span class="s3">\n    </span><span class="s1">// Flow does not support `foo /*: string*/ =&gt; {};`</span><span class="s3">\n    </span><span class="s1">firstParam.leadingComments?.length ||</span><span class="s3">\n    </span><span class="s1">firstParam.trailingComments?.length</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (this.tokenMap) {</span><span class="s3">\n    </span><span class="s1">if (node.loc == null) return true;</span><span class="s3">\n    </span><span class="s1">if (this.tokenMap.findMatching(node, </span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">) !== null) return true;</span><span class="s3">\n    </span><span class="s1">const arrowToken = this.tokenMap.findMatching(node, </span><span class="s3">\&quot;</span><span class="s1">=&gt;</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">if (arrowToken?.loc == null) return true;</span><span class="s3">\n    </span><span class="s1">return arrowToken.loc.start.line !== node.loc.start.line;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (this.format.retainLines) return true;</span><span class="s3">\n\n  </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function _getFuncIdName(</span><span class="s3">\n  </span><span class="s1">this: Printer,</span><span class="s3">\n  </span><span class="s1">idNode: t.Expression | t.PrivateName,</span><span class="s3">\n  </span><span class="s1">parent: ParentsOf&lt;t.Function | t.TSDeclareMethod | t.TSDeclareFunction&gt;,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">let id: t.Expression | t.PrivateName | t.LVal = idNode;</span><span class="s3">\n\n  </span><span class="s1">if (!id &amp;&amp; parent) {</span><span class="s3">\n    </span><span class="s1">const parentType = parent.type;</span><span class="s3">\n\n    </span><span class="s1">if (parentType === </span><span class="s3">\&quot;</span><span class="s1">VariableDeclarator</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">id = parent.id;</span><span class="s3">\n    </span><span class="s1">} else if (</span><span class="s3">\n      </span><span class="s1">parentType === </span><span class="s3">\&quot;</span><span class="s1">AssignmentExpression</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n      </span><span class="s1">parentType === </span><span class="s3">\&quot;</span><span class="s1">AssignmentPattern</span><span class="s3">\&quot;\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">id = parent.left;</span><span class="s3">\n    </span><span class="s1">} else if (</span><span class="s3">\n      </span><span class="s1">parentType === </span><span class="s3">\&quot;</span><span class="s1">ObjectProperty</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n      </span><span class="s1">parentType === </span><span class="s3">\&quot;</span><span class="s1">ClassProperty</span><span class="s3">\&quot;\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">if (!parent.computed || parent.key.type === </span><span class="s3">\&quot;</span><span class="s1">StringLiteral</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">id = parent.key;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (</span><span class="s3">\n      </span><span class="s1">parentType === </span><span class="s3">\&quot;</span><span class="s1">ClassPrivateProperty</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n      </span><span class="s1">parentType === </span><span class="s3">\&quot;</span><span class="s1">ClassAccessorProperty</span><span class="s3">\&quot;\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">id = parent.key;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (!id) return;</span><span class="s3">\n\n  </span><span class="s1">let nameInfo;</span><span class="s3">\n\n  </span><span class="s1">if (id.type === </span><span class="s3">\&quot;</span><span class="s1">Identifier</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">nameInfo = {</span><span class="s3">\n      </span><span class="s1">pos: id.loc?.start,</span><span class="s3">\n      </span><span class="s1">name: id.loc?.identifierName || id.name,</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">} else if (id.type === </span><span class="s3">\&quot;</span><span class="s1">PrivateName</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">nameInfo = {</span><span class="s3">\n      </span><span class="s1">pos: id.loc?.start,</span><span class="s3">\n      </span><span class="s1">name: </span><span class="s3">\&quot;</span><span class="s1">#</span><span class="s3">\&quot; </span><span class="s1">+ id.id.name,</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">} else if (id.type === </span><span class="s3">\&quot;</span><span class="s1">StringLiteral</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">nameInfo = {</span><span class="s3">\n      </span><span class="s1">pos: id.loc?.start,</span><span class="s3">\n      </span><span class="s1">name: id.value,</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return nameInfo;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[]}</span></pre>
</body>
</html>