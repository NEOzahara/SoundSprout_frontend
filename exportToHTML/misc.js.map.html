<html>
<head>
<title>misc.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
misc.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_core&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;_traverse&quot;</span><span class="s0">,</span><span class="s1">&quot;findBareSupers&quot;</span><span class="s0">,</span><span class="s1">&quot;visitors&quot;</span><span class="s0">,</span><span class="s1">&quot;environmentVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;Super&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;parentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;isCallExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;callee&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;referenceVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;TSTypeAnnotation|TypeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;skip&quot;</span><span class="s0">,</span><span class="s1">&quot;ReferencedIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;scope&quot;</span><span class="s0">,</span><span class="s1">&quot;hasOwnBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;rename&quot;</span><span class="s0">,</span><span class="s1">&quot;handleClassTDZ&quot;</span><span class="s0">,</span><span class="s1">&quot;state&quot;</span><span class="s0">,</span><span class="s1">&quot;classBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;getBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;classNameTDZError&quot;</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">,</span><span class="s1">&quot;addHelper&quot;</span><span class="s0">,</span><span class="s1">&quot;throwNode&quot;</span><span class="s0">,</span><span class="s1">&quot;t&quot;</span><span class="s0">,</span><span class="s1">&quot;callExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;stringLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceWith&quot;</span><span class="s0">,</span><span class="s1">&quot;sequenceExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;classFieldDefinitionEvaluationTDZVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;injectInitialization&quot;</span><span class="s0">,</span><span class="s1">&quot;constructor&quot;</span><span class="s0">,</span><span class="s1">&quot;nodes&quot;</span><span class="s0">,</span><span class="s1">&quot;renamer&quot;</span><span class="s0">,</span><span class="s1">&quot;lastReturnsThis&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;isDerived&quot;</span><span class="s0">,</span><span class="s1">&quot;superClass&quot;</span><span class="s0">,</span><span class="s1">&quot;newConstructor&quot;</span><span class="s0">,</span><span class="s1">&quot;classMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;identifier&quot;</span><span class="s0">,</span><span class="s1">&quot;blockStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;params&quot;</span><span class="s0">,</span><span class="s1">&quot;restElement&quot;</span><span class="s0">,</span><span class="s1">&quot;body&quot;</span><span class="s0">,</span><span class="s1">&quot;template&quot;</span><span class="s0">,</span><span class="s1">&quot;statement&quot;</span><span class="s0">,</span><span class="s1">&quot;ast&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;unshiftContainer&quot;</span><span class="s0">,</span><span class="s1">&quot;bareSupers&quot;</span><span class="s0">,</span><span class="s1">&quot;traverse&quot;</span><span class="s0">,</span><span class="s1">&quot;isFirst&quot;</span><span class="s0">,</span><span class="s1">&quot;bareSuper&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;n&quot;</span><span class="s0">,</span><span class="s1">&quot;cloneNode&quot;</span><span class="s0">,</span><span class="s1">&quot;isExpressionStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;allNodes&quot;</span><span class="s0">,</span><span class="s1">&quot;toExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;thisExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;insertAfter&quot;</span><span class="s0">,</span><span class="s1">&quot;memoiseComputedKey&quot;</span><span class="s0">,</span><span class="s1">&quot;keyNode&quot;</span><span class="s0">,</span><span class="s1">&quot;hint&quot;</span><span class="s0">,</span><span class="s1">&quot;isUidReference&quot;</span><span class="s0">,</span><span class="s1">&quot;isIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;hasUid&quot;</span><span class="s0">,</span><span class="s1">&quot;isMemoiseAssignment&quot;</span><span class="s0">,</span><span class="s1">&quot;isAssignmentExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;operator&quot;</span><span class="s0">,</span><span class="s1">&quot;left&quot;</span><span class="s0">,</span><span class="s1">&quot;ident&quot;</span><span class="s0">,</span><span class="s1">&quot;id&quot;</span><span class="s0">,</span><span class="s1">&quot;kind&quot;</span><span class="s0">,</span><span class="s1">&quot;assignmentExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;extractComputedKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;computedPaths&quot;</span><span class="s0">,</span><span class="s1">&quot;declarations&quot;</span><span class="s0">,</span><span class="s1">&quot;computedPath&quot;</span><span class="s0">,</span><span class="s1">&quot;computedKey&quot;</span><span class="s0">,</span><span class="s1">&quot;isReferencedIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;computedNode&quot;</span><span class="s0">,</span><span class="s1">&quot;isConstantExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;assignment&quot;</span><span class="s0">,</span><span class="s1">&quot;generateUidBasedOnNode&quot;</span><span class="s0">,</span><span class="s1">&quot;expressionStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../src/misc.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { template, types as t } from </span><span class="s3">\&quot;</span><span class="s1">@babel/core</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { File, NodePath, Scope, Visitor } from </span><span class="s3">\&quot;</span><span class="s1">@babel/core</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { visitors } from </span><span class="s3">\&quot;</span><span class="s1">@babel/traverse</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">const findBareSupers = visitors.environmentVisitor&lt;</span><span class="s3">\n  </span><span class="s1">NodePath&lt;t.CallExpression&gt;[]</span><span class="s3">\n</span><span class="s1">&gt;({</span><span class="s3">\n  </span><span class="s1">Super(path) {</span><span class="s3">\n    </span><span class="s1">const { node, parentPath } = path;</span><span class="s3">\n    </span><span class="s1">if (parentPath.isCallExpression({ callee: node })) {</span><span class="s3">\n      </span><span class="s1">this.push(parentPath);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">const referenceVisitor: Visitor&lt;{ scope: Scope }&gt; = {</span><span class="s3">\n  \&quot;</span><span class="s1">TSTypeAnnotation|TypeAnnotation</span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\n    </span><span class="s1">path: NodePath&lt;t.TSTypeAnnotation | t.TypeAnnotation&gt;,</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">path.skip();</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">ReferencedIdentifier(path: NodePath&lt;t.Identifier&gt;, { scope }) {</span><span class="s3">\n    </span><span class="s1">if (scope.hasOwnBinding(path.node.name)) {</span><span class="s3">\n      </span><span class="s1">scope.rename(path.node.name);</span><span class="s3">\n      </span><span class="s1">path.skip();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">type HandleClassTDZState = {</span><span class="s3">\n  </span><span class="s1">classBinding: Scope.Binding;</span><span class="s3">\n  </span><span class="s1">file: File;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">function handleClassTDZ(</span><span class="s3">\n  </span><span class="s1">path: NodePath&lt;t.Identifier&gt;,</span><span class="s3">\n  </span><span class="s1">state: HandleClassTDZState,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">state.classBinding &amp;&amp;</span><span class="s3">\n    </span><span class="s1">state.classBinding === path.scope.getBinding(path.node.name)</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">const classNameTDZError = state.file.addHelper(</span><span class="s3">\&quot;</span><span class="s1">classNameTDZError</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">const throwNode = t.callExpression(classNameTDZError, [</span><span class="s3">\n      </span><span class="s1">t.stringLiteral(path.node.name),</span><span class="s3">\n    </span><span class="s1">]);</span><span class="s3">\n\n    </span><span class="s1">path.replaceWith(t.sequenceExpression([throwNode, path.node]));</span><span class="s3">\n    </span><span class="s1">path.skip();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const classFieldDefinitionEvaluationTDZVisitor: Visitor&lt;HandleClassTDZState&gt; = {</span><span class="s3">\n  </span><span class="s1">ReferencedIdentifier: handleClassTDZ,</span><span class="s3">\n  \&quot;</span><span class="s1">TSTypeAnnotation|TypeAnnotation</span><span class="s3">\&quot;</span><span class="s1">(path) {</span><span class="s3">\n    </span><span class="s1">path.skip();</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">interface RenamerState {</span><span class="s3">\n  </span><span class="s1">scope: Scope;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function injectInitialization(</span><span class="s3">\n  </span><span class="s1">path: NodePath&lt;t.Class&gt;,</span><span class="s3">\n  </span><span class="s1">constructor: NodePath&lt;t.ClassMethod&gt; | undefined,</span><span class="s3">\n  </span><span class="s1">nodes: t.ExpressionStatement[],</span><span class="s3">\n  </span><span class="s1">renamer?: (visitor: Visitor&lt;RenamerState&gt;, state: RenamerState) =&gt; void,</span><span class="s3">\n  </span><span class="s1">lastReturnsThis?: boolean,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">if (!nodes.length) return;</span><span class="s3">\n\n  </span><span class="s1">const isDerived = !!path.node.superClass;</span><span class="s3">\n\n  </span><span class="s1">if (!constructor) {</span><span class="s3">\n    </span><span class="s1">const newConstructor = t.classMethod(</span><span class="s3">\n      \&quot;</span><span class="s1">constructor</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">t.identifier(</span><span class="s3">\&quot;</span><span class="s1">constructor</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">[],</span><span class="s3">\n      </span><span class="s1">t.blockStatement([]),</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n\n    </span><span class="s1">if (isDerived) {</span><span class="s3">\n      </span><span class="s1">newConstructor.params = [t.restElement(t.identifier(</span><span class="s3">\&quot;</span><span class="s1">args</span><span class="s3">\&quot;</span><span class="s1">))];</span><span class="s3">\n      </span><span class="s1">newConstructor.body.body.push(template.statement.ast`super(...args)`);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">[constructor] = path</span><span class="s3">\n      </span><span class="s1">.get(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">.unshiftContainer(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">, newConstructor) as NodePath&lt;t.ClassMethod&gt;[];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (renamer) {</span><span class="s3">\n    </span><span class="s1">renamer(referenceVisitor, { scope: constructor.scope });</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (isDerived) {</span><span class="s3">\n    </span><span class="s1">const bareSupers: NodePath&lt;t.CallExpression&gt;[] = [];</span><span class="s3">\n    </span><span class="s1">constructor.traverse(findBareSupers, bareSupers);</span><span class="s3">\n    </span><span class="s1">let isFirst = true;</span><span class="s3">\n    </span><span class="s1">for (const bareSuper of bareSupers) {</span><span class="s3">\n      </span><span class="s1">if (isFirst) {</span><span class="s3">\n        </span><span class="s1">isFirst = false;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">nodes = nodes.map(n =&gt; t.cloneNode(n));</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (!bareSuper.parentPath.isExpressionStatement()) {</span><span class="s3">\n        </span><span class="s1">const allNodes: t.Expression[] = [</span><span class="s3">\n          </span><span class="s1">bareSuper.node,</span><span class="s3">\n          </span><span class="s1">...nodes.map(n =&gt; t.toExpression(n)),</span><span class="s3">\n        </span><span class="s1">];</span><span class="s3">\n        </span><span class="s1">if (!lastReturnsThis) allNodes.push(t.thisExpression());</span><span class="s3">\n        </span><span class="s1">bareSuper.replaceWith(t.sequenceExpression(allNodes));</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">bareSuper.insertAfter(nodes);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">constructor.get(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">).unshiftContainer(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">, nodes);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type ComputedKeyAssignmentExpression = t.AssignmentExpression &amp; {</span><span class="s3">\n  </span><span class="s1">left: t.Identifier;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Try to memoise a computed key.</span><span class="s3">\n </span><span class="s1">* It returns undefined when the computed key is an uid reference, otherwise</span><span class="s3">\n </span><span class="s1">* an assignment expression `memoiserId = computed key`</span><span class="s3">\n </span><span class="s1">* @export</span><span class="s3">\n </span><span class="s1">* @param {t.Expression} keyNode Computed key</span><span class="s3">\n </span><span class="s1">* @param {Scope} scope The scope where memoiser id should be registered</span><span class="s3">\n </span><span class="s1">* @param {string} hint The memoiser id hint</span><span class="s3">\n </span><span class="s1">* @returns {(ComputedKeyAssignmentExpression | undefined)}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function memoiseComputedKey(</span><span class="s3">\n  </span><span class="s1">keyNode: t.Expression,</span><span class="s3">\n  </span><span class="s1">scope: Scope,</span><span class="s3">\n  </span><span class="s1">hint: string,</span><span class="s3">\n</span><span class="s1">): ComputedKeyAssignmentExpression | undefined {</span><span class="s3">\n  </span><span class="s1">const isUidReference = t.isIdentifier(keyNode) &amp;&amp; scope.hasUid(keyNode.name);</span><span class="s3">\n  </span><span class="s1">if (isUidReference) {</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const isMemoiseAssignment =</span><span class="s3">\n    </span><span class="s1">t.isAssignmentExpression(keyNode, { operator: </span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot; </span><span class="s1">}) &amp;&amp;</span><span class="s3">\n    </span><span class="s1">t.isIdentifier(keyNode.left) &amp;&amp;</span><span class="s3">\n    </span><span class="s1">scope.hasUid(keyNode.left.name);</span><span class="s3">\n  </span><span class="s1">if (isMemoiseAssignment) {</span><span class="s3">\n    </span><span class="s1">return t.cloneNode(keyNode as ComputedKeyAssignmentExpression);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">const ident = t.identifier(hint);</span><span class="s3">\n    </span><span class="s1">// Declaring in the same block scope</span><span class="s3">\n    </span><span class="s1">// Ref: https://github.com/babel/babel/pull/10029/files#diff-fbbdd83e7a9c998721c1484529c2ce92</span><span class="s3">\n    </span><span class="s1">scope.push({</span><span class="s3">\n      </span><span class="s1">id: ident,</span><span class="s3">\n      </span><span class="s1">kind: </span><span class="s3">\&quot;</span><span class="s1">let</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return t.assignmentExpression(</span><span class="s3">\n      \&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">t.cloneNode(ident),</span><span class="s3">\n      </span><span class="s1">keyNode,</span><span class="s3">\n    </span><span class="s1">) as ComputedKeyAssignmentExpression;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function extractComputedKeys(</span><span class="s3">\n  </span><span class="s1">path: NodePath&lt;t.Class&gt;,</span><span class="s3">\n  </span><span class="s1">computedPaths: NodePath&lt;t.ClassProperty | t.ClassMethod&gt;[],</span><span class="s3">\n  </span><span class="s1">file: File,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const { scope } = path;</span><span class="s3">\n  </span><span class="s1">const declarations: t.ExpressionStatement[] = [];</span><span class="s3">\n  </span><span class="s1">const state = {</span><span class="s3">\n    </span><span class="s1">classBinding: path.node.id &amp;&amp; scope.getBinding(path.node.id.name),</span><span class="s3">\n    </span><span class="s1">file,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">for (const computedPath of computedPaths) {</span><span class="s3">\n    </span><span class="s1">const computedKey = computedPath.get(</span><span class="s3">\&quot;</span><span class="s1">key</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">if (computedKey.isReferencedIdentifier()) {</span><span class="s3">\n      </span><span class="s1">handleClassTDZ(computedKey, state);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">computedKey.traverse(classFieldDefinitionEvaluationTDZVisitor, state);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const computedNode = computedPath.node;</span><span class="s3">\n    </span><span class="s1">// Make sure computed property names are only evaluated once (upon class definition)</span><span class="s3">\n    </span><span class="s1">// and in the right order in combination with static properties</span><span class="s3">\n    </span><span class="s1">if (!computedKey.isConstantExpression()) {</span><span class="s3">\n      </span><span class="s1">const assignment = memoiseComputedKey(</span><span class="s3">\n        </span><span class="s1">computedKey.node,</span><span class="s3">\n        </span><span class="s1">scope,</span><span class="s3">\n        </span><span class="s1">scope.generateUidBasedOnNode(computedKey.node),</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">if (assignment) {</span><span class="s3">\n        </span><span class="s1">declarations.push(t.expressionStatement(assignment));</span><span class="s3">\n        </span><span class="s1">computedNode.key = t.cloneNode(assignment.left);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return declarations;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;AAAA,IAAAA,KAAA,GAAAC,OAAA;AAEA,IAAAC,SAAA,GAAAD,OAAA;AAEA,MAAME,cAAc,GAAGC,kBAAQ,CAACC,kBAAkB,CAEhD;EACAC,KAAKA,CAACC,IAAI,EAAE;IACV,MAAM;MAAEC,IAAI;MAAEC;IAAW,CAAC,GAAGF,IAAI;IACjC,IAAIE,UAAU,CAACC,gBAAgB,CAAC;MAAEC,MAAM,EAAEH;IAAK,CAAC,CAAC,EAAE;MACjD,IAAI,CAACI,IAAI,CAACH,UAAU,CAAC;IACvB;EACF;AACF,CAAC,CAAC;AAEF,MAAMI,gBAA2C,GAAG;EAClD,iCAAiCC,CAC/BP,IAAqD,EACrD;IACAA,IAAI,CAACQ,IAAI,CAAC,CAAC;EACb,CAAC;EAEDC,oBAAoBA,CAACT,IAA4B,EAAE;IAAEU;EAAM,CAAC,EAAE;IAC5D,IAAIA,KAAK,CAACC,aAAa,CAACX,IAAI,CAACC,IAAI,CAACW,IAAI,CAAC,EAAE;MACvCF,KAAK,CAACG,MAAM,CAACb,IAAI,CAACC,IAAI,CAACW,IAAI,CAAC;MAC5BZ,IAAI,CAACQ,IAAI,CAAC,CAAC;IACb;EACF;AACF,CAAC;AAOD,SAASM,cAAcA,CACrBd,IAA4B,EAC5Be,KAA0B,EAC1B;EACA,IACEA,KAAK,CAACC,YAAY,IAClBD,KAAK,CAACC,YAAY,KAAKhB,IAAI,CAACU,KAAK,CAACO,UAAU,CAACjB,IAAI,CAACC,IAAI,CAACW,IAAI,CAAC,EAC5D;IACA,MAAMM,iBAAiB,GAAGH,KAAK,CAACI,IAAI,CAACC,SAAS,CAAC,mBAAmB,CAAC;IACnE,MAAMC,SAAS,GAAGC,WAAC,CAACC,cAAc,CAACL,iBAAiB,EAAE,CACpDI,WAAC,CAACE,aAAa,CAACxB,IAAI,CAACC,IAAI,CAACW,IAAI,CAAC,CAChC,CAAC;IAEFZ,IAAI,CAACyB,WAAW,CAACH,WAAC,CAACI,kBAAkB,CAAC,CAACL,SAAS,EAAErB,IAAI,CAACC,IAAI,CAAC,CAAC,CAAC;IAC9DD,IAAI,CAACQ,IAAI,CAAC,CAAC;EACb;AACF;AAEA,MAAMmB,wCAAsE,GAAG;EAC7ElB,oBAAoB,EAAEK,cAAc;EACpC,iCAAiCP,CAACP,IAAI,EAAE;IACtCA,IAAI,CAACQ,IAAI,CAAC,CAAC;EACb;AACF,CAAC;AAMM,SAASoB,oBAAoBA,CAClC5B,IAAuB,EACvB6B,WAAgD,EAChDC,KAA8B,EAC9BC,OAAuE,EACvEC,eAAyB,EACzB;EACA,IAAI,CAACF,KAAK,CAACG,MAAM,EAAE;EAEnB,MAAMC,SAAS,GAAG,CAAC,CAAClC,IAAI,CAACC,IAAI,CAACkC,UAAU;EAExC,IAAI,CAACN,WAAW,EAAE;IAChB,MAAMO,cAAc,GAAGd,WAAC,CAACe,WAAW,CAClC,aAAa,EACbf,WAAC,CAACgB,UAAU,CAAC,aAAa,CAAC,EAC3B,EAAE,EACFhB,WAAC,CAACiB,cAAc,CAAC,EAAE,CACrB,CAAC;IAED,IAAIL,SAAS,EAAE;MACbE,cAAc,CAACI,MAAM,GAAG,CAAClB,WAAC,CAACmB,WAAW,CAACnB,WAAC,CAACgB,UAAU,CAAC,MAAM,CAAC,CAAC,CAAC;MAC7DF,cAAc,CAACM,IAAI,CAACA,IAAI,CAACrC,IAAI,CAACsC,cAAQ,CAACC,SAAS,CAACC,GAAG,gBAAgB,CAAC;IACvE;IAEA,CAAChB,WAAW,CAAC,GAAG7B,IAAI,CACjB8C,GAAG,CAAC,MAAM,CAAC,CACXC,gBAAgB,CAAC,MAAM,EAAEX,cAAc,CAA8B;EAC1E;EAEA,IAAIL,OAAO,EAAE;IACXA,OAAO,CAACzB,gBAAgB,EAAE;MAAEI,KAAK,EAAEmB,WAAW,CAACnB;IAAM,CAAC,CAAC;EACzD;EAEA,IAAIwB,SAAS,EAAE;IACb,MAAMc,UAAwC,GAAG,EAAE;IACnDnB,WAAW,CAACoB,QAAQ,CAACrD,cAAc,EAAEoD,UAAU,CAAC;IAChD,IAAIE,OAAO,GAAG,IAAI;IAClB,KAAK,MAAMC,SAAS,IAAIH,UAAU,EAAE;MAClC,IAAIE,OAAO,EAAE;QACXA,OAAO,GAAG,KAAK;MACjB,CAAC,MAAM;QACLpB,KAAK,GAAGA,KAAK,CAACsB,GAAG,CAACC,CAAC,IAAI/B,WAAC,CAACgC,SAAS,CAACD,CAAC,CAAC,CAAC;MACxC;MACA,IAAI,CAACF,SAAS,CAACjD,UAAU,CAACqD,qBAAqB,CAAC,CAAC,EAAE;QACjD,MAAMC,QAAwB,GAAG,CAC/BL,SAAS,CAAClD,IAAI,EACd,GAAG6B,KAAK,CAACsB,GAAG,CAACC,CAAC,IAAI/B,WAAC,CAACmC,YAAY,CAACJ,CAAC,CAAC,CAAC,CACrC;QACD,IAAI,CAACrB,eAAe,EAAEwB,QAAQ,CAACnD,IAAI,CAACiB,WAAC,CAACoC,cAAc,CAAC,CAAC,CAAC;QACvDP,SAAS,CAAC1B,WAAW,CAACH,WAAC,CAACI,kBAAkB,CAAC8B,QAAQ,CAAC,CAAC;MACvD,CAAC,MAAM;QACLL,SAAS,CAACQ,WAAW,CAAC7B,KAAK,CAAC;MAC9B;IACF;EACF,CAAC,MAAM;IACLD,WAAW,CAACiB,GAAG,CAAC,MAAM,CAAC,CAACC,gBAAgB,CAAC,MAAM,EAAEjB,KAAK,CAAC;EACzD;AACF;AAgBO,SAAS8B,kBAAkBA,CAChCC,OAAqB,EACrBnD,KAAY,EACZoD,IAAY,EACiC;EAC7C,MAAMC,cAAc,GAAGzC,WAAC,CAAC0C,YAAY,CAACH,OAAO,CAAC,IAAInD,KAAK,CAACuD,MAAM,CAACJ,OAAO,CAACjD,IAAI,CAAC;EAC5E,IAAImD,cAAc,EAAE;IAClB;EACF;EACA,MAAMG,mBAAmB,GACvB5C,WAAC,CAAC6C,sBAAsB,CAACN,OAAO,EAAE;IAAEO,QAAQ,EAAE;EAAI,CAAC,CAAC,IACpD9C,WAAC,CAAC0C,YAAY,CAACH,OAAO,CAACQ,IAAI,CAAC,IAC5B3D,KAAK,CAACuD,MAAM,CAACJ,OAAO,CAACQ,IAAI,CAACzD,IAAI,CAAC;EACjC,IAAIsD,mBAAmB,EAAE;IACvB,OAAO5C,WAAC,CAACgC,SAAS,CAACO,OAA0C,CAAC;EAChE,CAAC,MAAM;IACL,MAAMS,KAAK,GAAGhD,WAAC,CAACgB,UAAU,CAACwB,IAAI,CAAC;IAGhCpD,KAAK,CAACL,IAAI,CAAC;MACTkE,EAAE,EAAED,KAAK;MACTE,IAAI,EAAE;IACR,CAAC,CAAC;IACF,OAAOlD,WAAC,CAACmD,oBAAoB,CAC3B,GAAG,EACHnD,WAAC,CAACgC,SAAS,CAACgB,KAAK,CAAC,EAClBT,OACF,CAAC;EACH;AACF;AAEO,SAASa,mBAAmBA,CACjC1E,IAAuB,EACvB2E,aAA0D,EAC1DxD,IAAU,EACV;EACA,MAAM;IAAET;EAAM,CAAC,GAAGV,IAAI;EACtB,MAAM4E,YAAqC,GAAG,EAAE;EAChD,MAAM7D,KAAK,GAAG;IACZC,YAAY,EAAEhB,IAAI,CAACC,IAAI,CAACsE,EAAE,IAAI7D,KAAK,CAACO,UAAU,CAACjB,IAAI,CAACC,IAAI,CAACsE,EAAE,CAAC3D,IAAI,CAAC;IACjEO;EACF,CAAC;EACD,KAAK,MAAM0D,YAAY,IAAIF,aAAa,EAAE;IACxC,MAAMG,WAAW,GAAGD,YAAY,CAAC/B,GAAG,CAAC,KAAK,CAAC;IAC3C,IAAIgC,WAAW,CAACC,sBAAsB,CAAC,CAAC,EAAE;MACxCjE,cAAc,CAACgE,WAAW,EAAE/D,KAAK,CAAC;IACpC,CAAC,MAAM;MACL+D,WAAW,CAAC7B,QAAQ,CAACtB,wCAAwC,EAAEZ,KAAK,CAAC;IACvE;IAEA,MAAMiE,YAAY,GAAGH,YAAY,CAAC5E,IAAI;IAGtC,IAAI,CAAC6E,WAAW,CAACG,oBAAoB,CAAC,CAAC,EAAE;MACvC,MAAMC,UAAU,GAAGtB,kBAAkB,CACnCkB,WAAW,CAAC7E,IAAI,EAChBS,KAAK,EACLA,KAAK,CAACyE,sBAAsB,CAACL,WAAW,CAAC7E,IAAI,CAC/C,CAAC;MACD,IAAIiF,UAAU,EAAE;QACdN,YAAY,CAACvE,IAAI,CAACiB,WAAC,CAAC8D,mBAAmB,CAACF,UAAU,CAAC,CAAC;QACpDF,YAAY,CAACK,GAAG,GAAG/D,WAAC,CAACgC,SAAS,CAAC4B,UAAU,CAACb,IAAI,CAAC;MACjD;IACF;EACF;EAEA,OAAOO,YAAY;AACrB&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[]}</span></pre>
</body>
</html>