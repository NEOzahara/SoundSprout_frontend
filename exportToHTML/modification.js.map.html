<html>
<head>
<title>modification.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
modification.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_cache&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;_index&quot;</span><span class="s0">,</span><span class="s1">&quot;_context&quot;</span><span class="s0">,</span><span class="s1">&quot;_removal&quot;</span><span class="s0">,</span><span class="s1">&quot;_t&quot;</span><span class="s0">,</span><span class="s1">&quot;_hoister&quot;</span><span class="s0">,</span><span class="s1">&quot;arrowFunctionExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;assertExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;assignmentExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;blockStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;callExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;cloneNode&quot;</span><span class="s0">,</span><span class="s1">&quot;expressionStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;isAssignmentExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isCallExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isExportNamedDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;isExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;isSequenceExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isSuper&quot;</span><span class="s0">,</span><span class="s1">&quot;thisExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;insertBefore&quot;</span><span class="s0">,</span><span class="s1">&quot;nodes_&quot;</span><span class="s0">,</span><span class="s1">&quot;_assertUnremoved&quot;</span><span class="s0">,</span><span class="s1">&quot;call&quot;</span><span class="s0">,</span><span class="s1">&quot;nodes&quot;</span><span class="s0">,</span><span class="s1">&quot;_verifyNodeList&quot;</span><span class="s0">,</span><span class="s1">&quot;parentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;parent&quot;</span><span class="s0">,</span><span class="s1">&quot;isExpressionStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;isLabeledStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;isExportDefaultDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;isDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;isNodeType&quot;</span><span class="s0">,</span><span class="s1">&quot;isJSXElement&quot;</span><span class="s0">,</span><span class="s1">&quot;isForStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceExpressionWithStatements&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;isArray&quot;</span><span class="s0">,</span><span class="s1">&quot;container&quot;</span><span class="s0">,</span><span class="s1">&quot;_containerInsertBefore&quot;</span><span class="s0">,</span><span class="s1">&quot;isStatementOrBlock&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldInsertCurrentNode&quot;</span><span class="s0">,</span><span class="s1">&quot;expression&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceWith&quot;</span><span class="s0">,</span><span class="s1">&quot;unshiftContainer&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;_containerInsert&quot;</span><span class="s0">,</span><span class="s1">&quot;from&quot;</span><span class="s0">,</span><span class="s1">&quot;updateSiblingKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;paths&quot;</span><span class="s0">,</span><span class="s1">&quot;splice&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;_this$context&quot;</span><span class="s0">,</span><span class="s1">&quot;to&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;getSibling&quot;</span><span class="s0">,</span><span class="s1">&quot;context&quot;</span><span class="s0">,</span><span class="s1">&quot;queue&quot;</span><span class="s0">,</span><span class="s1">&quot;pushContext&quot;</span><span class="s0">,</span><span class="s1">&quot;contexts&quot;</span><span class="s0">,</span><span class="s1">&quot;_getQueueContexts&quot;</span><span class="s0">,</span><span class="s1">&quot;setScope&quot;</span><span class="s0">,</span><span class="s1">&quot;debug&quot;</span><span class="s0">,</span><span class="s1">&quot;maybeQueue&quot;</span><span class="s0">,</span><span class="s1">&quot;_containerInsertAfter&quot;</span><span class="s0">,</span><span class="s1">&quot;last&quot;</span><span class="s0">,</span><span class="s1">&quot;arr&quot;</span><span class="s0">,</span><span class="s1">&quot;isHiddenInSequenceExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;expressions&quot;</span><span class="s0">,</span><span class="s1">&quot;isAlmostConstantAssignment&quot;</span><span class="s0">,</span><span class="s1">&quot;scope&quot;</span><span class="s0">,</span><span class="s1">&quot;left&quot;</span><span class="s0">,</span><span class="s1">&quot;blockScope&quot;</span><span class="s0">,</span><span class="s1">&quot;getBlockParent&quot;</span><span class="s0">,</span><span class="s1">&quot;hasOwnBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;getOwnBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;constantViolations&quot;</span><span class="s0">,</span><span class="s1">&quot;insertAfter&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;self&quot;</span><span class="s0">,</span><span class="s1">&quot;isPattern&quot;</span><span class="s0">,</span><span class="s1">&quot;unshift&quot;</span><span class="s0">,</span><span class="s1">&quot;callee&quot;</span><span class="s0">,</span><span class="s1">&quot;isPure&quot;</span><span class="s0">,</span><span class="s1">&quot;isMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;computed&quot;</span><span class="s0">,</span><span class="s1">&quot;temp&quot;</span><span class="s0">,</span><span class="s1">&quot;generateDeclaredUidIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;pushContainer&quot;</span><span class="s0">,</span><span class="s1">&quot;fromIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;incrementBy&quot;</span><span class="s0">,</span><span class="s1">&quot;getCachedPaths&quot;</span><span class="s0">,</span><span class="s1">&quot;hub&quot;</span><span class="s0">,</span><span class="s1">&quot;msg&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;NodePath&quot;</span><span class="s0">,</span><span class="s1">&quot;listKey&quot;</span><span class="s0">,</span><span class="s1">&quot;setContext&quot;</span><span class="s0">,</span><span class="s1">&quot;verifiedNodes&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceWithMultiple&quot;</span><span class="s0">,</span><span class="s1">&quot;exports&quot;</span><span class="s0">,</span><span class="s1">&quot;hoist&quot;</span><span class="s0">,</span><span class="s1">&quot;hoister&quot;</span><span class="s0">,</span><span class="s1">&quot;PathHoister&quot;</span><span class="s0">,</span><span class="s1">&quot;run&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../src/path/modification.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;// This file contains methods that modify the path/node in some ways.</span><span class="s3">\n\n</span><span class="s1">import { getCachedPaths } from </span><span class="s3">\&quot;</span><span class="s1">../cache.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import NodePath from </span><span class="s3">\&quot;</span><span class="s1">./index.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { _getQueueContexts, pushContext, setScope } from </span><span class="s3">\&quot;</span><span class="s1">./context.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { _assertUnremoved } from </span><span class="s3">\&quot;</span><span class="s1">./removal.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">arrowFunctionExpression,</span><span class="s3">\n  </span><span class="s1">assertExpression,</span><span class="s3">\n  </span><span class="s1">assignmentExpression,</span><span class="s3">\n  </span><span class="s1">blockStatement,</span><span class="s3">\n  </span><span class="s1">callExpression,</span><span class="s3">\n  </span><span class="s1">cloneNode,</span><span class="s3">\n  </span><span class="s1">expressionStatement,</span><span class="s3">\n  </span><span class="s1">isAssignmentExpression,</span><span class="s3">\n  </span><span class="s1">isCallExpression,</span><span class="s3">\n  </span><span class="s1">isExportNamedDeclaration,</span><span class="s3">\n  </span><span class="s1">isExpression,</span><span class="s3">\n  </span><span class="s1">isIdentifier,</span><span class="s3">\n  </span><span class="s1">isSequenceExpression,</span><span class="s3">\n  </span><span class="s1">isSuper,</span><span class="s3">\n  </span><span class="s1">thisExpression,</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">@babel/types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type * as t from </span><span class="s3">\&quot;</span><span class="s1">@babel/types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type Scope from </span><span class="s3">\&quot;</span><span class="s1">../scope/index.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Insert the provided nodes before the current one.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">export function insertBefore(</span><span class="s3">\n  </span><span class="s1">this: NodePath,</span><span class="s3">\n  </span><span class="s1">nodes_: t.Node | t.Node[],</span><span class="s3">\n</span><span class="s1">): NodePath[] {</span><span class="s3">\n  </span><span class="s1">_assertUnremoved.call(this);</span><span class="s3">\n\n  </span><span class="s1">const nodes = _verifyNodeList.call(this, nodes_);</span><span class="s3">\n\n  </span><span class="s1">const { parentPath, parent } = this;</span><span class="s3">\n\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">parentPath.isExpressionStatement() ||</span><span class="s3">\n    </span><span class="s1">parentPath.isLabeledStatement() ||</span><span class="s3">\n    </span><span class="s1">// https://github.com/babel/babel/issues/15293</span><span class="s3">\n    </span><span class="s1">// When Babel transforms `export class String { field }`, the class properties plugin will inject the defineProperty</span><span class="s3">\n    </span><span class="s1">// helper, which depends on the builtins e.g. String, Number, Symbol, etc. To prevent them from being shadowed by local</span><span class="s3">\n    </span><span class="s1">// exports, the helper injector replaces the named export into `class _String { field }; export { _String as String }`,</span><span class="s3">\n    </span><span class="s1">// with `parentPath` here changed to the moved ClassDeclaration, causing rare inconsistency between `parent` and `parentPath`.</span><span class="s3">\n    </span><span class="s1">// Here we retrieve the parent type from the `parent` property. This is a temporary fix and we should revisit when</span><span class="s3">\n    </span><span class="s1">// helpers should get injected.</span><span class="s3">\n    </span><span class="s1">isExportNamedDeclaration(parent) ||</span><span class="s3">\n    </span><span class="s1">(parentPath.isExportDefaultDeclaration() &amp;&amp; this.isDeclaration())</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return parentPath.insertBefore(nodes);</span><span class="s3">\n  </span><span class="s1">} else if (</span><span class="s3">\n    </span><span class="s1">(this.isNodeType(</span><span class="s3">\&quot;</span><span class="s1">Expression</span><span class="s3">\&quot;</span><span class="s1">) &amp;&amp; !this.isJSXElement()) ||</span><span class="s3">\n    </span><span class="s1">(parentPath.isForStatement() &amp;&amp; this.key === </span><span class="s3">\&quot;</span><span class="s1">init</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">if (this.node) nodes.push(this.node);</span><span class="s3">\n    </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts): check that nodes is an array of statements</span><span class="s3">\n    </span><span class="s1">return this.replaceExpressionWithStatements(nodes);</span><span class="s3">\n  </span><span class="s1">} else if (Array.isArray(this.container)) {</span><span class="s3">\n    </span><span class="s1">return _containerInsertBefore.call(this, nodes);</span><span class="s3">\n  </span><span class="s1">} else if (this.isStatementOrBlock()) {</span><span class="s3">\n    </span><span class="s1">const node = this.node as t.Statement;</span><span class="s3">\n    </span><span class="s1">const shouldInsertCurrentNode =</span><span class="s3">\n      </span><span class="s1">node &amp;&amp;</span><span class="s3">\n      </span><span class="s1">(!this.isExpressionStatement() ||</span><span class="s3">\n        </span><span class="s1">(node as t.ExpressionStatement).expression != null);</span><span class="s3">\n\n    </span><span class="s1">this.replaceWith(blockStatement(shouldInsertCurrentNode ? [node] : []));</span><span class="s3">\n    </span><span class="s1">return (this as NodePath&lt;t.BlockStatement&gt;).unshiftContainer(</span><span class="s3">\n      \&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">// @ts-expect-error Fixme: refine nodes to t.BlockStatement[</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">] when this is a BlockStatement path</span><span class="s3">\n      </span><span class="s1">nodes,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      \&quot;</span><span class="s1">We don't know what to do with this node type. </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n        \&quot;</span><span class="s1">We were previously a Statement but we can't fit in here?</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function _containerInsert&lt;N extends t.Node&gt;(</span><span class="s3">\n  </span><span class="s1">this: NodePath,</span><span class="s3">\n  </span><span class="s1">from: number,</span><span class="s3">\n  </span><span class="s1">nodes: N[],</span><span class="s3">\n</span><span class="s1">): NodePath&lt;N&gt;[] {</span><span class="s3">\n  </span><span class="s1">updateSiblingKeys.call(this, from, nodes.length);</span><span class="s3">\n\n  </span><span class="s1">const paths: NodePath&lt;N&gt;[] = [];</span><span class="s3">\n\n  </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts): this.container could be a NodePath</span><span class="s3">\n  </span><span class="s1">this.container.splice(from, 0, ...nodes);</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; nodes.length; i++) {</span><span class="s3">\n    </span><span class="s1">const to = from + i;</span><span class="s3">\n    </span><span class="s1">const path = this.getSibling(to) as NodePath&lt;N&gt;;</span><span class="s3">\n    </span><span class="s1">paths.push(path);</span><span class="s3">\n\n    </span><span class="s1">if (this.context?.queue) {</span><span class="s3">\n      </span><span class="s1">pushContext.call(path, this.context);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const contexts = _getQueueContexts.call(this);</span><span class="s3">\n\n  </span><span class="s1">for (const path of paths) {</span><span class="s3">\n    </span><span class="s1">setScope.call(path);</span><span class="s3">\n    </span><span class="s1">path.debug(</span><span class="s3">\&quot;</span><span class="s1">Inserted.</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n    </span><span class="s1">for (const context of contexts) {</span><span class="s3">\n      </span><span class="s1">context.maybeQueue(path, true);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return paths;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function _containerInsertBefore&lt;N extends t.Node&gt;(</span><span class="s3">\n  </span><span class="s1">this: NodePath,</span><span class="s3">\n  </span><span class="s1">nodes: N[],</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">return _containerInsert.call(this, this.key as number, nodes);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function _containerInsertAfter&lt;N extends t.Node&gt;(</span><span class="s3">\n  </span><span class="s1">this: NodePath,</span><span class="s3">\n  </span><span class="s1">nodes: N[],</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">return _containerInsert.call(this, (this.key as number) + 1, nodes);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const last = &lt;T&gt;(arr: T[]) =&gt; arr[arr.length - 1];</span><span class="s3">\n\n</span><span class="s1">function isHiddenInSequenceExpression(path: NodePath): boolean {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">isSequenceExpression(path.parent) &amp;&amp;</span><span class="s3">\n    </span><span class="s1">(last(path.parent.expressions) !== path.node ||</span><span class="s3">\n      </span><span class="s1">isHiddenInSequenceExpression(path.parentPath))</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function isAlmostConstantAssignment(</span><span class="s3">\n  </span><span class="s1">node: t.Node,</span><span class="s3">\n  </span><span class="s1">scope: Scope,</span><span class="s3">\n</span><span class="s1">): node is t.AssignmentExpression &amp; { left: t.Identifier } {</span><span class="s3">\n  </span><span class="s1">if (!isAssignmentExpression(node) || !isIdentifier(node.left)) {</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Not every scope can contain variables. For example, we might be in</span><span class="s3">\n  </span><span class="s1">// a ClassScope either in the ClassHeritage or in a computed key.</span><span class="s3">\n  </span><span class="s1">const blockScope = scope.getBlockParent();</span><span class="s3">\n\n  </span><span class="s1">// If the variable is defined in the current scope and only assigned here,</span><span class="s3">\n  </span><span class="s1">// we can be sure that its value won't change.</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">blockScope.hasOwnBinding(node.left.name) &amp;&amp;</span><span class="s3">\n    </span><span class="s1">blockScope.getOwnBinding(node.left.name).constantViolations.length &lt;= 1</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Insert the provided nodes after the current one. When inserting nodes after an</span><span class="s3">\n </span><span class="s1">* expression, ensure that the completion record is correct by pushing the current node.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">export function insertAfter(</span><span class="s3">\n  </span><span class="s1">this: NodePath,</span><span class="s3">\n  </span><span class="s1">nodes_: t.Node | t.Node[],</span><span class="s3">\n</span><span class="s1">): NodePath[] {</span><span class="s3">\n  </span><span class="s1">_assertUnremoved.call(this);</span><span class="s3">\n\n  </span><span class="s1">if (this.isSequenceExpression()) {</span><span class="s3">\n    </span><span class="s1">return last(this.get(</span><span class="s3">\&quot;</span><span class="s1">expressions</span><span class="s3">\&quot;</span><span class="s1">)).insertAfter(nodes_);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const nodes = _verifyNodeList.call(this, nodes_);</span><span class="s3">\n\n  </span><span class="s1">const { parentPath, parent } = this;</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">parentPath.isExpressionStatement() ||</span><span class="s3">\n    </span><span class="s1">parentPath.isLabeledStatement() ||</span><span class="s3">\n    </span><span class="s1">// see insertBefore</span><span class="s3">\n    </span><span class="s1">isExportNamedDeclaration(parent) ||</span><span class="s3">\n    </span><span class="s1">(parentPath.isExportDefaultDeclaration() &amp;&amp; this.isDeclaration())</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return parentPath.insertAfter(</span><span class="s3">\n      </span><span class="s1">nodes.map(node =&gt; {</span><span class="s3">\n        </span><span class="s1">// Usually after an expression we can safely insert another expression:</span><span class="s3">\n        </span><span class="s1">//   A.insertAfter(B)</span><span class="s3">\n        </span><span class="s1">//     foo = A;  -&gt; foo = (A, B);</span><span class="s3">\n        </span><span class="s1">// If A is an expression statement, it isn't safe anymore so we need to</span><span class="s3">\n        </span><span class="s1">// convert B to an expression statement</span><span class="s3">\n        </span><span class="s1">//     A;        -&gt; A; B // No semicolon! It could break if followed by [!</span><span class="s3">\n        </span><span class="s1">return isExpression(node) ? expressionStatement(node) : node;</span><span class="s3">\n      </span><span class="s1">}),</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">} else if (</span><span class="s3">\n    </span><span class="s1">(this.isNodeType(</span><span class="s3">\&quot;</span><span class="s1">Expression</span><span class="s3">\&quot;</span><span class="s1">) &amp;&amp;</span><span class="s3">\n      </span><span class="s1">!this.isJSXElement() &amp;&amp;</span><span class="s3">\n      </span><span class="s1">!parentPath.isJSXElement()) ||</span><span class="s3">\n    </span><span class="s1">(parentPath.isForStatement() &amp;&amp; this.key === </span><span class="s3">\&quot;</span><span class="s1">init</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">const self = this as NodePath&lt;t.Expression | t.VariableDeclaration&gt;;</span><span class="s3">\n    </span><span class="s1">if (self.node) {</span><span class="s3">\n      </span><span class="s1">const node = self.node;</span><span class="s3">\n      </span><span class="s1">let { scope } = this;</span><span class="s3">\n\n      </span><span class="s1">if (scope.path.isPattern()) {</span><span class="s3">\n        </span><span class="s1">assertExpression(node);</span><span class="s3">\n\n        </span><span class="s1">self.replaceWith(callExpression(arrowFunctionExpression([], node), []));</span><span class="s3">\n        </span><span class="s1">(self.get(</span><span class="s3">\&quot;</span><span class="s1">callee.body</span><span class="s3">\&quot;</span><span class="s1">) as NodePath&lt;t.Expression&gt;).insertAfter(nodes);</span><span class="s3">\n        </span><span class="s1">return [self];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (isHiddenInSequenceExpression(self)) {</span><span class="s3">\n        </span><span class="s1">nodes.unshift(node);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">// We need to preserve the value of this expression.</span><span class="s3">\n      </span><span class="s1">else if (isCallExpression(node) &amp;&amp; isSuper(node.callee)) {</span><span class="s3">\n        </span><span class="s1">nodes.unshift(node);</span><span class="s3">\n        </span><span class="s1">// `super(...)` always evaluates to `this`.</span><span class="s3">\n        </span><span class="s1">nodes.push(thisExpression());</span><span class="s3">\n      </span><span class="s1">} else if (isAlmostConstantAssignment(node, scope)) {</span><span class="s3">\n        </span><span class="s1">nodes.unshift(node);</span><span class="s3">\n        </span><span class="s1">nodes.push(cloneNode(node.left));</span><span class="s3">\n      </span><span class="s1">} else if (scope.isPure(node, true)) {</span><span class="s3">\n        </span><span class="s1">// Insert the nodes before rather than after; it's not observable.</span><span class="s3">\n        </span><span class="s1">nodes.push(node);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// Inserting after the computed key of a method should insert the</span><span class="s3">\n        </span><span class="s1">// temporary binding in the method's parent's scope.</span><span class="s3">\n        </span><span class="s1">if (parentPath.isMethod({ computed: true, key: node })) {</span><span class="s3">\n          </span><span class="s1">scope = scope.parent;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const temp = scope.generateDeclaredUidIdentifier();</span><span class="s3">\n        </span><span class="s1">nodes.unshift(</span><span class="s3">\n          </span><span class="s1">expressionStatement(</span><span class="s3">\n            </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts): This can be a variable</span><span class="s3">\n            </span><span class="s1">// declaration in the </span><span class="s3">\&quot;</span><span class="s1">init</span><span class="s3">\&quot; </span><span class="s1">of a for statement, but that's</span><span class="s3">\n            </span><span class="s1">// invalid here.</span><span class="s3">\n            </span><span class="s1">assignmentExpression(</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">, cloneNode(temp), node),</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">nodes.push(expressionStatement(cloneNode(temp)));</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts): check that nodes is an array of statements</span><span class="s3">\n    </span><span class="s1">return this.replaceExpressionWithStatements(nodes);</span><span class="s3">\n  </span><span class="s1">} else if (Array.isArray(this.container)) {</span><span class="s3">\n    </span><span class="s1">return _containerInsertAfter.call(this, nodes);</span><span class="s3">\n  </span><span class="s1">} else if (this.isStatementOrBlock()) {</span><span class="s3">\n    </span><span class="s1">const node = this.node as t.Statement;</span><span class="s3">\n    </span><span class="s1">const shouldInsertCurrentNode =</span><span class="s3">\n      </span><span class="s1">node &amp;&amp;</span><span class="s3">\n      </span><span class="s1">(!this.isExpressionStatement() ||</span><span class="s3">\n        </span><span class="s1">(node as t.ExpressionStatement).expression != null);</span><span class="s3">\n\n    </span><span class="s1">this.replaceWith(blockStatement(shouldInsertCurrentNode ? [node] : []));</span><span class="s3">\n    </span><span class="s1">// @ts-expect-error Fixme: refine nodes to t.BlockStatement[</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">] when this is a BlockStatement path</span><span class="s3">\n    </span><span class="s1">return this.pushContainer(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">, nodes);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      \&quot;</span><span class="s1">We don't know what to do with this node type. </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n        \&quot;</span><span class="s1">We were previously a Statement but we can't fit in here?</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Update all sibling node paths after `fromIndex` by `incrementBy`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">export function updateSiblingKeys(</span><span class="s3">\n  </span><span class="s1">this: NodePath,</span><span class="s3">\n  </span><span class="s1">fromIndex: number,</span><span class="s3">\n  </span><span class="s1">incrementBy: number,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">if (!this.parent) return;</span><span class="s3">\n\n  </span><span class="s1">const paths = getCachedPaths(this.hub, this.parent) || ([] as never[]);</span><span class="s3">\n\n  </span><span class="s1">for (const [, path] of paths) {</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">typeof path.key === </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n      </span><span class="s1">path.container === this.container &amp;&amp;</span><span class="s3">\n      </span><span class="s1">path.key &gt;= fromIndex</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">path.key += incrementBy;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function _verifyNodeList&lt;N extends t.Node&gt;(</span><span class="s3">\n  </span><span class="s1">this: NodePath,</span><span class="s3">\n  </span><span class="s1">nodes: N | N[],</span><span class="s3">\n</span><span class="s1">): N[] {</span><span class="s3">\n  </span><span class="s1">if (!nodes) {</span><span class="s3">\n    </span><span class="s1">return [];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (!Array.isArray(nodes)) {</span><span class="s3">\n    </span><span class="s1">nodes = [nodes];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">for (let i = 0; i &lt; nodes.length; i++) {</span><span class="s3">\n    </span><span class="s1">const node = nodes[i];</span><span class="s3">\n    </span><span class="s1">let msg;</span><span class="s3">\n\n    </span><span class="s1">if (!node) {</span><span class="s3">\n      </span><span class="s1">msg = </span><span class="s3">\&quot;</span><span class="s1">has falsy node</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">} else if (typeof node !== </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">msg = </span><span class="s3">\&quot;</span><span class="s1">contains a non-object node</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">} else if (!node.type) {</span><span class="s3">\n      </span><span class="s1">msg = </span><span class="s3">\&quot;</span><span class="s1">without a type</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">} else if (node instanceof NodePath) {</span><span class="s3">\n      </span><span class="s1">msg = </span><span class="s3">\&quot;</span><span class="s1">has a NodePath when it expected a raw object</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (msg) {</span><span class="s3">\n      </span><span class="s1">const type = Array.isArray(node) ? </span><span class="s3">\&quot;</span><span class="s1">array</span><span class="s3">\&quot; </span><span class="s1">: typeof node;</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\n        </span><span class="s1">`Node list ${msg} with the index of ${i} and type of ${type}`,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return nodes;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function unshiftContainer&lt;N extends t.Node, K extends keyof N &amp; string&gt;(</span><span class="s3">\n  </span><span class="s1">this: NodePath&lt;N&gt;,</span><span class="s3">\n  </span><span class="s1">listKey: K,</span><span class="s3">\n  </span><span class="s1">nodes: N[K] extends (infer E)[]</span><span class="s3">\n    </span><span class="s1">? E | E[]</span><span class="s3">\n    </span><span class="s1">: // todo: refine to t.Node[]</span><span class="s3">\n      </span><span class="s1">//  ? E extends t.Node</span><span class="s3">\n      </span><span class="s1">//    ? E | E[]</span><span class="s3">\n      </span><span class="s1">//    : never</span><span class="s3">\n      </span><span class="s1">never,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">// todo: NodePaths&lt;Nodes&gt;</span><span class="s3">\n  </span><span class="s1">_assertUnremoved.call(this);</span><span class="s3">\n\n  </span><span class="s1">// @ts-expect-error fixme</span><span class="s3">\n  </span><span class="s1">nodes = _verifyNodeList.call(this, nodes);</span><span class="s3">\n\n  </span><span class="s1">// get the first path and insert our nodes before it, if it doesn't exist then it</span><span class="s3">\n  </span><span class="s1">// doesn't matter, our nodes will be inserted anyway</span><span class="s3">\n  </span><span class="s1">const path = NodePath.get({</span><span class="s3">\n    </span><span class="s1">parentPath: this,</span><span class="s3">\n    </span><span class="s1">parent: this.node,</span><span class="s3">\n    </span><span class="s1">container: (this.node as N)[listKey] as unknown as t.Node | t.Node[],</span><span class="s3">\n    </span><span class="s1">listKey,</span><span class="s3">\n    </span><span class="s1">key: 0,</span><span class="s3">\n  </span><span class="s1">}).setContext(this.context);</span><span class="s3">\n\n  </span><span class="s1">return _containerInsertBefore.call(</span><span class="s3">\n    </span><span class="s1">path,</span><span class="s3">\n    </span><span class="s1">// @ts-expect-error typings needed to narrow down nodes as t.Node[]</span><span class="s3">\n    </span><span class="s1">nodes,</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function pushContainer&lt;</span><span class="s3">\n  </span><span class="s1">P extends NodePath,</span><span class="s3">\n  </span><span class="s1">K extends string &amp; keyof P[</span><span class="s3">\&quot;</span><span class="s1">node</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n</span><span class="s1">&gt;(</span><span class="s3">\n  </span><span class="s1">this: P,</span><span class="s3">\n  </span><span class="s1">listKey: K,</span><span class="s3">\n  </span><span class="s1">nodes: P[</span><span class="s3">\&quot;</span><span class="s1">node</span><span class="s3">\&quot;</span><span class="s1">][K] extends (infer E)[]</span><span class="s3">\n    </span><span class="s1">? E | E[]</span><span class="s3">\n    </span><span class="s1">: // todo: refine to t.Node[]</span><span class="s3">\n      </span><span class="s1">//  ? E extends t.Node</span><span class="s3">\n      </span><span class="s1">//    ? E | E[]</span><span class="s3">\n      </span><span class="s1">//    : never</span><span class="s3">\n      </span><span class="s1">never,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">_assertUnremoved.call(this);</span><span class="s3">\n\n  </span><span class="s1">const verifiedNodes = _verifyNodeList.call(</span><span class="s3">\n    </span><span class="s1">this,</span><span class="s3">\n    </span><span class="s1">// @ts-expect-error refine typings</span><span class="s3">\n    </span><span class="s1">nodes,</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n\n  </span><span class="s1">// get an invisible path that represents the last node + 1 and replace it with our</span><span class="s3">\n  </span><span class="s1">// nodes, effectively inlining it</span><span class="s3">\n\n  </span><span class="s1">const container = (this.node as P[</span><span class="s3">\&quot;</span><span class="s1">node</span><span class="s3">\&quot;</span><span class="s1">])[listKey] as t.Node[];</span><span class="s3">\n  </span><span class="s1">const path = NodePath.get({</span><span class="s3">\n    </span><span class="s1">parentPath: this,</span><span class="s3">\n    </span><span class="s1">parent: this.node,</span><span class="s3">\n    </span><span class="s1">container: container as unknown as t.Node | t.Node[],</span><span class="s3">\n    </span><span class="s1">listKey,</span><span class="s3">\n    </span><span class="s1">key: container.length,</span><span class="s3">\n  </span><span class="s1">}).setContext(this.context);</span><span class="s3">\n\n  </span><span class="s1">return path.replaceWithMultiple(verifiedNodes);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">import PathHoister from </span><span class="s3">\&quot;</span><span class="s1">./lib/hoister.ts</span><span class="s3">\&quot; </span><span class="s1">with { if: </span><span class="s3">\&quot;</span><span class="s1">!process.env.BABEL_8_BREAKING &amp;&amp; !USE_ESM</span><span class="s3">\&quot; </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">if (!process.env.BABEL_8_BREAKING &amp;&amp; !USE_ESM) {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Hoist the current node to the highest scope possible and return a UID</span><span class="s3">\n   </span><span class="s1">* referencing it.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">// eslint-disable-next-line no-restricted-globals</span><span class="s3">\n  </span><span class="s1">exports.hoist = function hoist&lt;T extends t.Node&gt;(</span><span class="s3">\n    </span><span class="s1">this: NodePath&lt;T&gt;,</span><span class="s3">\n    </span><span class="s1">scope: Scope = this.scope,</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">const hoister = new PathHoister&lt;T&gt;(this, scope);</span><span class="s3">\n    </span><span class="s1">return hoister.run();</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;;;;;AAEA,IAAAA,MAAA,GAAAC,OAAA;AACA,IAAAC,MAAA,GAAAD,OAAA;AACA,IAAAE,QAAA,GAAAF,OAAA;AACA,IAAAG,QAAA,GAAAH,OAAA;AACA,IAAAI,EAAA,GAAAJ,OAAA;AA8YA,IAAAK,QAAA,GAAAL,OAAA;AAAoG;EA7YlGM,uBAAuB;EACvBC,gBAAgB;EAChBC,oBAAoB;EACpBC,cAAc;EACdC,cAAc;EACdC,SAAS;EACTC,mBAAmB;EACnBC,sBAAsB;EACtBC,gBAAgB;EAChBC,wBAAwB;EACxBC,YAAY;EACZC,YAAY;EACZC,oBAAoB;EACpBC,OAAO;EACPC;AAAc,IAAAhB,EAAA;AAST,SAASiB,YAAYA,CAE1BC,MAAyB,EACb;EACZC,yBAAgB,CAACC,IAAI,CAAC,IAAI,CAAC;EAE3B,MAAMC,KAAK,GAAGC,eAAe,CAACF,IAAI,CAAC,IAAI,EAAEF,MAAM,CAAC;EAEhD,MAAM;IAAEK,UAAU;IAAEC;EAAO,CAAC,GAAG,IAAI;EAEnC,IACED,UAAU,CAACE,qBAAqB,CAAC,CAAC,IAClCF,UAAU,CAACG,kBAAkB,CAAC,CAAC,IAQ/Bf,wBAAwB,CAACa,MAAM,CAAC,IAC/BD,UAAU,CAACI,0BAA0B,CAAC,CAAC,IAAI,IAAI,CAACC,aAAa,CAAC,CAAE,EACjE;IACA,OAAOL,UAAU,CAACN,YAAY,CAACI,KAAK,CAAC;EACvC,CAAC,MAAM,IACJ,IAAI,CAACQ,UAAU,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,CAACC,YAAY,CAAC,CAAC,IACrDP,UAAU,CAACQ,cAAc,CAAC,CAAC,IAAI,IAAI,CAACC,GAAG,KAAK,MAAO,EACpD;IACA,IAAI,IAAI,CAACC,IAAI,EAAEZ,KAAK,CAACa,IAAI,CAAC,IAAI,CAACD,IAAI,CAAC;IAEpC,OAAO,IAAI,CAACE,+BAA+B,CAACd,KAAK,CAAC;EACpD,CAAC,MAAM,IAAIe,KAAK,CAACC,OAAO,CAAC,IAAI,CAACC,SAAS,CAAC,EAAE;IACxC,OAAOC,sBAAsB,CAACnB,IAAI,CAAC,IAAI,EAAEC,KAAK,CAAC;EACjD,CAAC,MAAM,IAAI,IAAI,CAACmB,kBAAkB,CAAC,CAAC,EAAE;IACpC,MAAMP,IAAI,GAAG,IAAI,CAACA,IAAmB;IACrC,MAAMQ,uBAAuB,GAC3BR,IAAI,KACH,CAAC,IAAI,CAACR,qBAAqB,CAAC,CAAC,IAC3BQ,IAAI,CAA2BS,UAAU,IAAI,IAAI,CAAC;IAEvD,IAAI,CAACC,WAAW,CAACtC,cAAc,CAACoC,uBAAuB,GAAG,CAACR,IAAI,CAAC,GAAG,EAAE,CAAC,CAAC;IACvE,OAAQ,IAAI,CAAgCW,gBAAgB,CAC1D,MAAM,EAENvB,KACF,CAAC;EACH,CAAC,MAAM;IACL,MAAM,IAAIwB,KAAK,CACb,gDAAgD,GAC9C,0DACJ,CAAC;EACH;AACF;AAEO,SAASC,gBAAgBA,CAE9BC,IAAY,EACZ1B,KAAU,EACK;EACf2B,iBAAiB,CAAC5B,IAAI,CAAC,IAAI,EAAE2B,IAAI,EAAE1B,KAAK,CAAC4B,MAAM,CAAC;EAEhD,MAAMC,KAAoB,GAAG,EAAE;EAG/B,IAAI,CAACZ,SAAS,CAACa,MAAM,CAACJ,IAAI,EAAE,CAAC,EAAE,GAAG1B,KAAK,CAAC;EACxC,KAAK,IAAI+B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG/B,KAAK,CAAC4B,MAAM,EAAEG,CAAC,EAAE,EAAE;IAAA,IAAAC,aAAA;IACrC,MAAMC,EAAE,GAAGP,IAAI,GAAGK,CAAC;IACnB,MAAMG,IAAI,GAAG,IAAI,CAACC,UAAU,CAACF,EAAE,CAAgB;IAC/CJ,KAAK,CAAChB,IAAI,CAACqB,IAAI,CAAC;IAEhB,KAAAF,aAAA,GAAI,IAAI,CAACI,OAAO,aAAZJ,aAAA,CAAcK,KAAK,EAAE;MACvBC,oBAAW,CAACvC,IAAI,CAACmC,IAAI,EAAE,IAAI,CAACE,OAAO,CAAC;IACtC;EACF;EAEA,MAAMG,QAAQ,GAAGC,0BAAiB,CAACzC,IAAI,CAAC,IAAI,CAAC;EAE7C,KAAK,MAAMmC,IAAI,IAAIL,KAAK,EAAE;IACxBY,iBAAQ,CAAC1C,IAAI,CAACmC,IAAI,CAAC;IACnBA,IAAI,CAACQ,KAAK,CAAC,WAAW,CAAC;IAEvB,KAAK,MAAMN,OAAO,IAAIG,QAAQ,EAAE;MAC9BH,OAAO,CAACO,UAAU,CAACT,IAAI,EAAE,IAAI,CAAC;IAChC;EACF;EAEA,OAAOL,KAAK;AACd;AAEO,SAASX,sBAAsBA,CAEpClB,KAAU,EACV;EACA,OAAOyB,gBAAgB,CAAC1B,IAAI,CAAC,IAAI,EAAE,IAAI,CAACY,GAAG,EAAYX,KAAK,CAAC;AAC/D;AAEO,SAAS4C,qBAAqBA,CAEnC5C,KAAU,EACV;EACA,OAAOyB,gBAAgB,CAAC1B,IAAI,CAAC,IAAI,EAAG,IAAI,CAACY,GAAG,GAAc,CAAC,EAAEX,KAAK,CAAC;AACrE;AAEA,MAAM6C,IAAI,GAAOC,GAAQ,IAAKA,GAAG,CAACA,GAAG,CAAClB,MAAM,GAAG,CAAC,CAAC;AAEjD,SAASmB,4BAA4BA,CAACb,IAAc,EAAW;EAC7D,OACEzC,oBAAoB,CAACyC,IAAI,CAAC/B,MAAM,CAAC,KAChC0C,IAAI,CAACX,IAAI,CAAC/B,MAAM,CAAC6C,WAAW,CAAC,KAAKd,IAAI,CAACtB,IAAI,IAC1CmC,4BAA4B,CAACb,IAAI,CAAChC,UAAU,CAAC,CAAC;AAEpD;AAEA,SAAS+C,0BAA0BA,CACjCrC,IAAY,EACZsC,KAAY,EAC6C;EACzD,IAAI,CAAC9D,sBAAsB,CAACwB,IAAI,CAAC,IAAI,CAACpB,YAAY,CAACoB,IAAI,CAACuC,IAAI,CAAC,EAAE;IAC7D,OAAO,KAAK;EACd;EAIA,MAAMC,UAAU,GAAGF,KAAK,CAACG,cAAc,CAAC,CAAC;EAIzC,OACED,UAAU,CAACE,aAAa,CAAC1C,IAAI,CAACuC,IAAI,CAACI,IAAI,CAAC,IACxCH,UAAU,CAACI,aAAa,CAAC5C,IAAI,CAACuC,IAAI,CAACI,IAAI,CAAC,CAACE,kBAAkB,CAAC7B,MAAM,IAAI,CAAC;AAE3E;AAOO,SAAS8B,WAAWA,CAEzB7D,MAAyB,EACb;EACZC,yBAAgB,CAACC,IAAI,CAAC,IAAI,CAAC;EAE3B,IAAI,IAAI,CAACN,oBAAoB,CAAC,CAAC,EAAE;IAC/B,OAAOoD,IAAI,CAAC,IAAI,CAACc,GAAG,CAAC,aAAa,CAAC,CAAC,CAACD,WAAW,CAAC7D,MAAM,CAAC;EAC1D;EAEA,MAAMG,KAAK,GAAGC,eAAe,CAACF,IAAI,CAAC,IAAI,EAAEF,MAAM,CAAC;EAEhD,MAAM;IAAEK,UAAU;IAAEC;EAAO,CAAC,GAAG,IAAI;EACnC,IACED,UAAU,CAACE,qBAAqB,CAAC,CAAC,IAClCF,UAAU,CAACG,kBAAkB,CAAC,CAAC,IAE/Bf,wBAAwB,CAACa,MAAM,CAAC,IAC/BD,UAAU,CAACI,0BAA0B,CAAC,CAAC,IAAI,IAAI,CAACC,aAAa,CAAC,CAAE,EACjE;IACA,OAAOL,UAAU,CAACwD,WAAW,CAC3B1D,KAAK,CAAC4D,GAAG,CAAChD,IAAI,IAAI;MAOhB,OAAOrB,YAAY,CAACqB,IAAI,CAAC,GAAGzB,mBAAmB,CAACyB,IAAI,CAAC,GAAGA,IAAI;IAC9D,CAAC,CACH,CAAC;EACH,CAAC,MAAM,IACJ,IAAI,CAACJ,UAAU,CAAC,YAAY,CAAC,IAC5B,CAAC,IAAI,CAACC,YAAY,CAAC,CAAC,IACpB,CAACP,UAAU,CAACO,YAAY,CAAC,CAAC,IAC3BP,UAAU,CAACQ,cAAc,CAAC,CAAC,IAAI,IAAI,CAACC,GAAG,KAAK,MAAO,EACpD;IACA,MAAMkD,IAAI,GAAG,IAAsD;IACnE,IAAIA,IAAI,CAACjD,IAAI,EAAE;MACb,MAAMA,IAAI,GAAGiD,IAAI,CAACjD,IAAI;MACtB,IAAI;QAAEsC;MAAM,CAAC,GAAG,IAAI;MAEpB,IAAIA,KAAK,CAAChB,IAAI,CAAC4B,SAAS,CAAC,CAAC,EAAE;QAC1BhF,gBAAgB,CAAC8B,IAAI,CAAC;QAEtBiD,IAAI,CAACvC,WAAW,CAACrC,cAAc,CAACJ,uBAAuB,CAAC,EAAE,EAAE+B,IAAI,CAAC,EAAE,EAAE,CAAC,CAAC;QACtEiD,IAAI,CAACF,GAAG,CAAC,aAAa,CAAC,CAA4BD,WAAW,CAAC1D,KAAK,CAAC;QACtE,OAAO,CAAC6D,IAAI,CAAC;MACf;MAEA,IAAId,4BAA4B,CAACc,IAAI,CAAC,EAAE;QACtC7D,KAAK,CAAC+D,OAAO,CAACnD,IAAI,CAAC;MACrB,CAAC,MAEI,IAAIvB,gBAAgB,CAACuB,IAAI,CAAC,IAAIlB,OAAO,CAACkB,IAAI,CAACoD,MAAM,CAAC,EAAE;QACvDhE,KAAK,CAAC+D,OAAO,CAACnD,IAAI,CAAC;QAEnBZ,KAAK,CAACa,IAAI,CAAClB,cAAc,CAAC,CAAC,CAAC;MAC9B,CAAC,MAAM,IAAIsD,0BAA0B,CAACrC,IAAI,EAAEsC,KAAK,CAAC,EAAE;QAClDlD,KAAK,CAAC+D,OAAO,CAACnD,IAAI,CAAC;QACnBZ,KAAK,CAACa,IAAI,CAAC3B,SAAS,CAAC0B,IAAI,CAACuC,IAAI,CAAC,CAAC;MAClC,CAAC,MAAM,IAAID,KAAK,CAACe,MAAM,CAACrD,IAAI,EAAE,IAAI,CAAC,EAAE;QAEnCZ,KAAK,CAACa,IAAI,CAACD,IAAI,CAAC;MAClB,CAAC,MAAM;QAGL,IAAIV,UAAU,CAACgE,QAAQ,CAAC;UAAEC,QAAQ,EAAE,IAAI;UAAExD,GAAG,EAAEC;QAAK,CAAC,CAAC,EAAE;UACtDsC,KAAK,GAAGA,KAAK,CAAC/C,MAAM;QACtB;QACA,MAAMiE,IAAI,GAAGlB,KAAK,CAACmB,6BAA6B,CAAC,CAAC;QAClDrE,KAAK,CAAC+D,OAAO,CACX5E,mBAAmB,CAIjBJ,oBAAoB,CAAC,GAAG,EAAEG,SAAS,CAACkF,IAAI,CAAC,EAAExD,IAAI,CACjD,CACF,CAAC;QACDZ,KAAK,CAACa,IAAI,CAAC1B,mBAAmB,CAACD,SAAS,CAACkF,IAAI,CAAC,CAAC,CAAC;MAClD;IACF;IAEA,OAAO,IAAI,CAACtD,+BAA+B,CAACd,KAAK,CAAC;EACpD,CAAC,MAAM,IAAIe,KAAK,CAACC,OAAO,CAAC,IAAI,CAACC,SAAS,CAAC,EAAE;IACxC,OAAO2B,qBAAqB,CAAC7C,IAAI,CAAC,IAAI,EAAEC,KAAK,CAAC;EAChD,CAAC,MAAM,IAAI,IAAI,CAACmB,kBAAkB,CAAC,CAAC,EAAE;IACpC,MAAMP,IAAI,GAAG,IAAI,CAACA,IAAmB;IACrC,MAAMQ,uBAAuB,GAC3BR,IAAI,KACH,CAAC,IAAI,CAACR,qBAAqB,CAAC,CAAC,IAC3BQ,IAAI,CAA2BS,UAAU,IAAI,IAAI,CAAC;IAEvD,IAAI,CAACC,WAAW,CAACtC,cAAc,CAACoC,uBAAuB,GAAG,CAACR,IAAI,CAAC,GAAG,EAAE,CAAC,CAAC;IAEvE,OAAO,IAAI,CAAC0D,aAAa,CAAC,MAAM,EAAEtE,KAAK,CAAC;EAC1C,CAAC,MAAM;IACL,MAAM,IAAIwB,KAAK,CACb,gDAAgD,GAC9C,0DACJ,CAAC;EACH;AACF;AAMO,SAASG,iBAAiBA,CAE/B4C,SAAiB,EACjBC,WAAmB,EACnB;EACA,IAAI,CAAC,IAAI,CAACrE,MAAM,EAAE;EAElB,MAAM0B,KAAK,GAAG,IAAA4C,qBAAc,EAAC,IAAI,CAACC,GAAG,EAAE,IAAI,CAACvE,MAAM,CAAC,IAAK,EAAc;EAEtE,KAAK,MAAM,GAAG+B,IAAI,CAAC,IAAIL,KAAK,EAAE;IAC5B,IACE,OAAOK,IAAI,CAACvB,GAAG,KAAK,QAAQ,IAC5BuB,IAAI,CAACjB,SAAS,KAAK,IAAI,CAACA,SAAS,IACjCiB,IAAI,CAACvB,GAAG,IAAI4D,SAAS,EACrB;MACArC,IAAI,CAACvB,GAAG,IAAI6D,WAAW;IACzB;EACF;AACF;AAEO,SAASvE,eAAeA,CAE7BD,KAAc,EACT;EACL,IAAI,CAACA,KAAK,EAAE;IACV,OAAO,EAAE;EACX;EAEA,IAAI,CAACe,KAAK,CAACC,OAAO,CAAChB,KAAK,CAAC,EAAE;IACzBA,KAAK,GAAG,CAACA,KAAK,CAAC;EACjB;EAEA,KAAK,IAAI+B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG/B,KAAK,CAAC4B,MAAM,EAAEG,CAAC,EAAE,EAAE;IACrC,MAAMnB,IAAI,GAAGZ,KAAK,CAAC+B,CAAC,CAAC;IACrB,IAAI4C,GAAG;IAEP,IAAI,CAAC/D,IAAI,EAAE;MACT+D,GAAG,GAAG,gBAAgB;IACxB,CAAC,MAAM,IAAI,OAAO/D,IAAI,KAAK,QAAQ,EAAE;MACnC+D,GAAG,GAAG,4BAA4B;IACpC,CAAC,MAAM,IAAI,CAAC/D,IAAI,CAACgE,IAAI,EAAE;MACrBD,GAAG,GAAG,gBAAgB;IACxB,CAAC,MAAM,IAAI/D,IAAI,YAAYiE,cAAQ,EAAE;MACnCF,GAAG,GAAG,8CAA8C;IACtD;IAEA,IAAIA,GAAG,EAAE;MACP,MAAMC,IAAI,GAAG7D,KAAK,CAACC,OAAO,CAACJ,IAAI,CAAC,GAAG,OAAO,GAAG,OAAOA,IAAI;MACxD,MAAM,IAAIY,KAAK,CACb,aAAamD,GAAG,sBAAsB5C,CAAC,gBAAgB6C,IAAI,EAC7D,CAAC;IACH;EACF;EAEA,OAAO5E,KAAK;AACd;AAEO,SAASuB,gBAAgBA,CAE9BuD,OAAU,EACV9E,KAMS,EACT;EAEAF,yBAAgB,CAACC,IAAI,CAAC,IAAI,CAAC;EAG3BC,KAAK,GAAGC,eAAe,CAACF,IAAI,CAAC,IAAI,EAAEC,KAAK,CAAC;EAIzC,MAAMkC,IAAI,GAAG2C,cAAQ,CAAClB,GAAG,CAAC;IACxBzD,UAAU,EAAE,IAAI;IAChBC,MAAM,EAAE,IAAI,CAACS,IAAI;IACjBK,SAAS,EAAG,IAAI,CAACL,IAAI,CAAOkE,OAAO,CAAiC;IACpEA,OAAO;IACPnE,GAAG,EAAE;EACP,CAAC,CAAC,CAACoE,UAAU,CAAC,IAAI,CAAC3C,OAAO,CAAC;EAE3B,OAAOlB,sBAAsB,CAACnB,IAAI,CAChCmC,IAAI,EAEJlC,KACF,CAAC;AACH;AAEO,SAASsE,aAAaA,CAK3BQ,OAAU,EACV9E,KAMS,EACT;EACAF,yBAAgB,CAACC,IAAI,CAAC,IAAI,CAAC;EAE3B,MAAMiF,aAAa,GAAG/E,eAAe,CAACF,IAAI,CACxC,IAAI,EAEJC,KACF,CAAC;EAKD,MAAMiB,SAAS,GAAI,IAAI,CAACL,IAAI,CAAekE,OAAO,CAAa;EAC/D,MAAM5C,IAAI,GAAG2C,cAAQ,CAAClB,GAAG,CAAC;IACxBzD,UAAU,EAAE,IAAI;IAChBC,MAAM,EAAE,IAAI,CAACS,IAAI;IACjBK,SAAS,EAAEA,SAAyC;IACpD6D,OAAO;IACPnE,GAAG,EAAEM,SAAS,CAACW;EACjB,CAAC,CAAC,CAACmD,UAAU,CAAC,IAAI,CAAC3C,OAAO,CAAC;EAE3B,OAAOF,IAAI,CAAC+C,mBAAmB,CAACD,aAAa,CAAC;AAChD;AAG+C;EAM7CE,OAAO,CAACC,KAAK,GAAG,SAASA,KAAKA,CAE5BjC,KAAY,GAAG,IAAI,CAACA,KAAK,EACzB;IACA,MAAMkC,OAAO,GAAG,IAAIC,gBAAW,CAAI,IAAI,EAAEnC,KAAK,CAAC;IAC/C,OAAOkC,OAAO,CAACE,GAAG,CAAC,CAAC;EACtB,CAAC;AACH&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[]}</span></pre>
</body>
</html>