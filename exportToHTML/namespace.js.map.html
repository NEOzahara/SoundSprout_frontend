<html>
<head>
<title>namespace.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
namespace.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_core&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;_globalTypes&quot;</span><span class="s0">,</span><span class="s1">&quot;_constEnum&quot;</span><span class="s0">,</span><span class="s1">&quot;getFirstIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;t&quot;</span><span class="s0">,</span><span class="s1">&quot;isIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;left&quot;</span><span class="s0">,</span><span class="s1">&quot;transpileNamespace&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;allowNamespaces&quot;</span><span class="s0">,</span><span class="s1">&quot;declare&quot;</span><span class="s0">,</span><span class="s1">&quot;id&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;remove&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;buildCodeFrameError&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;handleNested&quot;</span><span class="s0">,</span><span class="s1">&quot;program&quot;</span><span class="s0">,</span><span class="s1">&quot;findParent&quot;</span><span class="s0">,</span><span class="s1">&quot;p&quot;</span><span class="s0">,</span><span class="s1">&quot;isProgram&quot;</span><span class="s0">,</span><span class="s1">&quot;registerGlobalType&quot;</span><span class="s0">,</span><span class="s1">&quot;scope&quot;</span><span class="s0">,</span><span class="s1">&quot;hasOwnBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceWith&quot;</span><span class="s0">,</span><span class="s1">&quot;registerDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceWithMultiple&quot;</span><span class="s0">,</span><span class="s1">&quot;getDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;variableDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;variableDeclarator&quot;</span><span class="s0">,</span><span class="s1">&quot;identifier&quot;</span><span class="s0">,</span><span class="s1">&quot;getMemberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;itemName&quot;</span><span class="s0">,</span><span class="s1">&quot;memberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;handleVariableDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;hub&quot;</span><span class="s0">,</span><span class="s1">&quot;kind&quot;</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">,</span><span class="s1">&quot;declarations&quot;</span><span class="s0">,</span><span class="s1">&quot;every&quot;</span><span class="s0">,</span><span class="s1">&quot;declarator&quot;</span><span class="s0">,</span><span class="s1">&quot;init&quot;</span><span class="s0">,</span><span class="s1">&quot;assignmentExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;bindingIdentifiers&quot;</span><span class="s0">,</span><span class="s1">&quot;getBindingIdentifiers&quot;</span><span class="s0">,</span><span class="s1">&quot;assignments&quot;</span><span class="s0">,</span><span class="s1">&quot;idName&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;cloneNode&quot;</span><span class="s0">,</span><span class="s1">&quot;expressionStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;sequenceExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;buildNestedAmbientModuleError&quot;</span><span class="s0">,</span><span class="s1">&quot;buildError&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;parentExport&quot;</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">,</span><span class="s1">&quot;Set&quot;</span><span class="s0">,</span><span class="s1">&quot;realName&quot;</span><span class="s0">,</span><span class="s1">&quot;generateUid&quot;</span><span class="s0">,</span><span class="s1">&quot;body&quot;</span><span class="s0">,</span><span class="s1">&quot;namespaceTopLevel&quot;</span><span class="s0">,</span><span class="s1">&quot;isTSModuleBlock&quot;</span><span class="s0">,</span><span class="s1">&quot;exportNamedDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;isEmpty&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;subNode&quot;</span><span class="s0">,</span><span class="s1">&quot;transformed&quot;</span><span class="s0">,</span><span class="s1">&quot;moduleName&quot;</span><span class="s0">,</span><span class="s1">&quot;has&quot;</span><span class="s0">,</span><span class="s1">&quot;add&quot;</span><span class="s0">,</span><span class="s1">&quot;splice&quot;</span><span class="s0">,</span><span class="s1">&quot;isTypeScript&quot;</span><span class="s0">,</span><span class="s1">&quot;declaration&quot;</span><span class="s0">,</span><span class="s1">&quot;EXPORTED_CONST_ENUMS_IN_NAMESPACE&quot;</span><span class="s0">,</span><span class="s1">&quot;nodes&quot;</span><span class="s0">,</span><span class="s1">&quot;fallthroughValue&quot;</span><span class="s0">,</span><span class="s1">&quot;objectExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;memberExpr&quot;</span><span class="s0">,</span><span class="s1">&quot;template&quot;</span><span class="s0">,</span><span class="s1">&quot;expression&quot;</span><span class="s0">,</span><span class="s1">&quot;ast&quot;</span><span class="s0">,</span><span class="s1">&quot;statement&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../src/namespace.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { template, types as t, type NodePath } from </span><span class="s3">\&quot;</span><span class="s1">@babel/core</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">import { registerGlobalType } from </span><span class="s3">\&quot;</span><span class="s1">./global-types.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { EXPORTED_CONST_ENUMS_IN_NAMESPACE } from </span><span class="s3">\&quot;</span><span class="s1">./const-enum.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">export function getFirstIdentifier(node: t.TSEntityName): t.Identifier {</span><span class="s3">\n  </span><span class="s1">if (t.isIdentifier(node)) {</span><span class="s3">\n    </span><span class="s1">return node;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// In Babel 8 TSEntityName also includes ThisExpression, however, a namespace</span><span class="s3">\n  </span><span class="s1">// id must not be a ThisExpression or a TSQualifiedName { left: ThisExpression }.</span><span class="s3">\n  </span><span class="s1">// eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion</span><span class="s3">\n  </span><span class="s1">return getFirstIdentifier((node as t.TSQualifiedName).left);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default function transpileNamespace(</span><span class="s3">\n  </span><span class="s1">path: NodePath&lt;t.TSModuleDeclaration&gt;,</span><span class="s3">\n  </span><span class="s1">allowNamespaces: boolean,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">if (path.node.declare || path.node.id.type === </span><span class="s3">\&quot;</span><span class="s1">StringLiteral</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">path.remove();</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (!allowNamespaces) {</span><span class="s3">\n    </span><span class="s1">throw path</span><span class="s3">\n      </span><span class="s1">.get(</span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">.buildCodeFrameError(</span><span class="s3">\n        \&quot;</span><span class="s1">Namespace not marked type-only declare.</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n          \&quot; </span><span class="s1">Non-declarative namespaces are only supported experimentally in Babel.</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n          \&quot; </span><span class="s1">To enable and review caveats see:</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n          \&quot; </span><span class="s1">https://babeljs.io/docs/en/babel-plugin-transform-typescript</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const name = getFirstIdentifier(path.node.id).name;</span><span class="s3">\n  </span><span class="s1">const value = handleNested(path, path.node);</span><span class="s3">\n  </span><span class="s1">if (value === null) {</span><span class="s3">\n    </span><span class="s1">// This means that `path` is a type-only namespace.</span><span class="s3">\n    </span><span class="s1">// We call `registerGlobalType` here to allow it to be stripped.</span><span class="s3">\n    </span><span class="s1">const program = path.findParent(p =&gt; p.isProgram());</span><span class="s3">\n    </span><span class="s1">registerGlobalType(program.scope, name);</span><span class="s3">\n\n    </span><span class="s1">path.remove();</span><span class="s3">\n  </span><span class="s1">} else if (path.scope.hasOwnBinding(name)) {</span><span class="s3">\n    </span><span class="s1">path.replaceWith(value);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">path.scope.registerDeclaration(</span><span class="s3">\n      </span><span class="s1">path.replaceWithMultiple([getDeclaration(name), value])[0],</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function getDeclaration(name: string) {</span><span class="s3">\n  </span><span class="s1">return t.variableDeclaration(</span><span class="s3">\&quot;</span><span class="s1">let</span><span class="s3">\&quot;</span><span class="s1">, [</span><span class="s3">\n    </span><span class="s1">t.variableDeclarator(t.identifier(name)),</span><span class="s3">\n  </span><span class="s1">]);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function getMemberExpression(name: string, itemName: string) {</span><span class="s3">\n  </span><span class="s1">return t.memberExpression(t.identifier(name), t.identifier(itemName));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Convert export const foo = 1 to Namespace.foo = 1;</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {t.VariableDeclaration} node given variable declaration, e.g. `const foo = 1`</span><span class="s3">\n </span><span class="s1">* @param {string} name the generated unique namespace member name</span><span class="s3">\n </span><span class="s1">* @param {*} hub An instance implements HubInterface defined in `@babel/traverse` that can throw a code frame error</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function handleVariableDeclaration(</span><span class="s3">\n  </span><span class="s1">node: t.VariableDeclaration,</span><span class="s3">\n  </span><span class="s1">name: string,</span><span class="s3">\n  </span><span class="s1">hub: any,</span><span class="s3">\n</span><span class="s1">): t.Statement[] {</span><span class="s3">\n  </span><span class="s1">if (node.kind !== </span><span class="s3">\&quot;</span><span class="s1">const</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">throw hub.file.buildCodeFrameError(</span><span class="s3">\n      </span><span class="s1">node,</span><span class="s3">\n      \&quot;</span><span class="s1">Namespaces exporting non-const are not supported by Babel.</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n        \&quot; </span><span class="s1">Change to const or see:</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n        \&quot; </span><span class="s1">https://babeljs.io/docs/en/babel-plugin-transform-typescript</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const { declarations } = node;</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">declarations.every(</span><span class="s3">\n      </span><span class="s1">(declarator): declarator is t.VariableDeclarator &amp; { id: t.Identifier } =&gt;</span><span class="s3">\n        </span><span class="s1">t.isIdentifier(declarator.id),</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">// `export const a = 1` transforms to `const a = N.a = 1`, the output</span><span class="s3">\n    </span><span class="s1">// is smaller than `const a = 1; N.a = a`;</span><span class="s3">\n    </span><span class="s1">for (const declarator of declarations) {</span><span class="s3">\n      </span><span class="s1">declarator.init = t.assignmentExpression(</span><span class="s3">\n        \&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">getMemberExpression(name, declarator.id.name),</span><span class="s3">\n        </span><span class="s1">declarator.init,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return [node];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// Now we have pattern in declarators</span><span class="s3">\n  </span><span class="s1">// `export const [a] = 1` transforms to `const [a] = 1; N.a = a`</span><span class="s3">\n  </span><span class="s1">const bindingIdentifiers = t.getBindingIdentifiers(node);</span><span class="s3">\n  </span><span class="s1">const assignments = [];</span><span class="s3">\n  </span><span class="s1">// getBindingIdentifiers returns an object without prototype.</span><span class="s3">\n  </span><span class="s1">// eslint-disable-next-line guard-for-in</span><span class="s3">\n  </span><span class="s1">for (const idName in bindingIdentifiers) {</span><span class="s3">\n    </span><span class="s1">assignments.push(</span><span class="s3">\n      </span><span class="s1">t.assignmentExpression(</span><span class="s3">\n        \&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">getMemberExpression(name, idName),</span><span class="s3">\n        </span><span class="s1">t.cloneNode(bindingIdentifiers[idName]),</span><span class="s3">\n      </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return [node, t.expressionStatement(t.sequenceExpression(assignments))];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function buildNestedAmbientModuleError(path: NodePath, node: t.Node) {</span><span class="s3">\n  </span><span class="s1">return path.hub.buildError(</span><span class="s3">\n    </span><span class="s1">node,</span><span class="s3">\n    \&quot;</span><span class="s1">Ambient modules cannot be nested in other modules or namespaces.</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">Error,</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function handleNested(</span><span class="s3">\n  </span><span class="s1">path: NodePath,</span><span class="s3">\n  </span><span class="s1">node: t.TSModuleDeclaration,</span><span class="s3">\n  </span><span class="s1">parentExport?: t.Expression,</span><span class="s3">\n</span><span class="s1">): t.Statement | null {</span><span class="s3">\n  </span><span class="s1">const names = new Set();</span><span class="s3">\n  </span><span class="s1">const realName =</span><span class="s3">\n    </span><span class="s1">!process.env.BABEL_8_BREAKING || t.isIdentifier(node.id)</span><span class="s3">\n      </span><span class="s1">? (node.id as t.Identifier)</span><span class="s3">\n      </span><span class="s1">: getFirstIdentifier(node.id as unknown as t.TSQualifiedName);</span><span class="s3">\n\n  </span><span class="s1">const name = path.scope.generateUid(realName.name);</span><span class="s3">\n\n  </span><span class="s1">const body = node.body;</span><span class="s3">\n  </span><span class="s1">let id = node.id;</span><span class="s3">\n  </span><span class="s1">let namespaceTopLevel: t.Statement[];</span><span class="s3">\n  </span><span class="s1">if (process.env.BABEL_8_BREAKING) {</span><span class="s3">\n    </span><span class="s1">if (t.isTSQualifiedName(id)) {</span><span class="s3">\n      </span><span class="s1">// @ts-ignore(Babel 7 vs Babel 8) Babel 8 AST shape</span><span class="s3">\n      </span><span class="s1">namespaceTopLevel = body.body;</span><span class="s3">\n      </span><span class="s1">while (t.isTSQualifiedName(id)) {</span><span class="s3">\n        </span><span class="s1">namespaceTopLevel = [</span><span class="s3">\n          </span><span class="s1">t.exportNamedDeclaration(</span><span class="s3">\n            </span><span class="s1">t.tsModuleDeclaration(</span><span class="s3">\n              </span><span class="s1">// @ts-ignore(Babel 7 vs Babel 8) Babel 8 AST shape</span><span class="s3">\n              </span><span class="s1">t.cloneNode(id.right),</span><span class="s3">\n              </span><span class="s1">t.tsModuleBlock(namespaceTopLevel),</span><span class="s3">\n            </span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">];</span><span class="s3">\n\n        </span><span class="s1">// @ts-ignore(Babel 7 vs Babel 8) Babel 8 AST shape</span><span class="s3">\n        </span><span class="s1">id = id.left;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// @ts-ignore(Babel 7 vs Babel 8) Babel 8 AST shape</span><span class="s3">\n      </span><span class="s1">namespaceTopLevel = body.body;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">namespaceTopLevel = t.isTSModuleBlock(body)</span><span class="s3">\n      </span><span class="s1">? body.body</span><span class="s3">\n      </span><span class="s1">: // We handle `namespace X.Y {}` as if it was</span><span class="s3">\n        </span><span class="s1">//   namespace X {</span><span class="s3">\n        </span><span class="s1">//     export namespace Y {}</span><span class="s3">\n        </span><span class="s1">//   }</span><span class="s3">\n        </span><span class="s1">[t.exportNamedDeclaration(body)];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let isEmpty = true;</span><span class="s3">\n\n  </span><span class="s1">for (let i = 0; i &lt; namespaceTopLevel.length; i++) {</span><span class="s3">\n    </span><span class="s1">const subNode = namespaceTopLevel[i];</span><span class="s3">\n\n    </span><span class="s1">// The first switch is mainly to detect name usage. Only export</span><span class="s3">\n    </span><span class="s1">// declarations require further transformation.</span><span class="s3">\n    </span><span class="s1">switch (subNode.type) {</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">TSModuleDeclaration</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">if (!t.isIdentifier(subNode.id)) {</span><span class="s3">\n          </span><span class="s1">throw buildNestedAmbientModuleError(path, subNode);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">const transformed = handleNested(path, subNode);</span><span class="s3">\n        </span><span class="s1">if (transformed !== null) {</span><span class="s3">\n          </span><span class="s1">isEmpty = false;</span><span class="s3">\n          </span><span class="s1">const moduleName = subNode.id.name;</span><span class="s3">\n          </span><span class="s1">if (names.has(moduleName)) {</span><span class="s3">\n            </span><span class="s1">namespaceTopLevel[i] = transformed;</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">names.add(moduleName);</span><span class="s3">\n            </span><span class="s1">namespaceTopLevel.splice(</span><span class="s3">\n              </span><span class="s1">i++,</span><span class="s3">\n              </span><span class="s1">1,</span><span class="s3">\n              </span><span class="s1">getDeclaration(moduleName),</span><span class="s3">\n              </span><span class="s1">transformed,</span><span class="s3">\n            </span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">continue;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">TSEnumDeclaration</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">FunctionDeclaration</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ClassDeclaration</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">isEmpty = false;</span><span class="s3">\n        </span><span class="s1">names.add(subNode.id.name);</span><span class="s3">\n        </span><span class="s1">continue;</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">VariableDeclaration</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">isEmpty = false;</span><span class="s3">\n        </span><span class="s1">// getBindingIdentifiers returns an object without prototype.</span><span class="s3">\n        </span><span class="s1">// eslint-disable-next-line guard-for-in</span><span class="s3">\n        </span><span class="s1">for (const name in t.getBindingIdentifiers(subNode)) {</span><span class="s3">\n          </span><span class="s1">names.add(name);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">continue;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">default:</span><span class="s3">\n        </span><span class="s1">isEmpty &amp;&amp;= t.isTypeScript(subNode);</span><span class="s3">\n        </span><span class="s1">// Neither named declaration nor export, continue to next item.</span><span class="s3">\n        </span><span class="s1">continue;</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ExportNamedDeclaration</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">// Export declarations get parsed using the next switch.</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\&quot;</span><span class="s1">declare</span><span class="s3">\&quot; </span><span class="s1">in subNode.declaration &amp;&amp; subNode.declaration.declare) {</span><span class="s3">\n      </span><span class="s1">continue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Transform the export declarations that occur inside of a namespace.</span><span class="s3">\n    </span><span class="s1">switch (subNode.declaration.type) {</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">TSEnumDeclaration</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">EXPORTED_CONST_ENUMS_IN_NAMESPACE.add(subNode.declaration);</span><span class="s3">\n      </span><span class="s1">// fallthrough</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">FunctionDeclaration</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ClassDeclaration</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">isEmpty = false;</span><span class="s3">\n        </span><span class="s1">const itemName = subNode.declaration.id.name;</span><span class="s3">\n        </span><span class="s1">names.add(itemName);</span><span class="s3">\n        </span><span class="s1">namespaceTopLevel.splice(</span><span class="s3">\n          </span><span class="s1">i++,</span><span class="s3">\n          </span><span class="s1">1,</span><span class="s3">\n          </span><span class="s1">subNode.declaration,</span><span class="s3">\n          </span><span class="s1">t.expressionStatement(</span><span class="s3">\n            </span><span class="s1">t.assignmentExpression(</span><span class="s3">\n              \&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n              </span><span class="s1">getMemberExpression(name, itemName),</span><span class="s3">\n              </span><span class="s1">t.identifier(itemName),</span><span class="s3">\n            </span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">VariableDeclaration</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">isEmpty = false;</span><span class="s3">\n        </span><span class="s1">const nodes = handleVariableDeclaration(</span><span class="s3">\n          </span><span class="s1">subNode.declaration,</span><span class="s3">\n          </span><span class="s1">name,</span><span class="s3">\n          </span><span class="s1">path.hub,</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">namespaceTopLevel.splice(i, nodes.length, ...nodes);</span><span class="s3">\n        </span><span class="s1">i += nodes.length - 1;</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">TSModuleDeclaration</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">if (!t.isIdentifier(subNode.declaration.id)) {</span><span class="s3">\n          </span><span class="s1">throw buildNestedAmbientModuleError(path, subNode.declaration);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">const transformed = handleNested(</span><span class="s3">\n          </span><span class="s1">path,</span><span class="s3">\n          </span><span class="s1">subNode.declaration,</span><span class="s3">\n          </span><span class="s1">t.identifier(name),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">if (transformed !== null) {</span><span class="s3">\n          </span><span class="s1">isEmpty = false;</span><span class="s3">\n          </span><span class="s1">const moduleName = subNode.declaration.id.name;</span><span class="s3">\n          </span><span class="s1">if (names.has(moduleName)) {</span><span class="s3">\n            </span><span class="s1">namespaceTopLevel[i] = transformed;</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">names.add(moduleName);</span><span class="s3">\n            </span><span class="s1">namespaceTopLevel.splice(</span><span class="s3">\n              </span><span class="s1">i++,</span><span class="s3">\n              </span><span class="s1">1,</span><span class="s3">\n              </span><span class="s1">getDeclaration(moduleName),</span><span class="s3">\n              </span><span class="s1">transformed,</span><span class="s3">\n            </span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">namespaceTopLevel.splice(i, 1);</span><span class="s3">\n          </span><span class="s1">i--;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (isEmpty) return null;</span><span class="s3">\n\n  </span><span class="s1">// {}</span><span class="s3">\n  </span><span class="s1">let fallthroughValue: t.Expression = t.objectExpression([]);</span><span class="s3">\n\n  </span><span class="s1">if (parentExport) {</span><span class="s3">\n    </span><span class="s1">const memberExpr = t.memberExpression(parentExport, realName);</span><span class="s3">\n    </span><span class="s1">fallthroughValue = template.expression.ast`</span><span class="s3">\n      </span><span class="s1">${t.cloneNode(memberExpr)} ||</span><span class="s3">\n        </span><span class="s1">(${t.cloneNode(memberExpr)} = ${fallthroughValue})</span><span class="s3">\n    </span><span class="s1">`;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return template.statement.ast`</span><span class="s3">\n    </span><span class="s1">(function (${t.identifier(name)}) {</span><span class="s3">\n      </span><span class="s1">${namespaceTopLevel}</span><span class="s3">\n    </span><span class="s1">})(${realName} || (${t.cloneNode(realName)} = ${fallthroughValue}));</span><span class="s3">\n  </span><span class="s1">`;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[]}</span></pre>
</body>
</html>