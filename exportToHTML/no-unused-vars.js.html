<html>
<head>
<title>no-unused-vars.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #67a37c; font-style: italic;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #bcbec4;}
.s5 { color: #7a7e85;}
.s6 { color: #cf8e6d;}
.s7 { color: #42c3d4;}
.s8 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
no-unused-vars.js</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* </span><span class="s1">@fileoverview </span><span class="s0">Rule to flag declared but unused variables</span>
 <span class="s0">* </span><span class="s1">@author </span><span class="s0">Ilya Volodin</span>
 <span class="s0">*/</span>

<span class="s3">&quot;use strict&quot;</span><span class="s4">;</span>

<span class="s5">//------------------------------------------------------------------------------</span>
<span class="s5">// Requirements</span>
<span class="s5">//------------------------------------------------------------------------------</span>

<span class="s6">const </span><span class="s2">astUtils </span><span class="s4">= </span><span class="s2">require</span><span class="s4">(</span><span class="s3">&quot;./utils/ast-utils&quot;</span><span class="s4">);</span>

<span class="s5">//------------------------------------------------------------------------------</span>
<span class="s5">// Typedefs</span>
<span class="s5">//------------------------------------------------------------------------------</span>

<span class="s0">/**</span>
 <span class="s0">* Bag of data used for formatting the `unusedVar` lint message.</span>
 <span class="s0">* </span><span class="s1">@typedef </span><span class="s0">{Object} UnusedVarMessageData</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{string} varName The name of the unused var.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{'defined'|'assigned a value'} action Description of the vars state.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{string} additional Any additional info to be appended at the end.</span>
 <span class="s0">*/</span>

<span class="s5">//------------------------------------------------------------------------------</span>
<span class="s5">// Rule Definition</span>
<span class="s5">//------------------------------------------------------------------------------</span>

<span class="s0">/** </span><span class="s1">@type </span><span class="s0">{import('../shared/types').Rule} */</span>
<span class="s2">module</span><span class="s4">.</span><span class="s2">exports </span><span class="s4">= {</span>
    <span class="s2">meta</span><span class="s4">: {</span>
        <span class="s2">type</span><span class="s4">: </span><span class="s3">&quot;problem&quot;</span><span class="s4">,</span>

        <span class="s2">docs</span><span class="s4">: {</span>
            <span class="s2">description</span><span class="s4">: </span><span class="s3">&quot;Disallow unused variables&quot;</span><span class="s4">,</span>
            <span class="s2">recommended</span><span class="s4">: </span><span class="s6">true</span><span class="s4">,</span>
            <span class="s2">url</span><span class="s4">: </span><span class="s3">&quot;https://eslint.org/docs/latest/rules/no-unused-vars&quot;</span>
        <span class="s4">},</span>

        <span class="s2">schema</span><span class="s4">: [</span>
            <span class="s4">{</span>
                <span class="s2">oneOf</span><span class="s4">: [</span>
                    <span class="s4">{</span>
                        <span class="s6">enum</span><span class="s4">: [</span><span class="s3">&quot;all&quot;</span><span class="s4">, </span><span class="s3">&quot;local&quot;</span><span class="s4">]</span>
                    <span class="s4">},</span>
                    <span class="s4">{</span>
                        <span class="s2">type</span><span class="s4">: </span><span class="s3">&quot;object&quot;</span><span class="s4">,</span>
                        <span class="s2">properties</span><span class="s4">: {</span>
                            <span class="s2">vars</span><span class="s4">: {</span>
                                <span class="s6">enum</span><span class="s4">: [</span><span class="s3">&quot;all&quot;</span><span class="s4">, </span><span class="s3">&quot;local&quot;</span><span class="s4">]</span>
                            <span class="s4">},</span>
                            <span class="s2">varsIgnorePattern</span><span class="s4">: {</span>
                                <span class="s2">type</span><span class="s4">: </span><span class="s3">&quot;string&quot;</span>
                            <span class="s4">},</span>
                            <span class="s2">args</span><span class="s4">: {</span>
                                <span class="s6">enum</span><span class="s4">: [</span><span class="s3">&quot;all&quot;</span><span class="s4">, </span><span class="s3">&quot;after-used&quot;</span><span class="s4">, </span><span class="s3">&quot;none&quot;</span><span class="s4">]</span>
                            <span class="s4">},</span>
                            <span class="s2">ignoreRestSiblings</span><span class="s4">: {</span>
                                <span class="s2">type</span><span class="s4">: </span><span class="s3">&quot;boolean&quot;</span>
                            <span class="s4">},</span>
                            <span class="s2">argsIgnorePattern</span><span class="s4">: {</span>
                                <span class="s2">type</span><span class="s4">: </span><span class="s3">&quot;string&quot;</span>
                            <span class="s4">},</span>
                            <span class="s2">caughtErrors</span><span class="s4">: {</span>
                                <span class="s6">enum</span><span class="s4">: [</span><span class="s3">&quot;all&quot;</span><span class="s4">, </span><span class="s3">&quot;none&quot;</span><span class="s4">]</span>
                            <span class="s4">},</span>
                            <span class="s2">caughtErrorsIgnorePattern</span><span class="s4">: {</span>
                                <span class="s2">type</span><span class="s4">: </span><span class="s3">&quot;string&quot;</span>
                            <span class="s4">},</span>
                            <span class="s2">destructuredArrayIgnorePattern</span><span class="s4">: {</span>
                                <span class="s2">type</span><span class="s4">: </span><span class="s3">&quot;string&quot;</span>
                            <span class="s4">}</span>
                        <span class="s4">},</span>
                        <span class="s2">additionalProperties</span><span class="s4">: </span><span class="s6">false</span>
                    <span class="s4">}</span>
                <span class="s4">]</span>
            <span class="s4">}</span>
        <span class="s4">],</span>

        <span class="s2">messages</span><span class="s4">: {</span>
            <span class="s2">unusedVar</span><span class="s4">: </span><span class="s3">&quot;'{{varName}}' is {{action}} but never used{{additional}}.&quot;</span>
        <span class="s4">}</span>
    <span class="s4">},</span>

    <span class="s2">create</span><span class="s4">(</span><span class="s2">context</span><span class="s4">) {</span>
        <span class="s6">const </span><span class="s2">sourceCode </span><span class="s4">= </span><span class="s2">context</span><span class="s4">.</span><span class="s2">sourceCode</span><span class="s4">;</span>

        <span class="s6">const </span><span class="s2">REST_PROPERTY_TYPE </span><span class="s4">= </span><span class="s7">/^(?:RestElement|(?:Experimental)?RestProperty)$/u</span><span class="s4">;</span>

        <span class="s6">const </span><span class="s2">config </span><span class="s4">= {</span>
            <span class="s2">vars</span><span class="s4">: </span><span class="s3">&quot;all&quot;</span><span class="s4">,</span>
            <span class="s2">args</span><span class="s4">: </span><span class="s3">&quot;after-used&quot;</span><span class="s4">,</span>
            <span class="s2">ignoreRestSiblings</span><span class="s4">: </span><span class="s6">false</span><span class="s4">,</span>
            <span class="s2">caughtErrors</span><span class="s4">: </span><span class="s3">&quot;none&quot;</span>
        <span class="s4">};</span>

        <span class="s6">const </span><span class="s2">firstOption </span><span class="s4">= </span><span class="s2">context</span><span class="s4">.</span><span class="s2">options</span><span class="s4">[</span><span class="s8">0</span><span class="s4">];</span>

        <span class="s6">if </span><span class="s4">(</span><span class="s2">firstOption</span><span class="s4">) {</span>
            <span class="s6">if </span><span class="s4">(</span><span class="s6">typeof </span><span class="s2">firstOption </span><span class="s4">=== </span><span class="s3">&quot;string&quot;</span><span class="s4">) {</span>
                <span class="s2">config</span><span class="s4">.</span><span class="s2">vars </span><span class="s4">= </span><span class="s2">firstOption</span><span class="s4">;</span>
            <span class="s4">} </span><span class="s6">else </span><span class="s4">{</span>
                <span class="s2">config</span><span class="s4">.</span><span class="s2">vars </span><span class="s4">= </span><span class="s2">firstOption</span><span class="s4">.</span><span class="s2">vars </span><span class="s4">|| </span><span class="s2">config</span><span class="s4">.</span><span class="s2">vars</span><span class="s4">;</span>
                <span class="s2">config</span><span class="s4">.</span><span class="s2">args </span><span class="s4">= </span><span class="s2">firstOption</span><span class="s4">.</span><span class="s2">args </span><span class="s4">|| </span><span class="s2">config</span><span class="s4">.</span><span class="s2">args</span><span class="s4">;</span>
                <span class="s2">config</span><span class="s4">.</span><span class="s2">ignoreRestSiblings </span><span class="s4">= </span><span class="s2">firstOption</span><span class="s4">.</span><span class="s2">ignoreRestSiblings </span><span class="s4">|| </span><span class="s2">config</span><span class="s4">.</span><span class="s2">ignoreRestSiblings</span><span class="s4">;</span>
                <span class="s2">config</span><span class="s4">.</span><span class="s2">caughtErrors </span><span class="s4">= </span><span class="s2">firstOption</span><span class="s4">.</span><span class="s2">caughtErrors </span><span class="s4">|| </span><span class="s2">config</span><span class="s4">.</span><span class="s2">caughtErrors</span><span class="s4">;</span>

                <span class="s6">if </span><span class="s4">(</span><span class="s2">firstOption</span><span class="s4">.</span><span class="s2">varsIgnorePattern</span><span class="s4">) {</span>
                    <span class="s2">config</span><span class="s4">.</span><span class="s2">varsIgnorePattern </span><span class="s4">= </span><span class="s6">new </span><span class="s2">RegExp</span><span class="s4">(</span><span class="s2">firstOption</span><span class="s4">.</span><span class="s2">varsIgnorePattern</span><span class="s4">, </span><span class="s3">&quot;u&quot;</span><span class="s4">);</span>
                <span class="s4">}</span>

                <span class="s6">if </span><span class="s4">(</span><span class="s2">firstOption</span><span class="s4">.</span><span class="s2">argsIgnorePattern</span><span class="s4">) {</span>
                    <span class="s2">config</span><span class="s4">.</span><span class="s2">argsIgnorePattern </span><span class="s4">= </span><span class="s6">new </span><span class="s2">RegExp</span><span class="s4">(</span><span class="s2">firstOption</span><span class="s4">.</span><span class="s2">argsIgnorePattern</span><span class="s4">, </span><span class="s3">&quot;u&quot;</span><span class="s4">);</span>
                <span class="s4">}</span>

                <span class="s6">if </span><span class="s4">(</span><span class="s2">firstOption</span><span class="s4">.</span><span class="s2">caughtErrorsIgnorePattern</span><span class="s4">) {</span>
                    <span class="s2">config</span><span class="s4">.</span><span class="s2">caughtErrorsIgnorePattern </span><span class="s4">= </span><span class="s6">new </span><span class="s2">RegExp</span><span class="s4">(</span><span class="s2">firstOption</span><span class="s4">.</span><span class="s2">caughtErrorsIgnorePattern</span><span class="s4">, </span><span class="s3">&quot;u&quot;</span><span class="s4">);</span>
                <span class="s4">}</span>

                <span class="s6">if </span><span class="s4">(</span><span class="s2">firstOption</span><span class="s4">.</span><span class="s2">destructuredArrayIgnorePattern</span><span class="s4">) {</span>
                    <span class="s2">config</span><span class="s4">.</span><span class="s2">destructuredArrayIgnorePattern </span><span class="s4">= </span><span class="s6">new </span><span class="s2">RegExp</span><span class="s4">(</span><span class="s2">firstOption</span><span class="s4">.</span><span class="s2">destructuredArrayIgnorePattern</span><span class="s4">, </span><span class="s3">&quot;u&quot;</span><span class="s4">);</span>
                <span class="s4">}</span>
            <span class="s4">}</span>
        <span class="s4">}</span>

        <span class="s0">/**</span>
         <span class="s0">* Generates the message data about the variable being defined and unused,</span>
         <span class="s0">* including the ignore pattern if configured.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Variable} unusedVar eslint-scope variable object.</span>
         <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{UnusedVarMessageData} The message data to be used with this unused variable.</span>
         <span class="s0">*/</span>
        <span class="s6">function </span><span class="s2">getDefinedMessageData</span><span class="s4">(</span><span class="s2">unusedVar</span><span class="s4">) {</span>
            <span class="s6">const </span><span class="s2">defType </span><span class="s4">= </span><span class="s2">unusedVar</span><span class="s4">.</span><span class="s2">defs </span><span class="s4">&amp;&amp; </span><span class="s2">unusedVar</span><span class="s4">.</span><span class="s2">defs</span><span class="s4">[</span><span class="s8">0</span><span class="s4">] &amp;&amp; </span><span class="s2">unusedVar</span><span class="s4">.</span><span class="s2">defs</span><span class="s4">[</span><span class="s8">0</span><span class="s4">].</span><span class="s2">type</span><span class="s4">;</span>
            <span class="s6">let </span><span class="s2">type</span><span class="s4">;</span>
            <span class="s6">let </span><span class="s2">pattern</span><span class="s4">;</span>

            <span class="s6">if </span><span class="s4">(</span><span class="s2">defType </span><span class="s4">=== </span><span class="s3">&quot;CatchClause&quot; </span><span class="s4">&amp;&amp; </span><span class="s2">config</span><span class="s4">.</span><span class="s2">caughtErrorsIgnorePattern</span><span class="s4">) {</span>
                <span class="s2">type </span><span class="s4">= </span><span class="s3">&quot;args&quot;</span><span class="s4">;</span>
                <span class="s2">pattern </span><span class="s4">= </span><span class="s2">config</span><span class="s4">.</span><span class="s2">caughtErrorsIgnorePattern</span><span class="s4">.</span><span class="s2">toString</span><span class="s4">();</span>
            <span class="s4">} </span><span class="s6">else if </span><span class="s4">(</span><span class="s2">defType </span><span class="s4">=== </span><span class="s3">&quot;Parameter&quot; </span><span class="s4">&amp;&amp; </span><span class="s2">config</span><span class="s4">.</span><span class="s2">argsIgnorePattern</span><span class="s4">) {</span>
                <span class="s2">type </span><span class="s4">= </span><span class="s3">&quot;args&quot;</span><span class="s4">;</span>
                <span class="s2">pattern </span><span class="s4">= </span><span class="s2">config</span><span class="s4">.</span><span class="s2">argsIgnorePattern</span><span class="s4">.</span><span class="s2">toString</span><span class="s4">();</span>
            <span class="s4">} </span><span class="s6">else if </span><span class="s4">(</span><span class="s2">defType </span><span class="s4">!== </span><span class="s3">&quot;Parameter&quot; </span><span class="s4">&amp;&amp; </span><span class="s2">config</span><span class="s4">.</span><span class="s2">varsIgnorePattern</span><span class="s4">) {</span>
                <span class="s2">type </span><span class="s4">= </span><span class="s3">&quot;vars&quot;</span><span class="s4">;</span>
                <span class="s2">pattern </span><span class="s4">= </span><span class="s2">config</span><span class="s4">.</span><span class="s2">varsIgnorePattern</span><span class="s4">.</span><span class="s2">toString</span><span class="s4">();</span>
            <span class="s4">}</span>

            <span class="s6">const </span><span class="s2">additional </span><span class="s4">= </span><span class="s2">type </span><span class="s4">? </span><span class="s3">`. Allowed unused </span><span class="s2">$</span><span class="s4">{</span><span class="s2">type</span><span class="s4">} </span><span class="s3">must match </span><span class="s2">$</span><span class="s4">{</span><span class="s2">pattern</span><span class="s4">}</span><span class="s3">` </span><span class="s4">: </span><span class="s3">&quot;&quot;</span><span class="s4">;</span>

            <span class="s6">return </span><span class="s4">{</span>
                <span class="s2">varName</span><span class="s4">: </span><span class="s2">unusedVar</span><span class="s4">.</span><span class="s2">name</span><span class="s4">,</span>
                <span class="s2">action</span><span class="s4">: </span><span class="s3">&quot;defined&quot;</span><span class="s4">,</span>
                <span class="s2">additional</span>
            <span class="s4">};</span>
        <span class="s4">}</span>

        <span class="s0">/**</span>
         <span class="s0">* Generate the warning message about the variable being</span>
         <span class="s0">* assigned and unused, including the ignore pattern if configured.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Variable} unusedVar eslint-scope variable object.</span>
         <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{UnusedVarMessageData} The message data to be used with this unused variable.</span>
         <span class="s0">*/</span>
        <span class="s6">function </span><span class="s2">getAssignedMessageData</span><span class="s4">(</span><span class="s2">unusedVar</span><span class="s4">) {</span>
            <span class="s6">const </span><span class="s2">def </span><span class="s4">= </span><span class="s2">unusedVar</span><span class="s4">.</span><span class="s2">defs</span><span class="s4">[</span><span class="s8">0</span><span class="s4">];</span>
            <span class="s6">let </span><span class="s2">additional </span><span class="s4">= </span><span class="s3">&quot;&quot;</span><span class="s4">;</span>

            <span class="s6">if </span><span class="s4">(</span><span class="s2">config</span><span class="s4">.</span><span class="s2">destructuredArrayIgnorePattern </span><span class="s4">&amp;&amp; </span><span class="s2">def </span><span class="s4">&amp;&amp; </span><span class="s2">def</span><span class="s4">.</span><span class="s2">name</span><span class="s4">.</span><span class="s2">parent</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;ArrayPattern&quot;</span><span class="s4">) {</span>
                <span class="s2">additional </span><span class="s4">= </span><span class="s3">`. Allowed unused elements of array destructuring patterns must match </span><span class="s2">$</span><span class="s4">{</span><span class="s2">config</span><span class="s4">.</span><span class="s2">destructuredArrayIgnorePattern</span><span class="s4">.</span><span class="s2">toString</span><span class="s4">()}</span><span class="s3">`</span><span class="s4">;</span>
            <span class="s4">} </span><span class="s6">else if </span><span class="s4">(</span><span class="s2">config</span><span class="s4">.</span><span class="s2">varsIgnorePattern</span><span class="s4">) {</span>
                <span class="s2">additional </span><span class="s4">= </span><span class="s3">`. Allowed unused vars must match </span><span class="s2">$</span><span class="s4">{</span><span class="s2">config</span><span class="s4">.</span><span class="s2">varsIgnorePattern</span><span class="s4">.</span><span class="s2">toString</span><span class="s4">()}</span><span class="s3">`</span><span class="s4">;</span>
            <span class="s4">}</span>

            <span class="s6">return </span><span class="s4">{</span>
                <span class="s2">varName</span><span class="s4">: </span><span class="s2">unusedVar</span><span class="s4">.</span><span class="s2">name</span><span class="s4">,</span>
                <span class="s2">action</span><span class="s4">: </span><span class="s3">&quot;assigned a value&quot;</span><span class="s4">,</span>
                <span class="s2">additional</span>
            <span class="s4">};</span>
        <span class="s4">}</span>

        <span class="s5">//--------------------------------------------------------------------------</span>
        <span class="s5">// Helpers</span>
        <span class="s5">//--------------------------------------------------------------------------</span>

        <span class="s6">const </span><span class="s2">STATEMENT_TYPE </span><span class="s4">= </span><span class="s7">/(?:Statement|Declaration)$/u</span><span class="s4">;</span>

        <span class="s0">/**</span>
         <span class="s0">* Determines if a given variable is being exported from a module.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Variable} variable eslint-scope variable object.</span>
         <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} True if the variable is exported, false if not.</span>
         <span class="s0">* </span><span class="s1">@private</span>
         <span class="s0">*/</span>
        <span class="s6">function </span><span class="s2">isExported</span><span class="s4">(</span><span class="s2">variable</span><span class="s4">) {</span>

            <span class="s6">const </span><span class="s2">definition </span><span class="s4">= </span><span class="s2">variable</span><span class="s4">.</span><span class="s2">defs</span><span class="s4">[</span><span class="s8">0</span><span class="s4">];</span>

            <span class="s6">if </span><span class="s4">(</span><span class="s2">definition</span><span class="s4">) {</span>

                <span class="s6">let </span><span class="s2">node </span><span class="s4">= </span><span class="s2">definition</span><span class="s4">.</span><span class="s2">node</span><span class="s4">;</span>

                <span class="s6">if </span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;VariableDeclarator&quot;</span><span class="s4">) {</span>
                    <span class="s2">node </span><span class="s4">= </span><span class="s2">node</span><span class="s4">.</span><span class="s2">parent</span><span class="s4">;</span>
                <span class="s4">} </span><span class="s6">else if </span><span class="s4">(</span><span class="s2">definition</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;Parameter&quot;</span><span class="s4">) {</span>
                    <span class="s6">return false</span><span class="s4">;</span>
                <span class="s4">}</span>

                <span class="s6">return </span><span class="s2">node</span><span class="s4">.</span><span class="s2">parent</span><span class="s4">.</span><span class="s2">type</span><span class="s4">.</span><span class="s2">indexOf</span><span class="s4">(</span><span class="s3">&quot;Export&quot;</span><span class="s4">) === </span><span class="s8">0</span><span class="s4">;</span>
            <span class="s4">}</span>
            <span class="s6">return false</span><span class="s4">;</span>

        <span class="s4">}</span>

        <span class="s0">/**</span>
         <span class="s0">* Checks whether a node is a sibling of the rest property or not.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node a node to check</span>
         <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} True if the node is a sibling of the rest property, otherwise false.</span>
         <span class="s0">*/</span>
        <span class="s6">function </span><span class="s2">hasRestSibling</span><span class="s4">(</span><span class="s2">node</span><span class="s4">) {</span>
            <span class="s6">return </span><span class="s2">node</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;Property&quot; </span><span class="s4">&amp;&amp;</span>
                <span class="s2">node</span><span class="s4">.</span><span class="s2">parent</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;ObjectPattern&quot; </span><span class="s4">&amp;&amp;</span>
                <span class="s2">REST_PROPERTY_TYPE</span><span class="s4">.</span><span class="s2">test</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">parent</span><span class="s4">.</span><span class="s2">properties</span><span class="s4">[</span><span class="s2">node</span><span class="s4">.</span><span class="s2">parent</span><span class="s4">.</span><span class="s2">properties</span><span class="s4">.</span><span class="s2">length </span><span class="s4">- </span><span class="s8">1</span><span class="s4">].</span><span class="s2">type</span><span class="s4">);</span>
        <span class="s4">}</span>

        <span class="s0">/**</span>
         <span class="s0">* Determines if a variable has a sibling rest property</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Variable} variable eslint-scope variable object.</span>
         <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} True if the variable is exported, false if not.</span>
         <span class="s0">* </span><span class="s1">@private</span>
         <span class="s0">*/</span>
        <span class="s6">function </span><span class="s2">hasRestSpreadSibling</span><span class="s4">(</span><span class="s2">variable</span><span class="s4">) {</span>
            <span class="s6">if </span><span class="s4">(</span><span class="s2">config</span><span class="s4">.</span><span class="s2">ignoreRestSiblings</span><span class="s4">) {</span>
                <span class="s6">const </span><span class="s2">hasRestSiblingDefinition </span><span class="s4">= </span><span class="s2">variable</span><span class="s4">.</span><span class="s2">defs</span><span class="s4">.</span><span class="s2">some</span><span class="s4">(</span><span class="s2">def </span><span class="s4">=&gt; </span><span class="s2">hasRestSibling</span><span class="s4">(</span><span class="s2">def</span><span class="s4">.</span><span class="s2">name</span><span class="s4">.</span><span class="s2">parent</span><span class="s4">));</span>
                <span class="s6">const </span><span class="s2">hasRestSiblingReference </span><span class="s4">= </span><span class="s2">variable</span><span class="s4">.</span><span class="s2">references</span><span class="s4">.</span><span class="s2">some</span><span class="s4">(</span><span class="s2">ref </span><span class="s4">=&gt; </span><span class="s2">hasRestSibling</span><span class="s4">(</span><span class="s2">ref</span><span class="s4">.</span><span class="s2">identifier</span><span class="s4">.</span><span class="s2">parent</span><span class="s4">));</span>

                <span class="s6">return </span><span class="s2">hasRestSiblingDefinition </span><span class="s4">|| </span><span class="s2">hasRestSiblingReference</span><span class="s4">;</span>
            <span class="s4">}</span>

            <span class="s6">return false</span><span class="s4">;</span>
        <span class="s4">}</span>

        <span class="s0">/**</span>
         <span class="s0">* Determines if a reference is a read operation.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Reference} ref An eslint-scope Reference</span>
         <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} whether the given reference represents a read operation</span>
         <span class="s0">* </span><span class="s1">@private</span>
         <span class="s0">*/</span>
        <span class="s6">function </span><span class="s2">isReadRef</span><span class="s4">(</span><span class="s2">ref</span><span class="s4">) {</span>
            <span class="s6">return </span><span class="s2">ref</span><span class="s4">.</span><span class="s2">isRead</span><span class="s4">();</span>
        <span class="s4">}</span>

        <span class="s0">/**</span>
         <span class="s0">* Determine if an identifier is referencing an enclosing function name.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Reference} ref The reference to check.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode[]} nodes The candidate function nodes.</span>
         <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} True if it's a self-reference, false if not.</span>
         <span class="s0">* </span><span class="s1">@private</span>
         <span class="s0">*/</span>
        <span class="s6">function </span><span class="s2">isSelfReference</span><span class="s4">(</span><span class="s2">ref</span><span class="s4">, </span><span class="s2">nodes</span><span class="s4">) {</span>
            <span class="s6">let </span><span class="s2">scope </span><span class="s4">= </span><span class="s2">ref</span><span class="s4">.</span><span class="s2">from</span><span class="s4">;</span>

            <span class="s6">while </span><span class="s4">(</span><span class="s2">scope</span><span class="s4">) {</span>
                <span class="s6">if </span><span class="s4">(</span><span class="s2">nodes</span><span class="s4">.</span><span class="s2">includes</span><span class="s4">(</span><span class="s2">scope</span><span class="s4">.</span><span class="s2">block</span><span class="s4">)) {</span>
                    <span class="s6">return true</span><span class="s4">;</span>
                <span class="s4">}</span>

                <span class="s2">scope </span><span class="s4">= </span><span class="s2">scope</span><span class="s4">.</span><span class="s2">upper</span><span class="s4">;</span>
            <span class="s4">}</span>

            <span class="s6">return false</span><span class="s4">;</span>
        <span class="s4">}</span>

        <span class="s0">/**</span>
         <span class="s0">* Gets a list of function definitions for a specified variable.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Variable} variable eslint-scope variable object.</span>
         <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{ASTNode[]} Function nodes.</span>
         <span class="s0">* </span><span class="s1">@private</span>
         <span class="s0">*/</span>
        <span class="s6">function </span><span class="s2">getFunctionDefinitions</span><span class="s4">(</span><span class="s2">variable</span><span class="s4">) {</span>
            <span class="s6">const </span><span class="s2">functionDefinitions </span><span class="s4">= [];</span>

            <span class="s2">variable</span><span class="s4">.</span><span class="s2">defs</span><span class="s4">.</span><span class="s2">forEach</span><span class="s4">(</span><span class="s2">def </span><span class="s4">=&gt; {</span>
                <span class="s6">const </span><span class="s4">{ </span><span class="s2">type</span><span class="s4">, </span><span class="s2">node </span><span class="s4">} = </span><span class="s2">def</span><span class="s4">;</span>

                <span class="s5">// FunctionDeclarations</span>
                <span class="s6">if </span><span class="s4">(</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;FunctionName&quot;</span><span class="s4">) {</span>
                    <span class="s2">functionDefinitions</span><span class="s4">.</span><span class="s2">push</span><span class="s4">(</span><span class="s2">node</span><span class="s4">);</span>
                <span class="s4">}</span>

                <span class="s5">// FunctionExpressions</span>
                <span class="s6">if </span><span class="s4">(</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;Variable&quot; </span><span class="s4">&amp;&amp; </span><span class="s2">node</span><span class="s4">.</span><span class="s2">init </span><span class="s4">&amp;&amp;</span>
                    <span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">init</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;FunctionExpression&quot; </span><span class="s4">|| </span><span class="s2">node</span><span class="s4">.</span><span class="s2">init</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;ArrowFunctionExpression&quot;</span><span class="s4">)) {</span>
                    <span class="s2">functionDefinitions</span><span class="s4">.</span><span class="s2">push</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">init</span><span class="s4">);</span>
                <span class="s4">}</span>
            <span class="s4">});</span>
            <span class="s6">return </span><span class="s2">functionDefinitions</span><span class="s4">;</span>
        <span class="s4">}</span>

        <span class="s0">/**</span>
         <span class="s0">* Checks the position of given nodes.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} inner A node which is expected as inside.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} outer A node which is expected as outside.</span>
         <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} `true` if the `inner` node exists in the `outer` node.</span>
         <span class="s0">* </span><span class="s1">@private</span>
         <span class="s0">*/</span>
        <span class="s6">function </span><span class="s2">isInside</span><span class="s4">(</span><span class="s2">inner</span><span class="s4">, </span><span class="s2">outer</span><span class="s4">) {</span>
            <span class="s6">return </span><span class="s4">(</span>
                <span class="s2">inner</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s8">0</span><span class="s4">] &gt;= </span><span class="s2">outer</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s8">0</span><span class="s4">] &amp;&amp;</span>
                <span class="s2">inner</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s8">1</span><span class="s4">] &lt;= </span><span class="s2">outer</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s8">1</span><span class="s4">]</span>
            <span class="s4">);</span>
        <span class="s4">}</span>

        <span class="s0">/**</span>
         <span class="s0">* Checks whether a given node is unused expression or not.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The node itself</span>
         <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} The node is an unused expression.</span>
         <span class="s0">* </span><span class="s1">@private</span>
         <span class="s0">*/</span>
        <span class="s6">function </span><span class="s2">isUnusedExpression</span><span class="s4">(</span><span class="s2">node</span><span class="s4">) {</span>
            <span class="s6">const </span><span class="s2">parent </span><span class="s4">= </span><span class="s2">node</span><span class="s4">.</span><span class="s2">parent</span><span class="s4">;</span>

            <span class="s6">if </span><span class="s4">(</span><span class="s2">parent</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;ExpressionStatement&quot;</span><span class="s4">) {</span>
                <span class="s6">return true</span><span class="s4">;</span>
            <span class="s4">}</span>

            <span class="s6">if </span><span class="s4">(</span><span class="s2">parent</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;SequenceExpression&quot;</span><span class="s4">) {</span>
                <span class="s6">const </span><span class="s2">isLastExpression </span><span class="s4">= </span><span class="s2">parent</span><span class="s4">.</span><span class="s2">expressions</span><span class="s4">[</span><span class="s2">parent</span><span class="s4">.</span><span class="s2">expressions</span><span class="s4">.</span><span class="s2">length </span><span class="s4">- </span><span class="s8">1</span><span class="s4">] === </span><span class="s2">node</span><span class="s4">;</span>

                <span class="s6">if </span><span class="s4">(!</span><span class="s2">isLastExpression</span><span class="s4">) {</span>
                    <span class="s6">return true</span><span class="s4">;</span>
                <span class="s4">}</span>
                <span class="s6">return </span><span class="s2">isUnusedExpression</span><span class="s4">(</span><span class="s2">parent</span><span class="s4">);</span>
            <span class="s4">}</span>

            <span class="s6">return false</span><span class="s4">;</span>
        <span class="s4">}</span>

        <span class="s0">/**</span>
         <span class="s0">* If a given reference is left-hand side of an assignment, this gets</span>
         <span class="s0">* the right-hand side node of the assignment.</span>
         <span class="s0">*</span>
         <span class="s0">* In the following cases, this returns null.</span>
         <span class="s0">*</span>
         <span class="s0">* - The reference is not the LHS of an assignment expression.</span>
         <span class="s0">* - The reference is inside of a loop.</span>
         <span class="s0">* - The reference is inside of a function scope which is different from</span>
         <span class="s0">*   the declaration.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">{eslint-scope.Reference} ref A reference to check.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} prevRhsNode The previous RHS node.</span>
         <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{ASTNode|null} The RHS node or null.</span>
         <span class="s0">* </span><span class="s1">@private</span>
         <span class="s0">*/</span>
        <span class="s6">function </span><span class="s2">getRhsNode</span><span class="s4">(</span><span class="s2">ref</span><span class="s4">, </span><span class="s2">prevRhsNode</span><span class="s4">) {</span>
            <span class="s6">const </span><span class="s2">id </span><span class="s4">= </span><span class="s2">ref</span><span class="s4">.</span><span class="s2">identifier</span><span class="s4">;</span>
            <span class="s6">const </span><span class="s2">parent </span><span class="s4">= </span><span class="s2">id</span><span class="s4">.</span><span class="s2">parent</span><span class="s4">;</span>
            <span class="s6">const </span><span class="s2">refScope </span><span class="s4">= </span><span class="s2">ref</span><span class="s4">.</span><span class="s2">from</span><span class="s4">.</span><span class="s2">variableScope</span><span class="s4">;</span>
            <span class="s6">const </span><span class="s2">varScope </span><span class="s4">= </span><span class="s2">ref</span><span class="s4">.</span><span class="s2">resolved</span><span class="s4">.</span><span class="s2">scope</span><span class="s4">.</span><span class="s2">variableScope</span><span class="s4">;</span>
            <span class="s6">const </span><span class="s2">canBeUsedLater </span><span class="s4">= </span><span class="s2">refScope </span><span class="s4">!== </span><span class="s2">varScope </span><span class="s4">|| </span><span class="s2">astUtils</span><span class="s4">.</span><span class="s2">isInLoop</span><span class="s4">(</span><span class="s2">id</span><span class="s4">);</span>

            <span class="s5">/* 
             * Inherits the previous node if this reference is in the node. 
             * This is for `a = a + a`-like code. 
             */</span>
            <span class="s6">if </span><span class="s4">(</span><span class="s2">prevRhsNode </span><span class="s4">&amp;&amp; </span><span class="s2">isInside</span><span class="s4">(</span><span class="s2">id</span><span class="s4">, </span><span class="s2">prevRhsNode</span><span class="s4">)) {</span>
                <span class="s6">return </span><span class="s2">prevRhsNode</span><span class="s4">;</span>
            <span class="s4">}</span>

            <span class="s6">if </span><span class="s4">(</span><span class="s2">parent</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;AssignmentExpression&quot; </span><span class="s4">&amp;&amp;</span>
                <span class="s2">isUnusedExpression</span><span class="s4">(</span><span class="s2">parent</span><span class="s4">) &amp;&amp;</span>
                <span class="s2">id </span><span class="s4">=== </span><span class="s2">parent</span><span class="s4">.</span><span class="s2">left </span><span class="s4">&amp;&amp;</span>
                <span class="s4">!</span><span class="s2">canBeUsedLater</span>
            <span class="s4">) {</span>
                <span class="s6">return </span><span class="s2">parent</span><span class="s4">.</span><span class="s2">right</span><span class="s4">;</span>
            <span class="s4">}</span>
            <span class="s6">return null</span><span class="s4">;</span>
        <span class="s4">}</span>

        <span class="s0">/**</span>
         <span class="s0">* Checks whether a given function node is stored to somewhere or not.</span>
         <span class="s0">* If the function node is stored, the function can be used later.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} funcNode A function node to check.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} rhsNode The RHS node of the previous assignment.</span>
         <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} `true` if under the following conditions:</span>
         <span class="s0">*      - the funcNode is assigned to a variable.</span>
         <span class="s0">*      - the funcNode is bound as an argument of a function call.</span>
         <span class="s0">*      - the function is bound to a property and the object satisfies above conditions.</span>
         <span class="s0">* </span><span class="s1">@private</span>
         <span class="s0">*/</span>
        <span class="s6">function </span><span class="s2">isStorableFunction</span><span class="s4">(</span><span class="s2">funcNode</span><span class="s4">, </span><span class="s2">rhsNode</span><span class="s4">) {</span>
            <span class="s6">let </span><span class="s2">node </span><span class="s4">= </span><span class="s2">funcNode</span><span class="s4">;</span>
            <span class="s6">let </span><span class="s2">parent </span><span class="s4">= </span><span class="s2">funcNode</span><span class="s4">.</span><span class="s2">parent</span><span class="s4">;</span>

            <span class="s6">while </span><span class="s4">(</span><span class="s2">parent </span><span class="s4">&amp;&amp; </span><span class="s2">isInside</span><span class="s4">(</span><span class="s2">parent</span><span class="s4">, </span><span class="s2">rhsNode</span><span class="s4">)) {</span>
                <span class="s6">switch </span><span class="s4">(</span><span class="s2">parent</span><span class="s4">.</span><span class="s2">type</span><span class="s4">) {</span>
                    <span class="s6">case </span><span class="s3">&quot;SequenceExpression&quot;</span><span class="s4">:</span>
                        <span class="s6">if </span><span class="s4">(</span><span class="s2">parent</span><span class="s4">.</span><span class="s2">expressions</span><span class="s4">[</span><span class="s2">parent</span><span class="s4">.</span><span class="s2">expressions</span><span class="s4">.</span><span class="s2">length </span><span class="s4">- </span><span class="s8">1</span><span class="s4">] !== </span><span class="s2">node</span><span class="s4">) {</span>
                            <span class="s6">return false</span><span class="s4">;</span>
                        <span class="s4">}</span>
                        <span class="s6">break</span><span class="s4">;</span>

                    <span class="s6">case </span><span class="s3">&quot;CallExpression&quot;</span><span class="s4">:</span>
                    <span class="s6">case </span><span class="s3">&quot;NewExpression&quot;</span><span class="s4">:</span>
                        <span class="s6">return </span><span class="s2">parent</span><span class="s4">.</span><span class="s2">callee </span><span class="s4">!== </span><span class="s2">node</span><span class="s4">;</span>

                    <span class="s6">case </span><span class="s3">&quot;AssignmentExpression&quot;</span><span class="s4">:</span>
                    <span class="s6">case </span><span class="s3">&quot;TaggedTemplateExpression&quot;</span><span class="s4">:</span>
                    <span class="s6">case </span><span class="s3">&quot;YieldExpression&quot;</span><span class="s4">:</span>
                        <span class="s6">return true</span><span class="s4">;</span>

                    <span class="s6">default</span><span class="s4">:</span>
                        <span class="s6">if </span><span class="s4">(</span><span class="s2">STATEMENT_TYPE</span><span class="s4">.</span><span class="s2">test</span><span class="s4">(</span><span class="s2">parent</span><span class="s4">.</span><span class="s2">type</span><span class="s4">)) {</span>

                            <span class="s5">/* 
                             * If it encountered statements, this is a complex pattern. 
                             * Since analyzing complex patterns is hard, this returns `true` to avoid false positive. 
                             */</span>
                            <span class="s6">return true</span><span class="s4">;</span>
                        <span class="s4">}</span>
                <span class="s4">}</span>

                <span class="s2">node </span><span class="s4">= </span><span class="s2">parent</span><span class="s4">;</span>
                <span class="s2">parent </span><span class="s4">= </span><span class="s2">parent</span><span class="s4">.</span><span class="s2">parent</span><span class="s4">;</span>
            <span class="s4">}</span>

            <span class="s6">return false</span><span class="s4">;</span>
        <span class="s4">}</span>

        <span class="s0">/**</span>
         <span class="s0">* Checks whether a given Identifier node exists inside of a function node which can be used later.</span>
         <span class="s0">*</span>
         <span class="s0">* &quot;can be used later&quot; means:</span>
         <span class="s0">* - the function is assigned to a variable.</span>
         <span class="s0">* - the function is bound to a property and the object can be used later.</span>
         <span class="s0">* - the function is bound as an argument of a function call.</span>
         <span class="s0">*</span>
         <span class="s0">* If a reference exists in a function which can be used later, the reference is read when the function is called.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} id An Identifier node to check.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} rhsNode The RHS node of the previous assignment.</span>
         <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} `true` if the `id` node exists inside of a function node which can be used later.</span>
         <span class="s0">* </span><span class="s1">@private</span>
         <span class="s0">*/</span>
        <span class="s6">function </span><span class="s2">isInsideOfStorableFunction</span><span class="s4">(</span><span class="s2">id</span><span class="s4">, </span><span class="s2">rhsNode</span><span class="s4">) {</span>
            <span class="s6">const </span><span class="s2">funcNode </span><span class="s4">= </span><span class="s2">astUtils</span><span class="s4">.</span><span class="s2">getUpperFunction</span><span class="s4">(</span><span class="s2">id</span><span class="s4">);</span>

            <span class="s6">return </span><span class="s4">(</span>
                <span class="s2">funcNode </span><span class="s4">&amp;&amp;</span>
                <span class="s2">isInside</span><span class="s4">(</span><span class="s2">funcNode</span><span class="s4">, </span><span class="s2">rhsNode</span><span class="s4">) &amp;&amp;</span>
                <span class="s2">isStorableFunction</span><span class="s4">(</span><span class="s2">funcNode</span><span class="s4">, </span><span class="s2">rhsNode</span><span class="s4">)</span>
            <span class="s4">);</span>
        <span class="s4">}</span>

        <span class="s0">/**</span>
         <span class="s0">* Checks whether a given reference is a read to update itself or not.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">{eslint-scope.Reference} ref A reference to check.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} rhsNode The RHS node of the previous assignment.</span>
         <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} The reference is a read to update itself.</span>
         <span class="s0">* </span><span class="s1">@private</span>
         <span class="s0">*/</span>
        <span class="s6">function </span><span class="s2">isReadForItself</span><span class="s4">(</span><span class="s2">ref</span><span class="s4">, </span><span class="s2">rhsNode</span><span class="s4">) {</span>
            <span class="s6">const </span><span class="s2">id </span><span class="s4">= </span><span class="s2">ref</span><span class="s4">.</span><span class="s2">identifier</span><span class="s4">;</span>
            <span class="s6">const </span><span class="s2">parent </span><span class="s4">= </span><span class="s2">id</span><span class="s4">.</span><span class="s2">parent</span><span class="s4">;</span>

            <span class="s6">return </span><span class="s2">ref</span><span class="s4">.</span><span class="s2">isRead</span><span class="s4">() &amp;&amp; (</span>

                <span class="s5">// self update. e.g. `a += 1`, `a++`</span>
                <span class="s4">(</span>
                    <span class="s4">(</span>
                        <span class="s2">parent</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;AssignmentExpression&quot; </span><span class="s4">&amp;&amp;</span>
                        <span class="s2">parent</span><span class="s4">.</span><span class="s2">left </span><span class="s4">=== </span><span class="s2">id </span><span class="s4">&amp;&amp;</span>
                        <span class="s2">isUnusedExpression</span><span class="s4">(</span><span class="s2">parent</span><span class="s4">) &amp;&amp;</span>
                        <span class="s4">!</span><span class="s2">astUtils</span><span class="s4">.</span><span class="s2">isLogicalAssignmentOperator</span><span class="s4">(</span><span class="s2">parent</span><span class="s4">.</span><span class="s2">operator</span><span class="s4">)</span>
                    <span class="s4">) ||</span>
                    <span class="s4">(</span>
                        <span class="s2">parent</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;UpdateExpression&quot; </span><span class="s4">&amp;&amp;</span>
                        <span class="s2">isUnusedExpression</span><span class="s4">(</span><span class="s2">parent</span><span class="s4">)</span>
                    <span class="s4">)</span>
                <span class="s4">) ||</span>

                <span class="s5">// in RHS of an assignment for itself. e.g. `a = a + 1`</span>
                <span class="s4">(</span>
                    <span class="s2">rhsNode </span><span class="s4">&amp;&amp;</span>
                    <span class="s2">isInside</span><span class="s4">(</span><span class="s2">id</span><span class="s4">, </span><span class="s2">rhsNode</span><span class="s4">) &amp;&amp;</span>
                    <span class="s4">!</span><span class="s2">isInsideOfStorableFunction</span><span class="s4">(</span><span class="s2">id</span><span class="s4">, </span><span class="s2">rhsNode</span><span class="s4">)</span>
                <span class="s4">)</span>
            <span class="s4">);</span>
        <span class="s4">}</span>

        <span class="s0">/**</span>
         <span class="s0">* Determine if an identifier is used either in for-in or for-of loops.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Reference} ref The reference to check.</span>
         <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} whether reference is used in the for-in loops</span>
         <span class="s0">* </span><span class="s1">@private</span>
         <span class="s0">*/</span>
        <span class="s6">function </span><span class="s2">isForInOfRef</span><span class="s4">(</span><span class="s2">ref</span><span class="s4">) {</span>
            <span class="s6">let </span><span class="s2">target </span><span class="s4">= </span><span class="s2">ref</span><span class="s4">.</span><span class="s2">identifier</span><span class="s4">.</span><span class="s2">parent</span><span class="s4">;</span>


            <span class="s5">// &quot;for (var ...) { return; }&quot;</span>
            <span class="s6">if </span><span class="s4">(</span><span class="s2">target</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;VariableDeclarator&quot;</span><span class="s4">) {</span>
                <span class="s2">target </span><span class="s4">= </span><span class="s2">target</span><span class="s4">.</span><span class="s2">parent</span><span class="s4">.</span><span class="s2">parent</span><span class="s4">;</span>
            <span class="s4">}</span>

            <span class="s6">if </span><span class="s4">(</span><span class="s2">target</span><span class="s4">.</span><span class="s2">type </span><span class="s4">!== </span><span class="s3">&quot;ForInStatement&quot; </span><span class="s4">&amp;&amp; </span><span class="s2">target</span><span class="s4">.</span><span class="s2">type </span><span class="s4">!== </span><span class="s3">&quot;ForOfStatement&quot;</span><span class="s4">) {</span>
                <span class="s6">return false</span><span class="s4">;</span>
            <span class="s4">}</span>

            <span class="s5">// &quot;for (...) { return; }&quot;</span>
            <span class="s6">if </span><span class="s4">(</span><span class="s2">target</span><span class="s4">.</span><span class="s2">body</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;BlockStatement&quot;</span><span class="s4">) {</span>
                <span class="s2">target </span><span class="s4">= </span><span class="s2">target</span><span class="s4">.</span><span class="s2">body</span><span class="s4">.</span><span class="s2">body</span><span class="s4">[</span><span class="s8">0</span><span class="s4">];</span>

            <span class="s5">// &quot;for (...) return;&quot;</span>
            <span class="s4">} </span><span class="s6">else </span><span class="s4">{</span>
                <span class="s2">target </span><span class="s4">= </span><span class="s2">target</span><span class="s4">.</span><span class="s2">body</span><span class="s4">;</span>
            <span class="s4">}</span>

            <span class="s5">// For empty loop body</span>
            <span class="s6">if </span><span class="s4">(!</span><span class="s2">target</span><span class="s4">) {</span>
                <span class="s6">return false</span><span class="s4">;</span>
            <span class="s4">}</span>

            <span class="s6">return </span><span class="s2">target</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;ReturnStatement&quot;</span><span class="s4">;</span>
        <span class="s4">}</span>

        <span class="s0">/**</span>
         <span class="s0">* Determines if the variable is used.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Variable} variable The variable to check.</span>
         <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} True if the variable is used</span>
         <span class="s0">* </span><span class="s1">@private</span>
         <span class="s0">*/</span>
        <span class="s6">function </span><span class="s2">isUsedVariable</span><span class="s4">(</span><span class="s2">variable</span><span class="s4">) {</span>
            <span class="s6">const </span><span class="s2">functionNodes </span><span class="s4">= </span><span class="s2">getFunctionDefinitions</span><span class="s4">(</span><span class="s2">variable</span><span class="s4">),</span>
                <span class="s2">isFunctionDefinition </span><span class="s4">= </span><span class="s2">functionNodes</span><span class="s4">.</span><span class="s2">length </span><span class="s4">&gt; </span><span class="s8">0</span><span class="s4">;</span>
            <span class="s6">let </span><span class="s2">rhsNode </span><span class="s4">= </span><span class="s6">null</span><span class="s4">;</span>

            <span class="s6">return </span><span class="s2">variable</span><span class="s4">.</span><span class="s2">references</span><span class="s4">.</span><span class="s2">some</span><span class="s4">(</span><span class="s2">ref </span><span class="s4">=&gt; {</span>
                <span class="s6">if </span><span class="s4">(</span><span class="s2">isForInOfRef</span><span class="s4">(</span><span class="s2">ref</span><span class="s4">)) {</span>
                    <span class="s6">return true</span><span class="s4">;</span>
                <span class="s4">}</span>

                <span class="s6">const </span><span class="s2">forItself </span><span class="s4">= </span><span class="s2">isReadForItself</span><span class="s4">(</span><span class="s2">ref</span><span class="s4">, </span><span class="s2">rhsNode</span><span class="s4">);</span>

                <span class="s2">rhsNode </span><span class="s4">= </span><span class="s2">getRhsNode</span><span class="s4">(</span><span class="s2">ref</span><span class="s4">, </span><span class="s2">rhsNode</span><span class="s4">);</span>

                <span class="s6">return </span><span class="s4">(</span>
                    <span class="s2">isReadRef</span><span class="s4">(</span><span class="s2">ref</span><span class="s4">) &amp;&amp;</span>
                    <span class="s4">!</span><span class="s2">forItself </span><span class="s4">&amp;&amp;</span>
                    <span class="s4">!(</span><span class="s2">isFunctionDefinition </span><span class="s4">&amp;&amp; </span><span class="s2">isSelfReference</span><span class="s4">(</span><span class="s2">ref</span><span class="s4">, </span><span class="s2">functionNodes</span><span class="s4">))</span>
                <span class="s4">);</span>
            <span class="s4">});</span>
        <span class="s4">}</span>

        <span class="s0">/**</span>
         <span class="s0">* Checks whether the given variable is after the last used parameter.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">{eslint-scope.Variable} variable The variable to check.</span>
         <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} `true` if the variable is defined after the last</span>
         <span class="s0">* used parameter.</span>
         <span class="s0">*/</span>
        <span class="s6">function </span><span class="s2">isAfterLastUsedArg</span><span class="s4">(</span><span class="s2">variable</span><span class="s4">) {</span>
            <span class="s6">const </span><span class="s2">def </span><span class="s4">= </span><span class="s2">variable</span><span class="s4">.</span><span class="s2">defs</span><span class="s4">[</span><span class="s8">0</span><span class="s4">];</span>
            <span class="s6">const </span><span class="s2">params </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getDeclaredVariables</span><span class="s4">(</span><span class="s2">def</span><span class="s4">.</span><span class="s2">node</span><span class="s4">);</span>
            <span class="s6">const </span><span class="s2">posteriorParams </span><span class="s4">= </span><span class="s2">params</span><span class="s4">.</span><span class="s2">slice</span><span class="s4">(</span><span class="s2">params</span><span class="s4">.</span><span class="s2">indexOf</span><span class="s4">(</span><span class="s2">variable</span><span class="s4">) + </span><span class="s8">1</span><span class="s4">);</span>

            <span class="s5">// If any used parameters occur after this parameter, do not report.</span>
            <span class="s6">return </span><span class="s4">!</span><span class="s2">posteriorParams</span><span class="s4">.</span><span class="s2">some</span><span class="s4">(</span><span class="s2">v </span><span class="s4">=&gt; </span><span class="s2">v</span><span class="s4">.</span><span class="s2">references</span><span class="s4">.</span><span class="s2">length </span><span class="s4">&gt; </span><span class="s8">0 </span><span class="s4">|| </span><span class="s2">v</span><span class="s4">.</span><span class="s2">eslintUsed</span><span class="s4">);</span>
        <span class="s4">}</span>

        <span class="s0">/**</span>
         <span class="s0">* Gets an array of variables without read references.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Scope} scope an eslint-scope Scope object.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Variable[]} unusedVars an array that saving result.</span>
         <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Variable[]} unused variables of the scope and descendant scopes.</span>
         <span class="s0">* </span><span class="s1">@private</span>
         <span class="s0">*/</span>
        <span class="s6">function </span><span class="s2">collectUnusedVariables</span><span class="s4">(</span><span class="s2">scope</span><span class="s4">, </span><span class="s2">unusedVars</span><span class="s4">) {</span>
            <span class="s6">const </span><span class="s2">variables </span><span class="s4">= </span><span class="s2">scope</span><span class="s4">.</span><span class="s2">variables</span><span class="s4">;</span>
            <span class="s6">const </span><span class="s2">childScopes </span><span class="s4">= </span><span class="s2">scope</span><span class="s4">.</span><span class="s2">childScopes</span><span class="s4">;</span>
            <span class="s6">let </span><span class="s2">i</span><span class="s4">, </span><span class="s2">l</span><span class="s4">;</span>

            <span class="s6">if </span><span class="s4">(</span><span class="s2">scope</span><span class="s4">.</span><span class="s2">type </span><span class="s4">!== </span><span class="s3">&quot;global&quot; </span><span class="s4">|| </span><span class="s2">config</span><span class="s4">.</span><span class="s2">vars </span><span class="s4">=== </span><span class="s3">&quot;all&quot;</span><span class="s4">) {</span>
                <span class="s6">for </span><span class="s4">(</span><span class="s2">i </span><span class="s4">= </span><span class="s8">0</span><span class="s4">, </span><span class="s2">l </span><span class="s4">= </span><span class="s2">variables</span><span class="s4">.</span><span class="s2">length</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s2">l</span><span class="s4">; ++</span><span class="s2">i</span><span class="s4">) {</span>
                    <span class="s6">const </span><span class="s2">variable </span><span class="s4">= </span><span class="s2">variables</span><span class="s4">[</span><span class="s2">i</span><span class="s4">];</span>

                    <span class="s5">// skip a variable of class itself name in the class scope</span>
                    <span class="s6">if </span><span class="s4">(</span><span class="s2">scope</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;class&quot; </span><span class="s4">&amp;&amp; </span><span class="s2">scope</span><span class="s4">.</span><span class="s2">block</span><span class="s4">.</span><span class="s2">id </span><span class="s4">=== </span><span class="s2">variable</span><span class="s4">.</span><span class="s2">identifiers</span><span class="s4">[</span><span class="s8">0</span><span class="s4">]) {</span>
                        <span class="s6">continue</span><span class="s4">;</span>
                    <span class="s4">}</span>

                    <span class="s5">// skip function expression names and variables marked with markVariableAsUsed()</span>
                    <span class="s6">if </span><span class="s4">(</span><span class="s2">scope</span><span class="s4">.</span><span class="s2">functionExpressionScope </span><span class="s4">|| </span><span class="s2">variable</span><span class="s4">.</span><span class="s2">eslintUsed</span><span class="s4">) {</span>
                        <span class="s6">continue</span><span class="s4">;</span>
                    <span class="s4">}</span>

                    <span class="s5">// skip implicit &quot;arguments&quot; variable</span>
                    <span class="s6">if </span><span class="s4">(</span><span class="s2">scope</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;function&quot; </span><span class="s4">&amp;&amp; </span><span class="s2">variable</span><span class="s4">.</span><span class="s2">name </span><span class="s4">=== </span><span class="s3">&quot;arguments&quot; </span><span class="s4">&amp;&amp; </span><span class="s2">variable</span><span class="s4">.</span><span class="s2">identifiers</span><span class="s4">.</span><span class="s2">length </span><span class="s4">=== </span><span class="s8">0</span><span class="s4">) {</span>
                        <span class="s6">continue</span><span class="s4">;</span>
                    <span class="s4">}</span>

                    <span class="s5">// explicit global variables don't have definitions.</span>
                    <span class="s6">const </span><span class="s2">def </span><span class="s4">= </span><span class="s2">variable</span><span class="s4">.</span><span class="s2">defs</span><span class="s4">[</span><span class="s8">0</span><span class="s4">];</span>

                    <span class="s6">if </span><span class="s4">(</span><span class="s2">def</span><span class="s4">) {</span>
                        <span class="s6">const </span><span class="s2">type </span><span class="s4">= </span><span class="s2">def</span><span class="s4">.</span><span class="s2">type</span><span class="s4">;</span>
                        <span class="s6">const </span><span class="s2">refUsedInArrayPatterns </span><span class="s4">= </span><span class="s2">variable</span><span class="s4">.</span><span class="s2">references</span><span class="s4">.</span><span class="s2">some</span><span class="s4">(</span><span class="s2">ref </span><span class="s4">=&gt; </span><span class="s2">ref</span><span class="s4">.</span><span class="s2">identifier</span><span class="s4">.</span><span class="s2">parent</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;ArrayPattern&quot;</span><span class="s4">);</span>

                        <span class="s5">// skip elements of array destructuring patterns</span>
                        <span class="s6">if </span><span class="s4">(</span>
                            <span class="s4">(</span>
                                <span class="s2">def</span><span class="s4">.</span><span class="s2">name</span><span class="s4">.</span><span class="s2">parent</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;ArrayPattern&quot; </span><span class="s4">||</span>
                                <span class="s2">refUsedInArrayPatterns</span>
                            <span class="s4">) &amp;&amp;</span>
                            <span class="s2">config</span><span class="s4">.</span><span class="s2">destructuredArrayIgnorePattern </span><span class="s4">&amp;&amp;</span>
                            <span class="s2">config</span><span class="s4">.</span><span class="s2">destructuredArrayIgnorePattern</span><span class="s4">.</span><span class="s2">test</span><span class="s4">(</span><span class="s2">def</span><span class="s4">.</span><span class="s2">name</span><span class="s4">.</span><span class="s2">name</span><span class="s4">)</span>
                        <span class="s4">) {</span>
                            <span class="s6">continue</span><span class="s4">;</span>
                        <span class="s4">}</span>

                        <span class="s5">// skip catch variables</span>
                        <span class="s6">if </span><span class="s4">(</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;CatchClause&quot;</span><span class="s4">) {</span>
                            <span class="s6">if </span><span class="s4">(</span><span class="s2">config</span><span class="s4">.</span><span class="s2">caughtErrors </span><span class="s4">=== </span><span class="s3">&quot;none&quot;</span><span class="s4">) {</span>
                                <span class="s6">continue</span><span class="s4">;</span>
                            <span class="s4">}</span>

                            <span class="s5">// skip ignored parameters</span>
                            <span class="s6">if </span><span class="s4">(</span><span class="s2">config</span><span class="s4">.</span><span class="s2">caughtErrorsIgnorePattern </span><span class="s4">&amp;&amp; </span><span class="s2">config</span><span class="s4">.</span><span class="s2">caughtErrorsIgnorePattern</span><span class="s4">.</span><span class="s2">test</span><span class="s4">(</span><span class="s2">def</span><span class="s4">.</span><span class="s2">name</span><span class="s4">.</span><span class="s2">name</span><span class="s4">)) {</span>
                                <span class="s6">continue</span><span class="s4">;</span>
                            <span class="s4">}</span>
                        <span class="s4">}</span>

                        <span class="s6">if </span><span class="s4">(</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;Parameter&quot;</span><span class="s4">) {</span>

                            <span class="s5">// skip any setter argument</span>
                            <span class="s6">if </span><span class="s4">((</span><span class="s2">def</span><span class="s4">.</span><span class="s2">node</span><span class="s4">.</span><span class="s2">parent</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;Property&quot; </span><span class="s4">|| </span><span class="s2">def</span><span class="s4">.</span><span class="s2">node</span><span class="s4">.</span><span class="s2">parent</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;MethodDefinition&quot;</span><span class="s4">) &amp;&amp; </span><span class="s2">def</span><span class="s4">.</span><span class="s2">node</span><span class="s4">.</span><span class="s2">parent</span><span class="s4">.</span><span class="s2">kind </span><span class="s4">=== </span><span class="s3">&quot;set&quot;</span><span class="s4">) {</span>
                                <span class="s6">continue</span><span class="s4">;</span>
                            <span class="s4">}</span>

                            <span class="s5">// if &quot;args&quot; option is &quot;none&quot;, skip any parameter</span>
                            <span class="s6">if </span><span class="s4">(</span><span class="s2">config</span><span class="s4">.</span><span class="s2">args </span><span class="s4">=== </span><span class="s3">&quot;none&quot;</span><span class="s4">) {</span>
                                <span class="s6">continue</span><span class="s4">;</span>
                            <span class="s4">}</span>

                            <span class="s5">// skip ignored parameters</span>
                            <span class="s6">if </span><span class="s4">(</span><span class="s2">config</span><span class="s4">.</span><span class="s2">argsIgnorePattern </span><span class="s4">&amp;&amp; </span><span class="s2">config</span><span class="s4">.</span><span class="s2">argsIgnorePattern</span><span class="s4">.</span><span class="s2">test</span><span class="s4">(</span><span class="s2">def</span><span class="s4">.</span><span class="s2">name</span><span class="s4">.</span><span class="s2">name</span><span class="s4">)) {</span>
                                <span class="s6">continue</span><span class="s4">;</span>
                            <span class="s4">}</span>

                            <span class="s5">// if &quot;args&quot; option is &quot;after-used&quot;, skip used variables</span>
                            <span class="s6">if </span><span class="s4">(</span><span class="s2">config</span><span class="s4">.</span><span class="s2">args </span><span class="s4">=== </span><span class="s3">&quot;after-used&quot; </span><span class="s4">&amp;&amp; </span><span class="s2">astUtils</span><span class="s4">.</span><span class="s2">isFunction</span><span class="s4">(</span><span class="s2">def</span><span class="s4">.</span><span class="s2">name</span><span class="s4">.</span><span class="s2">parent</span><span class="s4">) &amp;&amp; !</span><span class="s2">isAfterLastUsedArg</span><span class="s4">(</span><span class="s2">variable</span><span class="s4">)) {</span>
                                <span class="s6">continue</span><span class="s4">;</span>
                            <span class="s4">}</span>
                        <span class="s4">} </span><span class="s6">else </span><span class="s4">{</span>

                            <span class="s5">// skip ignored variables</span>
                            <span class="s6">if </span><span class="s4">(</span><span class="s2">config</span><span class="s4">.</span><span class="s2">varsIgnorePattern </span><span class="s4">&amp;&amp; </span><span class="s2">config</span><span class="s4">.</span><span class="s2">varsIgnorePattern</span><span class="s4">.</span><span class="s2">test</span><span class="s4">(</span><span class="s2">def</span><span class="s4">.</span><span class="s2">name</span><span class="s4">.</span><span class="s2">name</span><span class="s4">)) {</span>
                                <span class="s6">continue</span><span class="s4">;</span>
                            <span class="s4">}</span>
                        <span class="s4">}</span>
                    <span class="s4">}</span>

                    <span class="s6">if </span><span class="s4">(!</span><span class="s2">isUsedVariable</span><span class="s4">(</span><span class="s2">variable</span><span class="s4">) &amp;&amp; !</span><span class="s2">isExported</span><span class="s4">(</span><span class="s2">variable</span><span class="s4">) &amp;&amp; !</span><span class="s2">hasRestSpreadSibling</span><span class="s4">(</span><span class="s2">variable</span><span class="s4">)) {</span>
                        <span class="s2">unusedVars</span><span class="s4">.</span><span class="s2">push</span><span class="s4">(</span><span class="s2">variable</span><span class="s4">);</span>
                    <span class="s4">}</span>
                <span class="s4">}</span>
            <span class="s4">}</span>

            <span class="s6">for </span><span class="s4">(</span><span class="s2">i </span><span class="s4">= </span><span class="s8">0</span><span class="s4">, </span><span class="s2">l </span><span class="s4">= </span><span class="s2">childScopes</span><span class="s4">.</span><span class="s2">length</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s2">l</span><span class="s4">; ++</span><span class="s2">i</span><span class="s4">) {</span>
                <span class="s2">collectUnusedVariables</span><span class="s4">(</span><span class="s2">childScopes</span><span class="s4">[</span><span class="s2">i</span><span class="s4">], </span><span class="s2">unusedVars</span><span class="s4">);</span>
            <span class="s4">}</span>

            <span class="s6">return </span><span class="s2">unusedVars</span><span class="s4">;</span>
        <span class="s4">}</span>

        <span class="s5">//--------------------------------------------------------------------------</span>
        <span class="s5">// Public</span>
        <span class="s5">//--------------------------------------------------------------------------</span>

        <span class="s6">return </span><span class="s4">{</span>
            <span class="s3">&quot;Program:exit&quot;</span><span class="s4">(</span><span class="s2">programNode</span><span class="s4">) {</span>
                <span class="s6">const </span><span class="s2">unusedVars </span><span class="s4">= </span><span class="s2">collectUnusedVariables</span><span class="s4">(</span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getScope</span><span class="s4">(</span><span class="s2">programNode</span><span class="s4">), []);</span>

                <span class="s6">for </span><span class="s4">(</span><span class="s6">let </span><span class="s2">i </span><span class="s4">= </span><span class="s8">0</span><span class="s4">, </span><span class="s2">l </span><span class="s4">= </span><span class="s2">unusedVars</span><span class="s4">.</span><span class="s2">length</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&lt; </span><span class="s2">l</span><span class="s4">; ++</span><span class="s2">i</span><span class="s4">) {</span>
                    <span class="s6">const </span><span class="s2">unusedVar </span><span class="s4">= </span><span class="s2">unusedVars</span><span class="s4">[</span><span class="s2">i</span><span class="s4">];</span>

                    <span class="s5">// Report the first declaration.</span>
                    <span class="s6">if </span><span class="s4">(</span><span class="s2">unusedVar</span><span class="s4">.</span><span class="s2">defs</span><span class="s4">.</span><span class="s2">length </span><span class="s4">&gt; </span><span class="s8">0</span><span class="s4">) {</span>

                        <span class="s5">// report last write reference, https://github.com/eslint/eslint/issues/14324</span>
                        <span class="s6">const </span><span class="s2">writeReferences </span><span class="s4">= </span><span class="s2">unusedVar</span><span class="s4">.</span><span class="s2">references</span><span class="s4">.</span><span class="s2">filter</span><span class="s4">(</span><span class="s2">ref </span><span class="s4">=&gt; </span><span class="s2">ref</span><span class="s4">.</span><span class="s2">isWrite</span><span class="s4">() &amp;&amp; </span><span class="s2">ref</span><span class="s4">.</span><span class="s2">from</span><span class="s4">.</span><span class="s2">variableScope </span><span class="s4">=== </span><span class="s2">unusedVar</span><span class="s4">.</span><span class="s2">scope</span><span class="s4">.</span><span class="s2">variableScope</span><span class="s4">);</span>

                        <span class="s6">let </span><span class="s2">referenceToReport</span><span class="s4">;</span>

                        <span class="s6">if </span><span class="s4">(</span><span class="s2">writeReferences</span><span class="s4">.</span><span class="s2">length </span><span class="s4">&gt; </span><span class="s8">0</span><span class="s4">) {</span>
                            <span class="s2">referenceToReport </span><span class="s4">= </span><span class="s2">writeReferences</span><span class="s4">[</span><span class="s2">writeReferences</span><span class="s4">.</span><span class="s2">length </span><span class="s4">- </span><span class="s8">1</span><span class="s4">];</span>
                        <span class="s4">}</span>

                        <span class="s2">context</span><span class="s4">.</span><span class="s2">report</span><span class="s4">({</span>
                            <span class="s2">node</span><span class="s4">: </span><span class="s2">referenceToReport </span><span class="s4">? </span><span class="s2">referenceToReport</span><span class="s4">.</span><span class="s2">identifier </span><span class="s4">: </span><span class="s2">unusedVar</span><span class="s4">.</span><span class="s2">identifiers</span><span class="s4">[</span><span class="s8">0</span><span class="s4">],</span>
                            <span class="s2">messageId</span><span class="s4">: </span><span class="s3">&quot;unusedVar&quot;</span><span class="s4">,</span>
                            <span class="s2">data</span><span class="s4">: </span><span class="s2">unusedVar</span><span class="s4">.</span><span class="s2">references</span><span class="s4">.</span><span class="s2">some</span><span class="s4">(</span><span class="s2">ref </span><span class="s4">=&gt; </span><span class="s2">ref</span><span class="s4">.</span><span class="s2">isWrite</span><span class="s4">())</span>
                                <span class="s4">? </span><span class="s2">getAssignedMessageData</span><span class="s4">(</span><span class="s2">unusedVar</span><span class="s4">)</span>
                                <span class="s4">: </span><span class="s2">getDefinedMessageData</span><span class="s4">(</span><span class="s2">unusedVar</span><span class="s4">)</span>
                        <span class="s4">});</span>

                    <span class="s5">// If there are no regular declaration, report the first `/*globals*/` comment directive.</span>
                    <span class="s4">} </span><span class="s6">else if </span><span class="s4">(</span><span class="s2">unusedVar</span><span class="s4">.</span><span class="s2">eslintExplicitGlobalComments</span><span class="s4">) {</span>
                        <span class="s6">const </span><span class="s2">directiveComment </span><span class="s4">= </span><span class="s2">unusedVar</span><span class="s4">.</span><span class="s2">eslintExplicitGlobalComments</span><span class="s4">[</span><span class="s8">0</span><span class="s4">];</span>

                        <span class="s2">context</span><span class="s4">.</span><span class="s2">report</span><span class="s4">({</span>
                            <span class="s2">node</span><span class="s4">: </span><span class="s2">programNode</span><span class="s4">,</span>
                            <span class="s2">loc</span><span class="s4">: </span><span class="s2">astUtils</span><span class="s4">.</span><span class="s2">getNameLocationInGlobalDirectiveComment</span><span class="s4">(</span><span class="s2">sourceCode</span><span class="s4">, </span><span class="s2">directiveComment</span><span class="s4">, </span><span class="s2">unusedVar</span><span class="s4">.</span><span class="s2">name</span><span class="s4">),</span>
                            <span class="s2">messageId</span><span class="s4">: </span><span class="s3">&quot;unusedVar&quot;</span><span class="s4">,</span>
                            <span class="s2">data</span><span class="s4">: </span><span class="s2">getDefinedMessageData</span><span class="s4">(</span><span class="s2">unusedVar</span><span class="s4">)</span>
                        <span class="s4">});</span>
                    <span class="s4">}</span>
                <span class="s4">}</span>
            <span class="s4">}</span>
        <span class="s4">};</span>

    <span class="s4">}</span>
<span class="s4">};</span>
</pre>
</body>
</html>