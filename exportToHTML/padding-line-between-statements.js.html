<html>
<head>
<title>padding-line-between-statements.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #67a37c; font-style: italic;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #bcbec4;}
.s5 { color: #7a7e85;}
.s6 { color: #cf8e6d;}
.s7 { color: #42c3d4;}
.s8 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
padding-line-between-statements.js</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* </span><span class="s1">@fileoverview </span><span class="s0">Rule to require or disallow newlines between statements</span>
 <span class="s0">* </span><span class="s1">@author </span><span class="s0">Toru Nagashima</span>
 <span class="s0">* </span><span class="s1">@deprecated </span><span class="s0">in ESLint v8.53.0</span>
 <span class="s0">*/</span>

<span class="s3">&quot;use strict&quot;</span><span class="s4">;</span>

<span class="s5">//------------------------------------------------------------------------------</span>
<span class="s5">// Requirements</span>
<span class="s5">//------------------------------------------------------------------------------</span>

<span class="s6">const </span><span class="s2">astUtils </span><span class="s4">= </span><span class="s2">require</span><span class="s4">(</span><span class="s3">&quot;./utils/ast-utils&quot;</span><span class="s4">);</span>

<span class="s5">//------------------------------------------------------------------------------</span>
<span class="s5">// Helpers</span>
<span class="s5">//------------------------------------------------------------------------------</span>

<span class="s6">const </span><span class="s2">LT </span><span class="s4">= </span><span class="s3">`[</span><span class="s2">$</span><span class="s4">{</span><span class="s2">Array</span><span class="s4">.</span><span class="s2">from</span><span class="s4">(</span><span class="s2">astUtils</span><span class="s4">.</span><span class="s2">LINEBREAKS</span><span class="s4">).</span><span class="s2">join</span><span class="s4">(</span><span class="s3">&quot;&quot;</span><span class="s4">)}</span><span class="s3">]`</span><span class="s4">;</span>
<span class="s6">const </span><span class="s2">PADDING_LINE_SEQUENCE </span><span class="s4">= </span><span class="s6">new </span><span class="s2">RegExp</span><span class="s4">(</span>
    <span class="s2">String</span><span class="s4">.</span><span class="s2">raw</span><span class="s3">`^(</span><span class="s6">\s</span><span class="s3">*?</span><span class="s2">$</span><span class="s4">{</span><span class="s2">LT</span><span class="s4">}</span><span class="s3">)</span><span class="s6">\s</span><span class="s3">*</span><span class="s2">$</span><span class="s4">{</span><span class="s2">LT</span><span class="s4">}</span><span class="s3">(</span><span class="s6">\s</span><span class="s3">*;?)$`</span><span class="s4">,</span>
    <span class="s3">&quot;u&quot;</span>
<span class="s4">);</span>
<span class="s6">const </span><span class="s2">CJS_EXPORT </span><span class="s4">= </span><span class="s7">/^(?:module\s*\.\s*)?exports(?:\s*\.|\s*\[|$)/u</span><span class="s4">;</span>
<span class="s6">const </span><span class="s2">CJS_IMPORT </span><span class="s4">= </span><span class="s7">/^require\(/u</span><span class="s4">;</span>

<span class="s0">/**</span>
 <span class="s0">* Creates tester which check if a node starts with specific keyword.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} keyword The keyword to test.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Object} the created tester.</span>
 <span class="s0">* </span><span class="s1">@private</span>
 <span class="s0">*/</span>
<span class="s6">function </span><span class="s2">newKeywordTester</span><span class="s4">(</span><span class="s2">keyword</span><span class="s4">) {</span>
    <span class="s6">return </span><span class="s4">{</span>
        <span class="s2">test</span><span class="s4">: (</span><span class="s2">node</span><span class="s4">, </span><span class="s2">sourceCode</span><span class="s4">) =&gt;</span>
            <span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getFirstToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">).</span><span class="s2">value </span><span class="s4">=== </span><span class="s2">keyword</span>
    <span class="s4">};</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Creates tester which check if a node starts with specific keyword and spans a single line.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} keyword The keyword to test.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Object} the created tester.</span>
 <span class="s0">* </span><span class="s1">@private</span>
 <span class="s0">*/</span>
<span class="s6">function </span><span class="s2">newSinglelineKeywordTester</span><span class="s4">(</span><span class="s2">keyword</span><span class="s4">) {</span>
    <span class="s6">return </span><span class="s4">{</span>
        <span class="s2">test</span><span class="s4">: (</span><span class="s2">node</span><span class="s4">, </span><span class="s2">sourceCode</span><span class="s4">) =&gt;</span>
            <span class="s2">node</span><span class="s4">.</span><span class="s2">loc</span><span class="s4">.</span><span class="s2">start</span><span class="s4">.</span><span class="s2">line </span><span class="s4">=== </span><span class="s2">node</span><span class="s4">.</span><span class="s2">loc</span><span class="s4">.</span><span class="s2">end</span><span class="s4">.</span><span class="s2">line </span><span class="s4">&amp;&amp;</span>
            <span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getFirstToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">).</span><span class="s2">value </span><span class="s4">=== </span><span class="s2">keyword</span>
    <span class="s4">};</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Creates tester which check if a node starts with specific keyword and spans multiple lines.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} keyword The keyword to test.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Object} the created tester.</span>
 <span class="s0">* </span><span class="s1">@private</span>
 <span class="s0">*/</span>
<span class="s6">function </span><span class="s2">newMultilineKeywordTester</span><span class="s4">(</span><span class="s2">keyword</span><span class="s4">) {</span>
    <span class="s6">return </span><span class="s4">{</span>
        <span class="s2">test</span><span class="s4">: (</span><span class="s2">node</span><span class="s4">, </span><span class="s2">sourceCode</span><span class="s4">) =&gt;</span>
            <span class="s2">node</span><span class="s4">.</span><span class="s2">loc</span><span class="s4">.</span><span class="s2">start</span><span class="s4">.</span><span class="s2">line </span><span class="s4">!== </span><span class="s2">node</span><span class="s4">.</span><span class="s2">loc</span><span class="s4">.</span><span class="s2">end</span><span class="s4">.</span><span class="s2">line </span><span class="s4">&amp;&amp;</span>
            <span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getFirstToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">).</span><span class="s2">value </span><span class="s4">=== </span><span class="s2">keyword</span>
    <span class="s4">};</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Creates tester which check if a node is specific type.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} type The node type to test.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Object} the created tester.</span>
 <span class="s0">* </span><span class="s1">@private</span>
 <span class="s0">*/</span>
<span class="s6">function </span><span class="s2">newNodeTypeTester</span><span class="s4">(</span><span class="s2">type</span><span class="s4">) {</span>
    <span class="s6">return </span><span class="s4">{</span>
        <span class="s2">test</span><span class="s4">: </span><span class="s2">node </span><span class="s4">=&gt;</span>
            <span class="s2">node</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s2">type</span>
    <span class="s4">};</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Checks the given node is an expression statement of IIFE.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The node to check.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} `true` if the node is an expression statement of IIFE.</span>
 <span class="s0">* </span><span class="s1">@private</span>
 <span class="s0">*/</span>
<span class="s6">function </span><span class="s2">isIIFEStatement</span><span class="s4">(</span><span class="s2">node</span><span class="s4">) {</span>
    <span class="s6">if </span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;ExpressionStatement&quot;</span><span class="s4">) {</span>
        <span class="s6">let </span><span class="s2">call </span><span class="s4">= </span><span class="s2">astUtils</span><span class="s4">.</span><span class="s2">skipChainExpression</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">expression</span><span class="s4">);</span>

        <span class="s6">if </span><span class="s4">(</span><span class="s2">call</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;UnaryExpression&quot;</span><span class="s4">) {</span>
            <span class="s2">call </span><span class="s4">= </span><span class="s2">astUtils</span><span class="s4">.</span><span class="s2">skipChainExpression</span><span class="s4">(</span><span class="s2">call</span><span class="s4">.</span><span class="s2">argument</span><span class="s4">);</span>
        <span class="s4">}</span>
        <span class="s6">return </span><span class="s2">call</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;CallExpression&quot; </span><span class="s4">&amp;&amp; </span><span class="s2">astUtils</span><span class="s4">.</span><span class="s2">isFunction</span><span class="s4">(</span><span class="s2">call</span><span class="s4">.</span><span class="s2">callee</span><span class="s4">);</span>
    <span class="s4">}</span>
    <span class="s6">return false</span><span class="s4">;</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Checks whether the given node is a block-like statement.</span>
 <span class="s0">* This checks the last token of the node is the closing brace of a block.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{SourceCode} sourceCode The source code to get tokens.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The node to check.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} `true` if the node is a block-like statement.</span>
 <span class="s0">* </span><span class="s1">@private</span>
 <span class="s0">*/</span>
<span class="s6">function </span><span class="s2">isBlockLikeStatement</span><span class="s4">(</span><span class="s2">sourceCode</span><span class="s4">, </span><span class="s2">node</span><span class="s4">) {</span>

    <span class="s5">// do-while with a block is a block-like statement.</span>
    <span class="s6">if </span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;DoWhileStatement&quot; </span><span class="s4">&amp;&amp; </span><span class="s2">node</span><span class="s4">.</span><span class="s2">body</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;BlockStatement&quot;</span><span class="s4">) {</span>
        <span class="s6">return true</span><span class="s4">;</span>
    <span class="s4">}</span>

    <span class="s5">/* 
     * IIFE is a block-like statement specially from 
     * JSCS#disallowPaddingNewLinesAfterBlocks. 
     */</span>
    <span class="s6">if </span><span class="s4">(</span><span class="s2">isIIFEStatement</span><span class="s4">(</span><span class="s2">node</span><span class="s4">)) {</span>
        <span class="s6">return true</span><span class="s4">;</span>
    <span class="s4">}</span>

    <span class="s5">// Checks the last token is a closing brace of blocks.</span>
    <span class="s6">const </span><span class="s2">lastToken </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getLastToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">, </span><span class="s2">astUtils</span><span class="s4">.</span><span class="s2">isNotSemicolonToken</span><span class="s4">);</span>
    <span class="s6">const </span><span class="s2">belongingNode </span><span class="s4">= </span><span class="s2">lastToken </span><span class="s4">&amp;&amp; </span><span class="s2">astUtils</span><span class="s4">.</span><span class="s2">isClosingBraceToken</span><span class="s4">(</span><span class="s2">lastToken</span><span class="s4">)</span>
        <span class="s4">? </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getNodeByRangeIndex</span><span class="s4">(</span><span class="s2">lastToken</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s8">0</span><span class="s4">])</span>
        <span class="s4">: </span><span class="s6">null</span><span class="s4">;</span>

    <span class="s6">return </span><span class="s2">Boolean</span><span class="s4">(</span><span class="s2">belongingNode</span><span class="s4">) &amp;&amp; (</span>
        <span class="s2">belongingNode</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;BlockStatement&quot; </span><span class="s4">||</span>
        <span class="s2">belongingNode</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;SwitchStatement&quot;</span>
    <span class="s4">);</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Gets the actual last token.</span>
 <span class="s0">*</span>
 <span class="s0">* If a semicolon is semicolon-less style's semicolon, this ignores it.</span>
 <span class="s0">* For example:</span>
 <span class="s0">*</span>
 <span class="s0">*     foo()</span>
 <span class="s0">*     ;[1, 2, 3].forEach(bar)</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{SourceCode} sourceCode The source code to get tokens.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The node to get.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Token} The actual last token.</span>
 <span class="s0">* </span><span class="s1">@private</span>
 <span class="s0">*/</span>
<span class="s6">function </span><span class="s2">getActualLastToken</span><span class="s4">(</span><span class="s2">sourceCode</span><span class="s4">, </span><span class="s2">node</span><span class="s4">) {</span>
    <span class="s6">const </span><span class="s2">semiToken </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getLastToken</span><span class="s4">(</span><span class="s2">node</span><span class="s4">);</span>
    <span class="s6">const </span><span class="s2">prevToken </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getTokenBefore</span><span class="s4">(</span><span class="s2">semiToken</span><span class="s4">);</span>
    <span class="s6">const </span><span class="s2">nextToken </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getTokenAfter</span><span class="s4">(</span><span class="s2">semiToken</span><span class="s4">);</span>
    <span class="s6">const </span><span class="s2">isSemicolonLessStyle </span><span class="s4">= </span><span class="s2">Boolean</span><span class="s4">(</span>
        <span class="s2">prevToken </span><span class="s4">&amp;&amp;</span>
        <span class="s2">nextToken </span><span class="s4">&amp;&amp;</span>
        <span class="s2">prevToken</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s8">0</span><span class="s4">] &gt;= </span><span class="s2">node</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s8">0</span><span class="s4">] &amp;&amp;</span>
        <span class="s2">astUtils</span><span class="s4">.</span><span class="s2">isSemicolonToken</span><span class="s4">(</span><span class="s2">semiToken</span><span class="s4">) &amp;&amp;</span>
        <span class="s2">semiToken</span><span class="s4">.</span><span class="s2">loc</span><span class="s4">.</span><span class="s2">start</span><span class="s4">.</span><span class="s2">line </span><span class="s4">!== </span><span class="s2">prevToken</span><span class="s4">.</span><span class="s2">loc</span><span class="s4">.</span><span class="s2">end</span><span class="s4">.</span><span class="s2">line </span><span class="s4">&amp;&amp;</span>
        <span class="s2">semiToken</span><span class="s4">.</span><span class="s2">loc</span><span class="s4">.</span><span class="s2">end</span><span class="s4">.</span><span class="s2">line </span><span class="s4">=== </span><span class="s2">nextToken</span><span class="s4">.</span><span class="s2">loc</span><span class="s4">.</span><span class="s2">start</span><span class="s4">.</span><span class="s2">line</span>
    <span class="s4">);</span>

    <span class="s6">return </span><span class="s2">isSemicolonLessStyle </span><span class="s4">? </span><span class="s2">prevToken </span><span class="s4">: </span><span class="s2">semiToken</span><span class="s4">;</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* This returns the concatenation of the first 2 captured strings.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} _ Unused. Whole matched string.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} trailingSpaces The trailing spaces of the first line.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} indentSpaces The indentation spaces of the last line.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{string} The concatenation of trailingSpaces and indentSpaces.</span>
 <span class="s0">* </span><span class="s1">@private</span>
 <span class="s0">*/</span>
<span class="s6">function </span><span class="s2">replacerToRemovePaddingLines</span><span class="s4">(</span><span class="s2">_</span><span class="s4">, </span><span class="s2">trailingSpaces</span><span class="s4">, </span><span class="s2">indentSpaces</span><span class="s4">) {</span>
    <span class="s6">return </span><span class="s2">trailingSpaces </span><span class="s4">+ </span><span class="s2">indentSpaces</span><span class="s4">;</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Check and report statements for `any` configuration.</span>
 <span class="s0">* It does nothing.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
 <span class="s0">* </span><span class="s1">@private</span>
 <span class="s0">*/</span>
<span class="s6">function </span><span class="s2">verifyForAny</span><span class="s4">() {</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Check and report statements for `never` configuration.</span>
 <span class="s0">* This autofix removes blank lines between the given 2 statements.</span>
 <span class="s0">* However, if comments exist between 2 blank lines, it does not remove those</span>
 <span class="s0">* blank lines automatically.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{RuleContext} context The rule context to report.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} _ Unused. The previous node to check.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} nextNode The next node to check.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Array&lt;Token[]&gt;} paddingLines The array of token pairs that blank</span>
 <span class="s0">* lines exist between the pair.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
 <span class="s0">* </span><span class="s1">@private</span>
 <span class="s0">*/</span>
<span class="s6">function </span><span class="s2">verifyForNever</span><span class="s4">(</span><span class="s2">context</span><span class="s4">, </span><span class="s2">_</span><span class="s4">, </span><span class="s2">nextNode</span><span class="s4">, </span><span class="s2">paddingLines</span><span class="s4">) {</span>
    <span class="s6">if </span><span class="s4">(</span><span class="s2">paddingLines</span><span class="s4">.</span><span class="s2">length </span><span class="s4">=== </span><span class="s8">0</span><span class="s4">) {</span>
        <span class="s6">return</span><span class="s4">;</span>
    <span class="s4">}</span>

    <span class="s2">context</span><span class="s4">.</span><span class="s2">report</span><span class="s4">({</span>
        <span class="s2">node</span><span class="s4">: </span><span class="s2">nextNode</span><span class="s4">,</span>
        <span class="s2">messageId</span><span class="s4">: </span><span class="s3">&quot;unexpectedBlankLine&quot;</span><span class="s4">,</span>
        <span class="s2">fix</span><span class="s4">(</span><span class="s2">fixer</span><span class="s4">) {</span>
            <span class="s6">if </span><span class="s4">(</span><span class="s2">paddingLines</span><span class="s4">.</span><span class="s2">length </span><span class="s4">&gt;= </span><span class="s8">2</span><span class="s4">) {</span>
                <span class="s6">return null</span><span class="s4">;</span>
            <span class="s4">}</span>

            <span class="s6">const </span><span class="s2">prevToken </span><span class="s4">= </span><span class="s2">paddingLines</span><span class="s4">[</span><span class="s8">0</span><span class="s4">][</span><span class="s8">0</span><span class="s4">];</span>
            <span class="s6">const </span><span class="s2">nextToken </span><span class="s4">= </span><span class="s2">paddingLines</span><span class="s4">[</span><span class="s8">0</span><span class="s4">][</span><span class="s8">1</span><span class="s4">];</span>
            <span class="s6">const </span><span class="s2">start </span><span class="s4">= </span><span class="s2">prevToken</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s8">1</span><span class="s4">];</span>
            <span class="s6">const </span><span class="s2">end </span><span class="s4">= </span><span class="s2">nextToken</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s8">0</span><span class="s4">];</span>
            <span class="s6">const </span><span class="s2">text </span><span class="s4">= </span><span class="s2">context</span><span class="s4">.</span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">text</span>
                <span class="s4">.</span><span class="s2">slice</span><span class="s4">(</span><span class="s2">start</span><span class="s4">, </span><span class="s2">end</span><span class="s4">)</span>
                <span class="s4">.</span><span class="s2">replace</span><span class="s4">(</span><span class="s2">PADDING_LINE_SEQUENCE</span><span class="s4">, </span><span class="s2">replacerToRemovePaddingLines</span><span class="s4">);</span>

            <span class="s6">return </span><span class="s2">fixer</span><span class="s4">.</span><span class="s2">replaceTextRange</span><span class="s4">([</span><span class="s2">start</span><span class="s4">, </span><span class="s2">end</span><span class="s4">], </span><span class="s2">text</span><span class="s4">);</span>
        <span class="s4">}</span>
    <span class="s4">});</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Check and report statements for `always` configuration.</span>
 <span class="s0">* This autofix inserts a blank line between the given 2 statements.</span>
 <span class="s0">* If the `prevNode` has trailing comments, it inserts a blank line after the</span>
 <span class="s0">* trailing comments.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{RuleContext} context The rule context to report.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} prevNode The previous node to check.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} nextNode The next node to check.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Array&lt;Token[]&gt;} paddingLines The array of token pairs that blank</span>
 <span class="s0">* lines exist between the pair.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
 <span class="s0">* </span><span class="s1">@private</span>
 <span class="s0">*/</span>
<span class="s6">function </span><span class="s2">verifyForAlways</span><span class="s4">(</span><span class="s2">context</span><span class="s4">, </span><span class="s2">prevNode</span><span class="s4">, </span><span class="s2">nextNode</span><span class="s4">, </span><span class="s2">paddingLines</span><span class="s4">) {</span>
    <span class="s6">if </span><span class="s4">(</span><span class="s2">paddingLines</span><span class="s4">.</span><span class="s2">length </span><span class="s4">&gt; </span><span class="s8">0</span><span class="s4">) {</span>
        <span class="s6">return</span><span class="s4">;</span>
    <span class="s4">}</span>

    <span class="s2">context</span><span class="s4">.</span><span class="s2">report</span><span class="s4">({</span>
        <span class="s2">node</span><span class="s4">: </span><span class="s2">nextNode</span><span class="s4">,</span>
        <span class="s2">messageId</span><span class="s4">: </span><span class="s3">&quot;expectedBlankLine&quot;</span><span class="s4">,</span>
        <span class="s2">fix</span><span class="s4">(</span><span class="s2">fixer</span><span class="s4">) {</span>
            <span class="s6">const </span><span class="s2">sourceCode </span><span class="s4">= </span><span class="s2">context</span><span class="s4">.</span><span class="s2">sourceCode</span><span class="s4">;</span>
            <span class="s6">let </span><span class="s2">prevToken </span><span class="s4">= </span><span class="s2">getActualLastToken</span><span class="s4">(</span><span class="s2">sourceCode</span><span class="s4">, </span><span class="s2">prevNode</span><span class="s4">);</span>
            <span class="s6">const </span><span class="s2">nextToken </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getFirstTokenBetween</span><span class="s4">(</span>
                <span class="s2">prevToken</span><span class="s4">,</span>
                <span class="s2">nextNode</span><span class="s4">,</span>
                <span class="s4">{</span>
                    <span class="s2">includeComments</span><span class="s4">: </span><span class="s6">true</span><span class="s4">,</span>

                    <span class="s0">/**</span>
                     <span class="s0">* Skip the trailing comments of the previous node.</span>
                     <span class="s0">* This inserts a blank line after the last trailing comment.</span>
                     <span class="s0">*</span>
                     <span class="s0">* For example:</span>
                     <span class="s0">*</span>
                     <span class="s0">*     foo(); // trailing comment.</span>
                     <span class="s0">*     // comment.</span>
                     <span class="s0">*     bar();</span>
                     <span class="s0">*</span>
                     <span class="s0">* Get fixed to:</span>
                     <span class="s0">*</span>
                     <span class="s0">*     foo(); // trailing comment.</span>
                     <span class="s0">*</span>
                     <span class="s0">*     // comment.</span>
                     <span class="s0">*     bar();</span>
                     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Token} token The token to check.</span>
                     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} `true` if the token is not a trailing comment.</span>
                     <span class="s0">* </span><span class="s1">@private</span>
                     <span class="s0">*/</span>
                    <span class="s2">filter</span><span class="s4">(</span><span class="s2">token</span><span class="s4">) {</span>
                        <span class="s6">if </span><span class="s4">(</span><span class="s2">astUtils</span><span class="s4">.</span><span class="s2">isTokenOnSameLine</span><span class="s4">(</span><span class="s2">prevToken</span><span class="s4">, </span><span class="s2">token</span><span class="s4">)) {</span>
                            <span class="s2">prevToken </span><span class="s4">= </span><span class="s2">token</span><span class="s4">;</span>
                            <span class="s6">return false</span><span class="s4">;</span>
                        <span class="s4">}</span>
                        <span class="s6">return true</span><span class="s4">;</span>
                    <span class="s4">}</span>
                <span class="s4">}</span>
            <span class="s4">) || </span><span class="s2">nextNode</span><span class="s4">;</span>
            <span class="s6">const </span><span class="s2">insertText </span><span class="s4">= </span><span class="s2">astUtils</span><span class="s4">.</span><span class="s2">isTokenOnSameLine</span><span class="s4">(</span><span class="s2">prevToken</span><span class="s4">, </span><span class="s2">nextToken</span><span class="s4">)</span>
                <span class="s4">? </span><span class="s3">&quot;</span><span class="s6">\n\n</span><span class="s3">&quot;</span>
                <span class="s4">: </span><span class="s3">&quot;</span><span class="s6">\n</span><span class="s3">&quot;</span><span class="s4">;</span>

            <span class="s6">return </span><span class="s2">fixer</span><span class="s4">.</span><span class="s2">insertTextAfter</span><span class="s4">(</span><span class="s2">prevToken</span><span class="s4">, </span><span class="s2">insertText</span><span class="s4">);</span>
        <span class="s4">}</span>
    <span class="s4">});</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Types of blank lines.</span>
 <span class="s0">* `any`, `never`, and `always` are defined.</span>
 <span class="s0">* Those have `verify` method to check and report statements.</span>
 <span class="s0">* </span><span class="s1">@private</span>
 <span class="s0">*/</span>
<span class="s6">const </span><span class="s2">PaddingTypes </span><span class="s4">= {</span>
    <span class="s2">any</span><span class="s4">: { </span><span class="s2">verify</span><span class="s4">: </span><span class="s2">verifyForAny </span><span class="s4">},</span>
    <span class="s2">never</span><span class="s4">: { </span><span class="s2">verify</span><span class="s4">: </span><span class="s2">verifyForNever </span><span class="s4">},</span>
    <span class="s2">always</span><span class="s4">: { </span><span class="s2">verify</span><span class="s4">: </span><span class="s2">verifyForAlways </span><span class="s4">}</span>
<span class="s4">};</span>

<span class="s0">/**</span>
 <span class="s0">* Types of statements.</span>
 <span class="s0">* Those have `test` method to check it matches to the given statement.</span>
 <span class="s0">* </span><span class="s1">@private</span>
 <span class="s0">*/</span>
<span class="s6">const </span><span class="s2">StatementTypes </span><span class="s4">= {</span>
    <span class="s3">&quot;*&quot;</span><span class="s4">: { </span><span class="s2">test</span><span class="s4">: () =&gt; </span><span class="s6">true </span><span class="s4">},</span>
    <span class="s3">&quot;block-like&quot;</span><span class="s4">: {</span>
        <span class="s2">test</span><span class="s4">: (</span><span class="s2">node</span><span class="s4">, </span><span class="s2">sourceCode</span><span class="s4">) =&gt; </span><span class="s2">isBlockLikeStatement</span><span class="s4">(</span><span class="s2">sourceCode</span><span class="s4">, </span><span class="s2">node</span><span class="s4">)</span>
    <span class="s4">},</span>
    <span class="s3">&quot;cjs-export&quot;</span><span class="s4">: {</span>
        <span class="s2">test</span><span class="s4">: (</span><span class="s2">node</span><span class="s4">, </span><span class="s2">sourceCode</span><span class="s4">) =&gt;</span>
            <span class="s2">node</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;ExpressionStatement&quot; </span><span class="s4">&amp;&amp;</span>
            <span class="s2">node</span><span class="s4">.</span><span class="s2">expression</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;AssignmentExpression&quot; </span><span class="s4">&amp;&amp;</span>
            <span class="s2">CJS_EXPORT</span><span class="s4">.</span><span class="s2">test</span><span class="s4">(</span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getText</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">expression</span><span class="s4">.</span><span class="s2">left</span><span class="s4">))</span>
    <span class="s4">},</span>
    <span class="s3">&quot;cjs-import&quot;</span><span class="s4">: {</span>
        <span class="s2">test</span><span class="s4">: (</span><span class="s2">node</span><span class="s4">, </span><span class="s2">sourceCode</span><span class="s4">) =&gt;</span>
            <span class="s2">node</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;VariableDeclaration&quot; </span><span class="s4">&amp;&amp;</span>
            <span class="s2">node</span><span class="s4">.</span><span class="s2">declarations</span><span class="s4">.</span><span class="s2">length </span><span class="s4">&gt; </span><span class="s8">0 </span><span class="s4">&amp;&amp;</span>
            <span class="s2">Boolean</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">declarations</span><span class="s4">[</span><span class="s8">0</span><span class="s4">].</span><span class="s2">init</span><span class="s4">) &amp;&amp;</span>
            <span class="s2">CJS_IMPORT</span><span class="s4">.</span><span class="s2">test</span><span class="s4">(</span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getText</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">declarations</span><span class="s4">[</span><span class="s8">0</span><span class="s4">].</span><span class="s2">init</span><span class="s4">))</span>
    <span class="s4">},</span>
    <span class="s2">directive</span><span class="s4">: {</span>
        <span class="s2">test</span><span class="s4">: </span><span class="s2">astUtils</span><span class="s4">.</span><span class="s2">isDirective</span>
    <span class="s4">},</span>
    <span class="s2">expression</span><span class="s4">: {</span>
        <span class="s2">test</span><span class="s4">: </span><span class="s2">node </span><span class="s4">=&gt; </span><span class="s2">node</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;ExpressionStatement&quot; </span><span class="s4">&amp;&amp; !</span><span class="s2">astUtils</span><span class="s4">.</span><span class="s2">isDirective</span><span class="s4">(</span><span class="s2">node</span><span class="s4">)</span>
    <span class="s4">},</span>
    <span class="s2">iife</span><span class="s4">: {</span>
        <span class="s2">test</span><span class="s4">: </span><span class="s2">isIIFEStatement</span>
    <span class="s4">},</span>
    <span class="s3">&quot;multiline-block-like&quot;</span><span class="s4">: {</span>
        <span class="s2">test</span><span class="s4">: (</span><span class="s2">node</span><span class="s4">, </span><span class="s2">sourceCode</span><span class="s4">) =&gt;</span>
            <span class="s2">node</span><span class="s4">.</span><span class="s2">loc</span><span class="s4">.</span><span class="s2">start</span><span class="s4">.</span><span class="s2">line </span><span class="s4">!== </span><span class="s2">node</span><span class="s4">.</span><span class="s2">loc</span><span class="s4">.</span><span class="s2">end</span><span class="s4">.</span><span class="s2">line </span><span class="s4">&amp;&amp;</span>
            <span class="s2">isBlockLikeStatement</span><span class="s4">(</span><span class="s2">sourceCode</span><span class="s4">, </span><span class="s2">node</span><span class="s4">)</span>
    <span class="s4">},</span>
    <span class="s3">&quot;multiline-expression&quot;</span><span class="s4">: {</span>
        <span class="s2">test</span><span class="s4">: </span><span class="s2">node </span><span class="s4">=&gt;</span>
            <span class="s2">node</span><span class="s4">.</span><span class="s2">loc</span><span class="s4">.</span><span class="s2">start</span><span class="s4">.</span><span class="s2">line </span><span class="s4">!== </span><span class="s2">node</span><span class="s4">.</span><span class="s2">loc</span><span class="s4">.</span><span class="s2">end</span><span class="s4">.</span><span class="s2">line </span><span class="s4">&amp;&amp;</span>
            <span class="s2">node</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;ExpressionStatement&quot; </span><span class="s4">&amp;&amp;</span>
            <span class="s4">!</span><span class="s2">astUtils</span><span class="s4">.</span><span class="s2">isDirective</span><span class="s4">(</span><span class="s2">node</span><span class="s4">)</span>
    <span class="s4">},</span>

    <span class="s3">&quot;multiline-const&quot;</span><span class="s4">: </span><span class="s2">newMultilineKeywordTester</span><span class="s4">(</span><span class="s3">&quot;const&quot;</span><span class="s4">),</span>
    <span class="s3">&quot;multiline-let&quot;</span><span class="s4">: </span><span class="s2">newMultilineKeywordTester</span><span class="s4">(</span><span class="s3">&quot;let&quot;</span><span class="s4">),</span>
    <span class="s3">&quot;multiline-var&quot;</span><span class="s4">: </span><span class="s2">newMultilineKeywordTester</span><span class="s4">(</span><span class="s3">&quot;var&quot;</span><span class="s4">),</span>
    <span class="s3">&quot;singleline-const&quot;</span><span class="s4">: </span><span class="s2">newSinglelineKeywordTester</span><span class="s4">(</span><span class="s3">&quot;const&quot;</span><span class="s4">),</span>
    <span class="s3">&quot;singleline-let&quot;</span><span class="s4">: </span><span class="s2">newSinglelineKeywordTester</span><span class="s4">(</span><span class="s3">&quot;let&quot;</span><span class="s4">),</span>
    <span class="s3">&quot;singleline-var&quot;</span><span class="s4">: </span><span class="s2">newSinglelineKeywordTester</span><span class="s4">(</span><span class="s3">&quot;var&quot;</span><span class="s4">),</span>

    <span class="s2">block</span><span class="s4">: </span><span class="s2">newNodeTypeTester</span><span class="s4">(</span><span class="s3">&quot;BlockStatement&quot;</span><span class="s4">),</span>
    <span class="s2">empty</span><span class="s4">: </span><span class="s2">newNodeTypeTester</span><span class="s4">(</span><span class="s3">&quot;EmptyStatement&quot;</span><span class="s4">),</span>
    <span class="s6">function</span><span class="s4">: </span><span class="s2">newNodeTypeTester</span><span class="s4">(</span><span class="s3">&quot;FunctionDeclaration&quot;</span><span class="s4">),</span>

    <span class="s6">break</span><span class="s4">: </span><span class="s2">newKeywordTester</span><span class="s4">(</span><span class="s3">&quot;break&quot;</span><span class="s4">),</span>
    <span class="s6">case</span><span class="s4">: </span><span class="s2">newKeywordTester</span><span class="s4">(</span><span class="s3">&quot;case&quot;</span><span class="s4">),</span>
    <span class="s6">class</span><span class="s4">: </span><span class="s2">newKeywordTester</span><span class="s4">(</span><span class="s3">&quot;class&quot;</span><span class="s4">),</span>
    <span class="s6">const</span><span class="s4">: </span><span class="s2">newKeywordTester</span><span class="s4">(</span><span class="s3">&quot;const&quot;</span><span class="s4">),</span>
    <span class="s6">continue</span><span class="s4">: </span><span class="s2">newKeywordTester</span><span class="s4">(</span><span class="s3">&quot;continue&quot;</span><span class="s4">),</span>
    <span class="s6">debugger</span><span class="s4">: </span><span class="s2">newKeywordTester</span><span class="s4">(</span><span class="s3">&quot;debugger&quot;</span><span class="s4">),</span>
    <span class="s6">default</span><span class="s4">: </span><span class="s2">newKeywordTester</span><span class="s4">(</span><span class="s3">&quot;default&quot;</span><span class="s4">),</span>
    <span class="s6">do</span><span class="s4">: </span><span class="s2">newKeywordTester</span><span class="s4">(</span><span class="s3">&quot;do&quot;</span><span class="s4">),</span>
    <span class="s6">export</span><span class="s4">: </span><span class="s2">newKeywordTester</span><span class="s4">(</span><span class="s3">&quot;export&quot;</span><span class="s4">),</span>
    <span class="s6">for</span><span class="s4">: </span><span class="s2">newKeywordTester</span><span class="s4">(</span><span class="s3">&quot;for&quot;</span><span class="s4">),</span>
    <span class="s6">if</span><span class="s4">: </span><span class="s2">newKeywordTester</span><span class="s4">(</span><span class="s3">&quot;if&quot;</span><span class="s4">),</span>
    <span class="s6">import</span><span class="s4">: </span><span class="s2">newKeywordTester</span><span class="s4">(</span><span class="s3">&quot;import&quot;</span><span class="s4">),</span>
    <span class="s6">let</span><span class="s4">: </span><span class="s2">newKeywordTester</span><span class="s4">(</span><span class="s3">&quot;let&quot;</span><span class="s4">),</span>
    <span class="s6">return</span><span class="s4">: </span><span class="s2">newKeywordTester</span><span class="s4">(</span><span class="s3">&quot;return&quot;</span><span class="s4">),</span>
    <span class="s6">switch</span><span class="s4">: </span><span class="s2">newKeywordTester</span><span class="s4">(</span><span class="s3">&quot;switch&quot;</span><span class="s4">),</span>
    <span class="s6">throw</span><span class="s4">: </span><span class="s2">newKeywordTester</span><span class="s4">(</span><span class="s3">&quot;throw&quot;</span><span class="s4">),</span>
    <span class="s6">try</span><span class="s4">: </span><span class="s2">newKeywordTester</span><span class="s4">(</span><span class="s3">&quot;try&quot;</span><span class="s4">),</span>
    <span class="s6">var</span><span class="s4">: </span><span class="s2">newKeywordTester</span><span class="s4">(</span><span class="s3">&quot;var&quot;</span><span class="s4">),</span>
    <span class="s6">while</span><span class="s4">: </span><span class="s2">newKeywordTester</span><span class="s4">(</span><span class="s3">&quot;while&quot;</span><span class="s4">),</span>
    <span class="s6">with</span><span class="s4">: </span><span class="s2">newKeywordTester</span><span class="s4">(</span><span class="s3">&quot;with&quot;</span><span class="s4">)</span>
<span class="s4">};</span>

<span class="s5">//------------------------------------------------------------------------------</span>
<span class="s5">// Rule Definition</span>
<span class="s5">//------------------------------------------------------------------------------</span>

<span class="s0">/** </span><span class="s1">@type </span><span class="s0">{import('../shared/types').Rule} */</span>
<span class="s2">module</span><span class="s4">.</span><span class="s2">exports </span><span class="s4">= {</span>
    <span class="s2">meta</span><span class="s4">: {</span>
        <span class="s2">deprecated</span><span class="s4">: </span><span class="s6">true</span><span class="s4">,</span>
        <span class="s2">replacedBy</span><span class="s4">: [],</span>
        <span class="s2">type</span><span class="s4">: </span><span class="s3">&quot;layout&quot;</span><span class="s4">,</span>

        <span class="s2">docs</span><span class="s4">: {</span>
            <span class="s2">description</span><span class="s4">: </span><span class="s3">&quot;Require or disallow padding lines between statements&quot;</span><span class="s4">,</span>
            <span class="s2">recommended</span><span class="s4">: </span><span class="s6">false</span><span class="s4">,</span>
            <span class="s2">url</span><span class="s4">: </span><span class="s3">&quot;https://eslint.org/docs/latest/rules/padding-line-between-statements&quot;</span>
        <span class="s4">},</span>

        <span class="s2">fixable</span><span class="s4">: </span><span class="s3">&quot;whitespace&quot;</span><span class="s4">,</span>

        <span class="s2">schema</span><span class="s4">: {</span>
            <span class="s2">definitions</span><span class="s4">: {</span>
                <span class="s2">paddingType</span><span class="s4">: {</span>
                    <span class="s6">enum</span><span class="s4">: </span><span class="s2">Object</span><span class="s4">.</span><span class="s2">keys</span><span class="s4">(</span><span class="s2">PaddingTypes</span><span class="s4">)</span>
                <span class="s4">},</span>
                <span class="s2">statementType</span><span class="s4">: {</span>
                    <span class="s2">anyOf</span><span class="s4">: [</span>
                        <span class="s4">{ </span><span class="s6">enum</span><span class="s4">: </span><span class="s2">Object</span><span class="s4">.</span><span class="s2">keys</span><span class="s4">(</span><span class="s2">StatementTypes</span><span class="s4">) },</span>
                        <span class="s4">{</span>
                            <span class="s2">type</span><span class="s4">: </span><span class="s3">&quot;array&quot;</span><span class="s4">,</span>
                            <span class="s2">items</span><span class="s4">: { </span><span class="s6">enum</span><span class="s4">: </span><span class="s2">Object</span><span class="s4">.</span><span class="s2">keys</span><span class="s4">(</span><span class="s2">StatementTypes</span><span class="s4">) },</span>
                            <span class="s2">minItems</span><span class="s4">: </span><span class="s8">1</span><span class="s4">,</span>
                            <span class="s2">uniqueItems</span><span class="s4">: </span><span class="s6">true</span>
                        <span class="s4">}</span>
                    <span class="s4">]</span>
                <span class="s4">}</span>
            <span class="s4">},</span>
            <span class="s2">type</span><span class="s4">: </span><span class="s3">&quot;array&quot;</span><span class="s4">,</span>
            <span class="s2">items</span><span class="s4">: {</span>
                <span class="s2">type</span><span class="s4">: </span><span class="s3">&quot;object&quot;</span><span class="s4">,</span>
                <span class="s2">properties</span><span class="s4">: {</span>
                    <span class="s2">blankLine</span><span class="s4">: { </span><span class="s2">$ref</span><span class="s4">: </span><span class="s3">&quot;#/definitions/paddingType&quot; </span><span class="s4">},</span>
                    <span class="s2">prev</span><span class="s4">: { </span><span class="s2">$ref</span><span class="s4">: </span><span class="s3">&quot;#/definitions/statementType&quot; </span><span class="s4">},</span>
                    <span class="s2">next</span><span class="s4">: { </span><span class="s2">$ref</span><span class="s4">: </span><span class="s3">&quot;#/definitions/statementType&quot; </span><span class="s4">}</span>
                <span class="s4">},</span>
                <span class="s2">additionalProperties</span><span class="s4">: </span><span class="s6">false</span><span class="s4">,</span>
                <span class="s2">required</span><span class="s4">: [</span><span class="s3">&quot;blankLine&quot;</span><span class="s4">, </span><span class="s3">&quot;prev&quot;</span><span class="s4">, </span><span class="s3">&quot;next&quot;</span><span class="s4">]</span>
            <span class="s4">}</span>
        <span class="s4">},</span>

        <span class="s2">messages</span><span class="s4">: {</span>
            <span class="s2">unexpectedBlankLine</span><span class="s4">: </span><span class="s3">&quot;Unexpected blank line before this statement.&quot;</span><span class="s4">,</span>
            <span class="s2">expectedBlankLine</span><span class="s4">: </span><span class="s3">&quot;Expected blank line before this statement.&quot;</span>
        <span class="s4">}</span>
    <span class="s4">},</span>

    <span class="s2">create</span><span class="s4">(</span><span class="s2">context</span><span class="s4">) {</span>
        <span class="s6">const </span><span class="s2">sourceCode </span><span class="s4">= </span><span class="s2">context</span><span class="s4">.</span><span class="s2">sourceCode</span><span class="s4">;</span>
        <span class="s6">const </span><span class="s2">configureList </span><span class="s4">= </span><span class="s2">context</span><span class="s4">.</span><span class="s2">options </span><span class="s4">|| [];</span>
        <span class="s6">let </span><span class="s2">scopeInfo </span><span class="s4">= </span><span class="s6">null</span><span class="s4">;</span>

        <span class="s0">/**</span>
         <span class="s0">* Processes to enter to new scope.</span>
         <span class="s0">* This manages the current previous statement.</span>
         <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
         <span class="s0">* </span><span class="s1">@private</span>
         <span class="s0">*/</span>
        <span class="s6">function </span><span class="s2">enterScope</span><span class="s4">() {</span>
            <span class="s2">scopeInfo </span><span class="s4">= {</span>
                <span class="s2">upper</span><span class="s4">: </span><span class="s2">scopeInfo</span><span class="s4">,</span>
                <span class="s2">prevNode</span><span class="s4">: </span><span class="s6">null</span>
            <span class="s4">};</span>
        <span class="s4">}</span>

        <span class="s0">/**</span>
         <span class="s0">* Processes to exit from the current scope.</span>
         <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
         <span class="s0">* </span><span class="s1">@private</span>
         <span class="s0">*/</span>
        <span class="s6">function </span><span class="s2">exitScope</span><span class="s4">() {</span>
            <span class="s2">scopeInfo </span><span class="s4">= </span><span class="s2">scopeInfo</span><span class="s4">.</span><span class="s2">upper</span><span class="s4">;</span>
        <span class="s4">}</span>

        <span class="s0">/**</span>
         <span class="s0">* Checks whether the given node matches the given type.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The statement node to check.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|string[]} type The statement type to check.</span>
         <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} `true` if the statement node matched the type.</span>
         <span class="s0">* </span><span class="s1">@private</span>
         <span class="s0">*/</span>
        <span class="s6">function </span><span class="s2">match</span><span class="s4">(</span><span class="s2">node</span><span class="s4">, </span><span class="s2">type</span><span class="s4">) {</span>
            <span class="s6">let </span><span class="s2">innerStatementNode </span><span class="s4">= </span><span class="s2">node</span><span class="s4">;</span>

            <span class="s6">while </span><span class="s4">(</span><span class="s2">innerStatementNode</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;LabeledStatement&quot;</span><span class="s4">) {</span>
                <span class="s2">innerStatementNode </span><span class="s4">= </span><span class="s2">innerStatementNode</span><span class="s4">.</span><span class="s2">body</span><span class="s4">;</span>
            <span class="s4">}</span>
            <span class="s6">if </span><span class="s4">(</span><span class="s2">Array</span><span class="s4">.</span><span class="s2">isArray</span><span class="s4">(</span><span class="s2">type</span><span class="s4">)) {</span>
                <span class="s6">return </span><span class="s2">type</span><span class="s4">.</span><span class="s2">some</span><span class="s4">(</span><span class="s2">match</span><span class="s4">.</span><span class="s2">bind</span><span class="s4">(</span><span class="s6">null</span><span class="s4">, </span><span class="s2">innerStatementNode</span><span class="s4">));</span>
            <span class="s4">}</span>
            <span class="s6">return </span><span class="s2">StatementTypes</span><span class="s4">[</span><span class="s2">type</span><span class="s4">].</span><span class="s2">test</span><span class="s4">(</span><span class="s2">innerStatementNode</span><span class="s4">, </span><span class="s2">sourceCode</span><span class="s4">);</span>
        <span class="s4">}</span>

        <span class="s0">/**</span>
         <span class="s0">* Finds the last matched configure from configureList.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} prevNode The previous statement to match.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} nextNode The current statement to match.</span>
         <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Object} The tester of the last matched configure.</span>
         <span class="s0">* </span><span class="s1">@private</span>
         <span class="s0">*/</span>
        <span class="s6">function </span><span class="s2">getPaddingType</span><span class="s4">(</span><span class="s2">prevNode</span><span class="s4">, </span><span class="s2">nextNode</span><span class="s4">) {</span>
            <span class="s6">for </span><span class="s4">(</span><span class="s6">let </span><span class="s2">i </span><span class="s4">= </span><span class="s2">configureList</span><span class="s4">.</span><span class="s2">length </span><span class="s4">- </span><span class="s8">1</span><span class="s4">; </span><span class="s2">i </span><span class="s4">&gt;= </span><span class="s8">0</span><span class="s4">; --</span><span class="s2">i</span><span class="s4">) {</span>
                <span class="s6">const </span><span class="s2">configure </span><span class="s4">= </span><span class="s2">configureList</span><span class="s4">[</span><span class="s2">i</span><span class="s4">];</span>
                <span class="s6">const </span><span class="s2">matched </span><span class="s4">=</span>
                    <span class="s2">match</span><span class="s4">(</span><span class="s2">prevNode</span><span class="s4">, </span><span class="s2">configure</span><span class="s4">.</span><span class="s2">prev</span><span class="s4">) &amp;&amp;</span>
                    <span class="s2">match</span><span class="s4">(</span><span class="s2">nextNode</span><span class="s4">, </span><span class="s2">configure</span><span class="s4">.</span><span class="s2">next</span><span class="s4">);</span>

                <span class="s6">if </span><span class="s4">(</span><span class="s2">matched</span><span class="s4">) {</span>
                    <span class="s6">return </span><span class="s2">PaddingTypes</span><span class="s4">[</span><span class="s2">configure</span><span class="s4">.</span><span class="s2">blankLine</span><span class="s4">];</span>
                <span class="s4">}</span>
            <span class="s4">}</span>
            <span class="s6">return </span><span class="s2">PaddingTypes</span><span class="s4">.</span><span class="s2">any</span><span class="s4">;</span>
        <span class="s4">}</span>

        <span class="s0">/**</span>
         <span class="s0">* Gets padding line sequences between the given 2 statements.</span>
         <span class="s0">* Comments are separators of the padding line sequences.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} prevNode The previous statement to count.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} nextNode The current statement to count.</span>
         <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Array&lt;Token[]&gt;} The array of token pairs.</span>
         <span class="s0">* </span><span class="s1">@private</span>
         <span class="s0">*/</span>
        <span class="s6">function </span><span class="s2">getPaddingLineSequences</span><span class="s4">(</span><span class="s2">prevNode</span><span class="s4">, </span><span class="s2">nextNode</span><span class="s4">) {</span>
            <span class="s6">const </span><span class="s2">pairs </span><span class="s4">= [];</span>
            <span class="s6">let </span><span class="s2">prevToken </span><span class="s4">= </span><span class="s2">getActualLastToken</span><span class="s4">(</span><span class="s2">sourceCode</span><span class="s4">, </span><span class="s2">prevNode</span><span class="s4">);</span>

            <span class="s6">if </span><span class="s4">(</span><span class="s2">nextNode</span><span class="s4">.</span><span class="s2">loc</span><span class="s4">.</span><span class="s2">start</span><span class="s4">.</span><span class="s2">line </span><span class="s4">- </span><span class="s2">prevToken</span><span class="s4">.</span><span class="s2">loc</span><span class="s4">.</span><span class="s2">end</span><span class="s4">.</span><span class="s2">line </span><span class="s4">&gt;= </span><span class="s8">2</span><span class="s4">) {</span>
                <span class="s6">do </span><span class="s4">{</span>
                    <span class="s6">const </span><span class="s2">token </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getTokenAfter</span><span class="s4">(</span>
                        <span class="s2">prevToken</span><span class="s4">,</span>
                        <span class="s4">{ </span><span class="s2">includeComments</span><span class="s4">: </span><span class="s6">true </span><span class="s4">}</span>
                    <span class="s4">);</span>

                    <span class="s6">if </span><span class="s4">(</span><span class="s2">token</span><span class="s4">.</span><span class="s2">loc</span><span class="s4">.</span><span class="s2">start</span><span class="s4">.</span><span class="s2">line </span><span class="s4">- </span><span class="s2">prevToken</span><span class="s4">.</span><span class="s2">loc</span><span class="s4">.</span><span class="s2">end</span><span class="s4">.</span><span class="s2">line </span><span class="s4">&gt;= </span><span class="s8">2</span><span class="s4">) {</span>
                        <span class="s2">pairs</span><span class="s4">.</span><span class="s2">push</span><span class="s4">([</span><span class="s2">prevToken</span><span class="s4">, </span><span class="s2">token</span><span class="s4">]);</span>
                    <span class="s4">}</span>
                    <span class="s2">prevToken </span><span class="s4">= </span><span class="s2">token</span><span class="s4">;</span>

                <span class="s4">} </span><span class="s6">while </span><span class="s4">(</span><span class="s2">prevToken</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s8">0</span><span class="s4">] &lt; </span><span class="s2">nextNode</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s8">0</span><span class="s4">]);</span>
            <span class="s4">}</span>

            <span class="s6">return </span><span class="s2">pairs</span><span class="s4">;</span>
        <span class="s4">}</span>

        <span class="s0">/**</span>
         <span class="s0">* Verify padding lines between the given node and the previous node.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The node to verify.</span>
         <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
         <span class="s0">* </span><span class="s1">@private</span>
         <span class="s0">*/</span>
        <span class="s6">function </span><span class="s2">verify</span><span class="s4">(</span><span class="s2">node</span><span class="s4">) {</span>
            <span class="s6">const </span><span class="s2">parentType </span><span class="s4">= </span><span class="s2">node</span><span class="s4">.</span><span class="s2">parent</span><span class="s4">.</span><span class="s2">type</span><span class="s4">;</span>
            <span class="s6">const </span><span class="s2">validParent </span><span class="s4">=</span>
                <span class="s2">astUtils</span><span class="s4">.</span><span class="s2">STATEMENT_LIST_PARENTS</span><span class="s4">.</span><span class="s2">has</span><span class="s4">(</span><span class="s2">parentType</span><span class="s4">) ||</span>
                <span class="s2">parentType </span><span class="s4">=== </span><span class="s3">&quot;SwitchStatement&quot;</span><span class="s4">;</span>

            <span class="s6">if </span><span class="s4">(!</span><span class="s2">validParent</span><span class="s4">) {</span>
                <span class="s6">return</span><span class="s4">;</span>
            <span class="s4">}</span>

            <span class="s5">// Save this node as the current previous statement.</span>
            <span class="s6">const </span><span class="s2">prevNode </span><span class="s4">= </span><span class="s2">scopeInfo</span><span class="s4">.</span><span class="s2">prevNode</span><span class="s4">;</span>

            <span class="s5">// Verify.</span>
            <span class="s6">if </span><span class="s4">(</span><span class="s2">prevNode</span><span class="s4">) {</span>
                <span class="s6">const </span><span class="s2">type </span><span class="s4">= </span><span class="s2">getPaddingType</span><span class="s4">(</span><span class="s2">prevNode</span><span class="s4">, </span><span class="s2">node</span><span class="s4">);</span>
                <span class="s6">const </span><span class="s2">paddingLines </span><span class="s4">= </span><span class="s2">getPaddingLineSequences</span><span class="s4">(</span><span class="s2">prevNode</span><span class="s4">, </span><span class="s2">node</span><span class="s4">);</span>

                <span class="s2">type</span><span class="s4">.</span><span class="s2">verify</span><span class="s4">(</span><span class="s2">context</span><span class="s4">, </span><span class="s2">prevNode</span><span class="s4">, </span><span class="s2">node</span><span class="s4">, </span><span class="s2">paddingLines</span><span class="s4">);</span>
            <span class="s4">}</span>

            <span class="s2">scopeInfo</span><span class="s4">.</span><span class="s2">prevNode </span><span class="s4">= </span><span class="s2">node</span><span class="s4">;</span>
        <span class="s4">}</span>

        <span class="s0">/**</span>
         <span class="s0">* Verify padding lines between the given node and the previous node.</span>
         <span class="s0">* Then process to enter to new scope.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The node to verify.</span>
         <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
         <span class="s0">* </span><span class="s1">@private</span>
         <span class="s0">*/</span>
        <span class="s6">function </span><span class="s2">verifyThenEnterScope</span><span class="s4">(</span><span class="s2">node</span><span class="s4">) {</span>
            <span class="s2">verify</span><span class="s4">(</span><span class="s2">node</span><span class="s4">);</span>
            <span class="s2">enterScope</span><span class="s4">();</span>
        <span class="s4">}</span>

        <span class="s6">return </span><span class="s4">{</span>
            <span class="s2">Program</span><span class="s4">: </span><span class="s2">enterScope</span><span class="s4">,</span>
            <span class="s2">BlockStatement</span><span class="s4">: </span><span class="s2">enterScope</span><span class="s4">,</span>
            <span class="s2">SwitchStatement</span><span class="s4">: </span><span class="s2">enterScope</span><span class="s4">,</span>
            <span class="s2">StaticBlock</span><span class="s4">: </span><span class="s2">enterScope</span><span class="s4">,</span>
            <span class="s3">&quot;Program:exit&quot;</span><span class="s4">: </span><span class="s2">exitScope</span><span class="s4">,</span>
            <span class="s3">&quot;BlockStatement:exit&quot;</span><span class="s4">: </span><span class="s2">exitScope</span><span class="s4">,</span>
            <span class="s3">&quot;SwitchStatement:exit&quot;</span><span class="s4">: </span><span class="s2">exitScope</span><span class="s4">,</span>
            <span class="s3">&quot;StaticBlock:exit&quot;</span><span class="s4">: </span><span class="s2">exitScope</span><span class="s4">,</span>

            <span class="s3">&quot;:statement&quot;</span><span class="s4">: </span><span class="s2">verify</span><span class="s4">,</span>

            <span class="s2">SwitchCase</span><span class="s4">: </span><span class="s2">verifyThenEnterScope</span><span class="s4">,</span>
            <span class="s3">&quot;SwitchCase:exit&quot;</span><span class="s4">: </span><span class="s2">exitScope</span>
        <span class="s4">};</span>
    <span class="s4">}</span>
<span class="s4">};</span>
</pre>
</body>
</html>