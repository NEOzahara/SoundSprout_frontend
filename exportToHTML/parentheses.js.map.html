<html>
<head>
<title>parentheses.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
parentheses.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_t&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;_index&quot;</span><span class="s0">,</span><span class="s1">&quot;isArrayTypeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;isBinaryExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isCallExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isForOfStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;isIndexedAccessType&quot;</span><span class="s0">,</span><span class="s1">&quot;isMemberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isObjectPattern&quot;</span><span class="s0">,</span><span class="s1">&quot;isOptionalMemberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isYieldExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;PRECEDENCE&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;getBinaryPrecedence&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;nodeType&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;operator&quot;</span><span class="s0">,</span><span class="s1">&quot;isTSTypeExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isClassExtendsClause&quot;</span><span class="s0">,</span><span class="s1">&quot;parent&quot;</span><span class="s0">,</span><span class="s1">&quot;parentType&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;superClass&quot;</span><span class="s0">,</span><span class="s1">&quot;hasPostfixPart&quot;</span><span class="s0">,</span><span class="s1">&quot;object&quot;</span><span class="s0">,</span><span class="s1">&quot;callee&quot;</span><span class="s0">,</span><span class="s1">&quot;tag&quot;</span><span class="s0">,</span><span class="s1">&quot;NullableTypeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;FunctionTypeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;tokenContext&quot;</span><span class="s0">,</span><span class="s1">&quot;Boolean&quot;</span><span class="s0">,</span><span class="s1">&quot;TokenContext&quot;</span><span class="s0">,</span><span class="s1">&quot;arrowFlowReturnType&quot;</span><span class="s0">,</span><span class="s1">&quot;UpdateExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;needsParenBeforeExpressionBrace&quot;</span><span class="s0">,</span><span class="s1">&quot;expressionStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;arrowBody&quot;</span><span class="s0">,</span><span class="s1">&quot;ObjectExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;DoExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;async&quot;</span><span class="s0">,</span><span class="s1">&quot;Binary&quot;</span><span class="s0">,</span><span class="s1">&quot;left&quot;</span><span class="s0">,</span><span class="s1">&quot;parentPos&quot;</span><span class="s0">,</span><span class="s1">&quot;nodePos&quot;</span><span class="s0">,</span><span class="s1">&quot;right&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;UnionTypeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;OptionalIndexedAccessType&quot;</span><span class="s0">,</span><span class="s1">&quot;objectType&quot;</span><span class="s0">,</span><span class="s1">&quot;TSAsExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;TSConditionalType&quot;</span><span class="s0">,</span><span class="s1">&quot;types&quot;</span><span class="s0">,</span><span class="s1">&quot;checkType&quot;</span><span class="s0">,</span><span class="s1">&quot;extendsType&quot;</span><span class="s0">,</span><span class="s1">&quot;TSUnionType&quot;</span><span class="s0">,</span><span class="s1">&quot;TSIntersectionType&quot;</span><span class="s0">,</span><span class="s1">&quot;TSInferType&quot;</span><span class="s0">,</span><span class="s1">&quot;typeParameter&quot;</span><span class="s0">,</span><span class="s1">&quot;constraint&quot;</span><span class="s0">,</span><span class="s1">&quot;TSTypeOperator&quot;</span><span class="s0">,</span><span class="s1">&quot;TSInstantiationExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;typeParameters&quot;</span><span class="s0">,</span><span class="s1">&quot;TSFunctionType&quot;</span><span class="s0">,</span><span class="s1">&quot;BinaryExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;inForStatementInit&quot;</span><span class="s0">,</span><span class="s1">&quot;SequenceExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;property&quot;</span><span class="s0">,</span><span class="s1">&quot;YieldExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;test&quot;</span><span class="s0">,</span><span class="s1">&quot;ClassExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;exportDefault&quot;</span><span class="s0">,</span><span class="s1">&quot;UnaryLike&quot;</span><span class="s0">,</span><span class="s1">&quot;FunctionExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;ConditionalExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;OptionalMemberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;AssignmentExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;LogicalExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;Identifier&quot;</span><span class="s0">,</span><span class="s1">&quot;_inForInit&quot;</span><span class="s0">,</span><span class="s1">&quot;getRawIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;_node$extra&quot;</span><span class="s0">,</span><span class="s1">&quot;extra&quot;</span><span class="s0">,</span><span class="s1">&quot;parenthesized&quot;</span><span class="s0">,</span><span class="s1">&quot;rightType&quot;</span><span class="s0">,</span><span class="s1">&quot;id&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;isFollowedByBracket&quot;</span><span class="s0">,</span><span class="s1">&quot;computed&quot;</span><span class="s0">,</span><span class="s1">&quot;optional&quot;</span><span class="s0">,</span><span class="s1">&quot;forHead&quot;</span><span class="s0">,</span><span class="s1">&quot;forInHead&quot;</span><span class="s0">,</span><span class="s1">&quot;forOfHead&quot;</span><span class="s0">,</span><span class="s1">&quot;await&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../src/node/parentheses.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import {</span><span class="s3">\n  </span><span class="s1">isArrayTypeAnnotation,</span><span class="s3">\n  </span><span class="s1">isBinaryExpression,</span><span class="s3">\n  </span><span class="s1">isCallExpression,</span><span class="s3">\n  </span><span class="s1">isForOfStatement,</span><span class="s3">\n  </span><span class="s1">isIndexedAccessType,</span><span class="s3">\n  </span><span class="s1">isMemberExpression,</span><span class="s3">\n  </span><span class="s1">isObjectPattern,</span><span class="s3">\n  </span><span class="s1">isOptionalMemberExpression,</span><span class="s3">\n  </span><span class="s1">isYieldExpression,</span><span class="s3">\n  </span><span class="s1">isStatement,</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">@babel/types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type * as t from </span><span class="s3">\&quot;</span><span class="s1">@babel/types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">import { TokenContext } from </span><span class="s3">\&quot;</span><span class="s1">./index.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">const PRECEDENCE = new Map([</span><span class="s3">\n  </span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">||</span><span class="s3">\&quot;</span><span class="s1">, 0],</span><span class="s3">\n  </span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">??</span><span class="s3">\&quot;</span><span class="s1">, 0],</span><span class="s3">\n  </span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">|&gt;</span><span class="s3">\&quot;</span><span class="s1">, 0],</span><span class="s3">\n  </span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">&amp;&amp;</span><span class="s3">\&quot;</span><span class="s1">, 1],</span><span class="s3">\n  </span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot;</span><span class="s1">, 2],</span><span class="s3">\n  </span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">^</span><span class="s3">\&quot;</span><span class="s1">, 3],</span><span class="s3">\n  </span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">&amp;</span><span class="s3">\&quot;</span><span class="s1">, 4],</span><span class="s3">\n  </span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">==</span><span class="s3">\&quot;</span><span class="s1">, 5],</span><span class="s3">\n  </span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">===</span><span class="s3">\&quot;</span><span class="s1">, 5],</span><span class="s3">\n  </span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">!=</span><span class="s3">\&quot;</span><span class="s1">, 5],</span><span class="s3">\n  </span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">!==</span><span class="s3">\&quot;</span><span class="s1">, 5],</span><span class="s3">\n  </span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">&lt;</span><span class="s3">\&quot;</span><span class="s1">, 6],</span><span class="s3">\n  </span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">&gt;</span><span class="s3">\&quot;</span><span class="s1">, 6],</span><span class="s3">\n  </span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">&lt;=</span><span class="s3">\&quot;</span><span class="s1">, 6],</span><span class="s3">\n  </span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">&gt;=</span><span class="s3">\&quot;</span><span class="s1">, 6],</span><span class="s3">\n  </span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">in</span><span class="s3">\&quot;</span><span class="s1">, 6],</span><span class="s3">\n  </span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">instanceof</span><span class="s3">\&quot;</span><span class="s1">, 6],</span><span class="s3">\n  </span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">&gt;&gt;</span><span class="s3">\&quot;</span><span class="s1">, 7],</span><span class="s3">\n  </span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">&lt;&lt;</span><span class="s3">\&quot;</span><span class="s1">, 7],</span><span class="s3">\n  </span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">&gt;&gt;&gt;</span><span class="s3">\&quot;</span><span class="s1">, 7],</span><span class="s3">\n  </span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">, 8],</span><span class="s3">\n  </span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">-</span><span class="s3">\&quot;</span><span class="s1">, 8],</span><span class="s3">\n  </span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">, 9],</span><span class="s3">\n  </span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">, 9],</span><span class="s3">\n  </span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">%</span><span class="s3">\&quot;</span><span class="s1">, 9],</span><span class="s3">\n  </span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">**</span><span class="s3">\&quot;</span><span class="s1">, 10],</span><span class="s3">\n</span><span class="s1">]);</span><span class="s3">\n\n</span><span class="s1">function getBinaryPrecedence(</span><span class="s3">\n  </span><span class="s1">node: t.Binary | t.TSAsExpression | t.TSSatisfiesExpression,</span><span class="s3">\n  </span><span class="s1">nodeType: string,</span><span class="s3">\n</span><span class="s1">): number;</span><span class="s3">\n</span><span class="s1">function getBinaryPrecedence(</span><span class="s3">\n  </span><span class="s1">node: t.Node,</span><span class="s3">\n  </span><span class="s1">nodeType: string,</span><span class="s3">\n</span><span class="s1">): number | undefined;</span><span class="s3">\n</span><span class="s1">function getBinaryPrecedence(node: t.Node, nodeType: string) {</span><span class="s3">\n  </span><span class="s1">if (nodeType === </span><span class="s3">\&quot;</span><span class="s1">BinaryExpression</span><span class="s3">\&quot; </span><span class="s1">|| nodeType === </span><span class="s3">\&quot;</span><span class="s1">LogicalExpression</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return PRECEDENCE.get((node as t.Binary).operator);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (nodeType === </span><span class="s3">\&quot;</span><span class="s1">TSAsExpression</span><span class="s3">\&quot; </span><span class="s1">|| nodeType === </span><span class="s3">\&quot;</span><span class="s1">TSSatisfiesExpression</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return PRECEDENCE.get(</span><span class="s3">\&quot;</span><span class="s1">in</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function isTSTypeExpression(nodeType: string) {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">nodeType === </span><span class="s3">\&quot;</span><span class="s1">TSAsExpression</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n    </span><span class="s1">nodeType === </span><span class="s3">\&quot;</span><span class="s1">TSSatisfiesExpression</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n    </span><span class="s1">nodeType === </span><span class="s3">\&quot;</span><span class="s1">TSTypeAssertion</span><span class="s3">\&quot;\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const isClassExtendsClause = (</span><span class="s3">\n  </span><span class="s1">node: t.Node,</span><span class="s3">\n  </span><span class="s1">parent: t.Node,</span><span class="s3">\n</span><span class="s1">): parent is t.Class =&gt; {</span><span class="s3">\n  </span><span class="s1">const parentType = parent.type;</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">(parentType === </span><span class="s3">\&quot;</span><span class="s1">ClassDeclaration</span><span class="s3">\&quot; </span><span class="s1">|| parentType === </span><span class="s3">\&quot;</span><span class="s1">ClassExpression</span><span class="s3">\&quot;</span><span class="s1">) &amp;&amp;</span><span class="s3">\n    </span><span class="s1">parent.superClass === node</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">const hasPostfixPart = (node: t.Node, parent: t.Node) =&gt; {</span><span class="s3">\n  </span><span class="s1">const parentType = parent.type;</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">((parentType === </span><span class="s3">\&quot;</span><span class="s1">MemberExpression</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n      </span><span class="s1">parentType === </span><span class="s3">\&quot;</span><span class="s1">OptionalMemberExpression</span><span class="s3">\&quot;</span><span class="s1">) &amp;&amp;</span><span class="s3">\n      </span><span class="s1">parent.object === node) ||</span><span class="s3">\n    </span><span class="s1">((parentType === </span><span class="s3">\&quot;</span><span class="s1">CallExpression</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n      </span><span class="s1">parentType === </span><span class="s3">\&quot;</span><span class="s1">OptionalCallExpression</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n      </span><span class="s1">parentType === </span><span class="s3">\&quot;</span><span class="s1">NewExpression</span><span class="s3">\&quot;</span><span class="s1">) &amp;&amp;</span><span class="s3">\n      </span><span class="s1">parent.callee === node) ||</span><span class="s3">\n    </span><span class="s1">(parentType === </span><span class="s3">\&quot;</span><span class="s1">TaggedTemplateExpression</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; parent.tag === node) ||</span><span class="s3">\n    </span><span class="s1">parentType === </span><span class="s3">\&quot;</span><span class="s1">TSNonNullExpression</span><span class="s3">\&quot;\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export function NullableTypeAnnotation(</span><span class="s3">\n  </span><span class="s1">node: t.NullableTypeAnnotation,</span><span class="s3">\n  </span><span class="s1">parent: t.Node,</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">return isArrayTypeAnnotation(parent);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function FunctionTypeAnnotation(</span><span class="s3">\n  </span><span class="s1">node: t.FunctionTypeAnnotation,</span><span class="s3">\n  </span><span class="s1">parent: t.Node,</span><span class="s3">\n  </span><span class="s1">tokenContext: number,</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">const parentType = parent.type;</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">// (() =&gt; A) | (() =&gt; B)</span><span class="s3">\n    </span><span class="s1">parentType === </span><span class="s3">\&quot;</span><span class="s1">UnionTypeAnnotation</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n    </span><span class="s1">// (() =&gt; A) &amp; (() =&gt; B)</span><span class="s3">\n    </span><span class="s1">parentType === </span><span class="s3">\&quot;</span><span class="s1">IntersectionTypeAnnotation</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n    </span><span class="s1">// (() =&gt; A)[]</span><span class="s3">\n    </span><span class="s1">parentType === </span><span class="s3">\&quot;</span><span class="s1">ArrayTypeAnnotation</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n    </span><span class="s1">Boolean(tokenContext &amp; TokenContext.arrowFlowReturnType)</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function UpdateExpression(</span><span class="s3">\n  </span><span class="s1">node: t.UpdateExpression,</span><span class="s3">\n  </span><span class="s1">parent: t.Node,</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">return hasPostfixPart(node, parent) || isClassExtendsClause(node, parent);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function needsParenBeforeExpressionBrace(tokenContext: number) {</span><span class="s3">\n  </span><span class="s1">return Boolean(</span><span class="s3">\n    </span><span class="s1">tokenContext &amp; (TokenContext.expressionStatement | TokenContext.arrowBody),</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function ObjectExpression(</span><span class="s3">\n  </span><span class="s1">node: t.ObjectExpression,</span><span class="s3">\n  </span><span class="s1">parent: t.Node,</span><span class="s3">\n  </span><span class="s1">tokenContext: number,</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">return needsParenBeforeExpressionBrace(tokenContext);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function DoExpression(</span><span class="s3">\n  </span><span class="s1">node: t.DoExpression,</span><span class="s3">\n  </span><span class="s1">parent: t.Node,</span><span class="s3">\n  </span><span class="s1">tokenContext: number,</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">// `async do` can start an expression statement</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">!node.async &amp;&amp; Boolean(tokenContext &amp; TokenContext.expressionStatement)</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function Binary(</span><span class="s3">\n  </span><span class="s1">node: t.Binary | t.TSAsExpression | t.TSSatisfiesExpression,</span><span class="s3">\n  </span><span class="s1">parent: t.Node,</span><span class="s3">\n</span><span class="s1">): boolean | undefined {</span><span class="s3">\n  </span><span class="s1">const parentType = parent.type;</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">node.type === </span><span class="s3">\&quot;</span><span class="s1">BinaryExpression</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n    </span><span class="s1">node.operator === </span><span class="s3">\&quot;</span><span class="s1">**</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n    </span><span class="s1">parentType === </span><span class="s3">\&quot;</span><span class="s1">BinaryExpression</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n    </span><span class="s1">parent.operator === </span><span class="s3">\&quot;</span><span class="s1">**</span><span class="s3">\&quot;\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return parent.left === node;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (isClassExtendsClause(node, parent)) {</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">hasPostfixPart(node, parent) ||</span><span class="s3">\n    </span><span class="s1">parentType === </span><span class="s3">\&quot;</span><span class="s1">UnaryExpression</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n    </span><span class="s1">parentType === </span><span class="s3">\&quot;</span><span class="s1">SpreadElement</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n    </span><span class="s1">parentType === </span><span class="s3">\&quot;</span><span class="s1">AwaitExpression</span><span class="s3">\&quot;\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const parentPos = getBinaryPrecedence(parent, parentType);</span><span class="s3">\n  </span><span class="s1">if (parentPos != null) {</span><span class="s3">\n    </span><span class="s1">const nodePos = getBinaryPrecedence(node, node.type);</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">// Logical expressions with the same precedence don't need parens.</span><span class="s3">\n      </span><span class="s1">(parentPos === nodePos &amp;&amp;</span><span class="s3">\n        </span><span class="s1">parentType === </span><span class="s3">\&quot;</span><span class="s1">BinaryExpression</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n        </span><span class="s1">parent.right === node) ||</span><span class="s3">\n      </span><span class="s1">parentPos &gt; nodePos</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return undefined;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function UnionTypeAnnotation(</span><span class="s3">\n  </span><span class="s1">node: t.UnionTypeAnnotation,</span><span class="s3">\n  </span><span class="s1">parent: t.Node,</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">const parentType = parent.type;</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">parentType === </span><span class="s3">\&quot;</span><span class="s1">ArrayTypeAnnotation</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n    </span><span class="s1">parentType === </span><span class="s3">\&quot;</span><span class="s1">NullableTypeAnnotation</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n    </span><span class="s1">parentType === </span><span class="s3">\&quot;</span><span class="s1">IntersectionTypeAnnotation</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n    </span><span class="s1">parentType === </span><span class="s3">\&quot;</span><span class="s1">UnionTypeAnnotation</span><span class="s3">\&quot;\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { UnionTypeAnnotation as IntersectionTypeAnnotation };</span><span class="s3">\n\n</span><span class="s1">export function OptionalIndexedAccessType(</span><span class="s3">\n  </span><span class="s1">node: t.OptionalIndexedAccessType,</span><span class="s3">\n  </span><span class="s1">parent: t.Node,</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">return isIndexedAccessType(parent) &amp;&amp; parent.objectType === node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function TSAsExpression(</span><span class="s3">\n  </span><span class="s1">node: t.TSAsExpression | t.TSSatisfiesExpression,</span><span class="s3">\n  </span><span class="s1">parent: t.Node,</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">(parent.type === </span><span class="s3">\&quot;</span><span class="s1">AssignmentExpression</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n      </span><span class="s1">parent.type === </span><span class="s3">\&quot;</span><span class="s1">AssignmentPattern</span><span class="s3">\&quot;</span><span class="s1">) &amp;&amp;</span><span class="s3">\n    </span><span class="s1">parent.left === node</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">parent.type === </span><span class="s3">\&quot;</span><span class="s1">BinaryExpression</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n    </span><span class="s1">(parent.operator === </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">|| parent.operator === </span><span class="s3">\&quot;</span><span class="s1">&amp;</span><span class="s3">\&quot;</span><span class="s1">) &amp;&amp;</span><span class="s3">\n    </span><span class="s1">node === parent.left</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return Binary(node, parent);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { TSAsExpression as TSSatisfiesExpression };</span><span class="s3">\n\n</span><span class="s1">export { UnaryLike as TSTypeAssertion };</span><span class="s3">\n\n</span><span class="s1">export function TSConditionalType(</span><span class="s3">\n  </span><span class="s1">node: t.TSConditionalType,</span><span class="s3">\n  </span><span class="s1">parent: t.Node,</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">const parentType = parent.type;</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">parentType === </span><span class="s3">\&quot;</span><span class="s1">TSArrayType</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n    </span><span class="s1">(parentType === </span><span class="s3">\&quot;</span><span class="s1">TSIndexedAccessType</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; parent.objectType === node) ||</span><span class="s3">\n    </span><span class="s1">parentType === </span><span class="s3">\&quot;</span><span class="s1">TSOptionalType</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n    </span><span class="s1">parentType === </span><span class="s3">\&quot;</span><span class="s1">TSTypeOperator</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n    </span><span class="s1">// for `infer K extends (L extends M ? M : ...)`</span><span class="s3">\n    </span><span class="s1">parentType === </span><span class="s3">\&quot;</span><span class="s1">TSTypeParameter</span><span class="s3">\&quot;\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">(parentType === </span><span class="s3">\&quot;</span><span class="s1">TSIntersectionType</span><span class="s3">\&quot; </span><span class="s1">|| parentType === </span><span class="s3">\&quot;</span><span class="s1">TSUnionType</span><span class="s3">\&quot;</span><span class="s1">) &amp;&amp;</span><span class="s3">\n    </span><span class="s1">parent.types[0] === node</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">parentType === </span><span class="s3">\&quot;</span><span class="s1">TSConditionalType</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n    </span><span class="s1">(parent.checkType === node || parent.extendsType === node)</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function TSUnionType(node: t.TSUnionType, parent: t.Node): boolean {</span><span class="s3">\n  </span><span class="s1">const parentType = parent.type;</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">parentType === </span><span class="s3">\&quot;</span><span class="s1">TSIntersectionType</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n    </span><span class="s1">parentType === </span><span class="s3">\&quot;</span><span class="s1">TSTypeOperator</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n    </span><span class="s1">parentType === </span><span class="s3">\&quot;</span><span class="s1">TSArrayType</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n    </span><span class="s1">(parentType === </span><span class="s3">\&quot;</span><span class="s1">TSIndexedAccessType</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; parent.objectType === node) ||</span><span class="s3">\n    </span><span class="s1">parentType === </span><span class="s3">\&quot;</span><span class="s1">TSOptionalType</span><span class="s3">\&quot;\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function TSIntersectionType(</span><span class="s3">\n  </span><span class="s1">node: t.TSUnionType,</span><span class="s3">\n  </span><span class="s1">parent: t.Node,</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">const parentType = parent.type;</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">parentType === </span><span class="s3">\&quot;</span><span class="s1">TSTypeOperator</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n    </span><span class="s1">parentType === </span><span class="s3">\&quot;</span><span class="s1">TSArrayType</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n    </span><span class="s1">(parentType === </span><span class="s3">\&quot;</span><span class="s1">TSIndexedAccessType</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; parent.objectType === node) ||</span><span class="s3">\n    </span><span class="s1">parentType === </span><span class="s3">\&quot;</span><span class="s1">TSOptionalType</span><span class="s3">\&quot;\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function TSInferType(node: t.TSInferType, parent: t.Node): boolean {</span><span class="s3">\n  </span><span class="s1">const parentType = parent.type;</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">parentType === </span><span class="s3">\&quot;</span><span class="s1">TSArrayType</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n    </span><span class="s1">(parentType === </span><span class="s3">\&quot;</span><span class="s1">TSIndexedAccessType</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; parent.objectType === node) ||</span><span class="s3">\n    </span><span class="s1">parentType === </span><span class="s3">\&quot;</span><span class="s1">TSOptionalType</span><span class="s3">\&quot;\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (node.typeParameter.constraint) {</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">(parentType === </span><span class="s3">\&quot;</span><span class="s1">TSIntersectionType</span><span class="s3">\&quot; </span><span class="s1">|| parentType === </span><span class="s3">\&quot;</span><span class="s1">TSUnionType</span><span class="s3">\&quot;</span><span class="s1">) &amp;&amp;</span><span class="s3">\n      </span><span class="s1">parent.types[0] === node</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function TSTypeOperator(</span><span class="s3">\n  </span><span class="s1">node: t.TSTypeOperator,</span><span class="s3">\n  </span><span class="s1">parent: t.Node,</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">const parentType = parent.type;</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">parentType === </span><span class="s3">\&quot;</span><span class="s1">TSArrayType</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n    </span><span class="s1">(parentType === </span><span class="s3">\&quot;</span><span class="s1">TSIndexedAccessType</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; parent.objectType === node) ||</span><span class="s3">\n    </span><span class="s1">parentType === </span><span class="s3">\&quot;</span><span class="s1">TSOptionalType</span><span class="s3">\&quot;\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function TSInstantiationExpression(</span><span class="s3">\n  </span><span class="s1">node: t.TSInstantiationExpression,</span><span class="s3">\n  </span><span class="s1">parent: t.Node,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const parentType = parent.type;</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">(parentType === </span><span class="s3">\&quot;</span><span class="s1">CallExpression</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n      </span><span class="s1">parentType === </span><span class="s3">\&quot;</span><span class="s1">OptionalCallExpression</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n      </span><span class="s1">parentType === </span><span class="s3">\&quot;</span><span class="s1">NewExpression</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n      </span><span class="s1">parentType === </span><span class="s3">\&quot;</span><span class="s1">TSInstantiationExpression</span><span class="s3">\&quot;</span><span class="s1">) &amp;&amp;</span><span class="s3">\n    </span><span class="s1">!!(process.env.BABEL_8_BREAKING</span><span class="s3">\n      </span><span class="s1">? // @ts-ignore(Babel 7 vs Babel 8) Babel 8 AST</span><span class="s3">\n        </span><span class="s1">parent.typeArguments</span><span class="s3">\n      </span><span class="s1">: // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST</span><span class="s3">\n        </span><span class="s1">parent.typeParameters)</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function TSFunctionType(</span><span class="s3">\n  </span><span class="s1">node: t.TSFunctionType,</span><span class="s3">\n  </span><span class="s1">parent: t.Node,</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">const parentType = parent.type;</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">parentType === </span><span class="s3">\&quot;</span><span class="s1">TSIntersectionType</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n    </span><span class="s1">parentType === </span><span class="s3">\&quot;</span><span class="s1">TSUnionType</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n    </span><span class="s1">parentType === </span><span class="s3">\&quot;</span><span class="s1">TSTypeOperator</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n    </span><span class="s1">parentType === </span><span class="s3">\&quot;</span><span class="s1">TSOptionalType</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n    </span><span class="s1">parentType === </span><span class="s3">\&quot;</span><span class="s1">TSArrayType</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n    </span><span class="s1">(parentType === </span><span class="s3">\&quot;</span><span class="s1">TSIndexedAccessType</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; parent.objectType === node) ||</span><span class="s3">\n    </span><span class="s1">(parentType === </span><span class="s3">\&quot;</span><span class="s1">TSConditionalType</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n      </span><span class="s1">(parent.checkType === node || parent.extendsType === node))</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { TSFunctionType as TSConstructorType };</span><span class="s3">\n\n</span><span class="s1">export function BinaryExpression(</span><span class="s3">\n  </span><span class="s1">node: t.BinaryExpression,</span><span class="s3">\n  </span><span class="s1">parent: t.Node,</span><span class="s3">\n  </span><span class="s1">tokenContext: unknown,</span><span class="s3">\n  </span><span class="s1">inForStatementInit: boolean,</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">// for ((1 in []);;);</span><span class="s3">\n  </span><span class="s1">// for (var x = (1 in []) in 2);</span><span class="s3">\n  </span><span class="s1">return node.operator === </span><span class="s3">\&quot;</span><span class="s1">in</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; inForStatementInit;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function SequenceExpression(</span><span class="s3">\n  </span><span class="s1">node: t.SequenceExpression,</span><span class="s3">\n  </span><span class="s1">parent: t.Node,</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">const parentType = parent.type;</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">parentType === </span><span class="s3">\&quot;</span><span class="s1">SequenceExpression</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n    </span><span class="s1">parentType === </span><span class="s3">\&quot;</span><span class="s1">ParenthesizedExpression</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n    </span><span class="s1">(parentType === </span><span class="s3">\&quot;</span><span class="s1">MemberExpression</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; parent.property === node) ||</span><span class="s3">\n    </span><span class="s1">(parentType === </span><span class="s3">\&quot;</span><span class="s1">OptionalMemberExpression</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; parent.property === node) ||</span><span class="s3">\n    </span><span class="s1">parentType === </span><span class="s3">\&quot;</span><span class="s1">TemplateLiteral</span><span class="s3">\&quot;\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (parentType === </span><span class="s3">\&quot;</span><span class="s1">ClassDeclaration</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (parentType === </span><span class="s3">\&quot;</span><span class="s1">ForOfStatement</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return parent.right === node;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (parentType === </span><span class="s3">\&quot;</span><span class="s1">ExportDefaultDeclaration</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return !isStatement(parent);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function YieldExpression(</span><span class="s3">\n  </span><span class="s1">node: t.YieldExpression,</span><span class="s3">\n  </span><span class="s1">parent: t.Node,</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">const parentType = parent.type;</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">parentType === </span><span class="s3">\&quot;</span><span class="s1">BinaryExpression</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n    </span><span class="s1">parentType === </span><span class="s3">\&quot;</span><span class="s1">LogicalExpression</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n    </span><span class="s1">parentType === </span><span class="s3">\&quot;</span><span class="s1">UnaryExpression</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n    </span><span class="s1">parentType === </span><span class="s3">\&quot;</span><span class="s1">SpreadElement</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n    </span><span class="s1">hasPostfixPart(node, parent) ||</span><span class="s3">\n    </span><span class="s1">(parentType === </span><span class="s3">\&quot;</span><span class="s1">AwaitExpression</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; isYieldExpression(node)) ||</span><span class="s3">\n    </span><span class="s1">(parentType === </span><span class="s3">\&quot;</span><span class="s1">ConditionalExpression</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; node === parent.test) ||</span><span class="s3">\n    </span><span class="s1">isClassExtendsClause(node, parent) ||</span><span class="s3">\n    </span><span class="s1">isTSTypeExpression(parentType)</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { YieldExpression as AwaitExpression };</span><span class="s3">\n\n</span><span class="s1">export function ClassExpression(</span><span class="s3">\n  </span><span class="s1">node: t.ClassExpression,</span><span class="s3">\n  </span><span class="s1">parent: t.Node,</span><span class="s3">\n  </span><span class="s1">tokenContext: number,</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">return Boolean(</span><span class="s3">\n    </span><span class="s1">tokenContext &amp;</span><span class="s3">\n      </span><span class="s1">(TokenContext.expressionStatement | TokenContext.exportDefault),</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function UnaryLike(</span><span class="s3">\n  </span><span class="s1">node:</span><span class="s3">\n    </span><span class="s1">| t.UnaryLike</span><span class="s3">\n    </span><span class="s1">| t.TSTypeAssertion</span><span class="s3">\n    </span><span class="s1">| t.ArrowFunctionExpression</span><span class="s3">\n    </span><span class="s1">| t.ConditionalExpression</span><span class="s3">\n    </span><span class="s1">| t.AssignmentExpression,</span><span class="s3">\n  </span><span class="s1">parent: t.Node,</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">hasPostfixPart(node, parent) ||</span><span class="s3">\n    </span><span class="s1">(isBinaryExpression(parent) &amp;&amp;</span><span class="s3">\n      </span><span class="s1">parent.operator === </span><span class="s3">\&quot;</span><span class="s1">**</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n      </span><span class="s1">parent.left === node) ||</span><span class="s3">\n    </span><span class="s1">isClassExtendsClause(node, parent)</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function FunctionExpression(</span><span class="s3">\n  </span><span class="s1">node: t.FunctionExpression,</span><span class="s3">\n  </span><span class="s1">parent: t.Node,</span><span class="s3">\n  </span><span class="s1">tokenContext: number,</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">return Boolean(</span><span class="s3">\n    </span><span class="s1">tokenContext &amp;</span><span class="s3">\n      </span><span class="s1">(TokenContext.expressionStatement | TokenContext.exportDefault),</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function ConditionalExpression(</span><span class="s3">\n  </span><span class="s1">node:</span><span class="s3">\n    </span><span class="s1">| t.ConditionalExpression</span><span class="s3">\n    </span><span class="s1">| t.ArrowFunctionExpression</span><span class="s3">\n    </span><span class="s1">| t.AssignmentExpression,</span><span class="s3">\n  </span><span class="s1">parent?: t.Node,</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">const parentType = parent.type;</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">parentType === </span><span class="s3">\&quot;</span><span class="s1">UnaryExpression</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n    </span><span class="s1">parentType === </span><span class="s3">\&quot;</span><span class="s1">SpreadElement</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n    </span><span class="s1">parentType === </span><span class="s3">\&quot;</span><span class="s1">BinaryExpression</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n    </span><span class="s1">parentType === </span><span class="s3">\&quot;</span><span class="s1">LogicalExpression</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n    </span><span class="s1">(parentType === </span><span class="s3">\&quot;</span><span class="s1">ConditionalExpression</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; parent.test === node) ||</span><span class="s3">\n    </span><span class="s1">parentType === </span><span class="s3">\&quot;</span><span class="s1">AwaitExpression</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n    </span><span class="s1">isTSTypeExpression(parentType)</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return UnaryLike(node, parent);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { ConditionalExpression as ArrowFunctionExpression };</span><span class="s3">\n\n</span><span class="s1">export function OptionalMemberExpression(</span><span class="s3">\n  </span><span class="s1">node: t.OptionalMemberExpression,</span><span class="s3">\n  </span><span class="s1">parent: t.Node,</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">(isCallExpression(parent) &amp;&amp; parent.callee === node) ||</span><span class="s3">\n    </span><span class="s1">(isMemberExpression(parent) &amp;&amp; parent.object === node)</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { OptionalMemberExpression as OptionalCallExpression };</span><span class="s3">\n\n</span><span class="s1">export function AssignmentExpression(</span><span class="s3">\n  </span><span class="s1">node: t.AssignmentExpression,</span><span class="s3">\n  </span><span class="s1">parent: t.Node,</span><span class="s3">\n  </span><span class="s1">tokenContext: number,</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">needsParenBeforeExpressionBrace(tokenContext) &amp;&amp;</span><span class="s3">\n    </span><span class="s1">isObjectPattern(node.left)</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return ConditionalExpression(node, parent);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function LogicalExpression(</span><span class="s3">\n  </span><span class="s1">node: t.LogicalExpression,</span><span class="s3">\n  </span><span class="s1">parent: t.Node,</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">const parentType = parent.type;</span><span class="s3">\n  </span><span class="s1">if (isTSTypeExpression(parentType)) return true;</span><span class="s3">\n  </span><span class="s1">if (parentType !== </span><span class="s3">\&quot;</span><span class="s1">LogicalExpression</span><span class="s3">\&quot;</span><span class="s1">) return false;</span><span class="s3">\n  </span><span class="s1">switch (node.operator) {</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">||</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">return parent.operator === </span><span class="s3">\&quot;</span><span class="s1">??</span><span class="s3">\&quot; </span><span class="s1">|| parent.operator === </span><span class="s3">\&quot;</span><span class="s1">&amp;&amp;</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">&amp;&amp;</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">return parent.operator === </span><span class="s3">\&quot;</span><span class="s1">??</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">??</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">return parent.operator !== </span><span class="s3">\&quot;</span><span class="s1">??</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function Identifier(</span><span class="s3">\n  </span><span class="s1">node: t.Identifier,</span><span class="s3">\n  </span><span class="s1">parent: t.Node,</span><span class="s3">\n  </span><span class="s1">tokenContext: number,</span><span class="s3">\n  </span><span class="s1">_inForInit: boolean,</span><span class="s3">\n  </span><span class="s1">getRawIdentifier: (node: t.Identifier) =&gt; string,</span><span class="s3">\n</span><span class="s1">): boolean {</span><span class="s3">\n  </span><span class="s1">const parentType = parent.type;</span><span class="s3">\n  </span><span class="s1">// 13.15.2 AssignmentExpression RS: Evaluation</span><span class="s3">\n  </span><span class="s1">// (fn) = function () {};</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">node.extra?.parenthesized &amp;&amp;</span><span class="s3">\n    </span><span class="s1">parentType === </span><span class="s3">\&quot;</span><span class="s1">AssignmentExpression</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n    </span><span class="s1">parent.left === node</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">const rightType = parent.right.type;</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">(rightType === </span><span class="s3">\&quot;</span><span class="s1">FunctionExpression</span><span class="s3">\&quot; </span><span class="s1">|| rightType === </span><span class="s3">\&quot;</span><span class="s1">ClassExpression</span><span class="s3">\&quot;</span><span class="s1">) &amp;&amp;</span><span class="s3">\n      </span><span class="s1">parent.right.id == null</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (getRawIdentifier &amp;&amp; getRawIdentifier(node) !== node.name) {</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Non-strict code allows the identifier `let`, but it cannot occur as-is in</span><span class="s3">\n  </span><span class="s1">// certain contexts to avoid ambiguity with contextual keyword `let`.</span><span class="s3">\n  </span><span class="s1">if (node.name === </span><span class="s3">\&quot;</span><span class="s1">let</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">// Some contexts only forbid `let [`, so check if the next token would</span><span class="s3">\n    </span><span class="s1">// be the left bracket of a computed member expression.</span><span class="s3">\n    </span><span class="s1">const isFollowedByBracket =</span><span class="s3">\n      </span><span class="s1">isMemberExpression(parent, {</span><span class="s3">\n        </span><span class="s1">object: node,</span><span class="s3">\n        </span><span class="s1">computed: true,</span><span class="s3">\n      </span><span class="s1">}) ||</span><span class="s3">\n      </span><span class="s1">isOptionalMemberExpression(parent, {</span><span class="s3">\n        </span><span class="s1">object: node,</span><span class="s3">\n        </span><span class="s1">computed: true,</span><span class="s3">\n        </span><span class="s1">optional: false,</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">isFollowedByBracket &amp;&amp;</span><span class="s3">\n      </span><span class="s1">tokenContext &amp;</span><span class="s3">\n        </span><span class="s1">(TokenContext.expressionStatement |</span><span class="s3">\n          </span><span class="s1">TokenContext.forHead |</span><span class="s3">\n          </span><span class="s1">TokenContext.forInHead)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return Boolean(tokenContext &amp; TokenContext.forOfHead);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// ECMAScript specifically forbids a for-of loop from starting with the</span><span class="s3">\n  </span><span class="s1">// token sequence `for (async of`, because it would be ambiguous with</span><span class="s3">\n  </span><span class="s1">// `for (async of =&gt; {};;)`, so we need to add extra parentheses.</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">node.name === </span><span class="s3">\&quot;</span><span class="s1">async</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n    </span><span class="s1">isForOfStatement(parent, { left: node, await: false })</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[]}</span></pre>
</body>
</html>