<html>
<head>
<title>printer.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
printer.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_buffer&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;n&quot;</span><span class="s0">,</span><span class="s1">&quot;_t&quot;</span><span class="s0">,</span><span class="s1">&quot;_tokenMap&quot;</span><span class="s0">,</span><span class="s1">&quot;generatorFunctions&quot;</span><span class="s0">,</span><span class="s1">&quot;_deprecated&quot;</span><span class="s0">,</span><span class="s1">&quot;isExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isFunction&quot;</span><span class="s0">,</span><span class="s1">&quot;isStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;isClassBody&quot;</span><span class="s0">,</span><span class="s1">&quot;isTSInterfaceBody&quot;</span><span class="s0">,</span><span class="s1">&quot;isTSEnumMember&quot;</span><span class="s0">,</span><span class="s1">&quot;SCIENTIFIC_NOTATION&quot;</span><span class="s0">,</span><span class="s1">&quot;ZERO_DECIMAL_INTEGER&quot;</span><span class="s0">,</span><span class="s1">&quot;HAS_NEWLINE&quot;</span><span class="s0">,</span><span class="s1">&quot;HAS_NEWLINE_OR_BlOCK_COMMENT_END&quot;</span><span class="s0">,</span><span class="s1">&quot;commentIsNewline&quot;</span><span class="s0">,</span><span class="s1">&quot;c&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;test&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;needsParens&quot;</span><span class="s0">,</span><span class="s1">&quot;Printer&quot;</span><span class="s0">,</span><span class="s1">&quot;constructor&quot;</span><span class="s0">,</span><span class="s1">&quot;format&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;tokens&quot;</span><span class="s0">,</span><span class="s1">&quot;originalCode&quot;</span><span class="s0">,</span><span class="s1">&quot;inForStatementInit&quot;</span><span class="s0">,</span><span class="s1">&quot;tokenContext&quot;</span><span class="s0">,</span><span class="s1">&quot;_tokens&quot;</span><span class="s0">,</span><span class="s1">&quot;_originalCode&quot;</span><span class="s0">,</span><span class="s1">&quot;_currentNode&quot;</span><span class="s0">,</span><span class="s1">&quot;_indent&quot;</span><span class="s0">,</span><span class="s1">&quot;_indentRepeat&quot;</span><span class="s0">,</span><span class="s1">&quot;_insideAux&quot;</span><span class="s0">,</span><span class="s1">&quot;_noLineTerminator&quot;</span><span class="s0">,</span><span class="s1">&quot;_noLineTerminatorAfterNode&quot;</span><span class="s0">,</span><span class="s1">&quot;_printAuxAfterOnNextUserNode&quot;</span><span class="s0">,</span><span class="s1">&quot;_printedComments&quot;</span><span class="s0">,</span><span class="s1">&quot;Set&quot;</span><span class="s0">,</span><span class="s1">&quot;_endsWithInteger&quot;</span><span class="s0">,</span><span class="s1">&quot;_endsWithWord&quot;</span><span class="s0">,</span><span class="s1">&quot;_endsWithDiv&quot;</span><span class="s0">,</span><span class="s1">&quot;_lastCommentLine&quot;</span><span class="s0">,</span><span class="s1">&quot;_endsWithInnerRaw&quot;</span><span class="s0">,</span><span class="s1">&quot;_indentInnerComments&quot;</span><span class="s0">,</span><span class="s1">&quot;tokenMap&quot;</span><span class="s0">,</span><span class="s1">&quot;_boundGetRawIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;_getRawIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;bind&quot;</span><span class="s0">,</span><span class="s1">&quot;_printSemicolonBeforeNextNode&quot;</span><span class="s0">,</span><span class="s1">&quot;_printSemicolonBeforeNextToken&quot;</span><span class="s0">,</span><span class="s1">&quot;indent&quot;</span><span class="s0">,</span><span class="s1">&quot;style&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;_inputMap&quot;</span><span class="s0">,</span><span class="s1">&quot;_buf&quot;</span><span class="s0">,</span><span class="s1">&quot;Buffer&quot;</span><span class="s0">,</span><span class="s1">&quot;enterForStatementInit&quot;</span><span class="s0">,</span><span class="s1">&quot;enterDelimited&quot;</span><span class="s0">,</span><span class="s1">&quot;oldInForStatementInit&quot;</span><span class="s0">,</span><span class="s1">&quot;oldNoLineTerminatorAfterNode&quot;</span><span class="s0">,</span><span class="s1">&quot;generate&quot;</span><span class="s0">,</span><span class="s1">&quot;ast&quot;</span><span class="s0">,</span><span class="s1">&quot;preserveFormat&quot;</span><span class="s0">,</span><span class="s1">&quot;TokenMap&quot;</span><span class="s0">,</span><span class="s1">&quot;print&quot;</span><span class="s0">,</span><span class="s1">&quot;_maybeAddAuxComment&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;compact&quot;</span><span class="s0">,</span><span class="s1">&quot;concise&quot;</span><span class="s0">,</span><span class="s1">&quot;dedent&quot;</span><span class="s0">,</span><span class="s1">&quot;semicolon&quot;</span><span class="s0">,</span><span class="s1">&quot;force&quot;</span><span class="s0">,</span><span class="s1">&quot;_appendChar&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;start&quot;</span><span class="s0">,</span><span class="s1">&quot;end&quot;</span><span class="s0">,</span><span class="s1">&quot;endMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;getCurrentLine&quot;</span><span class="s0">,</span><span class="s1">&quot;indexes&quot;</span><span class="s0">,</span><span class="s1">&quot;getIndexes&quot;</span><span class="s0">,</span><span class="s1">&quot;_catchUpTo&quot;</span><span class="s0">,</span><span class="s1">&quot;loc&quot;</span><span class="s0">,</span><span class="s1">&quot;_queue&quot;</span><span class="s0">,</span><span class="s1">&quot;rightBrace&quot;</span><span class="s0">,</span><span class="s1">&quot;minified&quot;</span><span class="s0">,</span><span class="s1">&quot;removeLastSemicolon&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceWithOffset&quot;</span><span class="s0">,</span><span class="s1">&quot;token&quot;</span><span class="s0">,</span><span class="s1">&quot;rightParens&quot;</span><span class="s0">,</span><span class="s1">&quot;space&quot;</span><span class="s0">,</span><span class="s1">&quot;_space&quot;</span><span class="s0">,</span><span class="s1">&quot;hasContent&quot;</span><span class="s0">,</span><span class="s1">&quot;lastCp&quot;</span><span class="s0">,</span><span class="s1">&quot;getLastChar&quot;</span><span class="s0">,</span><span class="s1">&quot;word&quot;</span><span class="s0">,</span><span class="s1">&quot;str&quot;</span><span class="s0">,</span><span class="s1">&quot;noLineTerminatorAfter&quot;</span><span class="s0">,</span><span class="s1">&quot;_maybePrintInnerComments&quot;</span><span class="s0">,</span><span class="s1">&quot;_catchUpToCurrentToken&quot;</span><span class="s0">,</span><span class="s1">&quot;charCodeAt&quot;</span><span class="s0">,</span><span class="s1">&quot;_append&quot;</span><span class="s0">,</span><span class="s1">&quot;number&quot;</span><span class="s0">,</span><span class="s1">&quot;isNonDecimalLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;secondChar&quot;</span><span class="s0">,</span><span class="s1">&quot;Number&quot;</span><span class="s0">,</span><span class="s1">&quot;isInteger&quot;</span><span class="s0">,</span><span class="s1">&quot;maybeNewline&quot;</span><span class="s0">,</span><span class="s1">&quot;occurrenceCount&quot;</span><span class="s0">,</span><span class="s1">&quot;lastChar&quot;</span><span class="s0">,</span><span class="s1">&quot;strFirst&quot;</span><span class="s0">,</span><span class="s1">&quot;tokenChar&quot;</span><span class="s0">,</span><span class="s1">&quot;char&quot;</span><span class="s0">,</span><span class="s1">&quot;String&quot;</span><span class="s0">,</span><span class="s1">&quot;fromCharCode&quot;</span><span class="s0">,</span><span class="s1">&quot;newline&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;retainLines&quot;</span><span class="s0">,</span><span class="s1">&quot;getNewlineCount&quot;</span><span class="s0">,</span><span class="s1">&quot;j&quot;</span><span class="s0">,</span><span class="s1">&quot;_newline&quot;</span><span class="s0">,</span><span class="s1">&quot;endsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;endsWithCharAndNewline&quot;</span><span class="s0">,</span><span class="s1">&quot;removeTrailingNewline&quot;</span><span class="s0">,</span><span class="s1">&quot;exactSource&quot;</span><span class="s0">,</span><span class="s1">&quot;cb&quot;</span><span class="s0">,</span><span class="s1">&quot;_catchUp&quot;</span><span class="s0">,</span><span class="s1">&quot;source&quot;</span><span class="s0">,</span><span class="s1">&quot;prop&quot;</span><span class="s0">,</span><span class="s1">&quot;columnOffset&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceIdentifierName&quot;</span><span class="s0">,</span><span class="s1">&quot;identifierName&quot;</span><span class="s0">,</span><span class="s1">&quot;pos&quot;</span><span class="s0">,</span><span class="s1">&quot;_canMarkIdName&quot;</span><span class="s0">,</span><span class="s1">&quot;sourcePosition&quot;</span><span class="s0">,</span><span class="s1">&quot;_sourcePosition&quot;</span><span class="s0">,</span><span class="s1">&quot;identifierNamePos&quot;</span><span class="s0">,</span><span class="s1">&quot;findMatching&quot;</span><span class="s0">,</span><span class="s1">&quot;appendChar&quot;</span><span class="s0">,</span><span class="s1">&quot;_maybeIndent&quot;</span><span class="s0">,</span><span class="s1">&quot;append&quot;</span><span class="s0">,</span><span class="s1">&quot;queue&quot;</span><span class="s0">,</span><span class="s1">&quot;firstChar&quot;</span><span class="s0">,</span><span class="s1">&quot;queueIndentation&quot;</span><span class="s0">,</span><span class="s1">&quot;_getIndent&quot;</span><span class="s0">,</span><span class="s1">&quot;_shouldIndent&quot;</span><span class="s0">,</span><span class="s1">&quot;catchUp&quot;</span><span class="s0">,</span><span class="s1">&quot;line&quot;</span><span class="s0">,</span><span class="s1">&quot;count&quot;</span><span class="s0">,</span><span class="s1">&quot;column&quot;</span><span class="s0">,</span><span class="s1">&quot;index&quot;</span><span class="s0">,</span><span class="s1">&quot;spacesCount&quot;</span><span class="s0">,</span><span class="s1">&quot;getCurrentColumn&quot;</span><span class="s0">,</span><span class="s1">&quot;spaces&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;replace&quot;</span><span class="s0">,</span><span class="s1">&quot;repeat&quot;</span><span class="s0">,</span><span class="s1">&quot;printTerminatorless&quot;</span><span class="s0">,</span><span class="s1">&quot;trailingCommentsLineOffset&quot;</span><span class="s0">,</span><span class="s1">&quot;_node$extra&quot;</span><span class="s0">,</span><span class="s1">&quot;_node$leadingComments&quot;</span><span class="s0">,</span><span class="s1">&quot;_node$leadingComments2&quot;</span><span class="s0">,</span><span class="s1">&quot;nodeType&quot;</span><span class="s0">,</span><span class="s1">&quot;oldConcise&quot;</span><span class="s0">,</span><span class="s1">&quot;_compact&quot;</span><span class="s0">,</span><span class="s1">&quot;printMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;ReferenceError&quot;</span><span class="s0">,</span><span class="s1">&quot;JSON&quot;</span><span class="s0">,</span><span class="s1">&quot;stringify&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;parent&quot;</span><span class="s0">,</span><span class="s1">&quot;oldInAux&quot;</span><span class="s0">,</span><span class="s1">&quot;parenthesized&quot;</span><span class="s0">,</span><span class="s1">&quot;extra&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldPrintParens&quot;</span><span class="s0">,</span><span class="s1">&quot;retainFunctionParens&quot;</span><span class="s0">,</span><span class="s1">&quot;leadingComments&quot;</span><span class="s0">,</span><span class="s1">&quot;parentType&quot;</span><span class="s0">,</span><span class="s1">&quot;callee&quot;</span><span class="s0">,</span><span class="s1">&quot;indentParenthesized&quot;</span><span class="s0">,</span><span class="s1">&quot;some&quot;</span><span class="s0">,</span><span class="s1">&quot;oldInForStatementInitWasTrue&quot;</span><span class="s0">,</span><span class="s1">&quot;isLastChild&quot;</span><span class="s0">,</span><span class="s1">&quot;_node$trailingComment&quot;</span><span class="s0">,</span><span class="s1">&quot;trailingComments&quot;</span><span class="s0">,</span><span class="s1">&quot;_printLeadingComments&quot;</span><span class="s0">,</span><span class="s1">&quot;_printTrailingComments&quot;</span><span class="s0">,</span><span class="s1">&quot;enteredPositionlessNode&quot;</span><span class="s0">,</span><span class="s1">&quot;_printAuxBeforeComment&quot;</span><span class="s0">,</span><span class="s1">&quot;_printAuxAfterComment&quot;</span><span class="s0">,</span><span class="s1">&quot;comment&quot;</span><span class="s0">,</span><span class="s1">&quot;auxiliaryCommentBefore&quot;</span><span class="s0">,</span><span class="s1">&quot;_printComment&quot;</span><span class="s0">,</span><span class="s1">&quot;auxiliaryCommentAfter&quot;</span><span class="s0">,</span><span class="s1">&quot;getPossibleRaw&quot;</span><span class="s0">,</span><span class="s1">&quot;raw&quot;</span><span class="s0">,</span><span class="s1">&quot;rawValue&quot;</span><span class="s0">,</span><span class="s1">&quot;printJoin&quot;</span><span class="s0">,</span><span class="s1">&quot;nodes&quot;</span><span class="s0">,</span><span class="s1">&quot;statement&quot;</span><span class="s0">,</span><span class="s1">&quot;separator&quot;</span><span class="s0">,</span><span class="s1">&quot;printTrailingSeparator&quot;</span><span class="s0">,</span><span class="s1">&quot;addNewlines&quot;</span><span class="s0">,</span><span class="s1">&quot;iterator&quot;</span><span class="s0">,</span><span class="s1">&quot;_nodes$0$loc&quot;</span><span class="s0">,</span><span class="s1">&quot;startLine&quot;</span><span class="s0">,</span><span class="s1">&quot;newlineOpts&quot;</span><span class="s0">,</span><span class="s1">&quot;nextNodeStartLine&quot;</span><span class="s0">,</span><span class="s1">&quot;boundSeparator&quot;</span><span class="s0">,</span><span class="s1">&quot;len&quot;</span><span class="s0">,</span><span class="s1">&quot;_printNewline&quot;</span><span class="s0">,</span><span class="s1">&quot;_node$trailingComment2&quot;</span><span class="s0">,</span><span class="s1">&quot;_nextNode$loc&quot;</span><span class="s0">,</span><span class="s1">&quot;nextNode&quot;</span><span class="s0">,</span><span class="s1">&quot;printAndIndentOnComments&quot;</span><span class="s0">,</span><span class="s1">&quot;printBlock&quot;</span><span class="s0">,</span><span class="s1">&quot;body&quot;</span><span class="s0">,</span><span class="s1">&quot;lineOffset&quot;</span><span class="s0">,</span><span class="s1">&quot;innerComments&quot;</span><span class="s0">,</span><span class="s1">&quot;_printComments&quot;</span><span class="s0">,</span><span class="s1">&quot;comments&quot;</span><span class="s0">,</span><span class="s1">&quot;nextTokenStr&quot;</span><span class="s0">,</span><span class="s1">&quot;nextTokenOccurrenceCount&quot;</span><span class="s0">,</span><span class="s1">&quot;_this$tokenMap&quot;</span><span class="s0">,</span><span class="s1">&quot;printInnerComments&quot;</span><span class="s0">,</span><span class="s1">&quot;nextToken&quot;</span><span class="s0">,</span><span class="s1">&quot;hasSpace&quot;</span><span class="s0">,</span><span class="s1">&quot;printedCommentsCount&quot;</span><span class="s0">,</span><span class="s1">&quot;size&quot;</span><span class="s0">,</span><span class="s1">&quot;noIndentInnerCommentsHere&quot;</span><span class="s0">,</span><span class="s1">&quot;printSequence&quot;</span><span class="s0">,</span><span class="s1">&quot;printList&quot;</span><span class="s0">,</span><span class="s1">&quot;items&quot;</span><span class="s0">,</span><span class="s1">&quot;commaSeparator&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldPrintTrailingComma&quot;</span><span class="s0">,</span><span class="s1">&quot;listEnd&quot;</span><span class="s0">,</span><span class="s1">&quot;listEndIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;findLastIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;matchesOriginal&quot;</span><span class="s0">,</span><span class="s1">&quot;newLine&quot;</span><span class="s0">,</span><span class="s1">&quot;opts&quot;</span><span class="s0">,</span><span class="s1">&quot;lastCommentLine&quot;</span><span class="s0">,</span><span class="s1">&quot;offset&quot;</span><span class="s0">,</span><span class="s1">&quot;_shouldPrintComment&quot;</span><span class="s0">,</span><span class="s1">&quot;ignore&quot;</span><span class="s0">,</span><span class="s1">&quot;has&quot;</span><span class="s0">,</span><span class="s1">&quot;commentTok&quot;</span><span class="s0">,</span><span class="s1">&quot;find&quot;</span><span class="s0">,</span><span class="s1">&quot;add&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldPrintComment&quot;</span><span class="s0">,</span><span class="s1">&quot;skipNewLines&quot;</span><span class="s0">,</span><span class="s1">&quot;noLineTerminator&quot;</span><span class="s0">,</span><span class="s1">&quot;isBlockComment&quot;</span><span class="s0">,</span><span class="s1">&quot;printNewLines&quot;</span><span class="s0">,</span><span class="s1">&quot;lastCharCode&quot;</span><span class="s0">,</span><span class="s1">&quot;val&quot;</span><span class="s0">,</span><span class="s1">&quot;adjustMultilineComment&quot;</span><span class="s0">,</span><span class="s1">&quot;_comment$loc&quot;</span><span class="s0">,</span><span class="s1">&quot;newlineRegex&quot;</span><span class="s0">,</span><span class="s1">&quot;RegExp&quot;</span><span class="s0">,</span><span class="s1">&quot;indentSize&quot;</span><span class="s0">,</span><span class="s1">&quot;nodeLoc&quot;</span><span class="s0">,</span><span class="s1">&quot;hasLoc&quot;</span><span class="s0">,</span><span class="s1">&quot;nodeStartLine&quot;</span><span class="s0">,</span><span class="s1">&quot;nodeEndLine&quot;</span><span class="s0">,</span><span class="s1">&quot;lastLine&quot;</span><span class="s0">,</span><span class="s1">&quot;leadingCommentNewline&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldPrint&quot;</span><span class="s0">,</span><span class="s1">&quot;commentStartLine&quot;</span><span class="s0">,</span><span class="s1">&quot;commentEndLine&quot;</span><span class="s0">,</span><span class="s1">&quot;Math&quot;</span><span class="s0">,</span><span class="s1">&quot;max&quot;</span><span class="s0">,</span><span class="s1">&quot;min&quot;</span><span class="s0">,</span><span class="s1">&quot;singleLine&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldSkipNewline&quot;</span><span class="s0">,</span><span class="s1">&quot;properties&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;assign&quot;</span><span class="s0">,</span><span class="s1">&quot;prototype&quot;</span><span class="s0">,</span><span class="s1">&quot;addDeprecatedGenerators&quot;</span><span class="s0">,</span><span class="s1">&quot;_default&quot;</span><span class="s0">,</span><span class="s1">&quot;exports&quot;</span><span class="s0">,</span><span class="s1">&quot;default&quot;</span><span class="s0">,</span><span class="s1">&quot;last&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../src/printer.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import Buffer, { type Pos } from </span><span class="s3">\&quot;</span><span class="s1">./buffer.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { Loc } from </span><span class="s3">\&quot;</span><span class="s1">./buffer.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import * as n from </span><span class="s3">\&quot;</span><span class="s1">./node/index.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type * as t from </span><span class="s3">\&quot;</span><span class="s1">@babel/types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">isExpression,</span><span class="s3">\n  </span><span class="s1">isFunction,</span><span class="s3">\n  </span><span class="s1">isStatement,</span><span class="s3">\n  </span><span class="s1">isClassBody,</span><span class="s3">\n  </span><span class="s1">isTSInterfaceBody,</span><span class="s3">\n  </span><span class="s1">isTSEnumMember,</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">@babel/types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { Opts as jsescOptions } from </span><span class="s3">\&quot;</span><span class="s1">jsesc</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">import { TokenMap } from </span><span class="s3">\&quot;</span><span class="s1">./token-map.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { GeneratorOptions } from </span><span class="s3">\&quot;</span><span class="s1">./index.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import * as generatorFunctions from </span><span class="s3">\&quot;</span><span class="s1">./generators/index.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">addDeprecatedGenerators,</span><span class="s3">\n  </span><span class="s1">type DeprecatedBabel7ASTTypes,</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">./generators/deprecated.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type SourceMap from </span><span class="s3">\&quot;</span><span class="s1">./source-map.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { TraceMap } from </span><span class="s3">\&quot;</span><span class="s1">@jridgewell/trace-mapping</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { Token } from </span><span class="s3">\&quot;</span><span class="s1">@babel/parser</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">// We inline this package</span><span class="s3">\n</span><span class="s1">// eslint-disable-next-line import/no-extraneous-dependencies</span><span class="s3">\n</span><span class="s1">import * as charCodes from </span><span class="s3">\&quot;</span><span class="s1">charcodes</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">const SCIENTIFIC_NOTATION = /e/i;</span><span class="s3">\n</span><span class="s1">const ZERO_DECIMAL_INTEGER = /</span><span class="s3">\\</span><span class="s1">.0+$/;</span><span class="s3">\n</span><span class="s1">const HAS_NEWLINE = /[</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">r</span><span class="s3">\\</span><span class="s1">u2028</span><span class="s3">\\</span><span class="s1">u2029]/;</span><span class="s3">\n</span><span class="s1">const HAS_NEWLINE_OR_BlOCK_COMMENT_END = /[</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">r</span><span class="s3">\\</span><span class="s1">u2028</span><span class="s3">\\</span><span class="s1">u2029]|</span><span class="s3">\\</span><span class="s1">*</span><span class="s3">\\</span><span class="s1">//;</span><span class="s3">\n\n</span><span class="s1">function commentIsNewline(c: t.Comment) {</span><span class="s3">\n  </span><span class="s1">return c.type === </span><span class="s3">\&quot;</span><span class="s1">CommentLine</span><span class="s3">\&quot; </span><span class="s1">|| HAS_NEWLINE.test(c.value);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const { needsParens } = n;</span><span class="s3">\n\n</span><span class="s1">const enum COMMENT_TYPE {</span><span class="s3">\n  </span><span class="s1">LEADING,</span><span class="s3">\n  </span><span class="s1">INNER,</span><span class="s3">\n  </span><span class="s1">TRAILING,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const enum COMMENT_SKIP_NEWLINE {</span><span class="s3">\n  </span><span class="s1">DEFAULT,</span><span class="s3">\n  </span><span class="s1">ALL,</span><span class="s3">\n  </span><span class="s1">LEADING,</span><span class="s3">\n  </span><span class="s1">TRAILING,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const enum PRINT_COMMENT_HINT {</span><span class="s3">\n  </span><span class="s1">SKIP,</span><span class="s3">\n  </span><span class="s1">ALLOW,</span><span class="s3">\n  </span><span class="s1">DEFER,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type Format = {</span><span class="s3">\n  </span><span class="s1">shouldPrintComment: (comment: string) =&gt; boolean;</span><span class="s3">\n  </span><span class="s1">preserveFormat: boolean;</span><span class="s3">\n  </span><span class="s1">retainLines: boolean;</span><span class="s3">\n  </span><span class="s1">retainFunctionParens: boolean;</span><span class="s3">\n  </span><span class="s1">comments: boolean;</span><span class="s3">\n  </span><span class="s1">auxiliaryCommentBefore: string;</span><span class="s3">\n  </span><span class="s1">auxiliaryCommentAfter: string;</span><span class="s3">\n  </span><span class="s1">compact: boolean | </span><span class="s3">\&quot;</span><span class="s1">auto</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">minified: boolean;</span><span class="s3">\n  </span><span class="s1">concise: boolean;</span><span class="s3">\n  </span><span class="s1">indent: {</span><span class="s3">\n    </span><span class="s1">adjustMultilineComment: boolean;</span><span class="s3">\n    </span><span class="s1">style: string;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @deprecated Removed in Babel 8, syntax type is always 'hash'</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">recordAndTupleSyntaxType?: GeneratorOptions[</span><span class="s3">\&quot;</span><span class="s1">recordAndTupleSyntaxType</span><span class="s3">\&quot;</span><span class="s1">];</span><span class="s3">\n  </span><span class="s1">jsescOption: jsescOptions;</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @deprecated Removed in Babel 8, use `jsescOption` instead</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">jsonCompatibleStrings?: boolean;</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* For use with the Hack-style pipe operator.</span><span class="s3">\n   </span><span class="s1">* Changes what token is used for pipe bodies’ topic references.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">topicToken?: GeneratorOptions[</span><span class="s3">\&quot;</span><span class="s1">topicToken</span><span class="s3">\&quot;</span><span class="s1">];</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @deprecated Removed in Babel 8</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">decoratorsBeforeExport?: boolean;</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The import attributes syntax style:</span><span class="s3">\n   </span><span class="s1">* - </span><span class="s3">\&quot;</span><span class="s1">with</span><span class="s3">\&quot;        </span><span class="s1">: `import { a } from </span><span class="s3">\&quot;</span><span class="s1">b</span><span class="s3">\&quot; </span><span class="s1">with { type: </span><span class="s3">\&quot;</span><span class="s1">json</span><span class="s3">\&quot; </span><span class="s1">};`</span><span class="s3">\n   </span><span class="s1">* - </span><span class="s3">\&quot;</span><span class="s1">assert</span><span class="s3">\&quot;      </span><span class="s1">: `import { a } from </span><span class="s3">\&quot;</span><span class="s1">b</span><span class="s3">\&quot; </span><span class="s1">assert { type: </span><span class="s3">\&quot;</span><span class="s1">json</span><span class="s3">\&quot; </span><span class="s1">};`</span><span class="s3">\n   </span><span class="s1">* - </span><span class="s3">\&quot;</span><span class="s1">with-legacy</span><span class="s3">\&quot; </span><span class="s1">: `import { a } from </span><span class="s3">\&quot;</span><span class="s1">b</span><span class="s3">\&quot; </span><span class="s1">with type: </span><span class="s3">\&quot;</span><span class="s1">json</span><span class="s3">\&quot;</span><span class="s1">;`</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">importAttributesKeyword?: </span><span class="s3">\&quot;</span><span class="s1">with</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">assert</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">with-legacy</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">interface AddNewlinesOptions {</span><span class="s3">\n  </span><span class="s1">addNewlines(leading: boolean, node: t.Node): number;</span><span class="s3">\n  </span><span class="s1">nextNodeStartLine: number;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">interface PrintSequenceOptions extends Partial&lt;AddNewlinesOptions&gt; {</span><span class="s3">\n  </span><span class="s1">statement?: boolean;</span><span class="s3">\n  </span><span class="s1">indent?: boolean;</span><span class="s3">\n  </span><span class="s1">trailingCommentsLineOffset?: number;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">interface PrintListOptions {</span><span class="s3">\n  </span><span class="s1">separator?: (this: Printer, occurrenceCount: number, last: boolean) =&gt; void;</span><span class="s3">\n  </span><span class="s1">iterator?: (node: t.Node, index: number) =&gt; void;</span><span class="s3">\n  </span><span class="s1">statement?: boolean;</span><span class="s3">\n  </span><span class="s1">indent?: boolean;</span><span class="s3">\n  </span><span class="s1">printTrailingSeparator?: boolean;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type PrintJoinOptions = PrintListOptions &amp; PrintSequenceOptions;</span><span class="s3">\n</span><span class="s1">class Printer {</span><span class="s3">\n  </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">format: Format,</span><span class="s3">\n    </span><span class="s1">map: SourceMap,</span><span class="s3">\n    </span><span class="s1">tokens?: Token[],</span><span class="s3">\n    </span><span class="s1">originalCode?: string,</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">this.format = format;</span><span class="s3">\n\n    </span><span class="s1">this._tokens = tokens;</span><span class="s3">\n    </span><span class="s1">this._originalCode = originalCode;</span><span class="s3">\n\n    </span><span class="s1">this._indentRepeat = format.indent.style.length;</span><span class="s3">\n\n    </span><span class="s1">this._inputMap = map?._inputMap;</span><span class="s3">\n\n    </span><span class="s1">this._buf = new Buffer(map, format.indent.style[0]);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">declare _inputMap: TraceMap;</span><span class="s3">\n\n  </span><span class="s1">declare format: Format;</span><span class="s3">\n\n  </span><span class="s1">inForStatementInit: boolean = false;</span><span class="s3">\n  </span><span class="s1">enterForStatementInit() {</span><span class="s3">\n    </span><span class="s1">if (this.inForStatementInit) return () =&gt; {};</span><span class="s3">\n    </span><span class="s1">this.inForStatementInit = true;</span><span class="s3">\n    </span><span class="s1">return () =&gt; {</span><span class="s3">\n      </span><span class="s1">this.inForStatementInit = false;</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">enterDelimited() {</span><span class="s3">\n    </span><span class="s1">const oldInForStatementInit = this.inForStatementInit;</span><span class="s3">\n    </span><span class="s1">const oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">oldInForStatementInit === false &amp;&amp;</span><span class="s3">\n      </span><span class="s1">oldNoLineTerminatorAfterNode === null</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return () =&gt; {};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.inForStatementInit = false;</span><span class="s3">\n    </span><span class="s1">this._noLineTerminatorAfterNode = null;</span><span class="s3">\n    </span><span class="s1">return () =&gt; {</span><span class="s3">\n      </span><span class="s1">this.inForStatementInit = oldInForStatementInit;</span><span class="s3">\n      </span><span class="s1">this._noLineTerminatorAfterNode = oldNoLineTerminatorAfterNode;</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">tokenContext: number = 0;</span><span class="s3">\n\n  </span><span class="s1">_tokens: Token[] = null;</span><span class="s3">\n  </span><span class="s1">_originalCode: string | null = null;</span><span class="s3">\n\n  </span><span class="s1">declare _buf: Buffer;</span><span class="s3">\n  </span><span class="s1">_currentNode: t.Node = null;</span><span class="s3">\n  </span><span class="s1">_indent: number = 0;</span><span class="s3">\n  </span><span class="s1">_indentRepeat: number = 0;</span><span class="s3">\n  </span><span class="s1">_insideAux: boolean = false;</span><span class="s3">\n  </span><span class="s1">_noLineTerminator: boolean = false;</span><span class="s3">\n  </span><span class="s1">_noLineTerminatorAfterNode: t.Node | null = null;</span><span class="s3">\n  </span><span class="s1">_printAuxAfterOnNextUserNode: boolean = false;</span><span class="s3">\n  </span><span class="s1">_printedComments = new Set&lt;t.Comment&gt;();</span><span class="s3">\n  </span><span class="s1">_endsWithInteger = false;</span><span class="s3">\n  </span><span class="s1">_endsWithWord = false;</span><span class="s3">\n  </span><span class="s1">_endsWithDiv = false;</span><span class="s3">\n  </span><span class="s1">_lastCommentLine = 0;</span><span class="s3">\n  </span><span class="s1">_endsWithInnerRaw: boolean = false;</span><span class="s3">\n  </span><span class="s1">_indentInnerComments: boolean = true;</span><span class="s3">\n  </span><span class="s1">tokenMap: TokenMap = null;</span><span class="s3">\n\n  </span><span class="s1">_boundGetRawIdentifier = this._getRawIdentifier.bind(this);</span><span class="s3">\n\n  </span><span class="s1">generate(ast: t.Node) {</span><span class="s3">\n    </span><span class="s1">if (this.format.preserveFormat) {</span><span class="s3">\n      </span><span class="s1">this.tokenMap = new TokenMap(ast, this._tokens, this._originalCode);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.print(ast);</span><span class="s3">\n    </span><span class="s1">this._maybeAddAuxComment();</span><span class="s3">\n\n    </span><span class="s1">return this._buf.get();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Increment indent size.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n\n  </span><span class="s1">indent(): void {</span><span class="s3">\n    </span><span class="s1">const { format } = this;</span><span class="s3">\n    </span><span class="s1">if (format.preserveFormat || format.compact || format.concise) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this._indent++;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Decrement indent size.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n\n  </span><span class="s1">dedent(): void {</span><span class="s3">\n    </span><span class="s1">const { format } = this;</span><span class="s3">\n    </span><span class="s1">if (format.preserveFormat || format.compact || format.concise) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this._indent--;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* If the next token is on the same line, we must first print a semicolon.</span><span class="s3">\n   </span><span class="s1">* This option is only used in `preserveFormat` node, for semicolons that</span><span class="s3">\n   </span><span class="s1">* might have omitted due to them being absent in the original code (thanks</span><span class="s3">\n   </span><span class="s1">* to ASI).</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* We need both *NextToken and *NextNode because we only want to insert the</span><span class="s3">\n   </span><span class="s1">* semicolon when the next token starts a new node, and not in cases like</span><span class="s3">\n   </span><span class="s1">* foo} (where } is not starting a new node). So we first set *NextNode, and</span><span class="s3">\n   </span><span class="s1">* then the print() method will move it to *NextToken.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">_printSemicolonBeforeNextNode: number = -1;</span><span class="s3">\n  </span><span class="s1">_printSemicolonBeforeNextToken: number = -1;</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Add a semicolon to the buffer.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">semicolon(force: boolean = false): void {</span><span class="s3">\n    </span><span class="s1">this._maybeAddAuxComment();</span><span class="s3">\n    </span><span class="s1">if (force) {</span><span class="s3">\n      </span><span class="s1">this._appendChar(charCodes.semicolon);</span><span class="s3">\n      </span><span class="s1">this._noLineTerminator = false;</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (this.tokenMap) {</span><span class="s3">\n      </span><span class="s1">const node = this._currentNode;</span><span class="s3">\n      </span><span class="s1">if (node.start != null &amp;&amp; node.end != null) {</span><span class="s3">\n        </span><span class="s1">if (!this.tokenMap.endMatches(node, </span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n          </span><span class="s1">// no semicolon</span><span class="s3">\n          </span><span class="s1">this._printSemicolonBeforeNextNode = this._buf.getCurrentLine();</span><span class="s3">\n          </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const indexes = this.tokenMap.getIndexes(this._currentNode);</span><span class="s3">\n        </span><span class="s1">this._catchUpTo(this._tokens[indexes[indexes.length - 1]].loc.start);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this._queue(charCodes.semicolon);</span><span class="s3">\n    </span><span class="s1">this._noLineTerminator = false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Add a right brace to the buffer.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n\n  </span><span class="s1">rightBrace(node: t.Node): void {</span><span class="s3">\n    </span><span class="s1">if (this.format.minified) {</span><span class="s3">\n      </span><span class="s1">this._buf.removeLastSemicolon();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.sourceWithOffset(</span><span class="s3">\&quot;</span><span class="s1">end</span><span class="s3">\&quot;</span><span class="s1">, node.loc, -1);</span><span class="s3">\n    </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">rightParens(node: t.Node): void {</span><span class="s3">\n    </span><span class="s1">this.sourceWithOffset(</span><span class="s3">\&quot;</span><span class="s1">end</span><span class="s3">\&quot;</span><span class="s1">, node.loc, -1);</span><span class="s3">\n    </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Add a space to the buffer unless it is compact.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n\n  </span><span class="s1">space(force: boolean = false): void {</span><span class="s3">\n    </span><span class="s1">const { format } = this;</span><span class="s3">\n    </span><span class="s1">if (format.compact || format.preserveFormat) return;</span><span class="s3">\n\n    </span><span class="s1">if (force) {</span><span class="s3">\n      </span><span class="s1">this._space();</span><span class="s3">\n    </span><span class="s1">} else if (this._buf.hasContent()) {</span><span class="s3">\n      </span><span class="s1">const lastCp = this.getLastChar();</span><span class="s3">\n      </span><span class="s1">if (lastCp !== charCodes.space &amp;&amp; lastCp !== charCodes.lineFeed) {</span><span class="s3">\n        </span><span class="s1">this._space();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Writes a token that can't be safely parsed without taking whitespace into account.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n\n  </span><span class="s1">word(str: string, noLineTerminatorAfter: boolean = false): void {</span><span class="s3">\n    </span><span class="s1">this.tokenContext = 0;</span><span class="s3">\n\n    </span><span class="s1">this._maybePrintInnerComments(str);</span><span class="s3">\n\n    </span><span class="s1">this._maybeAddAuxComment();</span><span class="s3">\n\n    </span><span class="s1">if (this.tokenMap) this._catchUpToCurrentToken(str);</span><span class="s3">\n\n    </span><span class="s1">// prevent concatenating words and creating // comment out of division and regex</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">this._endsWithWord ||</span><span class="s3">\n      </span><span class="s1">(this._endsWithDiv &amp;&amp; str.charCodeAt(0) === charCodes.slash)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">this._space();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this._append(str, false);</span><span class="s3">\n\n    </span><span class="s1">this._endsWithWord = true;</span><span class="s3">\n    </span><span class="s1">this._noLineTerminator = noLineTerminatorAfter;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Writes a number token so that we can validate if it is an integer.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n\n  </span><span class="s1">number(str: string, number?: number): void {</span><span class="s3">\n    </span><span class="s1">// const NON_DECIMAL_LITERAL = /^0[box]/;</span><span class="s3">\n    </span><span class="s1">function isNonDecimalLiteral(str: string) {</span><span class="s3">\n      </span><span class="s1">if (str.length &gt; 2 &amp;&amp; str.charCodeAt(0) === charCodes.digit0) {</span><span class="s3">\n        </span><span class="s1">const secondChar = str.charCodeAt(1);</span><span class="s3">\n        </span><span class="s1">return (</span><span class="s3">\n          </span><span class="s1">secondChar === charCodes.lowercaseB ||</span><span class="s3">\n          </span><span class="s1">secondChar === charCodes.lowercaseO ||</span><span class="s3">\n          </span><span class="s1">secondChar === charCodes.lowercaseX</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.word(str);</span><span class="s3">\n\n    </span><span class="s1">// Integer tokens need special handling because they cannot have '.'s inserted</span><span class="s3">\n    </span><span class="s1">// immediately after them.</span><span class="s3">\n    </span><span class="s1">this._endsWithInteger =</span><span class="s3">\n      </span><span class="s1">Number.isInteger(number) &amp;&amp;</span><span class="s3">\n      </span><span class="s1">!isNonDecimalLiteral(str) &amp;&amp;</span><span class="s3">\n      </span><span class="s1">!SCIENTIFIC_NOTATION.test(str) &amp;&amp;</span><span class="s3">\n      </span><span class="s1">!ZERO_DECIMAL_INTEGER.test(str) &amp;&amp;</span><span class="s3">\n      </span><span class="s1">str.charCodeAt(str.length - 1) !== charCodes.dot;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Writes a simple token.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {string} str The string to append.</span><span class="s3">\n   </span><span class="s1">* @param {boolean} [maybeNewline=false] Wether `str` might potentially</span><span class="s3">\n   </span><span class="s1">*    contain a line terminator or not.</span><span class="s3">\n   </span><span class="s1">* @param {number} [occurrenceCount=0] The occurrence count of this token in</span><span class="s3">\n   </span><span class="s1">*    the current node. This is used when printing in `preserveFormat` mode,</span><span class="s3">\n   </span><span class="s1">*    to know which token we should map to (for example, to disambiguate the</span><span class="s3">\n   </span><span class="s1">*    commas in an array literal).</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">token(str: string, maybeNewline = false, occurrenceCount = 0): void {</span><span class="s3">\n    </span><span class="s1">this.tokenContext = 0;</span><span class="s3">\n\n    </span><span class="s1">this._maybePrintInnerComments(str, occurrenceCount);</span><span class="s3">\n\n    </span><span class="s1">this._maybeAddAuxComment();</span><span class="s3">\n\n    </span><span class="s1">if (this.tokenMap) this._catchUpToCurrentToken(str, occurrenceCount);</span><span class="s3">\n\n    </span><span class="s1">const lastChar = this.getLastChar();</span><span class="s3">\n    </span><span class="s1">const strFirst = str.charCodeAt(0);</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">(lastChar === charCodes.exclamationMark &amp;&amp;</span><span class="s3">\n        </span><span class="s1">// space is mandatory to avoid outputting &lt;!--</span><span class="s3">\n        </span><span class="s1">// http://javascript.spec.whatwg.org/#comment-syntax</span><span class="s3">\n        </span><span class="s1">(str === </span><span class="s3">\&quot;</span><span class="s1">--</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n          </span><span class="s1">// Needs spaces to avoid changing a! == 0 to a!== 0</span><span class="s3">\n          </span><span class="s1">strFirst === charCodes.equalsTo)) ||</span><span class="s3">\n      </span><span class="s1">// Need spaces for operators of the same kind to avoid: `a+++b`</span><span class="s3">\n      </span><span class="s1">(strFirst === charCodes.plusSign &amp;&amp; lastChar === charCodes.plusSign) ||</span><span class="s3">\n      </span><span class="s1">(strFirst === charCodes.dash &amp;&amp; lastChar === charCodes.dash) ||</span><span class="s3">\n      </span><span class="s1">// Needs spaces to avoid changing '34' to '34.', which would still be a valid number.</span><span class="s3">\n      </span><span class="s1">(strFirst === charCodes.dot &amp;&amp; this._endsWithInteger)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">this._space();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this._append(str, maybeNewline);</span><span class="s3">\n    </span><span class="s1">this._noLineTerminator = false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">tokenChar(char: number): void {</span><span class="s3">\n    </span><span class="s1">this.tokenContext = 0;</span><span class="s3">\n\n    </span><span class="s1">const str = String.fromCharCode(char);</span><span class="s3">\n    </span><span class="s1">this._maybePrintInnerComments(str);</span><span class="s3">\n\n    </span><span class="s1">this._maybeAddAuxComment();</span><span class="s3">\n\n    </span><span class="s1">if (this.tokenMap) this._catchUpToCurrentToken(str);</span><span class="s3">\n\n    </span><span class="s1">const lastChar = this.getLastChar();</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">// Need spaces for operators of the same kind to avoid: `a+++b`</span><span class="s3">\n      </span><span class="s1">(char === charCodes.plusSign &amp;&amp; lastChar === charCodes.plusSign) ||</span><span class="s3">\n      </span><span class="s1">(char === charCodes.dash &amp;&amp; lastChar === charCodes.dash) ||</span><span class="s3">\n      </span><span class="s1">// Needs spaces to avoid changing '34' to '34.', which would still be a valid number.</span><span class="s3">\n      </span><span class="s1">(char === charCodes.dot &amp;&amp; this._endsWithInteger)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">this._space();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this._appendChar(char);</span><span class="s3">\n    </span><span class="s1">this._noLineTerminator = false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Add a newline (or many newlines), maintaining formatting.</span><span class="s3">\n   </span><span class="s1">* This function checks the number of newlines in the queue and subtracts them.</span><span class="s3">\n   </span><span class="s1">* It currently has some limitations.</span><span class="s3">\n   </span><span class="s1">* @see {Buffer#getNewlineCount}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">newline(i: number = 1, force?: boolean): void {</span><span class="s3">\n    </span><span class="s1">if (i &lt;= 0) return;</span><span class="s3">\n\n    </span><span class="s1">if (!force) {</span><span class="s3">\n      </span><span class="s1">if (this.format.retainLines || this.format.compact) return;</span><span class="s3">\n\n      </span><span class="s1">if (this.format.concise) {</span><span class="s3">\n        </span><span class="s1">this.space();</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (i &gt; 2) i = 2; // Max two lines</span><span class="s3">\n\n    </span><span class="s1">i -= this._buf.getNewlineCount();</span><span class="s3">\n\n    </span><span class="s1">for (let j = 0; j &lt; i; j++) {</span><span class="s3">\n      </span><span class="s1">this._newline();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">endsWith(char: number): boolean {</span><span class="s3">\n    </span><span class="s1">return this.getLastChar() === char;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">getLastChar(): number {</span><span class="s3">\n    </span><span class="s1">return this._buf.getLastChar();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">endsWithCharAndNewline(): number {</span><span class="s3">\n    </span><span class="s1">return this._buf.endsWithCharAndNewline();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">removeTrailingNewline(): void {</span><span class="s3">\n    </span><span class="s1">this._buf.removeTrailingNewline();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">exactSource(loc: Loc | undefined, cb: () =&gt; void) {</span><span class="s3">\n    </span><span class="s1">if (!loc) {</span><span class="s3">\n      </span><span class="s1">cb();</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this._catchUp(</span><span class="s3">\&quot;</span><span class="s1">start</span><span class="s3">\&quot;</span><span class="s1">, loc);</span><span class="s3">\n\n    </span><span class="s1">this._buf.exactSource(loc, cb);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">source(prop: </span><span class="s3">\&quot;</span><span class="s1">start</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">end</span><span class="s3">\&quot;</span><span class="s1">, loc: Loc | undefined): void {</span><span class="s3">\n    </span><span class="s1">if (!loc) return;</span><span class="s3">\n\n    </span><span class="s1">this._catchUp(prop, loc);</span><span class="s3">\n\n    </span><span class="s1">this._buf.source(prop, loc);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">sourceWithOffset(</span><span class="s3">\n    </span><span class="s1">prop: </span><span class="s3">\&quot;</span><span class="s1">start</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">end</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">loc: Loc | undefined,</span><span class="s3">\n    </span><span class="s1">columnOffset: number,</span><span class="s3">\n  </span><span class="s1">): void {</span><span class="s3">\n    </span><span class="s1">if (!loc || this.format.preserveFormat) return;</span><span class="s3">\n\n    </span><span class="s1">this._catchUp(prop, loc);</span><span class="s3">\n\n    </span><span class="s1">this._buf.sourceWithOffset(prop, loc, columnOffset);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">sourceIdentifierName(identifierName: string, pos?: Pos): void {</span><span class="s3">\n    </span><span class="s1">if (!this._buf._canMarkIdName) return;</span><span class="s3">\n\n    </span><span class="s1">const sourcePosition = this._buf._sourcePosition;</span><span class="s3">\n    </span><span class="s1">sourcePosition.identifierNamePos = pos;</span><span class="s3">\n    </span><span class="s1">sourcePosition.identifierName = identifierName;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_space(): void {</span><span class="s3">\n    </span><span class="s1">this._queue(charCodes.space);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_newline(): void {</span><span class="s3">\n    </span><span class="s1">this._queue(charCodes.lineFeed);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_catchUpToCurrentToken(str: string, occurrenceCount: number = 0): void {</span><span class="s3">\n    </span><span class="s1">// Assert: this.tokenMap</span><span class="s3">\n\n    </span><span class="s1">const token = this.tokenMap.findMatching(</span><span class="s3">\n      </span><span class="s1">this._currentNode,</span><span class="s3">\n      </span><span class="s1">str,</span><span class="s3">\n      </span><span class="s1">occurrenceCount,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">if (token) this._catchUpTo(token.loc.start);</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">this._printSemicolonBeforeNextToken !== -1 &amp;&amp;</span><span class="s3">\n      </span><span class="s1">this._printSemicolonBeforeNextToken === this._buf.getCurrentLine()</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">this._buf.appendChar(charCodes.semicolon);</span><span class="s3">\n      </span><span class="s1">this._endsWithWord = false;</span><span class="s3">\n      </span><span class="s1">this._endsWithInteger = false;</span><span class="s3">\n      </span><span class="s1">this._endsWithDiv = false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this._printSemicolonBeforeNextToken = -1;</span><span class="s3">\n    </span><span class="s1">this._printSemicolonBeforeNextNode = -1;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_append(str: string, maybeNewline: boolean): void {</span><span class="s3">\n    </span><span class="s1">this._maybeIndent(str.charCodeAt(0));</span><span class="s3">\n\n    </span><span class="s1">this._buf.append(str, maybeNewline);</span><span class="s3">\n\n    </span><span class="s1">// callers are expected to then set these to `true` when needed</span><span class="s3">\n    </span><span class="s1">this._endsWithWord = false;</span><span class="s3">\n    </span><span class="s1">this._endsWithInteger = false;</span><span class="s3">\n    </span><span class="s1">this._endsWithDiv = false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_appendChar(char: number): void {</span><span class="s3">\n    </span><span class="s1">this._maybeIndent(char);</span><span class="s3">\n\n    </span><span class="s1">this._buf.appendChar(char);</span><span class="s3">\n\n    </span><span class="s1">// callers are expected to then set these to `true` when needed</span><span class="s3">\n    </span><span class="s1">this._endsWithWord = false;</span><span class="s3">\n    </span><span class="s1">this._endsWithInteger = false;</span><span class="s3">\n    </span><span class="s1">this._endsWithDiv = false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_queue(char: number) {</span><span class="s3">\n    </span><span class="s1">this._maybeIndent(char);</span><span class="s3">\n\n    </span><span class="s1">this._buf.queue(char);</span><span class="s3">\n\n    </span><span class="s1">this._endsWithWord = false;</span><span class="s3">\n    </span><span class="s1">this._endsWithInteger = false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_maybeIndent(firstChar: number): void {</span><span class="s3">\n    </span><span class="s1">// we've got a newline before us so prepend on the indentation</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">this._indent &amp;&amp;</span><span class="s3">\n      </span><span class="s1">firstChar !== charCodes.lineFeed &amp;&amp;</span><span class="s3">\n      </span><span class="s1">this.endsWith(charCodes.lineFeed)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">this._buf.queueIndentation(this._getIndent());</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_shouldIndent(firstChar: number) {</span><span class="s3">\n    </span><span class="s1">// we've got a newline before us so prepend on the indentation</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">this._indent &amp;&amp;</span><span class="s3">\n      </span><span class="s1">firstChar !== charCodes.lineFeed &amp;&amp;</span><span class="s3">\n      </span><span class="s1">this.endsWith(charCodes.lineFeed)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">catchUp(line: number) {</span><span class="s3">\n    </span><span class="s1">if (!this.format.retainLines) return;</span><span class="s3">\n\n    </span><span class="s1">// catch up to this nodes newline if we're behind</span><span class="s3">\n    </span><span class="s1">const count = line - this._buf.getCurrentLine();</span><span class="s3">\n\n    </span><span class="s1">for (let i = 0; i &lt; count; i++) {</span><span class="s3">\n      </span><span class="s1">this._newline();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_catchUp(prop: </span><span class="s3">\&quot;</span><span class="s1">start</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">end</span><span class="s3">\&quot;</span><span class="s1">, loc?: Loc) {</span><span class="s3">\n    </span><span class="s1">const { format } = this;</span><span class="s3">\n    </span><span class="s1">if (!format.preserveFormat) {</span><span class="s3">\n      </span><span class="s1">if (format.retainLines &amp;&amp; loc?.[prop]) {</span><span class="s3">\n        </span><span class="s1">this.catchUp(loc[prop].line);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// catch up to this nodes newline if we're behind</span><span class="s3">\n    </span><span class="s1">const pos = loc?.[prop];</span><span class="s3">\n    </span><span class="s1">if (pos != null) this._catchUpTo(pos);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_catchUpTo({ line, column, index }: Pos) {</span><span class="s3">\n    </span><span class="s1">const count = line - this._buf.getCurrentLine();</span><span class="s3">\n    </span><span class="s1">if (count &gt; 0 &amp;&amp; this._noLineTerminator) {</span><span class="s3">\n      </span><span class="s1">// We cannot inject new lines when _noLineTemrinator is set</span><span class="s3">\n      </span><span class="s1">// to `true`, or we would generate invalid code.</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">for (let i = 0; i &lt; count; i++) {</span><span class="s3">\n      </span><span class="s1">this._newline();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const spacesCount =</span><span class="s3">\n      </span><span class="s1">count &gt; 0 ? column : column - this._buf.getCurrentColumn();</span><span class="s3">\n    </span><span class="s1">if (spacesCount &gt; 0) {</span><span class="s3">\n      </span><span class="s1">const spaces = this._originalCode</span><span class="s3">\n        </span><span class="s1">? this._originalCode</span><span class="s3">\n            </span><span class="s1">.slice(index - spacesCount, index)</span><span class="s3">\n            </span><span class="s1">// https://tc39.es/ecma262/#sec-white-space</span><span class="s3">\n            </span><span class="s1">.replace(/[^</span><span class="s3">\\</span><span class="s1">t</span><span class="s3">\\</span><span class="s1">v</span><span class="s3">\\</span><span class="s1">f</span><span class="s3">\\</span><span class="s1">uFEFF</span><span class="s3">\\</span><span class="s1">p{Space_Separator}]/gu, </span><span class="s3">\&quot; \&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">: </span><span class="s3">\&quot; \&quot;</span><span class="s1">.repeat(spacesCount);</span><span class="s3">\n      </span><span class="s1">this._append(spaces, false);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Get the current indent.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n\n  </span><span class="s1">_getIndent(): number {</span><span class="s3">\n    </span><span class="s1">return this._indentRepeat * this._indent;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">printTerminatorless(node: t.Node) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Set some state that will be modified if a newline has been inserted before any</span><span class="s3">\n     </span><span class="s1">* non-space characters.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* This is to prevent breaking semantics for terminatorless separator nodes. eg:</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">*   return foo;</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* returns `foo`. But if we do:</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">*   return</span><span class="s3">\n     </span><span class="s1">*   foo;</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">*  `undefined` will be returned and not `foo` due to the terminator.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this._noLineTerminator = true;</span><span class="s3">\n    </span><span class="s1">this.print(node);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">print(</span><span class="s3">\n    </span><span class="s1">node: t.Node | null,</span><span class="s3">\n    </span><span class="s1">noLineTerminatorAfter?: boolean,</span><span class="s3">\n    </span><span class="s1">// trailingCommentsLineOffset also used to check if called from printJoin</span><span class="s3">\n    </span><span class="s1">// it will be ignored if `noLineTerminatorAfter||this._noLineTerminator`</span><span class="s3">\n    </span><span class="s1">trailingCommentsLineOffset?: number,</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">if (!node) return;</span><span class="s3">\n\n    </span><span class="s1">this._endsWithInnerRaw = false;</span><span class="s3">\n\n    </span><span class="s1">const nodeType = node.type;</span><span class="s3">\n    </span><span class="s1">const format = this.format;</span><span class="s3">\n\n    </span><span class="s1">const oldConcise = format.concise;</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">// @ts-expect-error document _compact AST properties</span><span class="s3">\n      </span><span class="s1">node._compact</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">format.concise = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const printMethod =</span><span class="s3">\n      </span><span class="s1">this[</span><span class="s3">\n        </span><span class="s1">nodeType as Exclude&lt;</span><span class="s3">\n          </span><span class="s1">t.Node[</span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n          </span><span class="s1">| DeprecatedBabel7ASTTypes</span><span class="s3">\n          </span><span class="s1">// renamed</span><span class="s3">\n          </span><span class="s1">| t.DeprecatedAliases[</span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\n        </span><span class="s1">&gt;</span><span class="s3">\n      </span><span class="s1">];</span><span class="s3">\n    </span><span class="s1">if (printMethod === undefined) {</span><span class="s3">\n      </span><span class="s1">throw new ReferenceError(</span><span class="s3">\n        </span><span class="s1">`unknown node of type ${JSON.stringify(</span><span class="s3">\n          </span><span class="s1">nodeType,</span><span class="s3">\n        </span><span class="s1">)} with constructor ${JSON.stringify(node.constructor.name)}`,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const parent = this._currentNode;</span><span class="s3">\n    </span><span class="s1">this._currentNode = node;</span><span class="s3">\n\n    </span><span class="s1">if (this.tokenMap) {</span><span class="s3">\n      </span><span class="s1">this._printSemicolonBeforeNextToken = this._printSemicolonBeforeNextNode;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const oldInAux = this._insideAux;</span><span class="s3">\n    </span><span class="s1">this._insideAux = node.loc == null;</span><span class="s3">\n    </span><span class="s1">this._maybeAddAuxComment(this._insideAux &amp;&amp; !oldInAux);</span><span class="s3">\n\n    </span><span class="s1">const parenthesized = node.extra?.parenthesized as boolean | undefined;</span><span class="s3">\n    </span><span class="s1">let shouldPrintParens =</span><span class="s3">\n      </span><span class="s1">(parenthesized &amp;&amp; format.preserveFormat) ||</span><span class="s3">\n      </span><span class="s1">(parenthesized &amp;&amp;</span><span class="s3">\n        </span><span class="s1">format.retainFunctionParens &amp;&amp;</span><span class="s3">\n        </span><span class="s1">nodeType === </span><span class="s3">\&quot;</span><span class="s1">FunctionExpression</span><span class="s3">\&quot;</span><span class="s1">) ||</span><span class="s3">\n      </span><span class="s1">needsParens(</span><span class="s3">\n        </span><span class="s1">node,</span><span class="s3">\n        </span><span class="s1">parent,</span><span class="s3">\n        </span><span class="s1">this.tokenContext,</span><span class="s3">\n        </span><span class="s1">this.inForStatementInit,</span><span class="s3">\n        </span><span class="s1">format.preserveFormat ? this._boundGetRawIdentifier : undefined,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">!shouldPrintParens &amp;&amp;</span><span class="s3">\n      </span><span class="s1">parenthesized &amp;&amp;</span><span class="s3">\n      </span><span class="s1">node.leadingComments?.length &amp;&amp;</span><span class="s3">\n      </span><span class="s1">node.leadingComments[0].type === </span><span class="s3">\&quot;</span><span class="s1">CommentBlock</span><span class="s3">\&quot;\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">const parentType = parent?.type;</span><span class="s3">\n      </span><span class="s1">switch (parentType) {</span><span class="s3">\n        </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ExpressionStatement</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">VariableDeclarator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">AssignmentExpression</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ReturnStatement</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">CallExpression</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">OptionalCallExpression</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">NewExpression</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n          </span><span class="s1">if (parent.callee !== node) break;</span><span class="s3">\n        </span><span class="s1">// falls through</span><span class="s3">\n        </span><span class="s1">default:</span><span class="s3">\n          </span><span class="s1">shouldPrintParens = true;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">let indentParenthesized = false;</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">!shouldPrintParens &amp;&amp;</span><span class="s3">\n      </span><span class="s1">this._noLineTerminator &amp;&amp;</span><span class="s3">\n      </span><span class="s1">(node.leadingComments?.some(commentIsNewline) ||</span><span class="s3">\n        </span><span class="s1">(this.format.retainLines &amp;&amp;</span><span class="s3">\n          </span><span class="s1">node.loc &amp;&amp;</span><span class="s3">\n          </span><span class="s1">node.loc.start.line &gt; this._buf.getCurrentLine()))</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">shouldPrintParens = true;</span><span class="s3">\n      </span><span class="s1">indentParenthesized = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">let oldNoLineTerminatorAfterNode;</span><span class="s3">\n    </span><span class="s1">let oldInForStatementInitWasTrue;</span><span class="s3">\n    </span><span class="s1">if (!shouldPrintParens) {</span><span class="s3">\n      </span><span class="s1">noLineTerminatorAfter ||=</span><span class="s3">\n        </span><span class="s1">parent &amp;&amp;</span><span class="s3">\n        </span><span class="s1">this._noLineTerminatorAfterNode === parent &amp;&amp;</span><span class="s3">\n        </span><span class="s1">n.isLastChild(parent, node);</span><span class="s3">\n      </span><span class="s1">if (noLineTerminatorAfter) {</span><span class="s3">\n        </span><span class="s1">if (node.trailingComments?.some(commentIsNewline)) {</span><span class="s3">\n          </span><span class="s1">if (isExpression(node)) shouldPrintParens = true;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;</span><span class="s3">\n          </span><span class="s1">this._noLineTerminatorAfterNode = node;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (shouldPrintParens) {</span><span class="s3">\n      </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">if (indentParenthesized) this.indent();</span><span class="s3">\n      </span><span class="s1">this._endsWithInnerRaw = false;</span><span class="s3">\n      </span><span class="s1">if (this.inForStatementInit) {</span><span class="s3">\n        </span><span class="s1">oldInForStatementInitWasTrue = true;</span><span class="s3">\n        </span><span class="s1">this.inForStatementInit = false;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;</span><span class="s3">\n      </span><span class="s1">this._noLineTerminatorAfterNode = null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this._lastCommentLine = 0;</span><span class="s3">\n\n    </span><span class="s1">this._printLeadingComments(node, parent);</span><span class="s3">\n\n    </span><span class="s1">const loc = nodeType === </span><span class="s3">\&quot;</span><span class="s1">Program</span><span class="s3">\&quot; </span><span class="s1">|| nodeType === </span><span class="s3">\&quot;</span><span class="s1">File</span><span class="s3">\&quot; </span><span class="s1">? null : node.loc;</span><span class="s3">\n\n    </span><span class="s1">this.exactSource(</span><span class="s3">\n      </span><span class="s1">loc,</span><span class="s3">\n      </span><span class="s1">// @ts-expect-error Expected 1 arguments, but got 3.</span><span class="s3">\n      </span><span class="s1">printMethod.bind(this, node, parent),</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n\n    </span><span class="s1">if (shouldPrintParens) {</span><span class="s3">\n      </span><span class="s1">this._printTrailingComments(node, parent);</span><span class="s3">\n      </span><span class="s1">if (indentParenthesized) {</span><span class="s3">\n        </span><span class="s1">this.dedent();</span><span class="s3">\n        </span><span class="s1">this.newline();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">this._noLineTerminator = noLineTerminatorAfter;</span><span class="s3">\n      </span><span class="s1">if (oldInForStatementInitWasTrue) this.inForStatementInit = true;</span><span class="s3">\n    </span><span class="s1">} else if (noLineTerminatorAfter &amp;&amp; !this._noLineTerminator) {</span><span class="s3">\n      </span><span class="s1">this._noLineTerminator = true;</span><span class="s3">\n      </span><span class="s1">this._printTrailingComments(node, parent);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">this._printTrailingComments(node, parent, trailingCommentsLineOffset);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// end</span><span class="s3">\n    </span><span class="s1">this._currentNode = parent;</span><span class="s3">\n    </span><span class="s1">format.concise = oldConcise;</span><span class="s3">\n    </span><span class="s1">this._insideAux = oldInAux;</span><span class="s3">\n\n    </span><span class="s1">if (oldNoLineTerminatorAfterNode !== undefined) {</span><span class="s3">\n      </span><span class="s1">this._noLineTerminatorAfterNode = oldNoLineTerminatorAfterNode;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this._endsWithInnerRaw = false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_maybeAddAuxComment(enteredPositionlessNode?: boolean) {</span><span class="s3">\n    </span><span class="s1">if (enteredPositionlessNode) this._printAuxBeforeComment();</span><span class="s3">\n    </span><span class="s1">if (!this._insideAux) this._printAuxAfterComment();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_printAuxBeforeComment() {</span><span class="s3">\n    </span><span class="s1">if (this._printAuxAfterOnNextUserNode) return;</span><span class="s3">\n    </span><span class="s1">this._printAuxAfterOnNextUserNode = true;</span><span class="s3">\n\n    </span><span class="s1">const comment = this.format.auxiliaryCommentBefore;</span><span class="s3">\n    </span><span class="s1">if (comment) {</span><span class="s3">\n      </span><span class="s1">this._printComment(</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n          </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">CommentBlock</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n          </span><span class="s1">value: comment,</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">COMMENT_SKIP_NEWLINE.DEFAULT,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_printAuxAfterComment() {</span><span class="s3">\n    </span><span class="s1">if (!this._printAuxAfterOnNextUserNode) return;</span><span class="s3">\n    </span><span class="s1">this._printAuxAfterOnNextUserNode = false;</span><span class="s3">\n\n    </span><span class="s1">const comment = this.format.auxiliaryCommentAfter;</span><span class="s3">\n    </span><span class="s1">if (comment) {</span><span class="s3">\n      </span><span class="s1">this._printComment(</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n          </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">CommentBlock</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n          </span><span class="s1">value: comment,</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">COMMENT_SKIP_NEWLINE.DEFAULT,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">getPossibleRaw(</span><span class="s3">\n    </span><span class="s1">node:</span><span class="s3">\n      </span><span class="s1">| t.StringLiteral</span><span class="s3">\n      </span><span class="s1">| t.NumericLiteral</span><span class="s3">\n      </span><span class="s1">| t.BigIntLiteral</span><span class="s3">\n      </span><span class="s1">| t.DirectiveLiteral</span><span class="s3">\n      </span><span class="s1">| t.JSXText,</span><span class="s3">\n  </span><span class="s1">): string | undefined {</span><span class="s3">\n    </span><span class="s1">const extra = node.extra;</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">extra?.raw != null &amp;&amp;</span><span class="s3">\n      </span><span class="s1">extra.rawValue != null &amp;&amp;</span><span class="s3">\n      </span><span class="s1">node.value === extra.rawValue</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">// @ts-expect-error: The extra.raw of these AST node types must be a string</span><span class="s3">\n      </span><span class="s1">return extra.raw;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">printJoin(</span><span class="s3">\n    </span><span class="s1">nodes: Array&lt;t.Node&gt; | undefined | null,</span><span class="s3">\n    </span><span class="s1">statement?: boolean,</span><span class="s3">\n    </span><span class="s1">indent?: boolean,</span><span class="s3">\n    </span><span class="s1">separator?: PrintJoinOptions[</span><span class="s3">\&quot;</span><span class="s1">separator</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">printTrailingSeparator?: boolean,</span><span class="s3">\n    </span><span class="s1">addNewlines?: PrintJoinOptions[</span><span class="s3">\&quot;</span><span class="s1">addNewlines</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">iterator?: PrintJoinOptions[</span><span class="s3">\&quot;</span><span class="s1">iterator</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">trailingCommentsLineOffset?: number,</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">if (!nodes?.length) return;</span><span class="s3">\n\n    </span><span class="s1">if (indent == null &amp;&amp; this.format.retainLines) {</span><span class="s3">\n      </span><span class="s1">const startLine = nodes[0].loc?.start.line;</span><span class="s3">\n      </span><span class="s1">if (startLine != null &amp;&amp; startLine !== this._buf.getCurrentLine()) {</span><span class="s3">\n        </span><span class="s1">indent = true;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (indent) this.indent();</span><span class="s3">\n\n    </span><span class="s1">const newlineOpts: AddNewlinesOptions = {</span><span class="s3">\n      </span><span class="s1">addNewlines: addNewlines,</span><span class="s3">\n      </span><span class="s1">nextNodeStartLine: 0,</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n\n    </span><span class="s1">const boundSeparator = separator?.bind(this);</span><span class="s3">\n\n    </span><span class="s1">const len = nodes.length;</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; len; i++) {</span><span class="s3">\n      </span><span class="s1">const node = nodes[i];</span><span class="s3">\n      </span><span class="s1">if (!node) continue;</span><span class="s3">\n\n      </span><span class="s1">if (statement) this._printNewline(i === 0, newlineOpts);</span><span class="s3">\n\n      </span><span class="s1">this.print(node, undefined, trailingCommentsLineOffset || 0);</span><span class="s3">\n\n      </span><span class="s1">iterator?.(node, i);</span><span class="s3">\n\n      </span><span class="s1">if (boundSeparator != null) {</span><span class="s3">\n        </span><span class="s1">if (i &lt; len - 1) boundSeparator(i, false);</span><span class="s3">\n        </span><span class="s1">else if (printTrailingSeparator) boundSeparator(i, true);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (statement) {</span><span class="s3">\n        </span><span class="s1">if (!node.trailingComments?.length) {</span><span class="s3">\n          </span><span class="s1">this._lastCommentLine = 0;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (i + 1 === len) {</span><span class="s3">\n          </span><span class="s1">this.newline(1);</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">const nextNode = nodes[i + 1];</span><span class="s3">\n          </span><span class="s1">newlineOpts.nextNodeStartLine = nextNode.loc?.start.line || 0;</span><span class="s3">\n\n          </span><span class="s1">this._printNewline(true, newlineOpts);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (indent) this.dedent();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">printAndIndentOnComments(node: t.Node) {</span><span class="s3">\n    </span><span class="s1">const indent = node.leadingComments &amp;&amp; node.leadingComments.length &gt; 0;</span><span class="s3">\n    </span><span class="s1">if (indent) this.indent();</span><span class="s3">\n    </span><span class="s1">this.print(node);</span><span class="s3">\n    </span><span class="s1">if (indent) this.dedent();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">printBlock(parent: Extract&lt;t.Node, { body: t.Statement }&gt;) {</span><span class="s3">\n    </span><span class="s1">const node = parent.body;</span><span class="s3">\n\n    </span><span class="s1">if (node.type !== </span><span class="s3">\&quot;</span><span class="s1">EmptyStatement</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">this.space();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this.print(node);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_printTrailingComments(node: t.Node, parent?: t.Node, lineOffset?: number) {</span><span class="s3">\n    </span><span class="s1">const { innerComments, trailingComments } = node;</span><span class="s3">\n    </span><span class="s1">// We print inner comments here, so that if for some reason they couldn't</span><span class="s3">\n    </span><span class="s1">// be printed in earlier locations they are still printed *somewhere*,</span><span class="s3">\n    </span><span class="s1">// even if at the end of the node.</span><span class="s3">\n    </span><span class="s1">if (innerComments?.length) {</span><span class="s3">\n      </span><span class="s1">this._printComments(</span><span class="s3">\n        </span><span class="s1">COMMENT_TYPE.TRAILING,</span><span class="s3">\n        </span><span class="s1">innerComments,</span><span class="s3">\n        </span><span class="s1">node,</span><span class="s3">\n        </span><span class="s1">parent,</span><span class="s3">\n        </span><span class="s1">lineOffset,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (trailingComments?.length) {</span><span class="s3">\n      </span><span class="s1">this._printComments(</span><span class="s3">\n        </span><span class="s1">COMMENT_TYPE.TRAILING,</span><span class="s3">\n        </span><span class="s1">trailingComments,</span><span class="s3">\n        </span><span class="s1">node,</span><span class="s3">\n        </span><span class="s1">parent,</span><span class="s3">\n        </span><span class="s1">lineOffset,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_printLeadingComments(node: t.Node, parent: t.Node) {</span><span class="s3">\n    </span><span class="s1">const comments = node.leadingComments;</span><span class="s3">\n    </span><span class="s1">if (!comments?.length) return;</span><span class="s3">\n    </span><span class="s1">this._printComments(COMMENT_TYPE.LEADING, comments, node, parent);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_maybePrintInnerComments(</span><span class="s3">\n    </span><span class="s1">nextTokenStr: string,</span><span class="s3">\n    </span><span class="s1">nextTokenOccurrenceCount?: number,</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">if (this._endsWithInnerRaw) {</span><span class="s3">\n      </span><span class="s1">this.printInnerComments(</span><span class="s3">\n        </span><span class="s1">this.tokenMap?.findMatching(</span><span class="s3">\n          </span><span class="s1">this._currentNode,</span><span class="s3">\n          </span><span class="s1">nextTokenStr,</span><span class="s3">\n          </span><span class="s1">nextTokenOccurrenceCount,</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this._endsWithInnerRaw = true;</span><span class="s3">\n    </span><span class="s1">this._indentInnerComments = true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">printInnerComments(nextToken?: Token) {</span><span class="s3">\n    </span><span class="s1">const node = this._currentNode;</span><span class="s3">\n    </span><span class="s1">const comments = node.innerComments;</span><span class="s3">\n    </span><span class="s1">if (!comments?.length) return;</span><span class="s3">\n\n    </span><span class="s1">const hasSpace = this.endsWith(charCodes.space);</span><span class="s3">\n    </span><span class="s1">const indent = this._indentInnerComments;</span><span class="s3">\n    </span><span class="s1">const printedCommentsCount = this._printedComments.size;</span><span class="s3">\n    </span><span class="s1">if (indent) this.indent();</span><span class="s3">\n    </span><span class="s1">this._printComments(</span><span class="s3">\n      </span><span class="s1">COMMENT_TYPE.INNER,</span><span class="s3">\n      </span><span class="s1">comments,</span><span class="s3">\n      </span><span class="s1">node,</span><span class="s3">\n      </span><span class="s1">undefined,</span><span class="s3">\n      </span><span class="s1">undefined,</span><span class="s3">\n      </span><span class="s1">nextToken,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">if (hasSpace &amp;&amp; printedCommentsCount !== this._printedComments.size) {</span><span class="s3">\n      </span><span class="s1">this.space();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (indent) this.dedent();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">noIndentInnerCommentsHere() {</span><span class="s3">\n    </span><span class="s1">this._indentInnerComments = false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">printSequence(</span><span class="s3">\n    </span><span class="s1">nodes: t.Node[],</span><span class="s3">\n    </span><span class="s1">indent?: boolean,</span><span class="s3">\n    </span><span class="s1">trailingCommentsLineOffset?: number,</span><span class="s3">\n    </span><span class="s1">addNewlines?: PrintSequenceOptions[</span><span class="s3">\&quot;</span><span class="s1">addNewlines</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">this.printJoin(</span><span class="s3">\n      </span><span class="s1">nodes,</span><span class="s3">\n      </span><span class="s1">true,</span><span class="s3">\n      </span><span class="s1">indent ?? false,</span><span class="s3">\n      </span><span class="s1">undefined,</span><span class="s3">\n      </span><span class="s1">undefined,</span><span class="s3">\n      </span><span class="s1">addNewlines,</span><span class="s3">\n      </span><span class="s1">undefined,</span><span class="s3">\n      </span><span class="s1">trailingCommentsLineOffset,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">printList(</span><span class="s3">\n    </span><span class="s1">items: t.Node[],</span><span class="s3">\n    </span><span class="s1">printTrailingSeparator?: boolean,</span><span class="s3">\n    </span><span class="s1">statement?: boolean,</span><span class="s3">\n    </span><span class="s1">indent?: boolean,</span><span class="s3">\n    </span><span class="s1">separator?: PrintListOptions[</span><span class="s3">\&quot;</span><span class="s1">separator</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">iterator?: PrintListOptions[</span><span class="s3">\&quot;</span><span class="s1">iterator</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">this.printJoin(</span><span class="s3">\n      </span><span class="s1">items,</span><span class="s3">\n      </span><span class="s1">statement,</span><span class="s3">\n      </span><span class="s1">indent,</span><span class="s3">\n      </span><span class="s1">separator ?? commaSeparator,</span><span class="s3">\n      </span><span class="s1">printTrailingSeparator,</span><span class="s3">\n      </span><span class="s1">undefined,</span><span class="s3">\n      </span><span class="s1">iterator,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">shouldPrintTrailingComma(listEnd: string): boolean | null {</span><span class="s3">\n    </span><span class="s1">if (!this.tokenMap) return null;</span><span class="s3">\n\n    </span><span class="s1">const listEndIndex = this.tokenMap.findLastIndex(this._currentNode, token =&gt;</span><span class="s3">\n      </span><span class="s1">this.tokenMap.matchesOriginal(token, listEnd),</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">if (listEndIndex &lt;= 0) return null;</span><span class="s3">\n    </span><span class="s1">return this.tokenMap.matchesOriginal(this._tokens[listEndIndex - 1], </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_printNewline(newLine: boolean, opts: AddNewlinesOptions) {</span><span class="s3">\n    </span><span class="s1">const format = this.format;</span><span class="s3">\n\n    </span><span class="s1">// Fast path since 'this.newline' does nothing when not tracking lines.</span><span class="s3">\n    </span><span class="s1">if (format.retainLines || format.compact) return;</span><span class="s3">\n\n    </span><span class="s1">// Fast path for concise since 'this.newline' just inserts a space when</span><span class="s3">\n    </span><span class="s1">// concise formatting is in use.</span><span class="s3">\n    </span><span class="s1">if (format.concise) {</span><span class="s3">\n      </span><span class="s1">this.space();</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (!newLine) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const startLine = opts.nextNodeStartLine;</span><span class="s3">\n    </span><span class="s1">const lastCommentLine = this._lastCommentLine;</span><span class="s3">\n    </span><span class="s1">if (startLine &gt; 0 &amp;&amp; lastCommentLine &gt; 0) {</span><span class="s3">\n      </span><span class="s1">const offset = startLine - lastCommentLine;</span><span class="s3">\n      </span><span class="s1">if (offset &gt;= 0) {</span><span class="s3">\n        </span><span class="s1">this.newline(offset || 1);</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// don't add newlines at the beginning of the file</span><span class="s3">\n    </span><span class="s1">if (this._buf.hasContent()) {</span><span class="s3">\n      </span><span class="s1">// Here is the logic of the original line wrapping according to the node layout, we are not using it now.</span><span class="s3">\n      </span><span class="s1">// We currently add at most one newline to each node in the list, ignoring `opts.addNewlines`.</span><span class="s3">\n\n      </span><span class="s1">// let lines = 0;</span><span class="s3">\n      </span><span class="s1">// if (!leading) lines++; // always include at least a single line after</span><span class="s3">\n      </span><span class="s1">// if (opts.addNewlines) lines += opts.addNewlines(leading, node) || 0;</span><span class="s3">\n\n      </span><span class="s1">// const needs = leading ? needsWhitespaceBefore : needsWhitespaceAfter;</span><span class="s3">\n      </span><span class="s1">// if (needs(node, parent)) lines++;</span><span class="s3">\n\n      </span><span class="s1">// this.newline(Math.min(2, lines));</span><span class="s3">\n\n      </span><span class="s1">this.newline(1);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Returns `PRINT_COMMENT_HINT.DEFER` if the comment cannot be printed in this position due to</span><span class="s3">\n  </span><span class="s1">// line terminators, signaling that the print comments loop can stop and</span><span class="s3">\n  </span><span class="s1">// resume printing comments at the next possible position. This happens when</span><span class="s3">\n  </span><span class="s1">// printing inner comments, since if we have an inner comment with a multiline</span><span class="s3">\n  </span><span class="s1">// there is at least one inner position where line terminators are allowed.</span><span class="s3">\n  </span><span class="s1">_shouldPrintComment(</span><span class="s3">\n    </span><span class="s1">comment: t.Comment,</span><span class="s3">\n    </span><span class="s1">nextToken?: Token,</span><span class="s3">\n  </span><span class="s1">): PRINT_COMMENT_HINT {</span><span class="s3">\n    </span><span class="s1">// Some plugins (such as flow-strip-types) use this to mark comments as removed using the AST-root 'comments' property,</span><span class="s3">\n    </span><span class="s1">// where they can't manually mutate the AST node comment lists.</span><span class="s3">\n    </span><span class="s1">if (comment.ignore) return PRINT_COMMENT_HINT.SKIP;</span><span class="s3">\n\n    </span><span class="s1">if (this._printedComments.has(comment)) return PRINT_COMMENT_HINT.SKIP;</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">this._noLineTerminator &amp;&amp;</span><span class="s3">\n      </span><span class="s1">HAS_NEWLINE_OR_BlOCK_COMMENT_END.test(comment.value)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return PRINT_COMMENT_HINT.DEFER;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (nextToken &amp;&amp; this.tokenMap) {</span><span class="s3">\n      </span><span class="s1">const commentTok = this.tokenMap.find(</span><span class="s3">\n        </span><span class="s1">this._currentNode,</span><span class="s3">\n        </span><span class="s1">token =&gt; token.value === comment.value,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">if (commentTok &amp;&amp; commentTok.start &gt; nextToken.start) {</span><span class="s3">\n        </span><span class="s1">return PRINT_COMMENT_HINT.DEFER;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this._printedComments.add(comment);</span><span class="s3">\n\n    </span><span class="s1">if (!this.format.shouldPrintComment(comment.value)) {</span><span class="s3">\n      </span><span class="s1">return PRINT_COMMENT_HINT.SKIP;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return PRINT_COMMENT_HINT.ALLOW;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_printComment(comment: t.Comment, skipNewLines: COMMENT_SKIP_NEWLINE) {</span><span class="s3">\n    </span><span class="s1">const noLineTerminator = this._noLineTerminator;</span><span class="s3">\n    </span><span class="s1">const isBlockComment = comment.type === </span><span class="s3">\&quot;</span><span class="s1">CommentBlock</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n    </span><span class="s1">// Add a newline before and after a block comment, unless explicitly</span><span class="s3">\n    </span><span class="s1">// disallowed</span><span class="s3">\n    </span><span class="s1">const printNewLines =</span><span class="s3">\n      </span><span class="s1">isBlockComment &amp;&amp;</span><span class="s3">\n      </span><span class="s1">skipNewLines !== COMMENT_SKIP_NEWLINE.ALL &amp;&amp;</span><span class="s3">\n      </span><span class="s1">!this._noLineTerminator;</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">printNewLines &amp;&amp;</span><span class="s3">\n      </span><span class="s1">this._buf.hasContent() &amp;&amp;</span><span class="s3">\n      </span><span class="s1">skipNewLines !== COMMENT_SKIP_NEWLINE.LEADING</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">this.newline(1);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const lastCharCode = this.getLastChar();</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">lastCharCode !== charCodes.leftSquareBracket &amp;&amp;</span><span class="s3">\n      </span><span class="s1">lastCharCode !== charCodes.leftCurlyBrace &amp;&amp;</span><span class="s3">\n      </span><span class="s1">lastCharCode !== charCodes.leftParenthesis</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">this.space();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">let val;</span><span class="s3">\n    </span><span class="s1">if (isBlockComment) {</span><span class="s3">\n      </span><span class="s1">val = `/*${comment.value}*/`;</span><span class="s3">\n      </span><span class="s1">if (this.format.indent.adjustMultilineComment) {</span><span class="s3">\n        </span><span class="s1">const offset = comment.loc?.start.column;</span><span class="s3">\n        </span><span class="s1">if (offset) {</span><span class="s3">\n          </span><span class="s1">const newlineRegex = new RegExp(</span><span class="s3">\&quot;\\\\</span><span class="s1">n</span><span class="s3">\\\\</span><span class="s1">s{1,</span><span class="s3">\&quot; </span><span class="s1">+ offset + </span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">val = val.replace(newlineRegex, </span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (this.format.concise) {</span><span class="s3">\n          </span><span class="s1">val = val.replace(/</span><span class="s3">\\</span><span class="s1">n(?!$)/g, `</span><span class="s3">\\</span><span class="s1">n`);</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">let indentSize = this.format.retainLines</span><span class="s3">\n            </span><span class="s1">? 0</span><span class="s3">\n            </span><span class="s1">: this._buf.getCurrentColumn();</span><span class="s3">\n\n          </span><span class="s1">if (this._shouldIndent(charCodes.slash) || this.format.retainLines) {</span><span class="s3">\n            </span><span class="s1">indentSize += this._getIndent();</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">val = val.replace(/</span><span class="s3">\\</span><span class="s1">n(?!$)/g, `</span><span class="s3">\\</span><span class="s1">n${</span><span class="s3">\&quot; \&quot;</span><span class="s1">.repeat(indentSize)}`);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (!noLineTerminator) {</span><span class="s3">\n      </span><span class="s1">val = `//${comment.value}`;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// It was a single-line comment, so it's guaranteed to not</span><span class="s3">\n      </span><span class="s1">// contain newlines and it can be safely printed as a block</span><span class="s3">\n      </span><span class="s1">// comment.</span><span class="s3">\n      </span><span class="s1">val = `/*${comment.value}*/`;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Avoid converting a / operator into a line comment by appending /* to it</span><span class="s3">\n    </span><span class="s1">if (this._endsWithDiv) this._space();</span><span class="s3">\n\n    </span><span class="s1">if (this.tokenMap) {</span><span class="s3">\n      </span><span class="s1">const { _printSemicolonBeforeNextToken, _printSemicolonBeforeNextNode } =</span><span class="s3">\n        </span><span class="s1">this;</span><span class="s3">\n      </span><span class="s1">this._printSemicolonBeforeNextToken = -1;</span><span class="s3">\n      </span><span class="s1">this._printSemicolonBeforeNextNode = -1;</span><span class="s3">\n      </span><span class="s1">this.source(</span><span class="s3">\&quot;</span><span class="s1">start</span><span class="s3">\&quot;</span><span class="s1">, comment.loc);</span><span class="s3">\n      </span><span class="s1">this._append(val, isBlockComment);</span><span class="s3">\n      </span><span class="s1">this._printSemicolonBeforeNextNode = _printSemicolonBeforeNextNode;</span><span class="s3">\n      </span><span class="s1">this._printSemicolonBeforeNextToken = _printSemicolonBeforeNextToken;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">this.source(</span><span class="s3">\&quot;</span><span class="s1">start</span><span class="s3">\&quot;</span><span class="s1">, comment.loc);</span><span class="s3">\n      </span><span class="s1">this._append(val, isBlockComment);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (!isBlockComment &amp;&amp; !noLineTerminator) {</span><span class="s3">\n      </span><span class="s1">this.newline(1, true);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (printNewLines &amp;&amp; skipNewLines !== COMMENT_SKIP_NEWLINE.TRAILING) {</span><span class="s3">\n      </span><span class="s1">this.newline(1);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_printComments(</span><span class="s3">\n    </span><span class="s1">type: COMMENT_TYPE,</span><span class="s3">\n    </span><span class="s1">comments: readonly t.Comment[],</span><span class="s3">\n    </span><span class="s1">node: t.Node,</span><span class="s3">\n    </span><span class="s1">parent?: t.Node,</span><span class="s3">\n    </span><span class="s1">lineOffset: number = 0,</span><span class="s3">\n    </span><span class="s1">nextToken?: Token,</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">const nodeLoc = node.loc;</span><span class="s3">\n    </span><span class="s1">const len = comments.length;</span><span class="s3">\n    </span><span class="s1">let hasLoc = !!nodeLoc;</span><span class="s3">\n    </span><span class="s1">const nodeStartLine = hasLoc ? nodeLoc.start.line : 0;</span><span class="s3">\n    </span><span class="s1">const nodeEndLine = hasLoc ? nodeLoc.end.line : 0;</span><span class="s3">\n    </span><span class="s1">let lastLine = 0;</span><span class="s3">\n    </span><span class="s1">let leadingCommentNewline = 0;</span><span class="s3">\n\n    </span><span class="s1">const maybeNewline = this._noLineTerminator</span><span class="s3">\n      </span><span class="s1">? function () {}</span><span class="s3">\n      </span><span class="s1">: this.newline.bind(this);</span><span class="s3">\n\n    </span><span class="s1">for (let i = 0; i &lt; len; i++) {</span><span class="s3">\n      </span><span class="s1">const comment = comments[i];</span><span class="s3">\n\n      </span><span class="s1">const shouldPrint = this._shouldPrintComment(comment, nextToken);</span><span class="s3">\n      </span><span class="s1">if (shouldPrint === PRINT_COMMENT_HINT.DEFER) {</span><span class="s3">\n        </span><span class="s1">hasLoc = false;</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (hasLoc &amp;&amp; comment.loc &amp;&amp; shouldPrint === PRINT_COMMENT_HINT.ALLOW) {</span><span class="s3">\n        </span><span class="s1">const commentStartLine = comment.loc.start.line;</span><span class="s3">\n        </span><span class="s1">const commentEndLine = comment.loc.end.line;</span><span class="s3">\n        </span><span class="s1">if (type === COMMENT_TYPE.LEADING) {</span><span class="s3">\n          </span><span class="s1">let offset = 0;</span><span class="s3">\n          </span><span class="s1">if (i === 0) {</span><span class="s3">\n            </span><span class="s1">// Because currently we cannot handle blank lines before leading comments,</span><span class="s3">\n            </span><span class="s1">// we always wrap before and after multi-line comments.</span><span class="s3">\n            </span><span class="s1">if (</span><span class="s3">\n              </span><span class="s1">this._buf.hasContent() &amp;&amp;</span><span class="s3">\n              </span><span class="s1">(comment.type === </span><span class="s3">\&quot;</span><span class="s1">CommentLine</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n                </span><span class="s1">commentStartLine !== commentEndLine)</span><span class="s3">\n            </span><span class="s1">) {</span><span class="s3">\n              </span><span class="s1">offset = leadingCommentNewline = 1;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">offset = commentStartLine - lastLine;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">lastLine = commentEndLine;</span><span class="s3">\n\n          </span><span class="s1">maybeNewline(offset);</span><span class="s3">\n          </span><span class="s1">this._printComment(comment, COMMENT_SKIP_NEWLINE.ALL);</span><span class="s3">\n\n          </span><span class="s1">if (i + 1 === len) {</span><span class="s3">\n            </span><span class="s1">maybeNewline(</span><span class="s3">\n              </span><span class="s1">Math.max(nodeStartLine - lastLine, leadingCommentNewline),</span><span class="s3">\n            </span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">lastLine = nodeStartLine;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} else if (type === COMMENT_TYPE.INNER) {</span><span class="s3">\n          </span><span class="s1">const offset =</span><span class="s3">\n            </span><span class="s1">commentStartLine - (i === 0 ? nodeStartLine : lastLine);</span><span class="s3">\n          </span><span class="s1">lastLine = commentEndLine;</span><span class="s3">\n\n          </span><span class="s1">maybeNewline(offset);</span><span class="s3">\n          </span><span class="s1">this._printComment(comment, COMMENT_SKIP_NEWLINE.ALL);</span><span class="s3">\n\n          </span><span class="s1">if (i + 1 === len) {</span><span class="s3">\n            </span><span class="s1">maybeNewline(Math.min(1, nodeEndLine - lastLine)); // TODO: Improve here when inner comments processing is stronger</span><span class="s3">\n            </span><span class="s1">lastLine = nodeEndLine;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">const offset =</span><span class="s3">\n            </span><span class="s1">commentStartLine - (i === 0 ? nodeEndLine - lineOffset : lastLine);</span><span class="s3">\n          </span><span class="s1">lastLine = commentEndLine;</span><span class="s3">\n\n          </span><span class="s1">maybeNewline(offset);</span><span class="s3">\n          </span><span class="s1">this._printComment(comment, COMMENT_SKIP_NEWLINE.ALL);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">hasLoc = false;</span><span class="s3">\n        </span><span class="s1">if (shouldPrint !== PRINT_COMMENT_HINT.ALLOW) {</span><span class="s3">\n          </span><span class="s1">continue;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (len === 1) {</span><span class="s3">\n          </span><span class="s1">const singleLine = comment.loc</span><span class="s3">\n            </span><span class="s1">? comment.loc.start.line === comment.loc.end.line</span><span class="s3">\n            </span><span class="s1">: !HAS_NEWLINE.test(comment.value);</span><span class="s3">\n\n          </span><span class="s1">const shouldSkipNewline =</span><span class="s3">\n            </span><span class="s1">singleLine &amp;&amp;</span><span class="s3">\n            </span><span class="s1">!isStatement(node) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">!isClassBody(parent) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">!isTSInterfaceBody(parent) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">!isTSEnumMember(node);</span><span class="s3">\n\n          </span><span class="s1">if (type === COMMENT_TYPE.LEADING) {</span><span class="s3">\n            </span><span class="s1">this._printComment(</span><span class="s3">\n              </span><span class="s1">comment,</span><span class="s3">\n              </span><span class="s1">(shouldSkipNewline &amp;&amp; node.type !== </span><span class="s3">\&quot;</span><span class="s1">ObjectExpression</span><span class="s3">\&quot;</span><span class="s1">) ||</span><span class="s3">\n                </span><span class="s1">(singleLine &amp;&amp; isFunction(parent, { body: node }))</span><span class="s3">\n                </span><span class="s1">? COMMENT_SKIP_NEWLINE.ALL</span><span class="s3">\n                </span><span class="s1">: COMMENT_SKIP_NEWLINE.DEFAULT,</span><span class="s3">\n            </span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">} else if (shouldSkipNewline &amp;&amp; type === COMMENT_TYPE.TRAILING) {</span><span class="s3">\n            </span><span class="s1">this._printComment(comment, COMMENT_SKIP_NEWLINE.ALL);</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">this._printComment(comment, COMMENT_SKIP_NEWLINE.DEFAULT);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} else if (</span><span class="s3">\n          </span><span class="s1">type === COMMENT_TYPE.INNER &amp;&amp;</span><span class="s3">\n          </span><span class="s1">!(node.type === </span><span class="s3">\&quot;</span><span class="s1">ObjectExpression</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; node.properties.length &gt; 1) &amp;&amp;</span><span class="s3">\n          </span><span class="s1">node.type !== </span><span class="s3">\&quot;</span><span class="s1">ClassBody</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n          </span><span class="s1">node.type !== </span><span class="s3">\&quot;</span><span class="s1">TSInterfaceBody</span><span class="s3">\&quot;\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">// class X {</span><span class="s3">\n          </span><span class="s1">//   /*:: a: number*/</span><span class="s3">\n          </span><span class="s1">//   /*:: b: ?string*/</span><span class="s3">\n          </span><span class="s1">// }</span><span class="s3">\n\n          </span><span class="s1">this._printComment(</span><span class="s3">\n            </span><span class="s1">comment,</span><span class="s3">\n            </span><span class="s1">i === 0</span><span class="s3">\n              </span><span class="s1">? COMMENT_SKIP_NEWLINE.LEADING</span><span class="s3">\n              </span><span class="s1">: i === len - 1</span><span class="s3">\n                </span><span class="s1">? COMMENT_SKIP_NEWLINE.TRAILING</span><span class="s3">\n                </span><span class="s1">: COMMENT_SKIP_NEWLINE.DEFAULT,</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">this._printComment(comment, COMMENT_SKIP_NEWLINE.DEFAULT);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (type === COMMENT_TYPE.TRAILING &amp;&amp; hasLoc &amp;&amp; lastLine) {</span><span class="s3">\n      </span><span class="s1">this._lastCommentLine = lastLine;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Expose the node type functions and helpers on the prototype for easy usage.</span><span class="s3">\n</span><span class="s1">Object.assign(Printer.prototype, generatorFunctions);</span><span class="s3">\n\n</span><span class="s1">if (!process.env.BABEL_8_BREAKING) {</span><span class="s3">\n  </span><span class="s1">addDeprecatedGenerators(Printer);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type GeneratorFunctions = typeof generatorFunctions;</span><span class="s3">\n</span><span class="s1">// eslint-disable-next-line @typescript-eslint/no-empty-object-type</span><span class="s3">\n</span><span class="s1">interface Printer extends GeneratorFunctions {}</span><span class="s3">\n</span><span class="s1">export default Printer;</span><span class="s3">\n\n</span><span class="s1">function commaSeparator(this: Printer, occurrenceCount: number, last: boolean) {</span><span class="s3">\n  </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">, false, occurrenceCount);</span><span class="s3">\n  </span><span class="s1">if (!last) this.space();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[]}</span></pre>
</body>
</html>