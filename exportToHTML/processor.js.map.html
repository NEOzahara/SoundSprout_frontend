<html>
<head>
<title>processor.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
processor.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;processor.js&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceRoot&quot;</span><span class="s0">:</span><span class="s1">&quot;&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../src/processor.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;// synchronous utility for filtering entries and calculating subwalks</span><span class="s3">\n\n</span><span class="s1">import { GLOBSTAR, MMRegExp } from 'minimatch'</span><span class="s3">\n</span><span class="s1">import { Path } from 'path-scurry'</span><span class="s3">\n</span><span class="s1">import { MMPattern, Pattern } from './pattern.js'</span><span class="s3">\n</span><span class="s1">import { GlobWalkerOpts } from './walker.js'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A cache of which patterns have been processed for a given Path</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class HasWalkedCache {</span><span class="s3">\n  </span><span class="s1">store: Map&lt;string, Set&lt;string&gt;&gt;</span><span class="s3">\n  </span><span class="s1">constructor(store: Map&lt;string, Set&lt;string&gt;&gt; = new Map()) {</span><span class="s3">\n    </span><span class="s1">this.store = store</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">copy() {</span><span class="s3">\n    </span><span class="s1">return new HasWalkedCache(new Map(this.store))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">hasWalked(target: Path, pattern: Pattern) {</span><span class="s3">\n    </span><span class="s1">return this.store.get(target.fullpath())?.has(pattern.globString())</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">storeWalked(target: Path, pattern: Pattern) {</span><span class="s3">\n    </span><span class="s1">const fullpath = target.fullpath()</span><span class="s3">\n    </span><span class="s1">const cached = this.store.get(fullpath)</span><span class="s3">\n    </span><span class="s1">if (cached) cached.add(pattern.globString())</span><span class="s3">\n    </span><span class="s1">else this.store.set(fullpath, new Set([pattern.globString()]))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A record of which paths have been matched in a given walk step,</span><span class="s3">\n </span><span class="s1">* and whether they only are considered a match if they are a directory,</span><span class="s3">\n </span><span class="s1">* and whether their absolute or relative path should be returned.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class MatchRecord {</span><span class="s3">\n  </span><span class="s1">store: Map&lt;Path, number&gt; = new Map()</span><span class="s3">\n  </span><span class="s1">add(target: Path, absolute: boolean, ifDir: boolean) {</span><span class="s3">\n    </span><span class="s1">const n = (absolute ? 2 : 0) | (ifDir ? 1 : 0)</span><span class="s3">\n    </span><span class="s1">const current = this.store.get(target)</span><span class="s3">\n    </span><span class="s1">this.store.set(target, current === undefined ? n : n &amp; current)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// match, absolute, ifdir</span><span class="s3">\n  </span><span class="s1">entries(): [Path, boolean, boolean][] {</span><span class="s3">\n    </span><span class="s1">return [...this.store.entries()].map(([path, n]) =&gt; [</span><span class="s3">\n      </span><span class="s1">path,</span><span class="s3">\n      </span><span class="s1">!!(n &amp; 2),</span><span class="s3">\n      </span><span class="s1">!!(n &amp; 1),</span><span class="s3">\n    </span><span class="s1">])</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A collection of patterns that must be processed in a subsequent step</span><span class="s3">\n </span><span class="s1">* for a given path.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class SubWalks {</span><span class="s3">\n  </span><span class="s1">store: Map&lt;Path, Pattern[]&gt; = new Map()</span><span class="s3">\n  </span><span class="s1">add(target: Path, pattern: Pattern) {</span><span class="s3">\n    </span><span class="s1">if (!target.canReaddir()) {</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const subs = this.store.get(target)</span><span class="s3">\n    </span><span class="s1">if (subs) {</span><span class="s3">\n      </span><span class="s1">if (!subs.find(p =&gt; p.globString() === pattern.globString())) {</span><span class="s3">\n        </span><span class="s1">subs.push(pattern)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else this.store.set(target, [pattern])</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">get(target: Path): Pattern[] {</span><span class="s3">\n    </span><span class="s1">const subs = this.store.get(target)</span><span class="s3">\n    </span><span class="s1">/* c8 ignore start */</span><span class="s3">\n    </span><span class="s1">if (!subs) {</span><span class="s3">\n      </span><span class="s1">throw new Error('attempting to walk unknown path')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/* c8 ignore stop */</span><span class="s3">\n    </span><span class="s1">return subs</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">entries(): [Path, Pattern[]][] {</span><span class="s3">\n    </span><span class="s1">return this.keys().map(k =&gt; [k, this.store.get(k) as Pattern[]])</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">keys(): Path[] {</span><span class="s3">\n    </span><span class="s1">return [...this.store.keys()].filter(t =&gt; t.canReaddir())</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The class that processes patterns for a given path.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Handles child entry filtering, and determining whether a path's</span><span class="s3">\n </span><span class="s1">* directory contents must be read.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class Processor {</span><span class="s3">\n  </span><span class="s1">hasWalkedCache: HasWalkedCache</span><span class="s3">\n  </span><span class="s1">matches = new MatchRecord()</span><span class="s3">\n  </span><span class="s1">subwalks = new SubWalks()</span><span class="s3">\n  </span><span class="s1">patterns?: Pattern[]</span><span class="s3">\n  </span><span class="s1">follow: boolean</span><span class="s3">\n  </span><span class="s1">dot: boolean</span><span class="s3">\n  </span><span class="s1">opts: GlobWalkerOpts</span><span class="s3">\n\n  </span><span class="s1">constructor(opts: GlobWalkerOpts, hasWalkedCache?: HasWalkedCache) {</span><span class="s3">\n    </span><span class="s1">this.opts = opts</span><span class="s3">\n    </span><span class="s1">this.follow = !!opts.follow</span><span class="s3">\n    </span><span class="s1">this.dot = !!opts.dot</span><span class="s3">\n    </span><span class="s1">this.hasWalkedCache =</span><span class="s3">\n      </span><span class="s1">hasWalkedCache ? hasWalkedCache.copy() : new HasWalkedCache()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">processPatterns(target: Path, patterns: Pattern[]) {</span><span class="s3">\n    </span><span class="s1">this.patterns = patterns</span><span class="s3">\n    </span><span class="s1">const processingSet: [Path, Pattern][] = patterns.map(p =&gt; [target, p])</span><span class="s3">\n\n    </span><span class="s1">// map of paths to the magic-starting subwalks they need to walk</span><span class="s3">\n    </span><span class="s1">// first item in patterns is the filter</span><span class="s3">\n\n    </span><span class="s1">for (let [t, pattern] of processingSet) {</span><span class="s3">\n      </span><span class="s1">this.hasWalkedCache.storeWalked(t, pattern)</span><span class="s3">\n\n      </span><span class="s1">const root = pattern.root()</span><span class="s3">\n      </span><span class="s1">const absolute = pattern.isAbsolute() &amp;&amp; this.opts.absolute !== false</span><span class="s3">\n\n      </span><span class="s1">// start absolute patterns at root</span><span class="s3">\n      </span><span class="s1">if (root) {</span><span class="s3">\n        </span><span class="s1">t = t.resolve(</span><span class="s3">\n          </span><span class="s1">root === '/' &amp;&amp; this.opts.root !== undefined ?</span><span class="s3">\n            </span><span class="s1">this.opts.root</span><span class="s3">\n          </span><span class="s1">: root,</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">const rest = pattern.rest()</span><span class="s3">\n        </span><span class="s1">if (!rest) {</span><span class="s3">\n          </span><span class="s1">this.matches.add(t, true, false)</span><span class="s3">\n          </span><span class="s1">continue</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">pattern = rest</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (t.isENOENT()) continue</span><span class="s3">\n\n      </span><span class="s1">let p: MMPattern</span><span class="s3">\n      </span><span class="s1">let rest: Pattern | null</span><span class="s3">\n      </span><span class="s1">let changed = false</span><span class="s3">\n      </span><span class="s1">while (</span><span class="s3">\n        </span><span class="s1">typeof (p = pattern.pattern()) === 'string' &amp;&amp;</span><span class="s3">\n        </span><span class="s1">(rest = pattern.rest())</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">const c = t.resolve(p)</span><span class="s3">\n        </span><span class="s1">t = c</span><span class="s3">\n        </span><span class="s1">pattern = rest</span><span class="s3">\n        </span><span class="s1">changed = true</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">p = pattern.pattern()</span><span class="s3">\n      </span><span class="s1">rest = pattern.rest()</span><span class="s3">\n      </span><span class="s1">if (changed) {</span><span class="s3">\n        </span><span class="s1">if (this.hasWalkedCache.hasWalked(t, pattern)) continue</span><span class="s3">\n        </span><span class="s1">this.hasWalkedCache.storeWalked(t, pattern)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// now we have either a final string for a known entry,</span><span class="s3">\n      </span><span class="s1">// more strings for an unknown entry,</span><span class="s3">\n      </span><span class="s1">// or a pattern starting with magic, mounted on t.</span><span class="s3">\n      </span><span class="s1">if (typeof p === 'string') {</span><span class="s3">\n        </span><span class="s1">// must not be final entry, otherwise we would have</span><span class="s3">\n        </span><span class="s1">// concatenated it earlier.</span><span class="s3">\n        </span><span class="s1">const ifDir = p === '..' || p === '' || p === '.'</span><span class="s3">\n        </span><span class="s1">this.matches.add(t.resolve(p), absolute, ifDir)</span><span class="s3">\n        </span><span class="s1">continue</span><span class="s3">\n      </span><span class="s1">} else if (p === GLOBSTAR) {</span><span class="s3">\n        </span><span class="s1">// if no rest, match and subwalk pattern</span><span class="s3">\n        </span><span class="s1">// if rest, process rest and subwalk pattern</span><span class="s3">\n        </span><span class="s1">// if it's a symlink, but we didn't get here by way of a</span><span class="s3">\n        </span><span class="s1">// globstar match (meaning it's the first time THIS globstar</span><span class="s3">\n        </span><span class="s1">// has traversed a symlink), then we follow it. Otherwise, stop.</span><span class="s3">\n        </span><span class="s1">if (</span><span class="s3">\n          </span><span class="s1">!t.isSymbolicLink() ||</span><span class="s3">\n          </span><span class="s1">this.follow ||</span><span class="s3">\n          </span><span class="s1">pattern.checkFollowGlobstar()</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">this.subwalks.add(t, pattern)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const rp = rest?.pattern()</span><span class="s3">\n        </span><span class="s1">const rrest = rest?.rest()</span><span class="s3">\n        </span><span class="s1">if (!rest || ((rp === '' || rp === '.') &amp;&amp; !rrest)) {</span><span class="s3">\n          </span><span class="s1">// only HAS to be a dir if it ends in **/ or **/.</span><span class="s3">\n          </span><span class="s1">// but ending in ** will match files as well.</span><span class="s3">\n          </span><span class="s1">this.matches.add(t, absolute, rp === '' || rp === '.')</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">if (rp === '..') {</span><span class="s3">\n            </span><span class="s1">// this would mean you're matching **/.. at the fs root,</span><span class="s3">\n            </span><span class="s1">// and no thanks, I'm not gonna test that specific case.</span><span class="s3">\n            </span><span class="s1">/* c8 ignore start */</span><span class="s3">\n            </span><span class="s1">const tp = t.parent || t</span><span class="s3">\n            </span><span class="s1">/* c8 ignore stop */</span><span class="s3">\n            </span><span class="s1">if (!rrest) this.matches.add(tp, absolute, true)</span><span class="s3">\n            </span><span class="s1">else if (!this.hasWalkedCache.hasWalked(tp, rrest)) {</span><span class="s3">\n              </span><span class="s1">this.subwalks.add(tp, rrest)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else if (p instanceof RegExp) {</span><span class="s3">\n        </span><span class="s1">this.subwalks.add(t, pattern)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return this</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">subwalkTargets(): Path[] {</span><span class="s3">\n    </span><span class="s1">return this.subwalks.keys()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">child() {</span><span class="s3">\n    </span><span class="s1">return new Processor(this.opts, this.hasWalkedCache)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// return a new Processor containing the subwalks for each</span><span class="s3">\n  </span><span class="s1">// child entry, and a set of matches, and</span><span class="s3">\n  </span><span class="s1">// a hasWalkedCache that's a copy of this one</span><span class="s3">\n  </span><span class="s1">// then we're going to call</span><span class="s3">\n  </span><span class="s1">filterEntries(parent: Path, entries: Path[]): Processor {</span><span class="s3">\n    </span><span class="s1">const patterns = this.subwalks.get(parent)</span><span class="s3">\n    </span><span class="s1">// put matches and entry walks into the results processor</span><span class="s3">\n    </span><span class="s1">const results = this.child()</span><span class="s3">\n    </span><span class="s1">for (const e of entries) {</span><span class="s3">\n      </span><span class="s1">for (const pattern of patterns) {</span><span class="s3">\n        </span><span class="s1">const absolute = pattern.isAbsolute()</span><span class="s3">\n        </span><span class="s1">const p = pattern.pattern()</span><span class="s3">\n        </span><span class="s1">const rest = pattern.rest()</span><span class="s3">\n        </span><span class="s1">if (p === GLOBSTAR) {</span><span class="s3">\n          </span><span class="s1">results.testGlobstar(e, pattern, rest, absolute)</span><span class="s3">\n        </span><span class="s1">} else if (p instanceof RegExp) {</span><span class="s3">\n          </span><span class="s1">results.testRegExp(e, p, rest, absolute)</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">results.testString(e, p, rest, absolute)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return results</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">testGlobstar(</span><span class="s3">\n    </span><span class="s1">e: Path,</span><span class="s3">\n    </span><span class="s1">pattern: Pattern,</span><span class="s3">\n    </span><span class="s1">rest: Pattern | null,</span><span class="s3">\n    </span><span class="s1">absolute: boolean,</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">if (this.dot || !e.name.startsWith('.')) {</span><span class="s3">\n      </span><span class="s1">if (!pattern.hasMore()) {</span><span class="s3">\n        </span><span class="s1">this.matches.add(e, absolute, false)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (e.canReaddir()) {</span><span class="s3">\n        </span><span class="s1">// if we're in follow mode or it's not a symlink, just keep</span><span class="s3">\n        </span><span class="s1">// testing the same pattern. If there's more after the globstar,</span><span class="s3">\n        </span><span class="s1">// then this symlink consumes the globstar. If not, then we can</span><span class="s3">\n        </span><span class="s1">// follow at most ONE symlink along the way, so we mark it, which</span><span class="s3">\n        </span><span class="s1">// also checks to ensure that it wasn't already marked.</span><span class="s3">\n        </span><span class="s1">if (this.follow || !e.isSymbolicLink()) {</span><span class="s3">\n          </span><span class="s1">this.subwalks.add(e, pattern)</span><span class="s3">\n        </span><span class="s1">} else if (e.isSymbolicLink()) {</span><span class="s3">\n          </span><span class="s1">if (rest &amp;&amp; pattern.checkFollowGlobstar()) {</span><span class="s3">\n            </span><span class="s1">this.subwalks.add(e, rest)</span><span class="s3">\n          </span><span class="s1">} else if (pattern.markFollowGlobstar()) {</span><span class="s3">\n            </span><span class="s1">this.subwalks.add(e, pattern)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// if the NEXT thing matches this entry, then also add</span><span class="s3">\n    </span><span class="s1">// the rest.</span><span class="s3">\n    </span><span class="s1">if (rest) {</span><span class="s3">\n      </span><span class="s1">const rp = rest.pattern()</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">typeof rp === 'string' &amp;&amp;</span><span class="s3">\n        </span><span class="s1">// dots and empty were handled already</span><span class="s3">\n        </span><span class="s1">rp !== '..' &amp;&amp;</span><span class="s3">\n        </span><span class="s1">rp !== '' &amp;&amp;</span><span class="s3">\n        </span><span class="s1">rp !== '.'</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">this.testString(e, rp, rest.rest(), absolute)</span><span class="s3">\n      </span><span class="s1">} else if (rp === '..') {</span><span class="s3">\n        </span><span class="s1">/* c8 ignore start */</span><span class="s3">\n        </span><span class="s1">const ep = e.parent || e</span><span class="s3">\n        </span><span class="s1">/* c8 ignore stop */</span><span class="s3">\n        </span><span class="s1">this.subwalks.add(ep, rest)</span><span class="s3">\n      </span><span class="s1">} else if (rp instanceof RegExp) {</span><span class="s3">\n        </span><span class="s1">this.testRegExp(e, rp, rest.rest(), absolute)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">testRegExp(</span><span class="s3">\n    </span><span class="s1">e: Path,</span><span class="s3">\n    </span><span class="s1">p: MMRegExp,</span><span class="s3">\n    </span><span class="s1">rest: Pattern | null,</span><span class="s3">\n    </span><span class="s1">absolute: boolean,</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">if (!p.test(e.name)) return</span><span class="s3">\n    </span><span class="s1">if (!rest) {</span><span class="s3">\n      </span><span class="s1">this.matches.add(e, absolute, false)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">this.subwalks.add(e, rest)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">testString(e: Path, p: string, rest: Pattern | null, absolute: boolean) {</span><span class="s3">\n    </span><span class="s1">// should never happen?</span><span class="s3">\n    </span><span class="s1">if (!e.isNamed(p)) return</span><span class="s3">\n    </span><span class="s1">if (!rest) {</span><span class="s3">\n      </span><span class="s1">this.matches.add(e, absolute, false)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">this.subwalks.add(e, rest)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">]}</span></pre>
</body>
</html>