<html>
<head>
<title>removeTypeDuplicates.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
removeTypeDuplicates.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_index&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;getQualifiedName&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;isIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;isThisExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;right&quot;</span><span class="s0">,</span><span class="s1">&quot;left&quot;</span><span class="s0">,</span><span class="s1">&quot;removeTypeDuplicates&quot;</span><span class="s0">,</span><span class="s1">&quot;nodesIn&quot;</span><span class="s0">,</span><span class="s1">&quot;nodes&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;from&quot;</span><span class="s0">,</span><span class="s1">&quot;generics&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;bases&quot;</span><span class="s0">,</span><span class="s1">&quot;typeGroups&quot;</span><span class="s0">,</span><span class="s1">&quot;Set&quot;</span><span class="s0">,</span><span class="s1">&quot;types&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;includes&quot;</span><span class="s0">,</span><span class="s1">&quot;isTSAnyKeyword&quot;</span><span class="s0">,</span><span class="s1">&quot;isTSBaseType&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;isTSUnionType&quot;</span><span class="s0">,</span><span class="s1">&quot;has&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;add&quot;</span><span class="s0">,</span><span class="s1">&quot;typeArgumentsKey&quot;</span><span class="s0">,</span><span class="s1">&quot;isTSTypeReference&quot;</span><span class="s0">,</span><span class="s1">&quot;typeArguments&quot;</span><span class="s0">,</span><span class="s1">&quot;typeName&quot;</span><span class="s0">,</span><span class="s1">&quot;existing&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;existingTypeArguments&quot;</span><span class="s0">,</span><span class="s1">&quot;params&quot;</span><span class="s0">,</span><span class="s1">&quot;baseType&quot;</span><span class="s0">,</span><span class="s1">&quot;genericName&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../src/modifications/typescript/removeTypeDuplicates.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import {</span><span class="s3">\n  </span><span class="s1">isIdentifier,</span><span class="s3">\n  </span><span class="s1">isThisExpression,</span><span class="s3">\n  </span><span class="s1">isTSAnyKeyword,</span><span class="s3">\n  </span><span class="s1">isTSTypeReference,</span><span class="s3">\n  </span><span class="s1">isTSUnionType,</span><span class="s3">\n  </span><span class="s1">isTSBaseType,</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">../../validators/generated/index.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type * as t from </span><span class="s3">\&quot;</span><span class="s1">../../index.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">function getQualifiedName(node: t.TSTypeReference[</span><span class="s3">\&quot;</span><span class="s1">typeName</span><span class="s3">\&quot;</span><span class="s1">]): string {</span><span class="s3">\n  </span><span class="s1">return isIdentifier(node)</span><span class="s3">\n    </span><span class="s1">? node.name</span><span class="s3">\n    </span><span class="s1">: isThisExpression(node)</span><span class="s3">\n      </span><span class="s1">? </span><span class="s3">\&quot;</span><span class="s1">this</span><span class="s3">\&quot;\n      </span><span class="s1">: `${node.right.name}.${getQualifiedName(node.left)}`;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Dedupe type annotations.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function removeTypeDuplicates(</span><span class="s3">\n  </span><span class="s1">nodesIn: ReadonlyArray&lt;t.TSType&gt;,</span><span class="s3">\n</span><span class="s1">): Array&lt;t.TSType&gt; {</span><span class="s3">\n  </span><span class="s1">const nodes = Array.from(nodesIn);</span><span class="s3">\n\n  </span><span class="s1">const generics = new Map&lt;string, t.TSTypeReference&gt;();</span><span class="s3">\n  </span><span class="s1">const bases = new Map&lt;t.TSBaseType[</span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">], t.TSBaseType&gt;();</span><span class="s3">\n\n  </span><span class="s1">// store union type groups to circular references</span><span class="s3">\n  </span><span class="s1">const typeGroups = new Set&lt;t.TSType[]&gt;();</span><span class="s3">\n\n  </span><span class="s1">const types: t.TSType[] = [];</span><span class="s3">\n\n  </span><span class="s1">for (let i = 0; i &lt; nodes.length; i++) {</span><span class="s3">\n    </span><span class="s1">const node = nodes[i];</span><span class="s3">\n    </span><span class="s1">if (!node) continue;</span><span class="s3">\n\n    </span><span class="s1">// detect duplicates</span><span class="s3">\n    </span><span class="s1">if (types.includes(node)) {</span><span class="s3">\n      </span><span class="s1">continue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// this type matches anything</span><span class="s3">\n    </span><span class="s1">if (isTSAnyKeyword(node)) {</span><span class="s3">\n      </span><span class="s1">return [node];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Analogue of FlowBaseAnnotation</span><span class="s3">\n    </span><span class="s1">if (isTSBaseType(node)) {</span><span class="s3">\n      </span><span class="s1">bases.set(node.type, node);</span><span class="s3">\n      </span><span class="s1">continue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (isTSUnionType(node)) {</span><span class="s3">\n      </span><span class="s1">if (!typeGroups.has(node.types)) {</span><span class="s3">\n        </span><span class="s1">nodes.push(...node.types);</span><span class="s3">\n        </span><span class="s1">typeGroups.add(node.types);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">continue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// todo: support merging tuples: number[]</span><span class="s3">\n    </span><span class="s1">const typeArgumentsKey = process.env.BABEL_8_BREAKING</span><span class="s3">\n      </span><span class="s1">? </span><span class="s3">\&quot;</span><span class="s1">typeArguments</span><span class="s3">\&quot;\n      </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">typeParameters</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">// @ts-ignore(Babel 7 vs Babel 8) Babel 8 AST</span><span class="s3">\n    </span><span class="s1">if (isTSTypeReference(node) &amp;&amp; node[typeArgumentsKey]) {</span><span class="s3">\n      </span><span class="s1">// @ts-ignore(Babel 7 vs Babel 8) Babel 8 AST</span><span class="s3">\n      </span><span class="s1">const typeArguments = node[typeArgumentsKey];</span><span class="s3">\n      </span><span class="s1">const name = getQualifiedName(node.typeName);</span><span class="s3">\n\n      </span><span class="s1">if (generics.has(name)) {</span><span class="s3">\n        </span><span class="s1">let existing: t.TypeScript = generics.get(name);</span><span class="s3">\n        </span><span class="s1">// @ts-ignore(Babel 7 vs Babel 8) Babel 8 AST</span><span class="s3">\n        </span><span class="s1">const existingTypeArguments = existing[typeArgumentsKey];</span><span class="s3">\n        </span><span class="s1">if (existingTypeArguments) {</span><span class="s3">\n          </span><span class="s1">existingTypeArguments.params.push(...typeArguments.params);</span><span class="s3">\n          </span><span class="s1">existingTypeArguments.params = removeTypeDuplicates(</span><span class="s3">\n            </span><span class="s1">existingTypeArguments.params,</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">existing = typeArguments;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">generics.set(name, node);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">continue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">types.push(node);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// add back in bases</span><span class="s3">\n  </span><span class="s1">for (const [, baseType] of bases) {</span><span class="s3">\n    </span><span class="s1">types.push(baseType);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// add back in generics</span><span class="s3">\n  </span><span class="s1">for (const [, genericName] of generics) {</span><span class="s3">\n    </span><span class="s1">types.push(genericName);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return types;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[]}</span></pre>
</body>
</html>