<html>
<head>
<title>renamer.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
renamer.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;t&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;_t&quot;</span><span class="s0">,</span><span class="s1">&quot;_traverseNode&quot;</span><span class="s0">,</span><span class="s1">&quot;_visitors&quot;</span><span class="s0">,</span><span class="s1">&quot;_context&quot;</span><span class="s0">,</span><span class="s1">&quot;getAssignmentIdentifiers&quot;</span><span class="s0">,</span><span class="s1">&quot;renameVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;ReferencedIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;state&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;oldName&quot;</span><span class="s0">,</span><span class="s1">&quot;newName&quot;</span><span class="s0">,</span><span class="s1">&quot;Scope&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;scope&quot;</span><span class="s0">,</span><span class="s1">&quot;bindingIdentifierEquals&quot;</span><span class="s0">,</span><span class="s1">&quot;binding&quot;</span><span class="s0">,</span><span class="s1">&quot;identifier&quot;</span><span class="s0">,</span><span class="s1">&quot;skip&quot;</span><span class="s0">,</span><span class="s1">&quot;isMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;requeueComputedKeyAndDecorators&quot;</span><span class="s0">,</span><span class="s1">&quot;call&quot;</span><span class="s0">,</span><span class="s1">&quot;ObjectProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;shorthand&quot;</span><span class="s0">,</span><span class="s1">&quot;getBindingIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;_node$extra&quot;</span><span class="s0">,</span><span class="s1">&quot;extra&quot;</span><span class="s0">,</span><span class="s1">&quot;AssignmentExpression|Declaration|VariableDeclarator&quot;</span><span class="s0">,</span><span class="s1">&quot;isVariableDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;ids&quot;</span><span class="s0">,</span><span class="s1">&quot;isAssignmentExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;getOuterBindingIdentifiers&quot;</span><span class="s0">,</span><span class="s1">&quot;Renamer&quot;</span><span class="s0">,</span><span class="s1">&quot;constructor&quot;</span><span class="s0">,</span><span class="s1">&quot;maybeConvertFromExportDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;parentDeclar&quot;</span><span class="s0">,</span><span class="s1">&quot;maybeExportDeclar&quot;</span><span class="s0">,</span><span class="s1">&quot;parentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;isExportDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;isExportDefaultDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;declaration&quot;</span><span class="s0">,</span><span class="s1">&quot;isDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;id&quot;</span><span class="s0">,</span><span class="s1">&quot;isExportAllDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;splitExportDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;maybeConvertFromClassFunctionDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;maybeConvertFromClassFunctionExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;rename&quot;</span><span class="s0">,</span><span class="s1">&quot;find&quot;</span><span class="s0">,</span><span class="s1">&quot;isFunctionExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isClassExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;bindingIds&quot;</span><span class="s0">,</span><span class="s1">&quot;blockToTraverse&quot;</span><span class="s0">,</span><span class="s1">&quot;arguments&quot;</span><span class="s0">,</span><span class="s1">&quot;block&quot;</span><span class="s0">,</span><span class="s1">&quot;skipKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;discriminant&quot;</span><span class="s0">,</span><span class="s1">&quot;computed&quot;</span><span class="s0">,</span><span class="s1">&quot;isObjectMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;decorators&quot;</span><span class="s0">,</span><span class="s1">&quot;traverseNode&quot;</span><span class="s0">,</span><span class="s1">&quot;explode&quot;</span><span class="s0">,</span><span class="s1">&quot;removeOwnBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;bindings&quot;</span><span class="s0">,</span><span class="s1">&quot;exports&quot;</span><span class="s0">,</span><span class="s1">&quot;default&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../src/scope/lib/renamer.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type Binding from </span><span class="s3">\&quot;</span><span class="s1">../binding.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import * as t from </span><span class="s3">\&quot;</span><span class="s1">@babel/types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { NodePath, Visitor } from </span><span class="s3">\&quot;</span><span class="s1">../../index.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { traverseNode } from </span><span class="s3">\&quot;</span><span class="s1">../../traverse-node.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { explode } from </span><span class="s3">\&quot;</span><span class="s1">../../visitors.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { getAssignmentIdentifiers, type Identifier } from </span><span class="s3">\&quot;</span><span class="s1">@babel/types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { requeueComputedKeyAndDecorators } from </span><span class="s3">\&quot;</span><span class="s1">../../path/context.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">const renameVisitor: Visitor&lt;Renamer&gt; = {</span><span class="s3">\n  </span><span class="s1">ReferencedIdentifier({ node }, state) {</span><span class="s3">\n    </span><span class="s1">if (node.name === state.oldName) {</span><span class="s3">\n      </span><span class="s1">node.name = state.newName;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">Scope(path, state) {</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">!path.scope.bindingIdentifierEquals(</span><span class="s3">\n        </span><span class="s1">state.oldName,</span><span class="s3">\n        </span><span class="s1">state.binding.identifier,</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">path.skip();</span><span class="s3">\n      </span><span class="s1">if (path.isMethod()) {</span><span class="s3">\n        </span><span class="s1">if (</span><span class="s3">\n          </span><span class="s1">!process.env.BABEL_8_BREAKING &amp;&amp;</span><span class="s3">\n          </span><span class="s1">!path.requeueComputedKeyAndDecorators</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">// See https://github.com/babel/babel/issues/16694</span><span class="s3">\n          </span><span class="s1">requeueComputedKeyAndDecorators.call(path);</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">path.requeueComputedKeyAndDecorators();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">ObjectProperty({ node, scope }, state) {</span><span class="s3">\n    </span><span class="s1">const { name } = node.key as Identifier;</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">node.shorthand &amp;&amp;</span><span class="s3">\n      </span><span class="s1">// In destructuring the identifier is already renamed by the</span><span class="s3">\n      </span><span class="s1">// AssignmentExpression|Declaration|VariableDeclarator visitor,</span><span class="s3">\n      </span><span class="s1">// while in object literals it's renamed later by the</span><span class="s3">\n      </span><span class="s1">// ReferencedIdentifier visitor.</span><span class="s3">\n      </span><span class="s1">(name === state.oldName || name === state.newName) &amp;&amp;</span><span class="s3">\n      </span><span class="s1">// Ignore shadowed bindings</span><span class="s3">\n      </span><span class="s1">scope.getBindingIdentifier(name) === state.binding.identifier</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">node.shorthand = false;</span><span class="s3">\n      </span><span class="s1">if (!process.env.BABEL_8_BREAKING) {</span><span class="s3">\n        </span><span class="s1">if (node.extra?.shorthand) node.extra.shorthand = false;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  \&quot;</span><span class="s1">AssignmentExpression|Declaration|VariableDeclarator</span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\n    </span><span class="s1">path: NodePath&lt;</span><span class="s3">\n      </span><span class="s1">t.AssignmentExpression | t.Declaration | t.VariableDeclarator</span><span class="s3">\n    </span><span class="s1">&gt;,</span><span class="s3">\n    </span><span class="s1">state,</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">if (path.isVariableDeclaration()) return;</span><span class="s3">\n    </span><span class="s1">const ids = path.isAssignmentExpression()</span><span class="s3">\n      </span><span class="s1">? // See https://github.com/babel/babel/issues/16694</span><span class="s3">\n        </span><span class="s1">getAssignmentIdentifiers(path.node)</span><span class="s3">\n      </span><span class="s1">: path.getOuterBindingIdentifiers();</span><span class="s3">\n\n    </span><span class="s1">for (const name in ids) {</span><span class="s3">\n      </span><span class="s1">if (name === state.oldName) ids[name].name = state.newName;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export default class Renamer {</span><span class="s3">\n  </span><span class="s1">constructor(binding: Binding, oldName: string, newName: string) {</span><span class="s3">\n    </span><span class="s1">this.newName = newName;</span><span class="s3">\n    </span><span class="s1">this.oldName = oldName;</span><span class="s3">\n    </span><span class="s1">this.binding = binding;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">declare oldName: string;</span><span class="s3">\n  </span><span class="s1">declare newName: string;</span><span class="s3">\n  </span><span class="s1">declare binding: Binding;</span><span class="s3">\n\n  </span><span class="s1">maybeConvertFromExportDeclaration(parentDeclar: NodePath) {</span><span class="s3">\n    </span><span class="s1">const maybeExportDeclar = parentDeclar.parentPath;</span><span class="s3">\n\n    </span><span class="s1">if (!maybeExportDeclar.isExportDeclaration()) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (maybeExportDeclar.isExportDefaultDeclaration()) {</span><span class="s3">\n      </span><span class="s1">const { declaration } = maybeExportDeclar.node;</span><span class="s3">\n      </span><span class="s1">if (t.isDeclaration(declaration) &amp;&amp; !declaration.id) {</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (maybeExportDeclar.isExportAllDeclaration()) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">maybeExportDeclar.splitExportDeclaration();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">maybeConvertFromClassFunctionDeclaration(path: NodePath) {</span><span class="s3">\n    </span><span class="s1">return path; // TODO</span><span class="s3">\n\n    </span><span class="s1">// // retain the `name` of a class/function declaration</span><span class="s3">\n\n    </span><span class="s1">// if (!path.isFunctionDeclaration() &amp;&amp; !path.isClassDeclaration()) return;</span><span class="s3">\n    </span><span class="s1">// if (this.binding.kind !== </span><span class="s3">\&quot;</span><span class="s1">hoisted</span><span class="s3">\&quot;</span><span class="s1">) return;</span><span class="s3">\n\n    </span><span class="s1">// path.node.id = identifier(this.oldName);</span><span class="s3">\n    </span><span class="s1">// path.node._blockHoist = 3;</span><span class="s3">\n\n    </span><span class="s1">// path.replaceWith(</span><span class="s3">\n    </span><span class="s1">//   variableDeclaration(</span><span class="s3">\&quot;</span><span class="s1">let</span><span class="s3">\&quot;</span><span class="s1">, [</span><span class="s3">\n    </span><span class="s1">//     variableDeclarator(identifier(this.newName), toExpression(path.node)),</span><span class="s3">\n    </span><span class="s1">//   ]),</span><span class="s3">\n    </span><span class="s1">// );</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">maybeConvertFromClassFunctionExpression(path: NodePath) {</span><span class="s3">\n    </span><span class="s1">return path; // TODO</span><span class="s3">\n\n    </span><span class="s1">// // retain the `name` of a class/function expression</span><span class="s3">\n\n    </span><span class="s1">// if (!path.isFunctionExpression() &amp;&amp; !path.isClassExpression()) return;</span><span class="s3">\n    </span><span class="s1">// if (this.binding.kind !== </span><span class="s3">\&quot;</span><span class="s1">local</span><span class="s3">\&quot;</span><span class="s1">) return;</span><span class="s3">\n\n    </span><span class="s1">// path.node.id = identifier(this.oldName);</span><span class="s3">\n\n    </span><span class="s1">// this.binding.scope.parent.push({</span><span class="s3">\n    </span><span class="s1">//   id: identifier(this.newName),</span><span class="s3">\n    </span><span class="s1">// });</span><span class="s3">\n\n    </span><span class="s1">// path.replaceWith(</span><span class="s3">\n    </span><span class="s1">//   assignmentExpression(</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">, identifier(this.newName), path.node),</span><span class="s3">\n    </span><span class="s1">// );</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">rename(/* Babel 7 - block?: t.Pattern | t.Scopable */) {</span><span class="s3">\n    </span><span class="s1">const { binding, oldName, newName } = this;</span><span class="s3">\n    </span><span class="s1">const { scope, path } = binding;</span><span class="s3">\n\n    </span><span class="s1">const parentDeclar = path.find(</span><span class="s3">\n      </span><span class="s1">path =&gt;</span><span class="s3">\n        </span><span class="s1">path.isDeclaration() ||</span><span class="s3">\n        </span><span class="s1">path.isFunctionExpression() ||</span><span class="s3">\n        </span><span class="s1">path.isClassExpression(),</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">if (parentDeclar) {</span><span class="s3">\n      </span><span class="s1">const bindingIds = parentDeclar.getOuterBindingIdentifiers();</span><span class="s3">\n      </span><span class="s1">if (bindingIds[oldName] === binding.identifier) {</span><span class="s3">\n        </span><span class="s1">// When we are renaming an exported identifier, we need to ensure that</span><span class="s3">\n        </span><span class="s1">// the exported binding keeps the old name.</span><span class="s3">\n        </span><span class="s1">this.maybeConvertFromExportDeclaration(parentDeclar);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const blockToTraverse = process.env.BABEL_8_BREAKING</span><span class="s3">\n      </span><span class="s1">? scope.block</span><span class="s3">\n      </span><span class="s1">: (arguments[0] as t.Pattern | t.Scopable) || scope.block;</span><span class="s3">\n\n    </span><span class="s1">// When blockToTraverse is a SwitchStatement, the discriminant</span><span class="s3">\n    </span><span class="s1">// is not part of the current scope and thus should be skipped.</span><span class="s3">\n\n    </span><span class="s1">// const foo = {</span><span class="s3">\n    </span><span class="s1">//   get [x]() {</span><span class="s3">\n    </span><span class="s1">//     return x;</span><span class="s3">\n    </span><span class="s1">//   },</span><span class="s3">\n    </span><span class="s1">// };</span><span class="s3">\n    </span><span class="s1">const skipKeys: Record&lt;string, true&gt; = { discriminant: true };</span><span class="s3">\n    </span><span class="s1">if (t.isMethod(blockToTraverse)) {</span><span class="s3">\n      </span><span class="s1">if (blockToTraverse.computed) {</span><span class="s3">\n        </span><span class="s1">skipKeys.key = true;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (!t.isObjectMethod(blockToTraverse)) {</span><span class="s3">\n        </span><span class="s1">skipKeys.decorators = true;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">traverseNode(</span><span class="s3">\n      </span><span class="s1">blockToTraverse,</span><span class="s3">\n      </span><span class="s1">explode(renameVisitor),</span><span class="s3">\n      </span><span class="s1">scope,</span><span class="s3">\n      </span><span class="s1">this,</span><span class="s3">\n      </span><span class="s1">scope.path,</span><span class="s3">\n      </span><span class="s1">skipKeys,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n\n    </span><span class="s1">if (process.env.BABEL_8_BREAKING) {</span><span class="s3">\n      </span><span class="s1">scope.removeOwnBinding(oldName);</span><span class="s3">\n      </span><span class="s1">scope.bindings[newName] = binding;</span><span class="s3">\n      </span><span class="s1">this.binding.identifier.name = newName;</span><span class="s3">\n    </span><span class="s1">} else if (!arguments[0]) {</span><span class="s3">\n      </span><span class="s1">scope.removeOwnBinding(oldName);</span><span class="s3">\n      </span><span class="s1">scope.bindings[newName] = binding;</span><span class="s3">\n      </span><span class="s1">this.binding.identifier.name = newName;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (parentDeclar) {</span><span class="s3">\n      </span><span class="s1">this.maybeConvertFromClassFunctionDeclaration(path);</span><span class="s3">\n      </span><span class="s1">this.maybeConvertFromClassFunctionExpression(path);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[]}</span></pre>
</body>
</html>