<html>
<head>
<title>replacement.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
replacement.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_codeFrame&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;_index&quot;</span><span class="s0">,</span><span class="s1">&quot;_index2&quot;</span><span class="s0">,</span><span class="s1">&quot;_cache&quot;</span><span class="s0">,</span><span class="s1">&quot;_modification&quot;</span><span class="s0">,</span><span class="s1">&quot;_parser&quot;</span><span class="s0">,</span><span class="s1">&quot;_t&quot;</span><span class="s0">,</span><span class="s1">&quot;_context&quot;</span><span class="s0">,</span><span class="s1">&quot;FUNCTION_TYPES&quot;</span><span class="s0">,</span><span class="s1">&quot;arrowFunctionExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;assignmentExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;awaitExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;blockStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;buildUndefinedNode&quot;</span><span class="s0">,</span><span class="s1">&quot;callExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;cloneNode&quot;</span><span class="s0">,</span><span class="s1">&quot;conditionalExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;expressionStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;getBindingIdentifiers&quot;</span><span class="s0">,</span><span class="s1">&quot;identifier&quot;</span><span class="s0">,</span><span class="s1">&quot;inheritLeadingComments&quot;</span><span class="s0">,</span><span class="s1">&quot;inheritTrailingComments&quot;</span><span class="s0">,</span><span class="s1">&quot;inheritsComments&quot;</span><span class="s0">,</span><span class="s1">&quot;isBlockStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;isEmptyStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;isExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isExpressionStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;isIfStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;isProgram&quot;</span><span class="s0">,</span><span class="s1">&quot;isStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;isVariableDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;removeComments&quot;</span><span class="s0">,</span><span class="s1">&quot;returnStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;sequenceExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;validate&quot;</span><span class="s0">,</span><span class="s1">&quot;yieldExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceWithMultiple&quot;</span><span class="s0">,</span><span class="s1">&quot;nodes&quot;</span><span class="s0">,</span><span class="s1">&quot;_getCachedPaths&quot;</span><span class="s0">,</span><span class="s1">&quot;resync&quot;</span><span class="s0">,</span><span class="s1">&quot;call&quot;</span><span class="s0">,</span><span class="s1">&quot;_verifyNodeList&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;getCachedPaths&quot;</span><span class="s0">,</span><span class="s1">&quot;hub&quot;</span><span class="s0">,</span><span class="s1">&quot;parent&quot;</span><span class="s0">,</span><span class="s1">&quot;delete&quot;</span><span class="s0">,</span><span class="s1">&quot;container&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;paths&quot;</span><span class="s0">,</span><span class="s1">&quot;insertAfter&quot;</span><span class="s0">,</span><span class="s1">&quot;requeue&quot;</span><span class="s0">,</span><span class="s1">&quot;remove&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceWithSourceString&quot;</span><span class="s0">,</span><span class="s1">&quot;replacement&quot;</span><span class="s0">,</span><span class="s1">&quot;ast&quot;</span><span class="s0">,</span><span class="s1">&quot;parse&quot;</span><span class="s0">,</span><span class="s1">&quot;err&quot;</span><span class="s0">,</span><span class="s1">&quot;loc&quot;</span><span class="s0">,</span><span class="s1">&quot;message&quot;</span><span class="s0">,</span><span class="s1">&quot;codeFrameColumns&quot;</span><span class="s0">,</span><span class="s1">&quot;start&quot;</span><span class="s0">,</span><span class="s1">&quot;line&quot;</span><span class="s0">,</span><span class="s1">&quot;column&quot;</span><span class="s0">,</span><span class="s1">&quot;code&quot;</span><span class="s0">,</span><span class="s1">&quot;expressionAST&quot;</span><span class="s0">,</span><span class="s1">&quot;program&quot;</span><span class="s0">,</span><span class="s1">&quot;body&quot;</span><span class="s0">,</span><span class="s1">&quot;expression&quot;</span><span class="s0">,</span><span class="s1">&quot;traverse&quot;</span><span class="s0">,</span><span class="s1">&quot;removeProperties&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceWith&quot;</span><span class="s0">,</span><span class="s1">&quot;replacementPath&quot;</span><span class="s0">,</span><span class="s1">&quot;removed&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;NodePath&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;isArray&quot;</span><span class="s0">,</span><span class="s1">&quot;nodePath&quot;</span><span class="s0">,</span><span class="s1">&quot;isNodeType&quot;</span><span class="s0">,</span><span class="s1">&quot;canHaveVariableDeclarationOrExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;canSwapBetweenExpressionAndStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;parentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;isExportDefaultDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceExpressionWithStatements&quot;</span><span class="s0">,</span><span class="s1">&quot;oldNode&quot;</span><span class="s0">,</span><span class="s1">&quot;_replaceWith&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;setScope&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;_getCachedPaths2&quot;</span><span class="s0">,</span><span class="s1">&quot;ReferenceError&quot;</span><span class="s0">,</span><span class="s1">&quot;inList&quot;</span><span class="s0">,</span><span class="s1">&quot;debug&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;declars&quot;</span><span class="s0">,</span><span class="s1">&quot;nodesAsSingleExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;gatherSequenceExpressions&quot;</span><span class="s0">,</span><span class="s1">&quot;id&quot;</span><span class="s0">,</span><span class="s1">&quot;scope&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;functionParent&quot;</span><span class="s0">,</span><span class="s1">&quot;getFunctionParent&quot;</span><span class="s0">,</span><span class="s1">&quot;isParentAsync&quot;</span><span class="s0">,</span><span class="s1">&quot;async&quot;</span><span class="s0">,</span><span class="s1">&quot;isParentGenerator&quot;</span><span class="s0">,</span><span class="s1">&quot;generator&quot;</span><span class="s0">,</span><span class="s1">&quot;callee&quot;</span><span class="s0">,</span><span class="s1">&quot;hoistVariables&quot;</span><span class="s0">,</span><span class="s1">&quot;completionRecords&quot;</span><span class="s0">,</span><span class="s1">&quot;getCompletionRecords&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;loop&quot;</span><span class="s0">,</span><span class="s1">&quot;findParent&quot;</span><span class="s0">,</span><span class="s1">&quot;isLoop&quot;</span><span class="s0">,</span><span class="s1">&quot;uid&quot;</span><span class="s0">,</span><span class="s1">&quot;getData&quot;</span><span class="s0">,</span><span class="s1">&quot;generateDeclaredUidIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;pushContainer&quot;</span><span class="s0">,</span><span class="s1">&quot;setData&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;arrowFunctionToExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;newCallee&quot;</span><span class="s0">,</span><span class="s1">&quot;needToAwaitFunction&quot;</span><span class="s0">,</span><span class="s1">&quot;hasType&quot;</span><span class="s0">,</span><span class="s1">&quot;needToYieldFunction&quot;</span><span class="s0">,</span><span class="s1">&quot;exprs&quot;</span><span class="s0">,</span><span class="s1">&quot;ensureLastUndefined&quot;</span><span class="s0">,</span><span class="s1">&quot;kind&quot;</span><span class="s0">,</span><span class="s1">&quot;declar&quot;</span><span class="s0">,</span><span class="s1">&quot;declarations&quot;</span><span class="s0">,</span><span class="s1">&quot;bindings&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;keys&quot;</span><span class="s0">,</span><span class="s1">&quot;init&quot;</span><span class="s0">,</span><span class="s1">&quot;consequent&quot;</span><span class="s0">,</span><span class="s1">&quot;alternate&quot;</span><span class="s0">,</span><span class="s1">&quot;test&quot;</span><span class="s0">,</span><span class="s1">&quot;indexOf&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceInline&quot;</span><span class="s0">,</span><span class="s1">&quot;_containerInsertAfter&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../src/path/replacement.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;// This file contains methods responsible for replacing a node with another.</span><span class="s3">\n\n</span><span class="s1">import { codeFrameColumns } from </span><span class="s3">\&quot;</span><span class="s1">@babel/code-frame</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import traverse from </span><span class="s3">\&quot;</span><span class="s1">../index.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import NodePath from </span><span class="s3">\&quot;</span><span class="s1">./index.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { getCachedPaths } from </span><span class="s3">\&quot;</span><span class="s1">../cache.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { _verifyNodeList, _containerInsertAfter } from </span><span class="s3">\&quot;</span><span class="s1">./modification.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { parse } from </span><span class="s3">\&quot;</span><span class="s1">@babel/parser</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">FUNCTION_TYPES,</span><span class="s3">\n  </span><span class="s1">arrowFunctionExpression,</span><span class="s3">\n  </span><span class="s1">assignmentExpression,</span><span class="s3">\n  </span><span class="s1">awaitExpression,</span><span class="s3">\n  </span><span class="s1">blockStatement,</span><span class="s3">\n  </span><span class="s1">buildUndefinedNode,</span><span class="s3">\n  </span><span class="s1">callExpression,</span><span class="s3">\n  </span><span class="s1">cloneNode,</span><span class="s3">\n  </span><span class="s1">conditionalExpression,</span><span class="s3">\n  </span><span class="s1">expressionStatement,</span><span class="s3">\n  </span><span class="s1">getBindingIdentifiers,</span><span class="s3">\n  </span><span class="s1">identifier,</span><span class="s3">\n  </span><span class="s1">inheritLeadingComments,</span><span class="s3">\n  </span><span class="s1">inheritTrailingComments,</span><span class="s3">\n  </span><span class="s1">inheritsComments,</span><span class="s3">\n  </span><span class="s1">isBlockStatement,</span><span class="s3">\n  </span><span class="s1">isEmptyStatement,</span><span class="s3">\n  </span><span class="s1">isExpression,</span><span class="s3">\n  </span><span class="s1">isExpressionStatement,</span><span class="s3">\n  </span><span class="s1">isIfStatement,</span><span class="s3">\n  </span><span class="s1">isProgram,</span><span class="s3">\n  </span><span class="s1">isStatement,</span><span class="s3">\n  </span><span class="s1">isVariableDeclaration,</span><span class="s3">\n  </span><span class="s1">removeComments,</span><span class="s3">\n  </span><span class="s1">returnStatement,</span><span class="s3">\n  </span><span class="s1">sequenceExpression,</span><span class="s3">\n  </span><span class="s1">validate,</span><span class="s3">\n  </span><span class="s1">yieldExpression,</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">@babel/types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type * as t from </span><span class="s3">\&quot;</span><span class="s1">@babel/types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { resync, setScope } from </span><span class="s3">\&quot;</span><span class="s1">./context.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Replace a node with an array of multiple. This method performs the following steps:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*  - Inherit the comments of first provided node with that of the current node.</span><span class="s3">\n </span><span class="s1">*  - Insert the provided nodes after the current node.</span><span class="s3">\n </span><span class="s1">*  - Remove the current node.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">export function replaceWithMultiple(</span><span class="s3">\n  </span><span class="s1">this: NodePath,</span><span class="s3">\n  </span><span class="s1">nodes: t.Node | t.Node[],</span><span class="s3">\n</span><span class="s1">): NodePath[] {</span><span class="s3">\n  </span><span class="s1">resync.call(this);</span><span class="s3">\n\n  </span><span class="s1">nodes = _verifyNodeList.call(this, nodes);</span><span class="s3">\n  </span><span class="s1">inheritLeadingComments(nodes[0], this.node);</span><span class="s3">\n  </span><span class="s1">inheritTrailingComments(nodes[nodes.length - 1], this.node);</span><span class="s3">\n  </span><span class="s1">getCachedPaths(this.hub, this.parent)?.delete(this.node);</span><span class="s3">\n  </span><span class="s1">this.node =</span><span class="s3">\n    </span><span class="s1">// @ts-expect-error this.key must present in this.container</span><span class="s3">\n    </span><span class="s1">this.container[this.key] = null;</span><span class="s3">\n  </span><span class="s1">const paths = this.insertAfter(nodes);</span><span class="s3">\n\n  </span><span class="s1">if (this.node) {</span><span class="s3">\n    </span><span class="s1">this.requeue();</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">this.remove();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return paths;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Parse a string as an expression and replace the current node with the result.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* NOTE: This is typically not a good idea to use. Building source strings when</span><span class="s3">\n </span><span class="s1">* transforming ASTs is an antipattern and SHOULD NOT be encouraged. Even if it's</span><span class="s3">\n </span><span class="s1">* easier to use, your transforms will be extremely brittle.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">export function replaceWithSourceString(this: NodePath, replacement: string) {</span><span class="s3">\n  </span><span class="s1">resync.call(this);</span><span class="s3">\n  </span><span class="s1">let ast: t.File;</span><span class="s3">\n\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">replacement = `(${replacement})`;</span><span class="s3">\n    </span><span class="s1">ast = parse(replacement);</span><span class="s3">\n  </span><span class="s1">} catch (err) {</span><span class="s3">\n    </span><span class="s1">const loc = err.loc;</span><span class="s3">\n    </span><span class="s1">if (loc) {</span><span class="s3">\n      </span><span class="s1">err.message +=</span><span class="s3">\n        \&quot; </span><span class="s1">- make sure this is an expression.</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n        </span><span class="s1">codeFrameColumns(replacement, {</span><span class="s3">\n          </span><span class="s1">start: {</span><span class="s3">\n            </span><span class="s1">line: loc.line,</span><span class="s3">\n            </span><span class="s1">column: loc.column + 1,</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">err.code = </span><span class="s3">\&quot;</span><span class="s1">BABEL_REPLACE_SOURCE_ERROR</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">throw err;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const expressionAST = (ast.program.body[0] as t.ExpressionStatement)</span><span class="s3">\n    </span><span class="s1">.expression;</span><span class="s3">\n  </span><span class="s1">traverse.removeProperties(expressionAST);</span><span class="s3">\n  </span><span class="s1">return this.replaceWith(expressionAST);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Replace the current node with another.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function replaceWith&lt;R extends t.Node&gt;(</span><span class="s3">\n  </span><span class="s1">this: NodePath,</span><span class="s3">\n  </span><span class="s1">replacementPath: R,</span><span class="s3">\n</span><span class="s1">): [NodePath&lt;R&gt;];</span><span class="s3">\n</span><span class="s1">export function replaceWith&lt;R extends NodePath&gt;(</span><span class="s3">\n  </span><span class="s1">this: NodePath,</span><span class="s3">\n  </span><span class="s1">replacementPath: R,</span><span class="s3">\n</span><span class="s1">): [R];</span><span class="s3">\n</span><span class="s1">export function replaceWith(</span><span class="s3">\n  </span><span class="s1">this: NodePath,</span><span class="s3">\n  </span><span class="s1">replacementPath: t.Node | NodePath,</span><span class="s3">\n</span><span class="s1">): [NodePath] {</span><span class="s3">\n  </span><span class="s1">resync.call(this);</span><span class="s3">\n\n  </span><span class="s1">if (this.removed) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">You can't replace this node, we've already removed it</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let replacement: t.Node =</span><span class="s3">\n    </span><span class="s1">replacementPath instanceof NodePath</span><span class="s3">\n      </span><span class="s1">? replacementPath.node</span><span class="s3">\n      </span><span class="s1">: replacementPath;</span><span class="s3">\n\n  </span><span class="s1">if (!replacement) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      \&quot;</span><span class="s1">You passed `path.replaceWith()` a falsy node, use `path.remove()` instead</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (this.node === replacement) {</span><span class="s3">\n    </span><span class="s1">return [this];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (this.isProgram() &amp;&amp; !isProgram(replacement)) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      \&quot;</span><span class="s1">You can only replace a Program root node with another Program node</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (Array.isArray(replacement)) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      \&quot;</span><span class="s1">Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (typeof replacement === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      \&quot;</span><span class="s1">Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let nodePath = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n\n  </span><span class="s1">if (this.isNodeType(</span><span class="s3">\&quot;</span><span class="s1">Statement</span><span class="s3">\&quot;</span><span class="s1">) &amp;&amp; isExpression(replacement)) {</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">!this.canHaveVariableDeclarationOrExpression() &amp;&amp;</span><span class="s3">\n      </span><span class="s1">!this.canSwapBetweenExpressionAndStatement(replacement) &amp;&amp;</span><span class="s3">\n      </span><span class="s1">!this.parentPath.isExportDefaultDeclaration()</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">// replacing a statement with an expression so wrap it in an expression statement</span><span class="s3">\n      </span><span class="s1">replacement = expressionStatement(replacement);</span><span class="s3">\n      </span><span class="s1">nodePath = </span><span class="s3">\&quot;</span><span class="s1">expression</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (this.isNodeType(</span><span class="s3">\&quot;</span><span class="s1">Expression</span><span class="s3">\&quot;</span><span class="s1">) &amp;&amp; isStatement(replacement)) {</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">!this.canHaveVariableDeclarationOrExpression() &amp;&amp;</span><span class="s3">\n      </span><span class="s1">!this.canSwapBetweenExpressionAndStatement(replacement)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">// replacing an expression with a statement so let's explode it</span><span class="s3">\n      </span><span class="s1">return this.replaceExpressionWithStatements([replacement]) as [NodePath];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const oldNode = this.node;</span><span class="s3">\n  </span><span class="s1">if (oldNode) {</span><span class="s3">\n    </span><span class="s1">inheritsComments(replacement, oldNode);</span><span class="s3">\n    </span><span class="s1">removeComments(oldNode);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// replace the node</span><span class="s3">\n  </span><span class="s1">_replaceWith.call(this, replacement);</span><span class="s3">\n  </span><span class="s1">this.type = replacement.type;</span><span class="s3">\n\n  </span><span class="s1">// potentially create new scope</span><span class="s3">\n  </span><span class="s1">setScope.call(this);</span><span class="s3">\n\n  </span><span class="s1">// requeue for visiting</span><span class="s3">\n  </span><span class="s1">this.requeue();</span><span class="s3">\n\n  </span><span class="s1">return [nodePath ? this.get(nodePath) : this];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function _replaceWith(this: NodePath, node: t.Node) {</span><span class="s3">\n  </span><span class="s1">if (!this.container) {</span><span class="s3">\n    </span><span class="s1">throw new ReferenceError(</span><span class="s3">\&quot;</span><span class="s1">Container is falsy</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (this.inList) {</span><span class="s3">\n    </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts): check if validate accepts a numeric key</span><span class="s3">\n    </span><span class="s1">validate(this.parent, this.key, [node]);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">validate(this.parent, this.key as string, node);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">this.debug(`Replace with ${node?.type}`);</span><span class="s3">\n  </span><span class="s1">getCachedPaths(this.hub, this.parent)?.set(node, this).delete(this.node);</span><span class="s3">\n\n  </span><span class="s1">this.node =</span><span class="s3">\n    </span><span class="s1">// @ts-expect-error this.key must present in this.container</span><span class="s3">\n    </span><span class="s1">this.container[this.key] = node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This method takes an array of statements nodes and then explodes it</span><span class="s3">\n </span><span class="s1">* into expressions. This method retains completion records which is</span><span class="s3">\n </span><span class="s1">* extremely important to retain original semantics.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">export function replaceExpressionWithStatements(</span><span class="s3">\n  </span><span class="s1">this: NodePath,</span><span class="s3">\n  </span><span class="s1">nodes: Array&lt;t.Statement&gt;,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">resync.call(this);</span><span class="s3">\n\n  </span><span class="s1">const declars: t.Identifier[] = [];</span><span class="s3">\n  </span><span class="s1">const nodesAsSingleExpression = gatherSequenceExpressions(nodes, declars);</span><span class="s3">\n  </span><span class="s1">if (nodesAsSingleExpression) {</span><span class="s3">\n    </span><span class="s1">for (const id of declars) this.scope.push({ id });</span><span class="s3">\n    </span><span class="s1">return this.replaceWith(nodesAsSingleExpression)[0].get(</span><span class="s3">\&quot;</span><span class="s1">expressions</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const functionParent = this.getFunctionParent();</span><span class="s3">\n  </span><span class="s1">const isParentAsync = functionParent?.node.async;</span><span class="s3">\n  </span><span class="s1">const isParentGenerator = functionParent?.node.generator;</span><span class="s3">\n\n  </span><span class="s1">const container = arrowFunctionExpression([], blockStatement(nodes));</span><span class="s3">\n\n  </span><span class="s1">this.replaceWith(callExpression(container, []));</span><span class="s3">\n  </span><span class="s1">// replaceWith changes the type of </span><span class="s3">\&quot;</span><span class="s1">this</span><span class="s3">\&quot;</span><span class="s1">, but it isn't trackable by TS</span><span class="s3">\n  </span><span class="s1">type ThisType = NodePath&lt;</span><span class="s3">\n    </span><span class="s1">t.CallExpression &amp; {</span><span class="s3">\n      </span><span class="s1">callee: t.ArrowFunctionExpression &amp; { body: t.BlockStatement };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">&gt;;</span><span class="s3">\n\n  </span><span class="s1">// hoist variable declaration in do block</span><span class="s3">\n  </span><span class="s1">// `(do { var x = 1; x;})` -&gt; `var x; (() =&gt; { x = 1; return x; })()`</span><span class="s3">\n  </span><span class="s1">const callee = (this as ThisType).get(</span><span class="s3">\&quot;</span><span class="s1">callee</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">callee.get(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">).scope.hoistVariables(id =&gt; this.scope.push({ id }));</span><span class="s3">\n\n  </span><span class="s1">// add implicit returns to all ending expression statements</span><span class="s3">\n  </span><span class="s1">const completionRecords: Array&lt;NodePath&gt; = callee.getCompletionRecords();</span><span class="s3">\n  </span><span class="s1">for (const path of completionRecords) {</span><span class="s3">\n    </span><span class="s1">if (!path.isExpressionStatement()) continue;</span><span class="s3">\n\n    </span><span class="s1">const loop = path.findParent(path =&gt; path.isLoop());</span><span class="s3">\n    </span><span class="s1">if (loop) {</span><span class="s3">\n      </span><span class="s1">let uid = loop.getData(</span><span class="s3">\&quot;</span><span class="s1">expressionReplacementReturnUid</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n      </span><span class="s1">if (!uid) {</span><span class="s3">\n        </span><span class="s1">uid = callee.scope.generateDeclaredUidIdentifier(</span><span class="s3">\&quot;</span><span class="s1">ret</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">callee</span><span class="s3">\n          </span><span class="s1">.get(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">.pushContainer(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">, returnStatement(cloneNode(uid)));</span><span class="s3">\n        </span><span class="s1">loop.setData(</span><span class="s3">\&quot;</span><span class="s1">expressionReplacementReturnUid</span><span class="s3">\&quot;</span><span class="s1">, uid);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">uid = identifier(uid.name);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">path</span><span class="s3">\n        </span><span class="s1">.get(</span><span class="s3">\&quot;</span><span class="s1">expression</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">.replaceWith(</span><span class="s3">\n          </span><span class="s1">assignmentExpression(</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">, cloneNode(uid), path.node.expression),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">path.replaceWith(returnStatement(path.node.expression));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// This is an IIFE, so we don't need to worry about the noNewArrows assumption</span><span class="s3">\n  </span><span class="s1">callee.arrowFunctionToExpression();</span><span class="s3">\n  </span><span class="s1">// Fixme: we can not `assert this is NodePath&lt;t.FunctionExpression&gt;` in `arrowFunctionToExpression`</span><span class="s3">\n  </span><span class="s1">// because it is not a class method known at compile time.</span><span class="s3">\n  </span><span class="s1">const newCallee = callee as unknown as NodePath&lt;t.FunctionExpression&gt;;</span><span class="s3">\n\n  </span><span class="s1">// (() =&gt; await xxx)() -&gt; await (async () =&gt; await xxx)();</span><span class="s3">\n  </span><span class="s1">const needToAwaitFunction =</span><span class="s3">\n    </span><span class="s1">isParentAsync &amp;&amp;</span><span class="s3">\n    </span><span class="s1">traverse.hasType(</span><span class="s3">\n      </span><span class="s1">(this.get(</span><span class="s3">\&quot;</span><span class="s1">callee.body</span><span class="s3">\&quot;</span><span class="s1">) as NodePath&lt;t.BlockStatement&gt;).node,</span><span class="s3">\n      \&quot;</span><span class="s1">AwaitExpression</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">FUNCTION_TYPES,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">const needToYieldFunction =</span><span class="s3">\n    </span><span class="s1">isParentGenerator &amp;&amp;</span><span class="s3">\n    </span><span class="s1">traverse.hasType(</span><span class="s3">\n      </span><span class="s1">(this.get(</span><span class="s3">\&quot;</span><span class="s1">callee.body</span><span class="s3">\&quot;</span><span class="s1">) as NodePath&lt;t.BlockStatement&gt;).node,</span><span class="s3">\n      \&quot;</span><span class="s1">YieldExpression</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">FUNCTION_TYPES,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">if (needToAwaitFunction) {</span><span class="s3">\n    </span><span class="s1">newCallee.set(</span><span class="s3">\&quot;</span><span class="s1">async</span><span class="s3">\&quot;</span><span class="s1">, true);</span><span class="s3">\n    </span><span class="s1">// yield* will await the generator return result</span><span class="s3">\n    </span><span class="s1">if (!needToYieldFunction) {</span><span class="s3">\n      </span><span class="s1">this.replaceWith(awaitExpression((this as ThisType).node));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (needToYieldFunction) {</span><span class="s3">\n    </span><span class="s1">newCallee.set(</span><span class="s3">\&quot;</span><span class="s1">generator</span><span class="s3">\&quot;</span><span class="s1">, true);</span><span class="s3">\n    </span><span class="s1">this.replaceWith(yieldExpression((this as ThisType).node, true));</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return newCallee.get(</span><span class="s3">\&quot;</span><span class="s1">body.body</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function gatherSequenceExpressions(</span><span class="s3">\n  </span><span class="s1">nodes: ReadonlyArray&lt;t.Node&gt;,</span><span class="s3">\n  </span><span class="s1">declars: Array&lt;t.Identifier&gt;,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const exprs: t.Expression[] = [];</span><span class="s3">\n  </span><span class="s1">let ensureLastUndefined = true;</span><span class="s3">\n\n  </span><span class="s1">for (const node of nodes) {</span><span class="s3">\n    </span><span class="s1">// if we encounter emptyStatement before a non-emptyStatement</span><span class="s3">\n    </span><span class="s1">// we want to disregard that</span><span class="s3">\n    </span><span class="s1">if (!isEmptyStatement(node)) {</span><span class="s3">\n      </span><span class="s1">ensureLastUndefined = false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (isExpression(node)) {</span><span class="s3">\n      </span><span class="s1">exprs.push(node);</span><span class="s3">\n    </span><span class="s1">} else if (isExpressionStatement(node)) {</span><span class="s3">\n      </span><span class="s1">exprs.push(node.expression);</span><span class="s3">\n    </span><span class="s1">} else if (isVariableDeclaration(node)) {</span><span class="s3">\n      </span><span class="s1">if (node.kind !== </span><span class="s3">\&quot;</span><span class="s1">var</span><span class="s3">\&quot;</span><span class="s1">) return; // bailed</span><span class="s3">\n\n      </span><span class="s1">for (const declar of node.declarations) {</span><span class="s3">\n        </span><span class="s1">const bindings = getBindingIdentifiers(declar);</span><span class="s3">\n        </span><span class="s1">for (const key of Object.keys(bindings)) {</span><span class="s3">\n          </span><span class="s1">declars.push(cloneNode(bindings[key]));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (declar.init) {</span><span class="s3">\n          </span><span class="s1">exprs.push(assignmentExpression(</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">, declar.id, declar.init));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">ensureLastUndefined = true;</span><span class="s3">\n    </span><span class="s1">} else if (isIfStatement(node)) {</span><span class="s3">\n      </span><span class="s1">const consequent = node.consequent</span><span class="s3">\n        </span><span class="s1">? gatherSequenceExpressions([node.consequent], declars)</span><span class="s3">\n        </span><span class="s1">: buildUndefinedNode();</span><span class="s3">\n      </span><span class="s1">const alternate = node.alternate</span><span class="s3">\n        </span><span class="s1">? gatherSequenceExpressions([node.alternate], declars)</span><span class="s3">\n        </span><span class="s1">: buildUndefinedNode();</span><span class="s3">\n      </span><span class="s1">if (!consequent || !alternate) return; // bailed</span><span class="s3">\n\n      </span><span class="s1">exprs.push(conditionalExpression(node.test, consequent, alternate));</span><span class="s3">\n    </span><span class="s1">} else if (isBlockStatement(node)) {</span><span class="s3">\n      </span><span class="s1">const body = gatherSequenceExpressions(node.body, declars);</span><span class="s3">\n      </span><span class="s1">if (!body) return; // bailed</span><span class="s3">\n\n      </span><span class="s1">exprs.push(body);</span><span class="s3">\n    </span><span class="s1">} else if (isEmptyStatement(node)) {</span><span class="s3">\n      </span><span class="s1">// empty statement so ensure the last item is undefined if we're last</span><span class="s3">\n      </span><span class="s1">// checks if emptyStatement is first</span><span class="s3">\n      </span><span class="s1">if (nodes.indexOf(node) === 0) {</span><span class="s3">\n        </span><span class="s1">ensureLastUndefined = true;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// bailed, we can't turn this statement into an expression</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (ensureLastUndefined) exprs.push(buildUndefinedNode());</span><span class="s3">\n\n  </span><span class="s1">if (exprs.length === 1) {</span><span class="s3">\n    </span><span class="s1">return exprs[0];</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return sequenceExpression(exprs);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function replaceInline(this: NodePath, nodes: t.Node | Array&lt;t.Node&gt;) {</span><span class="s3">\n  </span><span class="s1">resync.call(this);</span><span class="s3">\n\n  </span><span class="s1">if (Array.isArray(nodes)) {</span><span class="s3">\n    </span><span class="s1">if (Array.isArray(this.container)) {</span><span class="s3">\n      </span><span class="s1">nodes = _verifyNodeList.call(this, nodes);</span><span class="s3">\n      </span><span class="s1">const paths = _containerInsertAfter.call(this, nodes);</span><span class="s3">\n      </span><span class="s1">this.remove();</span><span class="s3">\n      </span><span class="s1">return paths;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">return this.replaceWithMultiple(nodes);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return this.replaceWith(nodes);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[]}</span></pre>
</body>
</html>