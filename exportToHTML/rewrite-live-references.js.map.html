<html>
<head>
<title>rewrite-live-references.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
rewrite-live-references.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_core&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;isInType&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;parent&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;parentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;exportKind&quot;</span><span class="s0">,</span><span class="s1">&quot;isStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;isExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;rewriteLiveReferences&quot;</span><span class="s0">,</span><span class="s1">&quot;programPath&quot;</span><span class="s0">,</span><span class="s1">&quot;metadata&quot;</span><span class="s0">,</span><span class="s1">&quot;wrapReference&quot;</span><span class="s0">,</span><span class="s1">&quot;imported&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;exported&quot;</span><span class="s0">,</span><span class="s1">&quot;requeueInParent&quot;</span><span class="s0">,</span><span class="s1">&quot;requeue&quot;</span><span class="s0">,</span><span class="s1">&quot;source&quot;</span><span class="s0">,</span><span class="s1">&quot;data&quot;</span><span class="s0">,</span><span class="s1">&quot;localName&quot;</span><span class="s0">,</span><span class="s1">&quot;importName&quot;</span><span class="s0">,</span><span class="s1">&quot;imports&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;importsNamespace&quot;</span><span class="s0">,</span><span class="s1">&quot;local&quot;</span><span class="s0">,</span><span class="s1">&quot;exportMeta&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">,</span><span class="s1">&quot;rewriteBindingInitVisitorState&quot;</span><span class="s0">,</span><span class="s1">&quot;scope&quot;</span><span class="s0">,</span><span class="s1">&quot;traverse&quot;</span><span class="s0">,</span><span class="s1">&quot;rewriteBindingInitVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;rewriteReferencesVisitorState&quot;</span><span class="s0">,</span><span class="s1">&quot;seen&quot;</span><span class="s0">,</span><span class="s1">&quot;WeakSet&quot;</span><span class="s0">,</span><span class="s1">&quot;buildImportReference&quot;</span><span class="s0">,</span><span class="s1">&quot;identNode&quot;</span><span class="s0">,</span><span class="s1">&quot;meta&quot;</span><span class="s0">,</span><span class="s1">&quot;referenced&quot;</span><span class="s0">,</span><span class="s1">&quot;wrap&quot;</span><span class="s0">,</span><span class="s1">&quot;_wrapReference&quot;</span><span class="s0">,</span><span class="s1">&quot;namespace&quot;</span><span class="s0">,</span><span class="s1">&quot;t&quot;</span><span class="s0">,</span><span class="s1">&quot;identifier&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;_wrapReference2&quot;</span><span class="s0">,</span><span class="s1">&quot;interop&quot;</span><span class="s0">,</span><span class="s1">&quot;computed&quot;</span><span class="s0">,</span><span class="s1">&quot;stringSpecifiers&quot;</span><span class="s0">,</span><span class="s1">&quot;has&quot;</span><span class="s0">,</span><span class="s1">&quot;memberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;stringLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;rewriteReferencesVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;Scope&quot;</span><span class="s0">,</span><span class="s1">&quot;skip&quot;</span><span class="s0">,</span><span class="s1">&quot;ClassDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;id&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;exportNames&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;statement&quot;</span><span class="s0">,</span><span class="s1">&quot;expressionStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;buildBindingExportAssignmentExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;_blockHoist&quot;</span><span class="s0">,</span><span class="s1">&quot;insertAfter&quot;</span><span class="s0">,</span><span class="s1">&quot;VariableDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;isVar&quot;</span><span class="s0">,</span><span class="s1">&quot;kind&quot;</span><span class="s0">,</span><span class="s1">&quot;decl&quot;</span><span class="s0">,</span><span class="s1">&quot;init&quot;</span><span class="s0">,</span><span class="s1">&quot;isIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;isArrowFunctionExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isFunctionExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isClassExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;buildUndefinedNode&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;keys&quot;</span><span class="s0">,</span><span class="s1">&quot;getOuterBindingIdentifiers&quot;</span><span class="s0">,</span><span class="s1">&quot;localExpr&quot;</span><span class="s0">,</span><span class="s1">&quot;exportsObjectName&quot;</span><span class="s0">,</span><span class="s1">&quot;exportName&quot;</span><span class="s0">,</span><span class="s1">&quot;currentScope&quot;</span><span class="s0">,</span><span class="s1">&quot;hasOwnBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;rename&quot;</span><span class="s0">,</span><span class="s1">&quot;reduce&quot;</span><span class="s0">,</span><span class="s1">&quot;expr&quot;</span><span class="s0">,</span><span class="s1">&quot;assignmentExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;buildImportThrow&quot;</span><span class="s0">,</span><span class="s1">&quot;template&quot;</span><span class="s0">,</span><span class="s1">&quot;expression&quot;</span><span class="s0">,</span><span class="s1">&quot;ast&quot;</span><span class="s0">,</span><span class="s1">&quot;ReferencedIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;add&quot;</span><span class="s0">,</span><span class="s1">&quot;importData&quot;</span><span class="s0">,</span><span class="s1">&quot;buildCodeFrameError&quot;</span><span class="s0">,</span><span class="s1">&quot;localBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;getBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;rootBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;ref&quot;</span><span class="s0">,</span><span class="s1">&quot;loc&quot;</span><span class="s0">,</span><span class="s1">&quot;isCallExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;callee&quot;</span><span class="s0">,</span><span class="s1">&quot;isOptionalCallExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isTaggedTemplateExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;tag&quot;</span><span class="s0">,</span><span class="s1">&quot;isMemberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceWith&quot;</span><span class="s0">,</span><span class="s1">&quot;sequenceExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;numericLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;isJSXIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;object&quot;</span><span class="s0">,</span><span class="s1">&quot;property&quot;</span><span class="s0">,</span><span class="s1">&quot;jsxMemberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;jsxIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;UpdateExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;arg&quot;</span><span class="s0">,</span><span class="s1">&quot;update&quot;</span><span class="s0">,</span><span class="s1">&quot;exportedNames&quot;</span><span class="s0">,</span><span class="s1">&quot;operator&quot;</span><span class="s0">,</span><span class="s1">&quot;prefix&quot;</span><span class="s0">,</span><span class="s1">&quot;cloneNode&quot;</span><span class="s0">,</span><span class="s1">&quot;generateDeclaredUidIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;AssignmentExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;exit&quot;</span><span class="s0">,</span><span class="s1">&quot;left&quot;</span><span class="s0">,</span><span class="s1">&quot;assignment&quot;</span><span class="s0">,</span><span class="s1">&quot;right&quot;</span><span class="s0">,</span><span class="s1">&quot;newExpr&quot;</span><span class="s0">,</span><span class="s1">&quot;logicalExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;binaryExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;ids&quot;</span><span class="s0">,</span><span class="s1">&quot;programScopeIds&quot;</span><span class="s0">,</span><span class="s1">&quot;filter&quot;</span><span class="s0">,</span><span class="s1">&quot;find&quot;</span><span class="s0">,</span><span class="s1">&quot;items&quot;</span><span class="s0">,</span><span class="s1">&quot;forEach&quot;</span><span class="s0">,</span><span class="s1">&quot;isExpressionStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;ForXStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;programScope&quot;</span><span class="s0">,</span><span class="s1">&quot;isVariableDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;didTransformExport&quot;</span><span class="s0">,</span><span class="s1">&quot;importConstViolationName&quot;</span><span class="s0">,</span><span class="s1">&quot;loopBodyScope&quot;</span><span class="s0">,</span><span class="s1">&quot;ensureBlock&quot;</span><span class="s0">,</span><span class="s1">&quot;bodyPath&quot;</span><span class="s0">,</span><span class="s1">&quot;newLoopId&quot;</span><span class="s0">,</span><span class="s1">&quot;generateUidIdentifierBasedOnNode&quot;</span><span class="s0">,</span><span class="s1">&quot;variableDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;variableDeclarator&quot;</span><span class="s0">,</span><span class="s1">&quot;registerDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;unshiftContainer&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../src/rewrite-live-references.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { template, types as t } from </span><span class="s3">\&quot;</span><span class="s1">@babel/core</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { NodePath, Visitor, Scope } from </span><span class="s3">\&quot;</span><span class="s1">@babel/core</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">import type { ModuleMetadata } from </span><span class="s3">\&quot;</span><span class="s1">./normalize-and-load-metadata.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">interface RewriteReferencesVisitorState {</span><span class="s3">\n  </span><span class="s1">exported: Map&lt;any, any&gt;;</span><span class="s3">\n  </span><span class="s1">metadata: ModuleMetadata;</span><span class="s3">\n  </span><span class="s1">requeueInParent: (path: NodePath) =&gt; void;</span><span class="s3">\n  </span><span class="s1">scope: Scope;</span><span class="s3">\n  </span><span class="s1">imported: Map&lt;any, any&gt;;</span><span class="s3">\n  </span><span class="s1">buildImportReference: (</span><span class="s3">\n    </span><span class="s1">[source, importName, localName]: readonly [string, string, string],</span><span class="s3">\n    </span><span class="s1">identNode: t.Identifier | t.CallExpression | t.JSXIdentifier,</span><span class="s3">\n  </span><span class="s1">) =&gt; any;</span><span class="s3">\n  </span><span class="s1">seen: WeakSet&lt;object&gt;;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">interface RewriteBindingInitVisitorState {</span><span class="s3">\n  </span><span class="s1">exported: Map&lt;any, any&gt;;</span><span class="s3">\n  </span><span class="s1">metadata: ModuleMetadata;</span><span class="s3">\n  </span><span class="s1">requeueInParent: (path: NodePath) =&gt; void;</span><span class="s3">\n  </span><span class="s1">scope: Scope;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function isInType(path: NodePath) {</span><span class="s3">\n  </span><span class="s1">do {</span><span class="s3">\n    </span><span class="s1">switch (path.parent.type) {</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">TSTypeAnnotation</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">TSTypeAliasDeclaration</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">TSTypeReference</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">TypeAnnotation</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">TypeAlias</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ExportSpecifier</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">return (</span><span class="s3">\n          </span><span class="s1">(</span><span class="s3">\n            </span><span class="s1">path.parentPath.parent as</span><span class="s3">\n              </span><span class="s1">| t.ExportDefaultDeclaration</span><span class="s3">\n              </span><span class="s1">| t.ExportNamedDeclaration</span><span class="s3">\n          </span><span class="s1">).exportKind === </span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">default:</span><span class="s3">\n        </span><span class="s1">if (path.parentPath.isStatement() || path.parentPath.isExpression()) {</span><span class="s3">\n          </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} while ((path = path.parentPath));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default function rewriteLiveReferences(</span><span class="s3">\n  </span><span class="s1">programPath: NodePath&lt;t.Program&gt;,</span><span class="s3">\n  </span><span class="s1">metadata: ModuleMetadata,</span><span class="s3">\n  </span><span class="s1">wrapReference: (ref: t.Expression, payload: unknown) =&gt; null | t.Expression,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const imported = new Map();</span><span class="s3">\n  </span><span class="s1">const exported = new Map();</span><span class="s3">\n  </span><span class="s1">const requeueInParent = (path: NodePath) =&gt; {</span><span class="s3">\n    </span><span class="s1">// Manually re-queue `exports.default =` expressions so that the ES3</span><span class="s3">\n    </span><span class="s1">// transform has an opportunity to convert them. Ideally this would</span><span class="s3">\n    </span><span class="s1">// happen automatically from the replaceWith above. See #4140 for</span><span class="s3">\n    </span><span class="s1">// more info.</span><span class="s3">\n    </span><span class="s1">programPath.requeue(path);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">for (const [source, data] of metadata.source) {</span><span class="s3">\n    </span><span class="s1">for (const [localName, importName] of data.imports) {</span><span class="s3">\n      </span><span class="s1">imported.set(localName, [source, importName, null]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">for (const localName of data.importsNamespace) {</span><span class="s3">\n      </span><span class="s1">imported.set(localName, [source, null, localName]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">for (const [local, data] of metadata.local) {</span><span class="s3">\n    </span><span class="s1">let exportMeta = exported.get(local);</span><span class="s3">\n    </span><span class="s1">if (!exportMeta) {</span><span class="s3">\n      </span><span class="s1">exportMeta = [];</span><span class="s3">\n      </span><span class="s1">exported.set(local, exportMeta);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">exportMeta.push(...data.names);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Rewrite initialization of bindings to update exports.</span><span class="s3">\n  </span><span class="s1">const rewriteBindingInitVisitorState: RewriteBindingInitVisitorState = {</span><span class="s3">\n    </span><span class="s1">metadata,</span><span class="s3">\n    </span><span class="s1">requeueInParent,</span><span class="s3">\n    </span><span class="s1">scope: programPath.scope,</span><span class="s3">\n    </span><span class="s1">exported, // local name =&gt; exported name list</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">programPath.traverse(</span><span class="s3">\n    </span><span class="s1">// eslint-disable-next-line @typescript-eslint/no-use-before-define</span><span class="s3">\n    </span><span class="s1">rewriteBindingInitVisitor,</span><span class="s3">\n    </span><span class="s1">rewriteBindingInitVisitorState,</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n\n  </span><span class="s1">// Rewrite reads/writes from imports and exports to have the correct behavior.</span><span class="s3">\n  </span><span class="s1">const rewriteReferencesVisitorState: RewriteReferencesVisitorState = {</span><span class="s3">\n    </span><span class="s1">seen: new WeakSet(),</span><span class="s3">\n    </span><span class="s1">metadata,</span><span class="s3">\n    </span><span class="s1">requeueInParent,</span><span class="s3">\n    </span><span class="s1">scope: programPath.scope,</span><span class="s3">\n    </span><span class="s1">imported, // local / import</span><span class="s3">\n    </span><span class="s1">exported, // local name =&gt; exported name list</span><span class="s3">\n    </span><span class="s1">buildImportReference([source, importName, localName], identNode) {</span><span class="s3">\n      </span><span class="s1">const meta = metadata.source.get(source);</span><span class="s3">\n      </span><span class="s1">meta.referenced = true;</span><span class="s3">\n\n      </span><span class="s1">if (localName) {</span><span class="s3">\n        </span><span class="s1">if (meta.wrap) {</span><span class="s3">\n          </span><span class="s1">// @ts-expect-error Fixme: we should handle the case when identNode is a JSXIdentifier</span><span class="s3">\n          </span><span class="s1">identNode = wrapReference(identNode, meta.wrap) ?? identNode;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return identNode;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">let namespace: t.Expression = t.identifier(meta.name);</span><span class="s3">\n      </span><span class="s1">if (meta.wrap) {</span><span class="s3">\n        </span><span class="s1">namespace = wrapReference(namespace, meta.wrap) ?? namespace;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (importName === </span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; meta.interop === </span><span class="s3">\&quot;</span><span class="s1">node-default</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">return namespace;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const computed = metadata.stringSpecifiers.has(importName);</span><span class="s3">\n\n      </span><span class="s1">return t.memberExpression(</span><span class="s3">\n        </span><span class="s1">namespace,</span><span class="s3">\n        </span><span class="s1">computed ? t.stringLiteral(importName) : t.identifier(importName),</span><span class="s3">\n        </span><span class="s1">computed,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">// eslint-disable-next-line @typescript-eslint/no-use-before-define</span><span class="s3">\n  </span><span class="s1">programPath.traverse(rewriteReferencesVisitor, rewriteReferencesVisitorState);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A visitor to inject export update statements during binding initialization.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const rewriteBindingInitVisitor: Visitor&lt;RewriteBindingInitVisitorState&gt; = {</span><span class="s3">\n  </span><span class="s1">Scope(path) {</span><span class="s3">\n    </span><span class="s1">path.skip();</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">ClassDeclaration(path) {</span><span class="s3">\n    </span><span class="s1">const { requeueInParent, exported, metadata } = this;</span><span class="s3">\n\n    </span><span class="s1">const { id } = path.node;</span><span class="s3">\n    </span><span class="s1">if (!id) throw new Error(</span><span class="s3">\&quot;</span><span class="s1">Expected class to have a name</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">const localName = id.name;</span><span class="s3">\n\n    </span><span class="s1">const exportNames = exported.get(localName) || [];</span><span class="s3">\n    </span><span class="s1">if (exportNames.length &gt; 0) {</span><span class="s3">\n      </span><span class="s1">const statement = t.expressionStatement(</span><span class="s3">\n        </span><span class="s1">// eslint-disable-next-line @typescript-eslint/no-use-before-define</span><span class="s3">\n        </span><span class="s1">buildBindingExportAssignmentExpression(</span><span class="s3">\n          </span><span class="s1">metadata,</span><span class="s3">\n          </span><span class="s1">exportNames,</span><span class="s3">\n          </span><span class="s1">t.identifier(localName),</span><span class="s3">\n          </span><span class="s1">path.scope,</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts): avoid mutations</span><span class="s3">\n      </span><span class="s1">statement._blockHoist = path.node._blockHoist;</span><span class="s3">\n\n      </span><span class="s1">requeueInParent(path.insertAfter(statement)[0]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">VariableDeclaration(path) {</span><span class="s3">\n    </span><span class="s1">const { requeueInParent, exported, metadata } = this;</span><span class="s3">\n\n    </span><span class="s1">const isVar = path.node.kind === </span><span class="s3">\&quot;</span><span class="s1">var</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n    </span><span class="s1">for (const decl of path.get(</span><span class="s3">\&quot;</span><span class="s1">declarations</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n      </span><span class="s1">const { id } = decl.node;</span><span class="s3">\n      </span><span class="s1">let { init } = decl.node;</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">t.isIdentifier(id) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">exported.has(id.name) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">!t.isArrowFunctionExpression(init) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">(!t.isFunctionExpression(init) || init.id) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">(!t.isClassExpression(init) || init.id)</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">if (!init) {</span><span class="s3">\n          </span><span class="s1">if (isVar) {</span><span class="s3">\n            </span><span class="s1">// This variable might have already been assigned to, and the</span><span class="s3">\n            </span><span class="s1">// uninitalized declaration doesn't set it to `undefined` and does</span><span class="s3">\n            </span><span class="s1">// not updated the exported value.</span><span class="s3">\n            </span><span class="s1">continue;</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">init = path.scope.buildUndefinedNode();</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// eslint-disable-next-line @typescript-eslint/no-use-before-define</span><span class="s3">\n        </span><span class="s1">decl.node.init = buildBindingExportAssignmentExpression(</span><span class="s3">\n          </span><span class="s1">metadata,</span><span class="s3">\n          </span><span class="s1">exported.get(id.name),</span><span class="s3">\n          </span><span class="s1">init,</span><span class="s3">\n          </span><span class="s1">path.scope,</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">requeueInParent(decl.get(</span><span class="s3">\&quot;</span><span class="s1">init</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">for (const localName of Object.keys(</span><span class="s3">\n          </span><span class="s1">decl.getOuterBindingIdentifiers(),</span><span class="s3">\n        </span><span class="s1">)) {</span><span class="s3">\n          </span><span class="s1">if (exported.has(localName)) {</span><span class="s3">\n            </span><span class="s1">const statement = t.expressionStatement(</span><span class="s3">\n              </span><span class="s1">// eslint-disable-next-line @typescript-eslint/no-use-before-define</span><span class="s3">\n              </span><span class="s1">buildBindingExportAssignmentExpression(</span><span class="s3">\n                </span><span class="s1">metadata,</span><span class="s3">\n                </span><span class="s1">exported.get(localName),</span><span class="s3">\n                </span><span class="s1">t.identifier(localName),</span><span class="s3">\n                </span><span class="s1">path.scope,</span><span class="s3">\n              </span><span class="s1">),</span><span class="s3">\n            </span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts): avoid mutations</span><span class="s3">\n            </span><span class="s1">statement._blockHoist = path.node._blockHoist;</span><span class="s3">\n\n            </span><span class="s1">requeueInParent(path.insertAfter(statement)[0]);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">const buildBindingExportAssignmentExpression = (</span><span class="s3">\n  </span><span class="s1">metadata: ModuleMetadata,</span><span class="s3">\n  </span><span class="s1">exportNames: string[],</span><span class="s3">\n  </span><span class="s1">localExpr: t.Expression,</span><span class="s3">\n  </span><span class="s1">scope: Scope,</span><span class="s3">\n</span><span class="s1">) =&gt; {</span><span class="s3">\n  </span><span class="s1">const exportsObjectName = metadata.exportName;</span><span class="s3">\n  </span><span class="s1">for (</span><span class="s3">\n    </span><span class="s1">let currentScope = scope;</span><span class="s3">\n    </span><span class="s1">currentScope != null;</span><span class="s3">\n    </span><span class="s1">currentScope = currentScope.parent</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">if (currentScope.hasOwnBinding(exportsObjectName)) {</span><span class="s3">\n      </span><span class="s1">currentScope.rename(exportsObjectName);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return (exportNames || []).reduce((expr, exportName) =&gt; {</span><span class="s3">\n    </span><span class="s1">// class Foo {} export { Foo, Foo as Bar };</span><span class="s3">\n    </span><span class="s1">// as</span><span class="s3">\n    </span><span class="s1">// class Foo {} exports.Foo = exports.Bar = Foo;</span><span class="s3">\n    </span><span class="s1">const { stringSpecifiers } = metadata;</span><span class="s3">\n    </span><span class="s1">const computed = stringSpecifiers.has(exportName);</span><span class="s3">\n    </span><span class="s1">return t.assignmentExpression(</span><span class="s3">\n      \&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">t.memberExpression(</span><span class="s3">\n        </span><span class="s1">t.identifier(exportsObjectName),</span><span class="s3">\n        </span><span class="s1">computed ? t.stringLiteral(exportName) : t.identifier(exportName),</span><span class="s3">\n        </span><span class="s1">/* computed */ computed,</span><span class="s3">\n      </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">expr,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}, localExpr);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">const buildImportThrow = (localName: string) =&gt; {</span><span class="s3">\n  </span><span class="s1">return template.expression.ast`</span><span class="s3">\n    </span><span class="s1">(function() {</span><span class="s3">\n      </span><span class="s1">throw new Error('</span><span class="s3">\&quot;</span><span class="s1">' + '${localName}' + '</span><span class="s3">\&quot; </span><span class="s1">is read-only.');</span><span class="s3">\n    </span><span class="s1">})()</span><span class="s3">\n  </span><span class="s1">`;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">const rewriteReferencesVisitor: Visitor&lt;RewriteReferencesVisitorState&gt; = {</span><span class="s3">\n  </span><span class="s1">ReferencedIdentifier(path) {</span><span class="s3">\n    </span><span class="s1">const { seen, buildImportReference, scope, imported, requeueInParent } =</span><span class="s3">\n      </span><span class="s1">this;</span><span class="s3">\n    </span><span class="s1">if (seen.has(path.node)) return;</span><span class="s3">\n    </span><span class="s1">seen.add(path.node);</span><span class="s3">\n\n    </span><span class="s1">const localName = path.node.name;</span><span class="s3">\n\n    </span><span class="s1">const importData = imported.get(localName);</span><span class="s3">\n    </span><span class="s1">if (importData) {</span><span class="s3">\n      </span><span class="s1">if (isInType(path)) {</span><span class="s3">\n        </span><span class="s1">throw path.buildCodeFrameError(</span><span class="s3">\n          </span><span class="s1">`Cannot transform the imported binding </span><span class="s3">\&quot;</span><span class="s1">${localName}</span><span class="s3">\&quot; </span><span class="s1">since it's also used in a type annotation. ` +</span><span class="s3">\n            </span><span class="s1">`Please strip type annotations using @babel/preset-typescript or @babel/preset-flow.`,</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const localBinding = path.scope.getBinding(localName);</span><span class="s3">\n      </span><span class="s1">const rootBinding = scope.getBinding(localName);</span><span class="s3">\n\n      </span><span class="s1">// redeclared in this scope</span><span class="s3">\n      </span><span class="s1">if (rootBinding !== localBinding) return;</span><span class="s3">\n\n      </span><span class="s1">const ref = buildImportReference(importData, path.node);</span><span class="s3">\n\n      </span><span class="s1">// Preserve the binding location so that sourcemaps are nicer.</span><span class="s3">\n      </span><span class="s1">ref.loc = path.node.loc;</span><span class="s3">\n\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">(path.parentPath.isCallExpression({ callee: path.node }) ||</span><span class="s3">\n          </span><span class="s1">path.parentPath.isOptionalCallExpression({ callee: path.node }) ||</span><span class="s3">\n          </span><span class="s1">path.parentPath.isTaggedTemplateExpression({ tag: path.node })) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">t.isMemberExpression(ref)</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">path.replaceWith(t.sequenceExpression([t.numericLiteral(0), ref]));</span><span class="s3">\n      </span><span class="s1">} else if (path.isJSXIdentifier() &amp;&amp; t.isMemberExpression(ref)) {</span><span class="s3">\n        </span><span class="s1">const { object, property } = ref;</span><span class="s3">\n        </span><span class="s1">path.replaceWith(</span><span class="s3">\n          </span><span class="s1">t.jsxMemberExpression(</span><span class="s3">\n            </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts): possible bug `object` might not have a name</span><span class="s3">\n            </span><span class="s1">t.jsxIdentifier(object.name),</span><span class="s3">\n            </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts): possible bug `property` might not have a name</span><span class="s3">\n            </span><span class="s1">t.jsxIdentifier(property.name),</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">path.replaceWith(ref);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">requeueInParent(path);</span><span class="s3">\n\n      </span><span class="s1">// The path could have been replaced with an identifier that would</span><span class="s3">\n      </span><span class="s1">// otherwise be re-visited, so we skip processing its children.</span><span class="s3">\n      </span><span class="s1">path.skip();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">UpdateExpression(path) {</span><span class="s3">\n    </span><span class="s1">const {</span><span class="s3">\n      </span><span class="s1">scope,</span><span class="s3">\n      </span><span class="s1">seen,</span><span class="s3">\n      </span><span class="s1">imported,</span><span class="s3">\n      </span><span class="s1">exported,</span><span class="s3">\n      </span><span class="s1">requeueInParent,</span><span class="s3">\n      </span><span class="s1">buildImportReference,</span><span class="s3">\n    </span><span class="s1">} = this;</span><span class="s3">\n\n    </span><span class="s1">if (seen.has(path.node)) return;</span><span class="s3">\n\n    </span><span class="s1">seen.add(path.node);</span><span class="s3">\n\n    </span><span class="s1">const arg = path.get(</span><span class="s3">\&quot;</span><span class="s1">argument</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n    </span><span class="s1">// No change needed</span><span class="s3">\n    </span><span class="s1">if (arg.isMemberExpression()) return;</span><span class="s3">\n\n    </span><span class="s1">const update = path.node;</span><span class="s3">\n\n    </span><span class="s1">if (arg.isIdentifier()) {</span><span class="s3">\n      </span><span class="s1">const localName = arg.node.name;</span><span class="s3">\n\n      </span><span class="s1">// redeclared in this scope</span><span class="s3">\n      </span><span class="s1">if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const exportedNames = exported.get(localName);</span><span class="s3">\n      </span><span class="s1">const importData = imported.get(localName);</span><span class="s3">\n\n      </span><span class="s1">if (exportedNames?.length &gt; 0 || importData) {</span><span class="s3">\n        </span><span class="s1">if (importData) {</span><span class="s3">\n          </span><span class="s1">path.replaceWith(</span><span class="s3">\n            </span><span class="s1">t.assignmentExpression(</span><span class="s3">\n              </span><span class="s1">// eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion</span><span class="s3">\n              </span><span class="s1">(update.operator[0] + </span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">) as t.AssignmentExpression[</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n              </span><span class="s1">buildImportReference(importData, arg.node),</span><span class="s3">\n              </span><span class="s1">buildImportThrow(localName),</span><span class="s3">\n            </span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">} else if (update.prefix) {</span><span class="s3">\n          </span><span class="s1">// ++foo</span><span class="s3">\n          </span><span class="s1">// =&gt;   exports.foo = ++foo</span><span class="s3">\n          </span><span class="s1">path.replaceWith(</span><span class="s3">\n            </span><span class="s1">buildBindingExportAssignmentExpression(</span><span class="s3">\n              </span><span class="s1">this.metadata,</span><span class="s3">\n              </span><span class="s1">exportedNames,</span><span class="s3">\n              </span><span class="s1">t.cloneNode(update),</span><span class="s3">\n              </span><span class="s1">path.scope,</span><span class="s3">\n            </span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">// foo++</span><span class="s3">\n          </span><span class="s1">// =&gt;   (ref = i++, exports.i = i, ref)</span><span class="s3">\n          </span><span class="s1">const ref = scope.generateDeclaredUidIdentifier(localName);</span><span class="s3">\n\n          </span><span class="s1">path.replaceWith(</span><span class="s3">\n            </span><span class="s1">t.sequenceExpression([</span><span class="s3">\n              </span><span class="s1">t.assignmentExpression(</span><span class="s3">\n                \&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                </span><span class="s1">t.cloneNode(ref),</span><span class="s3">\n                </span><span class="s1">t.cloneNode(update),</span><span class="s3">\n              </span><span class="s1">),</span><span class="s3">\n              </span><span class="s1">buildBindingExportAssignmentExpression(</span><span class="s3">\n                </span><span class="s1">this.metadata,</span><span class="s3">\n                </span><span class="s1">exportedNames,</span><span class="s3">\n                </span><span class="s1">t.identifier(localName),</span><span class="s3">\n                </span><span class="s1">path.scope,</span><span class="s3">\n              </span><span class="s1">),</span><span class="s3">\n              </span><span class="s1">t.cloneNode(ref),</span><span class="s3">\n            </span><span class="s1">]),</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">requeueInParent(path);</span><span class="s3">\n    </span><span class="s1">path.skip();</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">AssignmentExpression: {</span><span class="s3">\n    </span><span class="s1">exit(path) {</span><span class="s3">\n      </span><span class="s1">const {</span><span class="s3">\n        </span><span class="s1">scope,</span><span class="s3">\n        </span><span class="s1">seen,</span><span class="s3">\n        </span><span class="s1">imported,</span><span class="s3">\n        </span><span class="s1">exported,</span><span class="s3">\n        </span><span class="s1">requeueInParent,</span><span class="s3">\n        </span><span class="s1">buildImportReference,</span><span class="s3">\n      </span><span class="s1">} = this;</span><span class="s3">\n\n      </span><span class="s1">if (seen.has(path.node)) return;</span><span class="s3">\n      </span><span class="s1">seen.add(path.node);</span><span class="s3">\n\n      </span><span class="s1">const left = path.get(</span><span class="s3">\&quot;</span><span class="s1">left</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n      </span><span class="s1">// No change needed</span><span class="s3">\n      </span><span class="s1">if (left.isMemberExpression()) return;</span><span class="s3">\n\n      </span><span class="s1">if (left.isIdentifier()) {</span><span class="s3">\n        </span><span class="s1">// Simple update-assign foo += 1; export { foo };</span><span class="s3">\n        </span><span class="s1">// =&gt;   exports.foo =  (foo += 1);</span><span class="s3">\n        </span><span class="s1">const localName = left.node.name;</span><span class="s3">\n\n        </span><span class="s1">// redeclared in this scope</span><span class="s3">\n        </span><span class="s1">if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {</span><span class="s3">\n          </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">const exportedNames = exported.get(localName);</span><span class="s3">\n        </span><span class="s1">const importData = imported.get(localName);</span><span class="s3">\n        </span><span class="s1">if (exportedNames?.length &gt; 0 || importData) {</span><span class="s3">\n          </span><span class="s1">const assignment = path.node;</span><span class="s3">\n\n          </span><span class="s1">if (importData) {</span><span class="s3">\n            </span><span class="s1">assignment.left = buildImportReference(importData, left.node);</span><span class="s3">\n\n            </span><span class="s1">assignment.right = t.sequenceExpression([</span><span class="s3">\n              </span><span class="s1">assignment.right,</span><span class="s3">\n              </span><span class="s1">buildImportThrow(localName),</span><span class="s3">\n            </span><span class="s1">]);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">const { operator } = assignment;</span><span class="s3">\n          </span><span class="s1">let newExpr;</span><span class="s3">\n          </span><span class="s1">if (operator === </span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">newExpr = assignment;</span><span class="s3">\n          </span><span class="s1">} else if (</span><span class="s3">\n            </span><span class="s1">operator === </span><span class="s3">\&quot;</span><span class="s1">&amp;&amp;=</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n            </span><span class="s1">operator === </span><span class="s3">\&quot;</span><span class="s1">||=</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n            </span><span class="s1">operator === </span><span class="s3">\&quot;</span><span class="s1">??=</span><span class="s3">\&quot;\n          </span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">newExpr = t.assignmentExpression(</span><span class="s3">\n              \&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n              </span><span class="s1">assignment.left,</span><span class="s3">\n              </span><span class="s1">t.logicalExpression(</span><span class="s3">\n                </span><span class="s1">operator.slice(0, -1) as t.LogicalExpression[</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n                </span><span class="s1">t.cloneNode(assignment.left) as t.Expression,</span><span class="s3">\n                </span><span class="s1">assignment.right,</span><span class="s3">\n              </span><span class="s1">),</span><span class="s3">\n            </span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">newExpr = t.assignmentExpression(</span><span class="s3">\n              \&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n              </span><span class="s1">assignment.left,</span><span class="s3">\n              </span><span class="s1">t.binaryExpression(</span><span class="s3">\n                </span><span class="s1">operator.slice(0, -1) as t.BinaryExpression[</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n                </span><span class="s1">t.cloneNode(assignment.left) as t.Expression,</span><span class="s3">\n                </span><span class="s1">assignment.right,</span><span class="s3">\n              </span><span class="s1">),</span><span class="s3">\n            </span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">path.replaceWith(</span><span class="s3">\n            </span><span class="s1">buildBindingExportAssignmentExpression(</span><span class="s3">\n              </span><span class="s1">this.metadata,</span><span class="s3">\n              </span><span class="s1">exportedNames,</span><span class="s3">\n              </span><span class="s1">newExpr,</span><span class="s3">\n              </span><span class="s1">path.scope,</span><span class="s3">\n            </span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n\n          </span><span class="s1">requeueInParent(path);</span><span class="s3">\n\n          </span><span class="s1">path.skip();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">const ids = left.getOuterBindingIdentifiers();</span><span class="s3">\n        </span><span class="s1">const programScopeIds = Object.keys(ids).filter(</span><span class="s3">\n          </span><span class="s1">localName =&gt;</span><span class="s3">\n            </span><span class="s1">scope.getBinding(localName) === path.scope.getBinding(localName),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">const id = programScopeIds.find(localName =&gt; imported.has(localName));</span><span class="s3">\n\n        </span><span class="s1">if (id) {</span><span class="s3">\n          </span><span class="s1">path.node.right = t.sequenceExpression([</span><span class="s3">\n            </span><span class="s1">path.node.right,</span><span class="s3">\n            </span><span class="s1">buildImportThrow(id),</span><span class="s3">\n          </span><span class="s1">]);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// Complex ({a, b, c} = {}); export { a, c };</span><span class="s3">\n        </span><span class="s1">// =&gt;   ({a, b, c} = {}), (exports.a = a, exports.c = c);</span><span class="s3">\n        </span><span class="s1">const items: t.Expression[] = [];</span><span class="s3">\n        </span><span class="s1">programScopeIds.forEach(localName =&gt; {</span><span class="s3">\n          </span><span class="s1">const exportedNames = exported.get(localName) || [];</span><span class="s3">\n          </span><span class="s1">if (exportedNames.length &gt; 0) {</span><span class="s3">\n            </span><span class="s1">items.push(</span><span class="s3">\n              </span><span class="s1">buildBindingExportAssignmentExpression(</span><span class="s3">\n                </span><span class="s1">this.metadata,</span><span class="s3">\n                </span><span class="s1">exportedNames,</span><span class="s3">\n                </span><span class="s1">t.identifier(localName),</span><span class="s3">\n                </span><span class="s1">path.scope,</span><span class="s3">\n              </span><span class="s1">),</span><span class="s3">\n            </span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n\n        </span><span class="s1">if (items.length &gt; 0) {</span><span class="s3">\n          </span><span class="s1">let node: t.Node = t.sequenceExpression(items);</span><span class="s3">\n          </span><span class="s1">if (path.parentPath.isExpressionStatement()) {</span><span class="s3">\n            </span><span class="s1">node = t.expressionStatement(node);</span><span class="s3">\n            </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts): avoid mutations</span><span class="s3">\n            </span><span class="s1">node._blockHoist = path.parentPath.node._blockHoist;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">const statement = path.insertAfter(node)[0];</span><span class="s3">\n          </span><span class="s1">requeueInParent(statement);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">ForXStatement(path) {</span><span class="s3">\n    </span><span class="s1">const { scope, node } = path;</span><span class="s3">\n    </span><span class="s1">const { left } = node;</span><span class="s3">\n    </span><span class="s1">const { exported, imported, scope: programScope } = this;</span><span class="s3">\n\n    </span><span class="s1">if (!t.isVariableDeclaration(left)) {</span><span class="s3">\n      </span><span class="s1">let didTransformExport = false,</span><span class="s3">\n        </span><span class="s1">importConstViolationName;</span><span class="s3">\n      </span><span class="s1">const loopBodyScope = path.get(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">).scope;</span><span class="s3">\n      </span><span class="s1">for (const name of Object.keys(t.getOuterBindingIdentifiers(left))) {</span><span class="s3">\n        </span><span class="s1">if (programScope.getBinding(name) === scope.getBinding(name)) {</span><span class="s3">\n          </span><span class="s1">if (exported.has(name)) {</span><span class="s3">\n            </span><span class="s1">didTransformExport = true;</span><span class="s3">\n            </span><span class="s1">if (loopBodyScope.hasOwnBinding(name)) {</span><span class="s3">\n              </span><span class="s1">loopBodyScope.rename(name);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">if (imported.has(name) &amp;&amp; !importConstViolationName) {</span><span class="s3">\n            </span><span class="s1">importConstViolationName = name;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (!didTransformExport &amp;&amp; !importConstViolationName) {</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">path.ensureBlock();</span><span class="s3">\n      </span><span class="s1">const bodyPath = path.get(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">) as NodePath&lt;t.BlockStatement&gt;;</span><span class="s3">\n\n      </span><span class="s1">const newLoopId = scope.generateUidIdentifierBasedOnNode(left);</span><span class="s3">\n      </span><span class="s1">path</span><span class="s3">\n        </span><span class="s1">.get(</span><span class="s3">\&quot;</span><span class="s1">left</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">.replaceWith(</span><span class="s3">\n          </span><span class="s1">t.variableDeclaration(</span><span class="s3">\&quot;</span><span class="s1">let</span><span class="s3">\&quot;</span><span class="s1">, [</span><span class="s3">\n            </span><span class="s1">t.variableDeclarator(t.cloneNode(newLoopId)),</span><span class="s3">\n          </span><span class="s1">]),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">scope.registerDeclaration(path.get(</span><span class="s3">\&quot;</span><span class="s1">left</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n\n      </span><span class="s1">if (didTransformExport) {</span><span class="s3">\n        </span><span class="s1">bodyPath.unshiftContainer(</span><span class="s3">\n          \&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n          </span><span class="s1">t.expressionStatement(t.assignmentExpression(</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">, left, newLoopId)),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (importConstViolationName) {</span><span class="s3">\n        </span><span class="s1">bodyPath.unshiftContainer(</span><span class="s3">\n          \&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n          </span><span class="s1">t.expressionStatement(buildImportThrow(importConstViolationName)),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[]}</span></pre>
</body>
</html>