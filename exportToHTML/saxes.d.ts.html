<html>
<head>
<title>saxes.d.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #67a37c; font-style: italic;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
saxes.d.ts</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* The list of supported events.</span>
 <span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">const </span><span class="s1">EVENTS</span><span class="s3">: </span><span class="s1">readonly </span><span class="s3">[</span><span class="s4">&quot;xmldecl&quot;</span><span class="s3">, </span><span class="s4">&quot;text&quot;</span><span class="s3">, </span><span class="s4">&quot;processinginstruction&quot;</span><span class="s3">, </span><span class="s4">&quot;doctype&quot;</span><span class="s3">, </span><span class="s4">&quot;comment&quot;</span><span class="s3">, </span><span class="s4">&quot;opentagstart&quot;</span><span class="s3">, </span><span class="s4">&quot;attribute&quot;</span><span class="s3">, </span><span class="s4">&quot;opentag&quot;</span><span class="s3">, </span><span class="s4">&quot;closetag&quot;</span><span class="s3">, </span><span class="s4">&quot;cdata&quot;</span><span class="s3">, </span><span class="s4">&quot;error&quot;</span><span class="s3">, </span><span class="s4">&quot;end&quot;</span><span class="s3">, </span><span class="s4">&quot;ready&quot;</span><span class="s3">];</span>
<span class="s0">/**</span>
 <span class="s0">* Event handler for the</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s5">@param </span><span class="s0">text The text data encountered by the parser.</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare type XMLDeclHandler </span><span class="s3">= (</span><span class="s1">decl</span><span class="s3">: </span><span class="s1">XMLDecl</span><span class="s3">) =&gt; </span><span class="s2">void</span><span class="s3">;</span>
<span class="s0">/**</span>
 <span class="s0">* Event handler for text data.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s5">@param </span><span class="s0">text The text data encountered by the parser.</span>
 <span class="s0">*</span>
 <span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare type TextHandler </span><span class="s3">= (</span><span class="s1">text</span><span class="s3">: </span><span class="s1">string</span><span class="s3">) =&gt; </span><span class="s2">void</span><span class="s3">;</span>
<span class="s0">/**</span>
 <span class="s0">* Event handler for processing instructions.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s5">@param </span><span class="s0">data The target and body of the processing instruction.</span>
 <span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare type PIHandler </span><span class="s3">= (</span><span class="s1">data</span><span class="s3">: {</span>
    <span class="s1">target</span><span class="s3">: </span><span class="s1">string</span><span class="s3">;</span>
    <span class="s1">body</span><span class="s3">: </span><span class="s1">string</span><span class="s3">;</span>
<span class="s3">}) =&gt; </span><span class="s2">void</span><span class="s3">;</span>
<span class="s0">/**</span>
 <span class="s0">* Event handler for doctype.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s5">@param </span><span class="s0">doctype The doctype contents.</span>
 <span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare type DoctypeHandler </span><span class="s3">= (</span><span class="s1">doctype</span><span class="s3">: </span><span class="s1">string</span><span class="s3">) =&gt; </span><span class="s2">void</span><span class="s3">;</span>
<span class="s0">/**</span>
 <span class="s0">* Event handler for comments.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s5">@param </span><span class="s0">comment The comment contents.</span>
 <span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare type CommentHandler </span><span class="s3">= (</span><span class="s1">comment</span><span class="s3">: </span><span class="s1">string</span><span class="s3">) =&gt; </span><span class="s2">void</span><span class="s3">;</span>
<span class="s0">/**</span>
 <span class="s0">* Event handler for the start of an open tag. This is called as soon as we</span>
 <span class="s0">* have a tag name.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s5">@param </span><span class="s0">tag The tag.</span>
 <span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare type OpenTagStartHandler</span><span class="s3">&lt;</span><span class="s1">O</span><span class="s3">&gt; = (</span><span class="s1">tag</span><span class="s3">: </span><span class="s1">StartTagForOptions</span><span class="s3">&lt;</span><span class="s1">O</span><span class="s3">&gt;) =&gt; </span><span class="s2">void</span><span class="s3">;</span>
<span class="s2">export </span><span class="s1">declare type AttributeEventForOptions</span><span class="s3">&lt;</span><span class="s1">O </span><span class="s2">extends </span><span class="s1">SaxesOptions</span><span class="s3">&gt; = </span><span class="s1">O </span><span class="s2">extends </span><span class="s3">{</span>
    <span class="s1">xmlns</span><span class="s3">: </span><span class="s2">true</span><span class="s3">;</span>
<span class="s3">} ? </span><span class="s1">SaxesAttributeNSIncomplete </span><span class="s3">: </span><span class="s1">O </span><span class="s2">extends </span><span class="s3">{</span>
    <span class="s1">xmlns</span><span class="s3">?: </span><span class="s2">false </span><span class="s3">| </span><span class="s1">undefined</span><span class="s3">;</span>
<span class="s3">} ? </span><span class="s1">SaxesAttributePlain </span><span class="s3">: </span><span class="s1">SaxesAttribute</span><span class="s3">;</span>
<span class="s0">/**</span>
 <span class="s0">* Event handler for attributes.</span>
 <span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare type AttributeHandler</span><span class="s3">&lt;</span><span class="s1">O</span><span class="s3">&gt; = (</span><span class="s1">attribute</span><span class="s3">: </span><span class="s1">AttributeEventForOptions</span><span class="s3">&lt;</span><span class="s1">O</span><span class="s3">&gt;) =&gt; </span><span class="s2">void</span><span class="s3">;</span>
<span class="s0">/**</span>
 <span class="s0">* Event handler for an open tag. This is called when the open tag is</span>
 <span class="s0">* complete. (We've encountered the &quot;&gt;&quot; that ends the open tag.)</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s5">@param </span><span class="s0">tag The tag.</span>
 <span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare type OpenTagHandler</span><span class="s3">&lt;</span><span class="s1">O</span><span class="s3">&gt; = (</span><span class="s1">tag</span><span class="s3">: </span><span class="s1">TagForOptions</span><span class="s3">&lt;</span><span class="s1">O</span><span class="s3">&gt;) =&gt; </span><span class="s2">void</span><span class="s3">;</span>
<span class="s0">/**</span>
 <span class="s0">* Event handler for a close tag. Note that for self-closing tags, this is</span>
 <span class="s0">* called right after ``opentag``.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s5">@param </span><span class="s0">tag The tag.</span>
 <span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare type CloseTagHandler</span><span class="s3">&lt;</span><span class="s1">O</span><span class="s3">&gt; = (</span><span class="s1">tag</span><span class="s3">: </span><span class="s1">TagForOptions</span><span class="s3">&lt;</span><span class="s1">O</span><span class="s3">&gt;) =&gt; </span><span class="s2">void</span><span class="s3">;</span>
<span class="s0">/**</span>
 <span class="s0">* Event handler for a CDATA section. This is called when ending the</span>
 <span class="s0">* CDATA section.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s5">@param </span><span class="s0">cdata The contents of the CDATA section.</span>
 <span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare type CDataHandler </span><span class="s3">= (</span><span class="s1">cdata</span><span class="s3">: </span><span class="s1">string</span><span class="s3">) =&gt; </span><span class="s2">void</span><span class="s3">;</span>
<span class="s0">/**</span>
 <span class="s0">* Event handler for the stream end. This is called when the stream has been</span>
 <span class="s0">* closed with ``close`` or by passing ``null`` to ``write``.</span>
 <span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare type EndHandler </span><span class="s3">= () =&gt; </span><span class="s2">void</span><span class="s3">;</span>
<span class="s0">/**</span>
 <span class="s0">* Event handler indicating parser readiness . This is called when the parser</span>
 <span class="s0">* is ready to parse a new document.</span>
 <span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare type ReadyHandler </span><span class="s3">= () =&gt; </span><span class="s2">void</span><span class="s3">;</span>
<span class="s0">/**</span>
 <span class="s0">* Event handler indicating an error.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s5">@param </span><span class="s0">err The error that occurred.</span>
 <span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare type ErrorHandler </span><span class="s3">= (</span><span class="s1">err</span><span class="s3">: </span><span class="s1">Error</span><span class="s3">) =&gt; </span><span class="s2">void</span><span class="s3">;</span>
<span class="s2">export </span><span class="s1">declare type EventName </span><span class="s3">= (</span><span class="s2">typeof </span><span class="s1">EVENTS</span><span class="s3">)[</span><span class="s1">number</span><span class="s3">];</span>
<span class="s2">export </span><span class="s1">declare type EventNameToHandler</span><span class="s3">&lt;</span><span class="s1">O</span><span class="s3">, </span><span class="s1">N </span><span class="s2">extends </span><span class="s1">EventName</span><span class="s3">&gt; = {</span>
    <span class="s4">&quot;xmldecl&quot;</span><span class="s3">: </span><span class="s1">XMLDeclHandler</span><span class="s3">;</span>
    <span class="s4">&quot;text&quot;</span><span class="s3">: </span><span class="s1">TextHandler</span><span class="s3">;</span>
    <span class="s4">&quot;processinginstruction&quot;</span><span class="s3">: </span><span class="s1">PIHandler</span><span class="s3">;</span>
    <span class="s4">&quot;doctype&quot;</span><span class="s3">: </span><span class="s1">DoctypeHandler</span><span class="s3">;</span>
    <span class="s4">&quot;comment&quot;</span><span class="s3">: </span><span class="s1">CommentHandler</span><span class="s3">;</span>
    <span class="s4">&quot;opentagstart&quot;</span><span class="s3">: </span><span class="s1">OpenTagStartHandler</span><span class="s3">&lt;</span><span class="s1">O</span><span class="s3">&gt;;</span>
    <span class="s4">&quot;attribute&quot;</span><span class="s3">: </span><span class="s1">AttributeHandler</span><span class="s3">&lt;</span><span class="s1">O</span><span class="s3">&gt;;</span>
    <span class="s4">&quot;opentag&quot;</span><span class="s3">: </span><span class="s1">OpenTagHandler</span><span class="s3">&lt;</span><span class="s1">O</span><span class="s3">&gt;;</span>
    <span class="s4">&quot;closetag&quot;</span><span class="s3">: </span><span class="s1">CloseTagHandler</span><span class="s3">&lt;</span><span class="s1">O</span><span class="s3">&gt;;</span>
    <span class="s4">&quot;cdata&quot;</span><span class="s3">: </span><span class="s1">CDataHandler</span><span class="s3">;</span>
    <span class="s4">&quot;error&quot;</span><span class="s3">: </span><span class="s1">ErrorHandler</span><span class="s3">;</span>
    <span class="s4">&quot;end&quot;</span><span class="s3">: </span><span class="s1">EndHandler</span><span class="s3">;</span>
    <span class="s4">&quot;ready&quot;</span><span class="s3">: </span><span class="s1">ReadyHandler</span><span class="s3">;</span>
<span class="s3">}[</span><span class="s1">N</span><span class="s3">];</span>
<span class="s0">/**</span>
 <span class="s0">* This interface defines the structure of attributes when the parser is</span>
 <span class="s0">* processing namespaces (created with ``xmlns: true``).</span>
 <span class="s0">*/</span>
<span class="s2">export interface </span><span class="s1">SaxesAttributeNS </span><span class="s3">{</span>
    <span class="s0">/**</span>
     <span class="s0">* The attribute's name. This is the combination of prefix and local name.</span>
     <span class="s0">* For instance ``a:b=&quot;c&quot;`` would have ``a:b`` for name.</span>
     <span class="s0">*/</span>
    <span class="s1">name</span><span class="s3">: </span><span class="s1">string</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The attribute's prefix. For instance ``a:b=&quot;c&quot;`` would have ``&quot;a&quot;`` for</span>
     <span class="s0">* ``prefix``.</span>
     <span class="s0">*/</span>
    <span class="s1">prefix</span><span class="s3">: </span><span class="s1">string</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The attribute's local name. For instance ``a:b=&quot;c&quot;`` would have ``&quot;b&quot;`` for</span>
     <span class="s0">* ``local``.</span>
     <span class="s0">*/</span>
    <span class="s1">local</span><span class="s3">: </span><span class="s1">string</span><span class="s3">;</span>
    <span class="s0">/** The namespace URI of this attribute. */</span>
    <span class="s1">uri</span><span class="s3">: </span><span class="s1">string</span><span class="s3">;</span>
    <span class="s0">/** The attribute's value. */</span>
    <span class="s1">value</span><span class="s3">: </span><span class="s1">string</span><span class="s3">;</span>
<span class="s3">}</span>
<span class="s0">/**</span>
 <span class="s0">* This is an attribute, as recorded by a parser which parses namespaces but</span>
 <span class="s0">* prior to the URI being resolvable. This is what is passed to the attribute</span>
 <span class="s0">* event handler.</span>
 <span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare type SaxesAttributeNSIncomplete </span><span class="s3">= </span><span class="s1">Exclude</span><span class="s3">&lt;</span><span class="s1">SaxesAttributeNS</span><span class="s3">, </span><span class="s4">&quot;uri&quot;</span><span class="s3">&gt;;</span>
<span class="s0">/**</span>
 <span class="s0">* This interface defines the structure of attributes when the parser is</span>
 <span class="s0">* NOT processing namespaces (created with ``xmlns: false``).</span>
 <span class="s0">*/</span>
<span class="s2">export interface </span><span class="s1">SaxesAttributePlain </span><span class="s3">{</span>
    <span class="s0">/**</span>
     <span class="s0">* The attribute's name.</span>
     <span class="s0">*/</span>
    <span class="s1">name</span><span class="s3">: </span><span class="s1">string</span><span class="s3">;</span>
    <span class="s0">/** The attribute's value. */</span>
    <span class="s1">value</span><span class="s3">: </span><span class="s1">string</span><span class="s3">;</span>
<span class="s3">}</span>
<span class="s0">/**</span>
 <span class="s0">* A saxes attribute, with or without namespace information.</span>
 <span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare type SaxesAttribute </span><span class="s3">= </span><span class="s1">SaxesAttributeNS </span><span class="s3">| </span><span class="s1">SaxesAttributePlain</span><span class="s3">;</span>
<span class="s0">/**</span>
 <span class="s0">* This are the fields that MAY be present on a complete tag.</span>
 <span class="s0">*/</span>
<span class="s2">export interface </span><span class="s1">SaxesTag </span><span class="s3">{</span>
    <span class="s0">/**</span>
     <span class="s0">* The tag's name. This is the combination of prefix and global name. For</span>
     <span class="s0">* instance ``&lt;a:b&gt;`` would have ``&quot;a:b&quot;`` for ``name``.</span>
     <span class="s0">*/</span>
    <span class="s1">name</span><span class="s3">: </span><span class="s1">string</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* A map of attribute name to attributes. If namespaces are tracked, the</span>
     <span class="s0">* values in the map are attribute objects. Otherwise, they are strings.</span>
     <span class="s0">*/</span>
    <span class="s1">attributes</span><span class="s3">: </span><span class="s1">Record</span><span class="s3">&lt;</span><span class="s1">string</span><span class="s3">, </span><span class="s1">SaxesAttributeNS</span><span class="s3">&gt; | </span><span class="s1">Record</span><span class="s3">&lt;</span><span class="s1">string</span><span class="s3">, </span><span class="s1">string</span><span class="s3">&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* The namespace bindings in effect.</span>
     <span class="s0">*/</span>
    <span class="s1">ns</span><span class="s3">?: </span><span class="s1">Record</span><span class="s3">&lt;</span><span class="s1">string</span><span class="s3">, </span><span class="s1">string</span><span class="s3">&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* The tag's prefix. For instance ``&lt;a:b&gt;`` would have ``&quot;a&quot;`` for</span>
     <span class="s0">* ``prefix``. Undefined if we do not track namespaces.</span>
     <span class="s0">*/</span>
    <span class="s1">prefix</span><span class="s3">?: </span><span class="s1">string</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The tag's local name. For instance ``&lt;a:b&gt;`` would</span>
     <span class="s0">* have ``&quot;b&quot;`` for ``local``. Undefined if we do not track namespaces.</span>
     <span class="s0">*/</span>
    <span class="s1">local</span><span class="s3">?: </span><span class="s1">string</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The namespace URI of this tag. Undefined if we do not track namespaces.</span>
     <span class="s0">*/</span>
    <span class="s1">uri</span><span class="s3">?: </span><span class="s1">string</span><span class="s3">;</span>
    <span class="s0">/** Whether the tag is self-closing (e.g. ``&lt;foo/&gt;``). */</span>
    <span class="s1">isSelfClosing</span><span class="s3">: </span><span class="s1">boolean</span><span class="s3">;</span>
<span class="s3">}</span>
<span class="s0">/**</span>
 <span class="s0">* This type defines the fields that are present on a tag object when</span>
 <span class="s0">* ``onopentagstart`` is called. This interface is namespace-agnostic.</span>
 <span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare type SaxesStartTag </span><span class="s3">= </span><span class="s1">Pick</span><span class="s3">&lt;</span><span class="s1">SaxesTag</span><span class="s3">, </span><span class="s4">&quot;name&quot; </span><span class="s3">| </span><span class="s4">&quot;attributes&quot; </span><span class="s3">| </span><span class="s4">&quot;ns&quot;</span><span class="s3">&gt;;</span>
<span class="s0">/**</span>
 <span class="s0">* This type defines the fields that are present on a tag object when</span>
 <span class="s0">* ``onopentagstart`` is called on a parser that does not processes namespaces.</span>
 <span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare type SaxesStartTagPlain </span><span class="s3">= </span><span class="s1">Pick</span><span class="s3">&lt;</span><span class="s1">SaxesStartTag</span><span class="s3">, </span><span class="s4">&quot;name&quot; </span><span class="s3">| </span><span class="s4">&quot;attributes&quot;</span><span class="s3">&gt;;</span>
<span class="s0">/**</span>
 <span class="s0">* This type defines the fields that are present on a tag object when</span>
 <span class="s0">* ``onopentagstart`` is called on a parser that does process namespaces.</span>
 <span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare type SaxesStartTagNS </span><span class="s3">= </span><span class="s1">Required</span><span class="s3">&lt;</span><span class="s1">SaxesStartTag</span><span class="s3">&gt;;</span>
<span class="s0">/**</span>
 <span class="s0">* This are the fields that are present on a complete tag produced by a parser</span>
 <span class="s0">* that does process namespaces.</span>
 <span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare type SaxesTagNS </span><span class="s3">= </span><span class="s1">Required</span><span class="s3">&lt;</span><span class="s1">SaxesTag</span><span class="s3">&gt; &amp; {</span>
    <span class="s1">attributes</span><span class="s3">: </span><span class="s1">Record</span><span class="s3">&lt;</span><span class="s1">string</span><span class="s3">, </span><span class="s1">SaxesAttributeNS</span><span class="s3">&gt;;</span>
<span class="s3">};</span>
<span class="s0">/**</span>
 <span class="s0">* This are the fields that are present on a complete tag produced by a parser</span>
 <span class="s0">* that does not process namespaces.</span>
 <span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare type SaxesTagPlain </span><span class="s3">= </span><span class="s1">Pick</span><span class="s3">&lt;</span><span class="s1">SaxesTag</span><span class="s3">, </span><span class="s4">&quot;name&quot; </span><span class="s3">| </span><span class="s4">&quot;attributes&quot; </span><span class="s3">| </span><span class="s4">&quot;isSelfClosing&quot;</span><span class="s3">&gt; &amp; {</span>
    <span class="s1">attributes</span><span class="s3">: </span><span class="s1">Record</span><span class="s3">&lt;</span><span class="s1">string</span><span class="s3">, </span><span class="s1">string</span><span class="s3">&gt;;</span>
<span class="s3">};</span>
<span class="s0">/**</span>
 <span class="s0">* An XML declaration.</span>
 <span class="s0">*/</span>
<span class="s2">export interface </span><span class="s1">XMLDecl </span><span class="s3">{</span>
    <span class="s0">/** The version specified by the XML declaration. */</span>
    <span class="s1">version</span><span class="s3">?: </span><span class="s1">string</span><span class="s3">;</span>
    <span class="s0">/** The encoding specified by the XML declaration. */</span>
    <span class="s1">encoding</span><span class="s3">?: </span><span class="s1">string</span><span class="s3">;</span>
    <span class="s0">/** The value of the standalone parameter */</span>
    <span class="s1">standalone</span><span class="s3">?: </span><span class="s1">string</span><span class="s3">;</span>
<span class="s3">}</span>
<span class="s0">/**</span>
 <span class="s0">* A callback for resolving name prefixes.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s5">@param </span><span class="s0">prefix The prefix to check.</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s5">@returns </span><span class="s0">The URI corresponding to the prefix, if any.</span>
 <span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare type ResolvePrefix </span><span class="s3">= (</span><span class="s1">prefix</span><span class="s3">: </span><span class="s1">string</span><span class="s3">) =&gt; </span><span class="s1">string </span><span class="s3">| </span><span class="s1">undefined</span><span class="s3">;</span>
<span class="s2">export interface </span><span class="s1">CommonOptions </span><span class="s3">{</span>
    <span class="s0">/** Whether to accept XML fragments. Unset means ``false``. */</span>
    <span class="s1">fragment</span><span class="s3">?: </span><span class="s1">boolean</span><span class="s3">;</span>
    <span class="s0">/** Whether to track positions. Unset means ``true``. */</span>
    <span class="s1">position</span><span class="s3">?: </span><span class="s1">boolean</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* A file name to use for error reporting. &quot;File name&quot; is a loose concept. You</span>
     <span class="s0">* could use a URL to some resource, or any descriptive name you like.</span>
     <span class="s0">*/</span>
    <span class="s1">fileName</span><span class="s3">?: </span><span class="s1">string</span><span class="s3">;</span>
<span class="s3">}</span>
<span class="s2">export interface </span><span class="s1">NSOptions </span><span class="s3">{</span>
    <span class="s0">/** Whether to track namespaces. Unset means ``false``. */</span>
    <span class="s1">xmlns</span><span class="s3">?: </span><span class="s1">boolean</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* A plain object whose key, value pairs define namespaces known before</span>
     <span class="s0">* parsing the XML file. It is not legal to pass bindings for the namespaces</span>
     <span class="s0">* ``&quot;xml&quot;`` or ``&quot;xmlns&quot;``.</span>
     <span class="s0">*/</span>
    <span class="s1">additionalNamespaces</span><span class="s3">?: </span><span class="s1">Record</span><span class="s3">&lt;</span><span class="s1">string</span><span class="s3">, </span><span class="s1">string</span><span class="s3">&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* A function that will be used if the parser cannot resolve a namespace</span>
     <span class="s0">* prefix on its own.</span>
     <span class="s0">*/</span>
    <span class="s1">resolvePrefix</span><span class="s3">?: </span><span class="s1">ResolvePrefix</span><span class="s3">;</span>
<span class="s3">}</span>
<span class="s2">export interface </span><span class="s1">NSOptionsWithoutNamespaces </span><span class="s2">extends </span><span class="s1">NSOptions </span><span class="s3">{</span>
    <span class="s1">xmlns</span><span class="s3">?: </span><span class="s2">false</span><span class="s3">;</span>
    <span class="s1">additionalNamespaces</span><span class="s3">?: </span><span class="s1">undefined</span><span class="s3">;</span>
    <span class="s1">resolvePrefix</span><span class="s3">?: </span><span class="s1">undefined</span><span class="s3">;</span>
<span class="s3">}</span>
<span class="s2">export interface </span><span class="s1">NSOptionsWithNamespaces </span><span class="s2">extends </span><span class="s1">NSOptions </span><span class="s3">{</span>
    <span class="s1">xmlns</span><span class="s3">: </span><span class="s2">true</span><span class="s3">;</span>
<span class="s3">}</span>
<span class="s2">export interface </span><span class="s1">XMLVersionOptions </span><span class="s3">{</span>
    <span class="s0">/**</span>
     <span class="s0">* The default XML version to use. If unspecified, and there is no XML</span>
     <span class="s0">* encoding declaration, the default version is &quot;1.0&quot;.</span>
     <span class="s0">*/</span>
    <span class="s1">defaultXMLVersion</span><span class="s3">?: </span><span class="s4">&quot;1.0&quot; </span><span class="s3">| </span><span class="s4">&quot;1.1&quot;</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* A flag indicating whether to force the XML version used for parsing to the</span>
     <span class="s0">* value of ``defaultXMLVersion``. When this flag is ``true``,</span>
     <span class="s0">* ``defaultXMLVersion`` must be specified. If unspecified, the default value</span>
     <span class="s0">* of this flag is ``false``.</span>
     <span class="s0">*/</span>
    <span class="s1">forceXMLVersion</span><span class="s3">?: </span><span class="s1">boolean</span><span class="s3">;</span>
<span class="s3">}</span>
<span class="s2">export interface </span><span class="s1">NoForcedXMLVersion </span><span class="s2">extends </span><span class="s1">XMLVersionOptions </span><span class="s3">{</span>
    <span class="s1">forceXMLVersion</span><span class="s3">?: </span><span class="s2">false</span><span class="s3">;</span>
<span class="s3">}</span>
<span class="s2">export interface </span><span class="s1">ForcedXMLVersion </span><span class="s2">extends </span><span class="s1">XMLVersionOptions </span><span class="s3">{</span>
    <span class="s1">forceXMLVersion</span><span class="s3">: </span><span class="s2">true</span><span class="s3">;</span>
    <span class="s1">defaultXMLVersion</span><span class="s3">: </span><span class="s1">Exclude</span><span class="s3">&lt;</span><span class="s1">XMLVersionOptions</span><span class="s3">[</span><span class="s4">&quot;defaultXMLVersion&quot;</span><span class="s3">], </span><span class="s1">undefined</span><span class="s3">&gt;;</span>
<span class="s3">}</span>
<span class="s0">/**</span>
 <span class="s0">* The entire set of options supported by saxes.</span>
 <span class="s0">*/</span>
<span class="s2">export </span><span class="s1">declare type SaxesOptions </span><span class="s3">= </span><span class="s1">CommonOptions </span><span class="s3">&amp; </span><span class="s1">NSOptions </span><span class="s3">&amp; </span><span class="s1">XMLVersionOptions</span><span class="s3">;</span>
<span class="s2">export </span><span class="s1">declare type TagForOptions</span><span class="s3">&lt;</span><span class="s1">O </span><span class="s2">extends </span><span class="s1">SaxesOptions</span><span class="s3">&gt; = </span><span class="s1">O </span><span class="s2">extends </span><span class="s3">{</span>
    <span class="s1">xmlns</span><span class="s3">: </span><span class="s2">true</span><span class="s3">;</span>
<span class="s3">} ? </span><span class="s1">SaxesTagNS </span><span class="s3">: </span><span class="s1">O </span><span class="s2">extends </span><span class="s3">{</span>
    <span class="s1">xmlns</span><span class="s3">?: </span><span class="s2">false </span><span class="s3">| </span><span class="s1">undefined</span><span class="s3">;</span>
<span class="s3">} ? </span><span class="s1">SaxesTagPlain </span><span class="s3">: </span><span class="s1">SaxesTag</span><span class="s3">;</span>
<span class="s2">export </span><span class="s1">declare type StartTagForOptions</span><span class="s3">&lt;</span><span class="s1">O </span><span class="s2">extends </span><span class="s1">SaxesOptions</span><span class="s3">&gt; = </span><span class="s1">O </span><span class="s2">extends </span><span class="s3">{</span>
    <span class="s1">xmlns</span><span class="s3">: </span><span class="s2">true</span><span class="s3">;</span>
<span class="s3">} ? </span><span class="s1">SaxesStartTagNS </span><span class="s3">: </span><span class="s1">O </span><span class="s2">extends </span><span class="s3">{</span>
    <span class="s1">xmlns</span><span class="s3">?: </span><span class="s2">false </span><span class="s3">| </span><span class="s1">undefined</span><span class="s3">;</span>
<span class="s3">} ? </span><span class="s1">SaxesStartTagPlain </span><span class="s3">: </span><span class="s1">SaxesStartTag</span><span class="s3">;</span>
<span class="s2">export </span><span class="s1">declare </span><span class="s2">class </span><span class="s1">SaxesParser</span><span class="s3">&lt;</span><span class="s1">O </span><span class="s2">extends </span><span class="s1">SaxesOptions </span><span class="s3">= {}&gt; {</span>
    <span class="s2">private </span><span class="s1">readonly fragmentOpt</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">readonly xmlnsOpt</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">readonly trackPosition</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">readonly fileName</span><span class="s3">?;</span>
    <span class="s2">private </span><span class="s1">readonly nameStartCheck</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">readonly nameCheck</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">readonly isName</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">readonly ns</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">openWakaBang</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">text</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">name</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">piTarget</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">entity</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">q</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">tags</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">tag</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">topNS</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">chunk</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">chunkPosition</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">i</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">prevI</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">carriedFromPrevious</span><span class="s3">?;</span>
    <span class="s2">private </span><span class="s1">forbiddenState</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">attribList</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">state</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">reportedTextBeforeRoot</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">reportedTextAfterRoot</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">closedRoot</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">sawRoot</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">xmlDeclPossible</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">xmlDeclExpects</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">entityReturnState</span><span class="s3">?;</span>
    <span class="s2">private </span><span class="s1">processAttribs</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">positionAtNewLine</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">doctype</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">getCode</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">isChar</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">pushAttrib</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">_closed</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">currentXMLVersion</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">readonly stateTable</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">xmldeclHandler</span><span class="s3">?;</span>
    <span class="s2">private </span><span class="s1">textHandler</span><span class="s3">?;</span>
    <span class="s2">private </span><span class="s1">piHandler</span><span class="s3">?;</span>
    <span class="s2">private </span><span class="s1">doctypeHandler</span><span class="s3">?;</span>
    <span class="s2">private </span><span class="s1">commentHandler</span><span class="s3">?;</span>
    <span class="s2">private </span><span class="s1">openTagStartHandler</span><span class="s3">?;</span>
    <span class="s2">private </span><span class="s1">openTagHandler</span><span class="s3">?;</span>
    <span class="s2">private </span><span class="s1">closeTagHandler</span><span class="s3">?;</span>
    <span class="s2">private </span><span class="s1">cdataHandler</span><span class="s3">?;</span>
    <span class="s2">private </span><span class="s1">errorHandler</span><span class="s3">?;</span>
    <span class="s2">private </span><span class="s1">endHandler</span><span class="s3">?;</span>
    <span class="s2">private </span><span class="s1">readyHandler</span><span class="s3">?;</span>
    <span class="s2">private </span><span class="s1">attributeHandler</span><span class="s3">?;</span>
    <span class="s0">/**</span>
     <span class="s0">* Indicates whether or not the parser is closed. If ``true``, wait for</span>
     <span class="s0">* the ``ready`` event to write again.</span>
     <span class="s0">*/</span>
    <span class="s1">get closed</span><span class="s3">(): </span><span class="s1">boolean</span><span class="s3">;</span>
    <span class="s1">readonly opt</span><span class="s3">: </span><span class="s1">SaxesOptions</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The XML declaration for this document.</span>
     <span class="s0">*/</span>
    <span class="s1">xmlDecl</span><span class="s3">: </span><span class="s1">XMLDecl</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The line number of the next character to be read by the parser. This field</span>
     <span class="s0">* is one-based. (The first line is numbered 1.)</span>
     <span class="s0">*/</span>
    <span class="s1">line</span><span class="s3">: </span><span class="s1">number</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The column number of the next character to be read by the parser.  *</span>
     <span class="s0">* This field is zero-based. (The first column is 0.)</span>
     <span class="s0">*</span>
     <span class="s0">* This field counts columns by *Unicode character*. Note that this *can*</span>
     <span class="s0">* be different from the index of the character in a JavaScript string due</span>
     <span class="s0">* to how JavaScript handles astral plane characters.</span>
     <span class="s0">*</span>
     <span class="s0">* See [[columnIndex]] for a number that corresponds to the JavaScript index.</span>
     <span class="s0">*/</span>
    <span class="s1">column</span><span class="s3">: </span><span class="s1">number</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* A map of entity name to expansion.</span>
     <span class="s0">*/</span>
    <span class="s1">ENTITIES</span><span class="s3">: </span><span class="s1">Record</span><span class="s3">&lt;</span><span class="s1">string</span><span class="s3">, </span><span class="s1">string</span><span class="s3">&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* </span><span class="s5">@param </span><span class="s0">opt The parser options.</span>
     <span class="s0">*/</span>
    <span class="s1">constructor</span><span class="s3">(</span><span class="s1">opt</span><span class="s3">?: </span><span class="s1">O</span><span class="s3">);</span>
    <span class="s1">_init</span><span class="s3">(): </span><span class="s2">void</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The stream position the parser is currently looking at. This field is</span>
     <span class="s0">* zero-based.</span>
     <span class="s0">*</span>
     <span class="s0">* This field is not based on counting Unicode characters but is to be</span>
     <span class="s0">* interpreted as a plain index into a JavaScript string.</span>
     <span class="s0">*/</span>
    <span class="s1">get position</span><span class="s3">(): </span><span class="s1">number</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The column number of the next character to be read by the parser.  *</span>
     <span class="s0">* This field is zero-based. (The first column in a line is 0.)</span>
     <span class="s0">*</span>
     <span class="s0">* This field reports the index at which the next character would be in the</span>
     <span class="s0">* line if the line were represented as a JavaScript string.  Note that this</span>
     <span class="s0">* *can* be different to a count based on the number of *Unicode characters*</span>
     <span class="s0">* due to how JavaScript handles astral plane characters.</span>
     <span class="s0">*</span>
     <span class="s0">* See [[column]] for a number that corresponds to a count of Unicode</span>
     <span class="s0">* characters.</span>
     <span class="s0">*/</span>
    <span class="s1">get columnIndex</span><span class="s3">(): </span><span class="s1">number</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Set an event listener on an event. The parser supports one handler per</span>
     <span class="s0">* event type. If you try to set an event handler over an existing handler,</span>
     <span class="s0">* the old handler is silently overwritten.</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s5">@param </span><span class="s0">name The event to listen to.</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s5">@param </span><span class="s0">handler The handler to set.</span>
     <span class="s0">*/</span>
    <span class="s1">on</span><span class="s3">&lt;</span><span class="s1">N </span><span class="s2">extends </span><span class="s1">EventName</span><span class="s3">&gt;(</span><span class="s1">name</span><span class="s3">: </span><span class="s1">N</span><span class="s3">, </span><span class="s1">handler</span><span class="s3">: </span><span class="s1">EventNameToHandler</span><span class="s3">&lt;</span><span class="s1">O</span><span class="s3">, </span><span class="s1">N</span><span class="s3">&gt;): </span><span class="s2">void</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Unset an event handler.</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s5">@parma </span><span class="s0">name The event to stop listening to.</span>
     <span class="s0">*/</span>
    <span class="s1">off</span><span class="s3">(</span><span class="s1">name</span><span class="s3">: </span><span class="s1">EventName</span><span class="s3">): </span><span class="s2">void</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Make an error object. The error object will have a message that contains</span>
     <span class="s0">* the ``fileName`` option passed at the creation of the parser. If position</span>
     <span class="s0">* tracking was turned on, it will also have line and column number</span>
     <span class="s0">* information.</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s5">@param </span><span class="s0">message The message describing the error to report.</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s5">@returns </span><span class="s0">An error object with a properly formatted message.</span>
     <span class="s0">*/</span>
    <span class="s1">makeError</span><span class="s3">(</span><span class="s1">message</span><span class="s3">: </span><span class="s1">string</span><span class="s3">): </span><span class="s1">Error</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Report a parsing error. This method is made public so that client code may</span>
     <span class="s0">* check for issues that are outside the scope of this project and can report</span>
     <span class="s0">* errors.</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s5">@param </span><span class="s0">message The error to report.</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s5">@returns </span><span class="s0">this</span>
     <span class="s0">*/</span>
    <span class="s1">fail</span><span class="s3">(</span><span class="s1">message</span><span class="s3">: </span><span class="s1">string</span><span class="s3">): </span><span class="s2">this</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Write a XML data to the parser.</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s5">@param </span><span class="s0">chunk The XML data to write.</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s5">@returns </span><span class="s0">this</span>
     <span class="s0">*/</span>
    <span class="s1">write</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">: </span><span class="s1">string </span><span class="s3">| {} | </span><span class="s2">null</span><span class="s3">): </span><span class="s2">this</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Close the current stream. Perform final well-formedness checks and reset</span>
     <span class="s0">* the parser tstate.</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s5">@returns </span><span class="s0">this</span>
     <span class="s0">*/</span>
    <span class="s1">close</span><span class="s3">(): </span><span class="s2">this</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Get a single code point out of the current chunk. This updates the current</span>
     <span class="s0">* position if we do position tracking.</span>
     <span class="s0">*</span>
     <span class="s0">* This is the algorithm to use for XML 1.0.</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s5">@returns </span><span class="s0">The character read.</span>
     <span class="s0">*/</span>
    <span class="s2">private </span><span class="s1">getCode10</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Get a single code point out of the current chunk. This updates the current</span>
     <span class="s0">* position if we do position tracking.</span>
     <span class="s0">*</span>
     <span class="s0">* This is the algorithm to use for XML 1.1.</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s5">@returns </span><span class="s0">{number} The character read.</span>
     <span class="s0">*/</span>
    <span class="s2">private </span><span class="s1">getCode11</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Like ``getCode`` but with the return value normalized so that ``NL`` is</span>
     <span class="s0">* returned for ``NL_LIKE``.</span>
     <span class="s0">*/</span>
    <span class="s2">private </span><span class="s1">getCodeNorm</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">unget</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Capture characters into a buffer until encountering one of a set of</span>
     <span class="s0">* characters.</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s5">@param </span><span class="s0">chars An array of codepoints. Encountering a character in the array</span>
     <span class="s0">* ends the capture. (``chars`` may safely contain ``NL``.)</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s5">@return </span><span class="s0">The character code that made the capture end, or ``EOC`` if we hit</span>
     <span class="s0">* the end of the chunk. The return value cannot be NL_LIKE: NL is returned</span>
     <span class="s0">* instead.</span>
     <span class="s0">*/</span>
    <span class="s2">private </span><span class="s1">captureTo</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Capture characters into a buffer until encountering a character.</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s5">@param </span><span class="s0">char The codepoint that ends the capture. **NOTE ``char`` MAY NOT</span>
     <span class="s0">* CONTAIN ``NL``.** Passing ``NL`` will result in buggy behavior.</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s5">@return </span><span class="s0">``true`` if we ran into the character. Otherwise, we ran into the</span>
     <span class="s0">* end of the current chunk.</span>
     <span class="s0">*/</span>
    <span class="s2">private </span><span class="s1">captureToChar</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Capture characters that satisfy ``isNameChar`` into the ``name`` field of</span>
     <span class="s0">* this parser.</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s5">@return </span><span class="s0">The character code that made the test fail, or ``EOC`` if we hit</span>
     <span class="s0">* the end of the chunk. The return value cannot be NL_LIKE: NL is returned</span>
     <span class="s0">* instead.</span>
     <span class="s0">*/</span>
    <span class="s2">private </span><span class="s1">captureNameChars</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Skip white spaces.</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s5">@return </span><span class="s0">The character that ended the skip, or ``EOC`` if we hit</span>
     <span class="s0">* the end of the chunk. The return value cannot be NL_LIKE: NL is returned</span>
     <span class="s0">* instead.</span>
     <span class="s0">*/</span>
    <span class="s2">private </span><span class="s1">skipSpaces</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">setXMLVersion</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">sBegin</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">sBeginWhitespace</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">sDoctype</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">sDoctypeQuote</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">sDTD</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">sDTDQuoted</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">sDTDOpenWaka</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">sDTDOpenWakaBang</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">sDTDComment</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">sDTDCommentEnding</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">sDTDCommentEnded</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">sDTDPI</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">sDTDPIEnding</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">sText</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">sEntity</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">sOpenWaka</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">sOpenWakaBang</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">sComment</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">sCommentEnding</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">sCommentEnded</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">sCData</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">sCDataEnding</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">sCDataEnding2</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">sPIFirstChar</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">sPIRest</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">sPIBody</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">sPIEnding</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">sXMLDeclNameStart</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">sXMLDeclName</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">sXMLDeclEq</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">sXMLDeclValueStart</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">sXMLDeclValue</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">sXMLDeclSeparator</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">sXMLDeclEnding</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">sOpenTag</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">sOpenTagSlash</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">sAttrib</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">sAttribName</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">sAttribNameSawWhite</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">sAttribValue</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">sAttribValueQuoted</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">sAttribValueClosed</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">sAttribValueUnquoted</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">sCloseTag</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">sCloseTagSawWhite</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">handleTextInRoot</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">handleTextOutsideRoot</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">pushAttribNS</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">pushAttribPlain</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* End parsing. This performs final well-formedness checks and resets the</span>
     <span class="s0">* parser to a clean state.</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s5">@returns </span><span class="s0">this</span>
     <span class="s0">*/</span>
    <span class="s2">private </span><span class="s1">end</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Resolve a namespace prefix.</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s5">@param </span><span class="s0">prefix The prefix to resolve.</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s5">@returns </span><span class="s0">The namespace URI or ``undefined`` if the prefix is not defined.</span>
     <span class="s0">*/</span>
    <span class="s1">resolve</span><span class="s3">(</span><span class="s1">prefix</span><span class="s3">: </span><span class="s1">string</span><span class="s3">): </span><span class="s1">string </span><span class="s3">| </span><span class="s1">undefined</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Parse a qname into its prefix and local name parts.</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s5">@param </span><span class="s0">name The name to parse</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s5">@returns</span>
     <span class="s0">*/</span>
    <span class="s2">private </span><span class="s1">qname</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">processAttribsNS</span><span class="s3">;</span>
    <span class="s2">private </span><span class="s1">processAttribsPlain</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Handle a complete open tag. This parser code calls this once it has seen</span>
     <span class="s0">* the whole tag. This method checks for well-formeness and then emits</span>
     <span class="s0">* ``onopentag``.</span>
     <span class="s0">*/</span>
    <span class="s2">private </span><span class="s1">openTag</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Handle a complete self-closing tag. This parser code calls this once it has</span>
     <span class="s0">* seen the whole tag. This method checks for well-formeness and then emits</span>
     <span class="s0">* ``onopentag`` and ``onclosetag``.</span>
     <span class="s0">*/</span>
    <span class="s2">private </span><span class="s1">openSelfClosingTag</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Handle a complete close tag. This parser code calls this once it has seen</span>
     <span class="s0">* the whole tag. This method checks for well-formeness and then emits</span>
     <span class="s0">* ``onclosetag``.</span>
     <span class="s0">*/</span>
    <span class="s2">private </span><span class="s1">closeTag</span><span class="s3">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Resolves an entity. Makes any necessary well-formedness checks.</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s5">@param </span><span class="s0">entity The entity to resolve.</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s5">@returns </span><span class="s0">The parsed entity.</span>
     <span class="s0">*/</span>
    <span class="s2">private </span><span class="s1">parseEntity</span><span class="s3">;</span>
<span class="s3">}</span>
</pre>
</body>
</html>