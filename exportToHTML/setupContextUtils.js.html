<html>
<head>
<title>setupContextUtils.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #6aab73;}
.s3 { color: #bcbec4;}
.s4 { color: #2aacb8;}
.s5 { color: #5f826b; font-style: italic;}
.s6 { color: #67a37c; font-style: italic;}
.s7 { color: #7a7e85;}
.s8 { color: #42c3d4;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
setupContextUtils.js</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">fs from </span><span class="s2">'fs'</span>
<span class="s0">import </span><span class="s1">url from </span><span class="s2">'url'</span>
<span class="s0">import </span><span class="s1">postcss from </span><span class="s2">'postcss'</span>
<span class="s0">import </span><span class="s1">dlv from </span><span class="s2">'dlv'</span>
<span class="s0">import </span><span class="s1">selectorParser from </span><span class="s2">'postcss-selector-parser'</span>

<span class="s0">import </span><span class="s1">transformThemeValue from </span><span class="s2">'../util/transformThemeValue'</span>
<span class="s0">import </span><span class="s1">parseObjectStyles from </span><span class="s2">'../util/parseObjectStyles'</span>
<span class="s0">import </span><span class="s1">prefixSelector from </span><span class="s2">'../util/prefixSelector'</span>
<span class="s0">import </span><span class="s1">isPlainObject from </span><span class="s2">'../util/isPlainObject'</span>
<span class="s0">import </span><span class="s1">escapeClassName from </span><span class="s2">'../util/escapeClassName'</span>
<span class="s0">import </span><span class="s1">nameClass</span><span class="s3">, { </span><span class="s1">formatClass </span><span class="s3">} </span><span class="s1">from </span><span class="s2">'../util/nameClass'</span>
<span class="s0">import </span><span class="s3">{ </span><span class="s1">coerceValue </span><span class="s3">} </span><span class="s1">from </span><span class="s2">'../util/pluginUtils'</span>
<span class="s0">import </span><span class="s3">{ </span><span class="s1">variantPlugins</span><span class="s3">, </span><span class="s1">corePlugins </span><span class="s3">} </span><span class="s1">from </span><span class="s2">'../corePlugins'</span>
<span class="s0">import </span><span class="s3">* as </span><span class="s1">sharedState from </span><span class="s2">'./sharedState'</span>
<span class="s0">import </span><span class="s3">{ </span><span class="s1">env </span><span class="s3">} </span><span class="s1">from </span><span class="s2">'./sharedState'</span>
<span class="s0">import </span><span class="s3">{ </span><span class="s1">toPath </span><span class="s3">} </span><span class="s1">from </span><span class="s2">'../util/toPath'</span>
<span class="s0">import </span><span class="s1">log from </span><span class="s2">'../util/log'</span>
<span class="s0">import </span><span class="s1">negateValue from </span><span class="s2">'../util/negateValue'</span>
<span class="s0">import </span><span class="s1">isSyntacticallyValidPropertyValue from </span><span class="s2">'../util/isSyntacticallyValidPropertyValue'</span>
<span class="s0">import </span><span class="s3">{ </span><span class="s1">generateRules</span><span class="s3">, </span><span class="s1">getClassNameFromSelector </span><span class="s3">} </span><span class="s1">from </span><span class="s2">'./generateRules'</span>
<span class="s0">import </span><span class="s3">{ </span><span class="s1">hasContentChanged </span><span class="s3">} </span><span class="s1">from </span><span class="s2">'./cacheInvalidation.js'</span>
<span class="s0">import </span><span class="s3">{ </span><span class="s1">Offsets </span><span class="s3">} </span><span class="s1">from </span><span class="s2">'./offsets.js'</span>
<span class="s0">import </span><span class="s3">{ </span><span class="s1">flagEnabled </span><span class="s3">} </span><span class="s1">from </span><span class="s2">'../featureFlags.js'</span>
<span class="s0">import </span><span class="s3">{ </span><span class="s1">finalizeSelector</span><span class="s3">, </span><span class="s1">formatVariantSelector </span><span class="s3">} </span><span class="s1">from </span><span class="s2">'../util/formatVariantSelector'</span>

<span class="s0">export const </span><span class="s1">INTERNAL_FEATURES </span><span class="s3">= </span><span class="s1">Symbol</span><span class="s3">()</span>

<span class="s0">const </span><span class="s1">VARIANT_TYPES </span><span class="s3">= {</span>
  <span class="s1">AddVariant</span><span class="s3">: </span><span class="s1">Symbol</span><span class="s3">.</span><span class="s1">for</span><span class="s3">(</span><span class="s2">'ADD_VARIANT'</span><span class="s3">),</span>
  <span class="s1">MatchVariant</span><span class="s3">: </span><span class="s1">Symbol</span><span class="s3">.</span><span class="s1">for</span><span class="s3">(</span><span class="s2">'MATCH_VARIANT'</span><span class="s3">),</span>
<span class="s3">}</span>

<span class="s0">const </span><span class="s1">VARIANT_INFO </span><span class="s3">= {</span>
  <span class="s1">Base</span><span class="s3">: </span><span class="s4">1 </span><span class="s3">&lt;&lt; </span><span class="s4">0</span><span class="s3">,</span>
  <span class="s1">Dynamic</span><span class="s3">: </span><span class="s4">1 </span><span class="s3">&lt;&lt; </span><span class="s4">1</span><span class="s3">,</span>
<span class="s3">}</span>

<span class="s0">function </span><span class="s1">prefix</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">selector</span><span class="s3">) {</span>
  <span class="s0">let </span><span class="s1">prefix </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">tailwindConfig</span><span class="s3">.</span><span class="s1">prefix</span>
  <span class="s0">return typeof </span><span class="s1">prefix </span><span class="s3">=== </span><span class="s2">'function' </span><span class="s3">? </span><span class="s1">prefix</span><span class="s3">(</span><span class="s1">selector</span><span class="s3">) : </span><span class="s1">prefix </span><span class="s3">+ </span><span class="s1">selector</span>
<span class="s3">}</span>

<span class="s0">function </span><span class="s1">normalizeOptionTypes</span><span class="s3">({ </span><span class="s1">type </span><span class="s3">= </span><span class="s2">'any'</span><span class="s3">, </span><span class="s1">...options </span><span class="s3">}) {</span>
  <span class="s0">let </span><span class="s1">types </span><span class="s3">= [].</span><span class="s1">concat</span><span class="s3">(</span><span class="s1">type</span><span class="s3">)</span>

  <span class="s0">return </span><span class="s3">{</span>
    <span class="s1">...options</span><span class="s3">,</span>
    <span class="s1">types</span><span class="s3">: </span><span class="s1">types</span><span class="s3">.</span><span class="s1">map</span><span class="s3">((</span><span class="s1">type</span><span class="s3">) =&gt; {</span>
      <span class="s0">if </span><span class="s3">(</span><span class="s1">Array</span><span class="s3">.</span><span class="s1">isArray</span><span class="s3">(</span><span class="s1">type</span><span class="s3">)) {</span>
        <span class="s0">return </span><span class="s3">{ </span><span class="s1">type</span><span class="s3">: </span><span class="s1">type</span><span class="s3">[</span><span class="s4">0</span><span class="s3">], </span><span class="s1">...type</span><span class="s3">[</span><span class="s4">1</span><span class="s3">] }</span>
      <span class="s3">}</span>
      <span class="s0">return </span><span class="s3">{ </span><span class="s1">type</span><span class="s3">, </span><span class="s1">preferOnConflict</span><span class="s3">: </span><span class="s0">false </span><span class="s3">}</span>
    <span class="s3">}),</span>
  <span class="s3">}</span>
<span class="s3">}</span>

<span class="s0">function </span><span class="s1">parseVariantFormatString</span><span class="s3">(</span><span class="s1">input</span><span class="s3">) {</span>
  <span class="s5">/** </span><span class="s6">@type </span><span class="s5">{string[]} */</span>
  <span class="s0">let </span><span class="s1">parts </span><span class="s3">= []</span>

  <span class="s7">// When parsing whitespace around special characters are insignificant</span>
  <span class="s7">// However, _inside_ of a variant they could be</span>
  <span class="s7">// Because the selector could look like this</span>
  <span class="s7">// @media { &amp;[data-name=&quot;foo bar&quot;] }</span>
  <span class="s7">// This is why we do not skip whitespace</span>

  <span class="s0">let </span><span class="s1">current </span><span class="s3">= </span><span class="s2">''</span>
  <span class="s0">let </span><span class="s1">depth </span><span class="s3">= </span><span class="s4">0</span>

  <span class="s0">for </span><span class="s3">(</span><span class="s0">let </span><span class="s1">idx </span><span class="s3">= </span><span class="s4">0</span><span class="s3">; </span><span class="s1">idx </span><span class="s3">&lt; </span><span class="s1">input</span><span class="s3">.</span><span class="s1">length</span><span class="s3">; </span><span class="s1">idx</span><span class="s3">++) {</span>
    <span class="s0">let </span><span class="s1">char </span><span class="s3">= </span><span class="s1">input</span><span class="s3">[</span><span class="s1">idx</span><span class="s3">]</span>

    <span class="s0">if </span><span class="s3">(</span><span class="s1">char </span><span class="s3">=== </span><span class="s2">'</span><span class="s0">\\</span><span class="s2">'</span><span class="s3">) {</span>
      <span class="s7">// Escaped characters are not special</span>
      <span class="s1">current </span><span class="s3">+= </span><span class="s2">'</span><span class="s0">\\</span><span class="s2">' </span><span class="s3">+ </span><span class="s1">input</span><span class="s3">[++</span><span class="s1">idx</span><span class="s3">]</span>
    <span class="s3">} </span><span class="s0">else if </span><span class="s3">(</span><span class="s1">char </span><span class="s3">=== </span><span class="s2">'{'</span><span class="s3">) {</span>
      <span class="s7">// Nested rule: start</span>
      <span class="s3">++</span><span class="s1">depth</span>
      <span class="s1">parts</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">current</span><span class="s3">.</span><span class="s1">trim</span><span class="s3">())</span>
      <span class="s1">current </span><span class="s3">= </span><span class="s2">''</span>
    <span class="s3">} </span><span class="s0">else if </span><span class="s3">(</span><span class="s1">char </span><span class="s3">=== </span><span class="s2">'}'</span><span class="s3">) {</span>
      <span class="s7">// Nested rule: end</span>
      <span class="s0">if </span><span class="s3">(--</span><span class="s1">depth </span><span class="s3">&lt; </span><span class="s4">0</span><span class="s3">) {</span>
        <span class="s0">throw new </span><span class="s1">Error</span><span class="s3">(</span><span class="s2">`Your { and } are unbalanced.`</span><span class="s3">)</span>
      <span class="s3">}</span>

      <span class="s1">parts</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">current</span><span class="s3">.</span><span class="s1">trim</span><span class="s3">())</span>
      <span class="s1">current </span><span class="s3">= </span><span class="s2">''</span>
    <span class="s3">} </span><span class="s0">else </span><span class="s3">{</span>
      <span class="s7">// Normal character</span>
      <span class="s1">current </span><span class="s3">+= </span><span class="s1">char</span>
    <span class="s3">}</span>
  <span class="s3">}</span>

  <span class="s0">if </span><span class="s3">(</span><span class="s1">current</span><span class="s3">.</span><span class="s1">length </span><span class="s3">&gt; </span><span class="s4">0</span><span class="s3">) {</span>
    <span class="s1">parts</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">current</span><span class="s3">.</span><span class="s1">trim</span><span class="s3">())</span>
  <span class="s3">}</span>

  <span class="s1">parts </span><span class="s3">= </span><span class="s1">parts</span><span class="s3">.</span><span class="s1">filter</span><span class="s3">((</span><span class="s1">part</span><span class="s3">) =&gt; </span><span class="s1">part </span><span class="s3">!== </span><span class="s2">''</span><span class="s3">)</span>

  <span class="s0">return </span><span class="s1">parts</span>
<span class="s3">}</span>

<span class="s0">function </span><span class="s1">insertInto</span><span class="s3">(</span><span class="s1">list</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, { </span><span class="s1">before </span><span class="s3">= [] } = {}) {</span>
  <span class="s1">before </span><span class="s3">= [].</span><span class="s1">concat</span><span class="s3">(</span><span class="s1">before</span><span class="s3">)</span>

  <span class="s0">if </span><span class="s3">(</span><span class="s1">before</span><span class="s3">.</span><span class="s1">length </span><span class="s3">&lt;= </span><span class="s4">0</span><span class="s3">) {</span>
    <span class="s1">list</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">value</span><span class="s3">)</span>
    <span class="s0">return</span>
  <span class="s3">}</span>

  <span class="s0">let </span><span class="s1">idx </span><span class="s3">= </span><span class="s1">list</span><span class="s3">.</span><span class="s1">length </span><span class="s3">- </span><span class="s4">1</span>
  <span class="s0">for </span><span class="s3">(</span><span class="s0">let </span><span class="s1">other of before</span><span class="s3">) {</span>
    <span class="s0">let </span><span class="s1">iidx </span><span class="s3">= </span><span class="s1">list</span><span class="s3">.</span><span class="s1">indexOf</span><span class="s3">(</span><span class="s1">other</span><span class="s3">)</span>
    <span class="s0">if </span><span class="s3">(</span><span class="s1">iidx </span><span class="s3">=== -</span><span class="s4">1</span><span class="s3">) </span><span class="s0">continue</span>
    <span class="s1">idx </span><span class="s3">= </span><span class="s1">Math</span><span class="s3">.</span><span class="s1">min</span><span class="s3">(</span><span class="s1">idx</span><span class="s3">, </span><span class="s1">iidx</span><span class="s3">)</span>
  <span class="s3">}</span>

  <span class="s1">list</span><span class="s3">.</span><span class="s1">splice</span><span class="s3">(</span><span class="s1">idx</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s1">value</span><span class="s3">)</span>
<span class="s3">}</span>

<span class="s0">function </span><span class="s1">parseStyles</span><span class="s3">(</span><span class="s1">styles</span><span class="s3">) {</span>
  <span class="s0">if </span><span class="s3">(!</span><span class="s1">Array</span><span class="s3">.</span><span class="s1">isArray</span><span class="s3">(</span><span class="s1">styles</span><span class="s3">)) {</span>
    <span class="s0">return </span><span class="s1">parseStyles</span><span class="s3">([</span><span class="s1">styles</span><span class="s3">])</span>
  <span class="s3">}</span>

  <span class="s0">return </span><span class="s1">styles</span><span class="s3">.</span><span class="s1">flatMap</span><span class="s3">((</span><span class="s1">style</span><span class="s3">) =&gt; {</span>
    <span class="s0">let </span><span class="s1">isNode </span><span class="s3">= !</span><span class="s1">Array</span><span class="s3">.</span><span class="s1">isArray</span><span class="s3">(</span><span class="s1">style</span><span class="s3">) &amp;&amp; !</span><span class="s1">isPlainObject</span><span class="s3">(</span><span class="s1">style</span><span class="s3">)</span>
    <span class="s0">return </span><span class="s1">isNode </span><span class="s3">? </span><span class="s1">style </span><span class="s3">: </span><span class="s1">parseObjectStyles</span><span class="s3">(</span><span class="s1">style</span><span class="s3">)</span>
  <span class="s3">})</span>
<span class="s3">}</span>

<span class="s0">function </span><span class="s1">getClasses</span><span class="s3">(</span><span class="s1">selector</span><span class="s3">, </span><span class="s1">mutate</span><span class="s3">) {</span>
  <span class="s0">let </span><span class="s1">parser </span><span class="s3">= </span><span class="s1">selectorParser</span><span class="s3">((</span><span class="s1">selectors</span><span class="s3">) =&gt; {</span>
    <span class="s0">let </span><span class="s1">allClasses </span><span class="s3">= []</span>

    <span class="s0">if </span><span class="s3">(</span><span class="s1">mutate</span><span class="s3">) {</span>
      <span class="s1">mutate</span><span class="s3">(</span><span class="s1">selectors</span><span class="s3">)</span>
    <span class="s3">}</span>

    <span class="s1">selectors</span><span class="s3">.</span><span class="s1">walkClasses</span><span class="s3">((</span><span class="s1">classNode</span><span class="s3">) =&gt; {</span>
      <span class="s1">allClasses</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">classNode</span><span class="s3">.</span><span class="s1">value</span><span class="s3">)</span>
    <span class="s3">})</span>

    <span class="s0">return </span><span class="s1">allClasses</span>
  <span class="s3">})</span>
  <span class="s0">return </span><span class="s1">parser</span><span class="s3">.</span><span class="s1">transformSync</span><span class="s3">(</span><span class="s1">selector</span><span class="s3">)</span>
<span class="s3">}</span>

<span class="s5">/**</span>
 <span class="s5">* Ignore everything inside a :not(...). This allows you to write code like</span>
 <span class="s5">* `div:not(.foo)`. If `.foo` is never found in your code, then we used to</span>
 <span class="s5">* not generated it. But now we will ignore everything inside a `:not`, so</span>
 <span class="s5">* that it still gets generated.</span>
 <span class="s5">*</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{selectorParser.Root} selectors</span>
 <span class="s5">*/</span>
<span class="s0">function </span><span class="s1">ignoreNot</span><span class="s3">(</span><span class="s1">selectors</span><span class="s3">) {</span>
  <span class="s1">selectors</span><span class="s3">.</span><span class="s1">walkPseudos</span><span class="s3">((</span><span class="s1">pseudo</span><span class="s3">) =&gt; {</span>
    <span class="s0">if </span><span class="s3">(</span><span class="s1">pseudo</span><span class="s3">.</span><span class="s1">value </span><span class="s3">=== </span><span class="s2">':not'</span><span class="s3">) {</span>
      <span class="s1">pseudo</span><span class="s3">.</span><span class="s1">remove</span><span class="s3">()</span>
    <span class="s3">}</span>
  <span class="s3">})</span>
<span class="s3">}</span>

<span class="s0">function </span><span class="s1">extractCandidates</span><span class="s3">(</span><span class="s1">node</span><span class="s3">, </span><span class="s1">state </span><span class="s3">= { </span><span class="s1">containsNonOnDemandable</span><span class="s3">: </span><span class="s0">false </span><span class="s3">}, </span><span class="s1">depth </span><span class="s3">= </span><span class="s4">0</span><span class="s3">) {</span>
  <span class="s0">let </span><span class="s1">classes </span><span class="s3">= []</span>
  <span class="s0">let </span><span class="s1">selectors </span><span class="s3">= []</span>

  <span class="s0">if </span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'rule'</span><span class="s3">) {</span>
    <span class="s7">// Handle normal rules</span>
    <span class="s1">selectors</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">...node</span><span class="s3">.</span><span class="s1">selectors</span><span class="s3">)</span>
  <span class="s3">} </span><span class="s0">else if </span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'atrule'</span><span class="s3">) {</span>
    <span class="s7">// Handle at-rules (which contains nested rules)</span>
    <span class="s1">node</span><span class="s3">.</span><span class="s1">walkRules</span><span class="s3">((</span><span class="s1">rule</span><span class="s3">) =&gt; </span><span class="s1">selectors</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">...rule</span><span class="s3">.</span><span class="s1">selectors</span><span class="s3">))</span>
  <span class="s3">}</span>

  <span class="s0">for </span><span class="s3">(</span><span class="s0">let </span><span class="s1">selector of selectors</span><span class="s3">) {</span>
    <span class="s0">let </span><span class="s1">classCandidates </span><span class="s3">= </span><span class="s1">getClasses</span><span class="s3">(</span><span class="s1">selector</span><span class="s3">, </span><span class="s1">ignoreNot</span><span class="s3">)</span>

    <span class="s7">// At least one of the selectors contains non-&quot;on-demandable&quot; candidates.</span>
    <span class="s0">if </span><span class="s3">(</span><span class="s1">classCandidates</span><span class="s3">.</span><span class="s1">length </span><span class="s3">=== </span><span class="s4">0</span><span class="s3">) {</span>
      <span class="s1">state</span><span class="s3">.</span><span class="s1">containsNonOnDemandable </span><span class="s3">= </span><span class="s0">true</span>
    <span class="s3">}</span>

    <span class="s0">for </span><span class="s3">(</span><span class="s0">let </span><span class="s1">classCandidate of classCandidates</span><span class="s3">) {</span>
      <span class="s1">classes</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">classCandidate</span><span class="s3">)</span>
    <span class="s3">}</span>
  <span class="s3">}</span>

  <span class="s0">if </span><span class="s3">(</span><span class="s1">depth </span><span class="s3">=== </span><span class="s4">0</span><span class="s3">) {</span>
    <span class="s0">return </span><span class="s3">[</span><span class="s1">state</span><span class="s3">.</span><span class="s1">containsNonOnDemandable </span><span class="s3">|| </span><span class="s1">classes</span><span class="s3">.</span><span class="s1">length </span><span class="s3">=== </span><span class="s4">0</span><span class="s3">, </span><span class="s1">classes</span><span class="s3">]</span>
  <span class="s3">}</span>

  <span class="s0">return </span><span class="s1">classes</span>
<span class="s3">}</span>

<span class="s0">function </span><span class="s1">withIdentifiers</span><span class="s3">(</span><span class="s1">styles</span><span class="s3">) {</span>
  <span class="s0">return </span><span class="s1">parseStyles</span><span class="s3">(</span><span class="s1">styles</span><span class="s3">).</span><span class="s1">flatMap</span><span class="s3">((</span><span class="s1">node</span><span class="s3">) =&gt; {</span>
    <span class="s0">let </span><span class="s1">nodeMap </span><span class="s3">= </span><span class="s0">new </span><span class="s1">Map</span><span class="s3">()</span>
    <span class="s0">let </span><span class="s3">[</span><span class="s1">containsNonOnDemandableSelectors</span><span class="s3">, </span><span class="s1">candidates</span><span class="s3">] = </span><span class="s1">extractCandidates</span><span class="s3">(</span><span class="s1">node</span><span class="s3">)</span>

    <span class="s7">// If this isn't &quot;on-demandable&quot;, assign it a universal candidate to always include it.</span>
    <span class="s0">if </span><span class="s3">(</span><span class="s1">containsNonOnDemandableSelectors</span><span class="s3">) {</span>
      <span class="s1">candidates</span><span class="s3">.</span><span class="s1">unshift</span><span class="s3">(</span><span class="s1">sharedState</span><span class="s3">.</span><span class="s1">NOT_ON_DEMAND</span><span class="s3">)</span>
    <span class="s3">}</span>

    <span class="s7">// However, it could be that it also contains &quot;on-demandable&quot; candidates.</span>
    <span class="s7">// E.g.: `span, .foo {}`, in that case it should still be possible to use</span>
    <span class="s7">// `@apply foo` for example.</span>
    <span class="s0">return </span><span class="s1">candidates</span><span class="s3">.</span><span class="s1">map</span><span class="s3">((</span><span class="s1">c</span><span class="s3">) =&gt; {</span>
      <span class="s0">if </span><span class="s3">(!</span><span class="s1">nodeMap</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s1">node</span><span class="s3">)) {</span>
        <span class="s1">nodeMap</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">node</span><span class="s3">, </span><span class="s1">node</span><span class="s3">)</span>
      <span class="s3">}</span>
      <span class="s0">return </span><span class="s3">[</span><span class="s1">c</span><span class="s3">, </span><span class="s1">nodeMap</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">node</span><span class="s3">)]</span>
    <span class="s3">})</span>
  <span class="s3">})</span>
<span class="s3">}</span>

<span class="s0">export function </span><span class="s1">isValidVariantFormatString</span><span class="s3">(</span><span class="s1">format</span><span class="s3">) {</span>
  <span class="s0">return </span><span class="s1">format</span><span class="s3">.</span><span class="s1">startsWith</span><span class="s3">(</span><span class="s2">'@'</span><span class="s3">) || </span><span class="s1">format</span><span class="s3">.</span><span class="s1">includes</span><span class="s3">(</span><span class="s2">'&amp;'</span><span class="s3">)</span>
<span class="s3">}</span>

<span class="s0">export function </span><span class="s1">parseVariant</span><span class="s3">(</span><span class="s1">variant</span><span class="s3">) {</span>
  <span class="s1">variant </span><span class="s3">= </span><span class="s1">variant</span>
    <span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span><span class="s8">/\n+/g</span><span class="s3">, </span><span class="s2">''</span><span class="s3">)</span>
    <span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span><span class="s8">/\s{1,}/g</span><span class="s3">, </span><span class="s2">' '</span><span class="s3">)</span>
    <span class="s3">.</span><span class="s1">trim</span><span class="s3">()</span>

  <span class="s0">let </span><span class="s1">fns </span><span class="s3">= </span><span class="s1">parseVariantFormatString</span><span class="s3">(</span><span class="s1">variant</span><span class="s3">)</span>
    <span class="s3">.</span><span class="s1">map</span><span class="s3">((</span><span class="s1">str</span><span class="s3">) =&gt; {</span>
      <span class="s0">if </span><span class="s3">(!</span><span class="s1">str</span><span class="s3">.</span><span class="s1">startsWith</span><span class="s3">(</span><span class="s2">'@'</span><span class="s3">)) {</span>
        <span class="s0">return </span><span class="s3">({ </span><span class="s1">format </span><span class="s3">}) =&gt; </span><span class="s1">format</span><span class="s3">(</span><span class="s1">str</span><span class="s3">)</span>
      <span class="s3">}</span>

      <span class="s0">let </span><span class="s3">[, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">params</span><span class="s3">] = </span><span class="s8">/@(\S*)( .+|[({].*)?/g</span><span class="s3">.</span><span class="s1">exec</span><span class="s3">(</span><span class="s1">str</span><span class="s3">)</span>
      <span class="s0">return </span><span class="s3">({ </span><span class="s1">wrap </span><span class="s3">}) =&gt; </span><span class="s1">wrap</span><span class="s3">(</span><span class="s1">postcss</span><span class="s3">.</span><span class="s1">atRule</span><span class="s3">({ </span><span class="s1">name</span><span class="s3">, </span><span class="s1">params</span><span class="s3">: </span><span class="s1">params</span><span class="s3">?.</span><span class="s1">trim</span><span class="s3">() ?? </span><span class="s2">'' </span><span class="s3">}))</span>
    <span class="s3">})</span>
    <span class="s3">.</span><span class="s1">reverse</span><span class="s3">()</span>

  <span class="s0">return </span><span class="s3">(</span><span class="s1">api</span><span class="s3">) =&gt; {</span>
    <span class="s0">for </span><span class="s3">(</span><span class="s0">let </span><span class="s1">fn of fns</span><span class="s3">) {</span>
      <span class="s1">fn</span><span class="s3">(</span><span class="s1">api</span><span class="s3">)</span>
    <span class="s3">}</span>
  <span class="s3">}</span>
<span class="s3">}</span>

<span class="s5">/**</span>
 <span class="s5">*</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{any} tailwindConfig</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{any} context</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{object} param2</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Offsets} param2.offsets</span>
 <span class="s5">*/</span>
<span class="s0">function </span><span class="s1">buildPluginApi</span><span class="s3">(</span><span class="s1">tailwindConfig</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, { </span><span class="s1">variantList</span><span class="s3">, </span><span class="s1">variantMap</span><span class="s3">, </span><span class="s1">offsets</span><span class="s3">, </span><span class="s1">classList </span><span class="s3">}) {</span>
  <span class="s0">function </span><span class="s1">getConfigValue</span><span class="s3">(</span><span class="s1">path</span><span class="s3">, </span><span class="s1">defaultValue</span><span class="s3">) {</span>
    <span class="s0">return </span><span class="s1">path </span><span class="s3">? </span><span class="s1">dlv</span><span class="s3">(</span><span class="s1">tailwindConfig</span><span class="s3">, </span><span class="s1">path</span><span class="s3">, </span><span class="s1">defaultValue</span><span class="s3">) : </span><span class="s1">tailwindConfig</span>
  <span class="s3">}</span>

  <span class="s0">function </span><span class="s1">applyConfiguredPrefix</span><span class="s3">(</span><span class="s1">selector</span><span class="s3">) {</span>
    <span class="s0">return </span><span class="s1">prefixSelector</span><span class="s3">(</span><span class="s1">tailwindConfig</span><span class="s3">.</span><span class="s1">prefix</span><span class="s3">, </span><span class="s1">selector</span><span class="s3">)</span>
  <span class="s3">}</span>

  <span class="s0">function </span><span class="s1">prefixIdentifier</span><span class="s3">(</span><span class="s1">identifier</span><span class="s3">, </span><span class="s1">options</span><span class="s3">) {</span>
    <span class="s0">if </span><span class="s3">(</span><span class="s1">identifier </span><span class="s3">=== </span><span class="s1">sharedState</span><span class="s3">.</span><span class="s1">NOT_ON_DEMAND</span><span class="s3">) {</span>
      <span class="s0">return </span><span class="s1">sharedState</span><span class="s3">.</span><span class="s1">NOT_ON_DEMAND</span>
    <span class="s3">}</span>

    <span class="s0">if </span><span class="s3">(!</span><span class="s1">options</span><span class="s3">.</span><span class="s1">respectPrefix</span><span class="s3">) {</span>
      <span class="s0">return </span><span class="s1">identifier</span>
    <span class="s3">}</span>

    <span class="s0">return </span><span class="s1">context</span><span class="s3">.</span><span class="s1">tailwindConfig</span><span class="s3">.</span><span class="s1">prefix </span><span class="s3">+ </span><span class="s1">identifier</span>
  <span class="s3">}</span>

  <span class="s0">function </span><span class="s1">resolveThemeValue</span><span class="s3">(</span><span class="s1">path</span><span class="s3">, </span><span class="s1">defaultValue</span><span class="s3">, </span><span class="s1">opts </span><span class="s3">= {}) {</span>
    <span class="s0">let </span><span class="s1">parts </span><span class="s3">= </span><span class="s1">toPath</span><span class="s3">(</span><span class="s1">path</span><span class="s3">)</span>
    <span class="s0">let </span><span class="s1">value </span><span class="s3">= </span><span class="s1">getConfigValue</span><span class="s3">([</span><span class="s2">'theme'</span><span class="s3">, </span><span class="s1">...parts</span><span class="s3">], </span><span class="s1">defaultValue</span><span class="s3">)</span>
    <span class="s0">return </span><span class="s1">transformThemeValue</span><span class="s3">(</span><span class="s1">parts</span><span class="s3">[</span><span class="s4">0</span><span class="s3">])(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">opts</span><span class="s3">)</span>
  <span class="s3">}</span>

  <span class="s0">let </span><span class="s1">variantIdentifier </span><span class="s3">= </span><span class="s4">0</span>
  <span class="s0">let </span><span class="s1">api </span><span class="s3">= {</span>
    <span class="s1">postcss</span><span class="s3">,</span>
    <span class="s1">prefix</span><span class="s3">: </span><span class="s1">applyConfiguredPrefix</span><span class="s3">,</span>
    <span class="s1">e</span><span class="s3">: </span><span class="s1">escapeClassName</span><span class="s3">,</span>
    <span class="s1">config</span><span class="s3">: </span><span class="s1">getConfigValue</span><span class="s3">,</span>
    <span class="s1">theme</span><span class="s3">: </span><span class="s1">resolveThemeValue</span><span class="s3">,</span>
    <span class="s1">corePlugins</span><span class="s3">: (</span><span class="s1">path</span><span class="s3">) =&gt; {</span>
      <span class="s0">if </span><span class="s3">(</span><span class="s1">Array</span><span class="s3">.</span><span class="s1">isArray</span><span class="s3">(</span><span class="s1">tailwindConfig</span><span class="s3">.</span><span class="s1">corePlugins</span><span class="s3">)) {</span>
        <span class="s0">return </span><span class="s1">tailwindConfig</span><span class="s3">.</span><span class="s1">corePlugins</span><span class="s3">.</span><span class="s1">includes</span><span class="s3">(</span><span class="s1">path</span><span class="s3">)</span>
      <span class="s3">}</span>

      <span class="s0">return </span><span class="s1">getConfigValue</span><span class="s3">([</span><span class="s2">'corePlugins'</span><span class="s3">, </span><span class="s1">path</span><span class="s3">], </span><span class="s0">true</span><span class="s3">)</span>
    <span class="s3">},</span>
    <span class="s1">variants</span><span class="s3">: () =&gt; {</span>
      <span class="s7">// Preserved for backwards compatibility but not used in v3.0+</span>
      <span class="s0">return </span><span class="s3">[]</span>
    <span class="s3">},</span>
    <span class="s1">addBase</span><span class="s3">(</span><span class="s1">base</span><span class="s3">) {</span>
      <span class="s0">for </span><span class="s3">(</span><span class="s0">let </span><span class="s3">[</span><span class="s1">identifier</span><span class="s3">, </span><span class="s1">rule</span><span class="s3">] </span><span class="s1">of withIdentifiers</span><span class="s3">(</span><span class="s1">base</span><span class="s3">)) {</span>
        <span class="s0">let </span><span class="s1">prefixedIdentifier </span><span class="s3">= </span><span class="s1">prefixIdentifier</span><span class="s3">(</span><span class="s1">identifier</span><span class="s3">, {})</span>
        <span class="s0">let </span><span class="s1">offset </span><span class="s3">= </span><span class="s1">offsets</span><span class="s3">.</span><span class="s1">create</span><span class="s3">(</span><span class="s2">'base'</span><span class="s3">)</span>

        <span class="s0">if </span><span class="s3">(!</span><span class="s1">context</span><span class="s3">.</span><span class="s1">candidateRuleMap</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s1">prefixedIdentifier</span><span class="s3">)) {</span>
          <span class="s1">context</span><span class="s3">.</span><span class="s1">candidateRuleMap</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">prefixedIdentifier</span><span class="s3">, [])</span>
        <span class="s3">}</span>

        <span class="s1">context</span><span class="s3">.</span><span class="s1">candidateRuleMap</span>
          <span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">prefixedIdentifier</span><span class="s3">)</span>
          <span class="s3">.</span><span class="s1">push</span><span class="s3">([{ </span><span class="s1">sort</span><span class="s3">: </span><span class="s1">offset</span><span class="s3">, </span><span class="s1">layer</span><span class="s3">: </span><span class="s2">'base' </span><span class="s3">}, </span><span class="s1">rule</span><span class="s3">])</span>
      <span class="s3">}</span>
    <span class="s3">},</span>
    <span class="s5">/**</span>
     <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string} group</span>
     <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Record&lt;string, string | string[]&gt;} declarations</span>
     <span class="s5">*/</span>
    <span class="s1">addDefaults</span><span class="s3">(</span><span class="s1">group</span><span class="s3">, </span><span class="s1">declarations</span><span class="s3">) {</span>
      <span class="s0">const </span><span class="s1">groups </span><span class="s3">= {</span>
        <span class="s3">[</span><span class="s2">`@defaults </span><span class="s1">$</span><span class="s3">{</span><span class="s1">group</span><span class="s3">}</span><span class="s2">`</span><span class="s3">]: </span><span class="s1">declarations</span><span class="s3">,</span>
      <span class="s3">}</span>

      <span class="s0">for </span><span class="s3">(</span><span class="s0">let </span><span class="s3">[</span><span class="s1">identifier</span><span class="s3">, </span><span class="s1">rule</span><span class="s3">] </span><span class="s1">of withIdentifiers</span><span class="s3">(</span><span class="s1">groups</span><span class="s3">)) {</span>
        <span class="s0">let </span><span class="s1">prefixedIdentifier </span><span class="s3">= </span><span class="s1">prefixIdentifier</span><span class="s3">(</span><span class="s1">identifier</span><span class="s3">, {})</span>

        <span class="s0">if </span><span class="s3">(!</span><span class="s1">context</span><span class="s3">.</span><span class="s1">candidateRuleMap</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s1">prefixedIdentifier</span><span class="s3">)) {</span>
          <span class="s1">context</span><span class="s3">.</span><span class="s1">candidateRuleMap</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">prefixedIdentifier</span><span class="s3">, [])</span>
        <span class="s3">}</span>

        <span class="s1">context</span><span class="s3">.</span><span class="s1">candidateRuleMap</span>
          <span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">prefixedIdentifier</span><span class="s3">)</span>
          <span class="s3">.</span><span class="s1">push</span><span class="s3">([{ </span><span class="s1">sort</span><span class="s3">: </span><span class="s1">offsets</span><span class="s3">.</span><span class="s1">create</span><span class="s3">(</span><span class="s2">'defaults'</span><span class="s3">), </span><span class="s1">layer</span><span class="s3">: </span><span class="s2">'defaults' </span><span class="s3">}, </span><span class="s1">rule</span><span class="s3">])</span>
      <span class="s3">}</span>
    <span class="s3">},</span>
    <span class="s1">addComponents</span><span class="s3">(</span><span class="s1">components</span><span class="s3">, </span><span class="s1">options</span><span class="s3">) {</span>
      <span class="s0">let </span><span class="s1">defaultOptions </span><span class="s3">= {</span>
        <span class="s1">preserveSource</span><span class="s3">: </span><span class="s0">false</span><span class="s3">,</span>
        <span class="s1">respectPrefix</span><span class="s3">: </span><span class="s0">true</span><span class="s3">,</span>
        <span class="s1">respectImportant</span><span class="s3">: </span><span class="s0">false</span><span class="s3">,</span>
      <span class="s3">}</span>

      <span class="s1">options </span><span class="s3">= </span><span class="s1">Object</span><span class="s3">.</span><span class="s1">assign</span><span class="s3">({}, </span><span class="s1">defaultOptions</span><span class="s3">, </span><span class="s1">Array</span><span class="s3">.</span><span class="s1">isArray</span><span class="s3">(</span><span class="s1">options</span><span class="s3">) ? {} : </span><span class="s1">options</span><span class="s3">)</span>

      <span class="s0">for </span><span class="s3">(</span><span class="s0">let </span><span class="s3">[</span><span class="s1">identifier</span><span class="s3">, </span><span class="s1">rule</span><span class="s3">] </span><span class="s1">of withIdentifiers</span><span class="s3">(</span><span class="s1">components</span><span class="s3">)) {</span>
        <span class="s0">let </span><span class="s1">prefixedIdentifier </span><span class="s3">= </span><span class="s1">prefixIdentifier</span><span class="s3">(</span><span class="s1">identifier</span><span class="s3">, </span><span class="s1">options</span><span class="s3">)</span>

        <span class="s1">classList</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">prefixedIdentifier</span><span class="s3">)</span>

        <span class="s0">if </span><span class="s3">(!</span><span class="s1">context</span><span class="s3">.</span><span class="s1">candidateRuleMap</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s1">prefixedIdentifier</span><span class="s3">)) {</span>
          <span class="s1">context</span><span class="s3">.</span><span class="s1">candidateRuleMap</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">prefixedIdentifier</span><span class="s3">, [])</span>
        <span class="s3">}</span>

        <span class="s1">context</span><span class="s3">.</span><span class="s1">candidateRuleMap</span>
          <span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">prefixedIdentifier</span><span class="s3">)</span>
          <span class="s3">.</span><span class="s1">push</span><span class="s3">([{ </span><span class="s1">sort</span><span class="s3">: </span><span class="s1">offsets</span><span class="s3">.</span><span class="s1">create</span><span class="s3">(</span><span class="s2">'components'</span><span class="s3">), </span><span class="s1">layer</span><span class="s3">: </span><span class="s2">'components'</span><span class="s3">, </span><span class="s1">options </span><span class="s3">}, </span><span class="s1">rule</span><span class="s3">])</span>
      <span class="s3">}</span>
    <span class="s3">},</span>
    <span class="s1">addUtilities</span><span class="s3">(</span><span class="s1">utilities</span><span class="s3">, </span><span class="s1">options</span><span class="s3">) {</span>
      <span class="s0">let </span><span class="s1">defaultOptions </span><span class="s3">= {</span>
        <span class="s1">preserveSource</span><span class="s3">: </span><span class="s0">false</span><span class="s3">,</span>
        <span class="s1">respectPrefix</span><span class="s3">: </span><span class="s0">true</span><span class="s3">,</span>
        <span class="s1">respectImportant</span><span class="s3">: </span><span class="s0">true</span><span class="s3">,</span>
      <span class="s3">}</span>

      <span class="s1">options </span><span class="s3">= </span><span class="s1">Object</span><span class="s3">.</span><span class="s1">assign</span><span class="s3">({}, </span><span class="s1">defaultOptions</span><span class="s3">, </span><span class="s1">Array</span><span class="s3">.</span><span class="s1">isArray</span><span class="s3">(</span><span class="s1">options</span><span class="s3">) ? {} : </span><span class="s1">options</span><span class="s3">)</span>

      <span class="s0">for </span><span class="s3">(</span><span class="s0">let </span><span class="s3">[</span><span class="s1">identifier</span><span class="s3">, </span><span class="s1">rule</span><span class="s3">] </span><span class="s1">of withIdentifiers</span><span class="s3">(</span><span class="s1">utilities</span><span class="s3">)) {</span>
        <span class="s0">let </span><span class="s1">prefixedIdentifier </span><span class="s3">= </span><span class="s1">prefixIdentifier</span><span class="s3">(</span><span class="s1">identifier</span><span class="s3">, </span><span class="s1">options</span><span class="s3">)</span>

        <span class="s1">classList</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">prefixedIdentifier</span><span class="s3">)</span>

        <span class="s0">if </span><span class="s3">(!</span><span class="s1">context</span><span class="s3">.</span><span class="s1">candidateRuleMap</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s1">prefixedIdentifier</span><span class="s3">)) {</span>
          <span class="s1">context</span><span class="s3">.</span><span class="s1">candidateRuleMap</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">prefixedIdentifier</span><span class="s3">, [])</span>
        <span class="s3">}</span>

        <span class="s1">context</span><span class="s3">.</span><span class="s1">candidateRuleMap</span>
          <span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">prefixedIdentifier</span><span class="s3">)</span>
          <span class="s3">.</span><span class="s1">push</span><span class="s3">([{ </span><span class="s1">sort</span><span class="s3">: </span><span class="s1">offsets</span><span class="s3">.</span><span class="s1">create</span><span class="s3">(</span><span class="s2">'utilities'</span><span class="s3">), </span><span class="s1">layer</span><span class="s3">: </span><span class="s2">'utilities'</span><span class="s3">, </span><span class="s1">options </span><span class="s3">}, </span><span class="s1">rule</span><span class="s3">])</span>
      <span class="s3">}</span>
    <span class="s3">},</span>
    <span class="s1">matchUtilities</span><span class="s3">: </span><span class="s0">function </span><span class="s3">(</span><span class="s1">utilities</span><span class="s3">, </span><span class="s1">options</span><span class="s3">) {</span>
      <span class="s0">let </span><span class="s1">defaultOptions </span><span class="s3">= {</span>
        <span class="s1">respectPrefix</span><span class="s3">: </span><span class="s0">true</span><span class="s3">,</span>
        <span class="s1">respectImportant</span><span class="s3">: </span><span class="s0">true</span><span class="s3">,</span>
        <span class="s1">modifiers</span><span class="s3">: </span><span class="s0">false</span><span class="s3">,</span>
      <span class="s3">}</span>

      <span class="s1">options </span><span class="s3">= </span><span class="s1">normalizeOptionTypes</span><span class="s3">({ </span><span class="s1">...defaultOptions</span><span class="s3">, </span><span class="s1">...options </span><span class="s3">})</span>

      <span class="s0">let </span><span class="s1">offset </span><span class="s3">= </span><span class="s1">offsets</span><span class="s3">.</span><span class="s1">create</span><span class="s3">(</span><span class="s2">'utilities'</span><span class="s3">)</span>

      <span class="s0">for </span><span class="s3">(</span><span class="s0">let </span><span class="s1">identifier </span><span class="s0">in </span><span class="s1">utilities</span><span class="s3">) {</span>
        <span class="s0">let </span><span class="s1">prefixedIdentifier </span><span class="s3">= </span><span class="s1">prefixIdentifier</span><span class="s3">(</span><span class="s1">identifier</span><span class="s3">, </span><span class="s1">options</span><span class="s3">)</span>
        <span class="s0">let </span><span class="s1">rule </span><span class="s3">= </span><span class="s1">utilities</span><span class="s3">[</span><span class="s1">identifier</span><span class="s3">]</span>

        <span class="s1">classList</span><span class="s3">.</span><span class="s1">add</span><span class="s3">([</span><span class="s1">prefixedIdentifier</span><span class="s3">, </span><span class="s1">options</span><span class="s3">])</span>

        <span class="s0">function </span><span class="s1">wrapped</span><span class="s3">(</span><span class="s1">modifier</span><span class="s3">, { </span><span class="s1">isOnlyPlugin </span><span class="s3">}) {</span>
          <span class="s0">let </span><span class="s3">[</span><span class="s1">value</span><span class="s3">, </span><span class="s1">coercedType</span><span class="s3">, </span><span class="s1">utilityModifier</span><span class="s3">] = </span><span class="s1">coerceValue</span><span class="s3">(</span>
            <span class="s1">options</span><span class="s3">.</span><span class="s1">types</span><span class="s3">,</span>
            <span class="s1">modifier</span><span class="s3">,</span>
            <span class="s1">options</span><span class="s3">,</span>
            <span class="s1">tailwindConfig</span>
          <span class="s3">)</span>

          <span class="s0">if </span><span class="s3">(</span><span class="s1">value </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) {</span>
            <span class="s0">return </span><span class="s3">[]</span>
          <span class="s3">}</span>

          <span class="s0">if </span><span class="s3">(!</span><span class="s1">options</span><span class="s3">.</span><span class="s1">types</span><span class="s3">.</span><span class="s1">some</span><span class="s3">(({ </span><span class="s1">type </span><span class="s3">}) =&gt; </span><span class="s1">type </span><span class="s3">=== </span><span class="s1">coercedType</span><span class="s3">)) {</span>
            <span class="s0">if </span><span class="s3">(</span><span class="s1">isOnlyPlugin</span><span class="s3">) {</span>
              <span class="s1">log</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">([</span>
                <span class="s2">`Unnecessary typehint </span><span class="s0">\`</span><span class="s1">$</span><span class="s3">{</span><span class="s1">coercedType</span><span class="s3">}</span><span class="s0">\` </span><span class="s2">in </span><span class="s0">\`</span><span class="s1">$</span><span class="s3">{</span><span class="s1">identifier</span><span class="s3">}</span><span class="s2">-</span><span class="s1">$</span><span class="s3">{</span><span class="s1">modifier</span><span class="s3">}</span><span class="s0">\`</span><span class="s2">.`</span><span class="s3">,</span>
                <span class="s2">`You can safely update it to </span><span class="s0">\`</span><span class="s1">$</span><span class="s3">{</span><span class="s1">identifier</span><span class="s3">}</span><span class="s2">-</span><span class="s1">$</span><span class="s3">{</span><span class="s1">modifier</span><span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span>
                  <span class="s1">coercedType </span><span class="s3">+ </span><span class="s2">':'</span><span class="s3">,</span>
                  <span class="s2">''</span>
                <span class="s3">)}</span><span class="s0">\`</span><span class="s2">.`</span><span class="s3">,</span>
              <span class="s3">])</span>
            <span class="s3">} </span><span class="s0">else </span><span class="s3">{</span>
              <span class="s0">return </span><span class="s3">[]</span>
            <span class="s3">}</span>
          <span class="s3">}</span>

          <span class="s0">if </span><span class="s3">(!</span><span class="s1">isSyntacticallyValidPropertyValue</span><span class="s3">(</span><span class="s1">value</span><span class="s3">)) {</span>
            <span class="s0">return </span><span class="s3">[]</span>
          <span class="s3">}</span>

          <span class="s0">let </span><span class="s1">extras </span><span class="s3">= {</span>
            <span class="s1">get modifier</span><span class="s3">() {</span>
              <span class="s0">if </span><span class="s3">(!</span><span class="s1">options</span><span class="s3">.</span><span class="s1">modifiers</span><span class="s3">) {</span>
                <span class="s1">log</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span><span class="s2">`modifier-used-without-options-for-</span><span class="s1">$</span><span class="s3">{</span><span class="s1">identifier</span><span class="s3">}</span><span class="s2">`</span><span class="s3">, [</span>
                  <span class="s2">'Your plugin must set `modifiers: true` in its options to support modifiers.'</span><span class="s3">,</span>
                <span class="s3">])</span>
              <span class="s3">}</span>

              <span class="s0">return </span><span class="s1">utilityModifier</span>
            <span class="s3">},</span>
          <span class="s3">}</span>

          <span class="s0">let </span><span class="s1">modifiersEnabled </span><span class="s3">= </span><span class="s1">flagEnabled</span><span class="s3">(</span><span class="s1">tailwindConfig</span><span class="s3">, </span><span class="s2">'generalizedModifiers'</span><span class="s3">)</span>

          <span class="s0">let </span><span class="s1">ruleSets </span><span class="s3">= []</span>
            <span class="s3">.</span><span class="s1">concat</span><span class="s3">(</span><span class="s1">modifiersEnabled </span><span class="s3">? </span><span class="s1">rule</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">extras</span><span class="s3">) : </span><span class="s1">rule</span><span class="s3">(</span><span class="s1">value</span><span class="s3">))</span>
            <span class="s3">.</span><span class="s1">filter</span><span class="s3">(</span><span class="s1">Boolean</span><span class="s3">)</span>
            <span class="s3">.</span><span class="s1">map</span><span class="s3">((</span><span class="s1">declaration</span><span class="s3">) =&gt; ({</span>
              <span class="s3">[</span><span class="s1">nameClass</span><span class="s3">(</span><span class="s1">identifier</span><span class="s3">, </span><span class="s1">modifier</span><span class="s3">)]: </span><span class="s1">declaration</span><span class="s3">,</span>
            <span class="s3">}))</span>

          <span class="s0">return </span><span class="s1">ruleSets</span>
        <span class="s3">}</span>

        <span class="s0">let </span><span class="s1">withOffsets </span><span class="s3">= [{ </span><span class="s1">sort</span><span class="s3">: </span><span class="s1">offset</span><span class="s3">, </span><span class="s1">layer</span><span class="s3">: </span><span class="s2">'utilities'</span><span class="s3">, </span><span class="s1">options </span><span class="s3">}, </span><span class="s1">wrapped</span><span class="s3">]</span>

        <span class="s0">if </span><span class="s3">(!</span><span class="s1">context</span><span class="s3">.</span><span class="s1">candidateRuleMap</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s1">prefixedIdentifier</span><span class="s3">)) {</span>
          <span class="s1">context</span><span class="s3">.</span><span class="s1">candidateRuleMap</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">prefixedIdentifier</span><span class="s3">, [])</span>
        <span class="s3">}</span>

        <span class="s1">context</span><span class="s3">.</span><span class="s1">candidateRuleMap</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">prefixedIdentifier</span><span class="s3">).</span><span class="s1">push</span><span class="s3">(</span><span class="s1">withOffsets</span><span class="s3">)</span>
      <span class="s3">}</span>
    <span class="s3">},</span>
    <span class="s1">matchComponents</span><span class="s3">: </span><span class="s0">function </span><span class="s3">(</span><span class="s1">components</span><span class="s3">, </span><span class="s1">options</span><span class="s3">) {</span>
      <span class="s0">let </span><span class="s1">defaultOptions </span><span class="s3">= {</span>
        <span class="s1">respectPrefix</span><span class="s3">: </span><span class="s0">true</span><span class="s3">,</span>
        <span class="s1">respectImportant</span><span class="s3">: </span><span class="s0">false</span><span class="s3">,</span>
        <span class="s1">modifiers</span><span class="s3">: </span><span class="s0">false</span><span class="s3">,</span>
      <span class="s3">}</span>

      <span class="s1">options </span><span class="s3">= </span><span class="s1">normalizeOptionTypes</span><span class="s3">({ </span><span class="s1">...defaultOptions</span><span class="s3">, </span><span class="s1">...options </span><span class="s3">})</span>

      <span class="s0">let </span><span class="s1">offset </span><span class="s3">= </span><span class="s1">offsets</span><span class="s3">.</span><span class="s1">create</span><span class="s3">(</span><span class="s2">'components'</span><span class="s3">)</span>

      <span class="s0">for </span><span class="s3">(</span><span class="s0">let </span><span class="s1">identifier </span><span class="s0">in </span><span class="s1">components</span><span class="s3">) {</span>
        <span class="s0">let </span><span class="s1">prefixedIdentifier </span><span class="s3">= </span><span class="s1">prefixIdentifier</span><span class="s3">(</span><span class="s1">identifier</span><span class="s3">, </span><span class="s1">options</span><span class="s3">)</span>
        <span class="s0">let </span><span class="s1">rule </span><span class="s3">= </span><span class="s1">components</span><span class="s3">[</span><span class="s1">identifier</span><span class="s3">]</span>

        <span class="s1">classList</span><span class="s3">.</span><span class="s1">add</span><span class="s3">([</span><span class="s1">prefixedIdentifier</span><span class="s3">, </span><span class="s1">options</span><span class="s3">])</span>

        <span class="s0">function </span><span class="s1">wrapped</span><span class="s3">(</span><span class="s1">modifier</span><span class="s3">, { </span><span class="s1">isOnlyPlugin </span><span class="s3">}) {</span>
          <span class="s0">let </span><span class="s3">[</span><span class="s1">value</span><span class="s3">, </span><span class="s1">coercedType</span><span class="s3">, </span><span class="s1">utilityModifier</span><span class="s3">] = </span><span class="s1">coerceValue</span><span class="s3">(</span>
            <span class="s1">options</span><span class="s3">.</span><span class="s1">types</span><span class="s3">,</span>
            <span class="s1">modifier</span><span class="s3">,</span>
            <span class="s1">options</span><span class="s3">,</span>
            <span class="s1">tailwindConfig</span>
          <span class="s3">)</span>

          <span class="s0">if </span><span class="s3">(</span><span class="s1">value </span><span class="s3">=== </span><span class="s1">undefined</span><span class="s3">) {</span>
            <span class="s0">return </span><span class="s3">[]</span>
          <span class="s3">}</span>

          <span class="s0">if </span><span class="s3">(!</span><span class="s1">options</span><span class="s3">.</span><span class="s1">types</span><span class="s3">.</span><span class="s1">some</span><span class="s3">(({ </span><span class="s1">type </span><span class="s3">}) =&gt; </span><span class="s1">type </span><span class="s3">=== </span><span class="s1">coercedType</span><span class="s3">)) {</span>
            <span class="s0">if </span><span class="s3">(</span><span class="s1">isOnlyPlugin</span><span class="s3">) {</span>
              <span class="s1">log</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">([</span>
                <span class="s2">`Unnecessary typehint </span><span class="s0">\`</span><span class="s1">$</span><span class="s3">{</span><span class="s1">coercedType</span><span class="s3">}</span><span class="s0">\` </span><span class="s2">in </span><span class="s0">\`</span><span class="s1">$</span><span class="s3">{</span><span class="s1">identifier</span><span class="s3">}</span><span class="s2">-</span><span class="s1">$</span><span class="s3">{</span><span class="s1">modifier</span><span class="s3">}</span><span class="s0">\`</span><span class="s2">.`</span><span class="s3">,</span>
                <span class="s2">`You can safely update it to </span><span class="s0">\`</span><span class="s1">$</span><span class="s3">{</span><span class="s1">identifier</span><span class="s3">}</span><span class="s2">-</span><span class="s1">$</span><span class="s3">{</span><span class="s1">modifier</span><span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span>
                  <span class="s1">coercedType </span><span class="s3">+ </span><span class="s2">':'</span><span class="s3">,</span>
                  <span class="s2">''</span>
                <span class="s3">)}</span><span class="s0">\`</span><span class="s2">.`</span><span class="s3">,</span>
              <span class="s3">])</span>
            <span class="s3">} </span><span class="s0">else </span><span class="s3">{</span>
              <span class="s0">return </span><span class="s3">[]</span>
            <span class="s3">}</span>
          <span class="s3">}</span>

          <span class="s0">if </span><span class="s3">(!</span><span class="s1">isSyntacticallyValidPropertyValue</span><span class="s3">(</span><span class="s1">value</span><span class="s3">)) {</span>
            <span class="s0">return </span><span class="s3">[]</span>
          <span class="s3">}</span>

          <span class="s0">let </span><span class="s1">extras </span><span class="s3">= {</span>
            <span class="s1">get modifier</span><span class="s3">() {</span>
              <span class="s0">if </span><span class="s3">(!</span><span class="s1">options</span><span class="s3">.</span><span class="s1">modifiers</span><span class="s3">) {</span>
                <span class="s1">log</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span><span class="s2">`modifier-used-without-options-for-</span><span class="s1">$</span><span class="s3">{</span><span class="s1">identifier</span><span class="s3">}</span><span class="s2">`</span><span class="s3">, [</span>
                  <span class="s2">'Your plugin must set `modifiers: true` in its options to support modifiers.'</span><span class="s3">,</span>
                <span class="s3">])</span>
              <span class="s3">}</span>

              <span class="s0">return </span><span class="s1">utilityModifier</span>
            <span class="s3">},</span>
          <span class="s3">}</span>

          <span class="s0">let </span><span class="s1">modifiersEnabled </span><span class="s3">= </span><span class="s1">flagEnabled</span><span class="s3">(</span><span class="s1">tailwindConfig</span><span class="s3">, </span><span class="s2">'generalizedModifiers'</span><span class="s3">)</span>

          <span class="s0">let </span><span class="s1">ruleSets </span><span class="s3">= []</span>
            <span class="s3">.</span><span class="s1">concat</span><span class="s3">(</span><span class="s1">modifiersEnabled </span><span class="s3">? </span><span class="s1">rule</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">extras</span><span class="s3">) : </span><span class="s1">rule</span><span class="s3">(</span><span class="s1">value</span><span class="s3">))</span>
            <span class="s3">.</span><span class="s1">filter</span><span class="s3">(</span><span class="s1">Boolean</span><span class="s3">)</span>
            <span class="s3">.</span><span class="s1">map</span><span class="s3">((</span><span class="s1">declaration</span><span class="s3">) =&gt; ({</span>
              <span class="s3">[</span><span class="s1">nameClass</span><span class="s3">(</span><span class="s1">identifier</span><span class="s3">, </span><span class="s1">modifier</span><span class="s3">)]: </span><span class="s1">declaration</span><span class="s3">,</span>
            <span class="s3">}))</span>

          <span class="s0">return </span><span class="s1">ruleSets</span>
        <span class="s3">}</span>

        <span class="s0">let </span><span class="s1">withOffsets </span><span class="s3">= [{ </span><span class="s1">sort</span><span class="s3">: </span><span class="s1">offset</span><span class="s3">, </span><span class="s1">layer</span><span class="s3">: </span><span class="s2">'components'</span><span class="s3">, </span><span class="s1">options </span><span class="s3">}, </span><span class="s1">wrapped</span><span class="s3">]</span>

        <span class="s0">if </span><span class="s3">(!</span><span class="s1">context</span><span class="s3">.</span><span class="s1">candidateRuleMap</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s1">prefixedIdentifier</span><span class="s3">)) {</span>
          <span class="s1">context</span><span class="s3">.</span><span class="s1">candidateRuleMap</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">prefixedIdentifier</span><span class="s3">, [])</span>
        <span class="s3">}</span>

        <span class="s1">context</span><span class="s3">.</span><span class="s1">candidateRuleMap</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">prefixedIdentifier</span><span class="s3">).</span><span class="s1">push</span><span class="s3">(</span><span class="s1">withOffsets</span><span class="s3">)</span>
      <span class="s3">}</span>
    <span class="s3">},</span>
    <span class="s1">addVariant</span><span class="s3">(</span><span class="s1">variantName</span><span class="s3">, </span><span class="s1">variantFunctions</span><span class="s3">, </span><span class="s1">options </span><span class="s3">= {}) {</span>
      <span class="s1">variantFunctions </span><span class="s3">= [].</span><span class="s1">concat</span><span class="s3">(</span><span class="s1">variantFunctions</span><span class="s3">).</span><span class="s1">map</span><span class="s3">((</span><span class="s1">variantFunction</span><span class="s3">) =&gt; {</span>
        <span class="s0">if </span><span class="s3">(</span><span class="s0">typeof </span><span class="s1">variantFunction </span><span class="s3">!== </span><span class="s2">'string'</span><span class="s3">) {</span>
          <span class="s7">// Safelist public API functions</span>
          <span class="s0">return </span><span class="s3">(</span><span class="s1">api </span><span class="s3">= {}) =&gt; {</span>
            <span class="s0">let </span><span class="s3">{ </span><span class="s1">args</span><span class="s3">, </span><span class="s1">modifySelectors</span><span class="s3">, </span><span class="s1">container</span><span class="s3">, </span><span class="s1">separator</span><span class="s3">, </span><span class="s1">wrap</span><span class="s3">, </span><span class="s1">format </span><span class="s3">} = </span><span class="s1">api</span>
            <span class="s0">let </span><span class="s1">result </span><span class="s3">= </span><span class="s1">variantFunction</span><span class="s3">(</span>
              <span class="s1">Object</span><span class="s3">.</span><span class="s1">assign</span><span class="s3">(</span>
                <span class="s3">{ </span><span class="s1">modifySelectors</span><span class="s3">, </span><span class="s1">container</span><span class="s3">, </span><span class="s1">separator </span><span class="s3">},</span>
                <span class="s1">options</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s1">VARIANT_TYPES</span><span class="s3">.</span><span class="s1">MatchVariant </span><span class="s3">&amp;&amp; { </span><span class="s1">args</span><span class="s3">, </span><span class="s1">wrap</span><span class="s3">, </span><span class="s1">format </span><span class="s3">}</span>
              <span class="s3">)</span>
            <span class="s3">)</span>

            <span class="s0">if </span><span class="s3">(</span><span class="s0">typeof </span><span class="s1">result </span><span class="s3">=== </span><span class="s2">'string' </span><span class="s3">&amp;&amp; !</span><span class="s1">isValidVariantFormatString</span><span class="s3">(</span><span class="s1">result</span><span class="s3">)) {</span>
              <span class="s0">throw new </span><span class="s1">Error</span><span class="s3">(</span>
                <span class="s2">`Your custom variant </span><span class="s0">\`</span><span class="s1">$</span><span class="s3">{</span><span class="s1">variantName</span><span class="s3">}</span><span class="s0">\` </span><span class="s2">has an invalid format string. Make sure it's an at-rule or contains a </span><span class="s0">\`</span><span class="s2">&amp;</span><span class="s0">\` </span><span class="s2">placeholder.`</span>
              <span class="s3">)</span>
            <span class="s3">}</span>

            <span class="s0">if </span><span class="s3">(</span><span class="s1">Array</span><span class="s3">.</span><span class="s1">isArray</span><span class="s3">(</span><span class="s1">result</span><span class="s3">)) {</span>
              <span class="s0">return </span><span class="s1">result</span>
                <span class="s3">.</span><span class="s1">filter</span><span class="s3">((</span><span class="s1">variant</span><span class="s3">) =&gt; </span><span class="s0">typeof </span><span class="s1">variant </span><span class="s3">=== </span><span class="s2">'string'</span><span class="s3">)</span>
                <span class="s3">.</span><span class="s1">map</span><span class="s3">((</span><span class="s1">variant</span><span class="s3">) =&gt; </span><span class="s1">parseVariant</span><span class="s3">(</span><span class="s1">variant</span><span class="s3">))</span>
            <span class="s3">}</span>

            <span class="s7">// result may be undefined with legacy variants that use APIs like `modifySelectors`</span>
            <span class="s7">// result may also be a postcss node if someone was returning the result from `modifySelectors`</span>
            <span class="s0">return </span><span class="s1">result </span><span class="s3">&amp;&amp; </span><span class="s0">typeof </span><span class="s1">result </span><span class="s3">=== </span><span class="s2">'string' </span><span class="s3">&amp;&amp; </span><span class="s1">parseVariant</span><span class="s3">(</span><span class="s1">result</span><span class="s3">)(</span><span class="s1">api</span><span class="s3">)</span>
          <span class="s3">}</span>
        <span class="s3">}</span>

        <span class="s0">if </span><span class="s3">(!</span><span class="s1">isValidVariantFormatString</span><span class="s3">(</span><span class="s1">variantFunction</span><span class="s3">)) {</span>
          <span class="s0">throw new </span><span class="s1">Error</span><span class="s3">(</span>
            <span class="s2">`Your custom variant </span><span class="s0">\`</span><span class="s1">$</span><span class="s3">{</span><span class="s1">variantName</span><span class="s3">}</span><span class="s0">\` </span><span class="s2">has an invalid format string. Make sure it's an at-rule or contains a </span><span class="s0">\`</span><span class="s2">&amp;</span><span class="s0">\` </span><span class="s2">placeholder.`</span>
          <span class="s3">)</span>
        <span class="s3">}</span>

        <span class="s0">return </span><span class="s1">parseVariant</span><span class="s3">(</span><span class="s1">variantFunction</span><span class="s3">)</span>
      <span class="s3">})</span>

      <span class="s1">insertInto</span><span class="s3">(</span><span class="s1">variantList</span><span class="s3">, </span><span class="s1">variantName</span><span class="s3">, </span><span class="s1">options</span><span class="s3">)</span>
      <span class="s1">variantMap</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">variantName</span><span class="s3">, </span><span class="s1">variantFunctions</span><span class="s3">)</span>
      <span class="s1">context</span><span class="s3">.</span><span class="s1">variantOptions</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">variantName</span><span class="s3">, </span><span class="s1">options</span><span class="s3">)</span>
    <span class="s3">},</span>
    <span class="s1">matchVariant</span><span class="s3">(</span><span class="s1">variant</span><span class="s3">, </span><span class="s1">variantFn</span><span class="s3">, </span><span class="s1">options</span><span class="s3">) {</span>
      <span class="s7">// A unique identifier that &quot;groups&quot; these variants together.</span>
      <span class="s7">// This is for internal use only which is why it is not present in the types</span>
      <span class="s0">let </span><span class="s1">id </span><span class="s3">= </span><span class="s1">options</span><span class="s3">?.</span><span class="s1">id </span><span class="s3">?? ++</span><span class="s1">variantIdentifier</span>
      <span class="s0">let </span><span class="s1">isSpecial </span><span class="s3">= </span><span class="s1">variant </span><span class="s3">=== </span><span class="s2">'@'</span>

      <span class="s0">let </span><span class="s1">modifiersEnabled </span><span class="s3">= </span><span class="s1">flagEnabled</span><span class="s3">(</span><span class="s1">tailwindConfig</span><span class="s3">, </span><span class="s2">'generalizedModifiers'</span><span class="s3">)</span>

      <span class="s0">for </span><span class="s3">(</span><span class="s0">let </span><span class="s3">[</span><span class="s1">key</span><span class="s3">, </span><span class="s1">value</span><span class="s3">] </span><span class="s1">of Object</span><span class="s3">.</span><span class="s1">entries</span><span class="s3">(</span><span class="s1">options</span><span class="s3">?.</span><span class="s1">values </span><span class="s3">?? {})) {</span>
        <span class="s0">if </span><span class="s3">(</span><span class="s1">key </span><span class="s3">=== </span><span class="s2">'DEFAULT'</span><span class="s3">) </span><span class="s0">continue</span>

        <span class="s1">api</span><span class="s3">.</span><span class="s1">addVariant</span><span class="s3">(</span>
          <span class="s1">isSpecial </span><span class="s3">? </span><span class="s2">`</span><span class="s1">$</span><span class="s3">{</span><span class="s1">variant</span><span class="s3">}</span><span class="s1">$</span><span class="s3">{</span><span class="s1">key</span><span class="s3">}</span><span class="s2">` </span><span class="s3">: </span><span class="s2">`</span><span class="s1">$</span><span class="s3">{</span><span class="s1">variant</span><span class="s3">}</span><span class="s2">-</span><span class="s1">$</span><span class="s3">{</span><span class="s1">key</span><span class="s3">}</span><span class="s2">`</span><span class="s3">,</span>
          <span class="s3">({ </span><span class="s1">args</span><span class="s3">, </span><span class="s1">container </span><span class="s3">}) =&gt; {</span>
            <span class="s0">return </span><span class="s1">variantFn</span><span class="s3">(</span>
              <span class="s1">value</span><span class="s3">,</span>
              <span class="s1">modifiersEnabled </span><span class="s3">? { </span><span class="s1">modifier</span><span class="s3">: </span><span class="s1">args</span><span class="s3">?.</span><span class="s1">modifier</span><span class="s3">, </span><span class="s1">container </span><span class="s3">} : { </span><span class="s1">container </span><span class="s3">}</span>
            <span class="s3">)</span>
          <span class="s3">},</span>

          <span class="s3">{</span>
            <span class="s1">...options</span><span class="s3">,</span>
            <span class="s1">value</span><span class="s3">,</span>
            <span class="s1">id</span><span class="s3">,</span>
            <span class="s1">type</span><span class="s3">: </span><span class="s1">VARIANT_TYPES</span><span class="s3">.</span><span class="s1">MatchVariant</span><span class="s3">,</span>
            <span class="s1">variantInfo</span><span class="s3">: </span><span class="s1">VARIANT_INFO</span><span class="s3">.</span><span class="s1">Base</span><span class="s3">,</span>
          <span class="s3">}</span>
        <span class="s3">)</span>
      <span class="s3">}</span>

      <span class="s0">let </span><span class="s1">hasDefault </span><span class="s3">= </span><span class="s2">'DEFAULT' </span><span class="s0">in </span><span class="s3">(</span><span class="s1">options</span><span class="s3">?.</span><span class="s1">values </span><span class="s3">?? {})</span>

      <span class="s1">api</span><span class="s3">.</span><span class="s1">addVariant</span><span class="s3">(</span>
        <span class="s1">variant</span><span class="s3">,</span>
        <span class="s3">({ </span><span class="s1">args</span><span class="s3">, </span><span class="s1">container </span><span class="s3">}) =&gt; {</span>
          <span class="s0">if </span><span class="s3">(</span><span class="s1">args</span><span class="s3">?.</span><span class="s1">value </span><span class="s3">=== </span><span class="s1">sharedState</span><span class="s3">.</span><span class="s1">NONE </span><span class="s3">&amp;&amp; !</span><span class="s1">hasDefault</span><span class="s3">) {</span>
            <span class="s0">return null</span>
          <span class="s3">}</span>

          <span class="s0">return </span><span class="s1">variantFn</span><span class="s3">(</span>
            <span class="s1">args</span><span class="s3">?.</span><span class="s1">value </span><span class="s3">=== </span><span class="s1">sharedState</span><span class="s3">.</span><span class="s1">NONE</span>
              <span class="s3">? </span><span class="s1">options</span><span class="s3">.</span><span class="s1">values</span><span class="s3">.</span><span class="s1">DEFAULT</span>
              <span class="s3">: </span><span class="s7">// Falling back to args if it is a string, otherwise '' for older intellisense</span>
                <span class="s7">// (JetBrains) plugins.</span>
                <span class="s1">args</span><span class="s3">?.</span><span class="s1">value </span><span class="s3">?? (</span><span class="s0">typeof </span><span class="s1">args </span><span class="s3">=== </span><span class="s2">'string' </span><span class="s3">? </span><span class="s1">args </span><span class="s3">: </span><span class="s2">''</span><span class="s3">),</span>
            <span class="s1">modifiersEnabled </span><span class="s3">? { </span><span class="s1">modifier</span><span class="s3">: </span><span class="s1">args</span><span class="s3">?.</span><span class="s1">modifier</span><span class="s3">, </span><span class="s1">container </span><span class="s3">} : { </span><span class="s1">container </span><span class="s3">}</span>
          <span class="s3">)</span>
        <span class="s3">},</span>
        <span class="s3">{</span>
          <span class="s1">...options</span><span class="s3">,</span>
          <span class="s1">id</span><span class="s3">,</span>
          <span class="s1">type</span><span class="s3">: </span><span class="s1">VARIANT_TYPES</span><span class="s3">.</span><span class="s1">MatchVariant</span><span class="s3">,</span>
          <span class="s1">variantInfo</span><span class="s3">: </span><span class="s1">VARIANT_INFO</span><span class="s3">.</span><span class="s1">Dynamic</span><span class="s3">,</span>
        <span class="s3">}</span>
      <span class="s3">)</span>
    <span class="s3">},</span>
  <span class="s3">}</span>

  <span class="s0">return </span><span class="s1">api</span>
<span class="s3">}</span>

<span class="s0">let </span><span class="s1">fileModifiedMapCache </span><span class="s3">= </span><span class="s0">new </span><span class="s1">WeakMap</span><span class="s3">()</span>
<span class="s0">export function </span><span class="s1">getFileModifiedMap</span><span class="s3">(</span><span class="s1">context</span><span class="s3">) {</span>
  <span class="s0">if </span><span class="s3">(!</span><span class="s1">fileModifiedMapCache</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s1">context</span><span class="s3">)) {</span>
    <span class="s1">fileModifiedMapCache</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s0">new </span><span class="s1">Map</span><span class="s3">())</span>
  <span class="s3">}</span>
  <span class="s0">return </span><span class="s1">fileModifiedMapCache</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">context</span><span class="s3">)</span>
<span class="s3">}</span>

<span class="s0">function </span><span class="s1">trackModified</span><span class="s3">(</span><span class="s1">files</span><span class="s3">, </span><span class="s1">fileModifiedMap</span><span class="s3">) {</span>
  <span class="s0">let </span><span class="s1">changed </span><span class="s3">= </span><span class="s0">false</span>
  <span class="s0">let </span><span class="s1">mtimesToCommit </span><span class="s3">= </span><span class="s0">new </span><span class="s1">Map</span><span class="s3">()</span>

  <span class="s0">for </span><span class="s3">(</span><span class="s0">let </span><span class="s1">file of files</span><span class="s3">) {</span>
    <span class="s0">if </span><span class="s3">(!</span><span class="s1">file</span><span class="s3">) </span><span class="s0">continue</span>

    <span class="s0">let </span><span class="s1">parsed </span><span class="s3">= </span><span class="s1">url</span><span class="s3">.</span><span class="s1">parse</span><span class="s3">(</span><span class="s1">file</span><span class="s3">)</span>
    <span class="s0">let </span><span class="s1">pathname </span><span class="s3">= </span><span class="s1">parsed</span><span class="s3">.</span><span class="s1">hash </span><span class="s3">? </span><span class="s1">parsed</span><span class="s3">.</span><span class="s1">href</span><span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span><span class="s1">parsed</span><span class="s3">.</span><span class="s1">hash</span><span class="s3">, </span><span class="s2">''</span><span class="s3">) : </span><span class="s1">parsed</span><span class="s3">.</span><span class="s1">href</span>
    <span class="s1">pathname </span><span class="s3">= </span><span class="s1">parsed</span><span class="s3">.</span><span class="s1">search </span><span class="s3">? </span><span class="s1">pathname</span><span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span><span class="s1">parsed</span><span class="s3">.</span><span class="s1">search</span><span class="s3">, </span><span class="s2">''</span><span class="s3">) : </span><span class="s1">pathname</span>
    <span class="s0">let </span><span class="s1">newModified </span><span class="s3">= </span><span class="s1">fs</span><span class="s3">.</span><span class="s1">statSync</span><span class="s3">(</span><span class="s1">decodeURIComponent</span><span class="s3">(</span><span class="s1">pathname</span><span class="s3">), { </span><span class="s1">throwIfNoEntry</span><span class="s3">: </span><span class="s0">false </span><span class="s3">})?.</span><span class="s1">mtimeMs</span>
    <span class="s0">if </span><span class="s3">(!</span><span class="s1">newModified</span><span class="s3">) {</span>
      <span class="s7">// It could happen that a file is passed in that doesn't exist. E.g.:</span>
      <span class="s7">// postcss-cli will provide you a fake path when reading from stdin. This</span>
      <span class="s7">// path then looks like /path-to-your-project/stdin In that case we just</span>
      <span class="s7">// want to ignore it and don't track changes at all.</span>
      <span class="s0">continue</span>
    <span class="s3">}</span>

    <span class="s0">if </span><span class="s3">(!</span><span class="s1">fileModifiedMap</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s1">file</span><span class="s3">) || </span><span class="s1">newModified </span><span class="s3">&gt; </span><span class="s1">fileModifiedMap</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">file</span><span class="s3">)) {</span>
      <span class="s1">changed </span><span class="s3">= </span><span class="s0">true</span>
    <span class="s3">}</span>

    <span class="s1">mtimesToCommit</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">file</span><span class="s3">, </span><span class="s1">newModified</span><span class="s3">)</span>
  <span class="s3">}</span>

  <span class="s0">return </span><span class="s3">[</span><span class="s1">changed</span><span class="s3">, </span><span class="s1">mtimesToCommit</span><span class="s3">]</span>
<span class="s3">}</span>

<span class="s0">function </span><span class="s1">extractVariantAtRules</span><span class="s3">(</span><span class="s1">node</span><span class="s3">) {</span>
  <span class="s1">node</span><span class="s3">.</span><span class="s1">walkAtRules</span><span class="s3">((</span><span class="s1">atRule</span><span class="s3">) =&gt; {</span>
    <span class="s0">if </span><span class="s3">([</span><span class="s2">'responsive'</span><span class="s3">, </span><span class="s2">'variants'</span><span class="s3">].</span><span class="s1">includes</span><span class="s3">(</span><span class="s1">atRule</span><span class="s3">.</span><span class="s1">name</span><span class="s3">)) {</span>
      <span class="s1">extractVariantAtRules</span><span class="s3">(</span><span class="s1">atRule</span><span class="s3">)</span>
      <span class="s1">atRule</span><span class="s3">.</span><span class="s1">before</span><span class="s3">(</span><span class="s1">atRule</span><span class="s3">.</span><span class="s1">nodes</span><span class="s3">)</span>
      <span class="s1">atRule</span><span class="s3">.</span><span class="s1">remove</span><span class="s3">()</span>
    <span class="s3">}</span>
  <span class="s3">})</span>
<span class="s3">}</span>

<span class="s0">function </span><span class="s1">collectLayerPlugins</span><span class="s3">(</span><span class="s1">root</span><span class="s3">) {</span>
  <span class="s0">let </span><span class="s1">layerPlugins </span><span class="s3">= []</span>

  <span class="s1">root</span><span class="s3">.</span><span class="s1">each</span><span class="s3">((</span><span class="s1">node</span><span class="s3">) =&gt; {</span>
    <span class="s0">if </span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'atrule' </span><span class="s3">&amp;&amp; [</span><span class="s2">'responsive'</span><span class="s3">, </span><span class="s2">'variants'</span><span class="s3">].</span><span class="s1">includes</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">name</span><span class="s3">)) {</span>
      <span class="s1">node</span><span class="s3">.</span><span class="s1">name </span><span class="s3">= </span><span class="s2">'layer'</span>
      <span class="s1">node</span><span class="s3">.</span><span class="s1">params </span><span class="s3">= </span><span class="s2">'utilities'</span>
    <span class="s3">}</span>
  <span class="s3">})</span>

  <span class="s7">// Walk @layer rules and treat them like plugins</span>
  <span class="s1">root</span><span class="s3">.</span><span class="s1">walkAtRules</span><span class="s3">(</span><span class="s2">'layer'</span><span class="s3">, (</span><span class="s1">layerRule</span><span class="s3">) =&gt; {</span>
    <span class="s1">extractVariantAtRules</span><span class="s3">(</span><span class="s1">layerRule</span><span class="s3">)</span>

    <span class="s0">if </span><span class="s3">(</span><span class="s1">layerRule</span><span class="s3">.</span><span class="s1">params </span><span class="s3">=== </span><span class="s2">'base'</span><span class="s3">) {</span>
      <span class="s0">for </span><span class="s3">(</span><span class="s0">let </span><span class="s1">node of layerRule</span><span class="s3">.</span><span class="s1">nodes</span><span class="s3">) {</span>
        <span class="s1">layerPlugins</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s0">function </span><span class="s3">({ </span><span class="s1">addBase </span><span class="s3">}) {</span>
          <span class="s1">addBase</span><span class="s3">(</span><span class="s1">node</span><span class="s3">, { </span><span class="s1">respectPrefix</span><span class="s3">: </span><span class="s0">false </span><span class="s3">})</span>
        <span class="s3">})</span>
      <span class="s3">}</span>
      <span class="s1">layerRule</span><span class="s3">.</span><span class="s1">remove</span><span class="s3">()</span>
    <span class="s3">} </span><span class="s0">else if </span><span class="s3">(</span><span class="s1">layerRule</span><span class="s3">.</span><span class="s1">params </span><span class="s3">=== </span><span class="s2">'components'</span><span class="s3">) {</span>
      <span class="s0">for </span><span class="s3">(</span><span class="s0">let </span><span class="s1">node of layerRule</span><span class="s3">.</span><span class="s1">nodes</span><span class="s3">) {</span>
        <span class="s1">layerPlugins</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s0">function </span><span class="s3">({ </span><span class="s1">addComponents </span><span class="s3">}) {</span>
          <span class="s1">addComponents</span><span class="s3">(</span><span class="s1">node</span><span class="s3">, { </span><span class="s1">respectPrefix</span><span class="s3">: </span><span class="s0">false</span><span class="s3">, </span><span class="s1">preserveSource</span><span class="s3">: </span><span class="s0">true </span><span class="s3">})</span>
        <span class="s3">})</span>
      <span class="s3">}</span>
      <span class="s1">layerRule</span><span class="s3">.</span><span class="s1">remove</span><span class="s3">()</span>
    <span class="s3">} </span><span class="s0">else if </span><span class="s3">(</span><span class="s1">layerRule</span><span class="s3">.</span><span class="s1">params </span><span class="s3">=== </span><span class="s2">'utilities'</span><span class="s3">) {</span>
      <span class="s0">for </span><span class="s3">(</span><span class="s0">let </span><span class="s1">node of layerRule</span><span class="s3">.</span><span class="s1">nodes</span><span class="s3">) {</span>
        <span class="s1">layerPlugins</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s0">function </span><span class="s3">({ </span><span class="s1">addUtilities </span><span class="s3">}) {</span>
          <span class="s1">addUtilities</span><span class="s3">(</span><span class="s1">node</span><span class="s3">, { </span><span class="s1">respectPrefix</span><span class="s3">: </span><span class="s0">false</span><span class="s3">, </span><span class="s1">preserveSource</span><span class="s3">: </span><span class="s0">true </span><span class="s3">})</span>
        <span class="s3">})</span>
      <span class="s3">}</span>
      <span class="s1">layerRule</span><span class="s3">.</span><span class="s1">remove</span><span class="s3">()</span>
    <span class="s3">}</span>
  <span class="s3">})</span>

  <span class="s0">return </span><span class="s1">layerPlugins</span>
<span class="s3">}</span>

<span class="s0">function </span><span class="s1">resolvePlugins</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">root</span><span class="s3">) {</span>
  <span class="s0">let </span><span class="s1">corePluginList </span><span class="s3">= </span><span class="s1">Object</span><span class="s3">.</span><span class="s1">entries</span><span class="s3">({ </span><span class="s1">...variantPlugins</span><span class="s3">, </span><span class="s1">...corePlugins </span><span class="s3">})</span>
    <span class="s3">.</span><span class="s1">map</span><span class="s3">(([</span><span class="s1">name</span><span class="s3">, </span><span class="s1">plugin</span><span class="s3">]) =&gt; {</span>
      <span class="s0">if </span><span class="s3">(!</span><span class="s1">context</span><span class="s3">.</span><span class="s1">tailwindConfig</span><span class="s3">.</span><span class="s1">corePlugins</span><span class="s3">.</span><span class="s1">includes</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)) {</span>
        <span class="s0">return null</span>
      <span class="s3">}</span>

      <span class="s0">return </span><span class="s1">plugin</span>
    <span class="s3">})</span>
    <span class="s3">.</span><span class="s1">filter</span><span class="s3">(</span><span class="s1">Boolean</span><span class="s3">)</span>

  <span class="s0">let </span><span class="s1">userPlugins </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">tailwindConfig</span><span class="s3">.</span><span class="s1">plugins</span><span class="s3">.</span><span class="s1">map</span><span class="s3">((</span><span class="s1">plugin</span><span class="s3">) =&gt; {</span>
    <span class="s0">if </span><span class="s3">(</span><span class="s1">plugin</span><span class="s3">.</span><span class="s1">__isOptionsFunction</span><span class="s3">) {</span>
      <span class="s1">plugin </span><span class="s3">= </span><span class="s1">plugin</span><span class="s3">()</span>
    <span class="s3">}</span>

    <span class="s0">return typeof </span><span class="s1">plugin </span><span class="s3">=== </span><span class="s2">'function' </span><span class="s3">? </span><span class="s1">plugin </span><span class="s3">: </span><span class="s1">plugin</span><span class="s3">.</span><span class="s1">handler</span>
  <span class="s3">})</span>

  <span class="s0">let </span><span class="s1">layerPlugins </span><span class="s3">= </span><span class="s1">collectLayerPlugins</span><span class="s3">(</span><span class="s1">root</span><span class="s3">)</span>

  <span class="s7">// TODO: This is a workaround for backwards compatibility, since custom variants</span>
  <span class="s7">// were historically sorted before screen/stackable variants.</span>
  <span class="s0">let </span><span class="s1">beforeVariants </span><span class="s3">= [</span>
    <span class="s1">variantPlugins</span><span class="s3">[</span><span class="s2">'childVariant'</span><span class="s3">],</span>
    <span class="s1">variantPlugins</span><span class="s3">[</span><span class="s2">'pseudoElementVariants'</span><span class="s3">],</span>
    <span class="s1">variantPlugins</span><span class="s3">[</span><span class="s2">'pseudoClassVariants'</span><span class="s3">],</span>
    <span class="s1">variantPlugins</span><span class="s3">[</span><span class="s2">'hasVariants'</span><span class="s3">],</span>
    <span class="s1">variantPlugins</span><span class="s3">[</span><span class="s2">'ariaVariants'</span><span class="s3">],</span>
    <span class="s1">variantPlugins</span><span class="s3">[</span><span class="s2">'dataVariants'</span><span class="s3">],</span>
  <span class="s3">]</span>
  <span class="s0">let </span><span class="s1">afterVariants </span><span class="s3">= [</span>
    <span class="s1">variantPlugins</span><span class="s3">[</span><span class="s2">'supportsVariants'</span><span class="s3">],</span>
    <span class="s1">variantPlugins</span><span class="s3">[</span><span class="s2">'reducedMotionVariants'</span><span class="s3">],</span>
    <span class="s1">variantPlugins</span><span class="s3">[</span><span class="s2">'prefersContrastVariants'</span><span class="s3">],</span>
    <span class="s1">variantPlugins</span><span class="s3">[</span><span class="s2">'screenVariants'</span><span class="s3">],</span>
    <span class="s1">variantPlugins</span><span class="s3">[</span><span class="s2">'orientationVariants'</span><span class="s3">],</span>
    <span class="s1">variantPlugins</span><span class="s3">[</span><span class="s2">'directionVariants'</span><span class="s3">],</span>
    <span class="s1">variantPlugins</span><span class="s3">[</span><span class="s2">'darkVariants'</span><span class="s3">],</span>
    <span class="s1">variantPlugins</span><span class="s3">[</span><span class="s2">'forcedColorsVariants'</span><span class="s3">],</span>
    <span class="s1">variantPlugins</span><span class="s3">[</span><span class="s2">'printVariant'</span><span class="s3">],</span>
  <span class="s3">]</span>

  <span class="s7">// This is a compatibility fix for the pre 3.4 dark mode behavior</span>
  <span class="s7">// `class` retains the old behavior, but `selector` keeps the new behavior</span>
  <span class="s0">let </span><span class="s1">isLegacyDarkMode </span><span class="s3">=</span>
    <span class="s1">context</span><span class="s3">.</span><span class="s1">tailwindConfig</span><span class="s3">.</span><span class="s1">darkMode </span><span class="s3">=== </span><span class="s2">'class' </span><span class="s3">||</span>
    <span class="s3">(</span><span class="s1">Array</span><span class="s3">.</span><span class="s1">isArray</span><span class="s3">(</span><span class="s1">context</span><span class="s3">.</span><span class="s1">tailwindConfig</span><span class="s3">.</span><span class="s1">darkMode</span><span class="s3">) &amp;&amp;</span>
      <span class="s1">context</span><span class="s3">.</span><span class="s1">tailwindConfig</span><span class="s3">.</span><span class="s1">darkMode</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] === </span><span class="s2">'class'</span><span class="s3">)</span>

  <span class="s0">if </span><span class="s3">(</span><span class="s1">isLegacyDarkMode</span><span class="s3">) {</span>
    <span class="s1">afterVariants </span><span class="s3">= [</span>
      <span class="s1">variantPlugins</span><span class="s3">[</span><span class="s2">'supportsVariants'</span><span class="s3">],</span>
      <span class="s1">variantPlugins</span><span class="s3">[</span><span class="s2">'reducedMotionVariants'</span><span class="s3">],</span>
      <span class="s1">variantPlugins</span><span class="s3">[</span><span class="s2">'prefersContrastVariants'</span><span class="s3">],</span>
      <span class="s1">variantPlugins</span><span class="s3">[</span><span class="s2">'darkVariants'</span><span class="s3">],</span>
      <span class="s1">variantPlugins</span><span class="s3">[</span><span class="s2">'screenVariants'</span><span class="s3">],</span>
      <span class="s1">variantPlugins</span><span class="s3">[</span><span class="s2">'orientationVariants'</span><span class="s3">],</span>
      <span class="s1">variantPlugins</span><span class="s3">[</span><span class="s2">'directionVariants'</span><span class="s3">],</span>
      <span class="s1">variantPlugins</span><span class="s3">[</span><span class="s2">'forcedColorsVariants'</span><span class="s3">],</span>
      <span class="s1">variantPlugins</span><span class="s3">[</span><span class="s2">'printVariant'</span><span class="s3">],</span>
    <span class="s3">]</span>
  <span class="s3">}</span>

  <span class="s0">return </span><span class="s3">[</span><span class="s1">...corePluginList</span><span class="s3">, </span><span class="s1">...beforeVariants</span><span class="s3">, </span><span class="s1">...userPlugins</span><span class="s3">, </span><span class="s1">...afterVariants</span><span class="s3">, </span><span class="s1">...layerPlugins</span><span class="s3">]</span>
<span class="s3">}</span>

<span class="s0">function </span><span class="s1">registerPlugins</span><span class="s3">(</span><span class="s1">plugins</span><span class="s3">, </span><span class="s1">context</span><span class="s3">) {</span>
  <span class="s0">let </span><span class="s1">variantList </span><span class="s3">= []</span>
  <span class="s0">let </span><span class="s1">variantMap </span><span class="s3">= </span><span class="s0">new </span><span class="s1">Map</span><span class="s3">()</span>
  <span class="s1">context</span><span class="s3">.</span><span class="s1">variantMap </span><span class="s3">= </span><span class="s1">variantMap</span>

  <span class="s0">let </span><span class="s1">offsets </span><span class="s3">= </span><span class="s0">new </span><span class="s1">Offsets</span><span class="s3">()</span>
  <span class="s1">context</span><span class="s3">.</span><span class="s1">offsets </span><span class="s3">= </span><span class="s1">offsets</span>

  <span class="s0">let </span><span class="s1">classList </span><span class="s3">= </span><span class="s0">new </span><span class="s1">Set</span><span class="s3">()</span>

  <span class="s0">let </span><span class="s1">pluginApi </span><span class="s3">= </span><span class="s1">buildPluginApi</span><span class="s3">(</span><span class="s1">context</span><span class="s3">.</span><span class="s1">tailwindConfig</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, {</span>
    <span class="s1">variantList</span><span class="s3">,</span>
    <span class="s1">variantMap</span><span class="s3">,</span>
    <span class="s1">offsets</span><span class="s3">,</span>
    <span class="s1">classList</span><span class="s3">,</span>
  <span class="s3">})</span>

  <span class="s0">for </span><span class="s3">(</span><span class="s0">let </span><span class="s1">plugin of plugins</span><span class="s3">) {</span>
    <span class="s0">if </span><span class="s3">(</span><span class="s1">Array</span><span class="s3">.</span><span class="s1">isArray</span><span class="s3">(</span><span class="s1">plugin</span><span class="s3">)) {</span>
      <span class="s0">for </span><span class="s3">(</span><span class="s0">let </span><span class="s1">pluginItem of plugin</span><span class="s3">) {</span>
        <span class="s1">pluginItem</span><span class="s3">(</span><span class="s1">pluginApi</span><span class="s3">)</span>
      <span class="s3">}</span>
    <span class="s3">} </span><span class="s0">else </span><span class="s3">{</span>
      <span class="s1">plugin</span><span class="s3">?.(</span><span class="s1">pluginApi</span><span class="s3">)</span>
    <span class="s3">}</span>
  <span class="s3">}</span>

  <span class="s7">// Make sure to record bit masks for every variant</span>
  <span class="s1">offsets</span><span class="s3">.</span><span class="s1">recordVariants</span><span class="s3">(</span><span class="s1">variantList</span><span class="s3">, (</span><span class="s1">variant</span><span class="s3">) =&gt; </span><span class="s1">variantMap</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">variant</span><span class="s3">).</span><span class="s1">length</span><span class="s3">)</span>

  <span class="s7">// Build variantMap</span>
  <span class="s0">for </span><span class="s3">(</span><span class="s0">let </span><span class="s3">[</span><span class="s1">variantName</span><span class="s3">, </span><span class="s1">variantFunctions</span><span class="s3">] </span><span class="s1">of variantMap</span><span class="s3">.</span><span class="s1">entries</span><span class="s3">()) {</span>
    <span class="s1">context</span><span class="s3">.</span><span class="s1">variantMap</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span>
      <span class="s1">variantName</span><span class="s3">,</span>
      <span class="s1">variantFunctions</span><span class="s3">.</span><span class="s1">map</span><span class="s3">((</span><span class="s1">variantFunction</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">) =&gt; [</span>
        <span class="s1">offsets</span><span class="s3">.</span><span class="s1">forVariant</span><span class="s3">(</span><span class="s1">variantName</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">),</span>
        <span class="s1">variantFunction</span><span class="s3">,</span>
      <span class="s3">])</span>
    <span class="s3">)</span>
  <span class="s3">}</span>

  <span class="s0">let </span><span class="s1">safelist </span><span class="s3">= (</span><span class="s1">context</span><span class="s3">.</span><span class="s1">tailwindConfig</span><span class="s3">.</span><span class="s1">safelist </span><span class="s3">?? []).</span><span class="s1">filter</span><span class="s3">(</span><span class="s1">Boolean</span><span class="s3">)</span>
  <span class="s0">if </span><span class="s3">(</span><span class="s1">safelist</span><span class="s3">.</span><span class="s1">length </span><span class="s3">&gt; </span><span class="s4">0</span><span class="s3">) {</span>
    <span class="s0">let </span><span class="s1">checks </span><span class="s3">= []</span>

    <span class="s0">for </span><span class="s3">(</span><span class="s0">let </span><span class="s1">value of safelist</span><span class="s3">) {</span>
      <span class="s0">if </span><span class="s3">(</span><span class="s0">typeof </span><span class="s1">value </span><span class="s3">=== </span><span class="s2">'string'</span><span class="s3">) {</span>
        <span class="s1">context</span><span class="s3">.</span><span class="s1">changedContent</span><span class="s3">.</span><span class="s1">push</span><span class="s3">({ </span><span class="s1">content</span><span class="s3">: </span><span class="s1">value</span><span class="s3">, </span><span class="s1">extension</span><span class="s3">: </span><span class="s2">'html' </span><span class="s3">})</span>
        <span class="s0">continue</span>
      <span class="s3">}</span>

      <span class="s0">if </span><span class="s3">(</span><span class="s1">value </span><span class="s0">instanceof </span><span class="s1">RegExp</span><span class="s3">) {</span>
        <span class="s1">log</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span><span class="s2">'root-regex'</span><span class="s3">, [</span>
          <span class="s2">'Regular expressions in `safelist` work differently in Tailwind CSS v3.0.'</span><span class="s3">,</span>
          <span class="s2">'Update your `safelist` configuration to eliminate this warning.'</span><span class="s3">,</span>
          <span class="s2">'https://tailwindcss.com/docs/content-configuration#safelisting-classes'</span><span class="s3">,</span>
        <span class="s3">])</span>
        <span class="s0">continue</span>
      <span class="s3">}</span>

      <span class="s1">checks</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">value</span><span class="s3">)</span>
    <span class="s3">}</span>

    <span class="s0">if </span><span class="s3">(</span><span class="s1">checks</span><span class="s3">.</span><span class="s1">length </span><span class="s3">&gt; </span><span class="s4">0</span><span class="s3">) {</span>
      <span class="s0">let </span><span class="s1">patternMatchingCount </span><span class="s3">= </span><span class="s0">new </span><span class="s1">Map</span><span class="s3">()</span>
      <span class="s0">let </span><span class="s1">prefixLength </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">tailwindConfig</span><span class="s3">.</span><span class="s1">prefix</span><span class="s3">.</span><span class="s1">length</span>
      <span class="s0">let </span><span class="s1">checkImportantUtils </span><span class="s3">= </span><span class="s1">checks</span><span class="s3">.</span><span class="s1">some</span><span class="s3">((</span><span class="s1">check</span><span class="s3">) =&gt; </span><span class="s1">check</span><span class="s3">.</span><span class="s1">pattern</span><span class="s3">.</span><span class="s1">source</span><span class="s3">.</span><span class="s1">includes</span><span class="s3">(</span><span class="s2">'!'</span><span class="s3">))</span>

      <span class="s0">for </span><span class="s3">(</span><span class="s0">let </span><span class="s1">util of classList</span><span class="s3">) {</span>
        <span class="s0">let </span><span class="s1">utils </span><span class="s3">= </span><span class="s1">Array</span><span class="s3">.</span><span class="s1">isArray</span><span class="s3">(</span><span class="s1">util</span><span class="s3">)</span>
          <span class="s3">? (() =&gt; {</span>
              <span class="s0">let </span><span class="s3">[</span><span class="s1">utilName</span><span class="s3">, </span><span class="s1">options</span><span class="s3">] = </span><span class="s1">util</span>
              <span class="s0">let </span><span class="s1">values </span><span class="s3">= </span><span class="s1">Object</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">(</span><span class="s1">options</span><span class="s3">?.</span><span class="s1">values </span><span class="s3">?? {})</span>
              <span class="s0">let </span><span class="s1">classes </span><span class="s3">= </span><span class="s1">values</span><span class="s3">.</span><span class="s1">map</span><span class="s3">((</span><span class="s1">value</span><span class="s3">) =&gt; </span><span class="s1">formatClass</span><span class="s3">(</span><span class="s1">utilName</span><span class="s3">, </span><span class="s1">value</span><span class="s3">))</span>

              <span class="s0">if </span><span class="s3">(</span><span class="s1">options</span><span class="s3">?.</span><span class="s1">supportsNegativeValues</span><span class="s3">) {</span>
                <span class="s7">// This is the normal negated version</span>
                <span class="s7">// e.g. `-inset-1` or `-tw-inset-1`</span>
                <span class="s1">classes </span><span class="s3">= [</span><span class="s1">...classes</span><span class="s3">, </span><span class="s1">...classes</span><span class="s3">.</span><span class="s1">map</span><span class="s3">((</span><span class="s1">cls</span><span class="s3">) =&gt; </span><span class="s2">'-' </span><span class="s3">+ </span><span class="s1">cls</span><span class="s3">)]</span>

                <span class="s7">// This is the negated version *after* the prefix</span>
                <span class="s7">// e.g. `tw--inset-1`</span>
                <span class="s7">// The prefix is already attached to util name</span>
                <span class="s7">// So we add the negative after the prefix</span>
                <span class="s1">classes </span><span class="s3">= [</span>
                  <span class="s1">...classes</span><span class="s3">,</span>
                  <span class="s1">...classes</span><span class="s3">.</span><span class="s1">map</span><span class="s3">(</span>
                    <span class="s3">(</span><span class="s1">cls</span><span class="s3">) =&gt; </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span><span class="s4">0</span><span class="s3">, </span><span class="s1">prefixLength</span><span class="s3">) + </span><span class="s2">'-' </span><span class="s3">+ </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span><span class="s1">prefixLength</span><span class="s3">)</span>
                  <span class="s3">),</span>
                <span class="s3">]</span>
              <span class="s3">}</span>

              <span class="s0">if </span><span class="s3">(</span><span class="s1">options</span><span class="s3">.</span><span class="s1">types</span><span class="s3">.</span><span class="s1">some</span><span class="s3">(({ </span><span class="s1">type </span><span class="s3">}) =&gt; </span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'color'</span><span class="s3">)) {</span>
                <span class="s1">classes </span><span class="s3">= [</span>
                  <span class="s1">...classes</span><span class="s3">,</span>
                  <span class="s1">...classes</span><span class="s3">.</span><span class="s1">flatMap</span><span class="s3">((</span><span class="s1">cls</span><span class="s3">) =&gt;</span>
                    <span class="s1">Object</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">(</span><span class="s1">context</span><span class="s3">.</span><span class="s1">tailwindConfig</span><span class="s3">.</span><span class="s1">theme</span><span class="s3">.</span><span class="s1">opacity</span><span class="s3">).</span><span class="s1">map</span><span class="s3">(</span>
                      <span class="s3">(</span><span class="s1">opacity</span><span class="s3">) =&gt; </span><span class="s2">`</span><span class="s1">$</span><span class="s3">{</span><span class="s1">cls</span><span class="s3">}</span><span class="s2">/</span><span class="s1">$</span><span class="s3">{</span><span class="s1">opacity</span><span class="s3">}</span><span class="s2">`</span>
                    <span class="s3">)</span>
                  <span class="s3">),</span>
                <span class="s3">]</span>
              <span class="s3">}</span>

              <span class="s0">if </span><span class="s3">(</span><span class="s1">checkImportantUtils </span><span class="s3">&amp;&amp; </span><span class="s1">options</span><span class="s3">?.</span><span class="s1">respectImportant</span><span class="s3">) {</span>
                <span class="s1">classes </span><span class="s3">= [</span><span class="s1">...classes</span><span class="s3">, </span><span class="s1">...classes</span><span class="s3">.</span><span class="s1">map</span><span class="s3">((</span><span class="s1">cls</span><span class="s3">) =&gt; </span><span class="s2">'!' </span><span class="s3">+ </span><span class="s1">cls</span><span class="s3">)]</span>
              <span class="s3">}</span>

              <span class="s0">return </span><span class="s1">classes</span>
            <span class="s3">})()</span>
          <span class="s3">: [</span><span class="s1">util</span><span class="s3">]</span>

        <span class="s0">for </span><span class="s3">(</span><span class="s0">let </span><span class="s1">util of utils</span><span class="s3">) {</span>
          <span class="s0">for </span><span class="s3">(</span><span class="s0">let </span><span class="s3">{ </span><span class="s1">pattern</span><span class="s3">, </span><span class="s1">variants </span><span class="s3">= [] } </span><span class="s1">of checks</span><span class="s3">) {</span>
            <span class="s7">// RegExp with the /g flag are stateful, so let's reset the last</span>
            <span class="s7">// index pointer to reset the state.</span>
            <span class="s1">pattern</span><span class="s3">.</span><span class="s1">lastIndex </span><span class="s3">= </span><span class="s4">0</span>

            <span class="s0">if </span><span class="s3">(!</span><span class="s1">patternMatchingCount</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s1">pattern</span><span class="s3">)) {</span>
              <span class="s1">patternMatchingCount</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">pattern</span><span class="s3">, </span><span class="s4">0</span><span class="s3">)</span>
            <span class="s3">}</span>

            <span class="s0">if </span><span class="s3">(!</span><span class="s1">pattern</span><span class="s3">.</span><span class="s1">test</span><span class="s3">(</span><span class="s1">util</span><span class="s3">)) </span><span class="s0">continue</span>

            <span class="s1">patternMatchingCount</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">pattern</span><span class="s3">, </span><span class="s1">patternMatchingCount</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">pattern</span><span class="s3">) + </span><span class="s4">1</span><span class="s3">)</span>

            <span class="s1">context</span><span class="s3">.</span><span class="s1">changedContent</span><span class="s3">.</span><span class="s1">push</span><span class="s3">({ </span><span class="s1">content</span><span class="s3">: </span><span class="s1">util</span><span class="s3">, </span><span class="s1">extension</span><span class="s3">: </span><span class="s2">'html' </span><span class="s3">})</span>
            <span class="s0">for </span><span class="s3">(</span><span class="s0">let </span><span class="s1">variant of variants</span><span class="s3">) {</span>
              <span class="s1">context</span><span class="s3">.</span><span class="s1">changedContent</span><span class="s3">.</span><span class="s1">push</span><span class="s3">({</span>
                <span class="s1">content</span><span class="s3">: </span><span class="s1">variant </span><span class="s3">+ </span><span class="s1">context</span><span class="s3">.</span><span class="s1">tailwindConfig</span><span class="s3">.</span><span class="s1">separator </span><span class="s3">+ </span><span class="s1">util</span><span class="s3">,</span>
                <span class="s1">extension</span><span class="s3">: </span><span class="s2">'html'</span><span class="s3">,</span>
              <span class="s3">})</span>
            <span class="s3">}</span>
          <span class="s3">}</span>
        <span class="s3">}</span>
      <span class="s3">}</span>

      <span class="s0">for </span><span class="s3">(</span><span class="s0">let </span><span class="s3">[</span><span class="s1">regex</span><span class="s3">, </span><span class="s1">count</span><span class="s3">] </span><span class="s1">of patternMatchingCount</span><span class="s3">.</span><span class="s1">entries</span><span class="s3">()) {</span>
        <span class="s0">if </span><span class="s3">(</span><span class="s1">count </span><span class="s3">!== </span><span class="s4">0</span><span class="s3">) </span><span class="s0">continue</span>

        <span class="s1">log</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">([</span>
          <span class="s2">`The safelist pattern </span><span class="s0">\`</span><span class="s1">$</span><span class="s3">{</span><span class="s1">regex</span><span class="s3">}</span><span class="s0">\` </span><span class="s2">doesn't match any Tailwind CSS classes.`</span><span class="s3">,</span>
          <span class="s2">'Fix this pattern or remove it from your `safelist` configuration.'</span><span class="s3">,</span>
          <span class="s2">'https://tailwindcss.com/docs/content-configuration#safelisting-classes'</span><span class="s3">,</span>
        <span class="s3">])</span>
      <span class="s3">}</span>
    <span class="s3">}</span>
  <span class="s3">}</span>

  <span class="s0">let </span><span class="s1">darkClassName </span><span class="s3">= [].</span><span class="s1">concat</span><span class="s3">(</span><span class="s1">context</span><span class="s3">.</span><span class="s1">tailwindConfig</span><span class="s3">.</span><span class="s1">darkMode </span><span class="s3">?? </span><span class="s2">'media'</span><span class="s3">)[</span><span class="s4">1</span><span class="s3">] ?? </span><span class="s2">'dark'</span>

  <span class="s7">// A list of utilities that are used by certain Tailwind CSS utilities but</span>
  <span class="s7">// that don't exist on their own. This will result in them &quot;not existing&quot; and</span>
  <span class="s7">// sorting could be weird since you still require them in order to make the</span>
  <span class="s7">// host utilities work properly. (Thanks Biology)</span>
  <span class="s0">let </span><span class="s1">parasiteUtilities </span><span class="s3">= [</span>
    <span class="s1">prefix</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">darkClassName</span><span class="s3">),</span>
    <span class="s1">prefix</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s2">'group'</span><span class="s3">),</span>
    <span class="s1">prefix</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s2">'peer'</span><span class="s3">),</span>
  <span class="s3">]</span>
  <span class="s1">context</span><span class="s3">.</span><span class="s1">getClassOrder </span><span class="s3">= </span><span class="s0">function </span><span class="s1">getClassOrder</span><span class="s3">(</span><span class="s1">classes</span><span class="s3">) {</span>
    <span class="s7">// Sort classes so they're ordered in a deterministic manner</span>
    <span class="s0">let </span><span class="s1">sorted </span><span class="s3">= [</span><span class="s1">...classes</span><span class="s3">].</span><span class="s1">sort</span><span class="s3">((</span><span class="s1">a</span><span class="s3">, </span><span class="s1">z</span><span class="s3">) =&gt; {</span>
      <span class="s0">if </span><span class="s3">(</span><span class="s1">a </span><span class="s3">=== </span><span class="s1">z</span><span class="s3">) </span><span class="s0">return </span><span class="s4">0</span>
      <span class="s0">if </span><span class="s3">(</span><span class="s1">a </span><span class="s3">&lt; </span><span class="s1">z</span><span class="s3">) </span><span class="s0">return </span><span class="s3">-</span><span class="s4">1</span>
      <span class="s0">return </span><span class="s4">1</span>
    <span class="s3">})</span>

    <span class="s7">// Non-util classes won't be generated, so we default them to null</span>
    <span class="s0">let </span><span class="s1">sortedClassNames </span><span class="s3">= </span><span class="s0">new </span><span class="s1">Map</span><span class="s3">(</span><span class="s1">sorted</span><span class="s3">.</span><span class="s1">map</span><span class="s3">((</span><span class="s1">className</span><span class="s3">) =&gt; [</span><span class="s1">className</span><span class="s3">, </span><span class="s0">null</span><span class="s3">]))</span>

    <span class="s7">// Sort all classes in order</span>
    <span class="s7">// Non-tailwind classes won't be generated and will be left as `null`</span>
    <span class="s0">let </span><span class="s1">rules </span><span class="s3">= </span><span class="s1">generateRules</span><span class="s3">(</span><span class="s0">new </span><span class="s1">Set</span><span class="s3">(</span><span class="s1">sorted</span><span class="s3">), </span><span class="s1">context</span><span class="s3">, </span><span class="s0">true</span><span class="s3">)</span>
    <span class="s1">rules </span><span class="s3">= </span><span class="s1">context</span><span class="s3">.</span><span class="s1">offsets</span><span class="s3">.</span><span class="s1">sort</span><span class="s3">(</span><span class="s1">rules</span><span class="s3">)</span>

    <span class="s0">let </span><span class="s1">idx </span><span class="s3">= </span><span class="s1">BigInt</span><span class="s3">(</span><span class="s1">parasiteUtilities</span><span class="s3">.</span><span class="s1">length</span><span class="s3">)</span>

    <span class="s0">for </span><span class="s3">(</span><span class="s0">const </span><span class="s3">[, </span><span class="s1">rule</span><span class="s3">] </span><span class="s1">of rules</span><span class="s3">) {</span>
      <span class="s0">let </span><span class="s1">candidate </span><span class="s3">= </span><span class="s1">rule</span><span class="s3">.</span><span class="s1">raws</span><span class="s3">.</span><span class="s1">tailwind</span><span class="s3">.</span><span class="s1">candidate</span>

      <span class="s7">// When multiple rules match a candidate</span>
      <span class="s7">// always take the position of the first one</span>
      <span class="s1">sortedClassNames</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">candidate</span><span class="s3">, </span><span class="s1">sortedClassNames</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">candidate</span><span class="s3">) ?? </span><span class="s1">idx</span><span class="s3">++)</span>
    <span class="s3">}</span>

    <span class="s0">return </span><span class="s1">classes</span><span class="s3">.</span><span class="s1">map</span><span class="s3">((</span><span class="s1">className</span><span class="s3">) =&gt; {</span>
      <span class="s0">let </span><span class="s1">order </span><span class="s3">= </span><span class="s1">sortedClassNames</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">className</span><span class="s3">) ?? </span><span class="s0">null</span>
      <span class="s0">let </span><span class="s1">parasiteIndex </span><span class="s3">= </span><span class="s1">parasiteUtilities</span><span class="s3">.</span><span class="s1">indexOf</span><span class="s3">(</span><span class="s1">className</span><span class="s3">)</span>

      <span class="s0">if </span><span class="s3">(</span><span class="s1">order </span><span class="s3">=== </span><span class="s0">null </span><span class="s3">&amp;&amp; </span><span class="s1">parasiteIndex </span><span class="s3">!== -</span><span class="s4">1</span><span class="s3">) {</span>
        <span class="s7">// This will make sure that it is at the very beginning of the</span>
        <span class="s7">// `components` layer which technically means 'before any</span>
        <span class="s7">// components'.</span>
        <span class="s1">order </span><span class="s3">= </span><span class="s1">BigInt</span><span class="s3">(</span><span class="s1">parasiteIndex</span><span class="s3">)</span>
      <span class="s3">}</span>

      <span class="s0">return </span><span class="s3">[</span><span class="s1">className</span><span class="s3">, </span><span class="s1">order</span><span class="s3">]</span>
    <span class="s3">})</span>
  <span class="s3">}</span>

  <span class="s7">// Generate a list of strings for autocompletion purposes, e.g.</span>
  <span class="s7">// ['uppercase', 'lowercase', ...]</span>
  <span class="s1">context</span><span class="s3">.</span><span class="s1">getClassList </span><span class="s3">= </span><span class="s0">function </span><span class="s1">getClassList</span><span class="s3">(</span><span class="s1">options </span><span class="s3">= {}) {</span>
    <span class="s0">let </span><span class="s1">output </span><span class="s3">= []</span>

    <span class="s0">for </span><span class="s3">(</span><span class="s0">let </span><span class="s1">util of classList</span><span class="s3">) {</span>
      <span class="s0">if </span><span class="s3">(</span><span class="s1">Array</span><span class="s3">.</span><span class="s1">isArray</span><span class="s3">(</span><span class="s1">util</span><span class="s3">)) {</span>
        <span class="s0">let </span><span class="s3">[</span><span class="s1">utilName</span><span class="s3">, </span><span class="s1">utilOptions</span><span class="s3">] = </span><span class="s1">util</span>
        <span class="s0">let </span><span class="s1">negativeClasses </span><span class="s3">= []</span>

        <span class="s0">let </span><span class="s1">modifiers </span><span class="s3">= </span><span class="s1">Object</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">(</span><span class="s1">utilOptions</span><span class="s3">?.</span><span class="s1">modifiers </span><span class="s3">?? {})</span>

        <span class="s0">if </span><span class="s3">(</span><span class="s1">utilOptions</span><span class="s3">?.</span><span class="s1">types</span><span class="s3">?.</span><span class="s1">some</span><span class="s3">(({ </span><span class="s1">type </span><span class="s3">}) =&gt; </span><span class="s1">type </span><span class="s3">=== </span><span class="s2">'color'</span><span class="s3">)) {</span>
          <span class="s1">modifiers</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">...Object</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">(</span><span class="s1">context</span><span class="s3">.</span><span class="s1">tailwindConfig</span><span class="s3">.</span><span class="s1">theme</span><span class="s3">.</span><span class="s1">opacity </span><span class="s3">?? {}))</span>
        <span class="s3">}</span>

        <span class="s0">let </span><span class="s1">metadata </span><span class="s3">= { </span><span class="s1">modifiers </span><span class="s3">}</span>
        <span class="s0">let </span><span class="s1">includeMetadata </span><span class="s3">= </span><span class="s1">options</span><span class="s3">.</span><span class="s1">includeMetadata </span><span class="s3">&amp;&amp; </span><span class="s1">modifiers</span><span class="s3">.</span><span class="s1">length </span><span class="s3">&gt; </span><span class="s4">0</span>

        <span class="s0">for </span><span class="s3">(</span><span class="s0">let </span><span class="s3">[</span><span class="s1">key</span><span class="s3">, </span><span class="s1">value</span><span class="s3">] </span><span class="s1">of Object</span><span class="s3">.</span><span class="s1">entries</span><span class="s3">(</span><span class="s1">utilOptions</span><span class="s3">?.</span><span class="s1">values </span><span class="s3">?? {})) {</span>
          <span class="s7">// Ignore undefined and null values</span>
          <span class="s0">if </span><span class="s3">(</span><span class="s1">value </span><span class="s3">== </span><span class="s0">null</span><span class="s3">) {</span>
            <span class="s0">continue</span>
          <span class="s3">}</span>

          <span class="s0">let </span><span class="s1">cls </span><span class="s3">= </span><span class="s1">formatClass</span><span class="s3">(</span><span class="s1">utilName</span><span class="s3">, </span><span class="s1">key</span><span class="s3">)</span>
          <span class="s1">output</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">includeMetadata </span><span class="s3">? [</span><span class="s1">cls</span><span class="s3">, </span><span class="s1">metadata</span><span class="s3">] : </span><span class="s1">cls</span><span class="s3">)</span>

          <span class="s0">if </span><span class="s3">(</span><span class="s1">utilOptions</span><span class="s3">?.</span><span class="s1">supportsNegativeValues </span><span class="s3">&amp;&amp; </span><span class="s1">negateValue</span><span class="s3">(</span><span class="s1">value</span><span class="s3">)) {</span>
            <span class="s0">let </span><span class="s1">cls </span><span class="s3">= </span><span class="s1">formatClass</span><span class="s3">(</span><span class="s1">utilName</span><span class="s3">, </span><span class="s2">`-</span><span class="s1">$</span><span class="s3">{</span><span class="s1">key</span><span class="s3">}</span><span class="s2">`</span><span class="s3">)</span>
            <span class="s1">negativeClasses</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">includeMetadata </span><span class="s3">? [</span><span class="s1">cls</span><span class="s3">, </span><span class="s1">metadata</span><span class="s3">] : </span><span class="s1">cls</span><span class="s3">)</span>
          <span class="s3">}</span>
        <span class="s3">}</span>

        <span class="s1">output</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">...negativeClasses</span><span class="s3">)</span>
      <span class="s3">} </span><span class="s0">else </span><span class="s3">{</span>
        <span class="s1">output</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">util</span><span class="s3">)</span>
      <span class="s3">}</span>
    <span class="s3">}</span>

    <span class="s0">return </span><span class="s1">output</span>
  <span class="s3">}</span>

  <span class="s7">// Generate a list of available variants with meta information of the type of variant.</span>
  <span class="s1">context</span><span class="s3">.</span><span class="s1">getVariants </span><span class="s3">= </span><span class="s0">function </span><span class="s1">getVariants</span><span class="s3">() {</span>
    <span class="s7">// We use a unique, random ID for candidate names to avoid conflicts</span>
    <span class="s7">// We can't use characters like `_`, `:`, `@` or `.` because they might</span>
    <span class="s7">// be used as a separator</span>
    <span class="s0">let </span><span class="s1">id </span><span class="s3">= </span><span class="s1">Math</span><span class="s3">.</span><span class="s1">random</span><span class="s3">().</span><span class="s1">toString</span><span class="s3">(</span><span class="s4">36</span><span class="s3">).</span><span class="s1">substring</span><span class="s3">(</span><span class="s4">7</span><span class="s3">).</span><span class="s1">toUpperCase</span><span class="s3">()</span>

    <span class="s0">let </span><span class="s1">result </span><span class="s3">= []</span>
    <span class="s0">for </span><span class="s3">(</span><span class="s0">let </span><span class="s3">[</span><span class="s1">name</span><span class="s3">, </span><span class="s1">options</span><span class="s3">] </span><span class="s1">of context</span><span class="s3">.</span><span class="s1">variantOptions</span><span class="s3">.</span><span class="s1">entries</span><span class="s3">()) {</span>
      <span class="s0">if </span><span class="s3">(</span><span class="s1">options</span><span class="s3">.</span><span class="s1">variantInfo </span><span class="s3">=== </span><span class="s1">VARIANT_INFO</span><span class="s3">.</span><span class="s1">Base</span><span class="s3">) </span><span class="s0">continue</span>

      <span class="s1">result</span><span class="s3">.</span><span class="s1">push</span><span class="s3">({</span>
        <span class="s1">name</span><span class="s3">,</span>
        <span class="s1">isArbitrary</span><span class="s3">: </span><span class="s1">options</span><span class="s3">.</span><span class="s1">type </span><span class="s3">=== </span><span class="s1">Symbol</span><span class="s3">.</span><span class="s1">for</span><span class="s3">(</span><span class="s2">'MATCH_VARIANT'</span><span class="s3">),</span>
        <span class="s1">values</span><span class="s3">: </span><span class="s1">Object</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">(</span><span class="s1">options</span><span class="s3">.</span><span class="s1">values </span><span class="s3">?? {}),</span>
        <span class="s1">hasDash</span><span class="s3">: </span><span class="s1">name </span><span class="s3">!== </span><span class="s2">'@'</span><span class="s3">,</span>
        <span class="s1">selectors</span><span class="s3">({ </span><span class="s1">modifier</span><span class="s3">, </span><span class="s1">value </span><span class="s3">} = {}) {</span>
          <span class="s0">let </span><span class="s1">candidate </span><span class="s3">= </span><span class="s2">`TAILWINDPLACEHOLDER</span><span class="s1">$</span><span class="s3">{</span><span class="s1">id</span><span class="s3">}</span><span class="s2">`</span>

          <span class="s0">let </span><span class="s1">rule </span><span class="s3">= </span><span class="s1">postcss</span><span class="s3">.</span><span class="s1">rule</span><span class="s3">({ </span><span class="s1">selector</span><span class="s3">: </span><span class="s2">`.</span><span class="s1">$</span><span class="s3">{</span><span class="s1">candidate</span><span class="s3">}</span><span class="s2">` </span><span class="s3">})</span>
          <span class="s0">let </span><span class="s1">container </span><span class="s3">= </span><span class="s1">postcss</span><span class="s3">.</span><span class="s1">root</span><span class="s3">({ </span><span class="s1">nodes</span><span class="s3">: [</span><span class="s1">rule</span><span class="s3">.</span><span class="s1">clone</span><span class="s3">()] })</span>

          <span class="s0">let </span><span class="s1">before </span><span class="s3">= </span><span class="s1">container</span><span class="s3">.</span><span class="s1">toString</span><span class="s3">()</span>

          <span class="s0">let </span><span class="s1">fns </span><span class="s3">= (</span><span class="s1">context</span><span class="s3">.</span><span class="s1">variantMap</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">name</span><span class="s3">) ?? []).</span><span class="s1">flatMap</span><span class="s3">(([</span><span class="s1">_</span><span class="s3">, </span><span class="s1">fn</span><span class="s3">]) =&gt; </span><span class="s1">fn</span><span class="s3">)</span>
          <span class="s0">let </span><span class="s1">formatStrings </span><span class="s3">= []</span>
          <span class="s0">for </span><span class="s3">(</span><span class="s0">let </span><span class="s1">fn of fns</span><span class="s3">) {</span>
            <span class="s0">let </span><span class="s1">localFormatStrings </span><span class="s3">= []</span>

            <span class="s0">let </span><span class="s1">api </span><span class="s3">= {</span>
              <span class="s1">args</span><span class="s3">: { </span><span class="s1">modifier</span><span class="s3">, </span><span class="s1">value</span><span class="s3">: </span><span class="s1">options</span><span class="s3">.</span><span class="s1">values</span><span class="s3">?.[</span><span class="s1">value</span><span class="s3">] ?? </span><span class="s1">value </span><span class="s3">},</span>
              <span class="s1">separator</span><span class="s3">: </span><span class="s1">context</span><span class="s3">.</span><span class="s1">tailwindConfig</span><span class="s3">.</span><span class="s1">separator</span><span class="s3">,</span>
              <span class="s1">modifySelectors</span><span class="s3">(</span><span class="s1">modifierFunction</span><span class="s3">) {</span>
                <span class="s7">// Run the modifierFunction over each rule</span>
                <span class="s1">container</span><span class="s3">.</span><span class="s1">each</span><span class="s3">((</span><span class="s1">rule</span><span class="s3">) =&gt; {</span>
                  <span class="s0">if </span><span class="s3">(</span><span class="s1">rule</span><span class="s3">.</span><span class="s1">type </span><span class="s3">!== </span><span class="s2">'rule'</span><span class="s3">) {</span>
                    <span class="s0">return</span>
                  <span class="s3">}</span>

                  <span class="s1">rule</span><span class="s3">.</span><span class="s1">selectors </span><span class="s3">= </span><span class="s1">rule</span><span class="s3">.</span><span class="s1">selectors</span><span class="s3">.</span><span class="s1">map</span><span class="s3">((</span><span class="s1">selector</span><span class="s3">) =&gt; {</span>
                    <span class="s0">return </span><span class="s1">modifierFunction</span><span class="s3">({</span>
                      <span class="s1">get className</span><span class="s3">() {</span>
                        <span class="s0">return </span><span class="s1">getClassNameFromSelector</span><span class="s3">(</span><span class="s1">selector</span><span class="s3">)</span>
                      <span class="s3">},</span>
                      <span class="s1">selector</span><span class="s3">,</span>
                    <span class="s3">})</span>
                  <span class="s3">})</span>
                <span class="s3">})</span>

                <span class="s0">return </span><span class="s1">container</span>
              <span class="s3">},</span>
              <span class="s1">format</span><span class="s3">(</span><span class="s1">str</span><span class="s3">) {</span>
                <span class="s1">localFormatStrings</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">str</span><span class="s3">)</span>
              <span class="s3">},</span>
              <span class="s1">wrap</span><span class="s3">(</span><span class="s1">wrapper</span><span class="s3">) {</span>
                <span class="s1">localFormatStrings</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s2">`@</span><span class="s1">$</span><span class="s3">{</span><span class="s1">wrapper</span><span class="s3">.</span><span class="s1">name</span><span class="s3">} </span><span class="s1">$</span><span class="s3">{</span><span class="s1">wrapper</span><span class="s3">.</span><span class="s1">params</span><span class="s3">} </span><span class="s2">{ &amp; }`</span><span class="s3">)</span>
              <span class="s3">},</span>
              <span class="s1">container</span><span class="s3">,</span>
            <span class="s3">}</span>

            <span class="s0">let </span><span class="s1">ruleWithVariant </span><span class="s3">= </span><span class="s1">fn</span><span class="s3">(</span><span class="s1">api</span><span class="s3">)</span>
            <span class="s0">if </span><span class="s3">(</span><span class="s1">localFormatStrings</span><span class="s3">.</span><span class="s1">length </span><span class="s3">&gt; </span><span class="s4">0</span><span class="s3">) {</span>
              <span class="s1">formatStrings</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">localFormatStrings</span><span class="s3">)</span>
            <span class="s3">}</span>

            <span class="s0">if </span><span class="s3">(</span><span class="s1">Array</span><span class="s3">.</span><span class="s1">isArray</span><span class="s3">(</span><span class="s1">ruleWithVariant</span><span class="s3">)) {</span>
              <span class="s0">for </span><span class="s3">(</span><span class="s0">let </span><span class="s1">variantFunction of ruleWithVariant</span><span class="s3">) {</span>
                <span class="s1">localFormatStrings </span><span class="s3">= []</span>
                <span class="s1">variantFunction</span><span class="s3">(</span><span class="s1">api</span><span class="s3">)</span>
                <span class="s1">formatStrings</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">localFormatStrings</span><span class="s3">)</span>
              <span class="s3">}</span>
            <span class="s3">}</span>
          <span class="s3">}</span>

          <span class="s7">// Reverse engineer the result of the `container`</span>
          <span class="s0">let </span><span class="s1">manualFormatStrings </span><span class="s3">= []</span>
          <span class="s0">let </span><span class="s1">after </span><span class="s3">= </span><span class="s1">container</span><span class="s3">.</span><span class="s1">toString</span><span class="s3">()</span>

          <span class="s0">if </span><span class="s3">(</span><span class="s1">before </span><span class="s3">!== </span><span class="s1">after</span><span class="s3">) {</span>
            <span class="s7">// Figure out all selectors</span>
            <span class="s1">container</span><span class="s3">.</span><span class="s1">walkRules</span><span class="s3">((</span><span class="s1">rule</span><span class="s3">) =&gt; {</span>
              <span class="s0">let </span><span class="s1">modified </span><span class="s3">= </span><span class="s1">rule</span><span class="s3">.</span><span class="s1">selector</span>

              <span class="s7">// Rebuild the base selector, this is what plugin authors would do</span>
              <span class="s7">// as well. E.g.: `${variant}${separator}${className}`.</span>
              <span class="s7">// However, plugin authors probably also prepend or append certain</span>
              <span class="s7">// classes, pseudos, ids, ...</span>
              <span class="s0">let </span><span class="s1">rebuiltBase </span><span class="s3">= </span><span class="s1">selectorParser</span><span class="s3">((</span><span class="s1">selectors</span><span class="s3">) =&gt; {</span>
                <span class="s1">selectors</span><span class="s3">.</span><span class="s1">walkClasses</span><span class="s3">((</span><span class="s1">classNode</span><span class="s3">) =&gt; {</span>
                  <span class="s1">classNode</span><span class="s3">.</span><span class="s1">value </span><span class="s3">= </span><span class="s2">`</span><span class="s1">$</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s1">$</span><span class="s3">{</span><span class="s1">context</span><span class="s3">.</span><span class="s1">tailwindConfig</span><span class="s3">.</span><span class="s1">separator</span><span class="s3">}</span><span class="s1">$</span><span class="s3">{</span><span class="s1">classNode</span><span class="s3">.</span><span class="s1">value</span><span class="s3">}</span><span class="s2">`</span>
                <span class="s3">})</span>
              <span class="s3">}).</span><span class="s1">processSync</span><span class="s3">(</span><span class="s1">modified</span><span class="s3">)</span>

              <span class="s7">// Now that we know the original selector, the new selector, and</span>
              <span class="s7">// the rebuild part in between, we can replace the part that plugin</span>
              <span class="s7">// authors need to rebuild with `&amp;`, and eventually store it in the</span>
              <span class="s7">// collectedFormats. Similar to what `format('...')` would do.</span>
              <span class="s7">//</span>
              <span class="s7">// E.g.:</span>
              <span class="s7">//                   variant: foo</span>
              <span class="s7">//                  selector: .markdown &gt; p</span>
              <span class="s7">//      modified (by plugin): .foo .foo\\:markdown &gt; p</span>
              <span class="s7">//    rebuiltBase (internal): .foo\\:markdown &gt; p</span>
              <span class="s7">//                    format: .foo &amp;</span>
              <span class="s1">manualFormatStrings</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">modified</span><span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span><span class="s1">rebuiltBase</span><span class="s3">, </span><span class="s2">'&amp;'</span><span class="s3">).</span><span class="s1">replace</span><span class="s3">(</span><span class="s1">candidate</span><span class="s3">, </span><span class="s2">'&amp;'</span><span class="s3">))</span>
            <span class="s3">})</span>

            <span class="s7">// Figure out all atrules</span>
            <span class="s1">container</span><span class="s3">.</span><span class="s1">walkAtRules</span><span class="s3">((</span><span class="s1">atrule</span><span class="s3">) =&gt; {</span>
              <span class="s1">manualFormatStrings</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s2">`@</span><span class="s1">$</span><span class="s3">{</span><span class="s1">atrule</span><span class="s3">.</span><span class="s1">name</span><span class="s3">} </span><span class="s2">(</span><span class="s1">$</span><span class="s3">{</span><span class="s1">atrule</span><span class="s3">.</span><span class="s1">params</span><span class="s3">}</span><span class="s2">) { &amp; }`</span><span class="s3">)</span>
            <span class="s3">})</span>
          <span class="s3">}</span>

          <span class="s0">let </span><span class="s1">isArbitraryVariant </span><span class="s3">= !(</span><span class="s1">value </span><span class="s0">in </span><span class="s3">(</span><span class="s1">options</span><span class="s3">.</span><span class="s1">values </span><span class="s3">?? {}))</span>
          <span class="s0">let </span><span class="s1">internalFeatures </span><span class="s3">= </span><span class="s1">options</span><span class="s3">[</span><span class="s1">INTERNAL_FEATURES</span><span class="s3">] ?? {}</span>

          <span class="s0">let </span><span class="s1">respectPrefix </span><span class="s3">= (() =&gt; {</span>
            <span class="s0">if </span><span class="s3">(</span><span class="s1">isArbitraryVariant</span><span class="s3">) </span><span class="s0">return false</span>
            <span class="s0">if </span><span class="s3">(</span><span class="s1">internalFeatures</span><span class="s3">.</span><span class="s1">respectPrefix </span><span class="s3">=== </span><span class="s0">false</span><span class="s3">) </span><span class="s0">return false</span>
            <span class="s0">return true</span>
          <span class="s3">})()</span>

          <span class="s1">formatStrings </span><span class="s3">= </span><span class="s1">formatStrings</span><span class="s3">.</span><span class="s1">map</span><span class="s3">((</span><span class="s1">format</span><span class="s3">) =&gt;</span>
            <span class="s1">format</span><span class="s3">.</span><span class="s1">map</span><span class="s3">((</span><span class="s1">str</span><span class="s3">) =&gt; ({</span>
              <span class="s1">format</span><span class="s3">: </span><span class="s1">str</span><span class="s3">,</span>
              <span class="s1">respectPrefix</span><span class="s3">,</span>
            <span class="s3">}))</span>
          <span class="s3">)</span>

          <span class="s1">manualFormatStrings </span><span class="s3">= </span><span class="s1">manualFormatStrings</span><span class="s3">.</span><span class="s1">map</span><span class="s3">((</span><span class="s1">format</span><span class="s3">) =&gt; ({</span>
            <span class="s1">format</span><span class="s3">,</span>
            <span class="s1">respectPrefix</span><span class="s3">,</span>
          <span class="s3">}))</span>

          <span class="s0">let </span><span class="s1">opts </span><span class="s3">= {</span>
            <span class="s1">candidate</span><span class="s3">,</span>
            <span class="s1">context</span><span class="s3">,</span>
          <span class="s3">}</span>

          <span class="s0">let </span><span class="s1">result </span><span class="s3">= </span><span class="s1">formatStrings</span><span class="s3">.</span><span class="s1">map</span><span class="s3">((</span><span class="s1">formats</span><span class="s3">) =&gt;</span>
            <span class="s1">finalizeSelector</span><span class="s3">(</span><span class="s2">`.</span><span class="s1">$</span><span class="s3">{</span><span class="s1">candidate</span><span class="s3">}</span><span class="s2">`</span><span class="s3">, </span><span class="s1">formatVariantSelector</span><span class="s3">(</span><span class="s1">formats</span><span class="s3">, </span><span class="s1">opts</span><span class="s3">), </span><span class="s1">opts</span><span class="s3">)</span>
              <span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span><span class="s2">`.</span><span class="s1">$</span><span class="s3">{</span><span class="s1">candidate</span><span class="s3">}</span><span class="s2">`</span><span class="s3">, </span><span class="s2">'&amp;'</span><span class="s3">)</span>
              <span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span><span class="s2">'{ &amp; }'</span><span class="s3">, </span><span class="s2">''</span><span class="s3">)</span>
              <span class="s3">.</span><span class="s1">trim</span><span class="s3">()</span>
          <span class="s3">)</span>

          <span class="s0">if </span><span class="s3">(</span><span class="s1">manualFormatStrings</span><span class="s3">.</span><span class="s1">length </span><span class="s3">&gt; </span><span class="s4">0</span><span class="s3">) {</span>
            <span class="s1">result</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span>
              <span class="s1">formatVariantSelector</span><span class="s3">(</span><span class="s1">manualFormatStrings</span><span class="s3">, </span><span class="s1">opts</span><span class="s3">)</span>
                <span class="s3">.</span><span class="s1">toString</span><span class="s3">()</span>
                <span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span><span class="s2">`.</span><span class="s1">$</span><span class="s3">{</span><span class="s1">candidate</span><span class="s3">}</span><span class="s2">`</span><span class="s3">, </span><span class="s2">'&amp;'</span><span class="s3">)</span>
            <span class="s3">)</span>
          <span class="s3">}</span>

          <span class="s0">return </span><span class="s1">result</span>
        <span class="s3">},</span>
      <span class="s3">})</span>
    <span class="s3">}</span>

    <span class="s0">return </span><span class="s1">result</span>
  <span class="s3">}</span>
<span class="s3">}</span>

<span class="s5">/**</span>
 <span class="s5">* Mark as class as retroactively invalid</span>
 <span class="s5">*</span>
 <span class="s5">*</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string} candidate</span>
 <span class="s5">*/</span>
<span class="s0">function </span><span class="s1">markInvalidUtilityCandidate</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">candidate</span><span class="s3">) {</span>
  <span class="s0">if </span><span class="s3">(!</span><span class="s1">context</span><span class="s3">.</span><span class="s1">classCache</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s1">candidate</span><span class="s3">)) {</span>
    <span class="s0">return</span>
  <span class="s3">}</span>

  <span class="s7">// Mark this as not being a real utility</span>
  <span class="s1">context</span><span class="s3">.</span><span class="s1">notClassCache</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">candidate</span><span class="s3">)</span>

  <span class="s7">// Remove it from any candidate-specific caches</span>
  <span class="s1">context</span><span class="s3">.</span><span class="s1">classCache</span><span class="s3">.</span><span class="s1">delete</span><span class="s3">(</span><span class="s1">candidate</span><span class="s3">)</span>
  <span class="s1">context</span><span class="s3">.</span><span class="s1">applyClassCache</span><span class="s3">.</span><span class="s1">delete</span><span class="s3">(</span><span class="s1">candidate</span><span class="s3">)</span>
  <span class="s1">context</span><span class="s3">.</span><span class="s1">candidateRuleMap</span><span class="s3">.</span><span class="s1">delete</span><span class="s3">(</span><span class="s1">candidate</span><span class="s3">)</span>
  <span class="s1">context</span><span class="s3">.</span><span class="s1">candidateRuleCache</span><span class="s3">.</span><span class="s1">delete</span><span class="s3">(</span><span class="s1">candidate</span><span class="s3">)</span>

  <span class="s7">// Ensure the stylesheet gets rebuilt</span>
  <span class="s1">context</span><span class="s3">.</span><span class="s1">stylesheetCache </span><span class="s3">= </span><span class="s0">null</span>
<span class="s3">}</span>

<span class="s5">/**</span>
 <span class="s5">* Mark as class as retroactively invalid</span>
 <span class="s5">*</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{import('postcss').Node} node</span>
 <span class="s5">*/</span>
<span class="s0">function </span><span class="s1">markInvalidUtilityNode</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">node</span><span class="s3">) {</span>
  <span class="s0">let </span><span class="s1">candidate </span><span class="s3">= </span><span class="s1">node</span><span class="s3">.</span><span class="s1">raws</span><span class="s3">.</span><span class="s1">tailwind</span><span class="s3">.</span><span class="s1">candidate</span>

  <span class="s0">if </span><span class="s3">(!</span><span class="s1">candidate</span><span class="s3">) {</span>
    <span class="s0">return</span>
  <span class="s3">}</span>

  <span class="s0">for </span><span class="s3">(</span><span class="s0">const </span><span class="s1">entry of context</span><span class="s3">.</span><span class="s1">ruleCache</span><span class="s3">) {</span>
    <span class="s0">if </span><span class="s3">(</span><span class="s1">entry</span><span class="s3">[</span><span class="s4">1</span><span class="s3">].</span><span class="s1">raws</span><span class="s3">.</span><span class="s1">tailwind</span><span class="s3">.</span><span class="s1">candidate </span><span class="s3">=== </span><span class="s1">candidate</span><span class="s3">) {</span>
      <span class="s1">context</span><span class="s3">.</span><span class="s1">ruleCache</span><span class="s3">.</span><span class="s1">delete</span><span class="s3">(</span><span class="s1">entry</span><span class="s3">)</span>
      <span class="s7">// context.postCssNodeCache.delete(node)</span>
    <span class="s3">}</span>
  <span class="s3">}</span>

  <span class="s1">markInvalidUtilityCandidate</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">candidate</span><span class="s3">)</span>
<span class="s3">}</span>

<span class="s0">export function </span><span class="s1">createContext</span><span class="s3">(</span><span class="s1">tailwindConfig</span><span class="s3">, </span><span class="s1">changedContent </span><span class="s3">= [], </span><span class="s1">root </span><span class="s3">= </span><span class="s1">postcss</span><span class="s3">.</span><span class="s1">root</span><span class="s3">()) {</span>
  <span class="s0">let </span><span class="s1">context </span><span class="s3">= {</span>
    <span class="s1">disposables</span><span class="s3">: [],</span>
    <span class="s1">ruleCache</span><span class="s3">: </span><span class="s0">new </span><span class="s1">Set</span><span class="s3">(),</span>
    <span class="s1">candidateRuleCache</span><span class="s3">: </span><span class="s0">new </span><span class="s1">Map</span><span class="s3">(),</span>
    <span class="s1">classCache</span><span class="s3">: </span><span class="s0">new </span><span class="s1">Map</span><span class="s3">(),</span>
    <span class="s1">applyClassCache</span><span class="s3">: </span><span class="s0">new </span><span class="s1">Map</span><span class="s3">(),</span>
    <span class="s7">// Seed the not class cache with the blocklist (which is only strings)</span>
    <span class="s1">notClassCache</span><span class="s3">: </span><span class="s0">new </span><span class="s1">Set</span><span class="s3">(</span><span class="s1">tailwindConfig</span><span class="s3">.</span><span class="s1">blocklist </span><span class="s3">?? []),</span>
    <span class="s1">postCssNodeCache</span><span class="s3">: </span><span class="s0">new </span><span class="s1">Map</span><span class="s3">(),</span>
    <span class="s1">candidateRuleMap</span><span class="s3">: </span><span class="s0">new </span><span class="s1">Map</span><span class="s3">(),</span>
    <span class="s1">tailwindConfig</span><span class="s3">,</span>
    <span class="s1">changedContent</span><span class="s3">: </span><span class="s1">changedContent</span><span class="s3">,</span>
    <span class="s1">variantMap</span><span class="s3">: </span><span class="s0">new </span><span class="s1">Map</span><span class="s3">(),</span>
    <span class="s1">stylesheetCache</span><span class="s3">: </span><span class="s0">null</span><span class="s3">,</span>
    <span class="s1">variantOptions</span><span class="s3">: </span><span class="s0">new </span><span class="s1">Map</span><span class="s3">(),</span>

    <span class="s1">markInvalidUtilityCandidate</span><span class="s3">: (</span><span class="s1">candidate</span><span class="s3">) =&gt; </span><span class="s1">markInvalidUtilityCandidate</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">candidate</span><span class="s3">),</span>
    <span class="s1">markInvalidUtilityNode</span><span class="s3">: (</span><span class="s1">node</span><span class="s3">) =&gt; </span><span class="s1">markInvalidUtilityNode</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">node</span><span class="s3">),</span>
  <span class="s3">}</span>

  <span class="s0">let </span><span class="s1">resolvedPlugins </span><span class="s3">= </span><span class="s1">resolvePlugins</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">root</span><span class="s3">)</span>
  <span class="s1">registerPlugins</span><span class="s3">(</span><span class="s1">resolvedPlugins</span><span class="s3">, </span><span class="s1">context</span><span class="s3">)</span>

  <span class="s0">return </span><span class="s1">context</span>
<span class="s3">}</span>

<span class="s0">let </span><span class="s1">contextMap </span><span class="s3">= </span><span class="s1">sharedState</span><span class="s3">.</span><span class="s1">contextMap</span>
<span class="s0">let </span><span class="s1">configContextMap </span><span class="s3">= </span><span class="s1">sharedState</span><span class="s3">.</span><span class="s1">configContextMap</span>
<span class="s0">let </span><span class="s1">contextSourcesMap </span><span class="s3">= </span><span class="s1">sharedState</span><span class="s3">.</span><span class="s1">contextSourcesMap</span>

<span class="s0">export function </span><span class="s1">getContext</span><span class="s3">(</span>
  <span class="s1">root</span><span class="s3">,</span>
  <span class="s1">result</span><span class="s3">,</span>
  <span class="s1">tailwindConfig</span><span class="s3">,</span>
  <span class="s1">userConfigPath</span><span class="s3">,</span>
  <span class="s1">tailwindConfigHash</span><span class="s3">,</span>
  <span class="s1">contextDependencies</span>
<span class="s3">) {</span>
  <span class="s0">let </span><span class="s1">sourcePath </span><span class="s3">= </span><span class="s1">result</span><span class="s3">.</span><span class="s1">opts</span><span class="s3">.</span><span class="s1">from</span>
  <span class="s0">let </span><span class="s1">isConfigFile </span><span class="s3">= </span><span class="s1">userConfigPath </span><span class="s3">!== </span><span class="s0">null</span>

  <span class="s1">env</span><span class="s3">.</span><span class="s1">DEBUG </span><span class="s3">&amp;&amp; </span><span class="s1">console</span><span class="s3">.</span><span class="s1">log</span><span class="s3">(</span><span class="s2">'Source path:'</span><span class="s3">, </span><span class="s1">sourcePath</span><span class="s3">)</span>

  <span class="s0">let </span><span class="s1">existingContext</span>

  <span class="s0">if </span><span class="s3">(</span><span class="s1">isConfigFile </span><span class="s3">&amp;&amp; </span><span class="s1">contextMap</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s1">sourcePath</span><span class="s3">)) {</span>
    <span class="s1">existingContext </span><span class="s3">= </span><span class="s1">contextMap</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">sourcePath</span><span class="s3">)</span>
  <span class="s3">} </span><span class="s0">else if </span><span class="s3">(</span><span class="s1">configContextMap</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s1">tailwindConfigHash</span><span class="s3">)) {</span>
    <span class="s0">let </span><span class="s1">context </span><span class="s3">= </span><span class="s1">configContextMap</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">tailwindConfigHash</span><span class="s3">)</span>
    <span class="s1">contextSourcesMap</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">context</span><span class="s3">).</span><span class="s1">add</span><span class="s3">(</span><span class="s1">sourcePath</span><span class="s3">)</span>
    <span class="s1">contextMap</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">sourcePath</span><span class="s3">, </span><span class="s1">context</span><span class="s3">)</span>

    <span class="s1">existingContext </span><span class="s3">= </span><span class="s1">context</span>
  <span class="s3">}</span>

  <span class="s0">let </span><span class="s1">cssDidChange </span><span class="s3">= </span><span class="s1">hasContentChanged</span><span class="s3">(</span><span class="s1">sourcePath</span><span class="s3">, </span><span class="s1">root</span><span class="s3">)</span>

  <span class="s7">// If there's already a context in the cache and we don't need to</span>
  <span class="s7">// reset the context, return the cached context.</span>
  <span class="s0">if </span><span class="s3">(</span><span class="s1">existingContext</span><span class="s3">) {</span>
    <span class="s0">let </span><span class="s3">[</span><span class="s1">contextDependenciesChanged</span><span class="s3">, </span><span class="s1">mtimesToCommit</span><span class="s3">] = </span><span class="s1">trackModified</span><span class="s3">(</span>
      <span class="s3">[</span><span class="s1">...contextDependencies</span><span class="s3">],</span>
      <span class="s1">getFileModifiedMap</span><span class="s3">(</span><span class="s1">existingContext</span><span class="s3">)</span>
    <span class="s3">)</span>
    <span class="s0">if </span><span class="s3">(!</span><span class="s1">contextDependenciesChanged </span><span class="s3">&amp;&amp; !</span><span class="s1">cssDidChange</span><span class="s3">) {</span>
      <span class="s0">return </span><span class="s3">[</span><span class="s1">existingContext</span><span class="s3">, </span><span class="s0">false</span><span class="s3">, </span><span class="s1">mtimesToCommit</span><span class="s3">]</span>
    <span class="s3">}</span>
  <span class="s3">}</span>

  <span class="s7">// If this source is in the context map, get the old context.</span>
  <span class="s7">// Remove this source from the context sources for the old context,</span>
  <span class="s7">// and clean up that context if no one else is using it. This can be</span>
  <span class="s7">// called by many processes in rapid succession, so we check for presence</span>
  <span class="s7">// first because the first process to run this code will wipe it out first.</span>
  <span class="s0">if </span><span class="s3">(</span><span class="s1">contextMap</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s1">sourcePath</span><span class="s3">)) {</span>
    <span class="s0">let </span><span class="s1">oldContext </span><span class="s3">= </span><span class="s1">contextMap</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">sourcePath</span><span class="s3">)</span>
    <span class="s0">if </span><span class="s3">(</span><span class="s1">contextSourcesMap</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s1">oldContext</span><span class="s3">)) {</span>
      <span class="s1">contextSourcesMap</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">oldContext</span><span class="s3">).</span><span class="s1">delete</span><span class="s3">(</span><span class="s1">sourcePath</span><span class="s3">)</span>
      <span class="s0">if </span><span class="s3">(</span><span class="s1">contextSourcesMap</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">oldContext</span><span class="s3">).</span><span class="s1">size </span><span class="s3">=== </span><span class="s4">0</span><span class="s3">) {</span>
        <span class="s1">contextSourcesMap</span><span class="s3">.</span><span class="s1">delete</span><span class="s3">(</span><span class="s1">oldContext</span><span class="s3">)</span>
        <span class="s0">for </span><span class="s3">(</span><span class="s0">let </span><span class="s3">[</span><span class="s1">tailwindConfigHash</span><span class="s3">, </span><span class="s1">context</span><span class="s3">] </span><span class="s1">of configContextMap</span><span class="s3">) {</span>
          <span class="s0">if </span><span class="s3">(</span><span class="s1">context </span><span class="s3">=== </span><span class="s1">oldContext</span><span class="s3">) {</span>
            <span class="s1">configContextMap</span><span class="s3">.</span><span class="s1">delete</span><span class="s3">(</span><span class="s1">tailwindConfigHash</span><span class="s3">)</span>
          <span class="s3">}</span>
        <span class="s3">}</span>
        <span class="s0">for </span><span class="s3">(</span><span class="s0">let </span><span class="s1">disposable of oldContext</span><span class="s3">.</span><span class="s1">disposables</span><span class="s3">.</span><span class="s1">splice</span><span class="s3">(</span><span class="s4">0</span><span class="s3">)) {</span>
          <span class="s1">disposable</span><span class="s3">(</span><span class="s1">oldContext</span><span class="s3">)</span>
        <span class="s3">}</span>
      <span class="s3">}</span>
    <span class="s3">}</span>
  <span class="s3">}</span>

  <span class="s1">env</span><span class="s3">.</span><span class="s1">DEBUG </span><span class="s3">&amp;&amp; </span><span class="s1">console</span><span class="s3">.</span><span class="s1">log</span><span class="s3">(</span><span class="s2">'Setting up new context...'</span><span class="s3">)</span>

  <span class="s0">let </span><span class="s1">context </span><span class="s3">= </span><span class="s1">createContext</span><span class="s3">(</span><span class="s1">tailwindConfig</span><span class="s3">, [], </span><span class="s1">root</span><span class="s3">)</span>

  <span class="s1">Object</span><span class="s3">.</span><span class="s1">assign</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, {</span>
    <span class="s1">userConfigPath</span><span class="s3">,</span>
  <span class="s3">})</span>

  <span class="s0">let </span><span class="s3">[, </span><span class="s1">mtimesToCommit</span><span class="s3">] = </span><span class="s1">trackModified</span><span class="s3">([</span><span class="s1">...contextDependencies</span><span class="s3">], </span><span class="s1">getFileModifiedMap</span><span class="s3">(</span><span class="s1">context</span><span class="s3">))</span>

  <span class="s7">// ---</span>

  <span class="s7">// Update all context tracking state</span>

  <span class="s1">configContextMap</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">tailwindConfigHash</span><span class="s3">, </span><span class="s1">context</span><span class="s3">)</span>
  <span class="s1">contextMap</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">sourcePath</span><span class="s3">, </span><span class="s1">context</span><span class="s3">)</span>

  <span class="s0">if </span><span class="s3">(!</span><span class="s1">contextSourcesMap</span><span class="s3">.</span><span class="s1">has</span><span class="s3">(</span><span class="s1">context</span><span class="s3">)) {</span>
    <span class="s1">contextSourcesMap</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s0">new </span><span class="s1">Set</span><span class="s3">())</span>
  <span class="s3">}</span>

  <span class="s1">contextSourcesMap</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">context</span><span class="s3">).</span><span class="s1">add</span><span class="s3">(</span><span class="s1">sourcePath</span><span class="s3">)</span>

  <span class="s0">return </span><span class="s3">[</span><span class="s1">context</span><span class="s3">, </span><span class="s0">true</span><span class="s3">, </span><span class="s1">mtimesToCommit</span><span class="s3">]</span>
<span class="s3">}</span>
</pre>
</body>
</html>