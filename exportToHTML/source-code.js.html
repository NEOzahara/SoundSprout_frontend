<html>
<head>
<title>source-code.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #67a37c; font-style: italic;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #bcbec4;}
.s5 { color: #7a7e85;}
.s6 { color: #cf8e6d;}
.s7 { color: #2aacb8;}
.s8 { color: #42c3d4;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
source-code.js</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* </span><span class="s1">@fileoverview </span><span class="s0">Abstraction of JavaScript source code.</span>
 <span class="s0">* </span><span class="s1">@author </span><span class="s0">Nicholas C. Zakas</span>
 <span class="s0">*/</span>
<span class="s3">&quot;use strict&quot;</span><span class="s4">;</span>

<span class="s5">//------------------------------------------------------------------------------</span>
<span class="s5">// Requirements</span>
<span class="s5">//------------------------------------------------------------------------------</span>

<span class="s6">const</span>
    <span class="s4">{ </span><span class="s2">isCommentToken </span><span class="s4">} = </span><span class="s2">require</span><span class="s4">(</span><span class="s3">&quot;@eslint-community/eslint-utils&quot;</span><span class="s4">),</span>
    <span class="s2">TokenStore </span><span class="s4">= </span><span class="s2">require</span><span class="s4">(</span><span class="s3">&quot;./token-store&quot;</span><span class="s4">),</span>
    <span class="s2">astUtils </span><span class="s4">= </span><span class="s2">require</span><span class="s4">(</span><span class="s3">&quot;../shared/ast-utils&quot;</span><span class="s4">),</span>
    <span class="s2">Traverser </span><span class="s4">= </span><span class="s2">require</span><span class="s4">(</span><span class="s3">&quot;../shared/traverser&quot;</span><span class="s4">),</span>
    <span class="s2">globals </span><span class="s4">= </span><span class="s2">require</span><span class="s4">(</span><span class="s3">&quot;../../conf/globals&quot;</span><span class="s4">),</span>
    <span class="s4">{</span>
        <span class="s2">directivesPattern</span>
    <span class="s4">} = </span><span class="s2">require</span><span class="s4">(</span><span class="s3">&quot;../shared/directives&quot;</span><span class="s4">),</span>

    <span class="s5">/* eslint-disable-next-line n/no-restricted-require -- Too messy to figure out right now. */</span>
    <span class="s2">ConfigCommentParser </span><span class="s4">= </span><span class="s2">require</span><span class="s4">(</span><span class="s3">&quot;../linter/config-comment-parser&quot;</span><span class="s4">),</span>
    <span class="s2">eslintScope </span><span class="s4">= </span><span class="s2">require</span><span class="s4">(</span><span class="s3">&quot;eslint-scope&quot;</span><span class="s4">);</span>

<span class="s5">//------------------------------------------------------------------------------</span>
<span class="s5">// Type Definitions</span>
<span class="s5">//------------------------------------------------------------------------------</span>

<span class="s0">/** </span><span class="s1">@typedef </span><span class="s0">{import(&quot;eslint-scope&quot;).Variable} Variable */</span>

<span class="s5">//------------------------------------------------------------------------------</span>
<span class="s5">// Private</span>
<span class="s5">//------------------------------------------------------------------------------</span>

<span class="s6">const </span><span class="s2">commentParser </span><span class="s4">= </span><span class="s6">new </span><span class="s2">ConfigCommentParser</span><span class="s4">();</span>

<span class="s0">/**</span>
 <span class="s0">* Validates that the given AST has the required information.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} ast The Program node of the AST to check.</span>
 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{Error} If the AST doesn't contain the correct information.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
 <span class="s0">* </span><span class="s1">@private</span>
 <span class="s0">*/</span>
<span class="s6">function </span><span class="s2">validate</span><span class="s4">(</span><span class="s2">ast</span><span class="s4">) {</span>
    <span class="s6">if </span><span class="s4">(!</span><span class="s2">ast</span><span class="s4">.</span><span class="s2">tokens</span><span class="s4">) {</span>
        <span class="s6">throw new </span><span class="s2">Error</span><span class="s4">(</span><span class="s3">&quot;AST is missing the tokens array.&quot;</span><span class="s4">);</span>
    <span class="s4">}</span>

    <span class="s6">if </span><span class="s4">(!</span><span class="s2">ast</span><span class="s4">.</span><span class="s2">comments</span><span class="s4">) {</span>
        <span class="s6">throw new </span><span class="s2">Error</span><span class="s4">(</span><span class="s3">&quot;AST is missing the comments array.&quot;</span><span class="s4">);</span>
    <span class="s4">}</span>

    <span class="s6">if </span><span class="s4">(!</span><span class="s2">ast</span><span class="s4">.</span><span class="s2">loc</span><span class="s4">) {</span>
        <span class="s6">throw new </span><span class="s2">Error</span><span class="s4">(</span><span class="s3">&quot;AST is missing location information.&quot;</span><span class="s4">);</span>
    <span class="s4">}</span>

    <span class="s6">if </span><span class="s4">(!</span><span class="s2">ast</span><span class="s4">.</span><span class="s2">range</span><span class="s4">) {</span>
        <span class="s6">throw new </span><span class="s2">Error</span><span class="s4">(</span><span class="s3">&quot;AST is missing range information&quot;</span><span class="s4">);</span>
    <span class="s4">}</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Retrieves globals for the given ecmaVersion.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{number} ecmaVersion The version to retrieve globals for.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Object} The globals for the given ecmaVersion.</span>
 <span class="s0">*/</span>
<span class="s6">function </span><span class="s2">getGlobalsForEcmaVersion</span><span class="s4">(</span><span class="s2">ecmaVersion</span><span class="s4">) {</span>

    <span class="s6">switch </span><span class="s4">(</span><span class="s2">ecmaVersion</span><span class="s4">) {</span>
        <span class="s6">case </span><span class="s7">3</span><span class="s4">:</span>
            <span class="s6">return </span><span class="s2">globals</span><span class="s4">.</span><span class="s2">es3</span><span class="s4">;</span>

        <span class="s6">case </span><span class="s7">5</span><span class="s4">:</span>
            <span class="s6">return </span><span class="s2">globals</span><span class="s4">.</span><span class="s2">es5</span><span class="s4">;</span>

        <span class="s6">default</span><span class="s4">:</span>
            <span class="s6">if </span><span class="s4">(</span><span class="s2">ecmaVersion </span><span class="s4">&lt; </span><span class="s7">2015</span><span class="s4">) {</span>
                <span class="s6">return </span><span class="s2">globals</span><span class="s4">[</span><span class="s3">`es</span><span class="s2">$</span><span class="s4">{</span><span class="s2">ecmaVersion </span><span class="s4">+ </span><span class="s7">2009</span><span class="s4">}</span><span class="s3">`</span><span class="s4">];</span>
            <span class="s4">}</span>

            <span class="s6">return </span><span class="s2">globals</span><span class="s4">[</span><span class="s3">`es</span><span class="s2">$</span><span class="s4">{</span><span class="s2">ecmaVersion</span><span class="s4">}</span><span class="s3">`</span><span class="s4">];</span>
    <span class="s4">}</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Check to see if its a ES6 export declaration.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} astNode An AST node.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} whether the given node represents an export declaration.</span>
 <span class="s0">* </span><span class="s1">@private</span>
 <span class="s0">*/</span>
<span class="s6">function </span><span class="s2">looksLikeExport</span><span class="s4">(</span><span class="s2">astNode</span><span class="s4">) {</span>
    <span class="s6">return </span><span class="s2">astNode</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;ExportDefaultDeclaration&quot; </span><span class="s4">|| </span><span class="s2">astNode</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;ExportNamedDeclaration&quot; </span><span class="s4">||</span>
        <span class="s2">astNode</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;ExportAllDeclaration&quot; </span><span class="s4">|| </span><span class="s2">astNode</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;ExportSpecifier&quot;</span><span class="s4">;</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Merges two sorted lists into a larger sorted list in O(n) time.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Token[]} tokens The list of tokens.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Token[]} comments The list of comments.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Token[]} A sorted list of tokens and comments.</span>
 <span class="s0">* </span><span class="s1">@private</span>
 <span class="s0">*/</span>
<span class="s6">function </span><span class="s2">sortedMerge</span><span class="s4">(</span><span class="s2">tokens</span><span class="s4">, </span><span class="s2">comments</span><span class="s4">) {</span>
    <span class="s6">const </span><span class="s2">result </span><span class="s4">= [];</span>
    <span class="s6">let </span><span class="s2">tokenIndex </span><span class="s4">= </span><span class="s7">0</span><span class="s4">;</span>
    <span class="s6">let </span><span class="s2">commentIndex </span><span class="s4">= </span><span class="s7">0</span><span class="s4">;</span>

    <span class="s6">while </span><span class="s4">(</span><span class="s2">tokenIndex </span><span class="s4">&lt; </span><span class="s2">tokens</span><span class="s4">.</span><span class="s2">length </span><span class="s4">|| </span><span class="s2">commentIndex </span><span class="s4">&lt; </span><span class="s2">comments</span><span class="s4">.</span><span class="s2">length</span><span class="s4">) {</span>
        <span class="s6">if </span><span class="s4">(</span><span class="s2">commentIndex </span><span class="s4">&gt;= </span><span class="s2">comments</span><span class="s4">.</span><span class="s2">length </span><span class="s4">|| </span><span class="s2">tokenIndex </span><span class="s4">&lt; </span><span class="s2">tokens</span><span class="s4">.</span><span class="s2">length </span><span class="s4">&amp;&amp; </span><span class="s2">tokens</span><span class="s4">[</span><span class="s2">tokenIndex</span><span class="s4">].</span><span class="s2">range</span><span class="s4">[</span><span class="s7">0</span><span class="s4">] &lt; </span><span class="s2">comments</span><span class="s4">[</span><span class="s2">commentIndex</span><span class="s4">].</span><span class="s2">range</span><span class="s4">[</span><span class="s7">0</span><span class="s4">]) {</span>
            <span class="s2">result</span><span class="s4">.</span><span class="s2">push</span><span class="s4">(</span><span class="s2">tokens</span><span class="s4">[</span><span class="s2">tokenIndex</span><span class="s4">++]);</span>
        <span class="s4">} </span><span class="s6">else </span><span class="s4">{</span>
            <span class="s2">result</span><span class="s4">.</span><span class="s2">push</span><span class="s4">(</span><span class="s2">comments</span><span class="s4">[</span><span class="s2">commentIndex</span><span class="s4">++]);</span>
        <span class="s4">}</span>
    <span class="s4">}</span>

    <span class="s6">return </span><span class="s2">result</span><span class="s4">;</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Normalizes a value for a global in a config</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{(boolean|string|null)} configuredValue The value given for a global in configuration or in</span>
 <span class="s0">* a global directive comment</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{(&quot;readable&quot;|&quot;writeable&quot;|&quot;off&quot;)} The value normalized as a string</span>
 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">Error if global value is invalid</span>
 <span class="s0">*/</span>
<span class="s6">function </span><span class="s2">normalizeConfigGlobal</span><span class="s4">(</span><span class="s2">configuredValue</span><span class="s4">) {</span>
    <span class="s6">switch </span><span class="s4">(</span><span class="s2">configuredValue</span><span class="s4">) {</span>
        <span class="s6">case </span><span class="s3">&quot;off&quot;</span><span class="s4">:</span>
            <span class="s6">return </span><span class="s3">&quot;off&quot;</span><span class="s4">;</span>

        <span class="s6">case true</span><span class="s4">:</span>
        <span class="s6">case </span><span class="s3">&quot;true&quot;</span><span class="s4">:</span>
        <span class="s6">case </span><span class="s3">&quot;writeable&quot;</span><span class="s4">:</span>
        <span class="s6">case </span><span class="s3">&quot;writable&quot;</span><span class="s4">:</span>
            <span class="s6">return </span><span class="s3">&quot;writable&quot;</span><span class="s4">;</span>

        <span class="s6">case null</span><span class="s4">:</span>
        <span class="s6">case false</span><span class="s4">:</span>
        <span class="s6">case </span><span class="s3">&quot;false&quot;</span><span class="s4">:</span>
        <span class="s6">case </span><span class="s3">&quot;readable&quot;</span><span class="s4">:</span>
        <span class="s6">case </span><span class="s3">&quot;readonly&quot;</span><span class="s4">:</span>
            <span class="s6">return </span><span class="s3">&quot;readonly&quot;</span><span class="s4">;</span>

        <span class="s6">default</span><span class="s4">:</span>
            <span class="s6">throw new </span><span class="s2">Error</span><span class="s4">(</span><span class="s3">`'</span><span class="s2">$</span><span class="s4">{</span><span class="s2">configuredValue</span><span class="s4">}</span><span class="s3">' is not a valid configuration for a global (use 'readonly', 'writable', or 'off')`</span><span class="s4">);</span>
    <span class="s4">}</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Determines if two nodes or tokens overlap.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode|Token} first The first node or token to check.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode|Token} second The second node or token to check.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} True if the two nodes or tokens overlap.</span>
 <span class="s0">* </span><span class="s1">@private</span>
 <span class="s0">*/</span>
<span class="s6">function </span><span class="s2">nodesOrTokensOverlap</span><span class="s4">(</span><span class="s2">first</span><span class="s4">, </span><span class="s2">second</span><span class="s4">) {</span>
    <span class="s6">return </span><span class="s4">(</span><span class="s2">first</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s7">0</span><span class="s4">] &lt;= </span><span class="s2">second</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s7">0</span><span class="s4">] &amp;&amp; </span><span class="s2">first</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s7">1</span><span class="s4">] &gt;= </span><span class="s2">second</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s7">0</span><span class="s4">]) ||</span>
        <span class="s4">(</span><span class="s2">second</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s7">0</span><span class="s4">] &lt;= </span><span class="s2">first</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s7">0</span><span class="s4">] &amp;&amp; </span><span class="s2">second</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s7">1</span><span class="s4">] &gt;= </span><span class="s2">first</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s7">0</span><span class="s4">]);</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Determines if two nodes or tokens have at least one whitespace character</span>
 <span class="s0">* between them. Order does not matter. Returns false if the given nodes or</span>
 <span class="s0">* tokens overlap.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{SourceCode} sourceCode The source code object.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode|Token} first The first node or token to check between.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode|Token} second The second node or token to check between.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{boolean} checkInsideOfJSXText If `true` is present, check inside of JSXText tokens for backward compatibility.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} True if there is a whitespace character between</span>
 <span class="s0">* any of the tokens found between the two given nodes or tokens.</span>
 <span class="s0">* </span><span class="s1">@public</span>
 <span class="s0">*/</span>
<span class="s6">function </span><span class="s2">isSpaceBetween</span><span class="s4">(</span><span class="s2">sourceCode</span><span class="s4">, </span><span class="s2">first</span><span class="s4">, </span><span class="s2">second</span><span class="s4">, </span><span class="s2">checkInsideOfJSXText</span><span class="s4">) {</span>
    <span class="s6">if </span><span class="s4">(</span><span class="s2">nodesOrTokensOverlap</span><span class="s4">(</span><span class="s2">first</span><span class="s4">, </span><span class="s2">second</span><span class="s4">)) {</span>
        <span class="s6">return false</span><span class="s4">;</span>
    <span class="s4">}</span>

    <span class="s6">const </span><span class="s4">[</span><span class="s2">startingNodeOrToken</span><span class="s4">, </span><span class="s2">endingNodeOrToken</span><span class="s4">] = </span><span class="s2">first</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s7">1</span><span class="s4">] &lt;= </span><span class="s2">second</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s7">0</span><span class="s4">]</span>
        <span class="s4">? [</span><span class="s2">first</span><span class="s4">, </span><span class="s2">second</span><span class="s4">]</span>
        <span class="s4">: [</span><span class="s2">second</span><span class="s4">, </span><span class="s2">first</span><span class="s4">];</span>
    <span class="s6">const </span><span class="s2">firstToken </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getLastToken</span><span class="s4">(</span><span class="s2">startingNodeOrToken</span><span class="s4">) || </span><span class="s2">startingNodeOrToken</span><span class="s4">;</span>
    <span class="s6">const </span><span class="s2">finalToken </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getFirstToken</span><span class="s4">(</span><span class="s2">endingNodeOrToken</span><span class="s4">) || </span><span class="s2">endingNodeOrToken</span><span class="s4">;</span>
    <span class="s6">let </span><span class="s2">currentToken </span><span class="s4">= </span><span class="s2">firstToken</span><span class="s4">;</span>

    <span class="s6">while </span><span class="s4">(</span><span class="s2">currentToken </span><span class="s4">!== </span><span class="s2">finalToken</span><span class="s4">) {</span>
        <span class="s6">const </span><span class="s2">nextToken </span><span class="s4">= </span><span class="s2">sourceCode</span><span class="s4">.</span><span class="s2">getTokenAfter</span><span class="s4">(</span><span class="s2">currentToken</span><span class="s4">, { </span><span class="s2">includeComments</span><span class="s4">: </span><span class="s6">true </span><span class="s4">});</span>

        <span class="s6">if </span><span class="s4">(</span>
            <span class="s2">currentToken</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s7">1</span><span class="s4">] !== </span><span class="s2">nextToken</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s7">0</span><span class="s4">] ||</span>

                <span class="s5">/* 
                 * For backward compatibility, check spaces in JSXText. 
                 * https://github.com/eslint/eslint/issues/12614 
                 */</span>
                <span class="s4">(</span>
                    <span class="s2">checkInsideOfJSXText </span><span class="s4">&amp;&amp;</span>
                    <span class="s2">nextToken </span><span class="s4">!== </span><span class="s2">finalToken </span><span class="s4">&amp;&amp;</span>
                    <span class="s2">nextToken</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;JSXText&quot; </span><span class="s4">&amp;&amp;</span>
                    <span class="s8">/\s/u</span><span class="s4">.</span><span class="s2">test</span><span class="s4">(</span><span class="s2">nextToken</span><span class="s4">.</span><span class="s2">value</span><span class="s4">)</span>
                <span class="s4">)</span>
        <span class="s4">) {</span>
            <span class="s6">return true</span><span class="s4">;</span>
        <span class="s4">}</span>

        <span class="s2">currentToken </span><span class="s4">= </span><span class="s2">nextToken</span><span class="s4">;</span>
    <span class="s4">}</span>

    <span class="s6">return false</span><span class="s4">;</span>
<span class="s4">}</span>

<span class="s5">//-----------------------------------------------------------------------------</span>
<span class="s5">// Directive Comments</span>
<span class="s5">//-----------------------------------------------------------------------------</span>

<span class="s0">/**</span>
 <span class="s0">* Ensures that variables representing built-in properties of the Global Object,</span>
 <span class="s0">* and any globals declared by special block comments, are present in the global</span>
 <span class="s0">* scope.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Scope} globalScope The global scope.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Object|undefined} configGlobals The globals declared in configuration</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Object|undefined} inlineGlobals The globals declared in the source code</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
 <span class="s0">*/</span>
<span class="s6">function </span><span class="s2">addDeclaredGlobals</span><span class="s4">(</span><span class="s2">globalScope</span><span class="s4">, </span><span class="s2">configGlobals </span><span class="s4">= {}, </span><span class="s2">inlineGlobals </span><span class="s4">= {}) {</span>

    <span class="s5">// Define configured global variables.</span>
    <span class="s6">for </span><span class="s4">(</span><span class="s6">const </span><span class="s2">id of </span><span class="s6">new </span><span class="s2">Set</span><span class="s4">([</span><span class="s2">...Object</span><span class="s4">.</span><span class="s2">keys</span><span class="s4">(</span><span class="s2">configGlobals</span><span class="s4">), </span><span class="s2">...Object</span><span class="s4">.</span><span class="s2">keys</span><span class="s4">(</span><span class="s2">inlineGlobals</span><span class="s4">)])) {</span>

        <span class="s5">/* 
         * `normalizeConfigGlobal` will throw an error if a configured global value is invalid. However, these errors would 
         * typically be caught when validating a config anyway (validity for inline global comments is checked separately). 
         */</span>
        <span class="s6">const </span><span class="s2">configValue </span><span class="s4">= </span><span class="s2">configGlobals</span><span class="s4">[</span><span class="s2">id</span><span class="s4">] === </span><span class="s6">void </span><span class="s7">0 </span><span class="s4">? </span><span class="s6">void </span><span class="s7">0 </span><span class="s4">: </span><span class="s2">normalizeConfigGlobal</span><span class="s4">(</span><span class="s2">configGlobals</span><span class="s4">[</span><span class="s2">id</span><span class="s4">]);</span>
        <span class="s6">const </span><span class="s2">commentValue </span><span class="s4">= </span><span class="s2">inlineGlobals</span><span class="s4">[</span><span class="s2">id</span><span class="s4">] &amp;&amp; </span><span class="s2">inlineGlobals</span><span class="s4">[</span><span class="s2">id</span><span class="s4">].</span><span class="s2">value</span><span class="s4">;</span>
        <span class="s6">const </span><span class="s2">value </span><span class="s4">= </span><span class="s2">commentValue </span><span class="s4">|| </span><span class="s2">configValue</span><span class="s4">;</span>
        <span class="s6">const </span><span class="s2">sourceComments </span><span class="s4">= </span><span class="s2">inlineGlobals</span><span class="s4">[</span><span class="s2">id</span><span class="s4">] &amp;&amp; </span><span class="s2">inlineGlobals</span><span class="s4">[</span><span class="s2">id</span><span class="s4">].</span><span class="s2">comments</span><span class="s4">;</span>

        <span class="s6">if </span><span class="s4">(</span><span class="s2">value </span><span class="s4">=== </span><span class="s3">&quot;off&quot;</span><span class="s4">) {</span>
            <span class="s6">continue</span><span class="s4">;</span>
        <span class="s4">}</span>

        <span class="s6">let </span><span class="s2">variable </span><span class="s4">= </span><span class="s2">globalScope</span><span class="s4">.</span><span class="s2">set</span><span class="s4">.</span><span class="s2">get</span><span class="s4">(</span><span class="s2">id</span><span class="s4">);</span>

        <span class="s6">if </span><span class="s4">(!</span><span class="s2">variable</span><span class="s4">) {</span>
            <span class="s2">variable </span><span class="s4">= </span><span class="s6">new </span><span class="s2">eslintScope</span><span class="s4">.</span><span class="s2">Variable</span><span class="s4">(</span><span class="s2">id</span><span class="s4">, </span><span class="s2">globalScope</span><span class="s4">);</span>

            <span class="s2">globalScope</span><span class="s4">.</span><span class="s2">variables</span><span class="s4">.</span><span class="s2">push</span><span class="s4">(</span><span class="s2">variable</span><span class="s4">);</span>
            <span class="s2">globalScope</span><span class="s4">.</span><span class="s2">set</span><span class="s4">.</span><span class="s2">set</span><span class="s4">(</span><span class="s2">id</span><span class="s4">, </span><span class="s2">variable</span><span class="s4">);</span>
        <span class="s4">}</span>

        <span class="s2">variable</span><span class="s4">.</span><span class="s2">eslintImplicitGlobalSetting </span><span class="s4">= </span><span class="s2">configValue</span><span class="s4">;</span>
        <span class="s2">variable</span><span class="s4">.</span><span class="s2">eslintExplicitGlobal </span><span class="s4">= </span><span class="s2">sourceComments </span><span class="s4">!== </span><span class="s6">void </span><span class="s7">0</span><span class="s4">;</span>
        <span class="s2">variable</span><span class="s4">.</span><span class="s2">eslintExplicitGlobalComments </span><span class="s4">= </span><span class="s2">sourceComments</span><span class="s4">;</span>
        <span class="s2">variable</span><span class="s4">.</span><span class="s2">writeable </span><span class="s4">= (</span><span class="s2">value </span><span class="s4">=== </span><span class="s3">&quot;writable&quot;</span><span class="s4">);</span>
    <span class="s4">}</span>

    <span class="s5">/* 
     * &quot;through&quot; contains all references which definitions cannot be found. 
     * Since we augment the global scope using configuration, we need to update 
     * references and remove the ones that were added by configuration. 
     */</span>
    <span class="s2">globalScope</span><span class="s4">.</span><span class="s2">through </span><span class="s4">= </span><span class="s2">globalScope</span><span class="s4">.</span><span class="s2">through</span><span class="s4">.</span><span class="s2">filter</span><span class="s4">(</span><span class="s2">reference </span><span class="s4">=&gt; {</span>
        <span class="s6">const </span><span class="s2">name </span><span class="s4">= </span><span class="s2">reference</span><span class="s4">.</span><span class="s2">identifier</span><span class="s4">.</span><span class="s2">name</span><span class="s4">;</span>
        <span class="s6">const </span><span class="s2">variable </span><span class="s4">= </span><span class="s2">globalScope</span><span class="s4">.</span><span class="s2">set</span><span class="s4">.</span><span class="s2">get</span><span class="s4">(</span><span class="s2">name</span><span class="s4">);</span>

        <span class="s6">if </span><span class="s4">(</span><span class="s2">variable</span><span class="s4">) {</span>

            <span class="s5">/* 
             * Links the variable and the reference. 
             * And this reference is removed from `Scope#through`. 
             */</span>
            <span class="s2">reference</span><span class="s4">.</span><span class="s2">resolved </span><span class="s4">= </span><span class="s2">variable</span><span class="s4">;</span>
            <span class="s2">variable</span><span class="s4">.</span><span class="s2">references</span><span class="s4">.</span><span class="s2">push</span><span class="s4">(</span><span class="s2">reference</span><span class="s4">);</span>

            <span class="s6">return false</span><span class="s4">;</span>
        <span class="s4">}</span>

        <span class="s6">return true</span><span class="s4">;</span>
    <span class="s4">});</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* Sets the given variable names as exported so they won't be triggered by</span>
 <span class="s0">* the `no-unused-vars` rule.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{eslint.Scope} globalScope The global scope to define exports in.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Record&lt;string,string&gt;} variables An object whose keys are the variable</span>
 <span class="s0">*      names to export.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
 <span class="s0">*/</span>
<span class="s6">function </span><span class="s2">markExportedVariables</span><span class="s4">(</span><span class="s2">globalScope</span><span class="s4">, </span><span class="s2">variables</span><span class="s4">) {</span>

    <span class="s2">Object</span><span class="s4">.</span><span class="s2">keys</span><span class="s4">(</span><span class="s2">variables</span><span class="s4">).</span><span class="s2">forEach</span><span class="s4">(</span><span class="s2">name </span><span class="s4">=&gt; {</span>
        <span class="s6">const </span><span class="s2">variable </span><span class="s4">= </span><span class="s2">globalScope</span><span class="s4">.</span><span class="s2">set</span><span class="s4">.</span><span class="s2">get</span><span class="s4">(</span><span class="s2">name</span><span class="s4">);</span>

        <span class="s6">if </span><span class="s4">(</span><span class="s2">variable</span><span class="s4">) {</span>
            <span class="s2">variable</span><span class="s4">.</span><span class="s2">eslintUsed </span><span class="s4">= </span><span class="s6">true</span><span class="s4">;</span>
            <span class="s2">variable</span><span class="s4">.</span><span class="s2">eslintExported </span><span class="s4">= </span><span class="s6">true</span><span class="s4">;</span>
        <span class="s4">}</span>
    <span class="s4">});</span>

<span class="s4">}</span>

<span class="s5">//------------------------------------------------------------------------------</span>
<span class="s5">// Public Interface</span>
<span class="s5">//------------------------------------------------------------------------------</span>

<span class="s6">const </span><span class="s2">caches </span><span class="s4">= </span><span class="s2">Symbol</span><span class="s4">(</span><span class="s3">&quot;caches&quot;</span><span class="s4">);</span>

<span class="s0">/**</span>
 <span class="s0">* Represents parsed source code.</span>
 <span class="s0">*/</span>
<span class="s6">class </span><span class="s2">SourceCode </span><span class="s6">extends </span><span class="s2">TokenStore </span><span class="s4">{</span>

    <span class="s0">/**</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|Object} textOrConfig The source code text or config object.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} textOrConfig.text The source code text.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} textOrConfig.ast The Program node of the AST representing the code. This AST should be created from the text that BOM was stripped.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Object|null} textOrConfig.parserServices The parser services.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ScopeManager|null} textOrConfig.scopeManager The scope of this source code.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Object|null} textOrConfig.visitorKeys The visitor keys to traverse AST.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} [astIfNoConfig] The Program node of the AST representing the code. This AST should be created from the text that BOM was stripped.</span>
     <span class="s0">*/</span>
    <span class="s2">constructor</span><span class="s4">(</span><span class="s2">textOrConfig</span><span class="s4">, </span><span class="s2">astIfNoConfig</span><span class="s4">) {</span>
        <span class="s6">let </span><span class="s2">text</span><span class="s4">, </span><span class="s2">ast</span><span class="s4">, </span><span class="s2">parserServices</span><span class="s4">, </span><span class="s2">scopeManager</span><span class="s4">, </span><span class="s2">visitorKeys</span><span class="s4">;</span>

        <span class="s5">// Process overloading.</span>
        <span class="s6">if </span><span class="s4">(</span><span class="s6">typeof </span><span class="s2">textOrConfig </span><span class="s4">=== </span><span class="s3">&quot;string&quot;</span><span class="s4">) {</span>
            <span class="s2">text </span><span class="s4">= </span><span class="s2">textOrConfig</span><span class="s4">;</span>
            <span class="s2">ast </span><span class="s4">= </span><span class="s2">astIfNoConfig</span><span class="s4">;</span>
        <span class="s4">} </span><span class="s6">else if </span><span class="s4">(</span><span class="s6">typeof </span><span class="s2">textOrConfig </span><span class="s4">=== </span><span class="s3">&quot;object&quot; </span><span class="s4">&amp;&amp; </span><span class="s2">textOrConfig </span><span class="s4">!== </span><span class="s6">null</span><span class="s4">) {</span>
            <span class="s2">text </span><span class="s4">= </span><span class="s2">textOrConfig</span><span class="s4">.</span><span class="s2">text</span><span class="s4">;</span>
            <span class="s2">ast </span><span class="s4">= </span><span class="s2">textOrConfig</span><span class="s4">.</span><span class="s2">ast</span><span class="s4">;</span>
            <span class="s2">parserServices </span><span class="s4">= </span><span class="s2">textOrConfig</span><span class="s4">.</span><span class="s2">parserServices</span><span class="s4">;</span>
            <span class="s2">scopeManager </span><span class="s4">= </span><span class="s2">textOrConfig</span><span class="s4">.</span><span class="s2">scopeManager</span><span class="s4">;</span>
            <span class="s2">visitorKeys </span><span class="s4">= </span><span class="s2">textOrConfig</span><span class="s4">.</span><span class="s2">visitorKeys</span><span class="s4">;</span>
        <span class="s4">}</span>

        <span class="s2">validate</span><span class="s4">(</span><span class="s2">ast</span><span class="s4">);</span>
        <span class="s6">super</span><span class="s4">(</span><span class="s2">ast</span><span class="s4">.</span><span class="s2">tokens</span><span class="s4">, </span><span class="s2">ast</span><span class="s4">.</span><span class="s2">comments</span><span class="s4">);</span>

        <span class="s0">/**</span>
         <span class="s0">* General purpose caching for the class.</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">[</span><span class="s2">caches</span><span class="s4">] = </span><span class="s6">new </span><span class="s2">Map</span><span class="s4">([</span>
            <span class="s4">[</span><span class="s3">&quot;scopes&quot;</span><span class="s4">, </span><span class="s6">new </span><span class="s2">WeakMap</span><span class="s4">()],</span>
            <span class="s4">[</span><span class="s3">&quot;vars&quot;</span><span class="s4">, </span><span class="s6">new </span><span class="s2">Map</span><span class="s4">()],</span>
            <span class="s4">[</span><span class="s3">&quot;configNodes&quot;</span><span class="s4">, </span><span class="s6">void </span><span class="s7">0</span><span class="s4">]</span>
        <span class="s4">]);</span>

        <span class="s0">/**</span>
         <span class="s0">* The flag to indicate that the source code has Unicode BOM.</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{boolean}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">hasBOM </span><span class="s4">= (</span><span class="s2">text</span><span class="s4">.</span><span class="s2">charCodeAt</span><span class="s4">(</span><span class="s7">0</span><span class="s4">) === </span><span class="s7">0xFEFF</span><span class="s4">);</span>

        <span class="s0">/**</span>
         <span class="s0">* The original text source code.</span>
         <span class="s0">* BOM was stripped from this text.</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{string}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">text </span><span class="s4">= (</span><span class="s6">this</span><span class="s4">.</span><span class="s2">hasBOM </span><span class="s4">? </span><span class="s2">text</span><span class="s4">.</span><span class="s2">slice</span><span class="s4">(</span><span class="s7">1</span><span class="s4">) : </span><span class="s2">text</span><span class="s4">);</span>

        <span class="s0">/**</span>
         <span class="s0">* The parsed AST for the source code.</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{ASTNode}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">ast </span><span class="s4">= </span><span class="s2">ast</span><span class="s4">;</span>

        <span class="s0">/**</span>
         <span class="s0">* The parser services of this source code.</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{Object}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">parserServices </span><span class="s4">= </span><span class="s2">parserServices </span><span class="s4">|| {};</span>

        <span class="s0">/**</span>
         <span class="s0">* The scope of this source code.</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{ScopeManager|null}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">scopeManager </span><span class="s4">= </span><span class="s2">scopeManager </span><span class="s4">|| </span><span class="s6">null</span><span class="s4">;</span>

        <span class="s0">/**</span>
         <span class="s0">* The visitor keys to traverse AST.</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{Object}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">visitorKeys </span><span class="s4">= </span><span class="s2">visitorKeys </span><span class="s4">|| </span><span class="s2">Traverser</span><span class="s4">.</span><span class="s2">DEFAULT_VISITOR_KEYS</span><span class="s4">;</span>

        <span class="s5">// Check the source text for the presence of a shebang since it is parsed as a standard line comment.</span>
        <span class="s6">const </span><span class="s2">shebangMatched </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">text</span><span class="s4">.</span><span class="s2">match</span><span class="s4">(</span><span class="s2">astUtils</span><span class="s4">.</span><span class="s2">shebangPattern</span><span class="s4">);</span>
        <span class="s6">const </span><span class="s2">hasShebang </span><span class="s4">= </span><span class="s2">shebangMatched </span><span class="s4">&amp;&amp; </span><span class="s2">ast</span><span class="s4">.</span><span class="s2">comments</span><span class="s4">.</span><span class="s2">length </span><span class="s4">&amp;&amp; </span><span class="s2">ast</span><span class="s4">.</span><span class="s2">comments</span><span class="s4">[</span><span class="s7">0</span><span class="s4">].</span><span class="s2">value </span><span class="s4">=== </span><span class="s2">shebangMatched</span><span class="s4">[</span><span class="s7">1</span><span class="s4">];</span>

        <span class="s6">if </span><span class="s4">(</span><span class="s2">hasShebang</span><span class="s4">) {</span>
            <span class="s2">ast</span><span class="s4">.</span><span class="s2">comments</span><span class="s4">[</span><span class="s7">0</span><span class="s4">].</span><span class="s2">type </span><span class="s4">= </span><span class="s3">&quot;Shebang&quot;</span><span class="s4">;</span>
        <span class="s4">}</span>

        <span class="s6">this</span><span class="s4">.</span><span class="s2">tokensAndComments </span><span class="s4">= </span><span class="s2">sortedMerge</span><span class="s4">(</span><span class="s2">ast</span><span class="s4">.</span><span class="s2">tokens</span><span class="s4">, </span><span class="s2">ast</span><span class="s4">.</span><span class="s2">comments</span><span class="s4">);</span>

        <span class="s0">/**</span>
         <span class="s0">* The source code split into lines according to ECMA-262 specification.</span>
         <span class="s0">* This is done to avoid each rule needing to do so separately.</span>
         <span class="s0">* </span><span class="s1">@type </span><span class="s0">{string[]}</span>
         <span class="s0">*/</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">lines </span><span class="s4">= [];</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">lineStartIndices </span><span class="s4">= [</span><span class="s7">0</span><span class="s4">];</span>

        <span class="s6">const </span><span class="s2">lineEndingPattern </span><span class="s4">= </span><span class="s2">astUtils</span><span class="s4">.</span><span class="s2">createGlobalLinebreakMatcher</span><span class="s4">();</span>
        <span class="s6">let </span><span class="s2">match</span><span class="s4">;</span>

        <span class="s5">/* 
         * Previously, this was implemented using a regex that 
         * matched a sequence of non-linebreak characters followed by a 
         * linebreak, then adding the lengths of the matches. However, 
         * this caused a catastrophic backtracking issue when the end 
         * of a file contained a large number of non-newline characters. 
         * To avoid this, the current implementation just matches newlines 
         * and uses match.index to get the correct line start indices. 
         */</span>
        <span class="s6">while </span><span class="s4">((</span><span class="s2">match </span><span class="s4">= </span><span class="s2">lineEndingPattern</span><span class="s4">.</span><span class="s2">exec</span><span class="s4">(</span><span class="s6">this</span><span class="s4">.</span><span class="s2">text</span><span class="s4">))) {</span>
            <span class="s6">this</span><span class="s4">.</span><span class="s2">lines</span><span class="s4">.</span><span class="s2">push</span><span class="s4">(</span><span class="s6">this</span><span class="s4">.</span><span class="s2">text</span><span class="s4">.</span><span class="s2">slice</span><span class="s4">(</span><span class="s6">this</span><span class="s4">.</span><span class="s2">lineStartIndices</span><span class="s4">[</span><span class="s6">this</span><span class="s4">.</span><span class="s2">lineStartIndices</span><span class="s4">.</span><span class="s2">length </span><span class="s4">- </span><span class="s7">1</span><span class="s4">], </span><span class="s2">match</span><span class="s4">.</span><span class="s2">index</span><span class="s4">));</span>
            <span class="s6">this</span><span class="s4">.</span><span class="s2">lineStartIndices</span><span class="s4">.</span><span class="s2">push</span><span class="s4">(</span><span class="s2">match</span><span class="s4">.</span><span class="s2">index </span><span class="s4">+ </span><span class="s2">match</span><span class="s4">[</span><span class="s7">0</span><span class="s4">].</span><span class="s2">length</span><span class="s4">);</span>
        <span class="s4">}</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">lines</span><span class="s4">.</span><span class="s2">push</span><span class="s4">(</span><span class="s6">this</span><span class="s4">.</span><span class="s2">text</span><span class="s4">.</span><span class="s2">slice</span><span class="s4">(</span><span class="s6">this</span><span class="s4">.</span><span class="s2">lineStartIndices</span><span class="s4">[</span><span class="s6">this</span><span class="s4">.</span><span class="s2">lineStartIndices</span><span class="s4">.</span><span class="s2">length </span><span class="s4">- </span><span class="s7">1</span><span class="s4">]));</span>

        <span class="s5">// Cache for comments found using getComments().</span>
        <span class="s6">this</span><span class="s4">.</span><span class="s2">_commentCache </span><span class="s4">= </span><span class="s6">new </span><span class="s2">WeakMap</span><span class="s4">();</span>

        <span class="s5">// don't allow further modification of this object</span>
        <span class="s2">Object</span><span class="s4">.</span><span class="s2">freeze</span><span class="s4">(</span><span class="s6">this</span><span class="s4">);</span>
        <span class="s2">Object</span><span class="s4">.</span><span class="s2">freeze</span><span class="s4">(</span><span class="s6">this</span><span class="s4">.</span><span class="s2">lines</span><span class="s4">);</span>
    <span class="s4">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Split the source code into multiple lines based on the line delimiters.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} text Source code as a string.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{string[]} Array of source code lines.</span>
     <span class="s0">* </span><span class="s1">@public</span>
     <span class="s0">*/</span>
    <span class="s6">static </span><span class="s2">splitLines</span><span class="s4">(</span><span class="s2">text</span><span class="s4">) {</span>
        <span class="s6">return </span><span class="s2">text</span><span class="s4">.</span><span class="s2">split</span><span class="s4">(</span><span class="s2">astUtils</span><span class="s4">.</span><span class="s2">createGlobalLinebreakMatcher</span><span class="s4">());</span>
    <span class="s4">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Gets the source code for the given node.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} [node] The AST node to get the text for.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{int} [beforeCount] The number of characters before the node to retrieve.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{int} [afterCount] The number of characters after the node to retrieve.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{string} The text representing the AST node.</span>
     <span class="s0">* </span><span class="s1">@public</span>
     <span class="s0">*/</span>
    <span class="s2">getText</span><span class="s4">(</span><span class="s2">node</span><span class="s4">, </span><span class="s2">beforeCount</span><span class="s4">, </span><span class="s2">afterCount</span><span class="s4">) {</span>
        <span class="s6">if </span><span class="s4">(</span><span class="s2">node</span><span class="s4">) {</span>
            <span class="s6">return this</span><span class="s4">.</span><span class="s2">text</span><span class="s4">.</span><span class="s2">slice</span><span class="s4">(</span><span class="s2">Math</span><span class="s4">.</span><span class="s2">max</span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s7">0</span><span class="s4">] - (</span><span class="s2">beforeCount </span><span class="s4">|| </span><span class="s7">0</span><span class="s4">), </span><span class="s7">0</span><span class="s4">),</span>
                <span class="s2">node</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s7">1</span><span class="s4">] + (</span><span class="s2">afterCount </span><span class="s4">|| </span><span class="s7">0</span><span class="s4">));</span>
        <span class="s4">}</span>
        <span class="s6">return this</span><span class="s4">.</span><span class="s2">text</span><span class="s4">;</span>
    <span class="s4">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Gets the entire source text split into an array of lines.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Array} The source text as an array of lines.</span>
     <span class="s0">* </span><span class="s1">@public</span>
     <span class="s0">*/</span>
    <span class="s2">getLines</span><span class="s4">() {</span>
        <span class="s6">return this</span><span class="s4">.</span><span class="s2">lines</span><span class="s4">;</span>
    <span class="s4">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Retrieves an array containing all comments in the source code.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{ASTNode[]} An array of comment nodes.</span>
     <span class="s0">* </span><span class="s1">@public</span>
     <span class="s0">*/</span>
    <span class="s2">getAllComments</span><span class="s4">() {</span>
        <span class="s6">return this</span><span class="s4">.</span><span class="s2">ast</span><span class="s4">.</span><span class="s2">comments</span><span class="s4">;</span>
    <span class="s4">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Gets all comments for the given node.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The AST node to get the comments for.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Object} An object containing a leading and trailing array</span>
     <span class="s0">*      of comments indexed by their position.</span>
     <span class="s0">* </span><span class="s1">@public</span>
     <span class="s0">* </span><span class="s1">@deprecated </span><span class="s0">replaced by getCommentsBefore(), getCommentsAfter(), and getCommentsInside().</span>
     <span class="s0">*/</span>
    <span class="s2">getComments</span><span class="s4">(</span><span class="s2">node</span><span class="s4">) {</span>
        <span class="s6">if </span><span class="s4">(</span><span class="s6">this</span><span class="s4">.</span><span class="s2">_commentCache</span><span class="s4">.</span><span class="s2">has</span><span class="s4">(</span><span class="s2">node</span><span class="s4">)) {</span>
            <span class="s6">return this</span><span class="s4">.</span><span class="s2">_commentCache</span><span class="s4">.</span><span class="s2">get</span><span class="s4">(</span><span class="s2">node</span><span class="s4">);</span>
        <span class="s4">}</span>

        <span class="s6">const </span><span class="s2">comments </span><span class="s4">= {</span>
            <span class="s2">leading</span><span class="s4">: [],</span>
            <span class="s2">trailing</span><span class="s4">: []</span>
        <span class="s4">};</span>

        <span class="s5">/* 
         * Return all comments as leading comments of the Program node when 
         * there is no executable code. 
         */</span>
        <span class="s6">if </span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;Program&quot;</span><span class="s4">) {</span>
            <span class="s6">if </span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">body</span><span class="s4">.</span><span class="s2">length </span><span class="s4">=== </span><span class="s7">0</span><span class="s4">) {</span>
                <span class="s2">comments</span><span class="s4">.</span><span class="s2">leading </span><span class="s4">= </span><span class="s2">node</span><span class="s4">.</span><span class="s2">comments</span><span class="s4">;</span>
            <span class="s4">}</span>
        <span class="s4">} </span><span class="s6">else </span><span class="s4">{</span>

            <span class="s5">/* 
             * Return comments as trailing comments of nodes that only contain 
             * comments (to mimic the comment attachment behavior present in Espree). 
             */</span>
            <span class="s6">if </span><span class="s4">((</span><span class="s2">node</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;BlockStatement&quot; </span><span class="s4">|| </span><span class="s2">node</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;ClassBody&quot;</span><span class="s4">) &amp;&amp; </span><span class="s2">node</span><span class="s4">.</span><span class="s2">body</span><span class="s4">.</span><span class="s2">length </span><span class="s4">=== </span><span class="s7">0 </span><span class="s4">||</span>
                <span class="s2">node</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;ObjectExpression&quot; </span><span class="s4">&amp;&amp; </span><span class="s2">node</span><span class="s4">.</span><span class="s2">properties</span><span class="s4">.</span><span class="s2">length </span><span class="s4">=== </span><span class="s7">0 </span><span class="s4">||</span>
                <span class="s2">node</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;ArrayExpression&quot; </span><span class="s4">&amp;&amp; </span><span class="s2">node</span><span class="s4">.</span><span class="s2">elements</span><span class="s4">.</span><span class="s2">length </span><span class="s4">=== </span><span class="s7">0 </span><span class="s4">||</span>
                <span class="s2">node</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;SwitchStatement&quot; </span><span class="s4">&amp;&amp; </span><span class="s2">node</span><span class="s4">.</span><span class="s2">cases</span><span class="s4">.</span><span class="s2">length </span><span class="s4">=== </span><span class="s7">0</span>
            <span class="s4">) {</span>
                <span class="s2">comments</span><span class="s4">.</span><span class="s2">trailing </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">getTokens</span><span class="s4">(</span><span class="s2">node</span><span class="s4">, {</span>
                    <span class="s2">includeComments</span><span class="s4">: </span><span class="s6">true</span><span class="s4">,</span>
                    <span class="s2">filter</span><span class="s4">: </span><span class="s2">isCommentToken</span>
                <span class="s4">});</span>
            <span class="s4">}</span>

            <span class="s5">/* 
             * Iterate over tokens before and after node and collect comment tokens. 
             * Do not include comments that exist outside of the parent node 
             * to avoid duplication. 
             */</span>
            <span class="s6">let </span><span class="s2">currentToken </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">getTokenBefore</span><span class="s4">(</span><span class="s2">node</span><span class="s4">, { </span><span class="s2">includeComments</span><span class="s4">: </span><span class="s6">true </span><span class="s4">});</span>

            <span class="s6">while </span><span class="s4">(</span><span class="s2">currentToken </span><span class="s4">&amp;&amp; </span><span class="s2">isCommentToken</span><span class="s4">(</span><span class="s2">currentToken</span><span class="s4">)) {</span>
                <span class="s6">if </span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">parent </span><span class="s4">&amp;&amp; </span><span class="s2">node</span><span class="s4">.</span><span class="s2">parent</span><span class="s4">.</span><span class="s2">type </span><span class="s4">!== </span><span class="s3">&quot;Program&quot; </span><span class="s4">&amp;&amp; (</span><span class="s2">currentToken</span><span class="s4">.</span><span class="s2">start </span><span class="s4">&lt; </span><span class="s2">node</span><span class="s4">.</span><span class="s2">parent</span><span class="s4">.</span><span class="s2">start</span><span class="s4">)) {</span>
                    <span class="s6">break</span><span class="s4">;</span>
                <span class="s4">}</span>
                <span class="s2">comments</span><span class="s4">.</span><span class="s2">leading</span><span class="s4">.</span><span class="s2">push</span><span class="s4">(</span><span class="s2">currentToken</span><span class="s4">);</span>
                <span class="s2">currentToken </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">getTokenBefore</span><span class="s4">(</span><span class="s2">currentToken</span><span class="s4">, { </span><span class="s2">includeComments</span><span class="s4">: </span><span class="s6">true </span><span class="s4">});</span>
            <span class="s4">}</span>

            <span class="s2">comments</span><span class="s4">.</span><span class="s2">leading</span><span class="s4">.</span><span class="s2">reverse</span><span class="s4">();</span>

            <span class="s2">currentToken </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">getTokenAfter</span><span class="s4">(</span><span class="s2">node</span><span class="s4">, { </span><span class="s2">includeComments</span><span class="s4">: </span><span class="s6">true </span><span class="s4">});</span>

            <span class="s6">while </span><span class="s4">(</span><span class="s2">currentToken </span><span class="s4">&amp;&amp; </span><span class="s2">isCommentToken</span><span class="s4">(</span><span class="s2">currentToken</span><span class="s4">)) {</span>
                <span class="s6">if </span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">parent </span><span class="s4">&amp;&amp; </span><span class="s2">node</span><span class="s4">.</span><span class="s2">parent</span><span class="s4">.</span><span class="s2">type </span><span class="s4">!== </span><span class="s3">&quot;Program&quot; </span><span class="s4">&amp;&amp; (</span><span class="s2">currentToken</span><span class="s4">.</span><span class="s2">end </span><span class="s4">&gt; </span><span class="s2">node</span><span class="s4">.</span><span class="s2">parent</span><span class="s4">.</span><span class="s2">end</span><span class="s4">)) {</span>
                    <span class="s6">break</span><span class="s4">;</span>
                <span class="s4">}</span>
                <span class="s2">comments</span><span class="s4">.</span><span class="s2">trailing</span><span class="s4">.</span><span class="s2">push</span><span class="s4">(</span><span class="s2">currentToken</span><span class="s4">);</span>
                <span class="s2">currentToken </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">getTokenAfter</span><span class="s4">(</span><span class="s2">currentToken</span><span class="s4">, { </span><span class="s2">includeComments</span><span class="s4">: </span><span class="s6">true </span><span class="s4">});</span>
            <span class="s4">}</span>
        <span class="s4">}</span>

        <span class="s6">this</span><span class="s4">.</span><span class="s2">_commentCache</span><span class="s4">.</span><span class="s2">set</span><span class="s4">(</span><span class="s2">node</span><span class="s4">, </span><span class="s2">comments</span><span class="s4">);</span>
        <span class="s6">return </span><span class="s2">comments</span><span class="s4">;</span>
    <span class="s4">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Retrieves the JSDoc comment for a given node.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The AST node to get the comment for.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Token|null} The Block comment token containing the JSDoc comment</span>
     <span class="s0">*      for the given node or null if not found.</span>
     <span class="s0">* </span><span class="s1">@public</span>
     <span class="s0">* </span><span class="s1">@deprecated</span>
     <span class="s0">*/</span>
    <span class="s2">getJSDocComment</span><span class="s4">(</span><span class="s2">node</span><span class="s4">) {</span>

        <span class="s0">/**</span>
         <span class="s0">* Checks for the presence of a JSDoc comment for the given node and returns it.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} astNode The AST node to get the comment for.</span>
         <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Token|null} The Block comment token containing the JSDoc comment</span>
         <span class="s0">*      for the given node or null if not found.</span>
         <span class="s0">* </span><span class="s1">@private</span>
         <span class="s0">*/</span>
        <span class="s6">const </span><span class="s2">findJSDocComment </span><span class="s4">= </span><span class="s2">astNode </span><span class="s4">=&gt; {</span>
            <span class="s6">const </span><span class="s2">tokenBefore </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">getTokenBefore</span><span class="s4">(</span><span class="s2">astNode</span><span class="s4">, { </span><span class="s2">includeComments</span><span class="s4">: </span><span class="s6">true </span><span class="s4">});</span>

            <span class="s6">if </span><span class="s4">(</span>
                <span class="s2">tokenBefore </span><span class="s4">&amp;&amp;</span>
                <span class="s2">isCommentToken</span><span class="s4">(</span><span class="s2">tokenBefore</span><span class="s4">) &amp;&amp;</span>
                <span class="s2">tokenBefore</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;Block&quot; </span><span class="s4">&amp;&amp;</span>
                <span class="s2">tokenBefore</span><span class="s4">.</span><span class="s2">value</span><span class="s4">.</span><span class="s2">charAt</span><span class="s4">(</span><span class="s7">0</span><span class="s4">) === </span><span class="s3">&quot;*&quot; </span><span class="s4">&amp;&amp;</span>
                <span class="s2">astNode</span><span class="s4">.</span><span class="s2">loc</span><span class="s4">.</span><span class="s2">start</span><span class="s4">.</span><span class="s2">line </span><span class="s4">- </span><span class="s2">tokenBefore</span><span class="s4">.</span><span class="s2">loc</span><span class="s4">.</span><span class="s2">end</span><span class="s4">.</span><span class="s2">line </span><span class="s4">&lt;= </span><span class="s7">1</span>
            <span class="s4">) {</span>
                <span class="s6">return </span><span class="s2">tokenBefore</span><span class="s4">;</span>
            <span class="s4">}</span>

            <span class="s6">return null</span><span class="s4">;</span>
        <span class="s4">};</span>
        <span class="s6">let </span><span class="s2">parent </span><span class="s4">= </span><span class="s2">node</span><span class="s4">.</span><span class="s2">parent</span><span class="s4">;</span>

        <span class="s6">switch </span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">type</span><span class="s4">) {</span>
            <span class="s6">case </span><span class="s3">&quot;ClassDeclaration&quot;</span><span class="s4">:</span>
            <span class="s6">case </span><span class="s3">&quot;FunctionDeclaration&quot;</span><span class="s4">:</span>
                <span class="s6">return </span><span class="s2">findJSDocComment</span><span class="s4">(</span><span class="s2">looksLikeExport</span><span class="s4">(</span><span class="s2">parent</span><span class="s4">) ? </span><span class="s2">parent </span><span class="s4">: </span><span class="s2">node</span><span class="s4">);</span>

            <span class="s6">case </span><span class="s3">&quot;ClassExpression&quot;</span><span class="s4">:</span>
                <span class="s6">return </span><span class="s2">findJSDocComment</span><span class="s4">(</span><span class="s2">parent</span><span class="s4">.</span><span class="s2">parent</span><span class="s4">);</span>

            <span class="s6">case </span><span class="s3">&quot;ArrowFunctionExpression&quot;</span><span class="s4">:</span>
            <span class="s6">case </span><span class="s3">&quot;FunctionExpression&quot;</span><span class="s4">:</span>
                <span class="s6">if </span><span class="s4">(</span><span class="s2">parent</span><span class="s4">.</span><span class="s2">type </span><span class="s4">!== </span><span class="s3">&quot;CallExpression&quot; </span><span class="s4">&amp;&amp; </span><span class="s2">parent</span><span class="s4">.</span><span class="s2">type </span><span class="s4">!== </span><span class="s3">&quot;NewExpression&quot;</span><span class="s4">) {</span>
                    <span class="s6">while </span><span class="s4">(</span>
                        <span class="s4">!</span><span class="s6">this</span><span class="s4">.</span><span class="s2">getCommentsBefore</span><span class="s4">(</span><span class="s2">parent</span><span class="s4">).</span><span class="s2">length </span><span class="s4">&amp;&amp;</span>
                        <span class="s4">!</span><span class="s8">/Function/u</span><span class="s4">.</span><span class="s2">test</span><span class="s4">(</span><span class="s2">parent</span><span class="s4">.</span><span class="s2">type</span><span class="s4">) &amp;&amp;</span>
                        <span class="s2">parent</span><span class="s4">.</span><span class="s2">type </span><span class="s4">!== </span><span class="s3">&quot;MethodDefinition&quot; </span><span class="s4">&amp;&amp;</span>
                        <span class="s2">parent</span><span class="s4">.</span><span class="s2">type </span><span class="s4">!== </span><span class="s3">&quot;Property&quot;</span>
                    <span class="s4">) {</span>
                        <span class="s2">parent </span><span class="s4">= </span><span class="s2">parent</span><span class="s4">.</span><span class="s2">parent</span><span class="s4">;</span>

                        <span class="s6">if </span><span class="s4">(!</span><span class="s2">parent</span><span class="s4">) {</span>
                            <span class="s6">break</span><span class="s4">;</span>
                        <span class="s4">}</span>
                    <span class="s4">}</span>

                    <span class="s6">if </span><span class="s4">(</span><span class="s2">parent </span><span class="s4">&amp;&amp; </span><span class="s2">parent</span><span class="s4">.</span><span class="s2">type </span><span class="s4">!== </span><span class="s3">&quot;FunctionDeclaration&quot; </span><span class="s4">&amp;&amp; </span><span class="s2">parent</span><span class="s4">.</span><span class="s2">type </span><span class="s4">!== </span><span class="s3">&quot;Program&quot;</span><span class="s4">) {</span>
                        <span class="s6">return </span><span class="s2">findJSDocComment</span><span class="s4">(</span><span class="s2">parent</span><span class="s4">);</span>
                    <span class="s4">}</span>
                <span class="s4">}</span>

                <span class="s6">return </span><span class="s2">findJSDocComment</span><span class="s4">(</span><span class="s2">node</span><span class="s4">);</span>

            <span class="s5">// falls through</span>
            <span class="s6">default</span><span class="s4">:</span>
                <span class="s6">return null</span><span class="s4">;</span>
        <span class="s4">}</span>
    <span class="s4">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Gets the deepest node containing a range index.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{int} index Range index of the desired node.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{ASTNode} The node if found or null if not found.</span>
     <span class="s0">* </span><span class="s1">@public</span>
     <span class="s0">*/</span>
    <span class="s2">getNodeByRangeIndex</span><span class="s4">(</span><span class="s2">index</span><span class="s4">) {</span>
        <span class="s6">let </span><span class="s2">result </span><span class="s4">= </span><span class="s6">null</span><span class="s4">;</span>

        <span class="s2">Traverser</span><span class="s4">.</span><span class="s2">traverse</span><span class="s4">(</span><span class="s6">this</span><span class="s4">.</span><span class="s2">ast</span><span class="s4">, {</span>
            <span class="s2">visitorKeys</span><span class="s4">: </span><span class="s6">this</span><span class="s4">.</span><span class="s2">visitorKeys</span><span class="s4">,</span>
            <span class="s2">enter</span><span class="s4">(</span><span class="s2">node</span><span class="s4">) {</span>
                <span class="s6">if </span><span class="s4">(</span><span class="s2">node</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s7">0</span><span class="s4">] &lt;= </span><span class="s2">index </span><span class="s4">&amp;&amp; </span><span class="s2">index </span><span class="s4">&lt; </span><span class="s2">node</span><span class="s4">.</span><span class="s2">range</span><span class="s4">[</span><span class="s7">1</span><span class="s4">]) {</span>
                    <span class="s2">result </span><span class="s4">= </span><span class="s2">node</span><span class="s4">;</span>
                <span class="s4">} </span><span class="s6">else </span><span class="s4">{</span>
                    <span class="s6">this</span><span class="s4">.</span><span class="s2">skip</span><span class="s4">();</span>
                <span class="s4">}</span>
            <span class="s4">},</span>
            <span class="s2">leave</span><span class="s4">(</span><span class="s2">node</span><span class="s4">) {</span>
                <span class="s6">if </span><span class="s4">(</span><span class="s2">node </span><span class="s4">=== </span><span class="s2">result</span><span class="s4">) {</span>
                    <span class="s6">this</span><span class="s4">.</span><span class="s2">break</span><span class="s4">();</span>
                <span class="s4">}</span>
            <span class="s4">}</span>
        <span class="s4">});</span>

        <span class="s6">return </span><span class="s2">result</span><span class="s4">;</span>
    <span class="s4">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Determines if two nodes or tokens have at least one whitespace character</span>
     <span class="s0">* between them. Order does not matter. Returns false if the given nodes or</span>
     <span class="s0">* tokens overlap.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode|Token} first The first node or token to check between.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode|Token} second The second node or token to check between.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} True if there is a whitespace character between</span>
     <span class="s0">* any of the tokens found between the two given nodes or tokens.</span>
     <span class="s0">* </span><span class="s1">@public</span>
     <span class="s0">*/</span>
    <span class="s2">isSpaceBetween</span><span class="s4">(</span><span class="s2">first</span><span class="s4">, </span><span class="s2">second</span><span class="s4">) {</span>
        <span class="s6">return </span><span class="s2">isSpaceBetween</span><span class="s4">(</span><span class="s6">this</span><span class="s4">, </span><span class="s2">first</span><span class="s4">, </span><span class="s2">second</span><span class="s4">, </span><span class="s6">false</span><span class="s4">);</span>
    <span class="s4">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Determines if two nodes or tokens have at least one whitespace character</span>
     <span class="s0">* between them. Order does not matter. Returns false if the given nodes or</span>
     <span class="s0">* tokens overlap.</span>
     <span class="s0">* For backward compatibility, this method returns true if there are</span>
     <span class="s0">* `JSXText` tokens that contain whitespaces between the two.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode|Token} first The first node or token to check between.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode|Token} second The second node or token to check between.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} True if there is a whitespace character between</span>
     <span class="s0">* any of the tokens found between the two given nodes or tokens.</span>
     <span class="s0">* </span><span class="s1">@deprecated </span><span class="s0">in favor of isSpaceBetween().</span>
     <span class="s0">* </span><span class="s1">@public</span>
     <span class="s0">*/</span>
    <span class="s2">isSpaceBetweenTokens</span><span class="s4">(</span><span class="s2">first</span><span class="s4">, </span><span class="s2">second</span><span class="s4">) {</span>
        <span class="s6">return </span><span class="s2">isSpaceBetween</span><span class="s4">(</span><span class="s6">this</span><span class="s4">, </span><span class="s2">first</span><span class="s4">, </span><span class="s2">second</span><span class="s4">, </span><span class="s6">true</span><span class="s4">);</span>
    <span class="s4">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Converts a source text index into a (line, column) pair.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{number} index The index of a character in a file</span>
     <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{TypeError} If non-numeric index or index out of range.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Object} A {line, column} location object with a 0-indexed column</span>
     <span class="s0">* </span><span class="s1">@public</span>
     <span class="s0">*/</span>
    <span class="s2">getLocFromIndex</span><span class="s4">(</span><span class="s2">index</span><span class="s4">) {</span>
        <span class="s6">if </span><span class="s4">(</span><span class="s6">typeof </span><span class="s2">index </span><span class="s4">!== </span><span class="s3">&quot;number&quot;</span><span class="s4">) {</span>
            <span class="s6">throw new </span><span class="s2">TypeError</span><span class="s4">(</span><span class="s3">&quot;Expected `index` to be a number.&quot;</span><span class="s4">);</span>
        <span class="s4">}</span>

        <span class="s6">if </span><span class="s4">(</span><span class="s2">index </span><span class="s4">&lt; </span><span class="s7">0 </span><span class="s4">|| </span><span class="s2">index </span><span class="s4">&gt; </span><span class="s6">this</span><span class="s4">.</span><span class="s2">text</span><span class="s4">.</span><span class="s2">length</span><span class="s4">) {</span>
            <span class="s6">throw new </span><span class="s2">RangeError</span><span class="s4">(</span><span class="s3">`Index out of range (requested index </span><span class="s2">$</span><span class="s4">{</span><span class="s2">index</span><span class="s4">}</span><span class="s3">, but source text has length </span><span class="s2">$</span><span class="s4">{</span><span class="s6">this</span><span class="s4">.</span><span class="s2">text</span><span class="s4">.</span><span class="s2">length</span><span class="s4">}</span><span class="s3">).`</span><span class="s4">);</span>
        <span class="s4">}</span>

        <span class="s5">/* 
         * For an argument of this.text.length, return the location one &quot;spot&quot; past the last character 
         * of the file. If the last character is a linebreak, the location will be column 0 of the next 
         * line; otherwise, the location will be in the next column on the same line. 
         * 
         * See getIndexFromLoc for the motivation for this special case. 
         */</span>
        <span class="s6">if </span><span class="s4">(</span><span class="s2">index </span><span class="s4">=== </span><span class="s6">this</span><span class="s4">.</span><span class="s2">text</span><span class="s4">.</span><span class="s2">length</span><span class="s4">) {</span>
            <span class="s6">return </span><span class="s4">{ </span><span class="s2">line</span><span class="s4">: </span><span class="s6">this</span><span class="s4">.</span><span class="s2">lines</span><span class="s4">.</span><span class="s2">length</span><span class="s4">, </span><span class="s2">column</span><span class="s4">: </span><span class="s6">this</span><span class="s4">.</span><span class="s2">lines</span><span class="s4">[</span><span class="s6">this</span><span class="s4">.</span><span class="s2">lines</span><span class="s4">.</span><span class="s2">length </span><span class="s4">- </span><span class="s7">1</span><span class="s4">].</span><span class="s2">length </span><span class="s4">};</span>
        <span class="s4">}</span>

        <span class="s5">/* 
         * To figure out which line index is on, determine the last place at which index could 
         * be inserted into lineStartIndices to keep the list sorted. 
         */</span>
        <span class="s6">const </span><span class="s2">lineNumber </span><span class="s4">= </span><span class="s2">index </span><span class="s4">&gt;= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">lineStartIndices</span><span class="s4">[</span><span class="s6">this</span><span class="s4">.</span><span class="s2">lineStartIndices</span><span class="s4">.</span><span class="s2">length </span><span class="s4">- </span><span class="s7">1</span><span class="s4">]</span>
            <span class="s4">? </span><span class="s6">this</span><span class="s4">.</span><span class="s2">lineStartIndices</span><span class="s4">.</span><span class="s2">length</span>
            <span class="s4">: </span><span class="s6">this</span><span class="s4">.</span><span class="s2">lineStartIndices</span><span class="s4">.</span><span class="s2">findIndex</span><span class="s4">(</span><span class="s2">el </span><span class="s4">=&gt; </span><span class="s2">index </span><span class="s4">&lt; </span><span class="s2">el</span><span class="s4">);</span>

        <span class="s6">return </span><span class="s4">{ </span><span class="s2">line</span><span class="s4">: </span><span class="s2">lineNumber</span><span class="s4">, </span><span class="s2">column</span><span class="s4">: </span><span class="s2">index </span><span class="s4">- </span><span class="s6">this</span><span class="s4">.</span><span class="s2">lineStartIndices</span><span class="s4">[</span><span class="s2">lineNumber </span><span class="s4">- </span><span class="s7">1</span><span class="s4">] };</span>
    <span class="s4">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Converts a (line, column) pair into a range index.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Object} loc A line/column location</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{number} loc.line The line number of the location (1-indexed)</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{number} loc.column The column number of the location (0-indexed)</span>
     <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{TypeError|RangeError} If `loc` is not an object with a numeric</span>
     <span class="s0">*   `line` and `column`, if the `line` is less than or equal to zero or</span>
     <span class="s0">*   the line or column is out of the expected range.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{number} The range index of the location in the file.</span>
     <span class="s0">* </span><span class="s1">@public</span>
     <span class="s0">*/</span>
    <span class="s2">getIndexFromLoc</span><span class="s4">(</span><span class="s2">loc</span><span class="s4">) {</span>
        <span class="s6">if </span><span class="s4">(</span><span class="s6">typeof </span><span class="s2">loc </span><span class="s4">!== </span><span class="s3">&quot;object&quot; </span><span class="s4">|| </span><span class="s6">typeof </span><span class="s2">loc</span><span class="s4">.</span><span class="s2">line </span><span class="s4">!== </span><span class="s3">&quot;number&quot; </span><span class="s4">|| </span><span class="s6">typeof </span><span class="s2">loc</span><span class="s4">.</span><span class="s2">column </span><span class="s4">!== </span><span class="s3">&quot;number&quot;</span><span class="s4">) {</span>
            <span class="s6">throw new </span><span class="s2">TypeError</span><span class="s4">(</span><span class="s3">&quot;Expected `loc` to be an object with numeric `line` and `column` properties.&quot;</span><span class="s4">);</span>
        <span class="s4">}</span>

        <span class="s6">if </span><span class="s4">(</span><span class="s2">loc</span><span class="s4">.</span><span class="s2">line </span><span class="s4">&lt;= </span><span class="s7">0</span><span class="s4">) {</span>
            <span class="s6">throw new </span><span class="s2">RangeError</span><span class="s4">(</span><span class="s3">`Line number out of range (line </span><span class="s2">$</span><span class="s4">{</span><span class="s2">loc</span><span class="s4">.</span><span class="s2">line</span><span class="s4">} </span><span class="s3">requested). Line numbers should be 1-based.`</span><span class="s4">);</span>
        <span class="s4">}</span>

        <span class="s6">if </span><span class="s4">(</span><span class="s2">loc</span><span class="s4">.</span><span class="s2">line </span><span class="s4">&gt; </span><span class="s6">this</span><span class="s4">.</span><span class="s2">lineStartIndices</span><span class="s4">.</span><span class="s2">length</span><span class="s4">) {</span>
            <span class="s6">throw new </span><span class="s2">RangeError</span><span class="s4">(</span><span class="s3">`Line number out of range (line </span><span class="s2">$</span><span class="s4">{</span><span class="s2">loc</span><span class="s4">.</span><span class="s2">line</span><span class="s4">} </span><span class="s3">requested, but only </span><span class="s2">$</span><span class="s4">{</span><span class="s6">this</span><span class="s4">.</span><span class="s2">lineStartIndices</span><span class="s4">.</span><span class="s2">length</span><span class="s4">} </span><span class="s3">lines present).`</span><span class="s4">);</span>
        <span class="s4">}</span>

        <span class="s6">const </span><span class="s2">lineStartIndex </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">lineStartIndices</span><span class="s4">[</span><span class="s2">loc</span><span class="s4">.</span><span class="s2">line </span><span class="s4">- </span><span class="s7">1</span><span class="s4">];</span>
        <span class="s6">const </span><span class="s2">lineEndIndex </span><span class="s4">= </span><span class="s2">loc</span><span class="s4">.</span><span class="s2">line </span><span class="s4">=== </span><span class="s6">this</span><span class="s4">.</span><span class="s2">lineStartIndices</span><span class="s4">.</span><span class="s2">length </span><span class="s4">? </span><span class="s6">this</span><span class="s4">.</span><span class="s2">text</span><span class="s4">.</span><span class="s2">length </span><span class="s4">: </span><span class="s6">this</span><span class="s4">.</span><span class="s2">lineStartIndices</span><span class="s4">[</span><span class="s2">loc</span><span class="s4">.</span><span class="s2">line</span><span class="s4">];</span>
        <span class="s6">const </span><span class="s2">positionIndex </span><span class="s4">= </span><span class="s2">lineStartIndex </span><span class="s4">+ </span><span class="s2">loc</span><span class="s4">.</span><span class="s2">column</span><span class="s4">;</span>

        <span class="s5">/* 
         * By design, getIndexFromLoc({ line: lineNum, column: 0 }) should return the start index of 
         * the given line, provided that the line number is valid element of this.lines. Since the 
         * last element of this.lines is an empty string for files with trailing newlines, add a 
         * special case where getting the index for the first location after the end of the file 
         * will return the length of the file, rather than throwing an error. This allows rules to 
         * use getIndexFromLoc consistently without worrying about edge cases at the end of a file. 
         */</span>
        <span class="s6">if </span><span class="s4">(</span>
            <span class="s2">loc</span><span class="s4">.</span><span class="s2">line </span><span class="s4">=== </span><span class="s6">this</span><span class="s4">.</span><span class="s2">lineStartIndices</span><span class="s4">.</span><span class="s2">length </span><span class="s4">&amp;&amp; </span><span class="s2">positionIndex </span><span class="s4">&gt; </span><span class="s2">lineEndIndex </span><span class="s4">||</span>
            <span class="s2">loc</span><span class="s4">.</span><span class="s2">line </span><span class="s4">&lt; </span><span class="s6">this</span><span class="s4">.</span><span class="s2">lineStartIndices</span><span class="s4">.</span><span class="s2">length </span><span class="s4">&amp;&amp; </span><span class="s2">positionIndex </span><span class="s4">&gt;= </span><span class="s2">lineEndIndex</span>
        <span class="s4">) {</span>
            <span class="s6">throw new </span><span class="s2">RangeError</span><span class="s4">(</span><span class="s3">`Column number out of range (column </span><span class="s2">$</span><span class="s4">{</span><span class="s2">loc</span><span class="s4">.</span><span class="s2">column</span><span class="s4">} </span><span class="s3">requested, but the length of line </span><span class="s2">$</span><span class="s4">{</span><span class="s2">loc</span><span class="s4">.</span><span class="s2">line</span><span class="s4">} </span><span class="s3">is </span><span class="s2">$</span><span class="s4">{</span><span class="s2">lineEndIndex </span><span class="s4">- </span><span class="s2">lineStartIndex</span><span class="s4">}</span><span class="s3">).`</span><span class="s4">);</span>
        <span class="s4">}</span>

        <span class="s6">return </span><span class="s2">positionIndex</span><span class="s4">;</span>
    <span class="s4">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Gets the scope for the given node</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} currentNode The node to get the scope of</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{eslint-scope.Scope} The scope information for this node</span>
     <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{TypeError} If the `currentNode` argument is missing.</span>
     <span class="s0">*/</span>
    <span class="s2">getScope</span><span class="s4">(</span><span class="s2">currentNode</span><span class="s4">) {</span>

        <span class="s6">if </span><span class="s4">(!</span><span class="s2">currentNode</span><span class="s4">) {</span>
            <span class="s6">throw new </span><span class="s2">TypeError</span><span class="s4">(</span><span class="s3">&quot;Missing required argument: node.&quot;</span><span class="s4">);</span>
        <span class="s4">}</span>

        <span class="s5">// check cache first</span>
        <span class="s6">const </span><span class="s2">cache </span><span class="s4">= </span><span class="s6">this</span><span class="s4">[</span><span class="s2">caches</span><span class="s4">].</span><span class="s2">get</span><span class="s4">(</span><span class="s3">&quot;scopes&quot;</span><span class="s4">);</span>
        <span class="s6">const </span><span class="s2">cachedScope </span><span class="s4">= </span><span class="s2">cache</span><span class="s4">.</span><span class="s2">get</span><span class="s4">(</span><span class="s2">currentNode</span><span class="s4">);</span>

        <span class="s6">if </span><span class="s4">(</span><span class="s2">cachedScope</span><span class="s4">) {</span>
            <span class="s6">return </span><span class="s2">cachedScope</span><span class="s4">;</span>
        <span class="s4">}</span>

        <span class="s5">// On Program node, get the outermost scope to avoid return Node.js special function scope or ES modules scope.</span>
        <span class="s6">const </span><span class="s2">inner </span><span class="s4">= </span><span class="s2">currentNode</span><span class="s4">.</span><span class="s2">type </span><span class="s4">!== </span><span class="s3">&quot;Program&quot;</span><span class="s4">;</span>

        <span class="s6">for </span><span class="s4">(</span><span class="s6">let </span><span class="s2">node </span><span class="s4">= </span><span class="s2">currentNode</span><span class="s4">; </span><span class="s2">node</span><span class="s4">; </span><span class="s2">node </span><span class="s4">= </span><span class="s2">node</span><span class="s4">.</span><span class="s2">parent</span><span class="s4">) {</span>
            <span class="s6">const </span><span class="s2">scope </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">scopeManager</span><span class="s4">.</span><span class="s2">acquire</span><span class="s4">(</span><span class="s2">node</span><span class="s4">, </span><span class="s2">inner</span><span class="s4">);</span>

            <span class="s6">if </span><span class="s4">(</span><span class="s2">scope</span><span class="s4">) {</span>
                <span class="s6">if </span><span class="s4">(</span><span class="s2">scope</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;function-expression-name&quot;</span><span class="s4">) {</span>
                    <span class="s2">cache</span><span class="s4">.</span><span class="s2">set</span><span class="s4">(</span><span class="s2">currentNode</span><span class="s4">, </span><span class="s2">scope</span><span class="s4">.</span><span class="s2">childScopes</span><span class="s4">[</span><span class="s7">0</span><span class="s4">]);</span>
                    <span class="s6">return </span><span class="s2">scope</span><span class="s4">.</span><span class="s2">childScopes</span><span class="s4">[</span><span class="s7">0</span><span class="s4">];</span>
                <span class="s4">}</span>

                <span class="s2">cache</span><span class="s4">.</span><span class="s2">set</span><span class="s4">(</span><span class="s2">currentNode</span><span class="s4">, </span><span class="s2">scope</span><span class="s4">);</span>
                <span class="s6">return </span><span class="s2">scope</span><span class="s4">;</span>
            <span class="s4">}</span>
        <span class="s4">}</span>

        <span class="s2">cache</span><span class="s4">.</span><span class="s2">set</span><span class="s4">(</span><span class="s2">currentNode</span><span class="s4">, </span><span class="s6">this</span><span class="s4">.</span><span class="s2">scopeManager</span><span class="s4">.</span><span class="s2">scopes</span><span class="s4">[</span><span class="s7">0</span><span class="s4">]);</span>
        <span class="s6">return this</span><span class="s4">.</span><span class="s2">scopeManager</span><span class="s4">.</span><span class="s2">scopes</span><span class="s4">[</span><span class="s7">0</span><span class="s4">];</span>
    <span class="s4">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Get the variables that `node` defines.</span>
     <span class="s0">* This is a convenience method that passes through</span>
     <span class="s0">* to the same method on the `scopeManager`.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The node for which the variables are obtained.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Array&lt;Variable&gt;} An array of variable nodes representing</span>
     <span class="s0">*      the variables that `node` defines.</span>
     <span class="s0">*/</span>
    <span class="s2">getDeclaredVariables</span><span class="s4">(</span><span class="s2">node</span><span class="s4">) {</span>
        <span class="s6">return this</span><span class="s4">.</span><span class="s2">scopeManager</span><span class="s4">.</span><span class="s2">getDeclaredVariables</span><span class="s4">(</span><span class="s2">node</span><span class="s4">);</span>
    <span class="s4">}</span>

    <span class="s5">/* eslint-disable class-methods-use-this -- node is owned by SourceCode */</span>
    <span class="s0">/**</span>
     <span class="s0">* Gets all the ancestors of a given node</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The node</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Array&lt;ASTNode&gt;} All the ancestor nodes in the AST, not including the provided node, starting</span>
     <span class="s0">* from the root node at index 0 and going inwards to the parent node.</span>
     <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{TypeError} When `node` is missing.</span>
     <span class="s0">*/</span>
    <span class="s2">getAncestors</span><span class="s4">(</span><span class="s2">node</span><span class="s4">) {</span>

        <span class="s6">if </span><span class="s4">(!</span><span class="s2">node</span><span class="s4">) {</span>
            <span class="s6">throw new </span><span class="s2">TypeError</span><span class="s4">(</span><span class="s3">&quot;Missing required argument: node.&quot;</span><span class="s4">);</span>
        <span class="s4">}</span>

        <span class="s6">const </span><span class="s2">ancestorsStartingAtParent </span><span class="s4">= [];</span>

        <span class="s6">for </span><span class="s4">(</span><span class="s6">let </span><span class="s2">ancestor </span><span class="s4">= </span><span class="s2">node</span><span class="s4">.</span><span class="s2">parent</span><span class="s4">; </span><span class="s2">ancestor</span><span class="s4">; </span><span class="s2">ancestor </span><span class="s4">= </span><span class="s2">ancestor</span><span class="s4">.</span><span class="s2">parent</span><span class="s4">) {</span>
            <span class="s2">ancestorsStartingAtParent</span><span class="s4">.</span><span class="s2">push</span><span class="s4">(</span><span class="s2">ancestor</span><span class="s4">);</span>
        <span class="s4">}</span>

        <span class="s6">return </span><span class="s2">ancestorsStartingAtParent</span><span class="s4">.</span><span class="s2">reverse</span><span class="s4">();</span>
    <span class="s4">}</span>
    <span class="s5">/* eslint-enable class-methods-use-this -- node is owned by SourceCode */</span>

    <span class="s0">/**</span>
     <span class="s0">* Marks a variable as used in the current scope</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} name The name of the variable to mark as used.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} [refNode] The closest node to the variable reference.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} True if the variable was found and marked as used, false if not.</span>
     <span class="s0">*/</span>
    <span class="s2">markVariableAsUsed</span><span class="s4">(</span><span class="s2">name</span><span class="s4">, </span><span class="s2">refNode </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">ast</span><span class="s4">) {</span>

        <span class="s6">const </span><span class="s2">currentScope </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">getScope</span><span class="s4">(</span><span class="s2">refNode</span><span class="s4">);</span>
        <span class="s6">let </span><span class="s2">initialScope </span><span class="s4">= </span><span class="s2">currentScope</span><span class="s4">;</span>

        <span class="s5">/* 
         * When we are in an ESM or CommonJS module, we need to start searching 
         * from the top-level scope, not the global scope. For ESM the top-level 
         * scope is the module scope; for CommonJS the top-level scope is the 
         * outer function scope. 
         * 
         * Without this check, we might miss a variable declared with `var` at 
         * the top-level because it won't exist in the global scope. 
         */</span>
        <span class="s6">if </span><span class="s4">(</span>
            <span class="s2">currentScope</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;global&quot; </span><span class="s4">&amp;&amp;</span>
            <span class="s2">currentScope</span><span class="s4">.</span><span class="s2">childScopes</span><span class="s4">.</span><span class="s2">length </span><span class="s4">&gt; </span><span class="s7">0 </span><span class="s4">&amp;&amp;</span>

            <span class="s5">// top-level scopes refer to a `Program` node</span>
            <span class="s2">currentScope</span><span class="s4">.</span><span class="s2">childScopes</span><span class="s4">[</span><span class="s7">0</span><span class="s4">].</span><span class="s2">block </span><span class="s4">=== </span><span class="s6">this</span><span class="s4">.</span><span class="s2">ast</span>
        <span class="s4">) {</span>
            <span class="s2">initialScope </span><span class="s4">= </span><span class="s2">currentScope</span><span class="s4">.</span><span class="s2">childScopes</span><span class="s4">[</span><span class="s7">0</span><span class="s4">];</span>
        <span class="s4">}</span>

        <span class="s6">for </span><span class="s4">(</span><span class="s6">let </span><span class="s2">scope </span><span class="s4">= </span><span class="s2">initialScope</span><span class="s4">; </span><span class="s2">scope</span><span class="s4">; </span><span class="s2">scope </span><span class="s4">= </span><span class="s2">scope</span><span class="s4">.</span><span class="s2">upper</span><span class="s4">) {</span>
            <span class="s6">const </span><span class="s2">variable </span><span class="s4">= </span><span class="s2">scope</span><span class="s4">.</span><span class="s2">variables</span><span class="s4">.</span><span class="s2">find</span><span class="s4">(</span><span class="s2">scopeVar </span><span class="s4">=&gt; </span><span class="s2">scopeVar</span><span class="s4">.</span><span class="s2">name </span><span class="s4">=== </span><span class="s2">name</span><span class="s4">);</span>

            <span class="s6">if </span><span class="s4">(</span><span class="s2">variable</span><span class="s4">) {</span>
                <span class="s2">variable</span><span class="s4">.</span><span class="s2">eslintUsed </span><span class="s4">= </span><span class="s6">true</span><span class="s4">;</span>
                <span class="s6">return true</span><span class="s4">;</span>
            <span class="s4">}</span>
        <span class="s4">}</span>

        <span class="s6">return false</span><span class="s4">;</span>
    <span class="s4">}</span>


    <span class="s0">/**</span>
     <span class="s0">* Returns an array of all inline configuration nodes found in the</span>
     <span class="s0">* source code.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Array&lt;Token&gt;} An array of all inline configuration nodes.</span>
     <span class="s0">*/</span>
    <span class="s2">getInlineConfigNodes</span><span class="s4">() {</span>

        <span class="s5">// check the cache first</span>
        <span class="s6">let </span><span class="s2">configNodes </span><span class="s4">= </span><span class="s6">this</span><span class="s4">[</span><span class="s2">caches</span><span class="s4">].</span><span class="s2">get</span><span class="s4">(</span><span class="s3">&quot;configNodes&quot;</span><span class="s4">);</span>

        <span class="s6">if </span><span class="s4">(</span><span class="s2">configNodes</span><span class="s4">) {</span>
            <span class="s6">return </span><span class="s2">configNodes</span><span class="s4">;</span>
        <span class="s4">}</span>

        <span class="s5">// calculate fresh config nodes</span>
        <span class="s2">configNodes </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">ast</span><span class="s4">.</span><span class="s2">comments</span><span class="s4">.</span><span class="s2">filter</span><span class="s4">(</span><span class="s2">comment </span><span class="s4">=&gt; {</span>

            <span class="s5">// shebang comments are never directives</span>
            <span class="s6">if </span><span class="s4">(</span><span class="s2">comment</span><span class="s4">.</span><span class="s2">type </span><span class="s4">=== </span><span class="s3">&quot;Shebang&quot;</span><span class="s4">) {</span>
                <span class="s6">return false</span><span class="s4">;</span>
            <span class="s4">}</span>

            <span class="s6">const </span><span class="s4">{ </span><span class="s2">directivePart </span><span class="s4">} = </span><span class="s2">commentParser</span><span class="s4">.</span><span class="s2">extractDirectiveComment</span><span class="s4">(</span><span class="s2">comment</span><span class="s4">.</span><span class="s2">value</span><span class="s4">);</span>

            <span class="s6">const </span><span class="s2">directiveMatch </span><span class="s4">= </span><span class="s2">directivesPattern</span><span class="s4">.</span><span class="s2">exec</span><span class="s4">(</span><span class="s2">directivePart</span><span class="s4">);</span>

            <span class="s6">if </span><span class="s4">(!</span><span class="s2">directiveMatch</span><span class="s4">) {</span>
                <span class="s6">return false</span><span class="s4">;</span>
            <span class="s4">}</span>

            <span class="s5">// only certain comment types are supported as line comments</span>
            <span class="s6">return </span><span class="s2">comment</span><span class="s4">.</span><span class="s2">type </span><span class="s4">!== </span><span class="s3">&quot;Line&quot; </span><span class="s4">|| !!</span><span class="s8">/^eslint-disable-(next-)?line$/u</span><span class="s4">.</span><span class="s2">test</span><span class="s4">(</span><span class="s2">directiveMatch</span><span class="s4">[</span><span class="s7">1</span><span class="s4">]);</span>
        <span class="s4">});</span>

        <span class="s6">this</span><span class="s4">[</span><span class="s2">caches</span><span class="s4">].</span><span class="s2">set</span><span class="s4">(</span><span class="s3">&quot;configNodes&quot;</span><span class="s4">, </span><span class="s2">configNodes</span><span class="s4">);</span>

        <span class="s6">return </span><span class="s2">configNodes</span><span class="s4">;</span>
    <span class="s4">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Applies language options sent in from the core.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Object} languageOptions The language options for this run.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
     <span class="s0">*/</span>
    <span class="s2">applyLanguageOptions</span><span class="s4">(</span><span class="s2">languageOptions</span><span class="s4">) {</span>

        <span class="s5">/* 
         * Add configured globals and language globals 
         * 
         * Using Object.assign instead of object spread for performance reasons 
         * https://github.com/eslint/eslint/issues/16302 
         */</span>
        <span class="s6">const </span><span class="s2">configGlobals </span><span class="s4">= </span><span class="s2">Object</span><span class="s4">.</span><span class="s2">assign</span><span class="s4">(</span>
            <span class="s2">Object</span><span class="s4">.</span><span class="s2">create</span><span class="s4">(</span><span class="s6">null</span><span class="s4">), </span><span class="s5">// https://github.com/eslint/eslint/issues/18363</span>
            <span class="s2">getGlobalsForEcmaVersion</span><span class="s4">(</span><span class="s2">languageOptions</span><span class="s4">.</span><span class="s2">ecmaVersion</span><span class="s4">),</span>
            <span class="s2">languageOptions</span><span class="s4">.</span><span class="s2">sourceType </span><span class="s4">=== </span><span class="s3">&quot;commonjs&quot; </span><span class="s4">? </span><span class="s2">globals</span><span class="s4">.</span><span class="s2">commonjs </span><span class="s4">: </span><span class="s6">void </span><span class="s7">0</span><span class="s4">,</span>
            <span class="s2">languageOptions</span><span class="s4">.</span><span class="s2">globals</span>
        <span class="s4">);</span>
        <span class="s6">const </span><span class="s2">varsCache </span><span class="s4">= </span><span class="s6">this</span><span class="s4">[</span><span class="s2">caches</span><span class="s4">].</span><span class="s2">get</span><span class="s4">(</span><span class="s3">&quot;vars&quot;</span><span class="s4">);</span>

        <span class="s2">varsCache</span><span class="s4">.</span><span class="s2">set</span><span class="s4">(</span><span class="s3">&quot;configGlobals&quot;</span><span class="s4">, </span><span class="s2">configGlobals</span><span class="s4">);</span>
    <span class="s4">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Applies configuration found inside of the source code. This method is only</span>
     <span class="s0">* called when ESLint is running with inline configuration allowed.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{{problems:Array&lt;Problem&gt;,configs:{config:FlatConfigArray,node:ASTNode}}} Information</span>
     <span class="s0">*      that ESLint needs to further process the inline configuration.</span>
     <span class="s0">*/</span>
    <span class="s2">applyInlineConfig</span><span class="s4">() {</span>

        <span class="s6">const </span><span class="s2">problems </span><span class="s4">= [];</span>
        <span class="s6">const </span><span class="s2">configs </span><span class="s4">= [];</span>
        <span class="s6">const </span><span class="s2">exportedVariables </span><span class="s4">= {};</span>
        <span class="s6">const </span><span class="s2">inlineGlobals </span><span class="s4">= </span><span class="s2">Object</span><span class="s4">.</span><span class="s2">create</span><span class="s4">(</span><span class="s6">null</span><span class="s4">);</span>

        <span class="s6">this</span><span class="s4">.</span><span class="s2">getInlineConfigNodes</span><span class="s4">().</span><span class="s2">forEach</span><span class="s4">(</span><span class="s2">comment </span><span class="s4">=&gt; {</span>

            <span class="s6">const </span><span class="s4">{ </span><span class="s2">directiveText</span><span class="s4">, </span><span class="s2">directiveValue </span><span class="s4">} = </span><span class="s2">commentParser</span><span class="s4">.</span><span class="s2">parseDirective</span><span class="s4">(</span><span class="s2">comment</span><span class="s4">);</span>

            <span class="s6">switch </span><span class="s4">(</span><span class="s2">directiveText</span><span class="s4">) {</span>
                <span class="s6">case </span><span class="s3">&quot;exported&quot;</span><span class="s4">:</span>
                    <span class="s2">Object</span><span class="s4">.</span><span class="s2">assign</span><span class="s4">(</span><span class="s2">exportedVariables</span><span class="s4">, </span><span class="s2">commentParser</span><span class="s4">.</span><span class="s2">parseStringConfig</span><span class="s4">(</span><span class="s2">directiveValue</span><span class="s4">, </span><span class="s2">comment</span><span class="s4">));</span>
                    <span class="s6">break</span><span class="s4">;</span>

                <span class="s6">case </span><span class="s3">&quot;globals&quot;</span><span class="s4">:</span>
                <span class="s6">case </span><span class="s3">&quot;global&quot;</span><span class="s4">:</span>
                    <span class="s6">for </span><span class="s4">(</span><span class="s6">const </span><span class="s4">[</span><span class="s2">id</span><span class="s4">, { </span><span class="s2">value </span><span class="s4">}] </span><span class="s2">of Object</span><span class="s4">.</span><span class="s2">entries</span><span class="s4">(</span><span class="s2">commentParser</span><span class="s4">.</span><span class="s2">parseStringConfig</span><span class="s4">(</span><span class="s2">directiveValue</span><span class="s4">, </span><span class="s2">comment</span><span class="s4">))) {</span>
                        <span class="s6">let </span><span class="s2">normalizedValue</span><span class="s4">;</span>

                        <span class="s6">try </span><span class="s4">{</span>
                            <span class="s2">normalizedValue </span><span class="s4">= </span><span class="s2">normalizeConfigGlobal</span><span class="s4">(</span><span class="s2">value</span><span class="s4">);</span>
                        <span class="s4">} </span><span class="s6">catch </span><span class="s4">(</span><span class="s2">err</span><span class="s4">) {</span>
                            <span class="s2">problems</span><span class="s4">.</span><span class="s2">push</span><span class="s4">({</span>
                                <span class="s2">ruleId</span><span class="s4">: </span><span class="s6">null</span><span class="s4">,</span>
                                <span class="s2">loc</span><span class="s4">: </span><span class="s2">comment</span><span class="s4">.</span><span class="s2">loc</span><span class="s4">,</span>
                                <span class="s2">message</span><span class="s4">: </span><span class="s2">err</span><span class="s4">.</span><span class="s2">message</span>
                            <span class="s4">});</span>
                            <span class="s6">continue</span><span class="s4">;</span>
                        <span class="s4">}</span>

                        <span class="s6">if </span><span class="s4">(</span><span class="s2">inlineGlobals</span><span class="s4">[</span><span class="s2">id</span><span class="s4">]) {</span>
                            <span class="s2">inlineGlobals</span><span class="s4">[</span><span class="s2">id</span><span class="s4">].</span><span class="s2">comments</span><span class="s4">.</span><span class="s2">push</span><span class="s4">(</span><span class="s2">comment</span><span class="s4">);</span>
                            <span class="s2">inlineGlobals</span><span class="s4">[</span><span class="s2">id</span><span class="s4">].</span><span class="s2">value </span><span class="s4">= </span><span class="s2">normalizedValue</span><span class="s4">;</span>
                        <span class="s4">} </span><span class="s6">else </span><span class="s4">{</span>
                            <span class="s2">inlineGlobals</span><span class="s4">[</span><span class="s2">id</span><span class="s4">] = {</span>
                                <span class="s2">comments</span><span class="s4">: [</span><span class="s2">comment</span><span class="s4">],</span>
                                <span class="s2">value</span><span class="s4">: </span><span class="s2">normalizedValue</span>
                            <span class="s4">};</span>
                        <span class="s4">}</span>
                    <span class="s4">}</span>
                    <span class="s6">break</span><span class="s4">;</span>

                <span class="s6">case </span><span class="s3">&quot;eslint&quot;</span><span class="s4">: {</span>
                    <span class="s6">const </span><span class="s2">parseResult </span><span class="s4">= </span><span class="s2">commentParser</span><span class="s4">.</span><span class="s2">parseJsonConfig</span><span class="s4">(</span><span class="s2">directiveValue</span><span class="s4">, </span><span class="s2">comment</span><span class="s4">.</span><span class="s2">loc</span><span class="s4">);</span>

                    <span class="s6">if </span><span class="s4">(</span><span class="s2">parseResult</span><span class="s4">.</span><span class="s2">success</span><span class="s4">) {</span>
                        <span class="s2">configs</span><span class="s4">.</span><span class="s2">push</span><span class="s4">({</span>
                            <span class="s2">config</span><span class="s4">: {</span>
                                <span class="s2">rules</span><span class="s4">: </span><span class="s2">parseResult</span><span class="s4">.</span><span class="s2">config</span>
                            <span class="s4">},</span>
                            <span class="s2">node</span><span class="s4">: </span><span class="s2">comment</span>
                        <span class="s4">});</span>
                    <span class="s4">} </span><span class="s6">else </span><span class="s4">{</span>
                        <span class="s2">problems</span><span class="s4">.</span><span class="s2">push</span><span class="s4">(</span><span class="s2">parseResult</span><span class="s4">.</span><span class="s2">error</span><span class="s4">);</span>
                    <span class="s4">}</span>

                    <span class="s6">break</span><span class="s4">;</span>
                <span class="s4">}</span>

                <span class="s5">// no default</span>
            <span class="s4">}</span>
        <span class="s4">});</span>

        <span class="s5">// save all the new variables for later</span>
        <span class="s6">const </span><span class="s2">varsCache </span><span class="s4">= </span><span class="s6">this</span><span class="s4">[</span><span class="s2">caches</span><span class="s4">].</span><span class="s2">get</span><span class="s4">(</span><span class="s3">&quot;vars&quot;</span><span class="s4">);</span>

        <span class="s2">varsCache</span><span class="s4">.</span><span class="s2">set</span><span class="s4">(</span><span class="s3">&quot;inlineGlobals&quot;</span><span class="s4">, </span><span class="s2">inlineGlobals</span><span class="s4">);</span>
        <span class="s2">varsCache</span><span class="s4">.</span><span class="s2">set</span><span class="s4">(</span><span class="s3">&quot;exportedVariables&quot;</span><span class="s4">, </span><span class="s2">exportedVariables</span><span class="s4">);</span>

        <span class="s6">return </span><span class="s4">{</span>
            <span class="s2">configs</span><span class="s4">,</span>
            <span class="s2">problems</span>
        <span class="s4">};</span>
    <span class="s4">}</span>

    <span class="s0">/**</span>
     <span class="s0">* Called by ESLint core to indicate that it has finished providing</span>
     <span class="s0">* information. We now add in all the missing variables and ensure that</span>
     <span class="s0">* state-changing methods cannot be called by rules.</span>
     <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
     <span class="s0">*/</span>
    <span class="s2">finalize</span><span class="s4">() {</span>

        <span class="s5">// Step 1: ensure that all of the necessary variables are up to date</span>
        <span class="s6">const </span><span class="s2">varsCache </span><span class="s4">= </span><span class="s6">this</span><span class="s4">[</span><span class="s2">caches</span><span class="s4">].</span><span class="s2">get</span><span class="s4">(</span><span class="s3">&quot;vars&quot;</span><span class="s4">);</span>
        <span class="s6">const </span><span class="s2">globalScope </span><span class="s4">= </span><span class="s6">this</span><span class="s4">.</span><span class="s2">scopeManager</span><span class="s4">.</span><span class="s2">scopes</span><span class="s4">[</span><span class="s7">0</span><span class="s4">];</span>
        <span class="s6">const </span><span class="s2">configGlobals </span><span class="s4">= </span><span class="s2">varsCache</span><span class="s4">.</span><span class="s2">get</span><span class="s4">(</span><span class="s3">&quot;configGlobals&quot;</span><span class="s4">);</span>
        <span class="s6">const </span><span class="s2">inlineGlobals </span><span class="s4">= </span><span class="s2">varsCache</span><span class="s4">.</span><span class="s2">get</span><span class="s4">(</span><span class="s3">&quot;inlineGlobals&quot;</span><span class="s4">);</span>
        <span class="s6">const </span><span class="s2">exportedVariables </span><span class="s4">= </span><span class="s2">varsCache</span><span class="s4">.</span><span class="s2">get</span><span class="s4">(</span><span class="s3">&quot;exportedVariables&quot;</span><span class="s4">);</span>

        <span class="s2">addDeclaredGlobals</span><span class="s4">(</span><span class="s2">globalScope</span><span class="s4">, </span><span class="s2">configGlobals</span><span class="s4">, </span><span class="s2">inlineGlobals</span><span class="s4">);</span>

        <span class="s6">if </span><span class="s4">(</span><span class="s2">exportedVariables</span><span class="s4">) {</span>
            <span class="s2">markExportedVariables</span><span class="s4">(</span><span class="s2">globalScope</span><span class="s4">, </span><span class="s2">exportedVariables</span><span class="s4">);</span>
        <span class="s4">}</span>

    <span class="s4">}</span>

<span class="s4">}</span>

<span class="s2">module</span><span class="s4">.</span><span class="s2">exports </span><span class="s4">= </span><span class="s2">SourceCode</span><span class="s4">;</span>
</pre>
</body>
</html>