<html>
<head>
<title>sourcemap-codec.mjs.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
sourcemap-codec.mjs.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;sourcemap-codec.mjs&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../src/vlq.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;../src/strings.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;../src/scopes.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;../src/sourcemap-codec.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { StringReader, StringWriter } from './strings';</span><span class="s3">\n\n</span><span class="s1">export const comma = ','.charCodeAt(0);</span><span class="s3">\n</span><span class="s1">export const semicolon = ';'.charCodeAt(0);</span><span class="s3">\n\n</span><span class="s1">const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';</span><span class="s3">\n</span><span class="s1">const intToChar = new Uint8Array(64); // 64 possible chars.</span><span class="s3">\n</span><span class="s1">const charToInt = new Uint8Array(128); // z is 122 in ASCII</span><span class="s3">\n\n</span><span class="s1">for (let i = 0; i &lt; chars.length; i++) {</span><span class="s3">\n  </span><span class="s1">const c = chars.charCodeAt(i);</span><span class="s3">\n  </span><span class="s1">intToChar[i] = c;</span><span class="s3">\n  </span><span class="s1">charToInt[c] = i;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function decodeInteger(reader: StringReader, relative: number): number {</span><span class="s3">\n  </span><span class="s1">let value = 0;</span><span class="s3">\n  </span><span class="s1">let shift = 0;</span><span class="s3">\n  </span><span class="s1">let integer = 0;</span><span class="s3">\n\n  </span><span class="s1">do {</span><span class="s3">\n    </span><span class="s1">const c = reader.next();</span><span class="s3">\n    </span><span class="s1">integer = charToInt[c];</span><span class="s3">\n    </span><span class="s1">value |= (integer &amp; 31) &lt;&lt; shift;</span><span class="s3">\n    </span><span class="s1">shift += 5;</span><span class="s3">\n  </span><span class="s1">} while (integer &amp; 32);</span><span class="s3">\n\n  </span><span class="s1">const shouldNegate = value &amp; 1;</span><span class="s3">\n  </span><span class="s1">value &gt;&gt;&gt;= 1;</span><span class="s3">\n\n  </span><span class="s1">if (shouldNegate) {</span><span class="s3">\n    </span><span class="s1">value = -0x80000000 | -value;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return relative + value;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function encodeInteger(builder: StringWriter, num: number, relative: number): number {</span><span class="s3">\n  </span><span class="s1">let delta = num - relative;</span><span class="s3">\n\n  </span><span class="s1">delta = delta &lt; 0 ? (-delta &lt;&lt; 1) | 1 : delta &lt;&lt; 1;</span><span class="s3">\n  </span><span class="s1">do {</span><span class="s3">\n    </span><span class="s1">let clamped = delta &amp; 0b011111;</span><span class="s3">\n    </span><span class="s1">delta &gt;&gt;&gt;= 5;</span><span class="s3">\n    </span><span class="s1">if (delta &gt; 0) clamped |= 0b100000;</span><span class="s3">\n    </span><span class="s1">builder.write(intToChar[clamped]);</span><span class="s3">\n  </span><span class="s1">} while (delta &gt; 0);</span><span class="s3">\n\n  </span><span class="s1">return num;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function hasMoreVlq(reader: StringReader, max: number) {</span><span class="s3">\n  </span><span class="s1">if (reader.pos &gt;= max) return false;</span><span class="s3">\n  </span><span class="s1">return reader.peek() !== comma;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;const bufLength = 1024 * 16;</span><span class="s3">\n\n</span><span class="s1">// Provide a fallback for older environments.</span><span class="s3">\n</span><span class="s1">const td =</span><span class="s3">\n  </span><span class="s1">typeof TextDecoder !== 'undefined'</span><span class="s3">\n    </span><span class="s1">? /* #__PURE__ */ new TextDecoder()</span><span class="s3">\n    </span><span class="s1">: typeof Buffer !== 'undefined'</span><span class="s3">\n    </span><span class="s1">? {</span><span class="s3">\n        </span><span class="s1">decode(buf: Uint8Array): string {</span><span class="s3">\n          </span><span class="s1">const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);</span><span class="s3">\n          </span><span class="s1">return out.toString();</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">decode(buf: Uint8Array): string {</span><span class="s3">\n          </span><span class="s1">let out = '';</span><span class="s3">\n          </span><span class="s1">for (let i = 0; i &lt; buf.length; i++) {</span><span class="s3">\n            </span><span class="s1">out += String.fromCharCode(buf[i]);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">return out;</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export class StringWriter {</span><span class="s3">\n  </span><span class="s1">pos = 0;</span><span class="s3">\n  </span><span class="s1">private out = '';</span><span class="s3">\n  </span><span class="s1">private buffer = new Uint8Array(bufLength);</span><span class="s3">\n\n  </span><span class="s1">write(v: number): void {</span><span class="s3">\n    </span><span class="s1">const { buffer } = this;</span><span class="s3">\n    </span><span class="s1">buffer[this.pos++] = v;</span><span class="s3">\n    </span><span class="s1">if (this.pos === bufLength) {</span><span class="s3">\n      </span><span class="s1">this.out += td.decode(buffer);</span><span class="s3">\n      </span><span class="s1">this.pos = 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">flush(): string {</span><span class="s3">\n    </span><span class="s1">const { buffer, out, pos } = this;</span><span class="s3">\n    </span><span class="s1">return pos &gt; 0 ? out + td.decode(buffer.subarray(0, pos)) : out;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export class StringReader {</span><span class="s3">\n  </span><span class="s1">pos = 0;</span><span class="s3">\n  </span><span class="s1">private declare buffer: string;</span><span class="s3">\n\n  </span><span class="s1">constructor(buffer: string) {</span><span class="s3">\n    </span><span class="s1">this.buffer = buffer;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">next(): number {</span><span class="s3">\n    </span><span class="s1">return this.buffer.charCodeAt(this.pos++);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">peek(): number {</span><span class="s3">\n    </span><span class="s1">return this.buffer.charCodeAt(this.pos);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">indexOf(char: string): number {</span><span class="s3">\n    </span><span class="s1">const { buffer, pos } = this;</span><span class="s3">\n    </span><span class="s1">const idx = buffer.indexOf(char, pos);</span><span class="s3">\n    </span><span class="s1">return idx === -1 ? buffer.length : idx;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { StringReader, StringWriter } from './strings';</span><span class="s3">\n</span><span class="s1">import { comma, decodeInteger, encodeInteger, hasMoreVlq, semicolon } from './vlq';</span><span class="s3">\n\n</span><span class="s1">const EMPTY: any[] = [];</span><span class="s3">\n\n</span><span class="s1">type Line = number;</span><span class="s3">\n</span><span class="s1">type Column = number;</span><span class="s3">\n</span><span class="s1">type Kind = number;</span><span class="s3">\n</span><span class="s1">type Name = number;</span><span class="s3">\n</span><span class="s1">type Var = number;</span><span class="s3">\n</span><span class="s1">type SourcesIndex = number;</span><span class="s3">\n</span><span class="s1">type ScopesIndex = number;</span><span class="s3">\n\n</span><span class="s1">type Mix&lt;A, B, O&gt; = (A &amp; O) | (B &amp; O);</span><span class="s3">\n\n</span><span class="s1">export type OriginalScope = Mix&lt;</span><span class="s3">\n  </span><span class="s1">[Line, Column, Line, Column, Kind],</span><span class="s3">\n  </span><span class="s1">[Line, Column, Line, Column, Kind, Name],</span><span class="s3">\n  </span><span class="s1">{ vars: Var[] }</span><span class="s3">\n</span><span class="s1">&gt;;</span><span class="s3">\n\n</span><span class="s1">export type GeneratedRange = Mix&lt;</span><span class="s3">\n  </span><span class="s1">[Line, Column, Line, Column],</span><span class="s3">\n  </span><span class="s1">[Line, Column, Line, Column, SourcesIndex, ScopesIndex],</span><span class="s3">\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">callsite: CallSite | null;</span><span class="s3">\n    </span><span class="s1">bindings: Binding[];</span><span class="s3">\n    </span><span class="s1">isScope: boolean;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&gt;;</span><span class="s3">\n</span><span class="s1">export type CallSite = [SourcesIndex, Line, Column];</span><span class="s3">\n</span><span class="s1">type Binding = BindingExpressionRange[];</span><span class="s3">\n</span><span class="s1">export type BindingExpressionRange = [Name] | [Name, Line, Column];</span><span class="s3">\n\n</span><span class="s1">export function decodeOriginalScopes(input: string): OriginalScope[] {</span><span class="s3">\n  </span><span class="s1">const { length } = input;</span><span class="s3">\n  </span><span class="s1">const reader = new StringReader(input);</span><span class="s3">\n  </span><span class="s1">const scopes: OriginalScope[] = [];</span><span class="s3">\n  </span><span class="s1">const stack: OriginalScope[] = [];</span><span class="s3">\n  </span><span class="s1">let line = 0;</span><span class="s3">\n\n  </span><span class="s1">for (; reader.pos &lt; length; reader.pos++) {</span><span class="s3">\n    </span><span class="s1">line = decodeInteger(reader, line);</span><span class="s3">\n    </span><span class="s1">const column = decodeInteger(reader, 0);</span><span class="s3">\n\n    </span><span class="s1">if (!hasMoreVlq(reader, length)) {</span><span class="s3">\n      </span><span class="s1">const last = stack.pop()!;</span><span class="s3">\n      </span><span class="s1">last[2] = line;</span><span class="s3">\n      </span><span class="s1">last[3] = column;</span><span class="s3">\n      </span><span class="s1">continue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const kind = decodeInteger(reader, 0);</span><span class="s3">\n    </span><span class="s1">const fields = decodeInteger(reader, 0);</span><span class="s3">\n    </span><span class="s1">const hasName = fields &amp; 0b0001;</span><span class="s3">\n\n    </span><span class="s1">const scope: OriginalScope = (</span><span class="s3">\n      </span><span class="s1">hasName ? [line, column, 0, 0, kind, decodeInteger(reader, 0)] : [line, column, 0, 0, kind]</span><span class="s3">\n    </span><span class="s1">) as OriginalScope;</span><span class="s3">\n\n    </span><span class="s1">let vars: Var[] = EMPTY;</span><span class="s3">\n    </span><span class="s1">if (hasMoreVlq(reader, length)) {</span><span class="s3">\n      </span><span class="s1">vars = [];</span><span class="s3">\n      </span><span class="s1">do {</span><span class="s3">\n        </span><span class="s1">const varsIndex = decodeInteger(reader, 0);</span><span class="s3">\n        </span><span class="s1">vars.push(varsIndex);</span><span class="s3">\n      </span><span class="s1">} while (hasMoreVlq(reader, length));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">scope.vars = vars;</span><span class="s3">\n\n    </span><span class="s1">scopes.push(scope);</span><span class="s3">\n    </span><span class="s1">stack.push(scope);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return scopes;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function encodeOriginalScopes(scopes: OriginalScope[]): string {</span><span class="s3">\n  </span><span class="s1">const writer = new StringWriter();</span><span class="s3">\n\n  </span><span class="s1">for (let i = 0; i &lt; scopes.length; ) {</span><span class="s3">\n    </span><span class="s1">i = _encodeOriginalScopes(scopes, i, writer, [0]);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return writer.flush();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function _encodeOriginalScopes(</span><span class="s3">\n  </span><span class="s1">scopes: OriginalScope[],</span><span class="s3">\n  </span><span class="s1">index: number,</span><span class="s3">\n  </span><span class="s1">writer: StringWriter,</span><span class="s3">\n  </span><span class="s1">state: [</span><span class="s3">\n    </span><span class="s1">number, // GenColumn</span><span class="s3">\n  </span><span class="s1">],</span><span class="s3">\n</span><span class="s1">): number {</span><span class="s3">\n  </span><span class="s1">const scope = scopes[index];</span><span class="s3">\n  </span><span class="s1">const { 0: startLine, 1: startColumn, 2: endLine, 3: endColumn, 4: kind, vars } = scope;</span><span class="s3">\n\n  </span><span class="s1">if (index &gt; 0) writer.write(comma);</span><span class="s3">\n\n  </span><span class="s1">state[0] = encodeInteger(writer, startLine, state[0]);</span><span class="s3">\n  </span><span class="s1">encodeInteger(writer, startColumn, 0);</span><span class="s3">\n  </span><span class="s1">encodeInteger(writer, kind, 0);</span><span class="s3">\n\n  </span><span class="s1">const fields = scope.length === 6 ? 0b0001 : 0;</span><span class="s3">\n  </span><span class="s1">encodeInteger(writer, fields, 0);</span><span class="s3">\n  </span><span class="s1">if (scope.length === 6) encodeInteger(writer, scope[5], 0);</span><span class="s3">\n\n  </span><span class="s1">for (const v of vars) {</span><span class="s3">\n    </span><span class="s1">encodeInteger(writer, v, 0);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">for (index++; index &lt; scopes.length; ) {</span><span class="s3">\n    </span><span class="s1">const next = scopes[index];</span><span class="s3">\n    </span><span class="s1">const { 0: l, 1: c } = next;</span><span class="s3">\n    </span><span class="s1">if (l &gt; endLine || (l === endLine &amp;&amp; c &gt;= endColumn)) {</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">index = _encodeOriginalScopes(scopes, index, writer, state);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">writer.write(comma);</span><span class="s3">\n  </span><span class="s1">state[0] = encodeInteger(writer, endLine, state[0]);</span><span class="s3">\n  </span><span class="s1">encodeInteger(writer, endColumn, 0);</span><span class="s3">\n\n  </span><span class="s1">return index;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function decodeGeneratedRanges(input: string): GeneratedRange[] {</span><span class="s3">\n  </span><span class="s1">const { length } = input;</span><span class="s3">\n  </span><span class="s1">const reader = new StringReader(input);</span><span class="s3">\n  </span><span class="s1">const ranges: GeneratedRange[] = [];</span><span class="s3">\n  </span><span class="s1">const stack: GeneratedRange[] = [];</span><span class="s3">\n\n  </span><span class="s1">let genLine = 0;</span><span class="s3">\n  </span><span class="s1">let definitionSourcesIndex = 0;</span><span class="s3">\n  </span><span class="s1">let definitionScopeIndex = 0;</span><span class="s3">\n  </span><span class="s1">let callsiteSourcesIndex = 0;</span><span class="s3">\n  </span><span class="s1">let callsiteLine = 0;</span><span class="s3">\n  </span><span class="s1">let callsiteColumn = 0;</span><span class="s3">\n  </span><span class="s1">let bindingLine = 0;</span><span class="s3">\n  </span><span class="s1">let bindingColumn = 0;</span><span class="s3">\n\n  </span><span class="s1">do {</span><span class="s3">\n    </span><span class="s1">const semi = reader.indexOf(';');</span><span class="s3">\n    </span><span class="s1">let genColumn = 0;</span><span class="s3">\n\n    </span><span class="s1">for (; reader.pos &lt; semi; reader.pos++) {</span><span class="s3">\n      </span><span class="s1">genColumn = decodeInteger(reader, genColumn);</span><span class="s3">\n\n      </span><span class="s1">if (!hasMoreVlq(reader, semi)) {</span><span class="s3">\n        </span><span class="s1">const last = stack.pop()!;</span><span class="s3">\n        </span><span class="s1">last[2] = genLine;</span><span class="s3">\n        </span><span class="s1">last[3] = genColumn;</span><span class="s3">\n        </span><span class="s1">continue;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const fields = decodeInteger(reader, 0);</span><span class="s3">\n      </span><span class="s1">const hasDefinition = fields &amp; 0b0001;</span><span class="s3">\n      </span><span class="s1">const hasCallsite = fields &amp; 0b0010;</span><span class="s3">\n      </span><span class="s1">const hasScope = fields &amp; 0b0100;</span><span class="s3">\n\n      </span><span class="s1">let callsite: CallSite | null = null;</span><span class="s3">\n      </span><span class="s1">let bindings: Binding[] = EMPTY;</span><span class="s3">\n      </span><span class="s1">let range: GeneratedRange;</span><span class="s3">\n      </span><span class="s1">if (hasDefinition) {</span><span class="s3">\n        </span><span class="s1">const defSourcesIndex = decodeInteger(reader, definitionSourcesIndex);</span><span class="s3">\n        </span><span class="s1">definitionScopeIndex = decodeInteger(</span><span class="s3">\n          </span><span class="s1">reader,</span><span class="s3">\n          </span><span class="s1">definitionSourcesIndex === defSourcesIndex ? definitionScopeIndex : 0,</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n\n        </span><span class="s1">definitionSourcesIndex = defSourcesIndex;</span><span class="s3">\n        </span><span class="s1">range = [genLine, genColumn, 0, 0, defSourcesIndex, definitionScopeIndex] as GeneratedRange;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">range = [genLine, genColumn, 0, 0] as GeneratedRange;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">range.isScope = !!hasScope;</span><span class="s3">\n\n      </span><span class="s1">if (hasCallsite) {</span><span class="s3">\n        </span><span class="s1">const prevCsi = callsiteSourcesIndex;</span><span class="s3">\n        </span><span class="s1">const prevLine = callsiteLine;</span><span class="s3">\n        </span><span class="s1">callsiteSourcesIndex = decodeInteger(reader, callsiteSourcesIndex);</span><span class="s3">\n        </span><span class="s1">const sameSource = prevCsi === callsiteSourcesIndex;</span><span class="s3">\n        </span><span class="s1">callsiteLine = decodeInteger(reader, sameSource ? callsiteLine : 0);</span><span class="s3">\n        </span><span class="s1">callsiteColumn = decodeInteger(</span><span class="s3">\n          </span><span class="s1">reader,</span><span class="s3">\n          </span><span class="s1">sameSource &amp;&amp; prevLine === callsiteLine ? callsiteColumn : 0,</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n\n        </span><span class="s1">callsite = [callsiteSourcesIndex, callsiteLine, callsiteColumn];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">range.callsite = callsite;</span><span class="s3">\n\n      </span><span class="s1">if (hasMoreVlq(reader, semi)) {</span><span class="s3">\n        </span><span class="s1">bindings = [];</span><span class="s3">\n        </span><span class="s1">do {</span><span class="s3">\n          </span><span class="s1">bindingLine = genLine;</span><span class="s3">\n          </span><span class="s1">bindingColumn = genColumn;</span><span class="s3">\n          </span><span class="s1">const expressionsCount = decodeInteger(reader, 0);</span><span class="s3">\n          </span><span class="s1">let expressionRanges: BindingExpressionRange[];</span><span class="s3">\n          </span><span class="s1">if (expressionsCount &lt; -1) {</span><span class="s3">\n            </span><span class="s1">expressionRanges = [[decodeInteger(reader, 0)]];</span><span class="s3">\n            </span><span class="s1">for (let i = -1; i &gt; expressionsCount; i--) {</span><span class="s3">\n              </span><span class="s1">const prevBl = bindingLine;</span><span class="s3">\n              </span><span class="s1">bindingLine = decodeInteger(reader, bindingLine);</span><span class="s3">\n              </span><span class="s1">bindingColumn = decodeInteger(reader, bindingLine === prevBl ? bindingColumn : 0);</span><span class="s3">\n              </span><span class="s1">const expression = decodeInteger(reader, 0);</span><span class="s3">\n              </span><span class="s1">expressionRanges.push([expression, bindingLine, bindingColumn]);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">expressionRanges = [[expressionsCount]];</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">bindings.push(expressionRanges);</span><span class="s3">\n        </span><span class="s1">} while (hasMoreVlq(reader, semi));</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">range.bindings = bindings;</span><span class="s3">\n\n      </span><span class="s1">ranges.push(range);</span><span class="s3">\n      </span><span class="s1">stack.push(range);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">genLine++;</span><span class="s3">\n    </span><span class="s1">reader.pos = semi + 1;</span><span class="s3">\n  </span><span class="s1">} while (reader.pos &lt; length);</span><span class="s3">\n\n  </span><span class="s1">return ranges;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function encodeGeneratedRanges(ranges: GeneratedRange[]): string {</span><span class="s3">\n  </span><span class="s1">if (ranges.length === 0) return '';</span><span class="s3">\n\n  </span><span class="s1">const writer = new StringWriter();</span><span class="s3">\n\n  </span><span class="s1">for (let i = 0; i &lt; ranges.length; ) {</span><span class="s3">\n    </span><span class="s1">i = _encodeGeneratedRanges(ranges, i, writer, [0, 0, 0, 0, 0, 0, 0]);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return writer.flush();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function _encodeGeneratedRanges(</span><span class="s3">\n  </span><span class="s1">ranges: GeneratedRange[],</span><span class="s3">\n  </span><span class="s1">index: number,</span><span class="s3">\n  </span><span class="s1">writer: StringWriter,</span><span class="s3">\n  </span><span class="s1">state: [</span><span class="s3">\n    </span><span class="s1">number, // GenLine</span><span class="s3">\n    </span><span class="s1">number, // GenColumn</span><span class="s3">\n    </span><span class="s1">number, // DefSourcesIndex</span><span class="s3">\n    </span><span class="s1">number, // DefScopesIndex</span><span class="s3">\n    </span><span class="s1">number, // CallSourcesIndex</span><span class="s3">\n    </span><span class="s1">number, // CallLine</span><span class="s3">\n    </span><span class="s1">number, // CallColumn</span><span class="s3">\n  </span><span class="s1">],</span><span class="s3">\n</span><span class="s1">): number {</span><span class="s3">\n  </span><span class="s1">const range = ranges[index];</span><span class="s3">\n  </span><span class="s1">const {</span><span class="s3">\n    </span><span class="s1">0: startLine,</span><span class="s3">\n    </span><span class="s1">1: startColumn,</span><span class="s3">\n    </span><span class="s1">2: endLine,</span><span class="s3">\n    </span><span class="s1">3: endColumn,</span><span class="s3">\n    </span><span class="s1">isScope,</span><span class="s3">\n    </span><span class="s1">callsite,</span><span class="s3">\n    </span><span class="s1">bindings,</span><span class="s3">\n  </span><span class="s1">} = range;</span><span class="s3">\n\n  </span><span class="s1">if (state[0] &lt; startLine) {</span><span class="s3">\n    </span><span class="s1">catchupLine(writer, state[0], startLine);</span><span class="s3">\n    </span><span class="s1">state[0] = startLine;</span><span class="s3">\n    </span><span class="s1">state[1] = 0;</span><span class="s3">\n  </span><span class="s1">} else if (index &gt; 0) {</span><span class="s3">\n    </span><span class="s1">writer.write(comma);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">state[1] = encodeInteger(writer, range[1], state[1]);</span><span class="s3">\n\n  </span><span class="s1">const fields =</span><span class="s3">\n    </span><span class="s1">(range.length === 6 ? 0b0001 : 0) | (callsite ? 0b0010 : 0) | (isScope ? 0b0100 : 0);</span><span class="s3">\n  </span><span class="s1">encodeInteger(writer, fields, 0);</span><span class="s3">\n\n  </span><span class="s1">if (range.length === 6) {</span><span class="s3">\n    </span><span class="s1">const { 4: sourcesIndex, 5: scopesIndex } = range;</span><span class="s3">\n    </span><span class="s1">if (sourcesIndex !== state[2]) {</span><span class="s3">\n      </span><span class="s1">state[3] = 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">state[2] = encodeInteger(writer, sourcesIndex, state[2]);</span><span class="s3">\n    </span><span class="s1">state[3] = encodeInteger(writer, scopesIndex, state[3]);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (callsite) {</span><span class="s3">\n    </span><span class="s1">const { 0: sourcesIndex, 1: callLine, 2: callColumn } = range.callsite!;</span><span class="s3">\n    </span><span class="s1">if (sourcesIndex !== state[4]) {</span><span class="s3">\n      </span><span class="s1">state[5] = 0;</span><span class="s3">\n      </span><span class="s1">state[6] = 0;</span><span class="s3">\n    </span><span class="s1">} else if (callLine !== state[5]) {</span><span class="s3">\n      </span><span class="s1">state[6] = 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">state[4] = encodeInteger(writer, sourcesIndex, state[4]);</span><span class="s3">\n    </span><span class="s1">state[5] = encodeInteger(writer, callLine, state[5]);</span><span class="s3">\n    </span><span class="s1">state[6] = encodeInteger(writer, callColumn, state[6]);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (bindings) {</span><span class="s3">\n    </span><span class="s1">for (const binding of bindings) {</span><span class="s3">\n      </span><span class="s1">if (binding.length &gt; 1) encodeInteger(writer, -binding.length, 0);</span><span class="s3">\n      </span><span class="s1">const expression = binding[0][0];</span><span class="s3">\n      </span><span class="s1">encodeInteger(writer, expression, 0);</span><span class="s3">\n      </span><span class="s1">let bindingStartLine = startLine;</span><span class="s3">\n      </span><span class="s1">let bindingStartColumn = startColumn;</span><span class="s3">\n      </span><span class="s1">for (let i = 1; i &lt; binding.length; i++) {</span><span class="s3">\n        </span><span class="s1">const expRange = binding[i];</span><span class="s3">\n        </span><span class="s1">bindingStartLine = encodeInteger(writer, expRange[1]!, bindingStartLine);</span><span class="s3">\n        </span><span class="s1">bindingStartColumn = encodeInteger(writer, expRange[2]!, bindingStartColumn);</span><span class="s3">\n        </span><span class="s1">encodeInteger(writer, expRange[0]!, 0);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">for (index++; index &lt; ranges.length; ) {</span><span class="s3">\n    </span><span class="s1">const next = ranges[index];</span><span class="s3">\n    </span><span class="s1">const { 0: l, 1: c } = next;</span><span class="s3">\n    </span><span class="s1">if (l &gt; endLine || (l === endLine &amp;&amp; c &gt;= endColumn)) {</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">index = _encodeGeneratedRanges(ranges, index, writer, state);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (state[0] &lt; endLine) {</span><span class="s3">\n    </span><span class="s1">catchupLine(writer, state[0], endLine);</span><span class="s3">\n    </span><span class="s1">state[0] = endLine;</span><span class="s3">\n    </span><span class="s1">state[1] = 0;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">writer.write(comma);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">state[1] = encodeInteger(writer, endColumn, state[1]);</span><span class="s3">\n\n  </span><span class="s1">return index;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function catchupLine(writer: StringWriter, lastLine: number, line: number) {</span><span class="s3">\n  </span><span class="s1">do {</span><span class="s3">\n    </span><span class="s1">writer.write(semicolon);</span><span class="s3">\n  </span><span class="s1">} while (++lastLine &lt; line);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { comma, decodeInteger, encodeInteger, hasMoreVlq, semicolon } from './vlq';</span><span class="s3">\n</span><span class="s1">import { StringWriter, StringReader } from './strings';</span><span class="s3">\n\n</span><span class="s1">export {</span><span class="s3">\n  </span><span class="s1">decodeOriginalScopes,</span><span class="s3">\n  </span><span class="s1">encodeOriginalScopes,</span><span class="s3">\n  </span><span class="s1">decodeGeneratedRanges,</span><span class="s3">\n  </span><span class="s1">encodeGeneratedRanges,</span><span class="s3">\n</span><span class="s1">} from './scopes';</span><span class="s3">\n</span><span class="s1">export type { OriginalScope, GeneratedRange, CallSite, BindingExpressionRange } from './scopes';</span><span class="s3">\n\n</span><span class="s1">export type SourceMapSegment =</span><span class="s3">\n  </span><span class="s1">| [number]</span><span class="s3">\n  </span><span class="s1">| [number, number, number, number]</span><span class="s3">\n  </span><span class="s1">| [number, number, number, number, number];</span><span class="s3">\n</span><span class="s1">export type SourceMapLine = SourceMapSegment[];</span><span class="s3">\n</span><span class="s1">export type SourceMapMappings = SourceMapLine[];</span><span class="s3">\n\n</span><span class="s1">export function decode(mappings: string): SourceMapMappings {</span><span class="s3">\n  </span><span class="s1">const { length } = mappings;</span><span class="s3">\n  </span><span class="s1">const reader = new StringReader(mappings);</span><span class="s3">\n  </span><span class="s1">const decoded: SourceMapMappings = [];</span><span class="s3">\n  </span><span class="s1">let genColumn = 0;</span><span class="s3">\n  </span><span class="s1">let sourcesIndex = 0;</span><span class="s3">\n  </span><span class="s1">let sourceLine = 0;</span><span class="s3">\n  </span><span class="s1">let sourceColumn = 0;</span><span class="s3">\n  </span><span class="s1">let namesIndex = 0;</span><span class="s3">\n\n  </span><span class="s1">do {</span><span class="s3">\n    </span><span class="s1">const semi = reader.indexOf(';');</span><span class="s3">\n    </span><span class="s1">const line: SourceMapLine = [];</span><span class="s3">\n    </span><span class="s1">let sorted = true;</span><span class="s3">\n    </span><span class="s1">let lastCol = 0;</span><span class="s3">\n    </span><span class="s1">genColumn = 0;</span><span class="s3">\n\n    </span><span class="s1">while (reader.pos &lt; semi) {</span><span class="s3">\n      </span><span class="s1">let seg: SourceMapSegment;</span><span class="s3">\n\n      </span><span class="s1">genColumn = decodeInteger(reader, genColumn);</span><span class="s3">\n      </span><span class="s1">if (genColumn &lt; lastCol) sorted = false;</span><span class="s3">\n      </span><span class="s1">lastCol = genColumn;</span><span class="s3">\n\n      </span><span class="s1">if (hasMoreVlq(reader, semi)) {</span><span class="s3">\n        </span><span class="s1">sourcesIndex = decodeInteger(reader, sourcesIndex);</span><span class="s3">\n        </span><span class="s1">sourceLine = decodeInteger(reader, sourceLine);</span><span class="s3">\n        </span><span class="s1">sourceColumn = decodeInteger(reader, sourceColumn);</span><span class="s3">\n\n        </span><span class="s1">if (hasMoreVlq(reader, semi)) {</span><span class="s3">\n          </span><span class="s1">namesIndex = decodeInteger(reader, namesIndex);</span><span class="s3">\n          </span><span class="s1">seg = [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex];</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">seg = [genColumn, sourcesIndex, sourceLine, sourceColumn];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">seg = [genColumn];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">line.push(seg);</span><span class="s3">\n      </span><span class="s1">reader.pos++;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (!sorted) sort(line);</span><span class="s3">\n    </span><span class="s1">decoded.push(line);</span><span class="s3">\n    </span><span class="s1">reader.pos = semi + 1;</span><span class="s3">\n  </span><span class="s1">} while (reader.pos &lt;= length);</span><span class="s3">\n\n  </span><span class="s1">return decoded;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function sort(line: SourceMapSegment[]) {</span><span class="s3">\n  </span><span class="s1">line.sort(sortComparator);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function sortComparator(a: SourceMapSegment, b: SourceMapSegment): number {</span><span class="s3">\n  </span><span class="s1">return a[0] - b[0];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function encode(decoded: SourceMapMappings): string;</span><span class="s3">\n</span><span class="s1">export function encode(decoded: Readonly&lt;SourceMapMappings&gt;): string;</span><span class="s3">\n</span><span class="s1">export function encode(decoded: Readonly&lt;SourceMapMappings&gt;): string {</span><span class="s3">\n  </span><span class="s1">const writer = new StringWriter();</span><span class="s3">\n  </span><span class="s1">let sourcesIndex = 0;</span><span class="s3">\n  </span><span class="s1">let sourceLine = 0;</span><span class="s3">\n  </span><span class="s1">let sourceColumn = 0;</span><span class="s3">\n  </span><span class="s1">let namesIndex = 0;</span><span class="s3">\n\n  </span><span class="s1">for (let i = 0; i &lt; decoded.length; i++) {</span><span class="s3">\n    </span><span class="s1">const line = decoded[i];</span><span class="s3">\n    </span><span class="s1">if (i &gt; 0) writer.write(semicolon);</span><span class="s3">\n    </span><span class="s1">if (line.length === 0) continue;</span><span class="s3">\n\n    </span><span class="s1">let genColumn = 0;</span><span class="s3">\n\n    </span><span class="s1">for (let j = 0; j &lt; line.length; j++) {</span><span class="s3">\n      </span><span class="s1">const segment = line[j];</span><span class="s3">\n      </span><span class="s1">if (j &gt; 0) writer.write(comma);</span><span class="s3">\n\n      </span><span class="s1">genColumn = encodeInteger(writer, segment[0], genColumn);</span><span class="s3">\n\n      </span><span class="s1">if (segment.length === 1) continue;</span><span class="s3">\n      </span><span class="s1">sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex);</span><span class="s3">\n      </span><span class="s1">sourceLine = encodeInteger(writer, segment[2], sourceLine);</span><span class="s3">\n      </span><span class="s1">sourceColumn = encodeInteger(writer, segment[3], sourceColumn);</span><span class="s3">\n\n      </span><span class="s1">if (segment.length === 4) continue;</span><span class="s3">\n      </span><span class="s1">namesIndex = encodeInteger(writer, segment[4], namesIndex);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return writer.flush();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">}</span></pre>
</body>
</html>