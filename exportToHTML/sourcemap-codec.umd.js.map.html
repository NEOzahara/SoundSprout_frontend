<html>
<head>
<title>sourcemap-codec.umd.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
sourcemap-codec.umd.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;sourcemap-codec.umd.js&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../src/vlq.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;../src/strings.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;../src/scopes.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;../src/sourcemap-codec.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { StringReader, StringWriter } from './strings';</span><span class="s3">\n\n</span><span class="s1">export const comma = ','.charCodeAt(0);</span><span class="s3">\n</span><span class="s1">export const semicolon = ';'.charCodeAt(0);</span><span class="s3">\n\n</span><span class="s1">const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';</span><span class="s3">\n</span><span class="s1">const intToChar = new Uint8Array(64); // 64 possible chars.</span><span class="s3">\n</span><span class="s1">const charToInt = new Uint8Array(128); // z is 122 in ASCII</span><span class="s3">\n\n</span><span class="s1">for (let i = 0; i &lt; chars.length; i++) {</span><span class="s3">\n  </span><span class="s1">const c = chars.charCodeAt(i);</span><span class="s3">\n  </span><span class="s1">intToChar[i] = c;</span><span class="s3">\n  </span><span class="s1">charToInt[c] = i;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function decodeInteger(reader: StringReader, relative: number): number {</span><span class="s3">\n  </span><span class="s1">let value = 0;</span><span class="s3">\n  </span><span class="s1">let shift = 0;</span><span class="s3">\n  </span><span class="s1">let integer = 0;</span><span class="s3">\n\n  </span><span class="s1">do {</span><span class="s3">\n    </span><span class="s1">const c = reader.next();</span><span class="s3">\n    </span><span class="s1">integer = charToInt[c];</span><span class="s3">\n    </span><span class="s1">value |= (integer &amp; 31) &lt;&lt; shift;</span><span class="s3">\n    </span><span class="s1">shift += 5;</span><span class="s3">\n  </span><span class="s1">} while (integer &amp; 32);</span><span class="s3">\n\n  </span><span class="s1">const shouldNegate = value &amp; 1;</span><span class="s3">\n  </span><span class="s1">value &gt;&gt;&gt;= 1;</span><span class="s3">\n\n  </span><span class="s1">if (shouldNegate) {</span><span class="s3">\n    </span><span class="s1">value = -0x80000000 | -value;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return relative + value;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function encodeInteger(builder: StringWriter, num: number, relative: number): number {</span><span class="s3">\n  </span><span class="s1">let delta = num - relative;</span><span class="s3">\n\n  </span><span class="s1">delta = delta &lt; 0 ? (-delta &lt;&lt; 1) | 1 : delta &lt;&lt; 1;</span><span class="s3">\n  </span><span class="s1">do {</span><span class="s3">\n    </span><span class="s1">let clamped = delta &amp; 0b011111;</span><span class="s3">\n    </span><span class="s1">delta &gt;&gt;&gt;= 5;</span><span class="s3">\n    </span><span class="s1">if (delta &gt; 0) clamped |= 0b100000;</span><span class="s3">\n    </span><span class="s1">builder.write(intToChar[clamped]);</span><span class="s3">\n  </span><span class="s1">} while (delta &gt; 0);</span><span class="s3">\n\n  </span><span class="s1">return num;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function hasMoreVlq(reader: StringReader, max: number) {</span><span class="s3">\n  </span><span class="s1">if (reader.pos &gt;= max) return false;</span><span class="s3">\n  </span><span class="s1">return reader.peek() !== comma;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;const bufLength = 1024 * 16;</span><span class="s3">\n\n</span><span class="s1">// Provide a fallback for older environments.</span><span class="s3">\n</span><span class="s1">const td =</span><span class="s3">\n  </span><span class="s1">typeof TextDecoder !== 'undefined'</span><span class="s3">\n    </span><span class="s1">? /* #__PURE__ */ new TextDecoder()</span><span class="s3">\n    </span><span class="s1">: typeof Buffer !== 'undefined'</span><span class="s3">\n    </span><span class="s1">? {</span><span class="s3">\n        </span><span class="s1">decode(buf: Uint8Array): string {</span><span class="s3">\n          </span><span class="s1">const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);</span><span class="s3">\n          </span><span class="s1">return out.toString();</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">decode(buf: Uint8Array): string {</span><span class="s3">\n          </span><span class="s1">let out = '';</span><span class="s3">\n          </span><span class="s1">for (let i = 0; i &lt; buf.length; i++) {</span><span class="s3">\n            </span><span class="s1">out += String.fromCharCode(buf[i]);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">return out;</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export class StringWriter {</span><span class="s3">\n  </span><span class="s1">pos = 0;</span><span class="s3">\n  </span><span class="s1">private out = '';</span><span class="s3">\n  </span><span class="s1">private buffer = new Uint8Array(bufLength);</span><span class="s3">\n\n  </span><span class="s1">write(v: number): void {</span><span class="s3">\n    </span><span class="s1">const { buffer } = this;</span><span class="s3">\n    </span><span class="s1">buffer[this.pos++] = v;</span><span class="s3">\n    </span><span class="s1">if (this.pos === bufLength) {</span><span class="s3">\n      </span><span class="s1">this.out += td.decode(buffer);</span><span class="s3">\n      </span><span class="s1">this.pos = 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">flush(): string {</span><span class="s3">\n    </span><span class="s1">const { buffer, out, pos } = this;</span><span class="s3">\n    </span><span class="s1">return pos &gt; 0 ? out + td.decode(buffer.subarray(0, pos)) : out;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export class StringReader {</span><span class="s3">\n  </span><span class="s1">pos = 0;</span><span class="s3">\n  </span><span class="s1">private declare buffer: string;</span><span class="s3">\n\n  </span><span class="s1">constructor(buffer: string) {</span><span class="s3">\n    </span><span class="s1">this.buffer = buffer;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">next(): number {</span><span class="s3">\n    </span><span class="s1">return this.buffer.charCodeAt(this.pos++);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">peek(): number {</span><span class="s3">\n    </span><span class="s1">return this.buffer.charCodeAt(this.pos);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">indexOf(char: string): number {</span><span class="s3">\n    </span><span class="s1">const { buffer, pos } = this;</span><span class="s3">\n    </span><span class="s1">const idx = buffer.indexOf(char, pos);</span><span class="s3">\n    </span><span class="s1">return idx === -1 ? buffer.length : idx;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { StringReader, StringWriter } from './strings';</span><span class="s3">\n</span><span class="s1">import { comma, decodeInteger, encodeInteger, hasMoreVlq, semicolon } from './vlq';</span><span class="s3">\n\n</span><span class="s1">const EMPTY: any[] = [];</span><span class="s3">\n\n</span><span class="s1">type Line = number;</span><span class="s3">\n</span><span class="s1">type Column = number;</span><span class="s3">\n</span><span class="s1">type Kind = number;</span><span class="s3">\n</span><span class="s1">type Name = number;</span><span class="s3">\n</span><span class="s1">type Var = number;</span><span class="s3">\n</span><span class="s1">type SourcesIndex = number;</span><span class="s3">\n</span><span class="s1">type ScopesIndex = number;</span><span class="s3">\n\n</span><span class="s1">type Mix&lt;A, B, O&gt; = (A &amp; O) | (B &amp; O);</span><span class="s3">\n\n</span><span class="s1">export type OriginalScope = Mix&lt;</span><span class="s3">\n  </span><span class="s1">[Line, Column, Line, Column, Kind],</span><span class="s3">\n  </span><span class="s1">[Line, Column, Line, Column, Kind, Name],</span><span class="s3">\n  </span><span class="s1">{ vars: Var[] }</span><span class="s3">\n</span><span class="s1">&gt;;</span><span class="s3">\n\n</span><span class="s1">export type GeneratedRange = Mix&lt;</span><span class="s3">\n  </span><span class="s1">[Line, Column, Line, Column],</span><span class="s3">\n  </span><span class="s1">[Line, Column, Line, Column, SourcesIndex, ScopesIndex],</span><span class="s3">\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">callsite: CallSite | null;</span><span class="s3">\n    </span><span class="s1">bindings: Binding[];</span><span class="s3">\n    </span><span class="s1">isScope: boolean;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&gt;;</span><span class="s3">\n</span><span class="s1">export type CallSite = [SourcesIndex, Line, Column];</span><span class="s3">\n</span><span class="s1">type Binding = BindingExpressionRange[];</span><span class="s3">\n</span><span class="s1">export type BindingExpressionRange = [Name] | [Name, Line, Column];</span><span class="s3">\n\n</span><span class="s1">export function decodeOriginalScopes(input: string): OriginalScope[] {</span><span class="s3">\n  </span><span class="s1">const { length } = input;</span><span class="s3">\n  </span><span class="s1">const reader = new StringReader(input);</span><span class="s3">\n  </span><span class="s1">const scopes: OriginalScope[] = [];</span><span class="s3">\n  </span><span class="s1">const stack: OriginalScope[] = [];</span><span class="s3">\n  </span><span class="s1">let line = 0;</span><span class="s3">\n\n  </span><span class="s1">for (; reader.pos &lt; length; reader.pos++) {</span><span class="s3">\n    </span><span class="s1">line = decodeInteger(reader, line);</span><span class="s3">\n    </span><span class="s1">const column = decodeInteger(reader, 0);</span><span class="s3">\n\n    </span><span class="s1">if (!hasMoreVlq(reader, length)) {</span><span class="s3">\n      </span><span class="s1">const last = stack.pop()!;</span><span class="s3">\n      </span><span class="s1">last[2] = line;</span><span class="s3">\n      </span><span class="s1">last[3] = column;</span><span class="s3">\n      </span><span class="s1">continue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const kind = decodeInteger(reader, 0);</span><span class="s3">\n    </span><span class="s1">const fields = decodeInteger(reader, 0);</span><span class="s3">\n    </span><span class="s1">const hasName = fields &amp; 0b0001;</span><span class="s3">\n\n    </span><span class="s1">const scope: OriginalScope = (</span><span class="s3">\n      </span><span class="s1">hasName ? [line, column, 0, 0, kind, decodeInteger(reader, 0)] : [line, column, 0, 0, kind]</span><span class="s3">\n    </span><span class="s1">) as OriginalScope;</span><span class="s3">\n\n    </span><span class="s1">let vars: Var[] = EMPTY;</span><span class="s3">\n    </span><span class="s1">if (hasMoreVlq(reader, length)) {</span><span class="s3">\n      </span><span class="s1">vars = [];</span><span class="s3">\n      </span><span class="s1">do {</span><span class="s3">\n        </span><span class="s1">const varsIndex = decodeInteger(reader, 0);</span><span class="s3">\n        </span><span class="s1">vars.push(varsIndex);</span><span class="s3">\n      </span><span class="s1">} while (hasMoreVlq(reader, length));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">scope.vars = vars;</span><span class="s3">\n\n    </span><span class="s1">scopes.push(scope);</span><span class="s3">\n    </span><span class="s1">stack.push(scope);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return scopes;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function encodeOriginalScopes(scopes: OriginalScope[]): string {</span><span class="s3">\n  </span><span class="s1">const writer = new StringWriter();</span><span class="s3">\n\n  </span><span class="s1">for (let i = 0; i &lt; scopes.length; ) {</span><span class="s3">\n    </span><span class="s1">i = _encodeOriginalScopes(scopes, i, writer, [0]);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return writer.flush();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function _encodeOriginalScopes(</span><span class="s3">\n  </span><span class="s1">scopes: OriginalScope[],</span><span class="s3">\n  </span><span class="s1">index: number,</span><span class="s3">\n  </span><span class="s1">writer: StringWriter,</span><span class="s3">\n  </span><span class="s1">state: [</span><span class="s3">\n    </span><span class="s1">number, // GenColumn</span><span class="s3">\n  </span><span class="s1">],</span><span class="s3">\n</span><span class="s1">): number {</span><span class="s3">\n  </span><span class="s1">const scope = scopes[index];</span><span class="s3">\n  </span><span class="s1">const { 0: startLine, 1: startColumn, 2: endLine, 3: endColumn, 4: kind, vars } = scope;</span><span class="s3">\n\n  </span><span class="s1">if (index &gt; 0) writer.write(comma);</span><span class="s3">\n\n  </span><span class="s1">state[0] = encodeInteger(writer, startLine, state[0]);</span><span class="s3">\n  </span><span class="s1">encodeInteger(writer, startColumn, 0);</span><span class="s3">\n  </span><span class="s1">encodeInteger(writer, kind, 0);</span><span class="s3">\n\n  </span><span class="s1">const fields = scope.length === 6 ? 0b0001 : 0;</span><span class="s3">\n  </span><span class="s1">encodeInteger(writer, fields, 0);</span><span class="s3">\n  </span><span class="s1">if (scope.length === 6) encodeInteger(writer, scope[5], 0);</span><span class="s3">\n\n  </span><span class="s1">for (const v of vars) {</span><span class="s3">\n    </span><span class="s1">encodeInteger(writer, v, 0);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">for (index++; index &lt; scopes.length; ) {</span><span class="s3">\n    </span><span class="s1">const next = scopes[index];</span><span class="s3">\n    </span><span class="s1">const { 0: l, 1: c } = next;</span><span class="s3">\n    </span><span class="s1">if (l &gt; endLine || (l === endLine &amp;&amp; c &gt;= endColumn)) {</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">index = _encodeOriginalScopes(scopes, index, writer, state);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">writer.write(comma);</span><span class="s3">\n  </span><span class="s1">state[0] = encodeInteger(writer, endLine, state[0]);</span><span class="s3">\n  </span><span class="s1">encodeInteger(writer, endColumn, 0);</span><span class="s3">\n\n  </span><span class="s1">return index;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function decodeGeneratedRanges(input: string): GeneratedRange[] {</span><span class="s3">\n  </span><span class="s1">const { length } = input;</span><span class="s3">\n  </span><span class="s1">const reader = new StringReader(input);</span><span class="s3">\n  </span><span class="s1">const ranges: GeneratedRange[] = [];</span><span class="s3">\n  </span><span class="s1">const stack: GeneratedRange[] = [];</span><span class="s3">\n\n  </span><span class="s1">let genLine = 0;</span><span class="s3">\n  </span><span class="s1">let definitionSourcesIndex = 0;</span><span class="s3">\n  </span><span class="s1">let definitionScopeIndex = 0;</span><span class="s3">\n  </span><span class="s1">let callsiteSourcesIndex = 0;</span><span class="s3">\n  </span><span class="s1">let callsiteLine = 0;</span><span class="s3">\n  </span><span class="s1">let callsiteColumn = 0;</span><span class="s3">\n  </span><span class="s1">let bindingLine = 0;</span><span class="s3">\n  </span><span class="s1">let bindingColumn = 0;</span><span class="s3">\n\n  </span><span class="s1">do {</span><span class="s3">\n    </span><span class="s1">const semi = reader.indexOf(';');</span><span class="s3">\n    </span><span class="s1">let genColumn = 0;</span><span class="s3">\n\n    </span><span class="s1">for (; reader.pos &lt; semi; reader.pos++) {</span><span class="s3">\n      </span><span class="s1">genColumn = decodeInteger(reader, genColumn);</span><span class="s3">\n\n      </span><span class="s1">if (!hasMoreVlq(reader, semi)) {</span><span class="s3">\n        </span><span class="s1">const last = stack.pop()!;</span><span class="s3">\n        </span><span class="s1">last[2] = genLine;</span><span class="s3">\n        </span><span class="s1">last[3] = genColumn;</span><span class="s3">\n        </span><span class="s1">continue;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const fields = decodeInteger(reader, 0);</span><span class="s3">\n      </span><span class="s1">const hasDefinition = fields &amp; 0b0001;</span><span class="s3">\n      </span><span class="s1">const hasCallsite = fields &amp; 0b0010;</span><span class="s3">\n      </span><span class="s1">const hasScope = fields &amp; 0b0100;</span><span class="s3">\n\n      </span><span class="s1">let callsite: CallSite | null = null;</span><span class="s3">\n      </span><span class="s1">let bindings: Binding[] = EMPTY;</span><span class="s3">\n      </span><span class="s1">let range: GeneratedRange;</span><span class="s3">\n      </span><span class="s1">if (hasDefinition) {</span><span class="s3">\n        </span><span class="s1">const defSourcesIndex = decodeInteger(reader, definitionSourcesIndex);</span><span class="s3">\n        </span><span class="s1">definitionScopeIndex = decodeInteger(</span><span class="s3">\n          </span><span class="s1">reader,</span><span class="s3">\n          </span><span class="s1">definitionSourcesIndex === defSourcesIndex ? definitionScopeIndex : 0,</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n\n        </span><span class="s1">definitionSourcesIndex = defSourcesIndex;</span><span class="s3">\n        </span><span class="s1">range = [genLine, genColumn, 0, 0, defSourcesIndex, definitionScopeIndex] as GeneratedRange;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">range = [genLine, genColumn, 0, 0] as GeneratedRange;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">range.isScope = !!hasScope;</span><span class="s3">\n\n      </span><span class="s1">if (hasCallsite) {</span><span class="s3">\n        </span><span class="s1">const prevCsi = callsiteSourcesIndex;</span><span class="s3">\n        </span><span class="s1">const prevLine = callsiteLine;</span><span class="s3">\n        </span><span class="s1">callsiteSourcesIndex = decodeInteger(reader, callsiteSourcesIndex);</span><span class="s3">\n        </span><span class="s1">const sameSource = prevCsi === callsiteSourcesIndex;</span><span class="s3">\n        </span><span class="s1">callsiteLine = decodeInteger(reader, sameSource ? callsiteLine : 0);</span><span class="s3">\n        </span><span class="s1">callsiteColumn = decodeInteger(</span><span class="s3">\n          </span><span class="s1">reader,</span><span class="s3">\n          </span><span class="s1">sameSource &amp;&amp; prevLine === callsiteLine ? callsiteColumn : 0,</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n\n        </span><span class="s1">callsite = [callsiteSourcesIndex, callsiteLine, callsiteColumn];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">range.callsite = callsite;</span><span class="s3">\n\n      </span><span class="s1">if (hasMoreVlq(reader, semi)) {</span><span class="s3">\n        </span><span class="s1">bindings = [];</span><span class="s3">\n        </span><span class="s1">do {</span><span class="s3">\n          </span><span class="s1">bindingLine = genLine;</span><span class="s3">\n          </span><span class="s1">bindingColumn = genColumn;</span><span class="s3">\n          </span><span class="s1">const expressionsCount = decodeInteger(reader, 0);</span><span class="s3">\n          </span><span class="s1">let expressionRanges: BindingExpressionRange[];</span><span class="s3">\n          </span><span class="s1">if (expressionsCount &lt; -1) {</span><span class="s3">\n            </span><span class="s1">expressionRanges = [[decodeInteger(reader, 0)]];</span><span class="s3">\n            </span><span class="s1">for (let i = -1; i &gt; expressionsCount; i--) {</span><span class="s3">\n              </span><span class="s1">const prevBl = bindingLine;</span><span class="s3">\n              </span><span class="s1">bindingLine = decodeInteger(reader, bindingLine);</span><span class="s3">\n              </span><span class="s1">bindingColumn = decodeInteger(reader, bindingLine === prevBl ? bindingColumn : 0);</span><span class="s3">\n              </span><span class="s1">const expression = decodeInteger(reader, 0);</span><span class="s3">\n              </span><span class="s1">expressionRanges.push([expression, bindingLine, bindingColumn]);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">expressionRanges = [[expressionsCount]];</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">bindings.push(expressionRanges);</span><span class="s3">\n        </span><span class="s1">} while (hasMoreVlq(reader, semi));</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">range.bindings = bindings;</span><span class="s3">\n\n      </span><span class="s1">ranges.push(range);</span><span class="s3">\n      </span><span class="s1">stack.push(range);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">genLine++;</span><span class="s3">\n    </span><span class="s1">reader.pos = semi + 1;</span><span class="s3">\n  </span><span class="s1">} while (reader.pos &lt; length);</span><span class="s3">\n\n  </span><span class="s1">return ranges;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function encodeGeneratedRanges(ranges: GeneratedRange[]): string {</span><span class="s3">\n  </span><span class="s1">if (ranges.length === 0) return '';</span><span class="s3">\n\n  </span><span class="s1">const writer = new StringWriter();</span><span class="s3">\n\n  </span><span class="s1">for (let i = 0; i &lt; ranges.length; ) {</span><span class="s3">\n    </span><span class="s1">i = _encodeGeneratedRanges(ranges, i, writer, [0, 0, 0, 0, 0, 0, 0]);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return writer.flush();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function _encodeGeneratedRanges(</span><span class="s3">\n  </span><span class="s1">ranges: GeneratedRange[],</span><span class="s3">\n  </span><span class="s1">index: number,</span><span class="s3">\n  </span><span class="s1">writer: StringWriter,</span><span class="s3">\n  </span><span class="s1">state: [</span><span class="s3">\n    </span><span class="s1">number, // GenLine</span><span class="s3">\n    </span><span class="s1">number, // GenColumn</span><span class="s3">\n    </span><span class="s1">number, // DefSourcesIndex</span><span class="s3">\n    </span><span class="s1">number, // DefScopesIndex</span><span class="s3">\n    </span><span class="s1">number, // CallSourcesIndex</span><span class="s3">\n    </span><span class="s1">number, // CallLine</span><span class="s3">\n    </span><span class="s1">number, // CallColumn</span><span class="s3">\n  </span><span class="s1">],</span><span class="s3">\n</span><span class="s1">): number {</span><span class="s3">\n  </span><span class="s1">const range = ranges[index];</span><span class="s3">\n  </span><span class="s1">const {</span><span class="s3">\n    </span><span class="s1">0: startLine,</span><span class="s3">\n    </span><span class="s1">1: startColumn,</span><span class="s3">\n    </span><span class="s1">2: endLine,</span><span class="s3">\n    </span><span class="s1">3: endColumn,</span><span class="s3">\n    </span><span class="s1">isScope,</span><span class="s3">\n    </span><span class="s1">callsite,</span><span class="s3">\n    </span><span class="s1">bindings,</span><span class="s3">\n  </span><span class="s1">} = range;</span><span class="s3">\n\n  </span><span class="s1">if (state[0] &lt; startLine) {</span><span class="s3">\n    </span><span class="s1">catchupLine(writer, state[0], startLine);</span><span class="s3">\n    </span><span class="s1">state[0] = startLine;</span><span class="s3">\n    </span><span class="s1">state[1] = 0;</span><span class="s3">\n  </span><span class="s1">} else if (index &gt; 0) {</span><span class="s3">\n    </span><span class="s1">writer.write(comma);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">state[1] = encodeInteger(writer, range[1], state[1]);</span><span class="s3">\n\n  </span><span class="s1">const fields =</span><span class="s3">\n    </span><span class="s1">(range.length === 6 ? 0b0001 : 0) | (callsite ? 0b0010 : 0) | (isScope ? 0b0100 : 0);</span><span class="s3">\n  </span><span class="s1">encodeInteger(writer, fields, 0);</span><span class="s3">\n\n  </span><span class="s1">if (range.length === 6) {</span><span class="s3">\n    </span><span class="s1">const { 4: sourcesIndex, 5: scopesIndex } = range;</span><span class="s3">\n    </span><span class="s1">if (sourcesIndex !== state[2]) {</span><span class="s3">\n      </span><span class="s1">state[3] = 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">state[2] = encodeInteger(writer, sourcesIndex, state[2]);</span><span class="s3">\n    </span><span class="s1">state[3] = encodeInteger(writer, scopesIndex, state[3]);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (callsite) {</span><span class="s3">\n    </span><span class="s1">const { 0: sourcesIndex, 1: callLine, 2: callColumn } = range.callsite!;</span><span class="s3">\n    </span><span class="s1">if (sourcesIndex !== state[4]) {</span><span class="s3">\n      </span><span class="s1">state[5] = 0;</span><span class="s3">\n      </span><span class="s1">state[6] = 0;</span><span class="s3">\n    </span><span class="s1">} else if (callLine !== state[5]) {</span><span class="s3">\n      </span><span class="s1">state[6] = 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">state[4] = encodeInteger(writer, sourcesIndex, state[4]);</span><span class="s3">\n    </span><span class="s1">state[5] = encodeInteger(writer, callLine, state[5]);</span><span class="s3">\n    </span><span class="s1">state[6] = encodeInteger(writer, callColumn, state[6]);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (bindings) {</span><span class="s3">\n    </span><span class="s1">for (const binding of bindings) {</span><span class="s3">\n      </span><span class="s1">if (binding.length &gt; 1) encodeInteger(writer, -binding.length, 0);</span><span class="s3">\n      </span><span class="s1">const expression = binding[0][0];</span><span class="s3">\n      </span><span class="s1">encodeInteger(writer, expression, 0);</span><span class="s3">\n      </span><span class="s1">let bindingStartLine = startLine;</span><span class="s3">\n      </span><span class="s1">let bindingStartColumn = startColumn;</span><span class="s3">\n      </span><span class="s1">for (let i = 1; i &lt; binding.length; i++) {</span><span class="s3">\n        </span><span class="s1">const expRange = binding[i];</span><span class="s3">\n        </span><span class="s1">bindingStartLine = encodeInteger(writer, expRange[1]!, bindingStartLine);</span><span class="s3">\n        </span><span class="s1">bindingStartColumn = encodeInteger(writer, expRange[2]!, bindingStartColumn);</span><span class="s3">\n        </span><span class="s1">encodeInteger(writer, expRange[0]!, 0);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">for (index++; index &lt; ranges.length; ) {</span><span class="s3">\n    </span><span class="s1">const next = ranges[index];</span><span class="s3">\n    </span><span class="s1">const { 0: l, 1: c } = next;</span><span class="s3">\n    </span><span class="s1">if (l &gt; endLine || (l === endLine &amp;&amp; c &gt;= endColumn)) {</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">index = _encodeGeneratedRanges(ranges, index, writer, state);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (state[0] &lt; endLine) {</span><span class="s3">\n    </span><span class="s1">catchupLine(writer, state[0], endLine);</span><span class="s3">\n    </span><span class="s1">state[0] = endLine;</span><span class="s3">\n    </span><span class="s1">state[1] = 0;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">writer.write(comma);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">state[1] = encodeInteger(writer, endColumn, state[1]);</span><span class="s3">\n\n  </span><span class="s1">return index;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function catchupLine(writer: StringWriter, lastLine: number, line: number) {</span><span class="s3">\n  </span><span class="s1">do {</span><span class="s3">\n    </span><span class="s1">writer.write(semicolon);</span><span class="s3">\n  </span><span class="s1">} while (++lastLine &lt; line);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { comma, decodeInteger, encodeInteger, hasMoreVlq, semicolon } from './vlq';</span><span class="s3">\n</span><span class="s1">import { StringWriter, StringReader } from './strings';</span><span class="s3">\n\n</span><span class="s1">export {</span><span class="s3">\n  </span><span class="s1">decodeOriginalScopes,</span><span class="s3">\n  </span><span class="s1">encodeOriginalScopes,</span><span class="s3">\n  </span><span class="s1">decodeGeneratedRanges,</span><span class="s3">\n  </span><span class="s1">encodeGeneratedRanges,</span><span class="s3">\n</span><span class="s1">} from './scopes';</span><span class="s3">\n</span><span class="s1">export type { OriginalScope, GeneratedRange, CallSite, BindingExpressionRange } from './scopes';</span><span class="s3">\n\n</span><span class="s1">export type SourceMapSegment =</span><span class="s3">\n  </span><span class="s1">| [number]</span><span class="s3">\n  </span><span class="s1">| [number, number, number, number]</span><span class="s3">\n  </span><span class="s1">| [number, number, number, number, number];</span><span class="s3">\n</span><span class="s1">export type SourceMapLine = SourceMapSegment[];</span><span class="s3">\n</span><span class="s1">export type SourceMapMappings = SourceMapLine[];</span><span class="s3">\n\n</span><span class="s1">export function decode(mappings: string): SourceMapMappings {</span><span class="s3">\n  </span><span class="s1">const { length } = mappings;</span><span class="s3">\n  </span><span class="s1">const reader = new StringReader(mappings);</span><span class="s3">\n  </span><span class="s1">const decoded: SourceMapMappings = [];</span><span class="s3">\n  </span><span class="s1">let genColumn = 0;</span><span class="s3">\n  </span><span class="s1">let sourcesIndex = 0;</span><span class="s3">\n  </span><span class="s1">let sourceLine = 0;</span><span class="s3">\n  </span><span class="s1">let sourceColumn = 0;</span><span class="s3">\n  </span><span class="s1">let namesIndex = 0;</span><span class="s3">\n\n  </span><span class="s1">do {</span><span class="s3">\n    </span><span class="s1">const semi = reader.indexOf(';');</span><span class="s3">\n    </span><span class="s1">const line: SourceMapLine = [];</span><span class="s3">\n    </span><span class="s1">let sorted = true;</span><span class="s3">\n    </span><span class="s1">let lastCol = 0;</span><span class="s3">\n    </span><span class="s1">genColumn = 0;</span><span class="s3">\n\n    </span><span class="s1">while (reader.pos &lt; semi) {</span><span class="s3">\n      </span><span class="s1">let seg: SourceMapSegment;</span><span class="s3">\n\n      </span><span class="s1">genColumn = decodeInteger(reader, genColumn);</span><span class="s3">\n      </span><span class="s1">if (genColumn &lt; lastCol) sorted = false;</span><span class="s3">\n      </span><span class="s1">lastCol = genColumn;</span><span class="s3">\n\n      </span><span class="s1">if (hasMoreVlq(reader, semi)) {</span><span class="s3">\n        </span><span class="s1">sourcesIndex = decodeInteger(reader, sourcesIndex);</span><span class="s3">\n        </span><span class="s1">sourceLine = decodeInteger(reader, sourceLine);</span><span class="s3">\n        </span><span class="s1">sourceColumn = decodeInteger(reader, sourceColumn);</span><span class="s3">\n\n        </span><span class="s1">if (hasMoreVlq(reader, semi)) {</span><span class="s3">\n          </span><span class="s1">namesIndex = decodeInteger(reader, namesIndex);</span><span class="s3">\n          </span><span class="s1">seg = [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex];</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">seg = [genColumn, sourcesIndex, sourceLine, sourceColumn];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">seg = [genColumn];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">line.push(seg);</span><span class="s3">\n      </span><span class="s1">reader.pos++;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (!sorted) sort(line);</span><span class="s3">\n    </span><span class="s1">decoded.push(line);</span><span class="s3">\n    </span><span class="s1">reader.pos = semi + 1;</span><span class="s3">\n  </span><span class="s1">} while (reader.pos &lt;= length);</span><span class="s3">\n\n  </span><span class="s1">return decoded;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function sort(line: SourceMapSegment[]) {</span><span class="s3">\n  </span><span class="s1">line.sort(sortComparator);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function sortComparator(a: SourceMapSegment, b: SourceMapSegment): number {</span><span class="s3">\n  </span><span class="s1">return a[0] - b[0];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function encode(decoded: SourceMapMappings): string;</span><span class="s3">\n</span><span class="s1">export function encode(decoded: Readonly&lt;SourceMapMappings&gt;): string;</span><span class="s3">\n</span><span class="s1">export function encode(decoded: Readonly&lt;SourceMapMappings&gt;): string {</span><span class="s3">\n  </span><span class="s1">const writer = new StringWriter();</span><span class="s3">\n  </span><span class="s1">let sourcesIndex = 0;</span><span class="s3">\n  </span><span class="s1">let sourceLine = 0;</span><span class="s3">\n  </span><span class="s1">let sourceColumn = 0;</span><span class="s3">\n  </span><span class="s1">let namesIndex = 0;</span><span class="s3">\n\n  </span><span class="s1">for (let i = 0; i &lt; decoded.length; i++) {</span><span class="s3">\n    </span><span class="s1">const line = decoded[i];</span><span class="s3">\n    </span><span class="s1">if (i &gt; 0) writer.write(semicolon);</span><span class="s3">\n    </span><span class="s1">if (line.length === 0) continue;</span><span class="s3">\n\n    </span><span class="s1">let genColumn = 0;</span><span class="s3">\n\n    </span><span class="s1">for (let j = 0; j &lt; line.length; j++) {</span><span class="s3">\n      </span><span class="s1">const segment = line[j];</span><span class="s3">\n      </span><span class="s1">if (j &gt; 0) writer.write(comma);</span><span class="s3">\n\n      </span><span class="s1">genColumn = encodeInteger(writer, segment[0], genColumn);</span><span class="s3">\n\n      </span><span class="s1">if (segment.length === 1) continue;</span><span class="s3">\n      </span><span class="s1">sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex);</span><span class="s3">\n      </span><span class="s1">sourceLine = encodeInteger(writer, segment[2], sourceLine);</span><span class="s3">\n      </span><span class="s1">sourceColumn = encodeInteger(writer, segment[3], sourceColumn);</span><span class="s3">\n\n      </span><span class="s1">if (segment.length === 4) continue;</span><span class="s3">\n      </span><span class="s1">namesIndex = encodeInteger(writer, segment[4], namesIndex);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return writer.flush();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">}</span></pre>
</body>
</html>