<html>
<head>
<title>statement.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #6aab73;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #cf8e6d;}
.s4 { color: #7a7e85;}
.s5 { color: #2aacb8;}
.s6 { color: #5f826b; font-style: italic;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
statement.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span><span class="s2">Object</span><span class="s1">.</span><span class="s2">defineProperty</span><span class="s1">(</span><span class="s2">exports</span><span class="s1">, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span><span class="s2">value</span><span class="s1">: </span><span class="s3">true</span><span class="s1">});</span><span class="s4">/* eslint max-len: 0 */</span>

<span class="s3">var </span><span class="s2">_index </span><span class="s1">= </span><span class="s2">require</span><span class="s1">(</span><span class="s0">'../index'</span><span class="s1">);</span>
















<span class="s3">var </span><span class="s2">_flow </span><span class="s1">= </span><span class="s2">require</span><span class="s1">(</span><span class="s0">'../plugins/flow'</span><span class="s1">);</span>


















<span class="s3">var </span><span class="s2">_typescript </span><span class="s1">= </span><span class="s2">require</span><span class="s1">(</span><span class="s0">'../plugins/typescript'</span><span class="s1">);</span>












<span class="s3">var </span><span class="s2">_tokenizer </span><span class="s1">= </span><span class="s2">require</span><span class="s1">(</span><span class="s0">'../tokenizer'</span><span class="s1">);</span>
<span class="s3">var </span><span class="s2">_keywords </span><span class="s1">= </span><span class="s2">require</span><span class="s1">(</span><span class="s0">'../tokenizer/keywords'</span><span class="s1">);</span>
<span class="s3">var </span><span class="s2">_state </span><span class="s1">= </span><span class="s2">require</span><span class="s1">(</span><span class="s0">'../tokenizer/state'</span><span class="s1">);</span>
<span class="s3">var </span><span class="s2">_types </span><span class="s1">= </span><span class="s2">require</span><span class="s1">(</span><span class="s0">'../tokenizer/types'</span><span class="s1">);</span>
<span class="s3">var </span><span class="s2">_charcodes </span><span class="s1">= </span><span class="s2">require</span><span class="s1">(</span><span class="s0">'../util/charcodes'</span><span class="s1">);</span>
<span class="s3">var </span><span class="s2">_base </span><span class="s1">= </span><span class="s2">require</span><span class="s1">(</span><span class="s0">'./base'</span><span class="s1">);</span>












<span class="s3">var </span><span class="s2">_expression </span><span class="s1">= </span><span class="s2">require</span><span class="s1">(</span><span class="s0">'./expression'</span><span class="s1">);</span>





<span class="s3">var </span><span class="s2">_lval </span><span class="s1">= </span><span class="s2">require</span><span class="s1">(</span><span class="s0">'./lval'</span><span class="s1">);</span>












<span class="s3">var </span><span class="s2">_util </span><span class="s1">= </span><span class="s2">require</span><span class="s1">(</span><span class="s0">'./util'</span><span class="s1">);</span>

 <span class="s3">function </span><span class="s2">parseTopLevel</span><span class="s1">() {</span>
  <span class="s2">parseBlockBody</span><span class="s1">(</span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">eof</span><span class="s1">);</span>
  <span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">scopes</span><span class="s1">.</span><span class="s2">push</span><span class="s1">(</span><span class="s3">new </span><span class="s1">(</span><span class="s5">0</span><span class="s1">, </span><span class="s2">_state</span><span class="s1">.</span><span class="s2">Scope</span><span class="s1">)(</span><span class="s5">0</span><span class="s1">, </span><span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">length</span><span class="s1">, </span><span class="s3">true</span><span class="s1">));</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">scopeDepth </span><span class="s1">!== </span><span class="s5">0</span><span class="s1">) {</span>
    <span class="s3">throw new </span><span class="s2">Error</span><span class="s1">(</span><span class="s0">`Invalid scope depth at end of file: </span><span class="s2">$</span><span class="s1">{</span><span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">scopeDepth</span><span class="s1">}</span><span class="s0">`</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s3">return new </span><span class="s1">(</span><span class="s5">0</span><span class="s1">, </span><span class="s2">_index</span><span class="s1">.</span><span class="s2">File</span><span class="s1">)(</span><span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">, </span><span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">scopes</span><span class="s1">);</span>
<span class="s1">} </span><span class="s2">exports</span><span class="s1">.</span><span class="s2">parseTopLevel </span><span class="s1">= </span><span class="s2">parseTopLevel</span><span class="s1">;</span>

<span class="s4">// Parse a single statement.</span>
<span class="s4">//</span>
<span class="s4">// If expecting a statement and finding a slash operator, parse a</span>
<span class="s4">// regular expression literal. This is to handle cases like</span>
<span class="s4">// `if (foo) /blah/.exec(foo)`, where looking at the previous token</span>
<span class="s4">// does not help.</span>

 <span class="s3">function </span><span class="s2">parseStatement</span><span class="s1">(</span><span class="s2">declaration</span><span class="s1">) {</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">_base</span><span class="s1">.</span><span class="s2">isFlowEnabled</span><span class="s1">) {</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s2">_flow</span><span class="s1">.</span><span class="s2">flowTryParseStatement</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, )) {</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">match</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">at</span><span class="s1">)) {</span>
    <span class="s2">parseDecorators</span><span class="s1">();</span>
  <span class="s1">}</span>
  <span class="s2">parseStatementContent</span><span class="s1">(</span><span class="s2">declaration</span><span class="s1">);</span>
<span class="s1">} </span><span class="s2">exports</span><span class="s1">.</span><span class="s2">parseStatement </span><span class="s1">= </span><span class="s2">parseStatement</span><span class="s1">;</span>

<span class="s3">function </span><span class="s2">parseStatementContent</span><span class="s1">(</span><span class="s2">declaration</span><span class="s1">) {</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">_base</span><span class="s1">.</span><span class="s2">isTypeScriptEnabled</span><span class="s1">) {</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s2">_typescript</span><span class="s1">.</span><span class="s2">tsTryParseStatementContent</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, )) {</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">const </span><span class="s2">starttype </span><span class="s1">= </span><span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">type</span><span class="s1">;</span>

  <span class="s4">// Most types of statements are recognized by the keyword they</span>
  <span class="s4">// start with. Many are trivial to parse, some require a bit of</span>
  <span class="s4">// complexity.</span>

  <span class="s3">switch </span><span class="s1">(</span><span class="s2">starttype</span><span class="s1">) {</span>
    <span class="s3">case </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_break</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_continue</span><span class="s1">:</span>
      <span class="s2">parseBreakContinueStatement</span><span class="s1">();</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_debugger</span><span class="s1">:</span>
      <span class="s2">parseDebuggerStatement</span><span class="s1">();</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_do</span><span class="s1">:</span>
      <span class="s2">parseDoStatement</span><span class="s1">();</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_for</span><span class="s1">:</span>
      <span class="s2">parseForStatement</span><span class="s1">();</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_function</span><span class="s1">:</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">lookaheadType</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, ) === </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">dot</span><span class="s1">) </span><span class="s3">break</span><span class="s1">;</span>
      <span class="s3">if </span><span class="s1">(!</span><span class="s2">declaration</span><span class="s1">) </span><span class="s2">_util</span><span class="s1">.</span><span class="s2">unexpected</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
      <span class="s2">parseFunctionStatement</span><span class="s1">();</span>
      <span class="s3">return</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_class</span><span class="s1">:</span>
      <span class="s3">if </span><span class="s1">(!</span><span class="s2">declaration</span><span class="s1">) </span><span class="s2">_util</span><span class="s1">.</span><span class="s2">unexpected</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
      <span class="s2">parseClass</span><span class="s1">(</span><span class="s3">true</span><span class="s1">);</span>
      <span class="s3">return</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_if</span><span class="s1">:</span>
      <span class="s2">parseIfStatement</span><span class="s1">();</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_return</span><span class="s1">:</span>
      <span class="s2">parseReturnStatement</span><span class="s1">();</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_switch</span><span class="s1">:</span>
      <span class="s2">parseSwitchStatement</span><span class="s1">();</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_throw</span><span class="s1">:</span>
      <span class="s2">parseThrowStatement</span><span class="s1">();</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_try</span><span class="s1">:</span>
      <span class="s2">parseTryStatement</span><span class="s1">();</span>
      <span class="s3">return</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_let</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_const</span><span class="s1">:</span>
      <span class="s3">if </span><span class="s1">(!</span><span class="s2">declaration</span><span class="s1">) </span><span class="s2">_util</span><span class="s1">.</span><span class="s2">unexpected</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, ); </span><span class="s4">// NOTE: falls through to _var</span>

    <span class="s3">case </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_var</span><span class="s1">:</span>
      <span class="s2">parseVarStatement</span><span class="s1">(</span><span class="s2">starttype </span><span class="s1">!== </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_var</span><span class="s1">);</span>
      <span class="s3">return</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_while</span><span class="s1">:</span>
      <span class="s2">parseWhileStatement</span><span class="s1">();</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">braceL</span><span class="s1">:</span>
      <span class="s2">parseBlock</span><span class="s1">();</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">semi</span><span class="s1">:</span>
      <span class="s2">parseEmptyStatement</span><span class="s1">();</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s3">case </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_export</span><span class="s1">:</span>
    <span class="s3">case </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_import</span><span class="s1">: {</span>
      <span class="s3">const </span><span class="s2">nextType </span><span class="s1">= </span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">lookaheadType</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s2">nextType </span><span class="s1">=== </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">parenL </span><span class="s1">|| </span><span class="s2">nextType </span><span class="s1">=== </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">dot</span><span class="s1">) {</span>
        <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">next</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s2">starttype </span><span class="s1">=== </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_import</span><span class="s1">) {</span>
        <span class="s2">parseImport</span><span class="s1">();</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s2">parseExport</span><span class="s1">();</span>
      <span class="s1">}</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">case </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">name</span><span class="s1">:</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">contextualKeyword </span><span class="s1">=== </span><span class="s2">_keywords</span><span class="s1">.</span><span class="s2">ContextualKeyword</span><span class="s1">.</span><span class="s2">_async</span><span class="s1">) {</span>
        <span class="s3">const </span><span class="s2">functionStart </span><span class="s1">= </span><span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">start</span><span class="s1">;</span>
        <span class="s4">// peek ahead and see if next token is a function</span>
        <span class="s3">const </span><span class="s2">snapshot </span><span class="s1">= </span><span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">snapshot</span><span class="s1">();</span>
        <span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">next</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">match</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_function</span><span class="s1">) &amp;&amp; !</span><span class="s2">_util</span><span class="s1">.</span><span class="s2">canInsertSemicolon</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, )) {</span>
          <span class="s2">_util</span><span class="s1">.</span><span class="s2">expect</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_function</span><span class="s1">);</span>
          <span class="s2">parseFunction</span><span class="s1">(</span><span class="s2">functionStart</span><span class="s1">, </span><span class="s3">true</span><span class="s1">);</span>
          <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">restoreFromSnapshot</span><span class="s1">(</span><span class="s2">snapshot</span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span>
        <span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">contextualKeyword </span><span class="s1">=== </span><span class="s2">_keywords</span><span class="s1">.</span><span class="s2">ContextualKeyword</span><span class="s1">.</span><span class="s2">_using </span><span class="s1">&amp;&amp;</span>
        <span class="s1">!</span><span class="s2">_util</span><span class="s1">.</span><span class="s2">hasFollowingLineBreak</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, ) &amp;&amp;</span>
        <span class="s4">// Statements like `using[0]` and `using in foo` aren't actual using</span>
        <span class="s4">// declarations.</span>
        <span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">lookaheadType</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, ) === </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">name</span>
      <span class="s1">) {</span>
        <span class="s2">parseVarStatement</span><span class="s1">(</span><span class="s3">true</span><span class="s1">);</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s2">startsAwaitUsing</span><span class="s1">()) {</span>
        <span class="s2">_util</span><span class="s1">.</span><span class="s2">expectContextual</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_keywords</span><span class="s1">.</span><span class="s2">ContextualKeyword</span><span class="s1">.</span><span class="s2">_await</span><span class="s1">);</span>
        <span class="s2">parseVarStatement</span><span class="s1">(</span><span class="s3">true</span><span class="s1">);</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s3">default</span><span class="s1">:</span>
      <span class="s4">// Do nothing.</span>
      <span class="s3">break</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s4">// If the statement does not start with a statement keyword or a</span>
  <span class="s4">// brace, it's an ExpressionStatement or LabeledStatement. We</span>
  <span class="s4">// simply start parsing an expression, and afterwards, if the</span>
  <span class="s4">// next token is a colon and the expression was a simple</span>
  <span class="s4">// Identifier node, we switch to interpreting it as a label.</span>
  <span class="s3">const </span><span class="s2">initialTokensLength </span><span class="s1">= </span><span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">length</span><span class="s1">;</span>
  <span class="s2">_expression</span><span class="s1">.</span><span class="s2">parseExpression</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
  <span class="s3">let </span><span class="s2">simpleName </span><span class="s1">= </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">length </span><span class="s1">=== </span><span class="s2">initialTokensLength </span><span class="s1">+ </span><span class="s5">1</span><span class="s1">) {</span>
    <span class="s3">const </span><span class="s2">token </span><span class="s1">= </span><span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">[</span><span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">length </span><span class="s1">- </span><span class="s5">1</span><span class="s1">];</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s2">token</span><span class="s1">.</span><span class="s2">type </span><span class="s1">=== </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">name</span><span class="s1">) {</span>
      <span class="s2">simpleName </span><span class="s1">= </span><span class="s2">token</span><span class="s1">.</span><span class="s2">contextualKeyword</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">simpleName </span><span class="s1">== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s2">_util</span><span class="s1">.</span><span class="s2">semicolon</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
    <span class="s3">return</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">eat</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">colon</span><span class="s1">)) {</span>
    <span class="s2">parseLabeledStatement</span><span class="s1">();</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s4">// This was an identifier, so we might want to handle flow/typescript-specific cases.</span>
    <span class="s2">parseIdentifierStatement</span><span class="s1">(</span><span class="s2">simpleName</span><span class="s1">);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s6">/**</span>
 <span class="s6">* Determine if we're positioned at an `await using` declaration.</span>
 <span class="s6">*</span>
 <span class="s6">* Note that this can happen either in place of a regular variable declaration</span>
 <span class="s6">* or in a loop body, and in both places, there are similar-looking cases where</span>
 <span class="s6">* we need to return false.</span>
 <span class="s6">*</span>
 <span class="s6">* Examples returning true:</span>
 <span class="s6">* await using foo = bar();</span>
 <span class="s6">* for (await using a of b) {}</span>
 <span class="s6">*</span>
 <span class="s6">* Examples returning false:</span>
 <span class="s6">* await using</span>
 <span class="s6">* await using + 1</span>
 <span class="s6">* await using instanceof T</span>
 <span class="s6">* for (await using;;) {}</span>
 <span class="s6">*</span>
 <span class="s6">* For now, we early return if we don't see `await`, then do a simple</span>
 <span class="s6">* backtracking-based lookahead for the `using` and identifier tokens. In the</span>
 <span class="s6">* future, this could be optimized with a character-based approach.</span>
 <span class="s6">*/</span>
<span class="s3">function </span><span class="s2">startsAwaitUsing</span><span class="s1">() {</span>
  <span class="s3">if </span><span class="s1">(!</span><span class="s2">_util</span><span class="s1">.</span><span class="s2">isContextual</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_keywords</span><span class="s1">.</span><span class="s2">ContextualKeyword</span><span class="s1">.</span><span class="s2">_await</span><span class="s1">)) {</span>
    <span class="s3">return false</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">const </span><span class="s2">snapshot </span><span class="s1">= </span><span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">snapshot</span><span class="s1">();</span>
  <span class="s4">// await</span>
  <span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">next</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
  <span class="s3">if </span><span class="s1">(!</span><span class="s2">_util</span><span class="s1">.</span><span class="s2">isContextual</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_keywords</span><span class="s1">.</span><span class="s2">ContextualKeyword</span><span class="s1">.</span><span class="s2">_using</span><span class="s1">) || </span><span class="s2">_util</span><span class="s1">.</span><span class="s2">hasPrecedingLineBreak</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, )) {</span>
    <span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">restoreFromSnapshot</span><span class="s1">(</span><span class="s2">snapshot</span><span class="s1">);</span>
    <span class="s3">return false</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s4">// using</span>
  <span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">next</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
  <span class="s3">if </span><span class="s1">(!</span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">match</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">name</span><span class="s1">) || </span><span class="s2">_util</span><span class="s1">.</span><span class="s2">hasPrecedingLineBreak</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, )) {</span>
    <span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">restoreFromSnapshot</span><span class="s1">(</span><span class="s2">snapshot</span><span class="s1">);</span>
    <span class="s3">return false</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">restoreFromSnapshot</span><span class="s1">(</span><span class="s2">snapshot</span><span class="s1">);</span>
  <span class="s3">return true</span><span class="s1">;</span>
<span class="s1">}</span>

 <span class="s3">function </span><span class="s2">parseDecorators</span><span class="s1">() {</span>
  <span class="s3">while </span><span class="s1">(</span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">match</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">at</span><span class="s1">)) {</span>
    <span class="s2">parseDecorator</span><span class="s1">();</span>
  <span class="s1">}</span>
<span class="s1">} </span><span class="s2">exports</span><span class="s1">.</span><span class="s2">parseDecorators </span><span class="s1">= </span><span class="s2">parseDecorators</span><span class="s1">;</span>

<span class="s3">function </span><span class="s2">parseDecorator</span><span class="s1">() {</span>
  <span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">next</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">eat</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">parenL</span><span class="s1">)) {</span>
    <span class="s2">_expression</span><span class="s1">.</span><span class="s2">parseExpression</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
    <span class="s2">_util</span><span class="s1">.</span><span class="s2">expect</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">parenR</span><span class="s1">);</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s2">_expression</span><span class="s1">.</span><span class="s2">parseIdentifier</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
    <span class="s3">while </span><span class="s1">(</span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">eat</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">dot</span><span class="s1">)) {</span>
      <span class="s2">_expression</span><span class="s1">.</span><span class="s2">parseIdentifier</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
    <span class="s1">}</span>
    <span class="s2">parseMaybeDecoratorArguments</span><span class="s1">();</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s2">parseMaybeDecoratorArguments</span><span class="s1">() {</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">_base</span><span class="s1">.</span><span class="s2">isTypeScriptEnabled</span><span class="s1">) {</span>
    <span class="s2">_typescript</span><span class="s1">.</span><span class="s2">tsParseMaybeDecoratorArguments</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s2">baseParseMaybeDecoratorArguments</span><span class="s1">();</span>
  <span class="s1">}</span>
<span class="s1">}</span>

 <span class="s3">function </span><span class="s2">baseParseMaybeDecoratorArguments</span><span class="s1">() {</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">eat</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">parenL</span><span class="s1">)) {</span>
    <span class="s2">_expression</span><span class="s1">.</span><span class="s2">parseCallExpressionArguments</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
  <span class="s1">}</span>
<span class="s1">} </span><span class="s2">exports</span><span class="s1">.</span><span class="s2">baseParseMaybeDecoratorArguments </span><span class="s1">= </span><span class="s2">baseParseMaybeDecoratorArguments</span><span class="s1">;</span>

<span class="s3">function </span><span class="s2">parseBreakContinueStatement</span><span class="s1">() {</span>
  <span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">next</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
  <span class="s3">if </span><span class="s1">(!</span><span class="s2">_util</span><span class="s1">.</span><span class="s2">isLineTerminator</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, )) {</span>
    <span class="s2">_expression</span><span class="s1">.</span><span class="s2">parseIdentifier</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
    <span class="s2">_util</span><span class="s1">.</span><span class="s2">semicolon</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s2">parseDebuggerStatement</span><span class="s1">() {</span>
  <span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">next</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
  <span class="s2">_util</span><span class="s1">.</span><span class="s2">semicolon</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s2">parseDoStatement</span><span class="s1">() {</span>
  <span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">next</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
  <span class="s2">parseStatement</span><span class="s1">(</span><span class="s3">false</span><span class="s1">);</span>
  <span class="s2">_util</span><span class="s1">.</span><span class="s2">expect</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_while</span><span class="s1">);</span>
  <span class="s2">_expression</span><span class="s1">.</span><span class="s2">parseParenExpression</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
  <span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">eat</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">semi</span><span class="s1">);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s2">parseForStatement</span><span class="s1">() {</span>
  <span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">scopeDepth</span><span class="s1">++;</span>
  <span class="s3">const </span><span class="s2">startTokenIndex </span><span class="s1">= </span><span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">length</span><span class="s1">;</span>
  <span class="s2">parseAmbiguousForStatement</span><span class="s1">();</span>
  <span class="s3">const </span><span class="s2">endTokenIndex </span><span class="s1">= </span><span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">length</span><span class="s1">;</span>
  <span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">scopes</span><span class="s1">.</span><span class="s2">push</span><span class="s1">(</span><span class="s3">new </span><span class="s1">(</span><span class="s5">0</span><span class="s1">, </span><span class="s2">_state</span><span class="s1">.</span><span class="s2">Scope</span><span class="s1">)(</span><span class="s2">startTokenIndex</span><span class="s1">, </span><span class="s2">endTokenIndex</span><span class="s1">, </span><span class="s3">false</span><span class="s1">));</span>
  <span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">scopeDepth</span><span class="s1">--;</span>
<span class="s1">}</span>

<span class="s6">/**</span>
 <span class="s6">* Determine if this token is a `using` declaration (explicit resource</span>
 <span class="s6">* management) as part of a loop.</span>
 <span class="s6">* https://github.com/tc39/proposal-explicit-resource-management</span>
 <span class="s6">*/</span>
<span class="s3">function </span><span class="s2">isUsingInLoop</span><span class="s1">() {</span>
  <span class="s3">if </span><span class="s1">(!</span><span class="s2">_util</span><span class="s1">.</span><span class="s2">isContextual</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_keywords</span><span class="s1">.</span><span class="s2">ContextualKeyword</span><span class="s1">.</span><span class="s2">_using</span><span class="s1">)) {</span>
    <span class="s3">return false</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s4">// This must be `for (using of`, where `using` is the name of the loop</span>
  <span class="s4">// variable.</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">_util</span><span class="s1">.</span><span class="s2">isLookaheadContextual</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_keywords</span><span class="s1">.</span><span class="s2">ContextualKeyword</span><span class="s1">.</span><span class="s2">_of</span><span class="s1">)) {</span>
    <span class="s3">return false</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">return true</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s4">// Disambiguating between a `for` and a `for`/`in` or `for`/`of`</span>
<span class="s4">// loop is non-trivial. Basically, we have to parse the init `var`</span>
<span class="s4">// statement or expression, disallowing the `in` operator (see</span>
<span class="s4">// the second parameter to `parseExpression`), and then check</span>
<span class="s4">// whether the next token is `in` or `of`. When there is no init</span>
<span class="s4">// part (semicolon immediately after the opening parenthesis), it</span>
<span class="s4">// is a regular `for` loop.</span>
<span class="s3">function </span><span class="s2">parseAmbiguousForStatement</span><span class="s1">() {</span>
  <span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">next</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>

  <span class="s3">let </span><span class="s2">forAwait </span><span class="s1">= </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">_util</span><span class="s1">.</span><span class="s2">isContextual</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_keywords</span><span class="s1">.</span><span class="s2">ContextualKeyword</span><span class="s1">.</span><span class="s2">_await</span><span class="s1">)) {</span>
    <span class="s2">forAwait </span><span class="s1">= </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">next</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
  <span class="s1">}</span>
  <span class="s2">_util</span><span class="s1">.</span><span class="s2">expect</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">parenL</span><span class="s1">);</span>

  <span class="s3">if </span><span class="s1">(</span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">match</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">semi</span><span class="s1">)) {</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s2">forAwait</span><span class="s1">) {</span>
      <span class="s2">_util</span><span class="s1">.</span><span class="s2">unexpected</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
    <span class="s1">}</span>
    <span class="s2">parseFor</span><span class="s1">();</span>
    <span class="s3">return</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">const </span><span class="s2">isAwaitUsing </span><span class="s1">= </span><span class="s2">startsAwaitUsing</span><span class="s1">();</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">isAwaitUsing </span><span class="s1">|| </span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">match</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_var</span><span class="s1">) || </span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">match</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_let</span><span class="s1">) || </span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">match</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_const</span><span class="s1">) || </span><span class="s2">isUsingInLoop</span><span class="s1">()) {</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s2">isAwaitUsing</span><span class="s1">) {</span>
      <span class="s2">_util</span><span class="s1">.</span><span class="s2">expectContextual</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_keywords</span><span class="s1">.</span><span class="s2">ContextualKeyword</span><span class="s1">.</span><span class="s2">_await</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">next</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
    <span class="s2">parseVar</span><span class="s1">(</span><span class="s3">true</span><span class="s1">, </span><span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">type </span><span class="s1">!== </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_var</span><span class="s1">);</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">match</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_in</span><span class="s1">) || </span><span class="s2">_util</span><span class="s1">.</span><span class="s2">isContextual</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_keywords</span><span class="s1">.</span><span class="s2">ContextualKeyword</span><span class="s1">.</span><span class="s2">_of</span><span class="s1">)) {</span>
      <span class="s2">parseForIn</span><span class="s1">(</span><span class="s2">forAwait</span><span class="s1">);</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">parseFor</span><span class="s1">();</span>
    <span class="s3">return</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">_expression</span><span class="s1">.</span><span class="s2">parseExpression</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s3">true</span><span class="s1">);</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">match</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_in</span><span class="s1">) || </span><span class="s2">_util</span><span class="s1">.</span><span class="s2">isContextual</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_keywords</span><span class="s1">.</span><span class="s2">ContextualKeyword</span><span class="s1">.</span><span class="s2">_of</span><span class="s1">)) {</span>
    <span class="s2">parseForIn</span><span class="s1">(</span><span class="s2">forAwait</span><span class="s1">);</span>
    <span class="s3">return</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">forAwait</span><span class="s1">) {</span>
    <span class="s2">_util</span><span class="s1">.</span><span class="s2">unexpected</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
  <span class="s1">}</span>
  <span class="s2">parseFor</span><span class="s1">();</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s2">parseFunctionStatement</span><span class="s1">() {</span>
  <span class="s3">const </span><span class="s2">functionStart </span><span class="s1">= </span><span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">start</span><span class="s1">;</span>
  <span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">next</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
  <span class="s2">parseFunction</span><span class="s1">(</span><span class="s2">functionStart</span><span class="s1">, </span><span class="s3">true</span><span class="s1">);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s2">parseIfStatement</span><span class="s1">() {</span>
  <span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">next</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
  <span class="s2">_expression</span><span class="s1">.</span><span class="s2">parseParenExpression</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
  <span class="s2">parseStatement</span><span class="s1">(</span><span class="s3">false</span><span class="s1">);</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">eat</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_else</span><span class="s1">)) {</span>
    <span class="s2">parseStatement</span><span class="s1">(</span><span class="s3">false</span><span class="s1">);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s2">parseReturnStatement</span><span class="s1">() {</span>
  <span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">next</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>

  <span class="s4">// In `return` (and `break`/`continue`), the keywords with</span>
  <span class="s4">// optional arguments, we eagerly look for a semicolon or the</span>
  <span class="s4">// possibility to insert one.</span>

  <span class="s3">if </span><span class="s1">(!</span><span class="s2">_util</span><span class="s1">.</span><span class="s2">isLineTerminator</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, )) {</span>
    <span class="s2">_expression</span><span class="s1">.</span><span class="s2">parseExpression</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
    <span class="s2">_util</span><span class="s1">.</span><span class="s2">semicolon</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s2">parseSwitchStatement</span><span class="s1">() {</span>
  <span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">next</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
  <span class="s2">_expression</span><span class="s1">.</span><span class="s2">parseParenExpression</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
  <span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">scopeDepth</span><span class="s1">++;</span>
  <span class="s3">const </span><span class="s2">startTokenIndex </span><span class="s1">= </span><span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">length</span><span class="s1">;</span>
  <span class="s2">_util</span><span class="s1">.</span><span class="s2">expect</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">braceL</span><span class="s1">);</span>

  <span class="s4">// Don't bother validation; just go through any sequence of cases, defaults, and statements.</span>
  <span class="s3">while </span><span class="s1">(!</span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">match</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">braceR</span><span class="s1">) &amp;&amp; !</span><span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">error</span><span class="s1">) {</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">match</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_case</span><span class="s1">) || </span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">match</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_default</span><span class="s1">)) {</span>
      <span class="s3">const </span><span class="s2">isCase </span><span class="s1">= </span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">match</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_case</span><span class="s1">);</span>
      <span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">next</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s2">isCase</span><span class="s1">) {</span>
        <span class="s2">_expression</span><span class="s1">.</span><span class="s2">parseExpression</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
      <span class="s1">}</span>
      <span class="s2">_util</span><span class="s1">.</span><span class="s2">expect</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">colon</span><span class="s1">);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s2">parseStatement</span><span class="s1">(</span><span class="s3">true</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">next</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, ); </span><span class="s4">// Closing brace</span>
  <span class="s3">const </span><span class="s2">endTokenIndex </span><span class="s1">= </span><span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">length</span><span class="s1">;</span>
  <span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">scopes</span><span class="s1">.</span><span class="s2">push</span><span class="s1">(</span><span class="s3">new </span><span class="s1">(</span><span class="s5">0</span><span class="s1">, </span><span class="s2">_state</span><span class="s1">.</span><span class="s2">Scope</span><span class="s1">)(</span><span class="s2">startTokenIndex</span><span class="s1">, </span><span class="s2">endTokenIndex</span><span class="s1">, </span><span class="s3">false</span><span class="s1">));</span>
  <span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">scopeDepth</span><span class="s1">--;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s2">parseThrowStatement</span><span class="s1">() {</span>
  <span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">next</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
  <span class="s2">_expression</span><span class="s1">.</span><span class="s2">parseExpression</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
  <span class="s2">_util</span><span class="s1">.</span><span class="s2">semicolon</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s2">parseCatchClauseParam</span><span class="s1">() {</span>
  <span class="s2">_lval</span><span class="s1">.</span><span class="s2">parseBindingAtom</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s3">true </span><span class="s4">/* isBlockScope */</span><span class="s1">);</span>

  <span class="s3">if </span><span class="s1">(</span><span class="s2">_base</span><span class="s1">.</span><span class="s2">isTypeScriptEnabled</span><span class="s1">) {</span>
    <span class="s2">_typescript</span><span class="s1">.</span><span class="s2">tsTryParseTypeAnnotation</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s2">parseTryStatement</span><span class="s1">() {</span>
  <span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">next</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>

  <span class="s2">parseBlock</span><span class="s1">();</span>

  <span class="s3">if </span><span class="s1">(</span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">match</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_catch</span><span class="s1">)) {</span>
    <span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">next</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
    <span class="s3">let </span><span class="s2">catchBindingStartTokenIndex </span><span class="s1">= </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">match</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">parenL</span><span class="s1">)) {</span>
      <span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">scopeDepth</span><span class="s1">++;</span>
      <span class="s2">catchBindingStartTokenIndex </span><span class="s1">= </span><span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">length</span><span class="s1">;</span>
      <span class="s2">_util</span><span class="s1">.</span><span class="s2">expect</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">parenL</span><span class="s1">);</span>
      <span class="s2">parseCatchClauseParam</span><span class="s1">();</span>
      <span class="s2">_util</span><span class="s1">.</span><span class="s2">expect</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">parenR</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">parseBlock</span><span class="s1">();</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s2">catchBindingStartTokenIndex </span><span class="s1">!= </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s4">// We need a special scope for the catch binding which includes the binding itself and the</span>
      <span class="s4">// catch block.</span>
      <span class="s3">const </span><span class="s2">endTokenIndex </span><span class="s1">= </span><span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">length</span><span class="s1">;</span>
      <span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">scopes</span><span class="s1">.</span><span class="s2">push</span><span class="s1">(</span><span class="s3">new </span><span class="s1">(</span><span class="s5">0</span><span class="s1">, </span><span class="s2">_state</span><span class="s1">.</span><span class="s2">Scope</span><span class="s1">)(</span><span class="s2">catchBindingStartTokenIndex</span><span class="s1">, </span><span class="s2">endTokenIndex</span><span class="s1">, </span><span class="s3">false</span><span class="s1">));</span>
      <span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">scopeDepth</span><span class="s1">--;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">eat</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_finally</span><span class="s1">)) {</span>
    <span class="s2">parseBlock</span><span class="s1">();</span>
  <span class="s1">}</span>
<span class="s1">}</span>

 <span class="s3">function </span><span class="s2">parseVarStatement</span><span class="s1">(</span><span class="s2">isBlockScope</span><span class="s1">) {</span>
  <span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">next</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
  <span class="s2">parseVar</span><span class="s1">(</span><span class="s3">false</span><span class="s1">, </span><span class="s2">isBlockScope</span><span class="s1">);</span>
  <span class="s2">_util</span><span class="s1">.</span><span class="s2">semicolon</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
<span class="s1">} </span><span class="s2">exports</span><span class="s1">.</span><span class="s2">parseVarStatement </span><span class="s1">= </span><span class="s2">parseVarStatement</span><span class="s1">;</span>

<span class="s3">function </span><span class="s2">parseWhileStatement</span><span class="s1">() {</span>
  <span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">next</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
  <span class="s2">_expression</span><span class="s1">.</span><span class="s2">parseParenExpression</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
  <span class="s2">parseStatement</span><span class="s1">(</span><span class="s3">false</span><span class="s1">);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s2">parseEmptyStatement</span><span class="s1">() {</span>
  <span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">next</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s2">parseLabeledStatement</span><span class="s1">() {</span>
  <span class="s2">parseStatement</span><span class="s1">(</span><span class="s3">true</span><span class="s1">);</span>
<span class="s1">}</span>

<span class="s6">/**</span>
 <span class="s6">* Parse a statement starting with an identifier of the given name. Subclasses match on the name</span>
 <span class="s6">* to handle statements like &quot;declare&quot;.</span>
 <span class="s6">*/</span>
<span class="s3">function </span><span class="s2">parseIdentifierStatement</span><span class="s1">(</span><span class="s2">contextualKeyword</span><span class="s1">) {</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">_base</span><span class="s1">.</span><span class="s2">isTypeScriptEnabled</span><span class="s1">) {</span>
    <span class="s2">_typescript</span><span class="s1">.</span><span class="s2">tsParseIdentifierStatement</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">contextualKeyword</span><span class="s1">);</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s2">_base</span><span class="s1">.</span><span class="s2">isFlowEnabled</span><span class="s1">) {</span>
    <span class="s2">_flow</span><span class="s1">.</span><span class="s2">flowParseIdentifierStatement</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">contextualKeyword</span><span class="s1">);</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s2">_util</span><span class="s1">.</span><span class="s2">semicolon</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s4">// Parse a semicolon-enclosed block of statements.</span>
 <span class="s3">function </span><span class="s2">parseBlock</span><span class="s1">(</span><span class="s2">isFunctionScope </span><span class="s1">= </span><span class="s3">false</span><span class="s1">, </span><span class="s2">contextId </span><span class="s1">= </span><span class="s5">0</span><span class="s1">) {</span>
  <span class="s3">const </span><span class="s2">startTokenIndex </span><span class="s1">= </span><span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">length</span><span class="s1">;</span>
  <span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">scopeDepth</span><span class="s1">++;</span>
  <span class="s2">_util</span><span class="s1">.</span><span class="s2">expect</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">braceL</span><span class="s1">);</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">contextId</span><span class="s1">) {</span>
    <span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">[</span><span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">length </span><span class="s1">- </span><span class="s5">1</span><span class="s1">].</span><span class="s2">contextId </span><span class="s1">= </span><span class="s2">contextId</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s2">parseBlockBody</span><span class="s1">(</span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">braceR</span><span class="s1">);</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">contextId</span><span class="s1">) {</span>
    <span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">[</span><span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">length </span><span class="s1">- </span><span class="s5">1</span><span class="s1">].</span><span class="s2">contextId </span><span class="s1">= </span><span class="s2">contextId</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">const </span><span class="s2">endTokenIndex </span><span class="s1">= </span><span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">length</span><span class="s1">;</span>
  <span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">scopes</span><span class="s1">.</span><span class="s2">push</span><span class="s1">(</span><span class="s3">new </span><span class="s1">(</span><span class="s5">0</span><span class="s1">, </span><span class="s2">_state</span><span class="s1">.</span><span class="s2">Scope</span><span class="s1">)(</span><span class="s2">startTokenIndex</span><span class="s1">, </span><span class="s2">endTokenIndex</span><span class="s1">, </span><span class="s2">isFunctionScope</span><span class="s1">));</span>
  <span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">scopeDepth</span><span class="s1">--;</span>
<span class="s1">} </span><span class="s2">exports</span><span class="s1">.</span><span class="s2">parseBlock </span><span class="s1">= </span><span class="s2">parseBlock</span><span class="s1">;</span>

 <span class="s3">function </span><span class="s2">parseBlockBody</span><span class="s1">(</span><span class="s2">end</span><span class="s1">) {</span>
  <span class="s3">while </span><span class="s1">(!</span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">eat</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">end</span><span class="s1">) &amp;&amp; !</span><span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">error</span><span class="s1">) {</span>
    <span class="s2">parseStatement</span><span class="s1">(</span><span class="s3">true</span><span class="s1">);</span>
  <span class="s1">}</span>
<span class="s1">} </span><span class="s2">exports</span><span class="s1">.</span><span class="s2">parseBlockBody </span><span class="s1">= </span><span class="s2">parseBlockBody</span><span class="s1">;</span>

<span class="s4">// Parse a regular `for` loop. The disambiguation code in</span>
<span class="s4">// `parseStatement` will already have parsed the init statement or</span>
<span class="s4">// expression.</span>

<span class="s3">function </span><span class="s2">parseFor</span><span class="s1">() {</span>
  <span class="s2">_util</span><span class="s1">.</span><span class="s2">expect</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">semi</span><span class="s1">);</span>
  <span class="s3">if </span><span class="s1">(!</span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">match</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">semi</span><span class="s1">)) {</span>
    <span class="s2">_expression</span><span class="s1">.</span><span class="s2">parseExpression</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
  <span class="s1">}</span>
  <span class="s2">_util</span><span class="s1">.</span><span class="s2">expect</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">semi</span><span class="s1">);</span>
  <span class="s3">if </span><span class="s1">(!</span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">match</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">parenR</span><span class="s1">)) {</span>
    <span class="s2">_expression</span><span class="s1">.</span><span class="s2">parseExpression</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
  <span class="s1">}</span>
  <span class="s2">_util</span><span class="s1">.</span><span class="s2">expect</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">parenR</span><span class="s1">);</span>
  <span class="s2">parseStatement</span><span class="s1">(</span><span class="s3">false</span><span class="s1">);</span>
<span class="s1">}</span>

<span class="s4">// Parse a `for`/`in` and `for`/`of` loop, which are almost</span>
<span class="s4">// same from parser's perspective.</span>

<span class="s3">function </span><span class="s2">parseForIn</span><span class="s1">(</span><span class="s2">forAwait</span><span class="s1">) {</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">forAwait</span><span class="s1">) {</span>
    <span class="s2">_util</span><span class="s1">.</span><span class="s2">eatContextual</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_keywords</span><span class="s1">.</span><span class="s2">ContextualKeyword</span><span class="s1">.</span><span class="s2">_of</span><span class="s1">);</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">next</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
  <span class="s1">}</span>
  <span class="s2">_expression</span><span class="s1">.</span><span class="s2">parseExpression</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
  <span class="s2">_util</span><span class="s1">.</span><span class="s2">expect</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">parenR</span><span class="s1">);</span>
  <span class="s2">parseStatement</span><span class="s1">(</span><span class="s3">false</span><span class="s1">);</span>
<span class="s1">}</span>

<span class="s4">// Parse a list of variable declarations.</span>

<span class="s3">function </span><span class="s2">parseVar</span><span class="s1">(</span><span class="s2">isFor</span><span class="s1">, </span><span class="s2">isBlockScope</span><span class="s1">) {</span>
  <span class="s3">while </span><span class="s1">(</span><span class="s3">true</span><span class="s1">) {</span>
    <span class="s2">parseVarHead</span><span class="s1">(</span><span class="s2">isBlockScope</span><span class="s1">);</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">eat</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">eq</span><span class="s1">)) {</span>
      <span class="s3">const </span><span class="s2">eqIndex </span><span class="s1">= </span><span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">length </span><span class="s1">- </span><span class="s5">1</span><span class="s1">;</span>
      <span class="s2">_expression</span><span class="s1">.</span><span class="s2">parseMaybeAssign</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">isFor</span><span class="s1">);</span>
      <span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">[</span><span class="s2">eqIndex</span><span class="s1">].</span><span class="s2">rhsEndIndex </span><span class="s1">= </span><span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">length</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(!</span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">eat</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">comma</span><span class="s1">)) {</span>
      <span class="s3">break</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s2">parseVarHead</span><span class="s1">(</span><span class="s2">isBlockScope</span><span class="s1">) {</span>
  <span class="s2">_lval</span><span class="s1">.</span><span class="s2">parseBindingAtom</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">isBlockScope</span><span class="s1">);</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">_base</span><span class="s1">.</span><span class="s2">isTypeScriptEnabled</span><span class="s1">) {</span>
    <span class="s2">_typescript</span><span class="s1">.</span><span class="s2">tsAfterParseVarHead</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s2">_base</span><span class="s1">.</span><span class="s2">isFlowEnabled</span><span class="s1">) {</span>
    <span class="s2">_flow</span><span class="s1">.</span><span class="s2">flowAfterParseVarHead</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s4">// Parse a function declaration or literal (depending on the</span>
<span class="s4">// `isStatement` parameter).</span>

 <span class="s3">function </span><span class="s2">parseFunction</span><span class="s1">(</span>
  <span class="s2">functionStart</span><span class="s1">,</span>
  <span class="s2">isStatement</span><span class="s1">,</span>
  <span class="s2">optionalId </span><span class="s1">= </span><span class="s3">false</span><span class="s1">,</span>
<span class="s1">) {</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">match</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">star</span><span class="s1">)) {</span>
    <span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">next</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(</span><span class="s2">isStatement </span><span class="s1">&amp;&amp; !</span><span class="s2">optionalId </span><span class="s1">&amp;&amp; !</span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">match</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">name</span><span class="s1">) &amp;&amp; !</span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">match</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_yield</span><span class="s1">)) {</span>
    <span class="s2">_util</span><span class="s1">.</span><span class="s2">unexpected</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
  <span class="s1">}</span>

  <span class="s3">let </span><span class="s2">nameScopeStartTokenIndex </span><span class="s1">= </span><span class="s3">null</span><span class="s1">;</span>

  <span class="s3">if </span><span class="s1">(</span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">match</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">name</span><span class="s1">)) {</span>
    <span class="s4">// Expression-style functions should limit their name's scope to the function body, so we make</span>
    <span class="s4">// a new function scope to enforce that.</span>
    <span class="s3">if </span><span class="s1">(!</span><span class="s2">isStatement</span><span class="s1">) {</span>
      <span class="s2">nameScopeStartTokenIndex </span><span class="s1">= </span><span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">length</span><span class="s1">;</span>
      <span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">scopeDepth</span><span class="s1">++;</span>
    <span class="s1">}</span>
    <span class="s2">_lval</span><span class="s1">.</span><span class="s2">parseBindingIdentifier</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s3">false</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s3">const </span><span class="s2">startTokenIndex </span><span class="s1">= </span><span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">length</span><span class="s1">;</span>
  <span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">scopeDepth</span><span class="s1">++;</span>
  <span class="s2">parseFunctionParams</span><span class="s1">();</span>
  <span class="s2">_expression</span><span class="s1">.</span><span class="s2">parseFunctionBodyAndFinish</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">functionStart</span><span class="s1">);</span>
  <span class="s3">const </span><span class="s2">endTokenIndex </span><span class="s1">= </span><span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">length</span><span class="s1">;</span>
  <span class="s4">// In addition to the block scope of the function body, we need a separate function-style scope</span>
  <span class="s4">// that includes the params.</span>
  <span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">scopes</span><span class="s1">.</span><span class="s2">push</span><span class="s1">(</span><span class="s3">new </span><span class="s1">(</span><span class="s5">0</span><span class="s1">, </span><span class="s2">_state</span><span class="s1">.</span><span class="s2">Scope</span><span class="s1">)(</span><span class="s2">startTokenIndex</span><span class="s1">, </span><span class="s2">endTokenIndex</span><span class="s1">, </span><span class="s3">true</span><span class="s1">));</span>
  <span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">scopeDepth</span><span class="s1">--;</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">nameScopeStartTokenIndex </span><span class="s1">!== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">scopes</span><span class="s1">.</span><span class="s2">push</span><span class="s1">(</span><span class="s3">new </span><span class="s1">(</span><span class="s5">0</span><span class="s1">, </span><span class="s2">_state</span><span class="s1">.</span><span class="s2">Scope</span><span class="s1">)(</span><span class="s2">nameScopeStartTokenIndex</span><span class="s1">, </span><span class="s2">endTokenIndex</span><span class="s1">, </span><span class="s3">true</span><span class="s1">));</span>
    <span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">scopeDepth</span><span class="s1">--;</span>
  <span class="s1">}</span>
<span class="s1">} </span><span class="s2">exports</span><span class="s1">.</span><span class="s2">parseFunction </span><span class="s1">= </span><span class="s2">parseFunction</span><span class="s1">;</span>

 <span class="s3">function </span><span class="s2">parseFunctionParams</span><span class="s1">(</span>
  <span class="s2">allowModifiers </span><span class="s1">= </span><span class="s3">false</span><span class="s1">,</span>
  <span class="s2">funcContextId </span><span class="s1">= </span><span class="s5">0</span><span class="s1">,</span>
<span class="s1">) {</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">_base</span><span class="s1">.</span><span class="s2">isTypeScriptEnabled</span><span class="s1">) {</span>
    <span class="s2">_typescript</span><span class="s1">.</span><span class="s2">tsStartParseFunctionParams</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s2">_base</span><span class="s1">.</span><span class="s2">isFlowEnabled</span><span class="s1">) {</span>
    <span class="s2">_flow</span><span class="s1">.</span><span class="s2">flowStartParseFunctionParams</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
  <span class="s1">}</span>

  <span class="s2">_util</span><span class="s1">.</span><span class="s2">expect</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">parenL</span><span class="s1">);</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">funcContextId</span><span class="s1">) {</span>
    <span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">[</span><span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">length </span><span class="s1">- </span><span class="s5">1</span><span class="s1">].</span><span class="s2">contextId </span><span class="s1">= </span><span class="s2">funcContextId</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s2">_lval</span><span class="s1">.</span><span class="s2">parseBindingList</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span>
    <span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">parenR</span><span class="s1">,</span>
    <span class="s3">false </span><span class="s4">/* isBlockScope */</span><span class="s1">,</span>
    <span class="s3">false </span><span class="s4">/* allowEmpty */</span><span class="s1">,</span>
    <span class="s2">allowModifiers</span><span class="s1">,</span>
    <span class="s2">funcContextId</span><span class="s1">,</span>
  <span class="s1">);</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">funcContextId</span><span class="s1">) {</span>
    <span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">[</span><span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">length </span><span class="s1">- </span><span class="s5">1</span><span class="s1">].</span><span class="s2">contextId </span><span class="s1">= </span><span class="s2">funcContextId</span><span class="s1">;</span>
  <span class="s1">}</span>
<span class="s1">} </span><span class="s2">exports</span><span class="s1">.</span><span class="s2">parseFunctionParams </span><span class="s1">= </span><span class="s2">parseFunctionParams</span><span class="s1">;</span>

<span class="s4">// Parse a class declaration or literal (depending on the</span>
<span class="s4">// `isStatement` parameter).</span>

 <span class="s3">function </span><span class="s2">parseClass</span><span class="s1">(</span><span class="s2">isStatement</span><span class="s1">, </span><span class="s2">optionalId </span><span class="s1">= </span><span class="s3">false</span><span class="s1">) {</span>
  <span class="s4">// Put a context ID on the class keyword, the open-brace, and the close-brace, so that later</span>
  <span class="s4">// code can easily navigate to meaningful points on the class.</span>
  <span class="s3">const </span><span class="s2">contextId </span><span class="s1">= </span><span class="s2">_base</span><span class="s1">.</span><span class="s2">getNextContextId</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>

  <span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">next</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
  <span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">[</span><span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">length </span><span class="s1">- </span><span class="s5">1</span><span class="s1">].</span><span class="s2">contextId </span><span class="s1">= </span><span class="s2">contextId</span><span class="s1">;</span>
  <span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">[</span><span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">length </span><span class="s1">- </span><span class="s5">1</span><span class="s1">].</span><span class="s2">isExpression </span><span class="s1">= !</span><span class="s2">isStatement</span><span class="s1">;</span>
  <span class="s4">// Like with functions, we declare a special &quot;name scope&quot; from the start of the name to the end</span>
  <span class="s4">// of the class, but only with expression-style classes, to represent the fact that the name is</span>
  <span class="s4">// available to the body of the class but not an outer declaration.</span>
  <span class="s3">let </span><span class="s2">nameScopeStartTokenIndex </span><span class="s1">= </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s1">(!</span><span class="s2">isStatement</span><span class="s1">) {</span>
    <span class="s2">nameScopeStartTokenIndex </span><span class="s1">= </span><span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">length</span><span class="s1">;</span>
    <span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">scopeDepth</span><span class="s1">++;</span>
  <span class="s1">}</span>
  <span class="s2">parseClassId</span><span class="s1">(</span><span class="s2">isStatement</span><span class="s1">, </span><span class="s2">optionalId</span><span class="s1">);</span>
  <span class="s2">parseClassSuper</span><span class="s1">();</span>
  <span class="s3">const </span><span class="s2">openBraceIndex </span><span class="s1">= </span><span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">length</span><span class="s1">;</span>
  <span class="s2">parseClassBody</span><span class="s1">(</span><span class="s2">contextId</span><span class="s1">);</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">error</span><span class="s1">) {</span>
    <span class="s3">return</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">[</span><span class="s2">openBraceIndex</span><span class="s1">].</span><span class="s2">contextId </span><span class="s1">= </span><span class="s2">contextId</span><span class="s1">;</span>
  <span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">[</span><span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">length </span><span class="s1">- </span><span class="s5">1</span><span class="s1">].</span><span class="s2">contextId </span><span class="s1">= </span><span class="s2">contextId</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">nameScopeStartTokenIndex </span><span class="s1">!== </span><span class="s3">null</span><span class="s1">) {</span>
    <span class="s3">const </span><span class="s2">endTokenIndex </span><span class="s1">= </span><span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">length</span><span class="s1">;</span>
    <span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">scopes</span><span class="s1">.</span><span class="s2">push</span><span class="s1">(</span><span class="s3">new </span><span class="s1">(</span><span class="s5">0</span><span class="s1">, </span><span class="s2">_state</span><span class="s1">.</span><span class="s2">Scope</span><span class="s1">)(</span><span class="s2">nameScopeStartTokenIndex</span><span class="s1">, </span><span class="s2">endTokenIndex</span><span class="s1">, </span><span class="s3">false</span><span class="s1">));</span>
    <span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">scopeDepth</span><span class="s1">--;</span>
  <span class="s1">}</span>
<span class="s1">} </span><span class="s2">exports</span><span class="s1">.</span><span class="s2">parseClass </span><span class="s1">= </span><span class="s2">parseClass</span><span class="s1">;</span>

<span class="s3">function </span><span class="s2">isClassProperty</span><span class="s1">() {</span>
  <span class="s3">return </span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">match</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">eq</span><span class="s1">) || </span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">match</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">semi</span><span class="s1">) || </span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">match</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">braceR</span><span class="s1">) || </span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">match</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">bang</span><span class="s1">) || </span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">match</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">colon</span><span class="s1">);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s2">isClassMethod</span><span class="s1">() {</span>
  <span class="s3">return </span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">match</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">parenL</span><span class="s1">) || </span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">match</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">lessThan</span><span class="s1">);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s2">parseClassBody</span><span class="s1">(</span><span class="s2">classContextId</span><span class="s1">) {</span>
  <span class="s2">_util</span><span class="s1">.</span><span class="s2">expect</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">braceL</span><span class="s1">);</span>

  <span class="s3">while </span><span class="s1">(!</span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">eat</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">braceR</span><span class="s1">) &amp;&amp; !</span><span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">error</span><span class="s1">) {</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">eat</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">semi</span><span class="s1">)) {</span>
      <span class="s3">continue</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">match</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">at</span><span class="s1">)) {</span>
      <span class="s2">parseDecorator</span><span class="s1">();</span>
      <span class="s3">continue</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">const </span><span class="s2">memberStart </span><span class="s1">= </span><span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">start</span><span class="s1">;</span>
    <span class="s2">parseClassMember</span><span class="s1">(</span><span class="s2">memberStart</span><span class="s1">, </span><span class="s2">classContextId</span><span class="s1">);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s2">parseClassMember</span><span class="s1">(</span><span class="s2">memberStart</span><span class="s1">, </span><span class="s2">classContextId</span><span class="s1">) {</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">_base</span><span class="s1">.</span><span class="s2">isTypeScriptEnabled</span><span class="s1">) {</span>
    <span class="s2">_typescript</span><span class="s1">.</span><span class="s2">tsParseModifiers</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, [</span>
      <span class="s2">_keywords</span><span class="s1">.</span><span class="s2">ContextualKeyword</span><span class="s1">.</span><span class="s2">_declare</span><span class="s1">,</span>
      <span class="s2">_keywords</span><span class="s1">.</span><span class="s2">ContextualKeyword</span><span class="s1">.</span><span class="s2">_public</span><span class="s1">,</span>
      <span class="s2">_keywords</span><span class="s1">.</span><span class="s2">ContextualKeyword</span><span class="s1">.</span><span class="s2">_protected</span><span class="s1">,</span>
      <span class="s2">_keywords</span><span class="s1">.</span><span class="s2">ContextualKeyword</span><span class="s1">.</span><span class="s2">_private</span><span class="s1">,</span>
      <span class="s2">_keywords</span><span class="s1">.</span><span class="s2">ContextualKeyword</span><span class="s1">.</span><span class="s2">_override</span><span class="s1">,</span>
    <span class="s1">]);</span>
  <span class="s1">}</span>
  <span class="s3">let </span><span class="s2">isStatic </span><span class="s1">= </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">match</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">name</span><span class="s1">) &amp;&amp; </span><span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">contextualKeyword </span><span class="s1">=== </span><span class="s2">_keywords</span><span class="s1">.</span><span class="s2">ContextualKeyword</span><span class="s1">.</span><span class="s2">_static</span><span class="s1">) {</span>
    <span class="s2">_expression</span><span class="s1">.</span><span class="s2">parseIdentifier</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, ); </span><span class="s4">// eats 'static'</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s2">isClassMethod</span><span class="s1">()) {</span>
      <span class="s2">parseClassMethod</span><span class="s1">(</span><span class="s2">memberStart</span><span class="s1">, </span><span class="s4">/* isConstructor */ </span><span class="s3">false</span><span class="s1">);</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s2">isClassProperty</span><span class="s1">()) {</span>
      <span class="s2">parseClassProperty</span><span class="s1">();</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s4">// otherwise something static</span>
    <span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">[</span><span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">length </span><span class="s1">- </span><span class="s5">1</span><span class="s1">].</span><span class="s2">type </span><span class="s1">= </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_static</span><span class="s1">;</span>
    <span class="s2">isStatic </span><span class="s1">= </span><span class="s3">true</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">match</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">braceL</span><span class="s1">)) {</span>
      <span class="s4">// This is a static block. Mark the word &quot;static&quot; with the class context ID for class element</span>
      <span class="s4">// detection and parse as a regular block.</span>
      <span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">[</span><span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">length </span><span class="s1">- </span><span class="s5">1</span><span class="s1">].</span><span class="s2">contextId </span><span class="s1">= </span><span class="s2">classContextId</span><span class="s1">;</span>
      <span class="s2">parseBlock</span><span class="s1">();</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">parseClassMemberWithIsStatic</span><span class="s1">(</span><span class="s2">memberStart</span><span class="s1">, </span><span class="s2">isStatic</span><span class="s1">, </span><span class="s2">classContextId</span><span class="s1">);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s2">parseClassMemberWithIsStatic</span><span class="s1">(</span>
  <span class="s2">memberStart</span><span class="s1">,</span>
  <span class="s2">isStatic</span><span class="s1">,</span>
  <span class="s2">classContextId</span><span class="s1">,</span>
<span class="s1">) {</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">_base</span><span class="s1">.</span><span class="s2">isTypeScriptEnabled</span><span class="s1">) {</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s2">_typescript</span><span class="s1">.</span><span class="s2">tsTryParseClassMemberWithIsStatic</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">isStatic</span><span class="s1">)) {</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">eat</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">star</span><span class="s1">)) {</span>
    <span class="s4">// a generator</span>
    <span class="s2">parseClassPropertyName</span><span class="s1">(</span><span class="s2">classContextId</span><span class="s1">);</span>
    <span class="s2">parseClassMethod</span><span class="s1">(</span><span class="s2">memberStart</span><span class="s1">, </span><span class="s4">/* isConstructor */ </span><span class="s3">false</span><span class="s1">);</span>
    <span class="s3">return</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s4">// Get the identifier name so we can tell if it's actually a keyword like &quot;async&quot;, &quot;get&quot;, or</span>
  <span class="s4">// &quot;set&quot;.</span>
  <span class="s2">parseClassPropertyName</span><span class="s1">(</span><span class="s2">classContextId</span><span class="s1">);</span>
  <span class="s3">let </span><span class="s2">isConstructor </span><span class="s1">= </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">const </span><span class="s2">token </span><span class="s1">= </span><span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">[</span><span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">length </span><span class="s1">- </span><span class="s5">1</span><span class="s1">];</span>
  <span class="s4">// We allow &quot;constructor&quot; as either an identifier or a string.</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">token</span><span class="s1">.</span><span class="s2">contextualKeyword </span><span class="s1">=== </span><span class="s2">_keywords</span><span class="s1">.</span><span class="s2">ContextualKeyword</span><span class="s1">.</span><span class="s2">_constructor</span><span class="s1">) {</span>
    <span class="s2">isConstructor </span><span class="s1">= </span><span class="s3">true</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s2">parsePostMemberNameModifiers</span><span class="s1">();</span>

  <span class="s3">if </span><span class="s1">(</span><span class="s2">isClassMethod</span><span class="s1">()) {</span>
    <span class="s2">parseClassMethod</span><span class="s1">(</span><span class="s2">memberStart</span><span class="s1">, </span><span class="s2">isConstructor</span><span class="s1">);</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s2">isClassProperty</span><span class="s1">()) {</span>
    <span class="s2">parseClassProperty</span><span class="s1">();</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s2">token</span><span class="s1">.</span><span class="s2">contextualKeyword </span><span class="s1">=== </span><span class="s2">_keywords</span><span class="s1">.</span><span class="s2">ContextualKeyword</span><span class="s1">.</span><span class="s2">_async </span><span class="s1">&amp;&amp; !</span><span class="s2">_util</span><span class="s1">.</span><span class="s2">isLineTerminator</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, )) {</span>
    <span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">[</span><span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">length </span><span class="s1">- </span><span class="s5">1</span><span class="s1">].</span><span class="s2">type </span><span class="s1">= </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_async</span><span class="s1">;</span>
    <span class="s4">// an async method</span>
    <span class="s3">const </span><span class="s2">isGenerator </span><span class="s1">= </span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">match</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">star</span><span class="s1">);</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s2">isGenerator</span><span class="s1">) {</span>
      <span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">next</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
    <span class="s1">}</span>

    <span class="s4">// The so-called parsed name would have been &quot;async&quot;: get the real name.</span>
    <span class="s2">parseClassPropertyName</span><span class="s1">(</span><span class="s2">classContextId</span><span class="s1">);</span>
    <span class="s2">parsePostMemberNameModifiers</span><span class="s1">();</span>
    <span class="s2">parseClassMethod</span><span class="s1">(</span><span class="s2">memberStart</span><span class="s1">, </span><span class="s3">false </span><span class="s4">/* isConstructor */</span><span class="s1">);</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span>
    <span class="s1">(</span><span class="s2">token</span><span class="s1">.</span><span class="s2">contextualKeyword </span><span class="s1">=== </span><span class="s2">_keywords</span><span class="s1">.</span><span class="s2">ContextualKeyword</span><span class="s1">.</span><span class="s2">_get </span><span class="s1">||</span>
      <span class="s2">token</span><span class="s1">.</span><span class="s2">contextualKeyword </span><span class="s1">=== </span><span class="s2">_keywords</span><span class="s1">.</span><span class="s2">ContextualKeyword</span><span class="s1">.</span><span class="s2">_set</span><span class="s1">) &amp;&amp;</span>
    <span class="s1">!(</span><span class="s2">_util</span><span class="s1">.</span><span class="s2">isLineTerminator</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, ) &amp;&amp; </span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">match</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">star</span><span class="s1">))</span>
  <span class="s1">) {</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s2">token</span><span class="s1">.</span><span class="s2">contextualKeyword </span><span class="s1">=== </span><span class="s2">_keywords</span><span class="s1">.</span><span class="s2">ContextualKeyword</span><span class="s1">.</span><span class="s2">_get</span><span class="s1">) {</span>
      <span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">[</span><span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">length </span><span class="s1">- </span><span class="s5">1</span><span class="s1">].</span><span class="s2">type </span><span class="s1">= </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_get</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">[</span><span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">length </span><span class="s1">- </span><span class="s5">1</span><span class="s1">].</span><span class="s2">type </span><span class="s1">= </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_set</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s4">// `get\n*` is an uninitialized property named 'get' followed by a generator.</span>
    <span class="s4">// a getter or setter</span>
    <span class="s4">// The so-called parsed name would have been &quot;get/set&quot;: get the real name.</span>
    <span class="s2">parseClassPropertyName</span><span class="s1">(</span><span class="s2">classContextId</span><span class="s1">);</span>
    <span class="s2">parseClassMethod</span><span class="s1">(</span><span class="s2">memberStart</span><span class="s1">, </span><span class="s4">/* isConstructor */ </span><span class="s3">false</span><span class="s1">);</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s2">token</span><span class="s1">.</span><span class="s2">contextualKeyword </span><span class="s1">=== </span><span class="s2">_keywords</span><span class="s1">.</span><span class="s2">ContextualKeyword</span><span class="s1">.</span><span class="s2">_accessor </span><span class="s1">&amp;&amp; !</span><span class="s2">_util</span><span class="s1">.</span><span class="s2">isLineTerminator</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, )) {</span>
    <span class="s2">parseClassPropertyName</span><span class="s1">(</span><span class="s2">classContextId</span><span class="s1">);</span>
    <span class="s2">parseClassProperty</span><span class="s1">();</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s2">_util</span><span class="s1">.</span><span class="s2">isLineTerminator</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, )) {</span>
    <span class="s4">// an uninitialized class property (due to ASI, since we don't otherwise recognize the next token)</span>
    <span class="s2">parseClassProperty</span><span class="s1">();</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s2">_util</span><span class="s1">.</span><span class="s2">unexpected</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s2">parseClassMethod</span><span class="s1">(</span><span class="s2">functionStart</span><span class="s1">, </span><span class="s2">isConstructor</span><span class="s1">) {</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">_base</span><span class="s1">.</span><span class="s2">isTypeScriptEnabled</span><span class="s1">) {</span>
    <span class="s2">_typescript</span><span class="s1">.</span><span class="s2">tsTryParseTypeParameters</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s2">_base</span><span class="s1">.</span><span class="s2">isFlowEnabled</span><span class="s1">) {</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">match</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">lessThan</span><span class="s1">)) {</span>
      <span class="s2">_flow</span><span class="s1">.</span><span class="s2">flowParseTypeParameterDeclaration</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">_expression</span><span class="s1">.</span><span class="s2">parseMethod</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">functionStart</span><span class="s1">, </span><span class="s2">isConstructor</span><span class="s1">);</span>
<span class="s1">}</span>

<span class="s4">// Return the name of the class property, if it is a simple identifier.</span>
 <span class="s3">function </span><span class="s2">parseClassPropertyName</span><span class="s1">(</span><span class="s2">classContextId</span><span class="s1">) {</span>
  <span class="s2">_expression</span><span class="s1">.</span><span class="s2">parsePropertyName</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">classContextId</span><span class="s1">);</span>
<span class="s1">} </span><span class="s2">exports</span><span class="s1">.</span><span class="s2">parseClassPropertyName </span><span class="s1">= </span><span class="s2">parseClassPropertyName</span><span class="s1">;</span>

 <span class="s3">function </span><span class="s2">parsePostMemberNameModifiers</span><span class="s1">() {</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">_base</span><span class="s1">.</span><span class="s2">isTypeScriptEnabled</span><span class="s1">) {</span>
    <span class="s3">const </span><span class="s2">oldIsType </span><span class="s1">= </span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">pushTypeContext</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s5">0</span><span class="s1">);</span>
    <span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">eat</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">question</span><span class="s1">);</span>
    <span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">popTypeContext</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">oldIsType</span><span class="s1">);</span>
  <span class="s1">}</span>
<span class="s1">} </span><span class="s2">exports</span><span class="s1">.</span><span class="s2">parsePostMemberNameModifiers </span><span class="s1">= </span><span class="s2">parsePostMemberNameModifiers</span><span class="s1">;</span>

 <span class="s3">function </span><span class="s2">parseClassProperty</span><span class="s1">() {</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">_base</span><span class="s1">.</span><span class="s2">isTypeScriptEnabled</span><span class="s1">) {</span>
    <span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">eatTypeToken</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">bang</span><span class="s1">);</span>
    <span class="s2">_typescript</span><span class="s1">.</span><span class="s2">tsTryParseTypeAnnotation</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s2">_base</span><span class="s1">.</span><span class="s2">isFlowEnabled</span><span class="s1">) {</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">match</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">colon</span><span class="s1">)) {</span>
      <span class="s2">_flow</span><span class="s1">.</span><span class="s2">flowParseTypeAnnotation</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(</span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">match</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">eq</span><span class="s1">)) {</span>
    <span class="s3">const </span><span class="s2">equalsTokenIndex </span><span class="s1">= </span><span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">length</span><span class="s1">;</span>
    <span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">next</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
    <span class="s2">_expression</span><span class="s1">.</span><span class="s2">parseMaybeAssign</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
    <span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">[</span><span class="s2">equalsTokenIndex</span><span class="s1">].</span><span class="s2">rhsEndIndex </span><span class="s1">= </span><span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">length</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s2">_util</span><span class="s1">.</span><span class="s2">semicolon</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
<span class="s1">} </span><span class="s2">exports</span><span class="s1">.</span><span class="s2">parseClassProperty </span><span class="s1">= </span><span class="s2">parseClassProperty</span><span class="s1">;</span>

<span class="s3">function </span><span class="s2">parseClassId</span><span class="s1">(</span><span class="s2">isStatement</span><span class="s1">, </span><span class="s2">optionalId </span><span class="s1">= </span><span class="s3">false</span><span class="s1">) {</span>
  <span class="s3">if </span><span class="s1">(</span>
    <span class="s2">_base</span><span class="s1">.</span><span class="s2">isTypeScriptEnabled </span><span class="s1">&amp;&amp;</span>
    <span class="s1">(!</span><span class="s2">isStatement </span><span class="s1">|| </span><span class="s2">optionalId</span><span class="s1">) &amp;&amp;</span>
    <span class="s2">_util</span><span class="s1">.</span><span class="s2">isContextual</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_keywords</span><span class="s1">.</span><span class="s2">ContextualKeyword</span><span class="s1">.</span><span class="s2">_implements</span><span class="s1">)</span>
  <span class="s1">) {</span>
    <span class="s3">return</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(</span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">match</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">name</span><span class="s1">)) {</span>
    <span class="s2">_lval</span><span class="s1">.</span><span class="s2">parseBindingIdentifier</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s3">true</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(</span><span class="s2">_base</span><span class="s1">.</span><span class="s2">isTypeScriptEnabled</span><span class="s1">) {</span>
    <span class="s2">_typescript</span><span class="s1">.</span><span class="s2">tsTryParseTypeParameters</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s2">_base</span><span class="s1">.</span><span class="s2">isFlowEnabled</span><span class="s1">) {</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">match</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">lessThan</span><span class="s1">)) {</span>
      <span class="s2">_flow</span><span class="s1">.</span><span class="s2">flowParseTypeParameterDeclaration</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s4">// Returns true if there was a superclass.</span>
<span class="s3">function </span><span class="s2">parseClassSuper</span><span class="s1">() {</span>
  <span class="s3">let </span><span class="s2">hasSuper </span><span class="s1">= </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">eat</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_extends</span><span class="s1">)) {</span>
    <span class="s2">_expression</span><span class="s1">.</span><span class="s2">parseExprSubscripts</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
    <span class="s2">hasSuper </span><span class="s1">= </span><span class="s3">true</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s2">hasSuper </span><span class="s1">= </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">_base</span><span class="s1">.</span><span class="s2">isTypeScriptEnabled</span><span class="s1">) {</span>
    <span class="s2">_typescript</span><span class="s1">.</span><span class="s2">tsAfterParseClassSuper</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">hasSuper</span><span class="s1">);</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s2">_base</span><span class="s1">.</span><span class="s2">isFlowEnabled</span><span class="s1">) {</span>
    <span class="s2">_flow</span><span class="s1">.</span><span class="s2">flowAfterParseClassSuper</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">hasSuper</span><span class="s1">);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s4">// Parses module export declaration.</span>

 <span class="s3">function </span><span class="s2">parseExport</span><span class="s1">() {</span>
  <span class="s3">const </span><span class="s2">exportIndex </span><span class="s1">= </span><span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">length </span><span class="s1">- </span><span class="s5">1</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">_base</span><span class="s1">.</span><span class="s2">isTypeScriptEnabled</span><span class="s1">) {</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s2">_typescript</span><span class="s1">.</span><span class="s2">tsTryParseExport</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, )) {</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s4">// export * from '...'</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">shouldParseExportStar</span><span class="s1">()) {</span>
    <span class="s2">parseExportStar</span><span class="s1">();</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s2">isExportDefaultSpecifier</span><span class="s1">()) {</span>
    <span class="s4">// export default from</span>
    <span class="s2">_expression</span><span class="s1">.</span><span class="s2">parseIdentifier</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">match</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">comma</span><span class="s1">) &amp;&amp; </span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">lookaheadType</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, ) === </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">star</span><span class="s1">) {</span>
      <span class="s2">_util</span><span class="s1">.</span><span class="s2">expect</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">comma</span><span class="s1">);</span>
      <span class="s2">_util</span><span class="s1">.</span><span class="s2">expect</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">star</span><span class="s1">);</span>
      <span class="s2">_util</span><span class="s1">.</span><span class="s2">expectContextual</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_keywords</span><span class="s1">.</span><span class="s2">ContextualKeyword</span><span class="s1">.</span><span class="s2">_as</span><span class="s1">);</span>
      <span class="s2">_expression</span><span class="s1">.</span><span class="s2">parseIdentifier</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s2">parseExportSpecifiersMaybe</span><span class="s1">();</span>
    <span class="s1">}</span>
    <span class="s2">parseExportFrom</span><span class="s1">();</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">eat</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_default</span><span class="s1">)) {</span>
    <span class="s4">// export default ...</span>
    <span class="s2">parseExportDefaultExpression</span><span class="s1">();</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s2">shouldParseExportDeclaration</span><span class="s1">()) {</span>
    <span class="s2">parseExportDeclaration</span><span class="s1">();</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s4">// export { x, y as z } [from '...']</span>
    <span class="s2">parseExportSpecifiers</span><span class="s1">();</span>
    <span class="s2">parseExportFrom</span><span class="s1">();</span>
  <span class="s1">}</span>
  <span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">[</span><span class="s2">exportIndex</span><span class="s1">].</span><span class="s2">rhsEndIndex </span><span class="s1">= </span><span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">length</span><span class="s1">;</span>
<span class="s1">} </span><span class="s2">exports</span><span class="s1">.</span><span class="s2">parseExport </span><span class="s1">= </span><span class="s2">parseExport</span><span class="s1">;</span>

<span class="s3">function </span><span class="s2">parseExportDefaultExpression</span><span class="s1">() {</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">_base</span><span class="s1">.</span><span class="s2">isTypeScriptEnabled</span><span class="s1">) {</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s2">_typescript</span><span class="s1">.</span><span class="s2">tsTryParseExportDefaultExpression</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, )) {</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">_base</span><span class="s1">.</span><span class="s2">isFlowEnabled</span><span class="s1">) {</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s2">_flow</span><span class="s1">.</span><span class="s2">flowTryParseExportDefaultExpression</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, )) {</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">const </span><span class="s2">functionStart </span><span class="s1">= </span><span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">start</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">eat</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_function</span><span class="s1">)) {</span>
    <span class="s2">parseFunction</span><span class="s1">(</span><span class="s2">functionStart</span><span class="s1">, </span><span class="s3">true</span><span class="s1">, </span><span class="s3">true</span><span class="s1">);</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s2">_util</span><span class="s1">.</span><span class="s2">isContextual</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_keywords</span><span class="s1">.</span><span class="s2">ContextualKeyword</span><span class="s1">.</span><span class="s2">_async</span><span class="s1">) &amp;&amp; </span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">lookaheadType</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, ) === </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_function</span><span class="s1">) {</span>
    <span class="s4">// async function declaration</span>
    <span class="s2">_util</span><span class="s1">.</span><span class="s2">eatContextual</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_keywords</span><span class="s1">.</span><span class="s2">ContextualKeyword</span><span class="s1">.</span><span class="s2">_async</span><span class="s1">);</span>
    <span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">eat</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_function</span><span class="s1">);</span>
    <span class="s2">parseFunction</span><span class="s1">(</span><span class="s2">functionStart</span><span class="s1">, </span><span class="s3">true</span><span class="s1">, </span><span class="s3">true</span><span class="s1">);</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">match</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_class</span><span class="s1">)) {</span>
    <span class="s2">parseClass</span><span class="s1">(</span><span class="s3">true</span><span class="s1">, </span><span class="s3">true</span><span class="s1">);</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">match</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">at</span><span class="s1">)) {</span>
    <span class="s2">parseDecorators</span><span class="s1">();</span>
    <span class="s2">parseClass</span><span class="s1">(</span><span class="s3">true</span><span class="s1">, </span><span class="s3">true</span><span class="s1">);</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s2">_expression</span><span class="s1">.</span><span class="s2">parseMaybeAssign</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
    <span class="s2">_util</span><span class="s1">.</span><span class="s2">semicolon</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s2">parseExportDeclaration</span><span class="s1">() {</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">_base</span><span class="s1">.</span><span class="s2">isTypeScriptEnabled</span><span class="s1">) {</span>
    <span class="s2">_typescript</span><span class="s1">.</span><span class="s2">tsParseExportDeclaration</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s2">_base</span><span class="s1">.</span><span class="s2">isFlowEnabled</span><span class="s1">) {</span>
    <span class="s2">_flow</span><span class="s1">.</span><span class="s2">flowParseExportDeclaration</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s2">parseStatement</span><span class="s1">(</span><span class="s3">true</span><span class="s1">);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s2">isExportDefaultSpecifier</span><span class="s1">() {</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">_base</span><span class="s1">.</span><span class="s2">isTypeScriptEnabled </span><span class="s1">&amp;&amp; </span><span class="s2">_typescript</span><span class="s1">.</span><span class="s2">tsIsDeclarationStart</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, )) {</span>
    <span class="s3">return false</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s2">_base</span><span class="s1">.</span><span class="s2">isFlowEnabled </span><span class="s1">&amp;&amp; </span><span class="s2">_flow</span><span class="s1">.</span><span class="s2">flowShouldDisallowExportDefaultSpecifier</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, )) {</span>
    <span class="s3">return false</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">match</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">name</span><span class="s1">)) {</span>
    <span class="s3">return </span><span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">contextualKeyword </span><span class="s1">!== </span><span class="s2">_keywords</span><span class="s1">.</span><span class="s2">ContextualKeyword</span><span class="s1">.</span><span class="s2">_async</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(!</span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">match</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_default</span><span class="s1">)) {</span>
    <span class="s3">return false</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">const </span><span class="s2">_next </span><span class="s1">= </span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">nextTokenStart</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
  <span class="s3">const </span><span class="s2">lookahead </span><span class="s1">= </span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">lookaheadTypeAndKeyword</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
  <span class="s3">const </span><span class="s2">hasFrom </span><span class="s1">=</span>
    <span class="s2">lookahead</span><span class="s1">.</span><span class="s2">type </span><span class="s1">=== </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">name </span><span class="s1">&amp;&amp; </span><span class="s2">lookahead</span><span class="s1">.</span><span class="s2">contextualKeyword </span><span class="s1">=== </span><span class="s2">_keywords</span><span class="s1">.</span><span class="s2">ContextualKeyword</span><span class="s1">.</span><span class="s2">_from</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">lookahead</span><span class="s1">.</span><span class="s2">type </span><span class="s1">=== </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">comma</span><span class="s1">) {</span>
    <span class="s3">return true</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s4">// lookahead again when `export default from` is seen</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">hasFrom</span><span class="s1">) {</span>
    <span class="s3">const </span><span class="s2">nextAfterFrom </span><span class="s1">= </span><span class="s2">_base</span><span class="s1">.</span><span class="s2">input</span><span class="s1">.</span><span class="s2">charCodeAt</span><span class="s1">(</span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">nextTokenStartSince</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_next </span><span class="s1">+ </span><span class="s5">4</span><span class="s1">));</span>
    <span class="s3">return </span><span class="s2">nextAfterFrom </span><span class="s1">=== </span><span class="s2">_charcodes</span><span class="s1">.</span><span class="s2">charCodes</span><span class="s1">.</span><span class="s2">quotationMark </span><span class="s1">|| </span><span class="s2">nextAfterFrom </span><span class="s1">=== </span><span class="s2">_charcodes</span><span class="s1">.</span><span class="s2">charCodes</span><span class="s1">.</span><span class="s2">apostrophe</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">return false</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s2">parseExportSpecifiersMaybe</span><span class="s1">() {</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">eat</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">comma</span><span class="s1">)) {</span>
    <span class="s2">parseExportSpecifiers</span><span class="s1">();</span>
  <span class="s1">}</span>
<span class="s1">}</span>

 <span class="s3">function </span><span class="s2">parseExportFrom</span><span class="s1">() {</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">_util</span><span class="s1">.</span><span class="s2">eatContextual</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_keywords</span><span class="s1">.</span><span class="s2">ContextualKeyword</span><span class="s1">.</span><span class="s2">_from</span><span class="s1">)) {</span>
    <span class="s2">_expression</span><span class="s1">.</span><span class="s2">parseExprAtom</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
    <span class="s2">maybeParseImportAttributes</span><span class="s1">();</span>
  <span class="s1">}</span>
  <span class="s2">_util</span><span class="s1">.</span><span class="s2">semicolon</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
<span class="s1">} </span><span class="s2">exports</span><span class="s1">.</span><span class="s2">parseExportFrom </span><span class="s1">= </span><span class="s2">parseExportFrom</span><span class="s1">;</span>

<span class="s3">function </span><span class="s2">shouldParseExportStar</span><span class="s1">() {</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">_base</span><span class="s1">.</span><span class="s2">isFlowEnabled</span><span class="s1">) {</span>
    <span class="s3">return </span><span class="s2">_flow</span><span class="s1">.</span><span class="s2">flowShouldParseExportStar</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s3">return </span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">match</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">star</span><span class="s1">);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s2">parseExportStar</span><span class="s1">() {</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">_base</span><span class="s1">.</span><span class="s2">isFlowEnabled</span><span class="s1">) {</span>
    <span class="s2">_flow</span><span class="s1">.</span><span class="s2">flowParseExportStar</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s2">baseParseExportStar</span><span class="s1">();</span>
  <span class="s1">}</span>
<span class="s1">}</span>

 <span class="s3">function </span><span class="s2">baseParseExportStar</span><span class="s1">() {</span>
  <span class="s2">_util</span><span class="s1">.</span><span class="s2">expect</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">star</span><span class="s1">);</span>

  <span class="s3">if </span><span class="s1">(</span><span class="s2">_util</span><span class="s1">.</span><span class="s2">isContextual</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_keywords</span><span class="s1">.</span><span class="s2">ContextualKeyword</span><span class="s1">.</span><span class="s2">_as</span><span class="s1">)) {</span>
    <span class="s2">parseExportNamespace</span><span class="s1">();</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s2">parseExportFrom</span><span class="s1">();</span>
  <span class="s1">}</span>
<span class="s1">} </span><span class="s2">exports</span><span class="s1">.</span><span class="s2">baseParseExportStar </span><span class="s1">= </span><span class="s2">baseParseExportStar</span><span class="s1">;</span>

<span class="s3">function </span><span class="s2">parseExportNamespace</span><span class="s1">() {</span>
  <span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">next</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
  <span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">[</span><span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">length </span><span class="s1">- </span><span class="s5">1</span><span class="s1">].</span><span class="s2">type </span><span class="s1">= </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_as</span><span class="s1">;</span>
  <span class="s2">_expression</span><span class="s1">.</span><span class="s2">parseIdentifier</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
  <span class="s2">parseExportSpecifiersMaybe</span><span class="s1">();</span>
  <span class="s2">parseExportFrom</span><span class="s1">();</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s2">shouldParseExportDeclaration</span><span class="s1">() {</span>
  <span class="s3">return </span><span class="s1">(</span>
    <span class="s1">(</span><span class="s2">_base</span><span class="s1">.</span><span class="s2">isTypeScriptEnabled </span><span class="s1">&amp;&amp; </span><span class="s2">_typescript</span><span class="s1">.</span><span class="s2">tsIsDeclarationStart</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, )) ||</span>
    <span class="s1">(</span><span class="s2">_base</span><span class="s1">.</span><span class="s2">isFlowEnabled </span><span class="s1">&amp;&amp; </span><span class="s2">_flow</span><span class="s1">.</span><span class="s2">flowShouldParseExportDeclaration</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, )) ||</span>
    <span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">type </span><span class="s1">=== </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_var </span><span class="s1">||</span>
    <span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">type </span><span class="s1">=== </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_const </span><span class="s1">||</span>
    <span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">type </span><span class="s1">=== </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_let </span><span class="s1">||</span>
    <span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">type </span><span class="s1">=== </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_function </span><span class="s1">||</span>
    <span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">type </span><span class="s1">=== </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_class </span><span class="s1">||</span>
    <span class="s2">_util</span><span class="s1">.</span><span class="s2">isContextual</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_keywords</span><span class="s1">.</span><span class="s2">ContextualKeyword</span><span class="s1">.</span><span class="s2">_async</span><span class="s1">) ||</span>
    <span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">match</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">at</span><span class="s1">)</span>
  <span class="s1">);</span>
<span class="s1">}</span>

<span class="s4">// Parses a comma-separated list of module exports.</span>
 <span class="s3">function </span><span class="s2">parseExportSpecifiers</span><span class="s1">() {</span>
  <span class="s3">let </span><span class="s2">first </span><span class="s1">= </span><span class="s3">true</span><span class="s1">;</span>

  <span class="s4">// export { x, y as z } [from '...']</span>
  <span class="s2">_util</span><span class="s1">.</span><span class="s2">expect</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">braceL</span><span class="s1">);</span>

  <span class="s3">while </span><span class="s1">(!</span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">eat</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">braceR</span><span class="s1">) &amp;&amp; !</span><span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">error</span><span class="s1">) {</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s2">first</span><span class="s1">) {</span>
      <span class="s2">first </span><span class="s1">= </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s2">_util</span><span class="s1">.</span><span class="s2">expect</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">comma</span><span class="s1">);</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">eat</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">braceR</span><span class="s1">)) {</span>
        <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">parseExportSpecifier</span><span class="s1">();</span>
  <span class="s1">}</span>
<span class="s1">} </span><span class="s2">exports</span><span class="s1">.</span><span class="s2">parseExportSpecifiers </span><span class="s1">= </span><span class="s2">parseExportSpecifiers</span><span class="s1">;</span>

<span class="s3">function </span><span class="s2">parseExportSpecifier</span><span class="s1">() {</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">_base</span><span class="s1">.</span><span class="s2">isTypeScriptEnabled</span><span class="s1">) {</span>
    <span class="s2">_typescript</span><span class="s1">.</span><span class="s2">tsParseExportSpecifier</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
    <span class="s3">return</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s2">_expression</span><span class="s1">.</span><span class="s2">parseIdentifier</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
  <span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">[</span><span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">length </span><span class="s1">- </span><span class="s5">1</span><span class="s1">].</span><span class="s2">identifierRole </span><span class="s1">= </span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">IdentifierRole</span><span class="s1">.</span><span class="s2">ExportAccess</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">_util</span><span class="s1">.</span><span class="s2">eatContextual</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_keywords</span><span class="s1">.</span><span class="s2">ContextualKeyword</span><span class="s1">.</span><span class="s2">_as</span><span class="s1">)) {</span>
    <span class="s2">_expression</span><span class="s1">.</span><span class="s2">parseIdentifier</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s6">/**</span>
 <span class="s6">* Starting at the `module` token in an import, determine if it was truly an</span>
 <span class="s6">* import reflection token or just looks like one.</span>
 <span class="s6">*</span>
 <span class="s6">* Returns true for:</span>
 <span class="s6">* import module foo from &quot;foo&quot;;</span>
 <span class="s6">* import module from from &quot;foo&quot;;</span>
 <span class="s6">*</span>
 <span class="s6">* Returns false for:</span>
 <span class="s6">* import module from &quot;foo&quot;;</span>
 <span class="s6">* import module, {bar} from &quot;foo&quot;;</span>
 <span class="s6">*/</span>
<span class="s3">function </span><span class="s2">isImportReflection</span><span class="s1">() {</span>
  <span class="s3">const </span><span class="s2">snapshot </span><span class="s1">= </span><span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">snapshot</span><span class="s1">();</span>
  <span class="s2">_util</span><span class="s1">.</span><span class="s2">expectContextual</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_keywords</span><span class="s1">.</span><span class="s2">ContextualKeyword</span><span class="s1">.</span><span class="s2">_module</span><span class="s1">);</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">_util</span><span class="s1">.</span><span class="s2">eatContextual</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_keywords</span><span class="s1">.</span><span class="s2">ContextualKeyword</span><span class="s1">.</span><span class="s2">_from</span><span class="s1">)) {</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s2">_util</span><span class="s1">.</span><span class="s2">isContextual</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_keywords</span><span class="s1">.</span><span class="s2">ContextualKeyword</span><span class="s1">.</span><span class="s2">_from</span><span class="s1">)) {</span>
      <span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">restoreFromSnapshot</span><span class="s1">(</span><span class="s2">snapshot</span><span class="s1">);</span>
      <span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">restoreFromSnapshot</span><span class="s1">(</span><span class="s2">snapshot</span><span class="s1">);</span>
      <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">match</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">comma</span><span class="s1">)) {</span>
    <span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">restoreFromSnapshot</span><span class="s1">(</span><span class="s2">snapshot</span><span class="s1">);</span>
    <span class="s3">return false</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">restoreFromSnapshot</span><span class="s1">(</span><span class="s2">snapshot</span><span class="s1">);</span>
    <span class="s3">return true</span><span class="s1">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s6">/**</span>
 <span class="s6">* Eat the &quot;module&quot; token from the import reflection proposal.</span>
 <span class="s6">* https://github.com/tc39/proposal-import-reflection</span>
 <span class="s6">*/</span>
<span class="s3">function </span><span class="s2">parseMaybeImportReflection</span><span class="s1">() {</span>
  <span class="s4">// isImportReflection does snapshot/restore, so only run it if we see the word</span>
  <span class="s4">// &quot;module&quot;.</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">_util</span><span class="s1">.</span><span class="s2">isContextual</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_keywords</span><span class="s1">.</span><span class="s2">ContextualKeyword</span><span class="s1">.</span><span class="s2">_module</span><span class="s1">) &amp;&amp; </span><span class="s2">isImportReflection</span><span class="s1">()) {</span>
    <span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">next</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s4">// Parses import declaration.</span>

 <span class="s3">function </span><span class="s2">parseImport</span><span class="s1">() {</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">_base</span><span class="s1">.</span><span class="s2">isTypeScriptEnabled </span><span class="s1">&amp;&amp; </span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">match</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">name</span><span class="s1">) &amp;&amp; </span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">lookaheadType</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, ) === </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">eq</span><span class="s1">) {</span>
    <span class="s2">_typescript</span><span class="s1">.</span><span class="s2">tsParseImportEqualsDeclaration</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
    <span class="s3">return</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">_base</span><span class="s1">.</span><span class="s2">isTypeScriptEnabled </span><span class="s1">&amp;&amp; </span><span class="s2">_util</span><span class="s1">.</span><span class="s2">isContextual</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_keywords</span><span class="s1">.</span><span class="s2">ContextualKeyword</span><span class="s1">.</span><span class="s2">_type</span><span class="s1">)) {</span>
    <span class="s3">const </span><span class="s2">lookahead </span><span class="s1">= </span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">lookaheadTypeAndKeyword</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s2">lookahead</span><span class="s1">.</span><span class="s2">type </span><span class="s1">=== </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">name </span><span class="s1">&amp;&amp; </span><span class="s2">lookahead</span><span class="s1">.</span><span class="s2">contextualKeyword </span><span class="s1">!== </span><span class="s2">_keywords</span><span class="s1">.</span><span class="s2">ContextualKeyword</span><span class="s1">.</span><span class="s2">_from</span><span class="s1">) {</span>
      <span class="s4">// One of these `import type` cases:</span>
      <span class="s4">// import type T = require('T');</span>
      <span class="s4">// import type A from 'A';</span>
      <span class="s2">_util</span><span class="s1">.</span><span class="s2">expectContextual</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_keywords</span><span class="s1">.</span><span class="s2">ContextualKeyword</span><span class="s1">.</span><span class="s2">_type</span><span class="s1">);</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">lookaheadType</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, ) === </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">eq</span><span class="s1">) {</span>
        <span class="s2">_typescript</span><span class="s1">.</span><span class="s2">tsParseImportEqualsDeclaration</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s4">// If this is an `import type...from` statement, then we already ate the</span>
      <span class="s4">// type token, so proceed to the regular import parser.</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s2">lookahead</span><span class="s1">.</span><span class="s2">type </span><span class="s1">=== </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">star </span><span class="s1">|| </span><span class="s2">lookahead</span><span class="s1">.</span><span class="s2">type </span><span class="s1">=== </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">braceL</span><span class="s1">) {</span>
      <span class="s4">// One of these `import type` cases, in which case we can eat the type token</span>
      <span class="s4">// and proceed as normal:</span>
      <span class="s4">// import type * as A from 'A';</span>
      <span class="s4">// import type {a} from 'A';</span>
      <span class="s2">_util</span><span class="s1">.</span><span class="s2">expectContextual</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_keywords</span><span class="s1">.</span><span class="s2">ContextualKeyword</span><span class="s1">.</span><span class="s2">_type</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s4">// Otherwise, we are importing the name &quot;type&quot;.</span>
  <span class="s1">}</span>

  <span class="s4">// import '...'</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">match</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">string</span><span class="s1">)) {</span>
    <span class="s2">_expression</span><span class="s1">.</span><span class="s2">parseExprAtom</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s2">parseMaybeImportReflection</span><span class="s1">();</span>
    <span class="s2">parseImportSpecifiers</span><span class="s1">();</span>
    <span class="s2">_util</span><span class="s1">.</span><span class="s2">expectContextual</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_keywords</span><span class="s1">.</span><span class="s2">ContextualKeyword</span><span class="s1">.</span><span class="s2">_from</span><span class="s1">);</span>
    <span class="s2">_expression</span><span class="s1">.</span><span class="s2">parseExprAtom</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
  <span class="s1">}</span>
  <span class="s2">maybeParseImportAttributes</span><span class="s1">();</span>
  <span class="s2">_util</span><span class="s1">.</span><span class="s2">semicolon</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
<span class="s1">} </span><span class="s2">exports</span><span class="s1">.</span><span class="s2">parseImport </span><span class="s1">= </span><span class="s2">parseImport</span><span class="s1">;</span>

<span class="s4">// eslint-disable-next-line no-unused-vars</span>
<span class="s3">function </span><span class="s2">shouldParseDefaultImport</span><span class="s1">() {</span>
  <span class="s3">return </span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">match</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">name</span><span class="s1">);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s2">parseImportSpecifierLocal</span><span class="s1">() {</span>
  <span class="s2">_lval</span><span class="s1">.</span><span class="s2">parseImportedIdentifier</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
<span class="s1">}</span>

<span class="s4">// Parses a comma-separated list of module imports.</span>
<span class="s3">function </span><span class="s2">parseImportSpecifiers</span><span class="s1">() {</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">_base</span><span class="s1">.</span><span class="s2">isFlowEnabled</span><span class="s1">) {</span>
    <span class="s2">_flow</span><span class="s1">.</span><span class="s2">flowStartParseImportSpecifiers</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
  <span class="s1">}</span>

  <span class="s3">let </span><span class="s2">first </span><span class="s1">= </span><span class="s3">true</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">shouldParseDefaultImport</span><span class="s1">()) {</span>
    <span class="s4">// import defaultObj, { x, y as z } from '...'</span>
    <span class="s2">parseImportSpecifierLocal</span><span class="s1">();</span>

    <span class="s3">if </span><span class="s1">(!</span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">eat</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">comma</span><span class="s1">)) </span><span class="s3">return</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(</span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">match</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">star</span><span class="s1">)) {</span>
    <span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">next</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
    <span class="s2">_util</span><span class="s1">.</span><span class="s2">expectContextual</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_keywords</span><span class="s1">.</span><span class="s2">ContextualKeyword</span><span class="s1">.</span><span class="s2">_as</span><span class="s1">);</span>

    <span class="s2">parseImportSpecifierLocal</span><span class="s1">();</span>

    <span class="s3">return</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">_util</span><span class="s1">.</span><span class="s2">expect</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">braceL</span><span class="s1">);</span>
  <span class="s3">while </span><span class="s1">(!</span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">eat</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">braceR</span><span class="s1">) &amp;&amp; !</span><span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">error</span><span class="s1">) {</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s2">first</span><span class="s1">) {</span>
      <span class="s2">first </span><span class="s1">= </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s4">// Detect an attempt to deep destructure</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">eat</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">colon</span><span class="s1">)) {</span>
        <span class="s2">_util</span><span class="s1">.</span><span class="s2">unexpected</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span>
          <span class="s0">&quot;ES2015 named imports do not destructure. Use another statement for destructuring after the import.&quot;</span><span class="s1">,</span>
        <span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s2">_util</span><span class="s1">.</span><span class="s2">expect</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">comma</span><span class="s1">);</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">eat</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">braceR</span><span class="s1">)) {</span>
        <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">parseImportSpecifier</span><span class="s1">();</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s2">parseImportSpecifier</span><span class="s1">() {</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">_base</span><span class="s1">.</span><span class="s2">isTypeScriptEnabled</span><span class="s1">) {</span>
    <span class="s2">_typescript</span><span class="s1">.</span><span class="s2">tsParseImportSpecifier</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
    <span class="s3">return</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">_base</span><span class="s1">.</span><span class="s2">isFlowEnabled</span><span class="s1">) {</span>
    <span class="s2">_flow</span><span class="s1">.</span><span class="s2">flowParseImportSpecifier</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
    <span class="s3">return</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s2">_lval</span><span class="s1">.</span><span class="s2">parseImportedIdentifier</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">_util</span><span class="s1">.</span><span class="s2">isContextual</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_keywords</span><span class="s1">.</span><span class="s2">ContextualKeyword</span><span class="s1">.</span><span class="s2">_as</span><span class="s1">)) {</span>
    <span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">[</span><span class="s2">_base</span><span class="s1">.</span><span class="s2">state</span><span class="s1">.</span><span class="s2">tokens</span><span class="s1">.</span><span class="s2">length </span><span class="s1">- </span><span class="s5">1</span><span class="s1">].</span><span class="s2">identifierRole </span><span class="s1">= </span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">IdentifierRole</span><span class="s1">.</span><span class="s2">ImportAccess</span><span class="s1">;</span>
    <span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">next</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
    <span class="s2">_lval</span><span class="s1">.</span><span class="s2">parseImportedIdentifier</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s6">/**</span>
 <span class="s6">* Parse import attributes like `with {type: &quot;json&quot;}`, or the legacy form</span>
 <span class="s6">* `assert {type: &quot;json&quot;}`.</span>
 <span class="s6">*</span>
 <span class="s6">* Import attributes technically have their own syntax, but are always parseable</span>
 <span class="s6">* as a plain JS object, so just do that for simplicity.</span>
 <span class="s6">*/</span>
<span class="s3">function </span><span class="s2">maybeParseImportAttributes</span><span class="s1">() {</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">match</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_types</span><span class="s1">.</span><span class="s2">TokenType</span><span class="s1">.</span><span class="s2">_with</span><span class="s1">) || (</span><span class="s2">_util</span><span class="s1">.</span><span class="s2">isContextual</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s2">_keywords</span><span class="s1">.</span><span class="s2">ContextualKeyword</span><span class="s1">.</span><span class="s2">_assert</span><span class="s1">) &amp;&amp; !</span><span class="s2">_util</span><span class="s1">.</span><span class="s2">hasPrecedingLineBreak</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, ))) {</span>
    <span class="s2">_tokenizer</span><span class="s1">.</span><span class="s2">next</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, );</span>
    <span class="s2">_expression</span><span class="s1">.</span><span class="s2">parseObj</span><span class="s1">.</span><span class="s2">call</span><span class="s1">(</span><span class="s3">void </span><span class="s5">0</span><span class="s1">, </span><span class="s3">false</span><span class="s1">, </span><span class="s3">false</span><span class="s1">);</span>
  <span class="s1">}</span>
<span class="s1">}</span>
</pre>
</body>
</html>