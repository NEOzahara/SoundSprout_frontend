<html>
<head>
<title>statements.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
statements.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_t&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;_index&quot;</span><span class="s0">,</span><span class="s1">&quot;isFor&quot;</span><span class="s0">,</span><span class="s1">&quot;isForStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;isIfStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;isStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;WithStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;word&quot;</span><span class="s0">,</span><span class="s1">&quot;space&quot;</span><span class="s0">,</span><span class="s1">&quot;token&quot;</span><span class="s0">,</span><span class="s1">&quot;print&quot;</span><span class="s0">,</span><span class="s1">&quot;object&quot;</span><span class="s0">,</span><span class="s1">&quot;printBlock&quot;</span><span class="s0">,</span><span class="s1">&quot;IfStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;test&quot;</span><span class="s0">,</span><span class="s1">&quot;needsBlock&quot;</span><span class="s0">,</span><span class="s1">&quot;alternate&quot;</span><span class="s0">,</span><span class="s1">&quot;getLastStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;consequent&quot;</span><span class="s0">,</span><span class="s1">&quot;newline&quot;</span><span class="s0">,</span><span class="s1">&quot;indent&quot;</span><span class="s0">,</span><span class="s1">&quot;printAndIndentOnComments&quot;</span><span class="s0">,</span><span class="s1">&quot;dedent&quot;</span><span class="s0">,</span><span class="s1">&quot;endsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;statement&quot;</span><span class="s0">,</span><span class="s1">&quot;body&quot;</span><span class="s0">,</span><span class="s1">&quot;ForStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;exit&quot;</span><span class="s0">,</span><span class="s1">&quot;enterForStatementInit&quot;</span><span class="s0">,</span><span class="s1">&quot;tokenContext&quot;</span><span class="s0">,</span><span class="s1">&quot;TokenContext&quot;</span><span class="s0">,</span><span class="s1">&quot;forHead&quot;</span><span class="s0">,</span><span class="s1">&quot;init&quot;</span><span class="s0">,</span><span class="s1">&quot;update&quot;</span><span class="s0">,</span><span class="s1">&quot;WhileStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;ForXStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;isForOf&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;await&quot;</span><span class="s0">,</span><span class="s1">&quot;noIndentInnerCommentsHere&quot;</span><span class="s0">,</span><span class="s1">&quot;forOfHead&quot;</span><span class="s0">,</span><span class="s1">&quot;forInHead&quot;</span><span class="s0">,</span><span class="s1">&quot;left&quot;</span><span class="s0">,</span><span class="s1">&quot;right&quot;</span><span class="s0">,</span><span class="s1">&quot;ForInStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;exports&quot;</span><span class="s0">,</span><span class="s1">&quot;ForOfStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;DoWhileStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;semicolon&quot;</span><span class="s0">,</span><span class="s1">&quot;printStatementAfterKeyword&quot;</span><span class="s0">,</span><span class="s1">&quot;printer&quot;</span><span class="s0">,</span><span class="s1">&quot;printTerminatorless&quot;</span><span class="s0">,</span><span class="s1">&quot;BreakStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;label&quot;</span><span class="s0">,</span><span class="s1">&quot;ContinueStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;ReturnStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;argument&quot;</span><span class="s0">,</span><span class="s1">&quot;ThrowStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;LabeledStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;TryStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;block&quot;</span><span class="s0">,</span><span class="s1">&quot;handlers&quot;</span><span class="s0">,</span><span class="s1">&quot;handler&quot;</span><span class="s0">,</span><span class="s1">&quot;finalizer&quot;</span><span class="s0">,</span><span class="s1">&quot;CatchClause&quot;</span><span class="s0">,</span><span class="s1">&quot;param&quot;</span><span class="s0">,</span><span class="s1">&quot;typeAnnotation&quot;</span><span class="s0">,</span><span class="s1">&quot;SwitchStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;discriminant&quot;</span><span class="s0">,</span><span class="s1">&quot;printSequence&quot;</span><span class="s0">,</span><span class="s1">&quot;cases&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;addNewlines&quot;</span><span class="s0">,</span><span class="s1">&quot;leading&quot;</span><span class="s0">,</span><span class="s1">&quot;cas&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;rightBrace&quot;</span><span class="s0">,</span><span class="s1">&quot;SwitchCase&quot;</span><span class="s0">,</span><span class="s1">&quot;DebuggerStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;VariableDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;parent&quot;</span><span class="s0">,</span><span class="s1">&quot;declare&quot;</span><span class="s0">,</span><span class="s1">&quot;kind&quot;</span><span class="s0">,</span><span class="s1">&quot;hasInits&quot;</span><span class="s0">,</span><span class="s1">&quot;declar&quot;</span><span class="s0">,</span><span class="s1">&quot;declarations&quot;</span><span class="s0">,</span><span class="s1">&quot;printList&quot;</span><span class="s0">,</span><span class="s1">&quot;occurrenceCount&quot;</span><span class="s0">,</span><span class="s1">&quot;VariableDeclarator&quot;</span><span class="s0">,</span><span class="s1">&quot;id&quot;</span><span class="s0">,</span><span class="s1">&quot;definite&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../src/generators/statements.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type Printer from </span><span class="s3">\&quot;</span><span class="s1">../printer.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">isFor,</span><span class="s3">\n  </span><span class="s1">isForStatement,</span><span class="s3">\n  </span><span class="s1">isIfStatement,</span><span class="s3">\n  </span><span class="s1">isStatement,</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">@babel/types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type * as t from </span><span class="s3">\&quot;</span><span class="s1">@babel/types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">// We inline this package</span><span class="s3">\n</span><span class="s1">// eslint-disable-next-line import/no-extraneous-dependencies</span><span class="s3">\n</span><span class="s1">import * as charCodes from </span><span class="s3">\&quot;</span><span class="s1">charcodes</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { TokenContext } from </span><span class="s3">\&quot;</span><span class="s1">../node/index.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">export function WithStatement(this: Printer, node: t.WithStatement) {</span><span class="s3">\n  </span><span class="s1">this.word(</span><span class="s3">\&quot;</span><span class="s1">with</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">this.space();</span><span class="s3">\n  </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">this.print(node.object);</span><span class="s3">\n  </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">this.printBlock(node);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function IfStatement(this: Printer, node: t.IfStatement) {</span><span class="s3">\n  </span><span class="s1">this.word(</span><span class="s3">\&quot;</span><span class="s1">if</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">this.space();</span><span class="s3">\n  </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">this.print(node.test);</span><span class="s3">\n  </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">this.space();</span><span class="s3">\n\n  </span><span class="s1">const needsBlock =</span><span class="s3">\n    </span><span class="s1">node.alternate &amp;&amp; isIfStatement(getLastStatement(node.consequent));</span><span class="s3">\n  </span><span class="s1">if (needsBlock) {</span><span class="s3">\n    </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">{</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">this.newline();</span><span class="s3">\n    </span><span class="s1">this.indent();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">this.printAndIndentOnComments(node.consequent);</span><span class="s3">\n\n  </span><span class="s1">if (needsBlock) {</span><span class="s3">\n    </span><span class="s1">this.dedent();</span><span class="s3">\n    </span><span class="s1">this.newline();</span><span class="s3">\n    </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (node.alternate) {</span><span class="s3">\n    </span><span class="s1">if (this.endsWith(charCodes.rightCurlyBrace)) this.space();</span><span class="s3">\n    </span><span class="s1">this.word(</span><span class="s3">\&quot;</span><span class="s1">else</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">this.space();</span><span class="s3">\n    </span><span class="s1">this.printAndIndentOnComments(node.alternate);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Recursively get the last statement.</span><span class="s3">\n</span><span class="s1">function getLastStatement(statement: t.Statement): t.Statement {</span><span class="s3">\n  </span><span class="s1">// @ts-expect-error: If statement.body is empty or not a Node, isStatement will return false</span><span class="s3">\n  </span><span class="s1">const { body } = statement;</span><span class="s3">\n  </span><span class="s1">if (isStatement(body) === false) {</span><span class="s3">\n    </span><span class="s1">return statement;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return getLastStatement(body);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function ForStatement(this: Printer, node: t.ForStatement) {</span><span class="s3">\n  </span><span class="s1">this.word(</span><span class="s3">\&quot;</span><span class="s1">for</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">this.space();</span><span class="s3">\n  </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">const exit = this.enterForStatementInit();</span><span class="s3">\n    </span><span class="s1">this.tokenContext |= TokenContext.forHead;</span><span class="s3">\n    </span><span class="s1">this.print(node.init);</span><span class="s3">\n    </span><span class="s1">exit();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n  </span><span class="s1">if (node.test) {</span><span class="s3">\n    </span><span class="s1">this.space();</span><span class="s3">\n    </span><span class="s1">this.print(node.test);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\&quot;</span><span class="s1">, false, 1);</span><span class="s3">\n\n  </span><span class="s1">if (node.update) {</span><span class="s3">\n    </span><span class="s1">this.space();</span><span class="s3">\n    </span><span class="s1">this.print(node.update);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">this.printBlock(node);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function WhileStatement(this: Printer, node: t.WhileStatement) {</span><span class="s3">\n  </span><span class="s1">this.word(</span><span class="s3">\&quot;</span><span class="s1">while</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">this.space();</span><span class="s3">\n  </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">this.print(node.test);</span><span class="s3">\n  </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">this.printBlock(node);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function ForXStatement(this: Printer, node: t.ForXStatement) {</span><span class="s3">\n  </span><span class="s1">this.word(</span><span class="s3">\&quot;</span><span class="s1">for</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">this.space();</span><span class="s3">\n  </span><span class="s1">const isForOf = node.type === </span><span class="s3">\&quot;</span><span class="s1">ForOfStatement</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">if (isForOf &amp;&amp; node.await) {</span><span class="s3">\n    </span><span class="s1">this.word(</span><span class="s3">\&quot;</span><span class="s1">await</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">this.space();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">this.noIndentInnerCommentsHere();</span><span class="s3">\n  </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">const exit = isForOf ? null : this.enterForStatementInit();</span><span class="s3">\n    </span><span class="s1">this.tokenContext |= isForOf</span><span class="s3">\n      </span><span class="s1">? TokenContext.forOfHead</span><span class="s3">\n      </span><span class="s1">: TokenContext.forInHead;</span><span class="s3">\n    </span><span class="s1">this.print(node.left);</span><span class="s3">\n    </span><span class="s1">exit?.();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">this.space();</span><span class="s3">\n  </span><span class="s1">this.word(isForOf ? </span><span class="s3">\&quot;</span><span class="s1">of</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">in</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">this.space();</span><span class="s3">\n  </span><span class="s1">this.print(node.right);</span><span class="s3">\n  </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">this.printBlock(node);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export const ForInStatement = ForXStatement;</span><span class="s3">\n</span><span class="s1">export const ForOfStatement = ForXStatement;</span><span class="s3">\n\n</span><span class="s1">export function DoWhileStatement(this: Printer, node: t.DoWhileStatement) {</span><span class="s3">\n  </span><span class="s1">this.word(</span><span class="s3">\&quot;</span><span class="s1">do</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">this.space();</span><span class="s3">\n  </span><span class="s1">this.print(node.body);</span><span class="s3">\n  </span><span class="s1">this.space();</span><span class="s3">\n  </span><span class="s1">this.word(</span><span class="s3">\&quot;</span><span class="s1">while</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">this.space();</span><span class="s3">\n  </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">this.print(node.test);</span><span class="s3">\n  </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">this.semicolon();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function printStatementAfterKeyword(printer: Printer, node: t.Node) {</span><span class="s3">\n  </span><span class="s1">if (node) {</span><span class="s3">\n    </span><span class="s1">printer.space();</span><span class="s3">\n    </span><span class="s1">printer.printTerminatorless(node);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">printer.semicolon();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function BreakStatement(this: Printer, node: t.ContinueStatement) {</span><span class="s3">\n  </span><span class="s1">this.word(</span><span class="s3">\&quot;</span><span class="s1">break</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">printStatementAfterKeyword(this, node.label);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function ContinueStatement(this: Printer, node: t.ContinueStatement) {</span><span class="s3">\n  </span><span class="s1">this.word(</span><span class="s3">\&quot;</span><span class="s1">continue</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">printStatementAfterKeyword(this, node.label);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function ReturnStatement(this: Printer, node: t.ReturnStatement) {</span><span class="s3">\n  </span><span class="s1">this.word(</span><span class="s3">\&quot;</span><span class="s1">return</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">printStatementAfterKeyword(this, node.argument);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function ThrowStatement(this: Printer, node: t.ThrowStatement) {</span><span class="s3">\n  </span><span class="s1">this.word(</span><span class="s3">\&quot;</span><span class="s1">throw</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">printStatementAfterKeyword(this, node.argument);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function LabeledStatement(this: Printer, node: t.LabeledStatement) {</span><span class="s3">\n  </span><span class="s1">this.print(node.label);</span><span class="s3">\n  </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">this.space();</span><span class="s3">\n  </span><span class="s1">this.print(node.body);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function TryStatement(this: Printer, node: t.TryStatement) {</span><span class="s3">\n  </span><span class="s1">this.word(</span><span class="s3">\&quot;</span><span class="s1">try</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">this.space();</span><span class="s3">\n  </span><span class="s1">this.print(node.block);</span><span class="s3">\n  </span><span class="s1">this.space();</span><span class="s3">\n\n  </span><span class="s1">// Esprima bug puts the catch clause in a `handlers` array.</span><span class="s3">\n  </span><span class="s1">// see https://code.google.com/p/esprima/issues/detail?id=433</span><span class="s3">\n  </span><span class="s1">// We run into this from regenerator generated ast.</span><span class="s3">\n  </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts) should ast node type be updated to support this?</span><span class="s3">\n  </span><span class="s1">if (node.handlers) {</span><span class="s3">\n    </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts) should ast node type be updated to support this?</span><span class="s3">\n    </span><span class="s1">this.print(node.handlers[0]);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">this.print(node.handler);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (node.finalizer) {</span><span class="s3">\n    </span><span class="s1">this.space();</span><span class="s3">\n    </span><span class="s1">this.word(</span><span class="s3">\&quot;</span><span class="s1">finally</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">this.space();</span><span class="s3">\n    </span><span class="s1">this.print(node.finalizer);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function CatchClause(this: Printer, node: t.CatchClause) {</span><span class="s3">\n  </span><span class="s1">this.word(</span><span class="s3">\&quot;</span><span class="s1">catch</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">this.space();</span><span class="s3">\n  </span><span class="s1">if (node.param) {</span><span class="s3">\n    </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">this.print(node.param);</span><span class="s3">\n    </span><span class="s1">this.print(node.param.typeAnnotation);</span><span class="s3">\n    </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">this.space();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">this.print(node.body);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function SwitchStatement(this: Printer, node: t.SwitchStatement) {</span><span class="s3">\n  </span><span class="s1">this.word(</span><span class="s3">\&quot;</span><span class="s1">switch</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">this.space();</span><span class="s3">\n  </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">this.print(node.discriminant);</span><span class="s3">\n  </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">this.space();</span><span class="s3">\n  </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">{</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n  </span><span class="s1">this.printSequence(</span><span class="s3">\n    </span><span class="s1">node.cases,</span><span class="s3">\n    </span><span class="s1">true,</span><span class="s3">\n    </span><span class="s1">undefined,</span><span class="s3">\n    </span><span class="s1">function addNewlines(leading, cas) {</span><span class="s3">\n      </span><span class="s1">if (!leading &amp;&amp; node.cases[node.cases.length - 1] === cas) return -1;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n\n  </span><span class="s1">this.rightBrace(node);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function SwitchCase(this: Printer, node: t.SwitchCase) {</span><span class="s3">\n  </span><span class="s1">if (node.test) {</span><span class="s3">\n    </span><span class="s1">this.word(</span><span class="s3">\&quot;</span><span class="s1">case</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">this.space();</span><span class="s3">\n    </span><span class="s1">this.print(node.test);</span><span class="s3">\n    </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">this.word(</span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (node.consequent.length) {</span><span class="s3">\n    </span><span class="s1">this.newline();</span><span class="s3">\n    </span><span class="s1">this.printSequence(node.consequent, true);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function DebuggerStatement(this: Printer) {</span><span class="s3">\n  </span><span class="s1">this.word(</span><span class="s3">\&quot;</span><span class="s1">debugger</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">this.semicolon();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function VariableDeclaration(</span><span class="s3">\n  </span><span class="s1">this: Printer,</span><span class="s3">\n  </span><span class="s1">node: t.VariableDeclaration,</span><span class="s3">\n  </span><span class="s1">parent: t.Node,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">if (node.declare) {</span><span class="s3">\n    </span><span class="s1">// TS</span><span class="s3">\n    </span><span class="s1">this.word(</span><span class="s3">\&quot;</span><span class="s1">declare</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">this.space();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const { kind } = node;</span><span class="s3">\n  </span><span class="s1">if (kind === </span><span class="s3">\&quot;</span><span class="s1">await using</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">this.word(</span><span class="s3">\&quot;</span><span class="s1">await</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">this.space();</span><span class="s3">\n    </span><span class="s1">this.word(</span><span class="s3">\&quot;</span><span class="s1">using</span><span class="s3">\&quot;</span><span class="s1">, true);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">this.word(kind, kind === </span><span class="s3">\&quot;</span><span class="s1">using</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">this.space();</span><span class="s3">\n\n  </span><span class="s1">let hasInits = false;</span><span class="s3">\n  </span><span class="s1">// don't add whitespace to loop heads</span><span class="s3">\n  </span><span class="s1">if (!isFor(parent)) {</span><span class="s3">\n    </span><span class="s1">for (const declar of node.declarations) {</span><span class="s3">\n      </span><span class="s1">if (declar.init) {</span><span class="s3">\n        </span><span class="s1">// has an init so let's split it up over multiple lines</span><span class="s3">\n        </span><span class="s1">hasInits = true;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// use a pretty separator when we aren't in compact mode, have initializers and don't have retainLines on</span><span class="s3">\n  </span><span class="s1">// this will format declarations like:</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">//   let foo = </span><span class="s3">\&quot;</span><span class="s1">bar</span><span class="s3">\&quot;</span><span class="s1">, bar = </span><span class="s3">\&quot;</span><span class="s1">foo</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// into</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">//   let foo = </span><span class="s3">\&quot;</span><span class="s1">bar</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">//       bar = </span><span class="s3">\&quot;</span><span class="s1">foo</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n\n  </span><span class="s1">this.printList(</span><span class="s3">\n    </span><span class="s1">node.declarations,</span><span class="s3">\n    </span><span class="s1">undefined,</span><span class="s3">\n    </span><span class="s1">undefined,</span><span class="s3">\n    </span><span class="s1">node.declarations.length &gt; 1,</span><span class="s3">\n    </span><span class="s1">hasInits</span><span class="s3">\n      </span><span class="s1">? function (this: Printer, occurrenceCount: number) {</span><span class="s3">\n          </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">, false, occurrenceCount);</span><span class="s3">\n          </span><span class="s1">this.newline();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">: undefined,</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n\n  </span><span class="s1">if (isFor(parent)) {</span><span class="s3">\n    </span><span class="s1">// don't give semicolons to these nodes since they'll be inserted in the parent generator</span><span class="s3">\n    </span><span class="s1">if (isForStatement(parent)) {</span><span class="s3">\n      </span><span class="s1">if (parent.init === node) return;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">if (parent.left === node) return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">this.semicolon();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function VariableDeclarator(this: Printer, node: t.VariableDeclarator) {</span><span class="s3">\n  </span><span class="s1">this.print(node.id);</span><span class="s3">\n  </span><span class="s1">if (node.definite) this.token(</span><span class="s3">\&quot;</span><span class="s1">!</span><span class="s3">\&quot;</span><span class="s1">); // TS</span><span class="s3">\n  </span><span class="s1">// @ts-ignore(Babel 7 vs Babel 8) Property 'typeAnnotation' does not exist on type 'MemberExpression'.</span><span class="s3">\n  </span><span class="s1">this.print(node.id.typeAnnotation);</span><span class="s3">\n  </span><span class="s1">if (node.init) {</span><span class="s3">\n    </span><span class="s1">this.space();</span><span class="s3">\n    </span><span class="s1">this.token(</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">this.space();</span><span class="s3">\n    </span><span class="s1">this.print(node.init);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[]}</span></pre>
</body>
</html>