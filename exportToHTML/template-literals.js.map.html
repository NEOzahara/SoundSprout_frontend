<html>
<head>
<title>template-literals.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
template-literals.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;TaggedTemplateExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;print&quot;</span><span class="s0">,</span><span class="s1">&quot;tag&quot;</span><span class="s0">,</span><span class="s1">&quot;typeParameters&quot;</span><span class="s0">,</span><span class="s1">&quot;quasi&quot;</span><span class="s0">,</span><span class="s1">&quot;TemplateElement&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;_printTemplate&quot;</span><span class="s0">,</span><span class="s1">&quot;substitutions&quot;</span><span class="s0">,</span><span class="s1">&quot;quasis&quot;</span><span class="s0">,</span><span class="s1">&quot;partRaw&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;raw&quot;</span><span class="s0">,</span><span class="s1">&quot;token&quot;</span><span class="s0">,</span><span class="s1">&quot;tokenMap&quot;</span><span class="s0">,</span><span class="s1">&quot;findMatching&quot;</span><span class="s0">,</span><span class="s1">&quot;_catchUpTo&quot;</span><span class="s0">,</span><span class="s1">&quot;loc&quot;</span><span class="s0">,</span><span class="s1">&quot;start&quot;</span><span class="s0">,</span><span class="s1">&quot;TemplateLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;expressions&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../src/generators/template-literals.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type Printer from </span><span class="s3">\&quot;</span><span class="s1">../printer.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type * as t from </span><span class="s3">\&quot;</span><span class="s1">@babel/types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">export function TaggedTemplateExpression(</span><span class="s3">\n  </span><span class="s1">this: Printer,</span><span class="s3">\n  </span><span class="s1">node: t.TaggedTemplateExpression,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">this.print(node.tag);</span><span class="s3">\n  </span><span class="s1">if (process.env.BABEL_8_BREAKING) {</span><span class="s3">\n    </span><span class="s1">// @ts-ignore(Babel 7 vs Babel 8) Babel 8 AST</span><span class="s3">\n    </span><span class="s1">this.print(node.typeArguments);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">// @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST</span><span class="s3">\n    </span><span class="s1">this.print(node.typeParameters);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">this.print(node.quasi);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function TemplateElement(this: Printer) {</span><span class="s3">\n  </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">TemplateElement printing is handled in TemplateLiteral</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type TemplateLiteralBase = t.Node &amp; {</span><span class="s3">\n  </span><span class="s1">quasis: t.TemplateElement[];</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export function _printTemplate&lt;T extends t.Node&gt;(</span><span class="s3">\n  </span><span class="s1">this: Printer,</span><span class="s3">\n  </span><span class="s1">node: TemplateLiteralBase,</span><span class="s3">\n  </span><span class="s1">substitutions: T[],</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const quasis = node.quasis;</span><span class="s3">\n  </span><span class="s1">let partRaw = </span><span class="s3">\&quot;</span><span class="s1">`</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; quasis.length - 1; i++) {</span><span class="s3">\n    </span><span class="s1">partRaw += quasis[i].value.raw;</span><span class="s3">\n    </span><span class="s1">this.token(partRaw + </span><span class="s3">\&quot;</span><span class="s1">${</span><span class="s3">\&quot;</span><span class="s1">, true);</span><span class="s3">\n    </span><span class="s1">this.print(substitutions[i]);</span><span class="s3">\n    </span><span class="s1">partRaw = </span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n    </span><span class="s1">// In Babel 7 we have individual tokens for ${ and }, so the automatic</span><span class="s3">\n    </span><span class="s1">// catchup logic does not work. Manually look for those tokens.</span><span class="s3">\n    </span><span class="s1">if (!process.env.BABEL_8_BREAKING &amp;&amp; this.tokenMap) {</span><span class="s3">\n      </span><span class="s1">const token = this.tokenMap.findMatching(node, </span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">, i);</span><span class="s3">\n      </span><span class="s1">if (token) this._catchUpTo(token.loc.start);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">partRaw += quasis[quasis.length - 1].value.raw;</span><span class="s3">\n  </span><span class="s1">this.token(partRaw + </span><span class="s3">\&quot;</span><span class="s1">`</span><span class="s3">\&quot;</span><span class="s1">, true);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function TemplateLiteral(this: Printer, node: t.TemplateLiteral) {</span><span class="s3">\n  </span><span class="s1">this._printTemplate(node, node.expressions);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;AAGO,SAASA,wBAAwBA,CAEtCC,IAAgC,EAChC;EACA,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,GAAG,CAAC;EAIb;IAEL,IAAI,CAACD,KAAK,CAACD,IAAI,CAACG,cAAc,CAAC;EACjC;EACA,IAAI,CAACF,KAAK,CAACD,IAAI,CAACI,KAAK,CAAC;AACxB;AAEO,SAASC,eAAeA,CAAA,EAAgB;EAC7C,MAAM,IAAIC,KAAK,CAAC,wDAAwD,CAAC;AAC3E;AAMO,SAASC,cAAcA,CAE5BP,IAAyB,EACzBQ,aAAkB,EAClB;EACA,MAAMC,MAAM,GAAGT,IAAI,CAACS,MAAM;EAC1B,IAAIC,OAAO,GAAG,GAAG;EACjB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,MAAM,CAACG,MAAM,GAAG,CAAC,EAAED,CAAC,EAAE,EAAE;IAC1CD,OAAO,IAAID,MAAM,CAACE,CAAC,CAAC,CAACE,KAAK,CAACC,GAAG;IAC9B,IAAI,CAACC,KAAK,CAACL,OAAO,GAAG,IAAI,EAAE,IAAI,CAAC;IAChC,IAAI,CAACT,KAAK,CAACO,aAAa,CAACG,CAAC,CAAC,CAAC;IAC5BD,OAAO,GAAG,GAAG;IAIb,IAAqC,IAAI,CAACM,QAAQ,EAAE;MAClD,MAAMD,KAAK,GAAG,IAAI,CAACC,QAAQ,CAACC,YAAY,CAACjB,IAAI,EAAE,GAAG,EAAEW,CAAC,CAAC;MACtD,IAAII,KAAK,EAAE,IAAI,CAACG,UAAU,CAACH,KAAK,CAACI,GAAG,CAACC,KAAK,CAAC;IAC7C;EACF;EACAV,OAAO,IAAID,MAAM,CAACA,MAAM,CAACG,MAAM,GAAG,CAAC,CAAC,CAACC,KAAK,CAACC,GAAG;EAC9C,IAAI,CAACC,KAAK,CAACL,OAAO,GAAG,GAAG,EAAE,IAAI,CAAC;AACjC;AAEO,SAASW,eAAeA,CAAgBrB,IAAuB,EAAE;EACtE,IAAI,CAACO,cAAc,CAACP,IAAI,EAAEA,IAAI,CAACsB,WAAW,CAAC;AAC7C&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[]}</span></pre>
</body>
</html>