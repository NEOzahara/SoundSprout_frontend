<html>
<head>
<title>test.d.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #67a37c; font-style: italic;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #bcbec4;}
.s5 { color: #cf8e6d;}
.s6 { color: #7a7e85;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test.d.ts</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* The `node:test` module facilitates the creation of JavaScript tests.</span>
 <span class="s0">* To access it:</span>
 <span class="s0">*</span>
 <span class="s0">* ```js</span>
 <span class="s0">* import test from 'node:test';</span>
 <span class="s0">* ```</span>
 <span class="s0">*</span>
 <span class="s0">* This module is only available under the `node:` scheme. The following will not</span>
 <span class="s0">* work:</span>
 <span class="s0">*</span>
 <span class="s0">* ```js</span>
 <span class="s0">* import test from 'node:test';</span>
 <span class="s0">* ```</span>
 <span class="s0">*</span>
 <span class="s0">* Tests created via the `test` module consist of a single function that is</span>
 <span class="s0">* processed in one of three ways:</span>
 <span class="s0">*</span>
 <span class="s0">* 1. A synchronous function that is considered failing if it throws an exception,</span>
 <span class="s0">* and is considered passing otherwise.</span>
 <span class="s0">* 2. A function that returns a `Promise` that is considered failing if the `Promise` rejects, and is considered passing if the `Promise` fulfills.</span>
 <span class="s0">* 3. A function that receives a callback function. If the callback receives any</span>
 <span class="s0">* truthy value as its first argument, the test is considered failing. If a</span>
 <span class="s0">* falsy value is passed as the first argument to the callback, the test is</span>
 <span class="s0">* considered passing. If the test function receives a callback function and</span>
 <span class="s0">* also returns a `Promise`, the test will fail.</span>
 <span class="s0">*</span>
 <span class="s0">* The following example illustrates how tests are written using the `test` module.</span>
 <span class="s0">*</span>
 <span class="s0">* ```js</span>
 <span class="s0">* test('synchronous passing test', (t) =&gt; {</span>
 <span class="s0">*   // This test passes because it does not throw an exception.</span>
 <span class="s0">*   assert.strictEqual(1, 1);</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* test('synchronous failing test', (t) =&gt; {</span>
 <span class="s0">*   // This test fails because it throws an exception.</span>
 <span class="s0">*   assert.strictEqual(1, 2);</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* test('asynchronous passing test', async (t) =&gt; {</span>
 <span class="s0">*   // This test passes because the Promise returned by the async</span>
 <span class="s0">*   // function is settled and not rejected.</span>
 <span class="s0">*   assert.strictEqual(1, 1);</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* test('asynchronous failing test', async (t) =&gt; {</span>
 <span class="s0">*   // This test fails because the Promise returned by the async</span>
 <span class="s0">*   // function is rejected.</span>
 <span class="s0">*   assert.strictEqual(1, 2);</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* test('failing test using Promises', (t) =&gt; {</span>
 <span class="s0">*   // Promises can be used directly as well.</span>
 <span class="s0">*   return new Promise((resolve, reject) =&gt; {</span>
 <span class="s0">*     setImmediate(() =&gt; {</span>
 <span class="s0">*       reject(new Error('this will cause the test to fail'));</span>
 <span class="s0">*     });</span>
 <span class="s0">*   });</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* test('callback passing test', (t, done) =&gt; {</span>
 <span class="s0">*   // done() is the callback function. When the setImmediate() runs, it invokes</span>
 <span class="s0">*   // done() with no arguments.</span>
 <span class="s0">*   setImmediate(done);</span>
 <span class="s0">* });</span>
 <span class="s0">*</span>
 <span class="s0">* test('callback failing test', (t, done) =&gt; {</span>
 <span class="s0">*   // When the setImmediate() runs, done() is invoked with an Error object and</span>
 <span class="s0">*   // the test fails.</span>
 <span class="s0">*   setImmediate(() =&gt; {</span>
 <span class="s0">*     done(new Error('callback failure'));</span>
 <span class="s0">*   });</span>
 <span class="s0">* });</span>
 <span class="s0">* ```</span>
 <span class="s0">*</span>
 <span class="s0">* If any tests fail, the process exit code is set to `1`.</span>
 <span class="s0">* </span><span class="s1">@since </span><span class="s0">v18.0.0, v16.17.0</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s0">[source](https://github.com/nodejs/node/blob/v22.x/lib/test.js)</span>
 <span class="s0">*/</span>
<span class="s2">declare module </span><span class="s3">&quot;node:test&quot; </span><span class="s4">{</span>
    <span class="s5">import </span><span class="s4">{ </span><span class="s2">Readable </span><span class="s4">} </span><span class="s2">from </span><span class="s3">&quot;node:stream&quot;</span><span class="s4">;</span>
    <span class="s0">/**</span>
     <span class="s0">* **Note:** `shard` is used to horizontally parallelize test running across</span>
     <span class="s0">* machines or processes, ideal for large-scale executions across varied</span>
     <span class="s0">* environments. It's incompatible with `watch` mode, tailored for rapid</span>
     <span class="s0">* code iteration by automatically rerunning tests on file changes.</span>
     <span class="s0">*</span>
     <span class="s0">* ```js</span>
     <span class="s0">* import { tap } from 'node:test/reporters';</span>
     <span class="s0">* import { run } from 'node:test';</span>
     <span class="s0">* import process from 'node:process';</span>
     <span class="s0">* import path from 'node:path';</span>
     <span class="s0">*</span>
     <span class="s0">* run({ files: [path.resolve('./tests/test.js')] })</span>
     <span class="s0">*   .compose(tap)</span>
     <span class="s0">*   .pipe(process.stdout);</span>
     <span class="s0">* ```</span>
     <span class="s0">* </span><span class="s1">@since </span><span class="s0">v18.9.0, v16.19.0</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">options Configuration options for running tests.</span>
     <span class="s0">*/</span>
    <span class="s5">function </span><span class="s2">run</span><span class="s4">(</span><span class="s2">options</span><span class="s4">?: </span><span class="s2">RunOptions</span><span class="s4">): </span><span class="s2">TestsStream</span><span class="s4">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The `test()` function is the value imported from the `test` module. Each</span>
     <span class="s0">* invocation of this function results in reporting the test to the `TestsStream`.</span>
     <span class="s0">*</span>
     <span class="s0">* The `TestContext` object passed to the `fn` argument can be used to perform</span>
     <span class="s0">* actions related to the current test. Examples include skipping the test, adding</span>
     <span class="s0">* additional diagnostic information, or creating subtests.</span>
     <span class="s0">*</span>
     <span class="s0">* `test()` returns a `Promise` that fulfills once the test completes.</span>
     <span class="s0">* if `test()` is called within a suite, it fulfills immediately.</span>
     <span class="s0">* The return value can usually be discarded for top level tests.</span>
     <span class="s0">* However, the return value from subtests should be used to prevent the parent</span>
     <span class="s0">* test from finishing first and cancelling the subtest</span>
     <span class="s0">* as shown in the following example.</span>
     <span class="s0">*</span>
     <span class="s0">* ```js</span>
     <span class="s0">* test('top level test', async (t) =&gt; {</span>
     <span class="s0">*   // The setTimeout() in the following subtest would cause it to outlive its</span>
     <span class="s0">*   // parent test if 'await' is removed on the next line. Once the parent test</span>
     <span class="s0">*   // completes, it will cancel any outstanding subtests.</span>
     <span class="s0">*   await t.test('longer running subtest', async (t) =&gt; {</span>
     <span class="s0">*     return new Promise((resolve, reject) =&gt; {</span>
     <span class="s0">*       setTimeout(resolve, 1000);</span>
     <span class="s0">*     });</span>
     <span class="s0">*   });</span>
     <span class="s0">* });</span>
     <span class="s0">* ```</span>
     <span class="s0">*</span>
     <span class="s0">* The `timeout` option can be used to fail the test if it takes longer than `timeout` milliseconds to complete. However, it is not a reliable mechanism for</span>
     <span class="s0">* canceling tests because a running test might block the application thread and</span>
     <span class="s0">* thus prevent the scheduled cancellation.</span>
     <span class="s0">* </span><span class="s1">@since </span><span class="s0">v18.0.0, v16.17.0</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">name The name of the test, which is displayed when reporting test results.</span>
     <span class="s0">* Defaults to the `name` property of `fn`, or `'&lt;anonymous&gt;'` if `fn` does not have a name.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">options Configuration options for the test.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">fn The function under test. The first argument to this function is a {</span><span class="s1">@link </span><span class="s0">TestContext} object.</span>
     <span class="s0">* If the test uses callbacks, the callback function is passed as the second argument.</span>
     <span class="s0">* </span><span class="s1">@return </span><span class="s0">Fulfilled with `undefined` once the test completes, or immediately if the test runs within a suite.</span>
     <span class="s0">*/</span>
    <span class="s5">function </span><span class="s2">test</span><span class="s4">(</span><span class="s2">name</span><span class="s4">?: </span><span class="s2">string</span><span class="s4">, </span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">TestFn</span><span class="s4">): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s5">void</span><span class="s4">&gt;;</span>
    <span class="s5">function </span><span class="s2">test</span><span class="s4">(</span><span class="s2">name</span><span class="s4">?: </span><span class="s2">string</span><span class="s4">, </span><span class="s2">options</span><span class="s4">?: </span><span class="s2">TestOptions</span><span class="s4">, </span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">TestFn</span><span class="s4">): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s5">void</span><span class="s4">&gt;;</span>
    <span class="s5">function </span><span class="s2">test</span><span class="s4">(</span><span class="s2">options</span><span class="s4">?: </span><span class="s2">TestOptions</span><span class="s4">, </span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">TestFn</span><span class="s4">): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s5">void</span><span class="s4">&gt;;</span>
    <span class="s5">function </span><span class="s2">test</span><span class="s4">(</span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">TestFn</span><span class="s4">): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s5">void</span><span class="s4">&gt;;</span>
    <span class="s2">namespace test </span><span class="s4">{</span>
        <span class="s5">export </span><span class="s4">{</span>
            <span class="s2">after</span><span class="s4">,</span>
            <span class="s2">afterEach</span><span class="s4">,</span>
            <span class="s2">assert</span><span class="s4">,</span>
            <span class="s2">before</span><span class="s4">,</span>
            <span class="s2">beforeEach</span><span class="s4">,</span>
            <span class="s2">describe</span><span class="s4">,</span>
            <span class="s2">it</span><span class="s4">,</span>
            <span class="s2">mock</span><span class="s4">,</span>
            <span class="s2">only</span><span class="s4">,</span>
            <span class="s2">run</span><span class="s4">,</span>
            <span class="s2">skip</span><span class="s4">,</span>
            <span class="s2">snapshot</span><span class="s4">,</span>
            <span class="s2">suite</span><span class="s4">,</span>
            <span class="s2">test</span><span class="s4">,</span>
            <span class="s2">todo</span><span class="s4">,</span>
        <span class="s4">};</span>
    <span class="s4">}</span>
    <span class="s0">/**</span>
     <span class="s0">* The `suite()` function is imported from the `node:test` module.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">name The name of the suite, which is displayed when reporting test results.</span>
     <span class="s0">* Defaults to the `name` property of `fn`, or `'&lt;anonymous&gt;'` if `fn` does not have a name.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">options Configuration options for the suite. This supports the same options as {</span><span class="s1">@link </span><span class="s0">test}.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">fn The suite function declaring nested tests and suites. The first argument to this function is a {</span><span class="s1">@link </span><span class="s0">SuiteContext} object.</span>
     <span class="s0">* </span><span class="s1">@return </span><span class="s0">Immediately fulfilled with `undefined`.</span>
     <span class="s0">* </span><span class="s1">@since </span><span class="s0">v20.13.0</span>
     <span class="s0">*/</span>
    <span class="s5">function </span><span class="s2">suite</span><span class="s4">(</span><span class="s2">name</span><span class="s4">?: </span><span class="s2">string</span><span class="s4">, </span><span class="s2">options</span><span class="s4">?: </span><span class="s2">TestOptions</span><span class="s4">, </span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">SuiteFn</span><span class="s4">): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s5">void</span><span class="s4">&gt;;</span>
    <span class="s5">function </span><span class="s2">suite</span><span class="s4">(</span><span class="s2">name</span><span class="s4">?: </span><span class="s2">string</span><span class="s4">, </span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">SuiteFn</span><span class="s4">): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s5">void</span><span class="s4">&gt;;</span>
    <span class="s5">function </span><span class="s2">suite</span><span class="s4">(</span><span class="s2">options</span><span class="s4">?: </span><span class="s2">TestOptions</span><span class="s4">, </span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">SuiteFn</span><span class="s4">): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s5">void</span><span class="s4">&gt;;</span>
    <span class="s5">function </span><span class="s2">suite</span><span class="s4">(</span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">SuiteFn</span><span class="s4">): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s5">void</span><span class="s4">&gt;;</span>
    <span class="s2">namespace suite </span><span class="s4">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Shorthand for skipping a suite. This is the same as calling {</span><span class="s1">@link </span><span class="s0">suite} with `options.skip` set to `true`.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v20.13.0</span>
         <span class="s0">*/</span>
        <span class="s5">function </span><span class="s2">skip</span><span class="s4">(</span><span class="s2">name</span><span class="s4">?: </span><span class="s2">string</span><span class="s4">, </span><span class="s2">options</span><span class="s4">?: </span><span class="s2">TestOptions</span><span class="s4">, </span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">SuiteFn</span><span class="s4">): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s5">void</span><span class="s4">&gt;;</span>
        <span class="s5">function </span><span class="s2">skip</span><span class="s4">(</span><span class="s2">name</span><span class="s4">?: </span><span class="s2">string</span><span class="s4">, </span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">SuiteFn</span><span class="s4">): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s5">void</span><span class="s4">&gt;;</span>
        <span class="s5">function </span><span class="s2">skip</span><span class="s4">(</span><span class="s2">options</span><span class="s4">?: </span><span class="s2">TestOptions</span><span class="s4">, </span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">SuiteFn</span><span class="s4">): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s5">void</span><span class="s4">&gt;;</span>
        <span class="s5">function </span><span class="s2">skip</span><span class="s4">(</span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">SuiteFn</span><span class="s4">): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s5">void</span><span class="s4">&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Shorthand for marking a suite as `TODO`. This is the same as calling {</span><span class="s1">@link </span><span class="s0">suite} with `options.todo` set to `true`.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v20.13.0</span>
         <span class="s0">*/</span>
        <span class="s5">function </span><span class="s2">todo</span><span class="s4">(</span><span class="s2">name</span><span class="s4">?: </span><span class="s2">string</span><span class="s4">, </span><span class="s2">options</span><span class="s4">?: </span><span class="s2">TestOptions</span><span class="s4">, </span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">SuiteFn</span><span class="s4">): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s5">void</span><span class="s4">&gt;;</span>
        <span class="s5">function </span><span class="s2">todo</span><span class="s4">(</span><span class="s2">name</span><span class="s4">?: </span><span class="s2">string</span><span class="s4">, </span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">SuiteFn</span><span class="s4">): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s5">void</span><span class="s4">&gt;;</span>
        <span class="s5">function </span><span class="s2">todo</span><span class="s4">(</span><span class="s2">options</span><span class="s4">?: </span><span class="s2">TestOptions</span><span class="s4">, </span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">SuiteFn</span><span class="s4">): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s5">void</span><span class="s4">&gt;;</span>
        <span class="s5">function </span><span class="s2">todo</span><span class="s4">(</span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">SuiteFn</span><span class="s4">): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s5">void</span><span class="s4">&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Shorthand for marking a suite as `only`. This is the same as calling {</span><span class="s1">@link </span><span class="s0">suite} with `options.only` set to `true`.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v20.13.0</span>
         <span class="s0">*/</span>
        <span class="s5">function </span><span class="s2">only</span><span class="s4">(</span><span class="s2">name</span><span class="s4">?: </span><span class="s2">string</span><span class="s4">, </span><span class="s2">options</span><span class="s4">?: </span><span class="s2">TestOptions</span><span class="s4">, </span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">SuiteFn</span><span class="s4">): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s5">void</span><span class="s4">&gt;;</span>
        <span class="s5">function </span><span class="s2">only</span><span class="s4">(</span><span class="s2">name</span><span class="s4">?: </span><span class="s2">string</span><span class="s4">, </span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">SuiteFn</span><span class="s4">): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s5">void</span><span class="s4">&gt;;</span>
        <span class="s5">function </span><span class="s2">only</span><span class="s4">(</span><span class="s2">options</span><span class="s4">?: </span><span class="s2">TestOptions</span><span class="s4">, </span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">SuiteFn</span><span class="s4">): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s5">void</span><span class="s4">&gt;;</span>
        <span class="s5">function </span><span class="s2">only</span><span class="s4">(</span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">SuiteFn</span><span class="s4">): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s5">void</span><span class="s4">&gt;;</span>
    <span class="s4">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Alias for {</span><span class="s1">@link </span><span class="s0">suite}.</span>
     <span class="s0">*</span>
     <span class="s0">* The `describe()` function is imported from the `node:test` module.</span>
     <span class="s0">*/</span>
    <span class="s5">function </span><span class="s2">describe</span><span class="s4">(</span><span class="s2">name</span><span class="s4">?: </span><span class="s2">string</span><span class="s4">, </span><span class="s2">options</span><span class="s4">?: </span><span class="s2">TestOptions</span><span class="s4">, </span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">SuiteFn</span><span class="s4">): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s5">void</span><span class="s4">&gt;;</span>
    <span class="s5">function </span><span class="s2">describe</span><span class="s4">(</span><span class="s2">name</span><span class="s4">?: </span><span class="s2">string</span><span class="s4">, </span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">SuiteFn</span><span class="s4">): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s5">void</span><span class="s4">&gt;;</span>
    <span class="s5">function </span><span class="s2">describe</span><span class="s4">(</span><span class="s2">options</span><span class="s4">?: </span><span class="s2">TestOptions</span><span class="s4">, </span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">SuiteFn</span><span class="s4">): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s5">void</span><span class="s4">&gt;;</span>
    <span class="s5">function </span><span class="s2">describe</span><span class="s4">(</span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">SuiteFn</span><span class="s4">): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s5">void</span><span class="s4">&gt;;</span>
    <span class="s2">namespace describe </span><span class="s4">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Shorthand for skipping a suite. This is the same as calling {</span><span class="s1">@link </span><span class="s0">describe} with `options.skip` set to `true`.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v18.15.0</span>
         <span class="s0">*/</span>
        <span class="s5">function </span><span class="s2">skip</span><span class="s4">(</span><span class="s2">name</span><span class="s4">?: </span><span class="s2">string</span><span class="s4">, </span><span class="s2">options</span><span class="s4">?: </span><span class="s2">TestOptions</span><span class="s4">, </span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">SuiteFn</span><span class="s4">): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s5">void</span><span class="s4">&gt;;</span>
        <span class="s5">function </span><span class="s2">skip</span><span class="s4">(</span><span class="s2">name</span><span class="s4">?: </span><span class="s2">string</span><span class="s4">, </span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">SuiteFn</span><span class="s4">): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s5">void</span><span class="s4">&gt;;</span>
        <span class="s5">function </span><span class="s2">skip</span><span class="s4">(</span><span class="s2">options</span><span class="s4">?: </span><span class="s2">TestOptions</span><span class="s4">, </span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">SuiteFn</span><span class="s4">): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s5">void</span><span class="s4">&gt;;</span>
        <span class="s5">function </span><span class="s2">skip</span><span class="s4">(</span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">SuiteFn</span><span class="s4">): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s5">void</span><span class="s4">&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Shorthand for marking a suite as `TODO`. This is the same as calling {</span><span class="s1">@link </span><span class="s0">describe} with `options.todo` set to `true`.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v18.15.0</span>
         <span class="s0">*/</span>
        <span class="s5">function </span><span class="s2">todo</span><span class="s4">(</span><span class="s2">name</span><span class="s4">?: </span><span class="s2">string</span><span class="s4">, </span><span class="s2">options</span><span class="s4">?: </span><span class="s2">TestOptions</span><span class="s4">, </span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">SuiteFn</span><span class="s4">): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s5">void</span><span class="s4">&gt;;</span>
        <span class="s5">function </span><span class="s2">todo</span><span class="s4">(</span><span class="s2">name</span><span class="s4">?: </span><span class="s2">string</span><span class="s4">, </span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">SuiteFn</span><span class="s4">): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s5">void</span><span class="s4">&gt;;</span>
        <span class="s5">function </span><span class="s2">todo</span><span class="s4">(</span><span class="s2">options</span><span class="s4">?: </span><span class="s2">TestOptions</span><span class="s4">, </span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">SuiteFn</span><span class="s4">): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s5">void</span><span class="s4">&gt;;</span>
        <span class="s5">function </span><span class="s2">todo</span><span class="s4">(</span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">SuiteFn</span><span class="s4">): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s5">void</span><span class="s4">&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Shorthand for marking a suite as `only`. This is the same as calling {</span><span class="s1">@link </span><span class="s0">describe} with `options.only` set to `true`.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v18.15.0</span>
         <span class="s0">*/</span>
        <span class="s5">function </span><span class="s2">only</span><span class="s4">(</span><span class="s2">name</span><span class="s4">?: </span><span class="s2">string</span><span class="s4">, </span><span class="s2">options</span><span class="s4">?: </span><span class="s2">TestOptions</span><span class="s4">, </span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">SuiteFn</span><span class="s4">): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s5">void</span><span class="s4">&gt;;</span>
        <span class="s5">function </span><span class="s2">only</span><span class="s4">(</span><span class="s2">name</span><span class="s4">?: </span><span class="s2">string</span><span class="s4">, </span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">SuiteFn</span><span class="s4">): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s5">void</span><span class="s4">&gt;;</span>
        <span class="s5">function </span><span class="s2">only</span><span class="s4">(</span><span class="s2">options</span><span class="s4">?: </span><span class="s2">TestOptions</span><span class="s4">, </span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">SuiteFn</span><span class="s4">): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s5">void</span><span class="s4">&gt;;</span>
        <span class="s5">function </span><span class="s2">only</span><span class="s4">(</span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">SuiteFn</span><span class="s4">): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s5">void</span><span class="s4">&gt;;</span>
    <span class="s4">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Alias for {</span><span class="s1">@link </span><span class="s0">test}.</span>
     <span class="s0">*</span>
     <span class="s0">* The `it()` function is imported from the `node:test` module.</span>
     <span class="s0">* </span><span class="s1">@since </span><span class="s0">v18.6.0, v16.17.0</span>
     <span class="s0">*/</span>
    <span class="s5">function </span><span class="s2">it</span><span class="s4">(</span><span class="s2">name</span><span class="s4">?: </span><span class="s2">string</span><span class="s4">, </span><span class="s2">options</span><span class="s4">?: </span><span class="s2">TestOptions</span><span class="s4">, </span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">TestFn</span><span class="s4">): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s5">void</span><span class="s4">&gt;;</span>
    <span class="s5">function </span><span class="s2">it</span><span class="s4">(</span><span class="s2">name</span><span class="s4">?: </span><span class="s2">string</span><span class="s4">, </span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">TestFn</span><span class="s4">): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s5">void</span><span class="s4">&gt;;</span>
    <span class="s5">function </span><span class="s2">it</span><span class="s4">(</span><span class="s2">options</span><span class="s4">?: </span><span class="s2">TestOptions</span><span class="s4">, </span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">TestFn</span><span class="s4">): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s5">void</span><span class="s4">&gt;;</span>
    <span class="s5">function </span><span class="s2">it</span><span class="s4">(</span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">TestFn</span><span class="s4">): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s5">void</span><span class="s4">&gt;;</span>
    <span class="s2">namespace it </span><span class="s4">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Shorthand for skipping a test. This is the same as calling {</span><span class="s1">@link </span><span class="s0">it} with `options.skip` set to `true`.</span>
         <span class="s0">*/</span>
        <span class="s5">function </span><span class="s2">skip</span><span class="s4">(</span><span class="s2">name</span><span class="s4">?: </span><span class="s2">string</span><span class="s4">, </span><span class="s2">options</span><span class="s4">?: </span><span class="s2">TestOptions</span><span class="s4">, </span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">TestFn</span><span class="s4">): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s5">void</span><span class="s4">&gt;;</span>
        <span class="s5">function </span><span class="s2">skip</span><span class="s4">(</span><span class="s2">name</span><span class="s4">?: </span><span class="s2">string</span><span class="s4">, </span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">TestFn</span><span class="s4">): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s5">void</span><span class="s4">&gt;;</span>
        <span class="s5">function </span><span class="s2">skip</span><span class="s4">(</span><span class="s2">options</span><span class="s4">?: </span><span class="s2">TestOptions</span><span class="s4">, </span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">TestFn</span><span class="s4">): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s5">void</span><span class="s4">&gt;;</span>
        <span class="s5">function </span><span class="s2">skip</span><span class="s4">(</span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">TestFn</span><span class="s4">): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s5">void</span><span class="s4">&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Shorthand for marking a test as `TODO`. This is the same as calling {</span><span class="s1">@link </span><span class="s0">it} with `options.todo` set to `true`.</span>
         <span class="s0">*/</span>
        <span class="s5">function </span><span class="s2">todo</span><span class="s4">(</span><span class="s2">name</span><span class="s4">?: </span><span class="s2">string</span><span class="s4">, </span><span class="s2">options</span><span class="s4">?: </span><span class="s2">TestOptions</span><span class="s4">, </span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">TestFn</span><span class="s4">): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s5">void</span><span class="s4">&gt;;</span>
        <span class="s5">function </span><span class="s2">todo</span><span class="s4">(</span><span class="s2">name</span><span class="s4">?: </span><span class="s2">string</span><span class="s4">, </span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">TestFn</span><span class="s4">): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s5">void</span><span class="s4">&gt;;</span>
        <span class="s5">function </span><span class="s2">todo</span><span class="s4">(</span><span class="s2">options</span><span class="s4">?: </span><span class="s2">TestOptions</span><span class="s4">, </span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">TestFn</span><span class="s4">): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s5">void</span><span class="s4">&gt;;</span>
        <span class="s5">function </span><span class="s2">todo</span><span class="s4">(</span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">TestFn</span><span class="s4">): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s5">void</span><span class="s4">&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Shorthand for marking a test as `only`. This is the same as calling {</span><span class="s1">@link </span><span class="s0">it} with `options.only` set to `true`.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v18.15.0</span>
         <span class="s0">*/</span>
        <span class="s5">function </span><span class="s2">only</span><span class="s4">(</span><span class="s2">name</span><span class="s4">?: </span><span class="s2">string</span><span class="s4">, </span><span class="s2">options</span><span class="s4">?: </span><span class="s2">TestOptions</span><span class="s4">, </span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">TestFn</span><span class="s4">): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s5">void</span><span class="s4">&gt;;</span>
        <span class="s5">function </span><span class="s2">only</span><span class="s4">(</span><span class="s2">name</span><span class="s4">?: </span><span class="s2">string</span><span class="s4">, </span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">TestFn</span><span class="s4">): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s5">void</span><span class="s4">&gt;;</span>
        <span class="s5">function </span><span class="s2">only</span><span class="s4">(</span><span class="s2">options</span><span class="s4">?: </span><span class="s2">TestOptions</span><span class="s4">, </span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">TestFn</span><span class="s4">): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s5">void</span><span class="s4">&gt;;</span>
        <span class="s5">function </span><span class="s2">only</span><span class="s4">(</span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">TestFn</span><span class="s4">): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s5">void</span><span class="s4">&gt;;</span>
    <span class="s4">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Shorthand for skipping a test. This is the same as calling {</span><span class="s1">@link </span><span class="s0">test} with `options.skip` set to `true`.</span>
     <span class="s0">* </span><span class="s1">@since </span><span class="s0">v20.2.0</span>
     <span class="s0">*/</span>
    <span class="s5">function </span><span class="s2">skip</span><span class="s4">(</span><span class="s2">name</span><span class="s4">?: </span><span class="s2">string</span><span class="s4">, </span><span class="s2">options</span><span class="s4">?: </span><span class="s2">TestOptions</span><span class="s4">, </span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">TestFn</span><span class="s4">): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s5">void</span><span class="s4">&gt;;</span>
    <span class="s5">function </span><span class="s2">skip</span><span class="s4">(</span><span class="s2">name</span><span class="s4">?: </span><span class="s2">string</span><span class="s4">, </span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">TestFn</span><span class="s4">): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s5">void</span><span class="s4">&gt;;</span>
    <span class="s5">function </span><span class="s2">skip</span><span class="s4">(</span><span class="s2">options</span><span class="s4">?: </span><span class="s2">TestOptions</span><span class="s4">, </span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">TestFn</span><span class="s4">): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s5">void</span><span class="s4">&gt;;</span>
    <span class="s5">function </span><span class="s2">skip</span><span class="s4">(</span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">TestFn</span><span class="s4">): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s5">void</span><span class="s4">&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Shorthand for marking a test as `TODO`. This is the same as calling {</span><span class="s1">@link </span><span class="s0">test} with `options.todo` set to `true`.</span>
     <span class="s0">* </span><span class="s1">@since </span><span class="s0">v20.2.0</span>
     <span class="s0">*/</span>
    <span class="s5">function </span><span class="s2">todo</span><span class="s4">(</span><span class="s2">name</span><span class="s4">?: </span><span class="s2">string</span><span class="s4">, </span><span class="s2">options</span><span class="s4">?: </span><span class="s2">TestOptions</span><span class="s4">, </span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">TestFn</span><span class="s4">): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s5">void</span><span class="s4">&gt;;</span>
    <span class="s5">function </span><span class="s2">todo</span><span class="s4">(</span><span class="s2">name</span><span class="s4">?: </span><span class="s2">string</span><span class="s4">, </span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">TestFn</span><span class="s4">): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s5">void</span><span class="s4">&gt;;</span>
    <span class="s5">function </span><span class="s2">todo</span><span class="s4">(</span><span class="s2">options</span><span class="s4">?: </span><span class="s2">TestOptions</span><span class="s4">, </span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">TestFn</span><span class="s4">): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s5">void</span><span class="s4">&gt;;</span>
    <span class="s5">function </span><span class="s2">todo</span><span class="s4">(</span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">TestFn</span><span class="s4">): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s5">void</span><span class="s4">&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Shorthand for marking a test as `only`. This is the same as calling {</span><span class="s1">@link </span><span class="s0">test} with `options.only` set to `true`.</span>
     <span class="s0">* </span><span class="s1">@since </span><span class="s0">v20.2.0</span>
     <span class="s0">*/</span>
    <span class="s5">function </span><span class="s2">only</span><span class="s4">(</span><span class="s2">name</span><span class="s4">?: </span><span class="s2">string</span><span class="s4">, </span><span class="s2">options</span><span class="s4">?: </span><span class="s2">TestOptions</span><span class="s4">, </span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">TestFn</span><span class="s4">): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s5">void</span><span class="s4">&gt;;</span>
    <span class="s5">function </span><span class="s2">only</span><span class="s4">(</span><span class="s2">name</span><span class="s4">?: </span><span class="s2">string</span><span class="s4">, </span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">TestFn</span><span class="s4">): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s5">void</span><span class="s4">&gt;;</span>
    <span class="s5">function </span><span class="s2">only</span><span class="s4">(</span><span class="s2">options</span><span class="s4">?: </span><span class="s2">TestOptions</span><span class="s4">, </span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">TestFn</span><span class="s4">): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s5">void</span><span class="s4">&gt;;</span>
    <span class="s5">function </span><span class="s2">only</span><span class="s4">(</span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">TestFn</span><span class="s4">): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s5">void</span><span class="s4">&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* The type of a function passed to {</span><span class="s1">@link </span><span class="s0">test}. The first argument to this function is a {</span><span class="s1">@link </span><span class="s0">TestContext} object.</span>
     <span class="s0">* If the test uses callbacks, the callback function is passed as the second argument.</span>
     <span class="s0">*/</span>
    <span class="s2">type TestFn </span><span class="s4">= (</span><span class="s2">t</span><span class="s4">: </span><span class="s2">TestContext</span><span class="s4">, </span><span class="s2">done</span><span class="s4">: (</span><span class="s2">result</span><span class="s4">?: </span><span class="s2">any</span><span class="s4">) =&gt; </span><span class="s5">void</span><span class="s4">) =&gt; </span><span class="s5">void </span><span class="s4">| </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s5">void</span><span class="s4">&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* The type of a suite test function. The argument to this function is a {</span><span class="s1">@link </span><span class="s0">SuiteContext} object.</span>
     <span class="s0">*/</span>
    <span class="s2">type SuiteFn </span><span class="s4">= (</span><span class="s2">s</span><span class="s4">: </span><span class="s2">SuiteContext</span><span class="s4">) =&gt; </span><span class="s5">void </span><span class="s4">| </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s5">void</span><span class="s4">&gt;;</span>
    <span class="s5">interface </span><span class="s2">TestShard </span><span class="s4">{</span>
        <span class="s0">/**</span>
         <span class="s0">* A positive integer between 1 and `total` that specifies the index of the shard to run.</span>
         <span class="s0">*/</span>
        <span class="s2">index</span><span class="s4">: </span><span class="s2">number</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* A positive integer that specifies the total number of shards to split the test files to.</span>
         <span class="s0">*/</span>
        <span class="s2">total</span><span class="s4">: </span><span class="s2">number</span><span class="s4">;</span>
    <span class="s4">}</span>
    <span class="s5">interface </span><span class="s2">RunOptions </span><span class="s4">{</span>
        <span class="s0">/**</span>
         <span class="s0">* If a number is provided, then that many test processes would run in parallel, where each process corresponds to one test file.</span>
         <span class="s0">* If `true`, it would run `os.availableParallelism() - 1` test files in parallel. If `false`, it would only run one test file at a time.</span>
         <span class="s0">* </span><span class="s1">@default </span><span class="s0">false</span>
         <span class="s0">*/</span>
        <span class="s2">concurrency</span><span class="s4">?: </span><span class="s2">number </span><span class="s4">| </span><span class="s2">boolean </span><span class="s4">| </span><span class="s2">undefined</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* An array containing the list of files to run. If omitted, files are run according to the</span>
         <span class="s0">* [test runner execution model](https://nodejs.org/docs/latest-v22.x/api/test.html#test-runner-execution-model).</span>
         <span class="s0">*/</span>
        <span class="s2">files</span><span class="s4">?: </span><span class="s2">readonly string</span><span class="s4">[] | </span><span class="s2">undefined</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Configures the test runner to exit the process once all known</span>
         <span class="s0">* tests have finished executing even if the event loop would</span>
         <span class="s0">* otherwise remain active.</span>
         <span class="s0">* </span><span class="s1">@default </span><span class="s0">false</span>
         <span class="s0">*/</span>
        <span class="s2">forceExit</span><span class="s4">?: </span><span class="s2">boolean </span><span class="s4">| </span><span class="s2">undefined</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* An array containing the list of glob patterns to match test files.</span>
         <span class="s0">* This option cannot be used together with `files`. If omitted, files are run according to the</span>
         <span class="s0">* [test runner execution model](https://nodejs.org/docs/latest-v22.x/api/test.html#test-runner-execution-model).</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v22.6.0</span>
         <span class="s0">*/</span>
        <span class="s2">globPatterns</span><span class="s4">?: </span><span class="s2">readonly string</span><span class="s4">[] | </span><span class="s2">undefined</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Sets inspector port of test child process.</span>
         <span class="s0">* This can be a number, or a function that takes no arguments and returns a</span>
         <span class="s0">* number. If a nullish value is provided, each process gets its own port,</span>
         <span class="s0">* incremented from the primary's `process.debugPort`. This option is ignored</span>
         <span class="s0">* if the `isolation` option is set to `'none'` as no child processes are</span>
         <span class="s0">* spawned.</span>
         <span class="s0">* </span><span class="s1">@default </span><span class="s0">undefined</span>
         <span class="s0">*/</span>
        <span class="s2">inspectPort</span><span class="s4">?: </span><span class="s2">number </span><span class="s4">| (() =&gt; </span><span class="s2">number</span><span class="s4">) | </span><span class="s2">undefined</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Configures the type of test isolation. If set to</span>
         <span class="s0">* `'process'`, each test file is run in a separate child process. If set to</span>
         <span class="s0">* `'none'`, all test files run in the current process.</span>
         <span class="s0">* </span><span class="s1">@default </span><span class="s0">'process'</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v22.8.0</span>
         <span class="s0">*/</span>
        <span class="s2">isolation</span><span class="s4">?: </span><span class="s3">&quot;process&quot; </span><span class="s4">| </span><span class="s3">&quot;none&quot; </span><span class="s4">| </span><span class="s2">undefined</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If truthy, the test context will only run tests that have the `only` option set</span>
         <span class="s0">*/</span>
        <span class="s2">only</span><span class="s4">?: </span><span class="s2">boolean </span><span class="s4">| </span><span class="s2">undefined</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* A function that accepts the `TestsStream` instance and can be used to setup listeners before any tests are run.</span>
         <span class="s0">* </span><span class="s1">@default </span><span class="s0">undefined</span>
         <span class="s0">*/</span>
        <span class="s2">setup</span><span class="s4">?: ((</span><span class="s2">reporter</span><span class="s4">: </span><span class="s2">TestsStream</span><span class="s4">) =&gt; </span><span class="s5">void </span><span class="s4">| </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s5">void</span><span class="s4">&gt;) | </span><span class="s2">undefined</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* An array of CLI flags to pass to the `node` executable when</span>
         <span class="s0">* spawning the subprocesses. This option has no effect when `isolation` is `'none`'.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v22.10.0</span>
         <span class="s0">* </span><span class="s1">@default </span><span class="s0">[]</span>
         <span class="s0">*/</span>
        <span class="s2">execArgv</span><span class="s4">?: </span><span class="s2">readonly string</span><span class="s4">[] | </span><span class="s2">undefined</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* An array of CLI flags to pass to each test file when spawning the</span>
         <span class="s0">* subprocesses. This option has no effect when `isolation` is `'none'`.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v22.10.0</span>
         <span class="s0">* </span><span class="s1">@default </span><span class="s0">[]</span>
         <span class="s0">*/</span>
        <span class="s2">argv</span><span class="s4">?: </span><span class="s2">readonly string</span><span class="s4">[] | </span><span class="s2">undefined</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Allows aborting an in-progress test execution.</span>
         <span class="s0">*/</span>
        <span class="s2">signal</span><span class="s4">?: </span><span class="s2">AbortSignal </span><span class="s4">| </span><span class="s2">undefined</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If provided, only run tests whose name matches the provided pattern.</span>
         <span class="s0">* Strings are interpreted as JavaScript regular expressions.</span>
         <span class="s0">* </span><span class="s1">@default </span><span class="s0">undefined</span>
         <span class="s0">*/</span>
        <span class="s2">testNamePatterns</span><span class="s4">?: </span><span class="s2">string </span><span class="s4">| </span><span class="s2">RegExp </span><span class="s4">| </span><span class="s2">ReadonlyArray</span><span class="s4">&lt;</span><span class="s2">string </span><span class="s4">| </span><span class="s2">RegExp</span><span class="s4">&gt; | </span><span class="s2">undefined</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* A String, RegExp or a RegExp Array, that can be used to exclude running tests whose</span>
         <span class="s0">* name matches the provided pattern. Test name patterns are interpreted as JavaScript</span>
         <span class="s0">* regular expressions. For each test that is executed, any corresponding test hooks,</span>
         <span class="s0">* such as `beforeEach()`, are also run.</span>
         <span class="s0">* </span><span class="s1">@default </span><span class="s0">undefined</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v22.1.0</span>
         <span class="s0">*/</span>
        <span class="s2">testSkipPatterns</span><span class="s4">?: </span><span class="s2">string </span><span class="s4">| </span><span class="s2">RegExp </span><span class="s4">| </span><span class="s2">ReadonlyArray</span><span class="s4">&lt;</span><span class="s2">string </span><span class="s4">| </span><span class="s2">RegExp</span><span class="s4">&gt; | </span><span class="s2">undefined</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The number of milliseconds after which the test execution will fail.</span>
         <span class="s0">* If unspecified, subtests inherit this value from their parent.</span>
         <span class="s0">* </span><span class="s1">@default </span><span class="s0">Infinity</span>
         <span class="s0">*/</span>
        <span class="s2">timeout</span><span class="s4">?: </span><span class="s2">number </span><span class="s4">| </span><span class="s2">undefined</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Whether to run in watch mode or not.</span>
         <span class="s0">* </span><span class="s1">@default </span><span class="s0">false</span>
         <span class="s0">*/</span>
        <span class="s2">watch</span><span class="s4">?: </span><span class="s2">boolean </span><span class="s4">| </span><span class="s2">undefined</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Running tests in a specific shard.</span>
         <span class="s0">* </span><span class="s1">@default </span><span class="s0">undefined</span>
         <span class="s0">*/</span>
        <span class="s2">shard</span><span class="s4">?: </span><span class="s2">TestShard </span><span class="s4">| </span><span class="s2">undefined</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* enable [code coverage](https://nodejs.org/docs/latest-v22.x/api/test.html#collecting-code-coverage) collection.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v22.10.0</span>
         <span class="s0">* </span><span class="s1">@default </span><span class="s0">false</span>
         <span class="s0">*/</span>
        <span class="s2">coverage</span><span class="s4">?: </span><span class="s2">boolean </span><span class="s4">| </span><span class="s2">undefined</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Excludes specific files from code coverage</span>
         <span class="s0">* using a glob pattern, which can match both absolute and relative file paths.</span>
         <span class="s0">* This property is only applicable when `coverage` was set to `true`.</span>
         <span class="s0">* If both `coverageExcludeGlobs` and `coverageIncludeGlobs` are provided,</span>
         <span class="s0">* files must meet **both** criteria to be included in the coverage report.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v22.10.0</span>
         <span class="s0">* </span><span class="s1">@default </span><span class="s0">undefined</span>
         <span class="s0">*/</span>
        <span class="s2">coverageExcludeGlobs</span><span class="s4">?: </span><span class="s2">string </span><span class="s4">| </span><span class="s2">readonly string</span><span class="s4">[] | </span><span class="s2">undefined</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Includes specific files in code coverage</span>
         <span class="s0">* using a glob pattern, which can match both absolute and relative file paths.</span>
         <span class="s0">* This property is only applicable when `coverage` was set to `true`.</span>
         <span class="s0">* If both `coverageExcludeGlobs` and `coverageIncludeGlobs` are provided,</span>
         <span class="s0">* files must meet **both** criteria to be included in the coverage report.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v22.10.0</span>
         <span class="s0">* </span><span class="s1">@default </span><span class="s0">undefined</span>
         <span class="s0">*/</span>
        <span class="s2">coverageIncludeGlobs</span><span class="s4">?: </span><span class="s2">string </span><span class="s4">| </span><span class="s2">readonly string</span><span class="s4">[] | </span><span class="s2">undefined</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Require a minimum percent of covered lines. If code</span>
         <span class="s0">* coverage does not reach the threshold specified, the process will exit with code `1`.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v22.10.0</span>
         <span class="s0">* </span><span class="s1">@default </span><span class="s0">0</span>
         <span class="s0">*/</span>
        <span class="s2">lineCoverage</span><span class="s4">?: </span><span class="s2">number </span><span class="s4">| </span><span class="s2">undefined</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Require a minimum percent of covered branches. If code</span>
         <span class="s0">* coverage does not reach the threshold specified, the process will exit with code `1`.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v22.10.0</span>
         <span class="s0">* </span><span class="s1">@default </span><span class="s0">0</span>
         <span class="s0">*/</span>
        <span class="s2">branchCoverage</span><span class="s4">?: </span><span class="s2">number </span><span class="s4">| </span><span class="s2">undefined</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Require a minimum percent of covered functions. If code</span>
         <span class="s0">* coverage does not reach the threshold specified, the process will exit with code `1`.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v22.10.0</span>
         <span class="s0">* </span><span class="s1">@default </span><span class="s0">0</span>
         <span class="s0">*/</span>
        <span class="s2">functionCoverage</span><span class="s4">?: </span><span class="s2">number </span><span class="s4">| </span><span class="s2">undefined</span><span class="s4">;</span>
    <span class="s4">}</span>
    <span class="s0">/**</span>
     <span class="s0">* A successful call to `run()` will return a new `TestsStream` object, streaming a series of events representing the execution of the tests.</span>
     <span class="s0">*</span>
     <span class="s0">* Some of the events are guaranteed to be emitted in the same order as the tests are defined, while others are emitted in the order that the tests execute.</span>
     <span class="s0">* </span><span class="s1">@since </span><span class="s0">v18.9.0, v16.19.0</span>
     <span class="s0">*/</span>
    <span class="s5">class </span><span class="s2">TestsStream </span><span class="s5">extends </span><span class="s2">Readable </span><span class="s5">implements </span><span class="s2">NodeJS</span><span class="s4">.</span><span class="s2">ReadableStream </span><span class="s4">{</span>
        <span class="s2">addListener</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:coverage&quot;</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: (</span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestCoverage</span><span class="s4">) =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">addListener</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:complete&quot;</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: (</span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestComplete</span><span class="s4">) =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">addListener</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:dequeue&quot;</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: (</span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestDequeue</span><span class="s4">) =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">addListener</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:diagnostic&quot;</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: (</span><span class="s2">data</span><span class="s4">: </span><span class="s2">DiagnosticData</span><span class="s4">) =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">addListener</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:enqueue&quot;</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: (</span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestEnqueue</span><span class="s4">) =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">addListener</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:fail&quot;</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: (</span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestFail</span><span class="s4">) =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">addListener</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:pass&quot;</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: (</span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestPass</span><span class="s4">) =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">addListener</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:plan&quot;</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: (</span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestPlan</span><span class="s4">) =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">addListener</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:start&quot;</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: (</span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestStart</span><span class="s4">) =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">addListener</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:stderr&quot;</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: (</span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestStderr</span><span class="s4">) =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">addListener</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:stdout&quot;</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: (</span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestStdout</span><span class="s4">) =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">addListener</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:summary&quot;</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: (</span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestSummary</span><span class="s4">) =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">addListener</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:watch:drained&quot;</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: () =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">addListener</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s2">string</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: (</span><span class="s2">...args</span><span class="s4">: </span><span class="s2">any</span><span class="s4">[]) =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">emit</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:coverage&quot;</span><span class="s4">, </span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestCoverage</span><span class="s4">): </span><span class="s2">boolean</span><span class="s4">;</span>
        <span class="s2">emit</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:complete&quot;</span><span class="s4">, </span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestComplete</span><span class="s4">): </span><span class="s2">boolean</span><span class="s4">;</span>
        <span class="s2">emit</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:dequeue&quot;</span><span class="s4">, </span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestDequeue</span><span class="s4">): </span><span class="s2">boolean</span><span class="s4">;</span>
        <span class="s2">emit</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:diagnostic&quot;</span><span class="s4">, </span><span class="s2">data</span><span class="s4">: </span><span class="s2">DiagnosticData</span><span class="s4">): </span><span class="s2">boolean</span><span class="s4">;</span>
        <span class="s2">emit</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:enqueue&quot;</span><span class="s4">, </span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestEnqueue</span><span class="s4">): </span><span class="s2">boolean</span><span class="s4">;</span>
        <span class="s2">emit</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:fail&quot;</span><span class="s4">, </span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestFail</span><span class="s4">): </span><span class="s2">boolean</span><span class="s4">;</span>
        <span class="s2">emit</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:pass&quot;</span><span class="s4">, </span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestPass</span><span class="s4">): </span><span class="s2">boolean</span><span class="s4">;</span>
        <span class="s2">emit</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:plan&quot;</span><span class="s4">, </span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestPlan</span><span class="s4">): </span><span class="s2">boolean</span><span class="s4">;</span>
        <span class="s2">emit</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:start&quot;</span><span class="s4">, </span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestStart</span><span class="s4">): </span><span class="s2">boolean</span><span class="s4">;</span>
        <span class="s2">emit</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:stderr&quot;</span><span class="s4">, </span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestStderr</span><span class="s4">): </span><span class="s2">boolean</span><span class="s4">;</span>
        <span class="s2">emit</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:stdout&quot;</span><span class="s4">, </span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestStdout</span><span class="s4">): </span><span class="s2">boolean</span><span class="s4">;</span>
        <span class="s2">emit</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:summary&quot;</span><span class="s4">, </span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestSummary</span><span class="s4">): </span><span class="s2">boolean</span><span class="s4">;</span>
        <span class="s2">emit</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:watch:drained&quot;</span><span class="s4">): </span><span class="s2">boolean</span><span class="s4">;</span>
        <span class="s2">emit</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s2">string </span><span class="s4">| </span><span class="s2">symbol</span><span class="s4">, </span><span class="s2">...args</span><span class="s4">: </span><span class="s2">any</span><span class="s4">[]): </span><span class="s2">boolean</span><span class="s4">;</span>
        <span class="s2">on</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:coverage&quot;</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: (</span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestCoverage</span><span class="s4">) =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">on</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:complete&quot;</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: (</span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestComplete</span><span class="s4">) =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">on</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:dequeue&quot;</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: (</span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestDequeue</span><span class="s4">) =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">on</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:diagnostic&quot;</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: (</span><span class="s2">data</span><span class="s4">: </span><span class="s2">DiagnosticData</span><span class="s4">) =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">on</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:enqueue&quot;</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: (</span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestEnqueue</span><span class="s4">) =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">on</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:fail&quot;</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: (</span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestFail</span><span class="s4">) =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">on</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:pass&quot;</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: (</span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestPass</span><span class="s4">) =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">on</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:plan&quot;</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: (</span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestPlan</span><span class="s4">) =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">on</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:start&quot;</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: (</span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestStart</span><span class="s4">) =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">on</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:stderr&quot;</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: (</span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestStderr</span><span class="s4">) =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">on</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:stdout&quot;</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: (</span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestStdout</span><span class="s4">) =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">on</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:summary&quot;</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: (</span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestSummary</span><span class="s4">) =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">on</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:watch:drained&quot;</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: () =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">on</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s2">string</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: (</span><span class="s2">...args</span><span class="s4">: </span><span class="s2">any</span><span class="s4">[]) =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">once</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:coverage&quot;</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: (</span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestCoverage</span><span class="s4">) =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">once</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:complete&quot;</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: (</span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestComplete</span><span class="s4">) =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">once</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:dequeue&quot;</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: (</span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestDequeue</span><span class="s4">) =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">once</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:diagnostic&quot;</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: (</span><span class="s2">data</span><span class="s4">: </span><span class="s2">DiagnosticData</span><span class="s4">) =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">once</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:enqueue&quot;</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: (</span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestEnqueue</span><span class="s4">) =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">once</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:fail&quot;</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: (</span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestFail</span><span class="s4">) =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">once</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:pass&quot;</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: (</span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestPass</span><span class="s4">) =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">once</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:plan&quot;</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: (</span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestPlan</span><span class="s4">) =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">once</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:start&quot;</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: (</span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestStart</span><span class="s4">) =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">once</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:stderr&quot;</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: (</span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestStderr</span><span class="s4">) =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">once</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:stdout&quot;</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: (</span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestStdout</span><span class="s4">) =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">once</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:summary&quot;</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: (</span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestSummary</span><span class="s4">) =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">once</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:watch:drained&quot;</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: () =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">once</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s2">string</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: (</span><span class="s2">...args</span><span class="s4">: </span><span class="s2">any</span><span class="s4">[]) =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">prependListener</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:coverage&quot;</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: (</span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestCoverage</span><span class="s4">) =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">prependListener</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:complete&quot;</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: (</span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestComplete</span><span class="s4">) =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">prependListener</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:dequeue&quot;</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: (</span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestDequeue</span><span class="s4">) =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">prependListener</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:diagnostic&quot;</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: (</span><span class="s2">data</span><span class="s4">: </span><span class="s2">DiagnosticData</span><span class="s4">) =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">prependListener</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:enqueue&quot;</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: (</span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestEnqueue</span><span class="s4">) =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">prependListener</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:fail&quot;</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: (</span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestFail</span><span class="s4">) =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">prependListener</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:pass&quot;</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: (</span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestPass</span><span class="s4">) =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">prependListener</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:plan&quot;</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: (</span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestPlan</span><span class="s4">) =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">prependListener</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:start&quot;</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: (</span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestStart</span><span class="s4">) =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">prependListener</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:stderr&quot;</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: (</span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestStderr</span><span class="s4">) =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">prependListener</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:stdout&quot;</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: (</span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestStdout</span><span class="s4">) =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">prependListener</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:summary&quot;</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: (</span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestSummary</span><span class="s4">) =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">prependListener</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:watch:drained&quot;</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: () =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">prependListener</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s2">string</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: (</span><span class="s2">...args</span><span class="s4">: </span><span class="s2">any</span><span class="s4">[]) =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">prependOnceListener</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:coverage&quot;</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: (</span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestCoverage</span><span class="s4">) =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">prependOnceListener</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:complete&quot;</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: (</span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestComplete</span><span class="s4">) =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">prependOnceListener</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:dequeue&quot;</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: (</span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestDequeue</span><span class="s4">) =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">prependOnceListener</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:diagnostic&quot;</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: (</span><span class="s2">data</span><span class="s4">: </span><span class="s2">DiagnosticData</span><span class="s4">) =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">prependOnceListener</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:enqueue&quot;</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: (</span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestEnqueue</span><span class="s4">) =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">prependOnceListener</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:fail&quot;</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: (</span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestFail</span><span class="s4">) =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">prependOnceListener</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:pass&quot;</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: (</span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestPass</span><span class="s4">) =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">prependOnceListener</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:plan&quot;</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: (</span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestPlan</span><span class="s4">) =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">prependOnceListener</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:start&quot;</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: (</span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestStart</span><span class="s4">) =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">prependOnceListener</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:stderr&quot;</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: (</span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestStderr</span><span class="s4">) =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">prependOnceListener</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:stdout&quot;</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: (</span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestStdout</span><span class="s4">) =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">prependOnceListener</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:summary&quot;</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: (</span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestSummary</span><span class="s4">) =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">prependOnceListener</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s3">&quot;test:watch:drained&quot;</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: () =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
        <span class="s2">prependOnceListener</span><span class="s4">(</span><span class="s2">event</span><span class="s4">: </span><span class="s2">string</span><span class="s4">, </span><span class="s2">listener</span><span class="s4">: (</span><span class="s2">...args</span><span class="s4">: </span><span class="s2">any</span><span class="s4">[]) =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">this</span><span class="s4">;</span>
    <span class="s4">}</span>
    <span class="s0">/**</span>
     <span class="s0">* An instance of `TestContext` is passed to each test function in order to</span>
     <span class="s0">* interact with the test runner. However, the `TestContext` constructor is not</span>
     <span class="s0">* exposed as part of the API.</span>
     <span class="s0">* </span><span class="s1">@since </span><span class="s0">v18.0.0, v16.17.0</span>
     <span class="s0">*/</span>
    <span class="s5">class </span><span class="s2">TestContext </span><span class="s4">{</span>
        <span class="s0">/**</span>
         <span class="s0">* An object containing assertion methods bound to the test context.</span>
         <span class="s0">* The top-level functions from the `node:assert` module are exposed here for the purpose of creating test plans.</span>
         <span class="s0">*</span>
         <span class="s0">* **Note:** Some of the functions from `node:assert` contain type assertions. If these are called via the</span>
         <span class="s0">* TestContext `assert` object, then the context parameter in the test's function signature **must be explicitly typed**</span>
         <span class="s0">* (ie. the parameter must have a type annotation), otherwise an error will be raised by the TypeScript compiler:</span>
         <span class="s0">* ```ts</span>
         <span class="s0">* import { test, type TestContext } from 'node:test';</span>
         <span class="s0">*</span>
         <span class="s0">* // The test function's context parameter must have a type annotation.</span>
         <span class="s0">* test('example', (t: TestContext) =&gt; {</span>
         <span class="s0">*   t.assert.deepStrictEqual(actual, expected);</span>
         <span class="s0">* });</span>
         <span class="s0">*</span>
         <span class="s0">* // Omitting the type annotation will result in a compilation error.</span>
         <span class="s0">* test('example', t =&gt; {</span>
         <span class="s0">*   t.assert.deepStrictEqual(actual, expected); // Error: 't' needs an explicit type annotation.</span>
         <span class="s0">* });</span>
         <span class="s0">* ```</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v22.2.0, v20.15.0</span>
         <span class="s0">*/</span>
        <span class="s2">readonly assert</span><span class="s4">: </span><span class="s2">TestContextAssert</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* This function is used to create a hook running before subtest of the current test.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">fn The hook function. The first argument to this function is a `TestContext` object.</span>
         <span class="s0">* If the hook uses callbacks, the callback function is passed as the second argument.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">options Configuration options for the hook.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v20.1.0, v18.17.0</span>
         <span class="s0">*/</span>
        <span class="s2">before</span><span class="s4">(</span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">TestContextHookFn</span><span class="s4">, </span><span class="s2">options</span><span class="s4">?: </span><span class="s2">HookOptions</span><span class="s4">): </span><span class="s5">void</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* This function is used to create a hook running before each subtest of the current test.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">fn The hook function. The first argument to this function is a `TestContext` object.</span>
         <span class="s0">* If the hook uses callbacks, the callback function is passed as the second argument.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">options Configuration options for the hook.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v18.8.0</span>
         <span class="s0">*/</span>
        <span class="s2">beforeEach</span><span class="s4">(</span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">TestContextHookFn</span><span class="s4">, </span><span class="s2">options</span><span class="s4">?: </span><span class="s2">HookOptions</span><span class="s4">): </span><span class="s5">void</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* This function is used to create a hook that runs after the current test finishes.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">fn The hook function. The first argument to this function is a `TestContext` object.</span>
         <span class="s0">* If the hook uses callbacks, the callback function is passed as the second argument.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">options Configuration options for the hook.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v18.13.0</span>
         <span class="s0">*/</span>
        <span class="s2">after</span><span class="s4">(</span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">TestContextHookFn</span><span class="s4">, </span><span class="s2">options</span><span class="s4">?: </span><span class="s2">HookOptions</span><span class="s4">): </span><span class="s5">void</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* This function is used to create a hook running after each subtest of the current test.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">fn The hook function. The first argument to this function is a `TestContext` object.</span>
         <span class="s0">* If the hook uses callbacks, the callback function is passed as the second argument.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">options Configuration options for the hook.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v18.8.0</span>
         <span class="s0">*/</span>
        <span class="s2">afterEach</span><span class="s4">(</span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">TestContextHookFn</span><span class="s4">, </span><span class="s2">options</span><span class="s4">?: </span><span class="s2">HookOptions</span><span class="s4">): </span><span class="s5">void</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* This function is used to write diagnostics to the output. Any diagnostic</span>
         <span class="s0">* information is included at the end of the test's results. This function does</span>
         <span class="s0">* not return a value.</span>
         <span class="s0">*</span>
         <span class="s0">* ```js</span>
         <span class="s0">* test('top level test', (t) =&gt; {</span>
         <span class="s0">*   t.diagnostic('A diagnostic message');</span>
         <span class="s0">* });</span>
         <span class="s0">* ```</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v18.0.0, v16.17.0</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">message Message to be reported.</span>
         <span class="s0">*/</span>
        <span class="s2">diagnostic</span><span class="s4">(</span><span class="s2">message</span><span class="s4">: </span><span class="s2">string</span><span class="s4">): </span><span class="s5">void</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The absolute path of the test file that created the current test. If a test file imports</span>
         <span class="s0">* additional modules that generate tests, the imported tests will return the path of the root test file.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v22.6.0</span>
         <span class="s0">*/</span>
        <span class="s2">readonly filePath</span><span class="s4">: </span><span class="s2">string </span><span class="s4">| </span><span class="s2">undefined</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The name of the test and each of its ancestors, separated by `&gt;`.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v22.3.0</span>
         <span class="s0">*/</span>
        <span class="s2">readonly fullName</span><span class="s4">: </span><span class="s2">string</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The name of the test.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v18.8.0, v16.18.0</span>
         <span class="s0">*/</span>
        <span class="s2">readonly name</span><span class="s4">: </span><span class="s2">string</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Used to set the number of assertions and subtests that are expected to run within the test.</span>
         <span class="s0">* If the number of assertions and subtests that run does not match the expected count, the test will fail.</span>
         <span class="s0">*</span>
         <span class="s0">* To make sure assertions are tracked, the assert functions on `context.assert` must be used,</span>
         <span class="s0">* instead of importing from the `node:assert` module.</span>
         <span class="s0">* ```js</span>
         <span class="s0">* test('top level test', (t) =&gt; {</span>
         <span class="s0">*   t.plan(2);</span>
         <span class="s0">*   t.assert.ok('some relevant assertion here');</span>
         <span class="s0">*   t.test('subtest', () =&gt; {});</span>
         <span class="s0">* });</span>
         <span class="s0">* ```</span>
         <span class="s0">*</span>
         <span class="s0">* When working with asynchronous code, the `plan` function can be used to ensure that the correct number of assertions are run:</span>
         <span class="s0">* ```js</span>
         <span class="s0">* test('planning with streams', (t, done) =&gt; {</span>
         <span class="s0">*   function* generate() {</span>
         <span class="s0">*     yield 'a';</span>
         <span class="s0">*     yield 'b';</span>
         <span class="s0">*     yield 'c';</span>
         <span class="s0">*   }</span>
         <span class="s0">*   const expected = ['a', 'b', 'c'];</span>
         <span class="s0">*   t.plan(expected.length);</span>
         <span class="s0">*   const stream = Readable.from(generate());</span>
         <span class="s0">*   stream.on('data', (chunk) =&gt; {</span>
         <span class="s0">*     t.assert.strictEqual(chunk, expected.shift());</span>
         <span class="s0">*   });</span>
         <span class="s0">*   stream.on('end', () =&gt; {</span>
         <span class="s0">*     done();</span>
         <span class="s0">*   });</span>
         <span class="s0">* });</span>
         <span class="s0">* ```</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v22.2.0</span>
         <span class="s0">*/</span>
        <span class="s2">plan</span><span class="s4">(</span><span class="s2">count</span><span class="s4">: </span><span class="s2">number</span><span class="s4">): </span><span class="s5">void</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If `shouldRunOnlyTests` is truthy, the test context will only run tests that</span>
         <span class="s0">* have the `only` option set. Otherwise, all tests are run. If Node.js was not</span>
         <span class="s0">* started with the `--test-only` command-line option, this function is a</span>
         <span class="s0">* no-op.</span>
         <span class="s0">*</span>
         <span class="s0">* ```js</span>
         <span class="s0">* test('top level test', (t) =&gt; {</span>
         <span class="s0">*   // The test context can be set to run subtests with the 'only' option.</span>
         <span class="s0">*   t.runOnly(true);</span>
         <span class="s0">*   return Promise.all([</span>
         <span class="s0">*     t.test('this subtest is now skipped'),</span>
         <span class="s0">*     t.test('this subtest is run', { only: true }),</span>
         <span class="s0">*   ]);</span>
         <span class="s0">* });</span>
         <span class="s0">* ```</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v18.0.0, v16.17.0</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">shouldRunOnlyTests Whether or not to run `only` tests.</span>
         <span class="s0">*/</span>
        <span class="s2">runOnly</span><span class="s4">(</span><span class="s2">shouldRunOnlyTests</span><span class="s4">: </span><span class="s2">boolean</span><span class="s4">): </span><span class="s5">void</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* ```js</span>
         <span class="s0">* test('top level test', async (t) =&gt; {</span>
         <span class="s0">*   await fetch('some/uri', { signal: t.signal });</span>
         <span class="s0">* });</span>
         <span class="s0">* ```</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v18.7.0, v16.17.0</span>
         <span class="s0">*/</span>
        <span class="s2">readonly signal</span><span class="s4">: </span><span class="s2">AbortSignal</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* This function causes the test's output to indicate the test as skipped. If `message` is provided, it is included in the output. Calling `skip()` does</span>
         <span class="s0">* not terminate execution of the test function. This function does not return a</span>
         <span class="s0">* value.</span>
         <span class="s0">*</span>
         <span class="s0">* ```js</span>
         <span class="s0">* test('top level test', (t) =&gt; {</span>
         <span class="s0">*   // Make sure to return here as well if the test contains additional logic.</span>
         <span class="s0">*   t.skip('this is skipped');</span>
         <span class="s0">* });</span>
         <span class="s0">* ```</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v18.0.0, v16.17.0</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">message Optional skip message.</span>
         <span class="s0">*/</span>
        <span class="s2">skip</span><span class="s4">(</span><span class="s2">message</span><span class="s4">?: </span><span class="s2">string</span><span class="s4">): </span><span class="s5">void</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* This function adds a `TODO` directive to the test's output. If `message` is</span>
         <span class="s0">* provided, it is included in the output. Calling `todo()` does not terminate</span>
         <span class="s0">* execution of the test function. This function does not return a value.</span>
         <span class="s0">*</span>
         <span class="s0">* ```js</span>
         <span class="s0">* test('top level test', (t) =&gt; {</span>
         <span class="s0">*   // This test is marked as `TODO`</span>
         <span class="s0">*   t.todo('this is a todo');</span>
         <span class="s0">* });</span>
         <span class="s0">* ```</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v18.0.0, v16.17.0</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">message Optional `TODO` message.</span>
         <span class="s0">*/</span>
        <span class="s2">todo</span><span class="s4">(</span><span class="s2">message</span><span class="s4">?: </span><span class="s2">string</span><span class="s4">): </span><span class="s5">void</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* This function is used to create subtests under the current test. This function behaves in</span>
         <span class="s0">* the same fashion as the top level {</span><span class="s1">@link </span><span class="s0">test} function.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v18.0.0</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">name The name of the test, which is displayed when reporting test results.</span>
         <span class="s0">* Defaults to the `name` property of `fn`, or `'&lt;anonymous&gt;'` if `fn` does not have a name.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">options Configuration options for the test.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">fn The function under test. This first argument to this function is a {</span><span class="s1">@link </span><span class="s0">TestContext} object.</span>
         <span class="s0">* If the test uses callbacks, the callback function is passed as the second argument.</span>
         <span class="s0">* </span><span class="s1">@returns </span><span class="s0">A {</span><span class="s1">@link </span><span class="s0">Promise} resolved with `undefined` once the test completes.</span>
         <span class="s0">*/</span>
        <span class="s2">test</span><span class="s4">: </span><span class="s5">typeof </span><span class="s2">test</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* This method polls a `condition` function until that function either returns</span>
         <span class="s0">* successfully or the operation times out.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v22.14.0</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">condition An assertion function that is invoked</span>
         <span class="s0">* periodically until it completes successfully or the defined polling timeout</span>
         <span class="s0">* elapses. Successful completion is defined as not throwing or rejecting. This</span>
         <span class="s0">* function does not accept any arguments, and is allowed to return any value.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">options An optional configuration object for the polling operation.</span>
         <span class="s0">* </span><span class="s1">@returns </span><span class="s0">Fulfilled with the value returned by `condition`.</span>
         <span class="s0">*/</span>
        <span class="s2">waitFor</span><span class="s4">&lt;</span><span class="s2">T</span><span class="s4">&gt;(</span><span class="s2">condition</span><span class="s4">: () =&gt; </span><span class="s2">T</span><span class="s4">, </span><span class="s2">options</span><span class="s4">?: </span><span class="s2">TestContextWaitForOptions</span><span class="s4">): </span><span class="s2">Promise</span><span class="s4">&lt;</span><span class="s2">Awaited</span><span class="s4">&lt;</span><span class="s2">T</span><span class="s4">&gt;&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* Each test provides its own MockTracker instance.</span>
         <span class="s0">*/</span>
        <span class="s2">readonly mock</span><span class="s4">: </span><span class="s2">MockTracker</span><span class="s4">;</span>
    <span class="s4">}</span>
    <span class="s5">interface </span><span class="s2">TestContextAssert </span><span class="s5">extends</span>
        <span class="s2">Pick</span><span class="s4">&lt;</span>
            <span class="s5">typeof import</span><span class="s4">(</span><span class="s3">&quot;assert&quot;</span><span class="s4">),</span>
            <span class="s4">| </span><span class="s3">&quot;deepEqual&quot;</span>
            <span class="s4">| </span><span class="s3">&quot;deepStrictEqual&quot;</span>
            <span class="s4">| </span><span class="s3">&quot;doesNotMatch&quot;</span>
            <span class="s4">| </span><span class="s3">&quot;doesNotReject&quot;</span>
            <span class="s4">| </span><span class="s3">&quot;doesNotThrow&quot;</span>
            <span class="s4">| </span><span class="s3">&quot;equal&quot;</span>
            <span class="s4">| </span><span class="s3">&quot;fail&quot;</span>
            <span class="s4">| </span><span class="s3">&quot;ifError&quot;</span>
            <span class="s4">| </span><span class="s3">&quot;match&quot;</span>
            <span class="s4">| </span><span class="s3">&quot;notDeepEqual&quot;</span>
            <span class="s4">| </span><span class="s3">&quot;notDeepStrictEqual&quot;</span>
            <span class="s4">| </span><span class="s3">&quot;notEqual&quot;</span>
            <span class="s4">| </span><span class="s3">&quot;notStrictEqual&quot;</span>
            <span class="s4">| </span><span class="s3">&quot;ok&quot;</span>
            <span class="s4">| </span><span class="s3">&quot;partialDeepStrictEqual&quot;</span>
            <span class="s4">| </span><span class="s3">&quot;rejects&quot;</span>
            <span class="s4">| </span><span class="s3">&quot;strictEqual&quot;</span>
            <span class="s4">| </span><span class="s3">&quot;throws&quot;</span>
        <span class="s4">&gt;</span>
    <span class="s4">{</span>
        <span class="s0">/**</span>
         <span class="s0">* This function serializes `value` and writes it to the file specified by `path`.</span>
         <span class="s0">*</span>
         <span class="s0">* ```js</span>
         <span class="s0">* test('snapshot test with default serialization', (t) =&gt; {</span>
         <span class="s0">*   t.assert.fileSnapshot({ value1: 1, value2: 2 }, './snapshots/snapshot.json');</span>
         <span class="s0">* });</span>
         <span class="s0">* ```</span>
         <span class="s0">*</span>
         <span class="s0">* This function differs from `context.assert.snapshot()` in the following ways:</span>
         <span class="s0">*</span>
         <span class="s0">* * The snapshot file path is explicitly provided by the user.</span>
         <span class="s0">* * Each snapshot file is limited to a single snapshot value.</span>
         <span class="s0">* * No additional escaping is performed by the test runner.</span>
         <span class="s0">*</span>
         <span class="s0">* These differences allow snapshot files to better support features such as syntax</span>
         <span class="s0">* highlighting.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v22.14.0</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">value A value to serialize to a string. If Node.js was started with</span>
         <span class="s0">* the [`--test-update-snapshots`](https://nodejs.org/docs/latest-v22.x/api/cli.html#--test-update-snapshots)</span>
         <span class="s0">* flag, the serialized value is written to</span>
         <span class="s0">* `path`. Otherwise, the serialized value is compared to the contents of the</span>
         <span class="s0">* existing snapshot file.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">path The file where the serialized `value` is written.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">options Optional configuration options.</span>
         <span class="s0">*/</span>
        <span class="s2">fileSnapshot</span><span class="s4">(</span><span class="s2">value</span><span class="s4">: </span><span class="s2">any</span><span class="s4">, </span><span class="s2">path</span><span class="s4">: </span><span class="s2">string</span><span class="s4">, </span><span class="s2">options</span><span class="s4">?: </span><span class="s2">AssertSnapshotOptions</span><span class="s4">): </span><span class="s5">void</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* This function implements assertions for snapshot testing.</span>
         <span class="s0">* ```js</span>
         <span class="s0">* test('snapshot test with default serialization', (t) =&gt; {</span>
         <span class="s0">*   t.assert.snapshot({ value1: 1, value2: 2 });</span>
         <span class="s0">* });</span>
         <span class="s0">*</span>
         <span class="s0">* test('snapshot test with custom serialization', (t) =&gt; {</span>
         <span class="s0">*   t.assert.snapshot({ value3: 3, value4: 4 }, {</span>
         <span class="s0">*     serializers: [(value) =&gt; JSON.stringify(value)]</span>
         <span class="s0">*   });</span>
         <span class="s0">* });</span>
         <span class="s0">* ```</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v22.3.0</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">value A value to serialize to a string. If Node.js was started with</span>
         <span class="s0">* the [`--test-update-snapshots`](https://nodejs.org/docs/latest-v22.x/api/cli.html#--test-update-snapshots)</span>
         <span class="s0">* flag, the serialized value is written to</span>
         <span class="s0">* the snapshot file. Otherwise, the serialized value is compared to the</span>
         <span class="s0">* corresponding value in the existing snapshot file.</span>
         <span class="s0">*/</span>
        <span class="s2">snapshot</span><span class="s4">(</span><span class="s2">value</span><span class="s4">: </span><span class="s2">any</span><span class="s4">, </span><span class="s2">options</span><span class="s4">?: </span><span class="s2">AssertSnapshotOptions</span><span class="s4">): </span><span class="s5">void</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* A custom assertion function registered with `assert.register()`.</span>
         <span class="s0">*/</span>
        <span class="s4">[</span><span class="s2">name</span><span class="s4">: </span><span class="s2">string</span><span class="s4">]: (</span><span class="s2">...args</span><span class="s4">: </span><span class="s2">any</span><span class="s4">[]) =&gt; </span><span class="s5">void</span><span class="s4">;</span>
    <span class="s4">}</span>
    <span class="s5">interface </span><span class="s2">AssertSnapshotOptions </span><span class="s4">{</span>
        <span class="s0">/**</span>
         <span class="s0">* An array of synchronous functions used to serialize `value` into a string.</span>
         <span class="s0">* `value` is passed as the only argument to the first serializer function.</span>
         <span class="s0">* The return value of each serializer is passed as input to the next serializer.</span>
         <span class="s0">* Once all serializers have run, the resulting value is coerced to a string.</span>
         <span class="s0">*</span>
         <span class="s0">* If no serializers are provided, the test runner's default serializers are used.</span>
         <span class="s0">*/</span>
        <span class="s2">serializers</span><span class="s4">?: </span><span class="s2">ReadonlyArray</span><span class="s4">&lt;(</span><span class="s2">value</span><span class="s4">: </span><span class="s2">any</span><span class="s4">) =&gt; </span><span class="s2">any</span><span class="s4">&gt; | </span><span class="s2">undefined</span><span class="s4">;</span>
    <span class="s4">}</span>
    <span class="s5">interface </span><span class="s2">TestContextWaitForOptions </span><span class="s4">{</span>
        <span class="s0">/**</span>
         <span class="s0">* The number of milliseconds to wait after an unsuccessful</span>
         <span class="s0">* invocation of `condition` before trying again.</span>
         <span class="s0">* </span><span class="s1">@default </span><span class="s0">50</span>
         <span class="s0">*/</span>
        <span class="s2">interval</span><span class="s4">?: </span><span class="s2">number </span><span class="s4">| </span><span class="s2">undefined</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The poll timeout in milliseconds. If `condition` has not</span>
         <span class="s0">* succeeded by the time this elapses, an error occurs.</span>
         <span class="s0">* </span><span class="s1">@default </span><span class="s0">1000</span>
         <span class="s0">*/</span>
        <span class="s2">timeout</span><span class="s4">?: </span><span class="s2">number </span><span class="s4">| </span><span class="s2">undefined</span><span class="s4">;</span>
    <span class="s4">}</span>

    <span class="s0">/**</span>
     <span class="s0">* An instance of `SuiteContext` is passed to each suite function in order to</span>
     <span class="s0">* interact with the test runner. However, the `SuiteContext` constructor is not</span>
     <span class="s0">* exposed as part of the API.</span>
     <span class="s0">* </span><span class="s1">@since </span><span class="s0">v18.7.0, v16.17.0</span>
     <span class="s0">*/</span>
    <span class="s5">class </span><span class="s2">SuiteContext </span><span class="s4">{</span>
        <span class="s0">/**</span>
         <span class="s0">* The absolute path of the test file that created the current suite. If a test file imports</span>
         <span class="s0">* additional modules that generate suites, the imported suites will return the path of the root test file.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v22.6.0</span>
         <span class="s0">*/</span>
        <span class="s2">readonly filePath</span><span class="s4">: </span><span class="s2">string </span><span class="s4">| </span><span class="s2">undefined</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The name of the suite.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v18.8.0, v16.18.0</span>
         <span class="s0">*/</span>
        <span class="s2">readonly name</span><span class="s4">: </span><span class="s2">string</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Can be used to abort test subtasks when the test has been aborted.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v18.7.0, v16.17.0</span>
         <span class="s0">*/</span>
        <span class="s2">readonly signal</span><span class="s4">: </span><span class="s2">AbortSignal</span><span class="s4">;</span>
    <span class="s4">}</span>
    <span class="s5">interface </span><span class="s2">TestOptions </span><span class="s4">{</span>
        <span class="s0">/**</span>
         <span class="s0">* If a number is provided, then that many tests would run in parallel.</span>
         <span class="s0">* If truthy, it would run (number of cpu cores - 1) tests in parallel.</span>
         <span class="s0">* For subtests, it will be `Infinity` tests in parallel.</span>
         <span class="s0">* If falsy, it would only run one test at a time.</span>
         <span class="s0">* If unspecified, subtests inherit this value from their parent.</span>
         <span class="s0">* </span><span class="s1">@default </span><span class="s0">false</span>
         <span class="s0">*/</span>
        <span class="s2">concurrency</span><span class="s4">?: </span><span class="s2">number </span><span class="s4">| </span><span class="s2">boolean </span><span class="s4">| </span><span class="s2">undefined</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If truthy, and the test context is configured to run `only` tests, then this test will be</span>
         <span class="s0">* run. Otherwise, the test is skipped.</span>
         <span class="s0">* </span><span class="s1">@default </span><span class="s0">false</span>
         <span class="s0">*/</span>
        <span class="s2">only</span><span class="s4">?: </span><span class="s2">boolean </span><span class="s4">| </span><span class="s2">undefined</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Allows aborting an in-progress test.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v18.8.0</span>
         <span class="s0">*/</span>
        <span class="s2">signal</span><span class="s4">?: </span><span class="s2">AbortSignal </span><span class="s4">| </span><span class="s2">undefined</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If truthy, the test is skipped. If a string is provided, that string is displayed in the</span>
         <span class="s0">* test results as the reason for skipping the test.</span>
         <span class="s0">* </span><span class="s1">@default </span><span class="s0">false</span>
         <span class="s0">*/</span>
        <span class="s2">skip</span><span class="s4">?: </span><span class="s2">boolean </span><span class="s4">| </span><span class="s2">string </span><span class="s4">| </span><span class="s2">undefined</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* A number of milliseconds the test will fail after. If unspecified, subtests inherit this</span>
         <span class="s0">* value from their parent.</span>
         <span class="s0">* </span><span class="s1">@default </span><span class="s0">Infinity</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v18.7.0</span>
         <span class="s0">*/</span>
        <span class="s2">timeout</span><span class="s4">?: </span><span class="s2">number </span><span class="s4">| </span><span class="s2">undefined</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If truthy, the test marked as `TODO`. If a string is provided, that string is displayed in</span>
         <span class="s0">* the test results as the reason why the test is `TODO`.</span>
         <span class="s0">* </span><span class="s1">@default </span><span class="s0">false</span>
         <span class="s0">*/</span>
        <span class="s2">todo</span><span class="s4">?: </span><span class="s2">boolean </span><span class="s4">| </span><span class="s2">string </span><span class="s4">| </span><span class="s2">undefined</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The number of assertions and subtests expected to be run in the test.</span>
         <span class="s0">* If the number of assertions run in the test does not match the number</span>
         <span class="s0">* specified in the plan, the test will fail.</span>
         <span class="s0">* </span><span class="s1">@default </span><span class="s0">undefined</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v22.2.0</span>
         <span class="s0">*/</span>
        <span class="s2">plan</span><span class="s4">?: </span><span class="s2">number </span><span class="s4">| </span><span class="s2">undefined</span><span class="s4">;</span>
    <span class="s4">}</span>
    <span class="s0">/**</span>
     <span class="s0">* This function creates a hook that runs before executing a suite.</span>
     <span class="s0">*</span>
     <span class="s0">* ```js</span>
     <span class="s0">* describe('tests', async () =&gt; {</span>
     <span class="s0">*   before(() =&gt; console.log('about to run some test'));</span>
     <span class="s0">*   it('is a subtest', () =&gt; {</span>
     <span class="s0">*     assert.ok('some relevant assertion here');</span>
     <span class="s0">*   });</span>
     <span class="s0">* });</span>
     <span class="s0">* ```</span>
     <span class="s0">* </span><span class="s1">@since </span><span class="s0">v18.8.0, v16.18.0</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">fn The hook function. If the hook uses callbacks, the callback function is passed as the second argument.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">options Configuration options for the hook.</span>
     <span class="s0">*/</span>
    <span class="s5">function </span><span class="s2">before</span><span class="s4">(</span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">HookFn</span><span class="s4">, </span><span class="s2">options</span><span class="s4">?: </span><span class="s2">HookOptions</span><span class="s4">): </span><span class="s5">void</span><span class="s4">;</span>
    <span class="s0">/**</span>
     <span class="s0">* This function creates a hook that runs after executing a suite.</span>
     <span class="s0">*</span>
     <span class="s0">* ```js</span>
     <span class="s0">* describe('tests', async () =&gt; {</span>
     <span class="s0">*   after(() =&gt; console.log('finished running tests'));</span>
     <span class="s0">*   it('is a subtest', () =&gt; {</span>
     <span class="s0">*     assert.ok('some relevant assertion here');</span>
     <span class="s0">*   });</span>
     <span class="s0">* });</span>
     <span class="s0">* ```</span>
     <span class="s0">* </span><span class="s1">@since </span><span class="s0">v18.8.0, v16.18.0</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">fn The hook function. If the hook uses callbacks, the callback function is passed as the second argument.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">options Configuration options for the hook.</span>
     <span class="s0">*/</span>
    <span class="s5">function </span><span class="s2">after</span><span class="s4">(</span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">HookFn</span><span class="s4">, </span><span class="s2">options</span><span class="s4">?: </span><span class="s2">HookOptions</span><span class="s4">): </span><span class="s5">void</span><span class="s4">;</span>
    <span class="s0">/**</span>
     <span class="s0">* This function creates a hook that runs before each test in the current suite.</span>
     <span class="s0">*</span>
     <span class="s0">* ```js</span>
     <span class="s0">* describe('tests', async () =&gt; {</span>
     <span class="s0">*   beforeEach(() =&gt; console.log('about to run a test'));</span>
     <span class="s0">*   it('is a subtest', () =&gt; {</span>
     <span class="s0">*     assert.ok('some relevant assertion here');</span>
     <span class="s0">*   });</span>
     <span class="s0">* });</span>
     <span class="s0">* ```</span>
     <span class="s0">* </span><span class="s1">@since </span><span class="s0">v18.8.0, v16.18.0</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">fn The hook function. If the hook uses callbacks, the callback function is passed as the second argument.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">options Configuration options for the hook.</span>
     <span class="s0">*/</span>
    <span class="s5">function </span><span class="s2">beforeEach</span><span class="s4">(</span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">HookFn</span><span class="s4">, </span><span class="s2">options</span><span class="s4">?: </span><span class="s2">HookOptions</span><span class="s4">): </span><span class="s5">void</span><span class="s4">;</span>
    <span class="s0">/**</span>
     <span class="s0">* This function creates a hook that runs after each test in the current suite.</span>
     <span class="s0">* The `afterEach()` hook is run even if the test fails.</span>
     <span class="s0">*</span>
     <span class="s0">* ```js</span>
     <span class="s0">* describe('tests', async () =&gt; {</span>
     <span class="s0">*   afterEach(() =&gt; console.log('finished running a test'));</span>
     <span class="s0">*   it('is a subtest', () =&gt; {</span>
     <span class="s0">*     assert.ok('some relevant assertion here');</span>
     <span class="s0">*   });</span>
     <span class="s0">* });</span>
     <span class="s0">* ```</span>
     <span class="s0">* </span><span class="s1">@since </span><span class="s0">v18.8.0, v16.18.0</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">fn The hook function. If the hook uses callbacks, the callback function is passed as the second argument.</span>
     <span class="s0">* </span><span class="s1">@param </span><span class="s0">options Configuration options for the hook.</span>
     <span class="s0">*/</span>
    <span class="s5">function </span><span class="s2">afterEach</span><span class="s4">(</span><span class="s2">fn</span><span class="s4">?: </span><span class="s2">HookFn</span><span class="s4">, </span><span class="s2">options</span><span class="s4">?: </span><span class="s2">HookOptions</span><span class="s4">): </span><span class="s5">void</span><span class="s4">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The hook function. The first argument is the context in which the hook is called.</span>
     <span class="s0">* If the hook uses callbacks, the callback function is passed as the second argument.</span>
     <span class="s0">*/</span>
    <span class="s2">type HookFn </span><span class="s4">= (</span><span class="s2">c</span><span class="s4">: </span><span class="s2">TestContext </span><span class="s4">| </span><span class="s2">SuiteContext</span><span class="s4">, </span><span class="s2">done</span><span class="s4">: (</span><span class="s2">result</span><span class="s4">?: </span><span class="s2">any</span><span class="s4">) =&gt; </span><span class="s5">void</span><span class="s4">) =&gt; </span><span class="s2">any</span><span class="s4">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The hook function. The first argument is a `TestContext` object.</span>
     <span class="s0">* If the hook uses callbacks, the callback function is passed as the second argument.</span>
     <span class="s0">*/</span>
    <span class="s2">type TestContextHookFn </span><span class="s4">= (</span><span class="s2">t</span><span class="s4">: </span><span class="s2">TestContext</span><span class="s4">, </span><span class="s2">done</span><span class="s4">: (</span><span class="s2">result</span><span class="s4">?: </span><span class="s2">any</span><span class="s4">) =&gt; </span><span class="s5">void</span><span class="s4">) =&gt; </span><span class="s2">any</span><span class="s4">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Configuration options for hooks.</span>
     <span class="s0">* </span><span class="s1">@since </span><span class="s0">v18.8.0</span>
     <span class="s0">*/</span>
    <span class="s5">interface </span><span class="s2">HookOptions </span><span class="s4">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Allows aborting an in-progress hook.</span>
         <span class="s0">*/</span>
        <span class="s2">signal</span><span class="s4">?: </span><span class="s2">AbortSignal </span><span class="s4">| </span><span class="s2">undefined</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* A number of milliseconds the hook will fail after. If unspecified, subtests inherit this</span>
         <span class="s0">* value from their parent.</span>
         <span class="s0">* </span><span class="s1">@default </span><span class="s0">Infinity</span>
         <span class="s0">*/</span>
        <span class="s2">timeout</span><span class="s4">?: </span><span class="s2">number </span><span class="s4">| </span><span class="s2">undefined</span><span class="s4">;</span>
    <span class="s4">}</span>
    <span class="s5">interface </span><span class="s2">MockFunctionOptions </span><span class="s4">{</span>
        <span class="s0">/**</span>
         <span class="s0">* The number of times that the mock will use the behavior of `implementation`.</span>
         <span class="s0">* Once the mock function has been called `times` times,</span>
         <span class="s0">* it will automatically restore the behavior of `original`.</span>
         <span class="s0">* This value must be an integer greater than zero.</span>
         <span class="s0">* </span><span class="s1">@default </span><span class="s0">Infinity</span>
         <span class="s0">*/</span>
        <span class="s2">times</span><span class="s4">?: </span><span class="s2">number </span><span class="s4">| </span><span class="s2">undefined</span><span class="s4">;</span>
    <span class="s4">}</span>
    <span class="s5">interface </span><span class="s2">MockMethodOptions </span><span class="s5">extends </span><span class="s2">MockFunctionOptions </span><span class="s4">{</span>
        <span class="s0">/**</span>
         <span class="s0">* If `true`, `object[methodName]` is treated as a getter.</span>
         <span class="s0">* This option cannot be used with the `setter` option.</span>
         <span class="s0">*/</span>
        <span class="s2">getter</span><span class="s4">?: </span><span class="s2">boolean </span><span class="s4">| </span><span class="s2">undefined</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If `true`, `object[methodName]` is treated as a setter.</span>
         <span class="s0">* This option cannot be used with the `getter` option.</span>
         <span class="s0">*/</span>
        <span class="s2">setter</span><span class="s4">?: </span><span class="s2">boolean </span><span class="s4">| </span><span class="s2">undefined</span><span class="s4">;</span>
    <span class="s4">}</span>
    <span class="s2">type Mock</span><span class="s4">&lt;</span><span class="s2">F </span><span class="s5">extends </span><span class="s2">Function</span><span class="s4">&gt; = </span><span class="s2">F </span><span class="s4">&amp; {</span>
        <span class="s2">mock</span><span class="s4">: </span><span class="s2">MockFunctionContext</span><span class="s4">&lt;</span><span class="s2">F</span><span class="s4">&gt;;</span>
    <span class="s4">};</span>
    <span class="s2">type NoOpFunction </span><span class="s4">= (</span><span class="s2">...args</span><span class="s4">: </span><span class="s2">any</span><span class="s4">[]) =&gt; </span><span class="s2">undefined</span><span class="s4">;</span>
    <span class="s2">type FunctionPropertyNames</span><span class="s4">&lt;</span><span class="s2">T</span><span class="s4">&gt; = {</span>
        <span class="s4">[</span><span class="s2">K </span><span class="s5">in </span><span class="s2">keyof T</span><span class="s4">]: </span><span class="s2">T</span><span class="s4">[</span><span class="s2">K</span><span class="s4">] </span><span class="s5">extends </span><span class="s2">Function </span><span class="s4">? </span><span class="s2">K </span><span class="s4">: </span><span class="s2">never</span><span class="s4">;</span>
    <span class="s4">}[</span><span class="s2">keyof T</span><span class="s4">];</span>
    <span class="s5">interface </span><span class="s2">MockModuleOptions </span><span class="s4">{</span>
        <span class="s0">/**</span>
         <span class="s0">* If false, each call to `require()` or `import()` generates a new mock module.</span>
         <span class="s0">* If true, subsequent calls will return the same module mock, and the mock module is inserted into the CommonJS cache.</span>
         <span class="s0">* </span><span class="s1">@default </span><span class="s0">false</span>
         <span class="s0">*/</span>
        <span class="s2">cache</span><span class="s4">?: </span><span class="s2">boolean </span><span class="s4">| </span><span class="s2">undefined</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The value to use as the mocked module's default export.</span>
         <span class="s0">*</span>
         <span class="s0">* If this value is not provided, ESM mocks do not include a default export.</span>
         <span class="s0">* If the mock is a CommonJS or builtin module, this setting is used as the value of `module.exports`.</span>
         <span class="s0">* If this value is not provided, CJS and builtin mocks use an empty object as the value of `module.exports`.</span>
         <span class="s0">*/</span>
        <span class="s2">defaultExport</span><span class="s4">?: </span><span class="s2">any</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* An object whose keys and values are used to create the named exports of the mock module.</span>
         <span class="s0">*</span>
         <span class="s0">* If the mock is a CommonJS or builtin module, these values are copied onto `module.exports`.</span>
         <span class="s0">* Therefore, if a mock is created with both named exports and a non-object default export,</span>
         <span class="s0">* the mock will throw an exception when used as a CJS or builtin module.</span>
         <span class="s0">*/</span>
        <span class="s2">namedExports</span><span class="s4">?: </span><span class="s2">object </span><span class="s4">| </span><span class="s2">undefined</span><span class="s4">;</span>
    <span class="s4">}</span>
    <span class="s0">/**</span>
     <span class="s0">* The `MockTracker` class is used to manage mocking functionality. The test runner</span>
     <span class="s0">* module provides a top level `mock` export which is a `MockTracker` instance.</span>
     <span class="s0">* Each test also provides its own `MockTracker` instance via the test context's `mock` property.</span>
     <span class="s0">* </span><span class="s1">@since </span><span class="s0">v19.1.0, v18.13.0</span>
     <span class="s0">*/</span>
    <span class="s5">class </span><span class="s2">MockTracker </span><span class="s4">{</span>
        <span class="s0">/**</span>
         <span class="s0">* This function is used to create a mock function.</span>
         <span class="s0">*</span>
         <span class="s0">* The following example creates a mock function that increments a counter by one</span>
         <span class="s0">* on each invocation. The `times` option is used to modify the mock behavior such</span>
         <span class="s0">* that the first two invocations add two to the counter instead of one.</span>
         <span class="s0">*</span>
         <span class="s0">* ```js</span>
         <span class="s0">* test('mocks a counting function', (t) =&gt; {</span>
         <span class="s0">*   let cnt = 0;</span>
         <span class="s0">*</span>
         <span class="s0">*   function addOne() {</span>
         <span class="s0">*     cnt++;</span>
         <span class="s0">*     return cnt;</span>
         <span class="s0">*   }</span>
         <span class="s0">*</span>
         <span class="s0">*   function addTwo() {</span>
         <span class="s0">*     cnt += 2;</span>
         <span class="s0">*     return cnt;</span>
         <span class="s0">*   }</span>
         <span class="s0">*</span>
         <span class="s0">*   const fn = t.mock.fn(addOne, addTwo, { times: 2 });</span>
         <span class="s0">*</span>
         <span class="s0">*   assert.strictEqual(fn(), 2);</span>
         <span class="s0">*   assert.strictEqual(fn(), 4);</span>
         <span class="s0">*   assert.strictEqual(fn(), 5);</span>
         <span class="s0">*   assert.strictEqual(fn(), 6);</span>
         <span class="s0">* });</span>
         <span class="s0">* ```</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v19.1.0, v18.13.0</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">original An optional function to create a mock on.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">implementation An optional function used as the mock implementation for `original`. This is useful for creating mocks that exhibit one behavior for a specified number of calls and</span>
         <span class="s0">* then restore the behavior of `original`.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">options Optional configuration options for the mock function.</span>
         <span class="s0">* </span><span class="s1">@return </span><span class="s0">The mocked function. The mocked function contains a special `mock` property, which is an instance of {</span><span class="s1">@link </span><span class="s0">MockFunctionContext}, and can be used for inspecting and changing the</span>
         <span class="s0">* behavior of the mocked function.</span>
         <span class="s0">*/</span>
        <span class="s2">fn</span><span class="s4">&lt;</span><span class="s2">F </span><span class="s5">extends </span><span class="s2">Function </span><span class="s4">= </span><span class="s2">NoOpFunction</span><span class="s4">&gt;(</span><span class="s2">original</span><span class="s4">?: </span><span class="s2">F</span><span class="s4">, </span><span class="s2">options</span><span class="s4">?: </span><span class="s2">MockFunctionOptions</span><span class="s4">): </span><span class="s2">Mock</span><span class="s4">&lt;</span><span class="s2">F</span><span class="s4">&gt;;</span>
        <span class="s2">fn</span><span class="s4">&lt;</span><span class="s2">F </span><span class="s5">extends </span><span class="s2">Function </span><span class="s4">= </span><span class="s2">NoOpFunction</span><span class="s4">, </span><span class="s2">Implementation </span><span class="s5">extends </span><span class="s2">Function </span><span class="s4">= </span><span class="s2">F</span><span class="s4">&gt;(</span>
            <span class="s2">original</span><span class="s4">?: </span><span class="s2">F</span><span class="s4">,</span>
            <span class="s2">implementation</span><span class="s4">?: </span><span class="s2">Implementation</span><span class="s4">,</span>
            <span class="s2">options</span><span class="s4">?: </span><span class="s2">MockFunctionOptions</span><span class="s4">,</span>
        <span class="s4">): </span><span class="s2">Mock</span><span class="s4">&lt;</span><span class="s2">F </span><span class="s4">| </span><span class="s2">Implementation</span><span class="s4">&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* This function is used to create a mock on an existing object method. The</span>
         <span class="s0">* following example demonstrates how a mock is created on an existing object</span>
         <span class="s0">* method.</span>
         <span class="s0">*</span>
         <span class="s0">* ```js</span>
         <span class="s0">* test('spies on an object method', (t) =&gt; {</span>
         <span class="s0">*   const number = {</span>
         <span class="s0">*     value: 5,</span>
         <span class="s0">*     subtract(a) {</span>
         <span class="s0">*       return this.value - a;</span>
         <span class="s0">*     },</span>
         <span class="s0">*   };</span>
         <span class="s0">*</span>
         <span class="s0">*   t.mock.method(number, 'subtract');</span>
         <span class="s0">*   assert.strictEqual(number.subtract.mock.calls.length, 0);</span>
         <span class="s0">*   assert.strictEqual(number.subtract(3), 2);</span>
         <span class="s0">*   assert.strictEqual(number.subtract.mock.calls.length, 1);</span>
         <span class="s0">*</span>
         <span class="s0">*   const call = number.subtract.mock.calls[0];</span>
         <span class="s0">*</span>
         <span class="s0">*   assert.deepStrictEqual(call.arguments, [3]);</span>
         <span class="s0">*   assert.strictEqual(call.result, 2);</span>
         <span class="s0">*   assert.strictEqual(call.error, undefined);</span>
         <span class="s0">*   assert.strictEqual(call.target, undefined);</span>
         <span class="s0">*   assert.strictEqual(call.this, number);</span>
         <span class="s0">* });</span>
         <span class="s0">* ```</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v19.1.0, v18.13.0</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">object The object whose method is being mocked.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">methodName The identifier of the method on `object` to mock. If `object[methodName]` is not a function, an error is thrown.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">implementation An optional function used as the mock implementation for `object[methodName]`.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">options Optional configuration options for the mock method.</span>
         <span class="s0">* </span><span class="s1">@return </span><span class="s0">The mocked method. The mocked method contains a special `mock` property, which is an instance of {</span><span class="s1">@link </span><span class="s0">MockFunctionContext}, and can be used for inspecting and changing the</span>
         <span class="s0">* behavior of the mocked method.</span>
         <span class="s0">*/</span>
        <span class="s2">method</span><span class="s4">&lt;</span>
            <span class="s2">MockedObject </span><span class="s5">extends </span><span class="s2">object</span><span class="s4">,</span>
            <span class="s2">MethodName </span><span class="s5">extends </span><span class="s2">FunctionPropertyNames</span><span class="s4">&lt;</span><span class="s2">MockedObject</span><span class="s4">&gt;,</span>
        <span class="s4">&gt;(</span>
            <span class="s2">object</span><span class="s4">: </span><span class="s2">MockedObject</span><span class="s4">,</span>
            <span class="s2">methodName</span><span class="s4">: </span><span class="s2">MethodName</span><span class="s4">,</span>
            <span class="s2">options</span><span class="s4">?: </span><span class="s2">MockFunctionOptions</span><span class="s4">,</span>
        <span class="s4">): </span><span class="s2">MockedObject</span><span class="s4">[</span><span class="s2">MethodName</span><span class="s4">] </span><span class="s5">extends </span><span class="s2">Function </span><span class="s4">? </span><span class="s2">Mock</span><span class="s4">&lt;</span><span class="s2">MockedObject</span><span class="s4">[</span><span class="s2">MethodName</span><span class="s4">]&gt;</span>
            <span class="s4">: </span><span class="s2">never</span><span class="s4">;</span>
        <span class="s2">method</span><span class="s4">&lt;</span>
            <span class="s2">MockedObject </span><span class="s5">extends </span><span class="s2">object</span><span class="s4">,</span>
            <span class="s2">MethodName </span><span class="s5">extends </span><span class="s2">FunctionPropertyNames</span><span class="s4">&lt;</span><span class="s2">MockedObject</span><span class="s4">&gt;,</span>
            <span class="s2">Implementation </span><span class="s5">extends </span><span class="s2">Function</span><span class="s4">,</span>
        <span class="s4">&gt;(</span>
            <span class="s2">object</span><span class="s4">: </span><span class="s2">MockedObject</span><span class="s4">,</span>
            <span class="s2">methodName</span><span class="s4">: </span><span class="s2">MethodName</span><span class="s4">,</span>
            <span class="s2">implementation</span><span class="s4">: </span><span class="s2">Implementation</span><span class="s4">,</span>
            <span class="s2">options</span><span class="s4">?: </span><span class="s2">MockFunctionOptions</span><span class="s4">,</span>
        <span class="s4">): </span><span class="s2">MockedObject</span><span class="s4">[</span><span class="s2">MethodName</span><span class="s4">] </span><span class="s5">extends </span><span class="s2">Function </span><span class="s4">? </span><span class="s2">Mock</span><span class="s4">&lt;</span><span class="s2">MockedObject</span><span class="s4">[</span><span class="s2">MethodName</span><span class="s4">] | </span><span class="s2">Implementation</span><span class="s4">&gt;</span>
            <span class="s4">: </span><span class="s2">never</span><span class="s4">;</span>
        <span class="s2">method</span><span class="s4">&lt;</span><span class="s2">MockedObject </span><span class="s5">extends </span><span class="s2">object</span><span class="s4">&gt;(</span>
            <span class="s2">object</span><span class="s4">: </span><span class="s2">MockedObject</span><span class="s4">,</span>
            <span class="s2">methodName</span><span class="s4">: </span><span class="s2">keyof MockedObject</span><span class="s4">,</span>
            <span class="s2">options</span><span class="s4">: </span><span class="s2">MockMethodOptions</span><span class="s4">,</span>
        <span class="s4">): </span><span class="s2">Mock</span><span class="s4">&lt;</span><span class="s2">Function</span><span class="s4">&gt;;</span>
        <span class="s2">method</span><span class="s4">&lt;</span><span class="s2">MockedObject </span><span class="s5">extends </span><span class="s2">object</span><span class="s4">&gt;(</span>
            <span class="s2">object</span><span class="s4">: </span><span class="s2">MockedObject</span><span class="s4">,</span>
            <span class="s2">methodName</span><span class="s4">: </span><span class="s2">keyof MockedObject</span><span class="s4">,</span>
            <span class="s2">implementation</span><span class="s4">: </span><span class="s2">Function</span><span class="s4">,</span>
            <span class="s2">options</span><span class="s4">: </span><span class="s2">MockMethodOptions</span><span class="s4">,</span>
        <span class="s4">): </span><span class="s2">Mock</span><span class="s4">&lt;</span><span class="s2">Function</span><span class="s4">&gt;;</span>

        <span class="s0">/**</span>
         <span class="s0">* This function is syntax sugar for `MockTracker.method` with `options.getter` set to `true`.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v19.3.0, v18.13.0</span>
         <span class="s0">*/</span>
        <span class="s2">getter</span><span class="s4">&lt;</span>
            <span class="s2">MockedObject </span><span class="s5">extends </span><span class="s2">object</span><span class="s4">,</span>
            <span class="s2">MethodName </span><span class="s5">extends </span><span class="s2">keyof MockedObject</span><span class="s4">,</span>
        <span class="s4">&gt;(</span>
            <span class="s2">object</span><span class="s4">: </span><span class="s2">MockedObject</span><span class="s4">,</span>
            <span class="s2">methodName</span><span class="s4">: </span><span class="s2">MethodName</span><span class="s4">,</span>
            <span class="s2">options</span><span class="s4">?: </span><span class="s2">MockFunctionOptions</span><span class="s4">,</span>
        <span class="s4">): </span><span class="s2">Mock</span><span class="s4">&lt;() =&gt; </span><span class="s2">MockedObject</span><span class="s4">[</span><span class="s2">MethodName</span><span class="s4">]&gt;;</span>
        <span class="s2">getter</span><span class="s4">&lt;</span>
            <span class="s2">MockedObject </span><span class="s5">extends </span><span class="s2">object</span><span class="s4">,</span>
            <span class="s2">MethodName </span><span class="s5">extends </span><span class="s2">keyof MockedObject</span><span class="s4">,</span>
            <span class="s2">Implementation </span><span class="s5">extends </span><span class="s2">Function</span><span class="s4">,</span>
        <span class="s4">&gt;(</span>
            <span class="s2">object</span><span class="s4">: </span><span class="s2">MockedObject</span><span class="s4">,</span>
            <span class="s2">methodName</span><span class="s4">: </span><span class="s2">MethodName</span><span class="s4">,</span>
            <span class="s2">implementation</span><span class="s4">?: </span><span class="s2">Implementation</span><span class="s4">,</span>
            <span class="s2">options</span><span class="s4">?: </span><span class="s2">MockFunctionOptions</span><span class="s4">,</span>
        <span class="s4">): </span><span class="s2">Mock</span><span class="s4">&lt;(() =&gt; </span><span class="s2">MockedObject</span><span class="s4">[</span><span class="s2">MethodName</span><span class="s4">]) | </span><span class="s2">Implementation</span><span class="s4">&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* This function is syntax sugar for `MockTracker.method` with `options.setter` set to `true`.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v19.3.0, v18.13.0</span>
         <span class="s0">*/</span>
        <span class="s2">setter</span><span class="s4">&lt;</span>
            <span class="s2">MockedObject </span><span class="s5">extends </span><span class="s2">object</span><span class="s4">,</span>
            <span class="s2">MethodName </span><span class="s5">extends </span><span class="s2">keyof MockedObject</span><span class="s4">,</span>
        <span class="s4">&gt;(</span>
            <span class="s2">object</span><span class="s4">: </span><span class="s2">MockedObject</span><span class="s4">,</span>
            <span class="s2">methodName</span><span class="s4">: </span><span class="s2">MethodName</span><span class="s4">,</span>
            <span class="s2">options</span><span class="s4">?: </span><span class="s2">MockFunctionOptions</span><span class="s4">,</span>
        <span class="s4">): </span><span class="s2">Mock</span><span class="s4">&lt;(</span><span class="s2">value</span><span class="s4">: </span><span class="s2">MockedObject</span><span class="s4">[</span><span class="s2">MethodName</span><span class="s4">]) =&gt; </span><span class="s5">void</span><span class="s4">&gt;;</span>
        <span class="s2">setter</span><span class="s4">&lt;</span>
            <span class="s2">MockedObject </span><span class="s5">extends </span><span class="s2">object</span><span class="s4">,</span>
            <span class="s2">MethodName </span><span class="s5">extends </span><span class="s2">keyof MockedObject</span><span class="s4">,</span>
            <span class="s2">Implementation </span><span class="s5">extends </span><span class="s2">Function</span><span class="s4">,</span>
        <span class="s4">&gt;(</span>
            <span class="s2">object</span><span class="s4">: </span><span class="s2">MockedObject</span><span class="s4">,</span>
            <span class="s2">methodName</span><span class="s4">: </span><span class="s2">MethodName</span><span class="s4">,</span>
            <span class="s2">implementation</span><span class="s4">?: </span><span class="s2">Implementation</span><span class="s4">,</span>
            <span class="s2">options</span><span class="s4">?: </span><span class="s2">MockFunctionOptions</span><span class="s4">,</span>
        <span class="s4">): </span><span class="s2">Mock</span><span class="s4">&lt;((</span><span class="s2">value</span><span class="s4">: </span><span class="s2">MockedObject</span><span class="s4">[</span><span class="s2">MethodName</span><span class="s4">]) =&gt; </span><span class="s5">void</span><span class="s4">) | </span><span class="s2">Implementation</span><span class="s4">&gt;;</span>

        <span class="s0">/**</span>
         <span class="s0">* This function is used to mock the exports of ECMAScript modules, CommonJS modules, and Node.js builtin modules.</span>
         <span class="s0">* Any references to the original module prior to mocking are not impacted.</span>
         <span class="s0">*</span>
         <span class="s0">* Only available through the [--experimental-test-module-mocks](https://nodejs.org/api/cli.html#--experimental-test-module-mocks) flag.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v22.3.0</span>
         <span class="s0">* </span><span class="s1">@experimental</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">specifier A string identifying the module to mock.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">options Optional configuration options for the mock module.</span>
         <span class="s0">*/</span>
        <span class="s2">module</span><span class="s4">(</span><span class="s2">specifier</span><span class="s4">: </span><span class="s2">string</span><span class="s4">, </span><span class="s2">options</span><span class="s4">?: </span><span class="s2">MockModuleOptions</span><span class="s4">): </span><span class="s2">MockModuleContext</span><span class="s4">;</span>

        <span class="s0">/**</span>
         <span class="s0">* This function restores the default behavior of all mocks that were previously</span>
         <span class="s0">* created by this `MockTracker` and disassociates the mocks from the `MockTracker` instance. Once disassociated, the mocks can still be used, but the `MockTracker` instance can no longer be</span>
         <span class="s0">* used to reset their behavior or</span>
         <span class="s0">* otherwise interact with them.</span>
         <span class="s0">*</span>
         <span class="s0">* After each test completes, this function is called on the test context's `MockTracker`. If the global `MockTracker` is used extensively, calling this</span>
         <span class="s0">* function manually is recommended.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v19.1.0, v18.13.0</span>
         <span class="s0">*/</span>
        <span class="s2">reset</span><span class="s4">(): </span><span class="s5">void</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* This function restores the default behavior of all mocks that were previously</span>
         <span class="s0">* created by this `MockTracker`. Unlike `mock.reset()`, `mock.restoreAll()` does</span>
         <span class="s0">* not disassociate the mocks from the `MockTracker` instance.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v19.1.0, v18.13.0</span>
         <span class="s0">*/</span>
        <span class="s2">restoreAll</span><span class="s4">(): </span><span class="s5">void</span><span class="s4">;</span>

        <span class="s2">timers</span><span class="s4">: </span><span class="s2">MockTimers</span><span class="s4">;</span>
    <span class="s4">}</span>
    <span class="s5">const </span><span class="s2">mock</span><span class="s4">: </span><span class="s2">MockTracker</span><span class="s4">;</span>
    <span class="s5">interface </span><span class="s2">MockFunctionCall</span><span class="s4">&lt;</span>
        <span class="s2">F </span><span class="s5">extends </span><span class="s2">Function</span><span class="s4">,</span>
        <span class="s2">ReturnType </span><span class="s4">= </span><span class="s2">F </span><span class="s5">extends </span><span class="s4">(</span><span class="s2">...args</span><span class="s4">: </span><span class="s2">any</span><span class="s4">) =&gt; </span><span class="s2">infer T </span><span class="s4">? </span><span class="s2">T</span>
            <span class="s4">: </span><span class="s2">F </span><span class="s5">extends </span><span class="s2">abstract </span><span class="s5">new</span><span class="s4">(</span><span class="s2">...args</span><span class="s4">: </span><span class="s2">any</span><span class="s4">) =&gt; </span><span class="s2">infer T </span><span class="s4">? </span><span class="s2">T</span>
            <span class="s4">: </span><span class="s2">unknown</span><span class="s4">,</span>
        <span class="s2">Args </span><span class="s4">= </span><span class="s2">F </span><span class="s5">extends </span><span class="s4">(</span><span class="s2">...args</span><span class="s4">: </span><span class="s2">infer Y</span><span class="s4">) =&gt; </span><span class="s2">any </span><span class="s4">? </span><span class="s2">Y</span>
            <span class="s4">: </span><span class="s2">F </span><span class="s5">extends </span><span class="s2">abstract </span><span class="s5">new</span><span class="s4">(</span><span class="s2">...args</span><span class="s4">: </span><span class="s2">infer Y</span><span class="s4">) =&gt; </span><span class="s2">any </span><span class="s4">? </span><span class="s2">Y</span>
            <span class="s4">: </span><span class="s2">unknown</span><span class="s4">[],</span>
    <span class="s4">&gt; {</span>
        <span class="s0">/**</span>
         <span class="s0">* An array of the arguments passed to the mock function.</span>
         <span class="s0">*/</span>
        <span class="s2">arguments</span><span class="s4">: </span><span class="s2">Args</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If the mocked function threw then this property contains the thrown value.</span>
         <span class="s0">*/</span>
        <span class="s2">error</span><span class="s4">: </span><span class="s2">unknown </span><span class="s4">| </span><span class="s2">undefined</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The value returned by the mocked function.</span>
         <span class="s0">*</span>
         <span class="s0">* If the mocked function threw, it will be `undefined`.</span>
         <span class="s0">*/</span>
        <span class="s2">result</span><span class="s4">: </span><span class="s2">ReturnType </span><span class="s4">| </span><span class="s2">undefined</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* An `Error` object whose stack can be used to determine the callsite of the mocked function invocation.</span>
         <span class="s0">*/</span>
        <span class="s2">stack</span><span class="s4">: </span><span class="s2">Error</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* If the mocked function is a constructor, this field contains the class being constructed.</span>
         <span class="s0">* Otherwise this will be `undefined`.</span>
         <span class="s0">*/</span>
        <span class="s2">target</span><span class="s4">: </span><span class="s2">F </span><span class="s5">extends </span><span class="s2">abstract </span><span class="s5">new</span><span class="s4">(</span><span class="s2">...args</span><span class="s4">: </span><span class="s2">any</span><span class="s4">) =&gt; </span><span class="s2">any </span><span class="s4">? </span><span class="s2">F </span><span class="s4">: </span><span class="s2">undefined</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The mocked function's `this` value.</span>
         <span class="s0">*/</span>
        <span class="s5">this</span><span class="s4">: </span><span class="s2">unknown</span><span class="s4">;</span>
    <span class="s4">}</span>
    <span class="s0">/**</span>
     <span class="s0">* The `MockFunctionContext` class is used to inspect or manipulate the behavior of</span>
     <span class="s0">* mocks created via the `MockTracker` APIs.</span>
     <span class="s0">* </span><span class="s1">@since </span><span class="s0">v19.1.0, v18.13.0</span>
     <span class="s0">*/</span>
    <span class="s5">class </span><span class="s2">MockFunctionContext</span><span class="s4">&lt;</span><span class="s2">F </span><span class="s5">extends </span><span class="s2">Function</span><span class="s4">&gt; {</span>
        <span class="s0">/**</span>
         <span class="s0">* A getter that returns a copy of the internal array used to track calls to the</span>
         <span class="s0">* mock. Each entry in the array is an object with the following properties.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v19.1.0, v18.13.0</span>
         <span class="s0">*/</span>
        <span class="s2">readonly calls</span><span class="s4">: </span><span class="s2">Array</span><span class="s4">&lt;</span><span class="s2">MockFunctionCall</span><span class="s4">&lt;</span><span class="s2">F</span><span class="s4">&gt;&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* This function returns the number of times that this mock has been invoked. This</span>
         <span class="s0">* function is more efficient than checking `ctx.calls.length` because `ctx.calls` is a getter that creates a copy of the internal call tracking array.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v19.1.0, v18.13.0</span>
         <span class="s0">* </span><span class="s1">@return </span><span class="s0">The number of times that this mock has been invoked.</span>
         <span class="s0">*/</span>
        <span class="s2">callCount</span><span class="s4">(): </span><span class="s2">number</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* This function is used to change the behavior of an existing mock.</span>
         <span class="s0">*</span>
         <span class="s0">* The following example creates a mock function using `t.mock.fn()`, calls the</span>
         <span class="s0">* mock function, and then changes the mock implementation to a different function.</span>
         <span class="s0">*</span>
         <span class="s0">* ```js</span>
         <span class="s0">* test('changes a mock behavior', (t) =&gt; {</span>
         <span class="s0">*   let cnt = 0;</span>
         <span class="s0">*</span>
         <span class="s0">*   function addOne() {</span>
         <span class="s0">*     cnt++;</span>
         <span class="s0">*     return cnt;</span>
         <span class="s0">*   }</span>
         <span class="s0">*</span>
         <span class="s0">*   function addTwo() {</span>
         <span class="s0">*     cnt += 2;</span>
         <span class="s0">*     return cnt;</span>
         <span class="s0">*   }</span>
         <span class="s0">*</span>
         <span class="s0">*   const fn = t.mock.fn(addOne);</span>
         <span class="s0">*</span>
         <span class="s0">*   assert.strictEqual(fn(), 1);</span>
         <span class="s0">*   fn.mock.mockImplementation(addTwo);</span>
         <span class="s0">*   assert.strictEqual(fn(), 3);</span>
         <span class="s0">*   assert.strictEqual(fn(), 5);</span>
         <span class="s0">* });</span>
         <span class="s0">* ```</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v19.1.0, v18.13.0</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">implementation The function to be used as the mock's new implementation.</span>
         <span class="s0">*/</span>
        <span class="s2">mockImplementation</span><span class="s4">(</span><span class="s2">implementation</span><span class="s4">: </span><span class="s2">F</span><span class="s4">): </span><span class="s5">void</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* This function is used to change the behavior of an existing mock for a single</span>
         <span class="s0">* invocation. Once invocation `onCall` has occurred, the mock will revert to</span>
         <span class="s0">* whatever behavior it would have used had `mockImplementationOnce()` not been</span>
         <span class="s0">* called.</span>
         <span class="s0">*</span>
         <span class="s0">* The following example creates a mock function using `t.mock.fn()`, calls the</span>
         <span class="s0">* mock function, changes the mock implementation to a different function for the</span>
         <span class="s0">* next invocation, and then resumes its previous behavior.</span>
         <span class="s0">*</span>
         <span class="s0">* ```js</span>
         <span class="s0">* test('changes a mock behavior once', (t) =&gt; {</span>
         <span class="s0">*   let cnt = 0;</span>
         <span class="s0">*</span>
         <span class="s0">*   function addOne() {</span>
         <span class="s0">*     cnt++;</span>
         <span class="s0">*     return cnt;</span>
         <span class="s0">*   }</span>
         <span class="s0">*</span>
         <span class="s0">*   function addTwo() {</span>
         <span class="s0">*     cnt += 2;</span>
         <span class="s0">*     return cnt;</span>
         <span class="s0">*   }</span>
         <span class="s0">*</span>
         <span class="s0">*   const fn = t.mock.fn(addOne);</span>
         <span class="s0">*</span>
         <span class="s0">*   assert.strictEqual(fn(), 1);</span>
         <span class="s0">*   fn.mock.mockImplementationOnce(addTwo);</span>
         <span class="s0">*   assert.strictEqual(fn(), 3);</span>
         <span class="s0">*   assert.strictEqual(fn(), 4);</span>
         <span class="s0">* });</span>
         <span class="s0">* ```</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v19.1.0, v18.13.0</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">implementation The function to be used as the mock's implementation for the invocation number specified by `onCall`.</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">onCall The invocation number that will use `implementation`. If the specified invocation has already occurred then an exception is thrown.</span>
         <span class="s0">*/</span>
        <span class="s2">mockImplementationOnce</span><span class="s4">(</span><span class="s2">implementation</span><span class="s4">: </span><span class="s2">F</span><span class="s4">, </span><span class="s2">onCall</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">): </span><span class="s5">void</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Resets the call history of the mock function.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v19.3.0, v18.13.0</span>
         <span class="s0">*/</span>
        <span class="s2">resetCalls</span><span class="s4">(): </span><span class="s5">void</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Resets the implementation of the mock function to its original behavior. The</span>
         <span class="s0">* mock can still be used after calling this function.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v19.1.0, v18.13.0</span>
         <span class="s0">*/</span>
        <span class="s2">restore</span><span class="s4">(): </span><span class="s5">void</span><span class="s4">;</span>
    <span class="s4">}</span>
    <span class="s0">/**</span>
     <span class="s0">* </span><span class="s1">@since </span><span class="s0">v22.3.0</span>
     <span class="s0">* </span><span class="s1">@experimental</span>
     <span class="s0">*/</span>
    <span class="s5">class </span><span class="s2">MockModuleContext </span><span class="s4">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Resets the implementation of the mock module.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v22.3.0</span>
         <span class="s0">*/</span>
        <span class="s2">restore</span><span class="s4">(): </span><span class="s5">void</span><span class="s4">;</span>
    <span class="s4">}</span>

    <span class="s2">type Timer </span><span class="s4">= </span><span class="s3">&quot;setInterval&quot; </span><span class="s4">| </span><span class="s3">&quot;setTimeout&quot; </span><span class="s4">| </span><span class="s3">&quot;setImmediate&quot; </span><span class="s4">| </span><span class="s3">&quot;Date&quot;</span><span class="s4">;</span>
    <span class="s5">interface </span><span class="s2">MockTimersOptions </span><span class="s4">{</span>
        <span class="s2">apis</span><span class="s4">: </span><span class="s2">Timer</span><span class="s4">[];</span>
        <span class="s2">now</span><span class="s4">?: </span><span class="s2">number </span><span class="s4">| </span><span class="s2">Date </span><span class="s4">| </span><span class="s2">undefined</span><span class="s4">;</span>
    <span class="s4">}</span>
    <span class="s0">/**</span>
     <span class="s0">* Mocking timers is a technique commonly used in software testing to simulate and</span>
     <span class="s0">* control the behavior of timers, such as `setInterval` and `setTimeout`,</span>
     <span class="s0">* without actually waiting for the specified time intervals.</span>
     <span class="s0">*</span>
     <span class="s0">* The MockTimers API also allows for mocking of the `Date` constructor and</span>
     <span class="s0">* `setImmediate`/`clearImmediate` functions.</span>
     <span class="s0">*</span>
     <span class="s0">* The `MockTracker` provides a top-level `timers` export</span>
     <span class="s0">* which is a `MockTimers` instance.</span>
     <span class="s0">* </span><span class="s1">@since </span><span class="s0">v20.4.0</span>
     <span class="s0">* </span><span class="s1">@experimental</span>
     <span class="s0">*/</span>
    <span class="s5">class </span><span class="s2">MockTimers </span><span class="s4">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Enables timer mocking for the specified timers.</span>
         <span class="s0">*</span>
         <span class="s0">* **Note:** When you enable mocking for a specific timer, its associated</span>
         <span class="s0">* clear function will also be implicitly mocked.</span>
         <span class="s0">*</span>
         <span class="s0">* **Note:** Mocking `Date` will affect the behavior of the mocked timers</span>
         <span class="s0">* as they use the same internal clock.</span>
         <span class="s0">*</span>
         <span class="s0">* Example usage without setting initial time:</span>
         <span class="s0">*</span>
         <span class="s0">* ```js</span>
         <span class="s0">* import { mock } from 'node:test';</span>
         <span class="s0">* mock.timers.enable({ apis: ['setInterval', 'Date'], now: 1234 });</span>
         <span class="s0">* ```</span>
         <span class="s0">*</span>
         <span class="s0">* The above example enables mocking for the `Date` constructor, `setInterval` timer and</span>
         <span class="s0">* implicitly mocks the `clearInterval` function. Only the `Date` constructor from `globalThis`,</span>
         <span class="s0">* `setInterval` and `clearInterval` functions from `node:timers`, `node:timers/promises`, and `globalThis` will be mocked.</span>
         <span class="s0">*</span>
         <span class="s0">* Example usage with initial time set</span>
         <span class="s0">*</span>
         <span class="s0">* ```js</span>
         <span class="s0">* import { mock } from 'node:test';</span>
         <span class="s0">* mock.timers.enable({ apis: ['Date'], now: 1000 });</span>
         <span class="s0">* ```</span>
         <span class="s0">*</span>
         <span class="s0">* Example usage with initial Date object as time set</span>
         <span class="s0">*</span>
         <span class="s0">* ```js</span>
         <span class="s0">* import { mock } from 'node:test';</span>
         <span class="s0">* mock.timers.enable({ apis: ['Date'], now: new Date() });</span>
         <span class="s0">* ```</span>
         <span class="s0">*</span>
         <span class="s0">* Alternatively, if you call `mock.timers.enable()` without any parameters:</span>
         <span class="s0">*</span>
         <span class="s0">* All timers (`'setInterval'`, `'clearInterval'`, `'Date'`, `'setImmediate'`, `'clearImmediate'`, `'setTimeout'`, and `'clearTimeout'`)</span>
         <span class="s0">* will be mocked.</span>
         <span class="s0">*</span>
         <span class="s0">* The `setInterval`, `clearInterval`, `setTimeout`, and `clearTimeout` functions from `node:timers`, `node:timers/promises`,</span>
         <span class="s0">* and `globalThis` will be mocked.</span>
         <span class="s0">* The `Date` constructor from `globalThis` will be mocked.</span>
         <span class="s0">*</span>
         <span class="s0">* If there is no initial epoch set, the initial date will be based on 0 in the Unix epoch. This is `January 1st, 1970, 00:00:00 UTC`. You can</span>
         <span class="s0">* set an initial date by passing a now property to the `.enable()` method. This value will be used as the initial date for the mocked Date</span>
         <span class="s0">* object. It can either be a positive integer, or another Date object.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v20.4.0</span>
         <span class="s0">*/</span>
        <span class="s2">enable</span><span class="s4">(</span><span class="s2">options</span><span class="s4">?: </span><span class="s2">MockTimersOptions</span><span class="s4">): </span><span class="s5">void</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* You can use the `.setTime()` method to manually move the mocked date to another time. This method only accepts a positive integer.</span>
         <span class="s0">* Note: This method will execute any mocked timers that are in the past from the new time.</span>
         <span class="s0">* In the below example we are setting a new time for the mocked date.</span>
         <span class="s0">* ```js</span>
         <span class="s0">* import assert from 'node:assert';</span>
         <span class="s0">* import { test } from 'node:test';</span>
         <span class="s0">* test('sets the time of a date object', (context) =&gt; {</span>
         <span class="s0">*   // Optionally choose what to mock</span>
         <span class="s0">*   context.mock.timers.enable({ apis: ['Date'], now: 100 });</span>
         <span class="s0">*   assert.strictEqual(Date.now(), 100);</span>
         <span class="s0">*   // Advance in time will also advance the date</span>
         <span class="s0">*   context.mock.timers.setTime(1000);</span>
         <span class="s0">*   context.mock.timers.tick(200);</span>
         <span class="s0">*   assert.strictEqual(Date.now(), 1200);</span>
         <span class="s0">* });</span>
         <span class="s0">* ```</span>
         <span class="s0">*/</span>
        <span class="s2">setTime</span><span class="s4">(</span><span class="s2">time</span><span class="s4">: </span><span class="s2">number</span><span class="s4">): </span><span class="s5">void</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* This function restores the default behavior of all mocks that were previously</span>
         <span class="s0">* created by this `MockTimers` instance and disassociates the mocks</span>
         <span class="s0">* from the `MockTracker` instance.</span>
         <span class="s0">*</span>
         <span class="s0">* **Note:** After each test completes, this function is called on</span>
         <span class="s0">* the test context's `MockTracker`.</span>
         <span class="s0">*</span>
         <span class="s0">* ```js</span>
         <span class="s0">* import { mock } from 'node:test';</span>
         <span class="s0">* mock.timers.reset();</span>
         <span class="s0">* ```</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v20.4.0</span>
         <span class="s0">*/</span>
        <span class="s2">reset</span><span class="s4">(): </span><span class="s5">void</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Advances time for all mocked timers.</span>
         <span class="s0">*</span>
         <span class="s0">* **Note:** This diverges from how `setTimeout` in Node.js behaves and accepts</span>
         <span class="s0">* only positive numbers. In Node.js, `setTimeout` with negative numbers is</span>
         <span class="s0">* only supported for web compatibility reasons.</span>
         <span class="s0">*</span>
         <span class="s0">* The following example mocks a `setTimeout` function and</span>
         <span class="s0">* by using `.tick` advances in</span>
         <span class="s0">* time triggering all pending timers.</span>
         <span class="s0">*</span>
         <span class="s0">* ```js</span>
         <span class="s0">* import assert from 'node:assert';</span>
         <span class="s0">* import { test } from 'node:test';</span>
         <span class="s0">*</span>
         <span class="s0">* test('mocks setTimeout to be executed synchronously without having to actually wait for it', (context) =&gt; {</span>
         <span class="s0">*   const fn = context.mock.fn();</span>
         <span class="s0">*</span>
         <span class="s0">*   context.mock.timers.enable({ apis: ['setTimeout'] });</span>
         <span class="s0">*</span>
         <span class="s0">*   setTimeout(fn, 9999);</span>
         <span class="s0">*</span>
         <span class="s0">*   assert.strictEqual(fn.mock.callCount(), 0);</span>
         <span class="s0">*</span>
         <span class="s0">*   // Advance in time</span>
         <span class="s0">*   context.mock.timers.tick(9999);</span>
         <span class="s0">*</span>
         <span class="s0">*   assert.strictEqual(fn.mock.callCount(), 1);</span>
         <span class="s0">* });</span>
         <span class="s0">* ```</span>
         <span class="s0">*</span>
         <span class="s0">* Alternativelly, the `.tick` function can be called many times</span>
         <span class="s0">*</span>
         <span class="s0">* ```js</span>
         <span class="s0">* import assert from 'node:assert';</span>
         <span class="s0">* import { test } from 'node:test';</span>
         <span class="s0">*</span>
         <span class="s0">* test('mocks setTimeout to be executed synchronously without having to actually wait for it', (context) =&gt; {</span>
         <span class="s0">*   const fn = context.mock.fn();</span>
         <span class="s0">*   context.mock.timers.enable({ apis: ['setTimeout'] });</span>
         <span class="s0">*   const nineSecs = 9000;</span>
         <span class="s0">*   setTimeout(fn, nineSecs);</span>
         <span class="s0">*</span>
         <span class="s0">*   const twoSeconds = 3000;</span>
         <span class="s0">*   context.mock.timers.tick(twoSeconds);</span>
         <span class="s0">*   context.mock.timers.tick(twoSeconds);</span>
         <span class="s0">*   context.mock.timers.tick(twoSeconds);</span>
         <span class="s0">*</span>
         <span class="s0">*   assert.strictEqual(fn.mock.callCount(), 1);</span>
         <span class="s0">* });</span>
         <span class="s0">* ```</span>
         <span class="s0">*</span>
         <span class="s0">* Advancing time using `.tick` will also advance the time for any `Date` object</span>
         <span class="s0">* created after the mock was enabled (if `Date` was also set to be mocked).</span>
         <span class="s0">*</span>
         <span class="s0">* ```js</span>
         <span class="s0">* import assert from 'node:assert';</span>
         <span class="s0">* import { test } from 'node:test';</span>
         <span class="s0">*</span>
         <span class="s0">* test('mocks setTimeout to be executed synchronously without having to actually wait for it', (context) =&gt; {</span>
         <span class="s0">*   const fn = context.mock.fn();</span>
         <span class="s0">*</span>
         <span class="s0">*   context.mock.timers.enable({ apis: ['setTimeout', 'Date'] });</span>
         <span class="s0">*   setTimeout(fn, 9999);</span>
         <span class="s0">*</span>
         <span class="s0">*   assert.strictEqual(fn.mock.callCount(), 0);</span>
         <span class="s0">*   assert.strictEqual(Date.now(), 0);</span>
         <span class="s0">*</span>
         <span class="s0">*   // Advance in time</span>
         <span class="s0">*   context.mock.timers.tick(9999);</span>
         <span class="s0">*   assert.strictEqual(fn.mock.callCount(), 1);</span>
         <span class="s0">*   assert.strictEqual(Date.now(), 9999);</span>
         <span class="s0">* });</span>
         <span class="s0">* ```</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v20.4.0</span>
         <span class="s0">*/</span>
        <span class="s2">tick</span><span class="s4">(</span><span class="s2">milliseconds</span><span class="s4">: </span><span class="s2">number</span><span class="s4">): </span><span class="s5">void</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Triggers all pending mocked timers immediately. If the `Date` object is also</span>
         <span class="s0">* mocked, it will also advance the `Date` object to the furthest timer's time.</span>
         <span class="s0">*</span>
         <span class="s0">* The example below triggers all pending timers immediately,</span>
         <span class="s0">* causing them to execute without any delay.</span>
         <span class="s0">*</span>
         <span class="s0">* ```js</span>
         <span class="s0">* import assert from 'node:assert';</span>
         <span class="s0">* import { test } from 'node:test';</span>
         <span class="s0">*</span>
         <span class="s0">* test('runAll functions following the given order', (context) =&gt; {</span>
         <span class="s0">*   context.mock.timers.enable({ apis: ['setTimeout', 'Date'] });</span>
         <span class="s0">*   const results = [];</span>
         <span class="s0">*   setTimeout(() =&gt; results.push(1), 9999);</span>
         <span class="s0">*</span>
         <span class="s0">*   // Notice that if both timers have the same timeout,</span>
         <span class="s0">*   // the order of execution is guaranteed</span>
         <span class="s0">*   setTimeout(() =&gt; results.push(3), 8888);</span>
         <span class="s0">*   setTimeout(() =&gt; results.push(2), 8888);</span>
         <span class="s0">*</span>
         <span class="s0">*   assert.deepStrictEqual(results, []);</span>
         <span class="s0">*</span>
         <span class="s0">*   context.mock.timers.runAll();</span>
         <span class="s0">*   assert.deepStrictEqual(results, [3, 2, 1]);</span>
         <span class="s0">*   // The Date object is also advanced to the furthest timer's time</span>
         <span class="s0">*   assert.strictEqual(Date.now(), 9999);</span>
         <span class="s0">* });</span>
         <span class="s0">* ```</span>
         <span class="s0">*</span>
         <span class="s0">* **Note:** The `runAll()` function is specifically designed for</span>
         <span class="s0">* triggering timers in the context of timer mocking.</span>
         <span class="s0">* It does not have any effect on real-time system</span>
         <span class="s0">* clocks or actual timers outside of the mocking environment.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v20.4.0</span>
         <span class="s0">*/</span>
        <span class="s2">runAll</span><span class="s4">(): </span><span class="s5">void</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* Calls {</span><span class="s1">@link </span><span class="s0">MockTimers.reset()}.</span>
         <span class="s0">*/</span>
        <span class="s4">[</span><span class="s2">Symbol</span><span class="s4">.</span><span class="s2">dispose</span><span class="s4">](): </span><span class="s5">void</span><span class="s4">;</span>
    <span class="s4">}</span>
    <span class="s0">/**</span>
     <span class="s0">* An object whose methods are used to configure available assertions on the</span>
     <span class="s0">* `TestContext` objects in the current process. The methods from `node:assert`</span>
     <span class="s0">* and snapshot testing functions are available by default.</span>
     <span class="s0">*</span>
     <span class="s0">* It is possible to apply the same configuration to all files by placing common</span>
     <span class="s0">* configuration code in a module</span>
     <span class="s0">* preloaded with `--require` or `--import`.</span>
     <span class="s0">* </span><span class="s1">@since </span><span class="s0">v22.14.0</span>
     <span class="s0">*/</span>
    <span class="s2">namespace assert </span><span class="s4">{</span>
        <span class="s0">/**</span>
         <span class="s0">* Defines a new assertion function with the provided name and function. If an</span>
         <span class="s0">* assertion already exists with the same name, it is overwritten.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v22.14.0</span>
         <span class="s0">*/</span>
        <span class="s5">function </span><span class="s2">register</span><span class="s4">(</span><span class="s2">name</span><span class="s4">: </span><span class="s2">string</span><span class="s4">, </span><span class="s2">fn</span><span class="s4">: (</span><span class="s5">this</span><span class="s4">: </span><span class="s2">TestContext</span><span class="s4">, </span><span class="s2">...args</span><span class="s4">: </span><span class="s2">any</span><span class="s4">[]) =&gt; </span><span class="s5">void</span><span class="s4">): </span><span class="s5">void</span><span class="s4">;</span>
    <span class="s4">}</span>
    <span class="s0">/**</span>
     <span class="s0">* </span><span class="s1">@since </span><span class="s0">v22.3.0</span>
     <span class="s0">*/</span>
    <span class="s2">namespace snapshot </span><span class="s4">{</span>
        <span class="s0">/**</span>
         <span class="s0">* This function is used to customize the default serialization mechanism used by the test runner.</span>
         <span class="s0">*</span>
         <span class="s0">* By default, the test runner performs serialization by calling `JSON.stringify(value, null, 2)` on the provided value.</span>
         <span class="s0">* `JSON.stringify()` does have limitations regarding circular structures and supported data types.</span>
         <span class="s0">* If a more robust serialization mechanism is required, this function should be used to specify a list of custom serializers.</span>
         <span class="s0">*</span>
         <span class="s0">* Serializers are called in order, with the output of the previous serializer passed as input to the next.</span>
         <span class="s0">* The final result must be a string value.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v22.3.0</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">serializers An array of synchronous functions used as the default serializers for snapshot tests.</span>
         <span class="s0">*/</span>
        <span class="s5">function </span><span class="s2">setDefaultSnapshotSerializers</span><span class="s4">(</span><span class="s2">serializers</span><span class="s4">: </span><span class="s2">ReadonlyArray</span><span class="s4">&lt;(</span><span class="s2">value</span><span class="s4">: </span><span class="s2">any</span><span class="s4">) =&gt; </span><span class="s2">any</span><span class="s4">&gt;): </span><span class="s5">void</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* This function is used to set a custom resolver for the location of the snapshot file used for snapshot testing.</span>
         <span class="s0">* By default, the snapshot filename is the same as the entry point filename with `.snapshot` appended.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v22.3.0</span>
         <span class="s0">* </span><span class="s1">@param </span><span class="s0">fn A function used to compute the location of the snapshot file.</span>
         <span class="s0">* The function receives the path of the test file as its only argument. If the</span>
         <span class="s0">* test is not associated with a file (for example in the REPL), the input is</span>
         <span class="s0">* undefined. `fn()` must return a string specifying the location of the snapshot file.</span>
         <span class="s0">*/</span>
        <span class="s5">function </span><span class="s2">setResolveSnapshotPath</span><span class="s4">(</span><span class="s2">fn</span><span class="s4">: (</span><span class="s2">path</span><span class="s4">: </span><span class="s2">string </span><span class="s4">| </span><span class="s2">undefined</span><span class="s4">) =&gt; </span><span class="s2">string</span><span class="s4">): </span><span class="s5">void</span><span class="s4">;</span>
    <span class="s4">}</span>
    <span class="s5">export </span><span class="s4">{</span>
        <span class="s2">after</span><span class="s4">,</span>
        <span class="s2">afterEach</span><span class="s4">,</span>
        <span class="s2">assert</span><span class="s4">,</span>
        <span class="s2">before</span><span class="s4">,</span>
        <span class="s2">beforeEach</span><span class="s4">,</span>
        <span class="s2">describe</span><span class="s4">,</span>
        <span class="s2">it</span><span class="s4">,</span>
        <span class="s2">Mock</span><span class="s4">,</span>
        <span class="s2">mock</span><span class="s4">,</span>
        <span class="s2">only</span><span class="s4">,</span>
        <span class="s2">run</span><span class="s4">,</span>
        <span class="s2">skip</span><span class="s4">,</span>
        <span class="s2">snapshot</span><span class="s4">,</span>
        <span class="s2">suite</span><span class="s4">,</span>
        <span class="s2">SuiteContext</span><span class="s4">,</span>
        <span class="s2">test</span><span class="s4">,</span>
        <span class="s2">test </span><span class="s4">as </span><span class="s5">default</span><span class="s4">,</span>
        <span class="s2">TestContext</span><span class="s4">,</span>
        <span class="s2">todo</span><span class="s4">,</span>
    <span class="s4">};</span>
<span class="s4">}</span>

<span class="s5">interface </span><span class="s2">TestError </span><span class="s5">extends </span><span class="s2">Error </span><span class="s4">{</span>
    <span class="s2">cause</span><span class="s4">: </span><span class="s2">Error</span><span class="s4">;</span>
<span class="s4">}</span>
<span class="s5">interface </span><span class="s2">TestLocationInfo </span><span class="s4">{</span>
    <span class="s0">/**</span>
     <span class="s0">* The column number where the test is defined, or</span>
     <span class="s0">* `undefined` if the test was run through the REPL.</span>
     <span class="s0">*/</span>
    <span class="s2">column</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The path of the test file, `undefined` if test was run through the REPL.</span>
     <span class="s0">*/</span>
    <span class="s2">file</span><span class="s4">?: </span><span class="s2">string</span><span class="s4">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The line number where the test is defined, or `undefined` if the test was run through the REPL.</span>
     <span class="s0">*/</span>
    <span class="s2">line</span><span class="s4">?: </span><span class="s2">number</span><span class="s4">;</span>
<span class="s4">}</span>
<span class="s5">interface </span><span class="s2">DiagnosticData </span><span class="s5">extends </span><span class="s2">TestLocationInfo </span><span class="s4">{</span>
    <span class="s0">/**</span>
     <span class="s0">* The diagnostic message.</span>
     <span class="s0">*/</span>
    <span class="s2">message</span><span class="s4">: </span><span class="s2">string</span><span class="s4">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The nesting level of the test.</span>
     <span class="s0">*/</span>
    <span class="s2">nesting</span><span class="s4">: </span><span class="s2">number</span><span class="s4">;</span>
<span class="s4">}</span>
<span class="s5">interface </span><span class="s2">TestCoverage </span><span class="s4">{</span>
    <span class="s0">/**</span>
     <span class="s0">* An object containing the coverage report.</span>
     <span class="s0">*/</span>
    <span class="s2">summary</span><span class="s4">: {</span>
        <span class="s0">/**</span>
         <span class="s0">* An array of coverage reports for individual files.</span>
         <span class="s0">*/</span>
        <span class="s2">files</span><span class="s4">: </span><span class="s2">Array</span><span class="s4">&lt;{</span>
            <span class="s0">/**</span>
             <span class="s0">* The absolute path of the file.</span>
             <span class="s0">*/</span>
            <span class="s2">path</span><span class="s4">: </span><span class="s2">string</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* The total number of lines.</span>
             <span class="s0">*/</span>
            <span class="s2">totalLineCount</span><span class="s4">: </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* The total number of branches.</span>
             <span class="s0">*/</span>
            <span class="s2">totalBranchCount</span><span class="s4">: </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* The total number of functions.</span>
             <span class="s0">*/</span>
            <span class="s2">totalFunctionCount</span><span class="s4">: </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* The number of covered lines.</span>
             <span class="s0">*/</span>
            <span class="s2">coveredLineCount</span><span class="s4">: </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* The number of covered branches.</span>
             <span class="s0">*/</span>
            <span class="s2">coveredBranchCount</span><span class="s4">: </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* The number of covered functions.</span>
             <span class="s0">*/</span>
            <span class="s2">coveredFunctionCount</span><span class="s4">: </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* The percentage of lines covered.</span>
             <span class="s0">*/</span>
            <span class="s2">coveredLinePercent</span><span class="s4">: </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* The percentage of branches covered.</span>
             <span class="s0">*/</span>
            <span class="s2">coveredBranchPercent</span><span class="s4">: </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* The percentage of functions covered.</span>
             <span class="s0">*/</span>
            <span class="s2">coveredFunctionPercent</span><span class="s4">: </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* An array of functions representing function coverage.</span>
             <span class="s0">*/</span>
            <span class="s2">functions</span><span class="s4">: </span><span class="s2">Array</span><span class="s4">&lt;{</span>
                <span class="s0">/**</span>
                 <span class="s0">* The name of the function.</span>
                 <span class="s0">*/</span>
                <span class="s2">name</span><span class="s4">: </span><span class="s2">string</span><span class="s4">;</span>
                <span class="s0">/**</span>
                 <span class="s0">* The line number where the function is defined.</span>
                 <span class="s0">*/</span>
                <span class="s2">line</span><span class="s4">: </span><span class="s2">number</span><span class="s4">;</span>
                <span class="s0">/**</span>
                 <span class="s0">* The number of times the function was called.</span>
                 <span class="s0">*/</span>
                <span class="s2">count</span><span class="s4">: </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s4">}&gt;;</span>
            <span class="s0">/**</span>
             <span class="s0">* An array of branches representing branch coverage.</span>
             <span class="s0">*/</span>
            <span class="s2">branches</span><span class="s4">: </span><span class="s2">Array</span><span class="s4">&lt;{</span>
                <span class="s0">/**</span>
                 <span class="s0">* The line number where the branch is defined.</span>
                 <span class="s0">*/</span>
                <span class="s2">line</span><span class="s4">: </span><span class="s2">number</span><span class="s4">;</span>
                <span class="s0">/**</span>
                 <span class="s0">* The number of times the branch was taken.</span>
                 <span class="s0">*/</span>
                <span class="s2">count</span><span class="s4">: </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s4">}&gt;;</span>
            <span class="s0">/**</span>
             <span class="s0">* An array of lines representing line numbers and the number of times they were covered.</span>
             <span class="s0">*/</span>
            <span class="s2">lines</span><span class="s4">: </span><span class="s2">Array</span><span class="s4">&lt;{</span>
                <span class="s0">/**</span>
                 <span class="s0">* The line number.</span>
                 <span class="s0">*/</span>
                <span class="s2">line</span><span class="s4">: </span><span class="s2">number</span><span class="s4">;</span>
                <span class="s0">/**</span>
                 <span class="s0">* The number of times the line was covered.</span>
                 <span class="s0">*/</span>
                <span class="s2">count</span><span class="s4">: </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s4">}&gt;;</span>
        <span class="s4">}&gt;;</span>
        <span class="s0">/**</span>
         <span class="s0">* An object containing whether or not the coverage for</span>
         <span class="s0">* each coverage type.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v22.9.0</span>
         <span class="s0">*/</span>
        <span class="s2">thresholds</span><span class="s4">: {</span>
            <span class="s0">/**</span>
             <span class="s0">* The function coverage threshold.</span>
             <span class="s0">*/</span>
            <span class="s5">function</span><span class="s4">: </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* The branch coverage threshold.</span>
             <span class="s0">*/</span>
            <span class="s2">branch</span><span class="s4">: </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* The line coverage threshold.</span>
             <span class="s0">*/</span>
            <span class="s2">line</span><span class="s4">: </span><span class="s2">number</span><span class="s4">;</span>
        <span class="s4">};</span>
        <span class="s0">/**</span>
         <span class="s0">* An object containing a summary of coverage for all files.</span>
         <span class="s0">*/</span>
        <span class="s2">totals</span><span class="s4">: {</span>
            <span class="s0">/**</span>
             <span class="s0">* The total number of lines.</span>
             <span class="s0">*/</span>
            <span class="s2">totalLineCount</span><span class="s4">: </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* The total number of branches.</span>
             <span class="s0">*/</span>
            <span class="s2">totalBranchCount</span><span class="s4">: </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* The total number of functions.</span>
             <span class="s0">*/</span>
            <span class="s2">totalFunctionCount</span><span class="s4">: </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* The number of covered lines.</span>
             <span class="s0">*/</span>
            <span class="s2">coveredLineCount</span><span class="s4">: </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* The number of covered branches.</span>
             <span class="s0">*/</span>
            <span class="s2">coveredBranchCount</span><span class="s4">: </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* The number of covered functions.</span>
             <span class="s0">*/</span>
            <span class="s2">coveredFunctionCount</span><span class="s4">: </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* The percentage of lines covered.</span>
             <span class="s0">*/</span>
            <span class="s2">coveredLinePercent</span><span class="s4">: </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* The percentage of branches covered.</span>
             <span class="s0">*/</span>
            <span class="s2">coveredBranchPercent</span><span class="s4">: </span><span class="s2">number</span><span class="s4">;</span>
            <span class="s0">/**</span>
             <span class="s0">* The percentage of functions covered.</span>
             <span class="s0">*/</span>
            <span class="s2">coveredFunctionPercent</span><span class="s4">: </span><span class="s2">number</span><span class="s4">;</span>
        <span class="s4">};</span>
        <span class="s0">/**</span>
         <span class="s0">* The working directory when code coverage began. This</span>
         <span class="s0">* is useful for displaying relative path names in case</span>
         <span class="s0">* the tests changed the working directory of the Node.js process.</span>
         <span class="s0">*/</span>
        <span class="s2">workingDirectory</span><span class="s4">: </span><span class="s2">string</span><span class="s4">;</span>
    <span class="s4">};</span>
    <span class="s0">/**</span>
     <span class="s0">* The nesting level of the test.</span>
     <span class="s0">*/</span>
    <span class="s2">nesting</span><span class="s4">: </span><span class="s2">number</span><span class="s4">;</span>
<span class="s4">}</span>
<span class="s5">interface </span><span class="s2">TestComplete </span><span class="s5">extends </span><span class="s2">TestLocationInfo </span><span class="s4">{</span>
    <span class="s0">/**</span>
     <span class="s0">* Additional execution metadata.</span>
     <span class="s0">*/</span>
    <span class="s2">details</span><span class="s4">: {</span>
        <span class="s0">/**</span>
         <span class="s0">* Whether the test passed or not.</span>
         <span class="s0">*/</span>
        <span class="s2">passed</span><span class="s4">: </span><span class="s2">boolean</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The duration of the test in milliseconds.</span>
         <span class="s0">*/</span>
        <span class="s2">duration_ms</span><span class="s4">: </span><span class="s2">number</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* An error wrapping the error thrown by the test if it did not pass.</span>
         <span class="s0">*/</span>
        <span class="s2">error</span><span class="s4">?: </span><span class="s2">TestError</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The type of the test, used to denote whether this is a suite.</span>
         <span class="s0">*/</span>
        <span class="s2">type</span><span class="s4">?: </span><span class="s3">&quot;suite&quot;</span><span class="s4">;</span>
    <span class="s4">};</span>
    <span class="s0">/**</span>
     <span class="s0">* The test name.</span>
     <span class="s0">*/</span>
    <span class="s2">name</span><span class="s4">: </span><span class="s2">string</span><span class="s4">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The nesting level of the test.</span>
     <span class="s0">*/</span>
    <span class="s2">nesting</span><span class="s4">: </span><span class="s2">number</span><span class="s4">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The ordinal number of the test.</span>
     <span class="s0">*/</span>
    <span class="s2">testNumber</span><span class="s4">: </span><span class="s2">number</span><span class="s4">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Present if `context.todo` is called.</span>
     <span class="s0">*/</span>
    <span class="s2">todo</span><span class="s4">?: </span><span class="s2">string </span><span class="s4">| </span><span class="s2">boolean</span><span class="s4">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Present if `context.skip` is called.</span>
     <span class="s0">*/</span>
    <span class="s2">skip</span><span class="s4">?: </span><span class="s2">string </span><span class="s4">| </span><span class="s2">boolean</span><span class="s4">;</span>
<span class="s4">}</span>
<span class="s5">interface </span><span class="s2">TestDequeue </span><span class="s5">extends </span><span class="s2">TestLocationInfo </span><span class="s4">{</span>
    <span class="s0">/**</span>
     <span class="s0">* The test name.</span>
     <span class="s0">*/</span>
    <span class="s2">name</span><span class="s4">: </span><span class="s2">string</span><span class="s4">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The nesting level of the test.</span>
     <span class="s0">*/</span>
    <span class="s2">nesting</span><span class="s4">: </span><span class="s2">number</span><span class="s4">;</span>
<span class="s4">}</span>
<span class="s5">interface </span><span class="s2">TestEnqueue </span><span class="s5">extends </span><span class="s2">TestLocationInfo </span><span class="s4">{</span>
    <span class="s0">/**</span>
     <span class="s0">* The test name.</span>
     <span class="s0">*/</span>
    <span class="s2">name</span><span class="s4">: </span><span class="s2">string</span><span class="s4">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The nesting level of the test.</span>
     <span class="s0">*/</span>
    <span class="s2">nesting</span><span class="s4">: </span><span class="s2">number</span><span class="s4">;</span>
<span class="s4">}</span>
<span class="s5">interface </span><span class="s2">TestFail </span><span class="s5">extends </span><span class="s2">TestLocationInfo </span><span class="s4">{</span>
    <span class="s0">/**</span>
     <span class="s0">* Additional execution metadata.</span>
     <span class="s0">*/</span>
    <span class="s2">details</span><span class="s4">: {</span>
        <span class="s0">/**</span>
         <span class="s0">* The duration of the test in milliseconds.</span>
         <span class="s0">*/</span>
        <span class="s2">duration_ms</span><span class="s4">: </span><span class="s2">number</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* An error wrapping the error thrown by the test.</span>
         <span class="s0">*/</span>
        <span class="s2">error</span><span class="s4">: </span><span class="s2">TestError</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The type of the test, used to denote whether this is a suite.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">v20.0.0, v19.9.0, v18.17.0</span>
         <span class="s0">*/</span>
        <span class="s2">type</span><span class="s4">?: </span><span class="s3">&quot;suite&quot;</span><span class="s4">;</span>
    <span class="s4">};</span>
    <span class="s0">/**</span>
     <span class="s0">* The test name.</span>
     <span class="s0">*/</span>
    <span class="s2">name</span><span class="s4">: </span><span class="s2">string</span><span class="s4">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The nesting level of the test.</span>
     <span class="s0">*/</span>
    <span class="s2">nesting</span><span class="s4">: </span><span class="s2">number</span><span class="s4">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The ordinal number of the test.</span>
     <span class="s0">*/</span>
    <span class="s2">testNumber</span><span class="s4">: </span><span class="s2">number</span><span class="s4">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Present if `context.todo` is called.</span>
     <span class="s0">*/</span>
    <span class="s2">todo</span><span class="s4">?: </span><span class="s2">string </span><span class="s4">| </span><span class="s2">boolean</span><span class="s4">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Present if `context.skip` is called.</span>
     <span class="s0">*/</span>
    <span class="s2">skip</span><span class="s4">?: </span><span class="s2">string </span><span class="s4">| </span><span class="s2">boolean</span><span class="s4">;</span>
<span class="s4">}</span>
<span class="s5">interface </span><span class="s2">TestPass </span><span class="s5">extends </span><span class="s2">TestLocationInfo </span><span class="s4">{</span>
    <span class="s0">/**</span>
     <span class="s0">* Additional execution metadata.</span>
     <span class="s0">*/</span>
    <span class="s2">details</span><span class="s4">: {</span>
        <span class="s0">/**</span>
         <span class="s0">* The duration of the test in milliseconds.</span>
         <span class="s0">*/</span>
        <span class="s2">duration_ms</span><span class="s4">: </span><span class="s2">number</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The type of the test, used to denote whether this is a suite.</span>
         <span class="s0">* </span><span class="s1">@since </span><span class="s0">20.0.0, 19.9.0, 18.17.0</span>
         <span class="s0">*/</span>
        <span class="s2">type</span><span class="s4">?: </span><span class="s3">&quot;suite&quot;</span><span class="s4">;</span>
    <span class="s4">};</span>
    <span class="s0">/**</span>
     <span class="s0">* The test name.</span>
     <span class="s0">*/</span>
    <span class="s2">name</span><span class="s4">: </span><span class="s2">string</span><span class="s4">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The nesting level of the test.</span>
     <span class="s0">*/</span>
    <span class="s2">nesting</span><span class="s4">: </span><span class="s2">number</span><span class="s4">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The ordinal number of the test.</span>
     <span class="s0">*/</span>
    <span class="s2">testNumber</span><span class="s4">: </span><span class="s2">number</span><span class="s4">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Present if `context.todo` is called.</span>
     <span class="s0">*/</span>
    <span class="s2">todo</span><span class="s4">?: </span><span class="s2">string </span><span class="s4">| </span><span class="s2">boolean</span><span class="s4">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Present if `context.skip` is called.</span>
     <span class="s0">*/</span>
    <span class="s2">skip</span><span class="s4">?: </span><span class="s2">string </span><span class="s4">| </span><span class="s2">boolean</span><span class="s4">;</span>
<span class="s4">}</span>
<span class="s5">interface </span><span class="s2">TestPlan </span><span class="s5">extends </span><span class="s2">TestLocationInfo </span><span class="s4">{</span>
    <span class="s0">/**</span>
     <span class="s0">* The nesting level of the test.</span>
     <span class="s0">*/</span>
    <span class="s2">nesting</span><span class="s4">: </span><span class="s2">number</span><span class="s4">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The number of subtests that have ran.</span>
     <span class="s0">*/</span>
    <span class="s2">count</span><span class="s4">: </span><span class="s2">number</span><span class="s4">;</span>
<span class="s4">}</span>
<span class="s5">interface </span><span class="s2">TestStart </span><span class="s5">extends </span><span class="s2">TestLocationInfo </span><span class="s4">{</span>
    <span class="s0">/**</span>
     <span class="s0">* The test name.</span>
     <span class="s0">*/</span>
    <span class="s2">name</span><span class="s4">: </span><span class="s2">string</span><span class="s4">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The nesting level of the test.</span>
     <span class="s0">*/</span>
    <span class="s2">nesting</span><span class="s4">: </span><span class="s2">number</span><span class="s4">;</span>
<span class="s4">}</span>
<span class="s5">interface </span><span class="s2">TestStderr </span><span class="s4">{</span>
    <span class="s0">/**</span>
     <span class="s0">* The path of the test file.</span>
     <span class="s0">*/</span>
    <span class="s2">file</span><span class="s4">: </span><span class="s2">string</span><span class="s4">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The message written to `stderr`.</span>
     <span class="s0">*/</span>
    <span class="s2">message</span><span class="s4">: </span><span class="s2">string</span><span class="s4">;</span>
<span class="s4">}</span>
<span class="s5">interface </span><span class="s2">TestStdout </span><span class="s4">{</span>
    <span class="s0">/**</span>
     <span class="s0">* The path of the test file.</span>
     <span class="s0">*/</span>
    <span class="s2">file</span><span class="s4">: </span><span class="s2">string</span><span class="s4">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The message written to `stdout`.</span>
     <span class="s0">*/</span>
    <span class="s2">message</span><span class="s4">: </span><span class="s2">string</span><span class="s4">;</span>
<span class="s4">}</span>
<span class="s5">interface </span><span class="s2">TestSummary </span><span class="s4">{</span>
    <span class="s0">/**</span>
     <span class="s0">* An object containing the counts of various test results.</span>
     <span class="s0">*/</span>
    <span class="s2">counts</span><span class="s4">: {</span>
        <span class="s0">/**</span>
         <span class="s0">* The total number of cancelled tests.</span>
         <span class="s0">*/</span>
        <span class="s2">cancelled</span><span class="s4">: </span><span class="s2">number</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The total number of passed tests.</span>
         <span class="s0">*/</span>
        <span class="s2">passed</span><span class="s4">: </span><span class="s2">number</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The total number of skipped tests.</span>
         <span class="s0">*/</span>
        <span class="s2">skipped</span><span class="s4">: </span><span class="s2">number</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The total number of suites run.</span>
         <span class="s0">*/</span>
        <span class="s2">suites</span><span class="s4">: </span><span class="s2">number</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The total number of tests run, excluding suites.</span>
         <span class="s0">*/</span>
        <span class="s2">tests</span><span class="s4">: </span><span class="s2">number</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The total number of TODO tests.</span>
         <span class="s0">*/</span>
        <span class="s2">todo</span><span class="s4">: </span><span class="s2">number</span><span class="s4">;</span>
        <span class="s0">/**</span>
         <span class="s0">* The total number of top level tests and suites.</span>
         <span class="s0">*/</span>
        <span class="s2">topLevel</span><span class="s4">: </span><span class="s2">number</span><span class="s4">;</span>
    <span class="s4">};</span>
    <span class="s0">/**</span>
     <span class="s0">* The duration of the test run in milliseconds.</span>
     <span class="s0">*/</span>
    <span class="s2">duration_ms</span><span class="s4">: </span><span class="s2">number</span><span class="s4">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The path of the test file that generated the</span>
     <span class="s0">* summary. If the summary corresponds to multiple files, this value is</span>
     <span class="s0">* `undefined`.</span>
     <span class="s0">*/</span>
    <span class="s2">file</span><span class="s4">: </span><span class="s2">string </span><span class="s4">| </span><span class="s2">undefined</span><span class="s4">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Indicates whether or not the test run is considered</span>
     <span class="s0">* successful or not. If any error condition occurs, such as a failing test or</span>
     <span class="s0">* unmet coverage threshold, this value will be set to `false`.</span>
     <span class="s0">*/</span>
    <span class="s2">success</span><span class="s4">: </span><span class="s2">boolean</span><span class="s4">;</span>
<span class="s4">}</span>

<span class="s0">/**</span>
 <span class="s0">* The `node:test/reporters` module exposes the builtin-reporters for `node:test`.</span>
 <span class="s0">* To access it:</span>
 <span class="s0">*</span>
 <span class="s0">* ```js</span>
 <span class="s0">* import test from 'node:test/reporters';</span>
 <span class="s0">* ```</span>
 <span class="s0">*</span>
 <span class="s0">* This module is only available under the `node:` scheme. The following will not</span>
 <span class="s0">* work:</span>
 <span class="s0">*</span>
 <span class="s0">* ```js</span>
 <span class="s0">* import test from 'node:test/reporters';</span>
 <span class="s0">* ```</span>
 <span class="s0">* </span><span class="s1">@since </span><span class="s0">v19.9.0</span>
 <span class="s0">* </span><span class="s1">@see </span><span class="s0">[source](https://github.com/nodejs/node/blob/v22.x/lib/test/reporters.js)</span>
 <span class="s0">*/</span>
<span class="s2">declare module </span><span class="s3">&quot;node:test/reporters&quot; </span><span class="s4">{</span>
    <span class="s5">import </span><span class="s4">{ </span><span class="s2">Transform</span><span class="s4">, </span><span class="s2">TransformOptions </span><span class="s4">} </span><span class="s2">from </span><span class="s3">&quot;node:stream&quot;</span><span class="s4">;</span>

    <span class="s2">type TestEvent </span><span class="s4">=</span>
        <span class="s4">| { </span><span class="s2">type</span><span class="s4">: </span><span class="s3">&quot;test:coverage&quot;</span><span class="s4">; </span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestCoverage </span><span class="s4">}</span>
        <span class="s4">| { </span><span class="s2">type</span><span class="s4">: </span><span class="s3">&quot;test:complete&quot;</span><span class="s4">; </span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestComplete </span><span class="s4">}</span>
        <span class="s4">| { </span><span class="s2">type</span><span class="s4">: </span><span class="s3">&quot;test:dequeue&quot;</span><span class="s4">; </span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestDequeue </span><span class="s4">}</span>
        <span class="s4">| { </span><span class="s2">type</span><span class="s4">: </span><span class="s3">&quot;test:diagnostic&quot;</span><span class="s4">; </span><span class="s2">data</span><span class="s4">: </span><span class="s2">DiagnosticData </span><span class="s4">}</span>
        <span class="s4">| { </span><span class="s2">type</span><span class="s4">: </span><span class="s3">&quot;test:enqueue&quot;</span><span class="s4">; </span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestEnqueue </span><span class="s4">}</span>
        <span class="s4">| { </span><span class="s2">type</span><span class="s4">: </span><span class="s3">&quot;test:fail&quot;</span><span class="s4">; </span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestFail </span><span class="s4">}</span>
        <span class="s4">| { </span><span class="s2">type</span><span class="s4">: </span><span class="s3">&quot;test:pass&quot;</span><span class="s4">; </span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestPass </span><span class="s4">}</span>
        <span class="s4">| { </span><span class="s2">type</span><span class="s4">: </span><span class="s3">&quot;test:plan&quot;</span><span class="s4">; </span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestPlan </span><span class="s4">}</span>
        <span class="s4">| { </span><span class="s2">type</span><span class="s4">: </span><span class="s3">&quot;test:start&quot;</span><span class="s4">; </span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestStart </span><span class="s4">}</span>
        <span class="s4">| { </span><span class="s2">type</span><span class="s4">: </span><span class="s3">&quot;test:stderr&quot;</span><span class="s4">; </span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestStderr </span><span class="s4">}</span>
        <span class="s4">| { </span><span class="s2">type</span><span class="s4">: </span><span class="s3">&quot;test:stdout&quot;</span><span class="s4">; </span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestStdout </span><span class="s4">}</span>
        <span class="s4">| { </span><span class="s2">type</span><span class="s4">: </span><span class="s3">&quot;test:summary&quot;</span><span class="s4">; </span><span class="s2">data</span><span class="s4">: </span><span class="s2">TestSummary </span><span class="s4">}</span>
        <span class="s4">| { </span><span class="s2">type</span><span class="s4">: </span><span class="s3">&quot;test:watch:drained&quot;</span><span class="s4">; </span><span class="s2">data</span><span class="s4">: </span><span class="s2">undefined </span><span class="s4">};</span>
    <span class="s2">type TestEventGenerator </span><span class="s4">= </span><span class="s2">AsyncGenerator</span><span class="s4">&lt;</span><span class="s2">TestEvent</span><span class="s4">, </span><span class="s5">void</span><span class="s4">&gt;;</span>

    <span class="s5">interface </span><span class="s2">ReporterConstructorWrapper</span><span class="s4">&lt;</span><span class="s2">T </span><span class="s5">extends new</span><span class="s4">(</span><span class="s2">...args</span><span class="s4">: </span><span class="s2">any</span><span class="s4">[]) =&gt; </span><span class="s2">Transform</span><span class="s4">&gt; {</span>
        <span class="s5">new</span><span class="s4">(</span><span class="s2">...args</span><span class="s4">: </span><span class="s2">ConstructorParameters</span><span class="s4">&lt;</span><span class="s2">T</span><span class="s4">&gt;): </span><span class="s2">InstanceType</span><span class="s4">&lt;</span><span class="s2">T</span><span class="s4">&gt;;</span>
        <span class="s4">(</span><span class="s2">...args</span><span class="s4">: </span><span class="s2">ConstructorParameters</span><span class="s4">&lt;</span><span class="s2">T</span><span class="s4">&gt;): </span><span class="s2">InstanceType</span><span class="s4">&lt;</span><span class="s2">T</span><span class="s4">&gt;;</span>
    <span class="s4">}</span>

    <span class="s0">/**</span>
     <span class="s0">* The `dot` reporter outputs the test results in a compact format,</span>
     <span class="s0">* where each passing test is represented by a `.`,</span>
     <span class="s0">* and each failing test is represented by a `X`.</span>
     <span class="s0">* </span><span class="s1">@since </span><span class="s0">v20.0.0</span>
     <span class="s0">*/</span>
    <span class="s5">function </span><span class="s2">dot</span><span class="s4">(</span><span class="s2">source</span><span class="s4">: </span><span class="s2">TestEventGenerator</span><span class="s4">): </span><span class="s2">AsyncGenerator</span><span class="s4">&lt;</span><span class="s3">&quot;</span><span class="s5">\n</span><span class="s3">&quot; </span><span class="s4">| </span><span class="s3">&quot;.&quot; </span><span class="s4">| </span><span class="s3">&quot;X&quot;</span><span class="s4">, </span><span class="s5">void</span><span class="s4">&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* The `tap` reporter outputs the test results in the [TAP](https://testanything.org/) format.</span>
     <span class="s0">* </span><span class="s1">@since </span><span class="s0">v20.0.0</span>
     <span class="s0">*/</span>
    <span class="s5">function </span><span class="s2">tap</span><span class="s4">(</span><span class="s2">source</span><span class="s4">: </span><span class="s2">TestEventGenerator</span><span class="s4">): </span><span class="s2">AsyncGenerator</span><span class="s4">&lt;</span><span class="s2">string</span><span class="s4">, </span><span class="s5">void</span><span class="s4">&gt;;</span>
    <span class="s5">class </span><span class="s2">SpecReporter </span><span class="s5">extends </span><span class="s2">Transform </span><span class="s4">{</span>
        <span class="s2">constructor</span><span class="s4">();</span>
    <span class="s4">}</span>
    <span class="s0">/**</span>
     <span class="s0">* The `spec` reporter outputs the test results in a human-readable format.</span>
     <span class="s0">* </span><span class="s1">@since </span><span class="s0">v20.0.0</span>
     <span class="s0">*/</span>
    <span class="s5">const </span><span class="s2">spec</span><span class="s4">: </span><span class="s2">ReporterConstructorWrapper</span><span class="s4">&lt;</span><span class="s5">typeof </span><span class="s2">SpecReporter</span><span class="s4">&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* The `junit` reporter outputs test results in a jUnit XML format.</span>
     <span class="s0">* </span><span class="s1">@since </span><span class="s0">v21.0.0</span>
     <span class="s0">*/</span>
    <span class="s5">function </span><span class="s2">junit</span><span class="s4">(</span><span class="s2">source</span><span class="s4">: </span><span class="s2">TestEventGenerator</span><span class="s4">): </span><span class="s2">AsyncGenerator</span><span class="s4">&lt;</span><span class="s2">string</span><span class="s4">, </span><span class="s5">void</span><span class="s4">&gt;;</span>
    <span class="s5">class </span><span class="s2">LcovReporter </span><span class="s5">extends </span><span class="s2">Transform </span><span class="s4">{</span>
        <span class="s2">constructor</span><span class="s4">(</span><span class="s2">opts</span><span class="s4">?: </span><span class="s2">Omit</span><span class="s4">&lt;</span><span class="s2">TransformOptions</span><span class="s4">, </span><span class="s3">&quot;writableObjectMode&quot;</span><span class="s4">&gt;);</span>
    <span class="s4">}</span>
    <span class="s0">/**</span>
     <span class="s0">* The `lcov` reporter outputs test coverage when used with the</span>
     <span class="s0">* [`--experimental-test-coverage`](https://nodejs.org/docs/latest-v22.x/api/cli.html#--experimental-test-coverage) flag.</span>
     <span class="s0">* </span><span class="s1">@since </span><span class="s0">v22.0.0</span>
     <span class="s0">*/</span>
    <span class="s6">// TODO: change the export to a wrapper function once node@0db38f0 is merged (breaking change)</span>
    <span class="s6">// const lcov: ReporterConstructorWrapper&lt;typeof LcovReporter&gt;;</span>
    <span class="s5">const </span><span class="s2">lcov</span><span class="s4">: </span><span class="s2">LcovReporter</span><span class="s4">;</span>

    <span class="s5">export </span><span class="s4">{ </span><span class="s2">dot</span><span class="s4">, </span><span class="s2">junit</span><span class="s4">, </span><span class="s2">lcov</span><span class="s4">, </span><span class="s2">spec</span><span class="s4">, </span><span class="s2">tap</span><span class="s4">, </span><span class="s2">TestEvent </span><span class="s4">};</span>
<span class="s4">}</span>
</pre>
</body>
</html>