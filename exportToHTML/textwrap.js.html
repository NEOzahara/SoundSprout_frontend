<html>
<head>
<title>textwrap.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #6aab73;}
.s3 { color: #cf8e6d;}
.s4 { color: #bcbec4;}
.s5 { color: #42c3d4;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
textwrap.js</font>
</center></td></tr></table>
<pre><span class="s0">// Partial port of python's argparse module, version 3.9.0 (only wrap and fill functions):</span>
<span class="s0">// https://github.com/python/cpython/blob/v3.9.0b4/Lib/textwrap.py</span>

<span class="s2">'use strict'</span>

<span class="s0">/* 
 * Text wrapping and filling. 
 */</span>

<span class="s0">// Copyright (C) 1999-2001 Gregory P. Ward.</span>
<span class="s0">// Copyright (C) 2002, 2003 Python Software Foundation.</span>
<span class="s0">// Copyright (C) 2020 argparse.js authors</span>
<span class="s0">// Originally written by Greg Ward &lt;gward@python.net&gt;</span>

<span class="s0">// Hardcode the recognized whitespace characters to the US-ASCII</span>
<span class="s0">// whitespace characters.  The main reason for doing this is that</span>
<span class="s0">// some Unicode spaces (like \u00a0) are non-breaking whitespaces.</span>
<span class="s0">//</span>
<span class="s0">// This less funky little regex just split on recognized spaces. E.g.</span>
<span class="s0">//   &quot;Hello there -- you goof-ball, use the -b option!&quot;</span>
<span class="s0">// splits into</span>
<span class="s0">//   Hello/ /there/ /--/ /you/ /goof-ball,/ /use/ /the/ /-b/ /option!/</span>
<span class="s3">const </span><span class="s1">wordsep_simple_re </span><span class="s4">= </span><span class="s5">/([\t\n\x0b\x0c\r ]+)/</span>

<span class="s3">class </span><span class="s1">TextWrapper </span><span class="s4">{</span>
    <span class="s0">/* 
     *  Object for wrapping/filling text.  The public interface consists of 
     *  the wrap() and fill() methods; the other methods are just there for 
     *  subclasses to override in order to tweak the default behaviour. 
     *  If you want to completely replace the main wrapping algorithm, 
     *  you'll probably have to override _wrap_chunks(). 
     * 
     *  Several instance attributes control various aspects of wrapping: 
     *    width (default: 70) 
     *      the maximum width of wrapped lines (unless break_long_words 
     *      is false) 
     *    initial_indent (default: &quot;&quot;) 
     *      string that will be prepended to the first line of wrapped 
     *      output.  Counts towards the line's width. 
     *    subsequent_indent (default: &quot;&quot;) 
     *      string that will be prepended to all lines save the first 
     *      of wrapped output; also counts towards each line's width. 
     *    expand_tabs (default: true) 
     *      Expand tabs in input text to spaces before further processing. 
     *      Each tab will become 0 .. 'tabsize' spaces, depending on its position 
     *      in its line.  If false, each tab is treated as a single character. 
     *    tabsize (default: 8) 
     *      Expand tabs in input text to 0 .. 'tabsize' spaces, unless 
     *      'expand_tabs' is false. 
     *    replace_whitespace (default: true) 
     *      Replace all whitespace characters in the input text by spaces 
     *      after tab expansion.  Note that if expand_tabs is false and 
     *      replace_whitespace is true, every tab will be converted to a 
     *      single space! 
     *    fix_sentence_endings (default: false) 
     *      Ensure that sentence-ending punctuation is always followed 
     *      by two spaces.  Off by default because the algorithm is 
     *      (unavoidably) imperfect. 
     *    break_long_words (default: true) 
     *      Break words longer than 'width'.  If false, those words will not 
     *      be broken, and some lines might be longer than 'width'. 
     *    break_on_hyphens (default: true) 
     *      Allow breaking hyphenated words. If true, wrapping will occur 
     *      preferably on whitespaces and right after hyphens part of 
     *      compound words. 
     *    drop_whitespace (default: true) 
     *      Drop leading and trailing whitespace from lines. 
     *    max_lines (default: None) 
     *      Truncate wrapped lines. 
     *    placeholder (default: ' [...]') 
     *      Append to the last line of truncated text. 
     */</span>

    <span class="s1">constructor</span><span class="s4">(</span><span class="s1">options </span><span class="s4">= {}) {</span>
        <span class="s3">let </span><span class="s4">{</span>
            <span class="s1">width </span><span class="s4">= </span><span class="s6">70</span><span class="s4">,</span>
            <span class="s1">initial_indent </span><span class="s4">= </span><span class="s2">''</span><span class="s4">,</span>
            <span class="s1">subsequent_indent </span><span class="s4">= </span><span class="s2">''</span><span class="s4">,</span>
            <span class="s1">expand_tabs </span><span class="s4">= </span><span class="s3">true</span><span class="s4">,</span>
            <span class="s1">replace_whitespace </span><span class="s4">= </span><span class="s3">true</span><span class="s4">,</span>
            <span class="s1">fix_sentence_endings </span><span class="s4">= </span><span class="s3">false</span><span class="s4">,</span>
            <span class="s1">break_long_words </span><span class="s4">= </span><span class="s3">true</span><span class="s4">,</span>
            <span class="s1">drop_whitespace </span><span class="s4">= </span><span class="s3">true</span><span class="s4">,</span>
            <span class="s1">break_on_hyphens </span><span class="s4">= </span><span class="s3">true</span><span class="s4">,</span>
            <span class="s1">tabsize </span><span class="s4">= </span><span class="s6">8</span><span class="s4">,</span>
            <span class="s1">max_lines </span><span class="s4">= </span><span class="s1">undefined</span><span class="s4">,</span>
            <span class="s1">placeholder</span><span class="s4">=</span><span class="s2">' [...]'</span>
        <span class="s4">} = </span><span class="s1">options</span>

        <span class="s3">this</span><span class="s4">.</span><span class="s1">width </span><span class="s4">= </span><span class="s1">width</span>
        <span class="s3">this</span><span class="s4">.</span><span class="s1">initial_indent </span><span class="s4">= </span><span class="s1">initial_indent</span>
        <span class="s3">this</span><span class="s4">.</span><span class="s1">subsequent_indent </span><span class="s4">= </span><span class="s1">subsequent_indent</span>
        <span class="s3">this</span><span class="s4">.</span><span class="s1">expand_tabs </span><span class="s4">= </span><span class="s1">expand_tabs</span>
        <span class="s3">this</span><span class="s4">.</span><span class="s1">replace_whitespace </span><span class="s4">= </span><span class="s1">replace_whitespace</span>
        <span class="s3">this</span><span class="s4">.</span><span class="s1">fix_sentence_endings </span><span class="s4">= </span><span class="s1">fix_sentence_endings</span>
        <span class="s3">this</span><span class="s4">.</span><span class="s1">break_long_words </span><span class="s4">= </span><span class="s1">break_long_words</span>
        <span class="s3">this</span><span class="s4">.</span><span class="s1">drop_whitespace </span><span class="s4">= </span><span class="s1">drop_whitespace</span>
        <span class="s3">this</span><span class="s4">.</span><span class="s1">break_on_hyphens </span><span class="s4">= </span><span class="s1">break_on_hyphens</span>
        <span class="s3">this</span><span class="s4">.</span><span class="s1">tabsize </span><span class="s4">= </span><span class="s1">tabsize</span>
        <span class="s3">this</span><span class="s4">.</span><span class="s1">max_lines </span><span class="s4">= </span><span class="s1">max_lines</span>
        <span class="s3">this</span><span class="s4">.</span><span class="s1">placeholder </span><span class="s4">= </span><span class="s1">placeholder</span>
    <span class="s4">}</span>


    <span class="s0">// -- Private methods -----------------------------------------------</span>
    <span class="s0">// (possibly useful for subclasses to override)</span>

    <span class="s1">_munge_whitespace</span><span class="s4">(</span><span class="s1">text</span><span class="s4">) {</span>
        <span class="s0">/* 
         *  _munge_whitespace(text : string) -&gt; string 
         * 
         *  Munge whitespace in text: expand tabs and convert all other 
         *  whitespace characters to spaces.  Eg. &quot; foo\\tbar\\n\\nbaz&quot; 
         *  becomes &quot; foo    bar  baz&quot;. 
         */</span>
        <span class="s3">if </span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s1">expand_tabs</span><span class="s4">) {</span>
            <span class="s1">text </span><span class="s4">= </span><span class="s1">text</span><span class="s4">.</span><span class="s1">replace</span><span class="s4">(</span><span class="s5">/\t/g</span><span class="s4">, </span><span class="s2">' '</span><span class="s4">.</span><span class="s1">repeat</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s1">tabsize</span><span class="s4">)) </span><span class="s0">// not strictly correct in js</span>
        <span class="s4">}</span>
        <span class="s3">if </span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s1">replace_whitespace</span><span class="s4">) {</span>
            <span class="s1">text </span><span class="s4">= </span><span class="s1">text</span><span class="s4">.</span><span class="s1">replace</span><span class="s4">(</span><span class="s5">/[\t\n\x0b\x0c\r]/g</span><span class="s4">, </span><span class="s2">' '</span><span class="s4">)</span>
        <span class="s4">}</span>
        <span class="s3">return </span><span class="s1">text</span>
    <span class="s4">}</span>

    <span class="s1">_split</span><span class="s4">(</span><span class="s1">text</span><span class="s4">) {</span>
        <span class="s0">/* 
         *  _split(text : string) -&gt; [string] 
         * 
         *  Split the text to wrap into indivisible chunks.  Chunks are 
         *  not quite the same as words; see _wrap_chunks() for full 
         *  details.  As an example, the text 
         *    Look, goof-ball -- use the -b option! 
         *  breaks into the following chunks: 
         *    'Look,', ' ', 'goof-', 'ball', ' ', '--', ' ', 
         *    'use', ' ', 'the', ' ', '-b', ' ', 'option!' 
         *  if break_on_hyphens is True, or in: 
         *    'Look,', ' ', 'goof-ball', ' ', '--', ' ', 
         *    'use', ' ', 'the', ' ', '-b', ' ', option!' 
         *  otherwise. 
         */</span>
        <span class="s3">let </span><span class="s1">chunks </span><span class="s4">= </span><span class="s1">text</span><span class="s4">.</span><span class="s1">split</span><span class="s4">(</span><span class="s1">wordsep_simple_re</span><span class="s4">)</span>
        <span class="s1">chunks </span><span class="s4">= </span><span class="s1">chunks</span><span class="s4">.</span><span class="s1">filter</span><span class="s4">(</span><span class="s1">Boolean</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">chunks</span>
    <span class="s4">}</span>

    <span class="s1">_handle_long_word</span><span class="s4">(</span><span class="s1">reversed_chunks</span><span class="s4">, </span><span class="s1">cur_line</span><span class="s4">, </span><span class="s1">cur_len</span><span class="s4">, </span><span class="s1">width</span><span class="s4">) {</span>
        <span class="s0">/* 
         *  _handle_long_word(chunks : [string], 
         *                    cur_line : [string], 
         *                    cur_len : int, width : int) 
         * 
         *  Handle a chunk of text (most likely a word, not whitespace) that 
         *  is too long to fit in any line. 
         */</span>
        <span class="s0">// Figure out when indent is larger than the specified width, and make</span>
        <span class="s0">// sure at least one character is stripped off on every pass</span>
        <span class="s3">let </span><span class="s1">space_left</span>
        <span class="s3">if </span><span class="s4">(</span><span class="s1">width </span><span class="s4">&lt; </span><span class="s6">1</span><span class="s4">) {</span>
            <span class="s1">space_left </span><span class="s4">= </span><span class="s6">1</span>
        <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
            <span class="s1">space_left </span><span class="s4">= </span><span class="s1">width </span><span class="s4">- </span><span class="s1">cur_len</span>
        <span class="s4">}</span>

        <span class="s0">// If we're allowed to break long words, then do so: put as much</span>
        <span class="s0">// of the next chunk onto the current line as will fit.</span>
        <span class="s3">if </span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s1">break_long_words</span><span class="s4">) {</span>
            <span class="s1">cur_line</span><span class="s4">.</span><span class="s1">push</span><span class="s4">(</span><span class="s1">reversed_chunks</span><span class="s4">[</span><span class="s1">reversed_chunks</span><span class="s4">.</span><span class="s1">length </span><span class="s4">- </span><span class="s6">1</span><span class="s4">].</span><span class="s1">slice</span><span class="s4">(</span><span class="s6">0</span><span class="s4">, </span><span class="s1">space_left</span><span class="s4">))</span>
            <span class="s1">reversed_chunks</span><span class="s4">[</span><span class="s1">reversed_chunks</span><span class="s4">.</span><span class="s1">length </span><span class="s4">- </span><span class="s6">1</span><span class="s4">] = </span><span class="s1">reversed_chunks</span><span class="s4">[</span><span class="s1">reversed_chunks</span><span class="s4">.</span><span class="s1">length </span><span class="s4">- </span><span class="s6">1</span><span class="s4">].</span><span class="s1">slice</span><span class="s4">(</span><span class="s1">space_left</span><span class="s4">)</span>

        <span class="s0">// Otherwise, we have to preserve the long word intact.  Only add</span>
        <span class="s0">// it to the current line if there's nothing already there --</span>
        <span class="s0">// that minimizes how much we violate the width constraint.</span>
        <span class="s4">} </span><span class="s3">else if </span><span class="s4">(!</span><span class="s1">cur_line</span><span class="s4">) {</span>
            <span class="s1">cur_line</span><span class="s4">.</span><span class="s1">push</span><span class="s4">(</span><span class="s1">...reversed_chunks</span><span class="s4">.</span><span class="s1">pop</span><span class="s4">())</span>
        <span class="s4">}</span>

        <span class="s0">// If we're not allowed to break long words, and there's already</span>
        <span class="s0">// text on the current line, do nothing.  Next time through the</span>
        <span class="s0">// main loop of _wrap_chunks(), we'll wind up here again, but</span>
        <span class="s0">// cur_len will be zero, so the next line will be entirely</span>
        <span class="s0">// devoted to the long word that we can't handle right now.</span>
    <span class="s4">}</span>

    <span class="s1">_wrap_chunks</span><span class="s4">(</span><span class="s1">chunks</span><span class="s4">) {</span>
        <span class="s0">/* 
         *  _wrap_chunks(chunks : [string]) -&gt; [string] 
         * 
         *  Wrap a sequence of text chunks and return a list of lines of 
         *  length 'self.width' or less.  (If 'break_long_words' is false, 
         *  some lines may be longer than this.)  Chunks correspond roughly 
         *  to words and the whitespace between them: each chunk is 
         *  indivisible (modulo 'break_long_words'), but a line break can 
         *  come between any two chunks.  Chunks should not have internal 
         *  whitespace; ie. a chunk is either all whitespace or a &quot;word&quot;. 
         *  Whitespace chunks will be removed from the beginning and end of 
         *  lines, but apart from that whitespace is preserved. 
         */</span>
        <span class="s3">let </span><span class="s1">lines </span><span class="s4">= []</span>
        <span class="s3">let </span><span class="s1">indent</span>
        <span class="s3">if </span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s1">width </span><span class="s4">&lt;= </span><span class="s6">0</span><span class="s4">) {</span>
            <span class="s3">throw </span><span class="s1">Error</span><span class="s4">(</span><span class="s2">`invalid width </span><span class="s1">$</span><span class="s4">{</span><span class="s3">this</span><span class="s4">.</span><span class="s1">width</span><span class="s4">} </span><span class="s2">(must be &gt; 0)`</span><span class="s4">)</span>
        <span class="s4">}</span>
        <span class="s3">if </span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s1">max_lines </span><span class="s4">!== </span><span class="s1">undefined</span><span class="s4">) {</span>
            <span class="s3">if </span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s1">max_lines </span><span class="s4">&gt; </span><span class="s6">1</span><span class="s4">) {</span>
                <span class="s1">indent </span><span class="s4">= </span><span class="s3">this</span><span class="s4">.</span><span class="s1">subsequent_indent</span>
            <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
                <span class="s1">indent </span><span class="s4">= </span><span class="s3">this</span><span class="s4">.</span><span class="s1">initial_indent</span>
            <span class="s4">}</span>
            <span class="s3">if </span><span class="s4">(</span><span class="s1">indent</span><span class="s4">.</span><span class="s1">length </span><span class="s4">+ </span><span class="s3">this</span><span class="s4">.</span><span class="s1">placeholder</span><span class="s4">.</span><span class="s1">trimStart</span><span class="s4">().</span><span class="s1">length </span><span class="s4">&gt; </span><span class="s3">this</span><span class="s4">.</span><span class="s1">width</span><span class="s4">) {</span>
                <span class="s3">throw </span><span class="s1">Error</span><span class="s4">(</span><span class="s2">'placeholder too large for max width'</span><span class="s4">)</span>
            <span class="s4">}</span>
        <span class="s4">}</span>

        <span class="s0">// Arrange in reverse order so items can be efficiently popped</span>
        <span class="s0">// from a stack of chucks.</span>
        <span class="s1">chunks </span><span class="s4">= </span><span class="s1">chunks</span><span class="s4">.</span><span class="s1">reverse</span><span class="s4">()</span>

        <span class="s3">while </span><span class="s4">(</span><span class="s1">chunks</span><span class="s4">.</span><span class="s1">length </span><span class="s4">&gt; </span><span class="s6">0</span><span class="s4">) {</span>

            <span class="s0">// Start the list of chunks that will make up the current line.</span>
            <span class="s0">// cur_len is just the length of all the chunks in cur_line.</span>
            <span class="s3">let </span><span class="s1">cur_line </span><span class="s4">= []</span>
            <span class="s3">let </span><span class="s1">cur_len </span><span class="s4">= </span><span class="s6">0</span>

            <span class="s0">// Figure out which static string will prefix this line.</span>
            <span class="s3">let </span><span class="s1">indent</span>
            <span class="s3">if </span><span class="s4">(</span><span class="s1">lines</span><span class="s4">) {</span>
                <span class="s1">indent </span><span class="s4">= </span><span class="s3">this</span><span class="s4">.</span><span class="s1">subsequent_indent</span>
            <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
                <span class="s1">indent </span><span class="s4">= </span><span class="s3">this</span><span class="s4">.</span><span class="s1">initial_indent</span>
            <span class="s4">}</span>

            <span class="s0">// Maximum width for this line.</span>
            <span class="s3">let </span><span class="s1">width </span><span class="s4">= </span><span class="s3">this</span><span class="s4">.</span><span class="s1">width </span><span class="s4">- </span><span class="s1">indent</span><span class="s4">.</span><span class="s1">length</span>

            <span class="s0">// First chunk on line is whitespace -- drop it, unless this</span>
            <span class="s0">// is the very beginning of the text (ie. no lines started yet).</span>
            <span class="s3">if </span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s1">drop_whitespace </span><span class="s4">&amp;&amp; </span><span class="s1">chunks</span><span class="s4">[</span><span class="s1">chunks</span><span class="s4">.</span><span class="s1">length </span><span class="s4">- </span><span class="s6">1</span><span class="s4">].</span><span class="s1">trim</span><span class="s4">() === </span><span class="s2">'' </span><span class="s4">&amp;&amp; </span><span class="s1">lines</span><span class="s4">.</span><span class="s1">length </span><span class="s4">&gt; </span><span class="s6">0</span><span class="s4">) {</span>
                <span class="s1">chunks</span><span class="s4">.</span><span class="s1">pop</span><span class="s4">()</span>
            <span class="s4">}</span>

            <span class="s3">while </span><span class="s4">(</span><span class="s1">chunks</span><span class="s4">.</span><span class="s1">length </span><span class="s4">&gt; </span><span class="s6">0</span><span class="s4">) {</span>
                <span class="s3">let </span><span class="s1">l </span><span class="s4">= </span><span class="s1">chunks</span><span class="s4">[</span><span class="s1">chunks</span><span class="s4">.</span><span class="s1">length </span><span class="s4">- </span><span class="s6">1</span><span class="s4">].</span><span class="s1">length</span>

                <span class="s0">// Can at least squeeze this chunk onto the current line.</span>
                <span class="s3">if </span><span class="s4">(</span><span class="s1">cur_len </span><span class="s4">+ </span><span class="s1">l </span><span class="s4">&lt;= </span><span class="s1">width</span><span class="s4">) {</span>
                    <span class="s1">cur_line</span><span class="s4">.</span><span class="s1">push</span><span class="s4">(</span><span class="s1">chunks</span><span class="s4">.</span><span class="s1">pop</span><span class="s4">())</span>
                    <span class="s1">cur_len </span><span class="s4">+= </span><span class="s1">l</span>

                <span class="s0">// Nope, this line is full.</span>
                <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
                    <span class="s3">break</span>
                <span class="s4">}</span>
            <span class="s4">}</span>

            <span class="s0">// The current line is full, and the next chunk is too big to</span>
            <span class="s0">// fit on *any* line (not just this one).</span>
            <span class="s3">if </span><span class="s4">(</span><span class="s1">chunks</span><span class="s4">.</span><span class="s1">length </span><span class="s4">&amp;&amp; </span><span class="s1">chunks</span><span class="s4">[</span><span class="s1">chunks</span><span class="s4">.</span><span class="s1">length </span><span class="s4">- </span><span class="s6">1</span><span class="s4">].</span><span class="s1">length </span><span class="s4">&gt; </span><span class="s1">width</span><span class="s4">) {</span>
                <span class="s3">this</span><span class="s4">.</span><span class="s1">_handle_long_word</span><span class="s4">(</span><span class="s1">chunks</span><span class="s4">, </span><span class="s1">cur_line</span><span class="s4">, </span><span class="s1">cur_len</span><span class="s4">, </span><span class="s1">width</span><span class="s4">)</span>
                <span class="s1">cur_len </span><span class="s4">= </span><span class="s1">cur_line</span><span class="s4">.</span><span class="s1">map</span><span class="s4">(</span><span class="s1">l </span><span class="s4">=&gt; </span><span class="s1">l</span><span class="s4">.</span><span class="s1">length</span><span class="s4">).</span><span class="s1">reduce</span><span class="s4">((</span><span class="s1">a</span><span class="s4">, </span><span class="s1">b</span><span class="s4">) =&gt; </span><span class="s1">a </span><span class="s4">+ </span><span class="s1">b</span><span class="s4">, </span><span class="s6">0</span><span class="s4">)</span>
            <span class="s4">}</span>

            <span class="s0">// If the last chunk on this line is all whitespace, drop it.</span>
            <span class="s3">if </span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s1">drop_whitespace </span><span class="s4">&amp;&amp; </span><span class="s1">cur_line</span><span class="s4">.</span><span class="s1">length </span><span class="s4">&gt; </span><span class="s6">0 </span><span class="s4">&amp;&amp; </span><span class="s1">cur_line</span><span class="s4">[</span><span class="s1">cur_line</span><span class="s4">.</span><span class="s1">length </span><span class="s4">- </span><span class="s6">1</span><span class="s4">].</span><span class="s1">trim</span><span class="s4">() === </span><span class="s2">''</span><span class="s4">) {</span>
                <span class="s1">cur_len </span><span class="s4">-= </span><span class="s1">cur_line</span><span class="s4">[</span><span class="s1">cur_line</span><span class="s4">.</span><span class="s1">length </span><span class="s4">- </span><span class="s6">1</span><span class="s4">].</span><span class="s1">length</span>
                <span class="s1">cur_line</span><span class="s4">.</span><span class="s1">pop</span><span class="s4">()</span>
            <span class="s4">}</span>

            <span class="s3">if </span><span class="s4">(</span><span class="s1">cur_line</span><span class="s4">) {</span>
                <span class="s3">if </span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s1">max_lines </span><span class="s4">=== </span><span class="s1">undefined </span><span class="s4">||</span>
                    <span class="s1">lines</span><span class="s4">.</span><span class="s1">length </span><span class="s4">+ </span><span class="s6">1 </span><span class="s4">&lt; </span><span class="s3">this</span><span class="s4">.</span><span class="s1">max_lines </span><span class="s4">||</span>
                    <span class="s4">(</span><span class="s1">chunks</span><span class="s4">.</span><span class="s1">length </span><span class="s4">=== </span><span class="s6">0 </span><span class="s4">||</span>
                     <span class="s3">this</span><span class="s4">.</span><span class="s1">drop_whitespace </span><span class="s4">&amp;&amp;</span>
                     <span class="s1">chunks</span><span class="s4">.</span><span class="s1">length </span><span class="s4">=== </span><span class="s6">1 </span><span class="s4">&amp;&amp;</span>
                     <span class="s4">!</span><span class="s1">chunks</span><span class="s4">[</span><span class="s6">0</span><span class="s4">].</span><span class="s1">trim</span><span class="s4">()) &amp;&amp; </span><span class="s1">cur_len </span><span class="s4">&lt;= </span><span class="s1">width</span><span class="s4">) {</span>
                    <span class="s0">// Convert current line back to a string and store it in</span>
                    <span class="s0">// list of all lines (return value).</span>
                    <span class="s1">lines</span><span class="s4">.</span><span class="s1">push</span><span class="s4">(</span><span class="s1">indent </span><span class="s4">+ </span><span class="s1">cur_line</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s2">''</span><span class="s4">))</span>
                <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
                    <span class="s3">let </span><span class="s1">had_break </span><span class="s4">= </span><span class="s3">false</span>
                    <span class="s3">while </span><span class="s4">(</span><span class="s1">cur_line</span><span class="s4">) {</span>
                        <span class="s3">if </span><span class="s4">(</span><span class="s1">cur_line</span><span class="s4">[</span><span class="s1">cur_line</span><span class="s4">.</span><span class="s1">length </span><span class="s4">- </span><span class="s6">1</span><span class="s4">].</span><span class="s1">trim</span><span class="s4">() &amp;&amp;</span>
                            <span class="s1">cur_len </span><span class="s4">+ </span><span class="s3">this</span><span class="s4">.</span><span class="s1">placeholder</span><span class="s4">.</span><span class="s1">length </span><span class="s4">&lt;= </span><span class="s1">width</span><span class="s4">) {</span>
                            <span class="s1">cur_line</span><span class="s4">.</span><span class="s1">push</span><span class="s4">(</span><span class="s3">this</span><span class="s4">.</span><span class="s1">placeholder</span><span class="s4">)</span>
                            <span class="s1">lines</span><span class="s4">.</span><span class="s1">push</span><span class="s4">(</span><span class="s1">indent </span><span class="s4">+ </span><span class="s1">cur_line</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s2">''</span><span class="s4">))</span>
                            <span class="s1">had_break </span><span class="s4">= </span><span class="s3">true</span>
                            <span class="s3">break</span>
                        <span class="s4">}</span>
                        <span class="s1">cur_len </span><span class="s4">-= </span><span class="s1">cur_line</span><span class="s4">[-</span><span class="s6">1</span><span class="s4">].</span><span class="s1">length</span>
                        <span class="s1">cur_line</span><span class="s4">.</span><span class="s1">pop</span><span class="s4">()</span>
                    <span class="s4">}</span>
                    <span class="s3">if </span><span class="s4">(!</span><span class="s1">had_break</span><span class="s4">) {</span>
                        <span class="s3">if </span><span class="s4">(</span><span class="s1">lines</span><span class="s4">) {</span>
                            <span class="s3">let </span><span class="s1">prev_line </span><span class="s4">= </span><span class="s1">lines</span><span class="s4">[</span><span class="s1">lines</span><span class="s4">.</span><span class="s1">length </span><span class="s4">- </span><span class="s6">1</span><span class="s4">].</span><span class="s1">trimEnd</span><span class="s4">()</span>
                            <span class="s3">if </span><span class="s4">(</span><span class="s1">prev_line</span><span class="s4">.</span><span class="s1">length </span><span class="s4">+ </span><span class="s3">this</span><span class="s4">.</span><span class="s1">placeholder</span><span class="s4">.</span><span class="s1">length </span><span class="s4">&lt;=</span>
                                    <span class="s3">this</span><span class="s4">.</span><span class="s1">width</span><span class="s4">) {</span>
                                <span class="s1">lines</span><span class="s4">[</span><span class="s1">lines</span><span class="s4">.</span><span class="s1">length </span><span class="s4">- </span><span class="s6">1</span><span class="s4">] = </span><span class="s1">prev_line </span><span class="s4">+ </span><span class="s3">this</span><span class="s4">.</span><span class="s1">placeholder</span>
                                <span class="s3">break</span>
                            <span class="s4">}</span>
                        <span class="s4">}</span>
                        <span class="s1">lines</span><span class="s4">.</span><span class="s1">push</span><span class="s4">(</span><span class="s1">indent </span><span class="s4">+ </span><span class="s3">this</span><span class="s4">.</span><span class="s1">placeholder</span><span class="s4">.</span><span class="s1">lstrip</span><span class="s4">())</span>
                    <span class="s4">}</span>
                    <span class="s3">break</span>
                <span class="s4">}</span>
            <span class="s4">}</span>
        <span class="s4">}</span>

        <span class="s3">return </span><span class="s1">lines</span>
    <span class="s4">}</span>

    <span class="s1">_split_chunks</span><span class="s4">(</span><span class="s1">text</span><span class="s4">) {</span>
        <span class="s1">text </span><span class="s4">= </span><span class="s3">this</span><span class="s4">.</span><span class="s1">_munge_whitespace</span><span class="s4">(</span><span class="s1">text</span><span class="s4">)</span>
        <span class="s3">return this</span><span class="s4">.</span><span class="s1">_split</span><span class="s4">(</span><span class="s1">text</span><span class="s4">)</span>
    <span class="s4">}</span>

    <span class="s0">// -- Public interface ----------------------------------------------</span>

    <span class="s1">wrap</span><span class="s4">(</span><span class="s1">text</span><span class="s4">) {</span>
        <span class="s0">/* 
         *  wrap(text : string) -&gt; [string] 
         * 
         *  Reformat the single paragraph in 'text' so it fits in lines of 
         *  no more than 'self.width' columns, and return a list of wrapped 
         *  lines.  Tabs in 'text' are expanded with string.expandtabs(), 
         *  and all other whitespace characters (including newline) are 
         *  converted to space. 
         */</span>
        <span class="s3">let </span><span class="s1">chunks </span><span class="s4">= </span><span class="s3">this</span><span class="s4">.</span><span class="s1">_split_chunks</span><span class="s4">(</span><span class="s1">text</span><span class="s4">)</span>
        <span class="s0">// not implemented in js</span>
        <span class="s0">//if (this.fix_sentence_endings) {</span>
        <span class="s0">//    this._fix_sentence_endings(chunks)</span>
        <span class="s0">//}</span>
        <span class="s3">return this</span><span class="s4">.</span><span class="s1">_wrap_chunks</span><span class="s4">(</span><span class="s1">chunks</span><span class="s4">)</span>
    <span class="s4">}</span>

    <span class="s1">fill</span><span class="s4">(</span><span class="s1">text</span><span class="s4">) {</span>
        <span class="s0">/* 
         *  fill(text : string) -&gt; string 
         * 
         *  Reformat the single paragraph in 'text' to fit in lines of no 
         *  more than 'self.width' columns, and return a new string 
         *  containing the entire wrapped paragraph. 
         */</span>
        <span class="s3">return this</span><span class="s4">.</span><span class="s1">wrap</span><span class="s4">(</span><span class="s1">text</span><span class="s4">).</span><span class="s1">join</span><span class="s4">(</span><span class="s2">'</span><span class="s3">\n</span><span class="s2">'</span><span class="s4">)</span>
    <span class="s4">}</span>
<span class="s4">}</span>


<span class="s0">// -- Convenience interface ---------------------------------------------</span>

<span class="s3">function </span><span class="s1">wrap</span><span class="s4">(</span><span class="s1">text</span><span class="s4">, </span><span class="s1">options </span><span class="s4">= {}) {</span>
    <span class="s0">/* 
     *  Wrap a single paragraph of text, returning a list of wrapped lines. 
     * 
     *  Reformat the single paragraph in 'text' so it fits in lines of no 
     *  more than 'width' columns, and return a list of wrapped lines.  By 
     *  default, tabs in 'text' are expanded with string.expandtabs(), and 
     *  all other whitespace characters (including newline) are converted to 
     *  space.  See TextWrapper class for available keyword args to customize 
     *  wrapping behaviour. 
     */</span>
    <span class="s3">let </span><span class="s4">{ </span><span class="s1">width </span><span class="s4">= </span><span class="s6">70</span><span class="s4">, </span><span class="s1">...kwargs </span><span class="s4">} = </span><span class="s1">options</span>
    <span class="s3">let </span><span class="s1">w </span><span class="s4">= </span><span class="s3">new </span><span class="s1">TextWrapper</span><span class="s4">(</span><span class="s1">Object</span><span class="s4">.</span><span class="s1">assign</span><span class="s4">({ </span><span class="s1">width </span><span class="s4">}, </span><span class="s1">kwargs</span><span class="s4">))</span>
    <span class="s3">return </span><span class="s1">w</span><span class="s4">.</span><span class="s1">wrap</span><span class="s4">(</span><span class="s1">text</span><span class="s4">)</span>
<span class="s4">}</span>

<span class="s3">function </span><span class="s1">fill</span><span class="s4">(</span><span class="s1">text</span><span class="s4">, </span><span class="s1">options </span><span class="s4">= {}) {</span>
    <span class="s0">/* 
     *  Fill a single paragraph of text, returning a new string. 
     * 
     *  Reformat the single paragraph in 'text' to fit in lines of no more 
     *  than 'width' columns, and return a new string containing the entire 
     *  wrapped paragraph.  As with wrap(), tabs are expanded and other 
     *  whitespace characters converted to space.  See TextWrapper class for 
     *  available keyword args to customize wrapping behaviour. 
     */</span>
    <span class="s3">let </span><span class="s4">{ </span><span class="s1">width </span><span class="s4">= </span><span class="s6">70</span><span class="s4">, </span><span class="s1">...kwargs </span><span class="s4">} = </span><span class="s1">options</span>
    <span class="s3">let </span><span class="s1">w </span><span class="s4">= </span><span class="s3">new </span><span class="s1">TextWrapper</span><span class="s4">(</span><span class="s1">Object</span><span class="s4">.</span><span class="s1">assign</span><span class="s4">({ </span><span class="s1">width </span><span class="s4">}, </span><span class="s1">kwargs</span><span class="s4">))</span>
    <span class="s3">return </span><span class="s1">w</span><span class="s4">.</span><span class="s1">fill</span><span class="s4">(</span><span class="s1">text</span><span class="s4">)</span>
<span class="s4">}</span>

<span class="s0">// -- Loosely related functionality -------------------------------------</span>

<span class="s3">let </span><span class="s1">_whitespace_only_re </span><span class="s4">= </span><span class="s5">/^[ \t]+$/mg</span>
<span class="s3">let </span><span class="s1">_leading_whitespace_re </span><span class="s4">= </span><span class="s5">/(^[ \t]*)(?:[^ \t\n])/mg</span>

<span class="s3">function </span><span class="s1">dedent</span><span class="s4">(</span><span class="s1">text</span><span class="s4">) {</span>
    <span class="s0">/* 
     *  Remove any common leading whitespace from every line in `text`. 
     * 
     *  This can be used to make triple-quoted strings line up with the left 
     *  edge of the display, while still presenting them in the source code 
     *  in indented form. 
     * 
     *  Note that tabs and spaces are both treated as whitespace, but they 
     *  are not equal: the lines &quot;  hello&quot; and &quot;\\thello&quot; are 
     *  considered to have no common leading whitespace. 
     * 
     *  Entirely blank lines are normalized to a newline character. 
     */</span>
    <span class="s0">// Look for the longest leading string of spaces and tabs common to</span>
    <span class="s0">// all lines.</span>
    <span class="s3">let </span><span class="s1">margin </span><span class="s4">= </span><span class="s1">undefined</span>
    <span class="s1">text </span><span class="s4">= </span><span class="s1">text</span><span class="s4">.</span><span class="s1">replace</span><span class="s4">(</span><span class="s1">_whitespace_only_re</span><span class="s4">, </span><span class="s2">''</span><span class="s4">)</span>
    <span class="s3">let </span><span class="s1">indents </span><span class="s4">= </span><span class="s1">text</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s1">_leading_whitespace_re</span><span class="s4">) || []</span>
    <span class="s3">for </span><span class="s4">(</span><span class="s3">let </span><span class="s1">indent of indents</span><span class="s4">) {</span>
        <span class="s1">indent </span><span class="s4">= </span><span class="s1">indent</span><span class="s4">.</span><span class="s1">slice</span><span class="s4">(</span><span class="s6">0</span><span class="s4">, -</span><span class="s6">1</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s4">(</span><span class="s1">margin </span><span class="s4">=== </span><span class="s1">undefined</span><span class="s4">) {</span>
            <span class="s1">margin </span><span class="s4">= </span><span class="s1">indent</span>

        <span class="s0">// Current line more deeply indented than previous winner:</span>
        <span class="s0">// no change (previous winner is still on top).</span>
        <span class="s4">} </span><span class="s3">else if </span><span class="s4">(</span><span class="s1">indent</span><span class="s4">.</span><span class="s1">startsWith</span><span class="s4">(</span><span class="s1">margin</span><span class="s4">)) {</span>
            <span class="s0">// pass</span>

        <span class="s0">// Current line consistent with and no deeper than previous winner:</span>
        <span class="s0">// it's the new winner.</span>
        <span class="s4">} </span><span class="s3">else if </span><span class="s4">(</span><span class="s1">margin</span><span class="s4">.</span><span class="s1">startsWith</span><span class="s4">(</span><span class="s1">indent</span><span class="s4">)) {</span>
            <span class="s1">margin </span><span class="s4">= </span><span class="s1">indent</span>

        <span class="s0">// Find the largest common whitespace between current line and previous</span>
        <span class="s0">// winner.</span>
        <span class="s4">} </span><span class="s3">else </span><span class="s4">{</span>
            <span class="s3">for </span><span class="s4">(</span><span class="s3">let </span><span class="s1">i </span><span class="s4">= </span><span class="s6">0</span><span class="s4">; </span><span class="s1">i </span><span class="s4">&lt; </span><span class="s1">margin</span><span class="s4">.</span><span class="s1">length </span><span class="s4">&amp;&amp; </span><span class="s1">i </span><span class="s4">&lt; </span><span class="s1">indent</span><span class="s4">.</span><span class="s1">length</span><span class="s4">; </span><span class="s1">i</span><span class="s4">++) {</span>
                <span class="s3">if </span><span class="s4">(</span><span class="s1">margin</span><span class="s4">[</span><span class="s1">i</span><span class="s4">] !== </span><span class="s1">indent</span><span class="s4">[</span><span class="s1">i</span><span class="s4">]) {</span>
                    <span class="s1">margin </span><span class="s4">= </span><span class="s1">margin</span><span class="s4">.</span><span class="s1">slice</span><span class="s4">(</span><span class="s6">0</span><span class="s4">, </span><span class="s1">i</span><span class="s4">)</span>
                    <span class="s3">break</span>
                <span class="s4">}</span>
            <span class="s4">}</span>
        <span class="s4">}</span>
    <span class="s4">}</span>

    <span class="s3">if </span><span class="s4">(</span><span class="s1">margin</span><span class="s4">) {</span>
        <span class="s1">text </span><span class="s4">= </span><span class="s1">text</span><span class="s4">.</span><span class="s1">replace</span><span class="s4">(</span><span class="s3">new </span><span class="s1">RegExp</span><span class="s4">(</span><span class="s2">'^' </span><span class="s4">+ </span><span class="s1">margin</span><span class="s4">, </span><span class="s2">'mg'</span><span class="s4">), </span><span class="s2">''</span><span class="s4">)</span>
    <span class="s4">}</span>
    <span class="s3">return </span><span class="s1">text</span>
<span class="s4">}</span>

<span class="s1">module</span><span class="s4">.</span><span class="s1">exports </span><span class="s4">= { </span><span class="s1">wrap</span><span class="s4">, </span><span class="s1">fill</span><span class="s4">, </span><span class="s1">dedent </span><span class="s4">}</span>
</pre>
</body>
</html>