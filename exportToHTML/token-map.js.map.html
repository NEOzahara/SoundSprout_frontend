<html>
<head>
<title>token-map.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
token-map.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_t&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;traverseFast&quot;</span><span class="s0">,</span><span class="s1">&quot;VISITOR_KEYS&quot;</span><span class="s0">,</span><span class="s1">&quot;TokenMap&quot;</span><span class="s0">,</span><span class="s1">&quot;constructor&quot;</span><span class="s0">,</span><span class="s1">&quot;ast&quot;</span><span class="s0">,</span><span class="s1">&quot;tokens&quot;</span><span class="s0">,</span><span class="s1">&quot;source&quot;</span><span class="s0">,</span><span class="s1">&quot;_tokens&quot;</span><span class="s0">,</span><span class="s1">&quot;_source&quot;</span><span class="s0">,</span><span class="s1">&quot;_nodesToTokenIndexes&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;_nodesOccurrencesCountCache&quot;</span><span class="s0">,</span><span class="s1">&quot;_tokensCache&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;indexes&quot;</span><span class="s0">,</span><span class="s1">&quot;_getTokensIndexesOfNode&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;has&quot;</span><span class="s0">,</span><span class="s1">&quot;getIndexes&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;find&quot;</span><span class="s0">,</span><span class="s1">&quot;condition&quot;</span><span class="s0">,</span><span class="s1">&quot;k&quot;</span><span class="s0">,</span><span class="s1">&quot;index&quot;</span><span class="s0">,</span><span class="s1">&quot;tok&quot;</span><span class="s0">,</span><span class="s1">&quot;findLastIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;findMatching&quot;</span><span class="s0">,</span><span class="s1">&quot;test&quot;</span><span class="s0">,</span><span class="s1">&quot;occurrenceCount&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;count&quot;</span><span class="s0">,</span><span class="s1">&quot;cache&quot;</span><span class="s0">,</span><span class="s1">&quot;matchesOriginal&quot;</span><span class="s0">,</span><span class="s1">&quot;token&quot;</span><span class="s0">,</span><span class="s1">&quot;end&quot;</span><span class="s0">,</span><span class="s1">&quot;start&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;startsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;startMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;endMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;first&quot;</span><span class="s0">,</span><span class="s1">&quot;last&quot;</span><span class="s0">,</span><span class="s1">&quot;_findTokensOfNode&quot;</span><span class="s0">,</span><span class="s1">&quot;low&quot;</span><span class="s0">,</span><span class="s1">&quot;children&quot;</span><span class="s0">,</span><span class="s1">&quot;childrenIterator&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;declaration&quot;</span><span class="s0">,</span><span class="s1">&quot;next&quot;</span><span class="s0">,</span><span class="s1">&quot;child&quot;</span><span class="s0">,</span><span class="s1">&quot;childTok&quot;</span><span class="s0">,</span><span class="s1">&quot;high&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;cached&quot;</span><span class="s0">,</span><span class="s1">&quot;_findFirstTokenOfNode&quot;</span><span class="s0">,</span><span class="s1">&quot;_findLastTokenOfNode&quot;</span><span class="s0">,</span><span class="s1">&quot;mid&quot;</span><span class="s0">,</span><span class="s1">&quot;exports&quot;</span><span class="s0">,</span><span class="s1">&quot;quasis&quot;</span><span class="s0">,</span><span class="s1">&quot;expressions&quot;</span><span class="s0">,</span><span class="s1">&quot;keys&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;isArray&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../src/token-map.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type * as t from </span><span class="s3">\&quot;</span><span class="s1">@babel/types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { Token } from </span><span class="s3">\&quot;</span><span class="s1">@babel/parser</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">import { traverseFast, VISITOR_KEYS } from </span><span class="s3">\&quot;</span><span class="s1">@babel/types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">export class TokenMap {</span><span class="s3">\n  </span><span class="s1">_tokens: Token[];</span><span class="s3">\n  </span><span class="s1">_source: string;</span><span class="s3">\n\n  </span><span class="s1">_nodesToTokenIndexes: Map&lt;t.Node, number[]&gt; = new Map();</span><span class="s3">\n  </span><span class="s1">_nodesOccurrencesCountCache: Map&lt;</span><span class="s3">\n    </span><span class="s1">t.Node,</span><span class="s3">\n    </span><span class="s1">{ test: string; count: number; i: number }</span><span class="s3">\n  </span><span class="s1">&gt; = new Map();</span><span class="s3">\n\n  </span><span class="s1">_tokensCache = new Map&lt;t.Node, { first: number; last: number }&gt;();</span><span class="s3">\n\n  </span><span class="s1">constructor(ast: t.Node, tokens: Token[], source: string) {</span><span class="s3">\n    </span><span class="s1">this._tokens = tokens;</span><span class="s3">\n    </span><span class="s1">this._source = source;</span><span class="s3">\n\n    </span><span class="s1">traverseFast(ast, node =&gt; {</span><span class="s3">\n      </span><span class="s1">const indexes = this._getTokensIndexesOfNode(node);</span><span class="s3">\n      </span><span class="s1">if (indexes.length &gt; 0) this._nodesToTokenIndexes.set(node, indexes);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n\n    </span><span class="s1">this._tokensCache = null;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">has(node: t.Node): boolean {</span><span class="s3">\n    </span><span class="s1">return this._nodesToTokenIndexes.has(node);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">getIndexes(node: t.Node): readonly number[] | undefined {</span><span class="s3">\n    </span><span class="s1">return this._nodesToTokenIndexes.get(node);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">find(</span><span class="s3">\n    </span><span class="s1">node: t.Node,</span><span class="s3">\n    </span><span class="s1">condition: (token: Token, index: number) =&gt; boolean,</span><span class="s3">\n  </span><span class="s1">): Token | null {</span><span class="s3">\n    </span><span class="s1">const indexes = this._nodesToTokenIndexes.get(node);</span><span class="s3">\n    </span><span class="s1">if (indexes) {</span><span class="s3">\n      </span><span class="s1">for (let k = 0; k &lt; indexes.length; k++) {</span><span class="s3">\n        </span><span class="s1">const index = indexes[k];</span><span class="s3">\n        </span><span class="s1">const tok = this._tokens[index];</span><span class="s3">\n        </span><span class="s1">if (condition(tok, index)) return tok;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return null;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">findLastIndex(</span><span class="s3">\n    </span><span class="s1">node: t.Node,</span><span class="s3">\n    </span><span class="s1">condition: (token: Token, index: number) =&gt; boolean,</span><span class="s3">\n  </span><span class="s1">): number {</span><span class="s3">\n    </span><span class="s1">const indexes = this._nodesToTokenIndexes.get(node);</span><span class="s3">\n    </span><span class="s1">if (indexes) {</span><span class="s3">\n      </span><span class="s1">for (let k = indexes.length - 1; k &gt;= 0; k--) {</span><span class="s3">\n        </span><span class="s1">const index = indexes[k];</span><span class="s3">\n        </span><span class="s1">const tok = this._tokens[index];</span><span class="s3">\n        </span><span class="s1">if (condition(tok, index)) return index;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return -1;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">findMatching(</span><span class="s3">\n    </span><span class="s1">node: t.Node,</span><span class="s3">\n    </span><span class="s1">test: string,</span><span class="s3">\n    </span><span class="s1">occurrenceCount: number = 0,</span><span class="s3">\n  </span><span class="s1">): Token | null {</span><span class="s3">\n    </span><span class="s1">const indexes = this._nodesToTokenIndexes.get(node);</span><span class="s3">\n    </span><span class="s1">if (indexes) {</span><span class="s3">\n      </span><span class="s1">let i = 0;</span><span class="s3">\n      </span><span class="s1">const count = occurrenceCount;</span><span class="s3">\n\n      </span><span class="s1">// To avoid O(n^2) search when printing lists (such as arrays), we</span><span class="s3">\n      </span><span class="s1">// cache the last index of a given token for a given occurrence count.</span><span class="s3">\n      </span><span class="s1">// If then we are asked to find the next occurrence of the same token,</span><span class="s3">\n      </span><span class="s1">// we start from the index of the previously found token.</span><span class="s3">\n      </span><span class="s1">// This cache only kicks in after 2 tokens of the same type, to avoid</span><span class="s3">\n      </span><span class="s1">// overhead in the simple case of having unique tokens per node.</span><span class="s3">\n      </span><span class="s1">if (count &gt; 1) {</span><span class="s3">\n        </span><span class="s1">const cache = this._nodesOccurrencesCountCache.get(node);</span><span class="s3">\n        </span><span class="s1">if (cache &amp;&amp; cache.test === test &amp;&amp; cache.count &lt; count) {</span><span class="s3">\n          </span><span class="s1">i = cache.i + 1;</span><span class="s3">\n          </span><span class="s1">occurrenceCount -= cache.count + 1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">for (; i &lt; indexes.length; i++) {</span><span class="s3">\n        </span><span class="s1">const tok = this._tokens[indexes[i]];</span><span class="s3">\n        </span><span class="s1">if (this.matchesOriginal(tok, test)) {</span><span class="s3">\n          </span><span class="s1">if (occurrenceCount === 0) {</span><span class="s3">\n            </span><span class="s1">if (count &gt; 0) {</span><span class="s3">\n              </span><span class="s1">this._nodesOccurrencesCountCache.set(node, { test, count, i });</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return tok;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">occurrenceCount--;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return null;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">matchesOriginal(token: Token, test: string) {</span><span class="s3">\n    </span><span class="s1">if (token.end - token.start !== test.length) return false;</span><span class="s3">\n    </span><span class="s1">if (token.value != null) return token.value === test;</span><span class="s3">\n    </span><span class="s1">return this._source.startsWith(test, token.start);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">startMatches(node: t.Node, test: string): boolean {</span><span class="s3">\n    </span><span class="s1">const indexes = this._nodesToTokenIndexes.get(node);</span><span class="s3">\n    </span><span class="s1">if (!indexes) return false;</span><span class="s3">\n    </span><span class="s1">const tok = this._tokens[indexes[0]];</span><span class="s3">\n    </span><span class="s1">if (tok.start !== node.start) return false;</span><span class="s3">\n    </span><span class="s1">return this.matchesOriginal(tok, test);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">endMatches(node: t.Node, test: string): boolean {</span><span class="s3">\n    </span><span class="s1">const indexes = this._nodesToTokenIndexes.get(node);</span><span class="s3">\n    </span><span class="s1">if (!indexes) return false;</span><span class="s3">\n    </span><span class="s1">const tok = this._tokens[indexes[indexes.length - 1]];</span><span class="s3">\n    </span><span class="s1">if (tok.end !== node.end) return false;</span><span class="s3">\n    </span><span class="s1">return this.matchesOriginal(tok, test);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_getTokensIndexesOfNode(node: t.Node): number[] {</span><span class="s3">\n    </span><span class="s1">if (node.start == null || node.end == null) return [];</span><span class="s3">\n\n    </span><span class="s1">const { first, last } = this._findTokensOfNode(</span><span class="s3">\n      </span><span class="s1">node,</span><span class="s3">\n      </span><span class="s1">0,</span><span class="s3">\n      </span><span class="s1">this._tokens.length - 1,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n\n    </span><span class="s1">let low = first;</span><span class="s3">\n\n    </span><span class="s1">const children = childrenIterator(node);</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">(node.type === </span><span class="s3">\&quot;</span><span class="s1">ExportNamedDeclaration</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n        </span><span class="s1">node.type === </span><span class="s3">\&quot;</span><span class="s1">ExportDefaultDeclaration</span><span class="s3">\&quot;</span><span class="s1">) &amp;&amp;</span><span class="s3">\n      </span><span class="s1">node.declaration &amp;&amp;</span><span class="s3">\n      </span><span class="s1">node.declaration.type === </span><span class="s3">\&quot;</span><span class="s1">ClassDeclaration</span><span class="s3">\&quot;\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">// Exported class declarations can be not properly nested inside</span><span class="s3">\n      </span><span class="s1">// the export declaration that contains them. For example, in</span><span class="s3">\n      </span><span class="s1">// `@dec export class Foo {}` the `export` is covered by the</span><span class="s3">\n      </span><span class="s1">// ClassDeclaration range. Skip the class declaration from the list</span><span class="s3">\n      </span><span class="s1">// of children to skip, so that when looking for `export` we also</span><span class="s3">\n      </span><span class="s1">// traverse its tokens.</span><span class="s3">\n      </span><span class="s1">children.next();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const indexes = [];</span><span class="s3">\n\n    </span><span class="s1">for (const child of children) {</span><span class="s3">\n      </span><span class="s1">if (child == null) continue;</span><span class="s3">\n      </span><span class="s1">if (child.start == null || child.end == null) continue;</span><span class="s3">\n\n      </span><span class="s1">const childTok = this._findTokensOfNode(child, low, last);</span><span class="s3">\n\n      </span><span class="s1">const high = childTok.first;</span><span class="s3">\n      </span><span class="s1">for (let k = low; k &lt; high; k++) indexes.push(k);</span><span class="s3">\n\n      </span><span class="s1">low = childTok.last + 1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">for (let k = low; k &lt;= last; k++) indexes.push(k);</span><span class="s3">\n\n    </span><span class="s1">return indexes;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_findTokensOfNode(node: t.Node, low: number, high: number) {</span><span class="s3">\n    </span><span class="s1">const cached = this._tokensCache.get(node);</span><span class="s3">\n    </span><span class="s1">if (cached) return cached;</span><span class="s3">\n\n    </span><span class="s1">const first = this._findFirstTokenOfNode(node.start, low, high);</span><span class="s3">\n    </span><span class="s1">const last = this._findLastTokenOfNode(node.end, first, high);</span><span class="s3">\n\n    </span><span class="s1">this._tokensCache.set(node, { first, last });</span><span class="s3">\n    </span><span class="s1">return { first, last };</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_findFirstTokenOfNode(start: number, low: number, high: number): number {</span><span class="s3">\n    </span><span class="s1">while (low &lt;= high) {</span><span class="s3">\n      </span><span class="s1">const mid = (high + low) &gt;&gt; 1;</span><span class="s3">\n      </span><span class="s1">if (start &lt; this._tokens[mid].start) {</span><span class="s3">\n        </span><span class="s1">high = mid - 1;</span><span class="s3">\n      </span><span class="s1">} else if (start &gt; this._tokens[mid].start) {</span><span class="s3">\n        </span><span class="s1">low = mid + 1;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">return mid;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return low;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_findLastTokenOfNode(end: number, low: number, high: number): number {</span><span class="s3">\n    </span><span class="s1">while (low &lt;= high) {</span><span class="s3">\n      </span><span class="s1">const mid = (high + low) &gt;&gt; 1;</span><span class="s3">\n      </span><span class="s1">if (end &lt; this._tokens[mid].end) {</span><span class="s3">\n        </span><span class="s1">high = mid - 1;</span><span class="s3">\n      </span><span class="s1">} else if (end &gt; this._tokens[mid].end) {</span><span class="s3">\n        </span><span class="s1">low = mid + 1;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">return mid;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return high;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function* childrenIterator(node: t.Node) {</span><span class="s3">\n  </span><span class="s1">// We need special handling to iterate TemplateLiteral</span><span class="s3">\n  </span><span class="s1">// children in order, since the two lists are interleaved.</span><span class="s3">\n  </span><span class="s1">if (node.type === </span><span class="s3">\&quot;</span><span class="s1">TemplateLiteral</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">yield node.quasis[0];</span><span class="s3">\n    </span><span class="s1">for (let i = 1; i &lt; node.quasis.length; i++) {</span><span class="s3">\n      </span><span class="s1">yield node.expressions[i - 1];</span><span class="s3">\n      </span><span class="s1">yield node.quasis[i];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const keys = VISITOR_KEYS[node.type];</span><span class="s3">\n  </span><span class="s1">for (const key of keys) {</span><span class="s3">\n    </span><span class="s1">const child = (node as any)[key];</span><span class="s3">\n    </span><span class="s1">if (!child) continue;</span><span class="s3">\n    </span><span class="s1">if (Array.isArray(child)) {</span><span class="s3">\n      </span><span class="s1">yield* child;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">yield child;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[]}</span></pre>
</body>
</html>