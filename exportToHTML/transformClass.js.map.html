<html>
<head>
<title>transformClass.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
transformClass.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_helperReplaceSupers&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;_core&quot;</span><span class="s0">,</span><span class="s1">&quot;_traverse&quot;</span><span class="s0">,</span><span class="s1">&quot;_helperAnnotateAsPure&quot;</span><span class="s0">,</span><span class="s1">&quot;_inlineCallSuperHelpers&quot;</span><span class="s0">,</span><span class="s1">&quot;buildConstructor&quot;</span><span class="s0">,</span><span class="s1">&quot;classRef&quot;</span><span class="s0">,</span><span class="s1">&quot;constructorBody&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;func&quot;</span><span class="s0">,</span><span class="s1">&quot;t&quot;</span><span class="s0">,</span><span class="s1">&quot;functionDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;cloneNode&quot;</span><span class="s0">,</span><span class="s1">&quot;inherits&quot;</span><span class="s0">,</span><span class="s1">&quot;transformClass&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">,</span><span class="s1">&quot;builtinClasses&quot;</span><span class="s0">,</span><span class="s1">&quot;isLoose&quot;</span><span class="s0">,</span><span class="s1">&quot;assumptions&quot;</span><span class="s0">,</span><span class="s1">&quot;supportUnicodeId&quot;</span><span class="s0">,</span><span class="s1">&quot;classState&quot;</span><span class="s0">,</span><span class="s1">&quot;parent&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;scope&quot;</span><span class="s0">,</span><span class="s1">&quot;classId&quot;</span><span class="s0">,</span><span class="s1">&quot;superName&quot;</span><span class="s0">,</span><span class="s1">&quot;superReturns&quot;</span><span class="s0">,</span><span class="s1">&quot;isDerived&quot;</span><span class="s0">,</span><span class="s1">&quot;extendsNative&quot;</span><span class="s0">,</span><span class="s1">&quot;construct&quot;</span><span class="s0">,</span><span class="s1">&quot;userConstructor&quot;</span><span class="s0">,</span><span class="s1">&quot;userConstructorPath&quot;</span><span class="s0">,</span><span class="s1">&quot;hasConstructor&quot;</span><span class="s0">,</span><span class="s1">&quot;body&quot;</span><span class="s0">,</span><span class="s1">&quot;superThises&quot;</span><span class="s0">,</span><span class="s1">&quot;pushedInherits&quot;</span><span class="s0">,</span><span class="s1">&quot;pushedCreateClass&quot;</span><span class="s0">,</span><span class="s1">&quot;protoAlias&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;methods&quot;</span><span class="s0">,</span><span class="s1">&quot;instance&quot;</span><span class="s0">,</span><span class="s1">&quot;hasComputed&quot;</span><span class="s0">,</span><span class="s1">&quot;list&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;static&quot;</span><span class="s0">,</span><span class="s1">&quot;setState&quot;</span><span class="s0">,</span><span class="s1">&quot;newState&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;assign&quot;</span><span class="s0">,</span><span class="s1">&quot;findThisesVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;visitors&quot;</span><span class="s0">,</span><span class="s1">&quot;environmentVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;ThisExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;createClassHelper&quot;</span><span class="s0">,</span><span class="s1">&quot;args&quot;</span><span class="s0">,</span><span class="s1">&quot;callExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;addHelper&quot;</span><span class="s0">,</span><span class="s1">&quot;maybeCreateConstructor&quot;</span><span class="s0">,</span><span class="s1">&quot;classBodyPath&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;isClassMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;kind&quot;</span><span class="s0">,</span><span class="s1">&quot;params&quot;</span><span class="s0">,</span><span class="s1">&quot;constructor&quot;</span><span class="s0">,</span><span class="s1">&quot;template&quot;</span><span class="s0">,</span><span class="s1">&quot;expression&quot;</span><span class="s0">,</span><span class="s1">&quot;ast&quot;</span><span class="s0">,</span><span class="s1">&quot;blockStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;unshiftContainer&quot;</span><span class="s0">,</span><span class="s1">&quot;classMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;identifier&quot;</span><span class="s0">,</span><span class="s1">&quot;buildBody&quot;</span><span class="s0">,</span><span class="s1">&quot;pushBody&quot;</span><span class="s0">,</span><span class="s1">&quot;verifyConstructor&quot;</span><span class="s0">,</span><span class="s1">&quot;pushDescriptors&quot;</span><span class="s0">,</span><span class="s1">&quot;classBodyPaths&quot;</span><span class="s0">,</span><span class="s1">&quot;isClassProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;isClassPrivateProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;buildCodeFrameError&quot;</span><span class="s0">,</span><span class="s1">&quot;decorators&quot;</span><span class="s0">,</span><span class="s1">&quot;isConstructor&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceSupers&quot;</span><span class="s0">,</span><span class="s1">&quot;ReplaceSupers&quot;</span><span class="s0">,</span><span class="s1">&quot;methodPath&quot;</span><span class="s0">,</span><span class="s1">&quot;objectRef&quot;</span><span class="s0">,</span><span class="s1">&quot;superRef&quot;</span><span class="s0">,</span><span class="s1">&quot;constantSuper&quot;</span><span class="s0">,</span><span class="s1">&quot;refToPreserve&quot;</span><span class="s0">,</span><span class="s1">&quot;replace&quot;</span><span class="s0">,</span><span class="s1">&quot;traverse&quot;</span><span class="s0">,</span><span class="s1">&quot;ReturnStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;getFunctionParent&quot;</span><span class="s0">,</span><span class="s1">&quot;isArrowFunctionExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;pushConstructor&quot;</span><span class="s0">,</span><span class="s1">&quot;_path$ensureFunctionN&quot;</span><span class="s0">,</span><span class="s1">&quot;ensureFunctionName&quot;</span><span class="s0">,</span><span class="s1">&quot;NodePath&quot;</span><span class="s0">,</span><span class="s1">&quot;prototype&quot;</span><span class="s0">,</span><span class="s1">&quot;wrapped&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceWith&quot;</span><span class="s0">,</span><span class="s1">&quot;pushMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;pushInheritsToBody&quot;</span><span class="s0">,</span><span class="s1">&quot;props&quot;</span><span class="s0">,</span><span class="s1">&quot;placement&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;desc&quot;</span><span class="s0">,</span><span class="s1">&quot;obj&quot;</span><span class="s0">,</span><span class="s1">&quot;objectExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;objectProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;properties&quot;</span><span class="s0">,</span><span class="s1">&quot;arrayExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;nullLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;lastNonNullIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;isNullLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;returnStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;wrapSuperCall&quot;</span><span class="s0">,</span><span class="s1">&quot;bareSuper&quot;</span><span class="s0">,</span><span class="s1">&quot;thisRef&quot;</span><span class="s0">,</span><span class="s1">&quot;bareSuperNode&quot;</span><span class="s0">,</span><span class="s1">&quot;call&quot;</span><span class="s0">,</span><span class="s1">&quot;superIsCallableConstructor&quot;</span><span class="s0">,</span><span class="s1">&quot;arguments&quot;</span><span class="s0">,</span><span class="s1">&quot;unshift&quot;</span><span class="s0">,</span><span class="s1">&quot;thisExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;isSpreadElement&quot;</span><span class="s0">,</span><span class="s1">&quot;isIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;argument&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;callee&quot;</span><span class="s0">,</span><span class="s1">&quot;memberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;logicalExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;_bareSuperNode$argume&quot;</span><span class="s0">,</span><span class="s1">&quot;bareSuperNodeArguments&quot;</span><span class="s0">,</span><span class="s1">&quot;addCallSuperHelper&quot;</span><span class="s0">,</span><span class="s1">&quot;parentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;isExpressionStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;container&quot;</span><span class="s0">,</span><span class="s1">&quot;assignmentExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;maxGuaranteedSuperBeforeIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;ref&quot;</span><span class="s0">,</span><span class="s1">&quot;generateDeclaredUidIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;buildAssertThisInitialized&quot;</span><span class="s0">,</span><span class="s1">&quot;bareSupers&quot;</span><span class="s0">,</span><span class="s1">&quot;Super&quot;</span><span class="s0">,</span><span class="s1">&quot;isCallExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;lastParentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;find&quot;</span><span class="s0">,</span><span class="s1">&quot;Math&quot;</span><span class="s0">,</span><span class="s1">&quot;min&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;left&quot;</span><span class="s0">,</span><span class="s1">&quot;isConditional&quot;</span><span class="s0">,</span><span class="s1">&quot;test&quot;</span><span class="s0">,</span><span class="s1">&quot;object&quot;</span><span class="s0">,</span><span class="s1">&quot;guaranteedCalls&quot;</span><span class="s0">,</span><span class="s1">&quot;Set&quot;</span><span class="s0">,</span><span class="s1">&quot;thisPath&quot;</span><span class="s0">,</span><span class="s1">&quot;isMemberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;thisIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;exprPath&quot;</span><span class="s0">,</span><span class="s1">&quot;isSequenceExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;listKey&quot;</span><span class="s0">,</span><span class="s1">&quot;isOptionalCallExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;has&quot;</span><span class="s0">,</span><span class="s1">&quot;add&quot;</span><span class="s0">,</span><span class="s1">&quot;wrapReturn&quot;</span><span class="s0">,</span><span class="s1">&quot;returnArg&quot;</span><span class="s0">,</span><span class="s1">&quot;thisExpr&quot;</span><span class="s0">,</span><span class="s1">&quot;returnParams&quot;</span><span class="s0">,</span><span class="s1">&quot;bodyPaths&quot;</span><span class="s0">,</span><span class="s1">&quot;guaranteedSuperBeforeFinish&quot;</span><span class="s0">,</span><span class="s1">&quot;pop&quot;</span><span class="s0">,</span><span class="s1">&quot;isReturnStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;pushContainer&quot;</span><span class="s0">,</span><span class="s1">&quot;returnPath&quot;</span><span class="s0">,</span><span class="s1">&quot;processMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;descKey&quot;</span><span class="s0">,</span><span class="s1">&quot;isNumericLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;isBigIntLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;stringLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;String&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;toComputedKey&quot;</span><span class="s0">,</span><span class="s1">&quot;isStringLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;fn&quot;</span><span class="s0">,</span><span class="s1">&quot;toExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;descriptor&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;setClassMethods&quot;</span><span class="s0">,</span><span class="s1">&quot;insertProtoAliasOnce&quot;</span><span class="s0">,</span><span class="s1">&quot;methodName&quot;</span><span class="s0">,</span><span class="s1">&quot;computed&quot;</span><span class="s0">,</span><span class="s1">&quot;isLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;functionExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;id&quot;</span><span class="s0">,</span><span class="s1">&quot;generator&quot;</span><span class="s0">,</span><span class="s1">&quot;async&quot;</span><span class="s0">,</span><span class="s1">&quot;expr&quot;</span><span class="s0">,</span><span class="s1">&quot;expressionStatement&quot;</span><span class="s0">,</span><span class="s1">&quot;inheritsComments&quot;</span><span class="s0">,</span><span class="s1">&quot;generateUidIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;classProto&quot;</span><span class="s0">,</span><span class="s1">&quot;protoDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;variableDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;variableDeclarator&quot;</span><span class="s0">,</span><span class="s1">&quot;method&quot;</span><span class="s0">,</span><span class="s1">&quot;directives&quot;</span><span class="s0">,</span><span class="s1">&quot;hasInstanceDescriptors&quot;</span><span class="s0">,</span><span class="s1">&quot;hasStaticDescriptors&quot;</span><span class="s0">,</span><span class="s1">&quot;extractDynamicKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;elem&quot;</span><span class="s0">,</span><span class="s1">&quot;isPure&quot;</span><span class="s0">,</span><span class="s1">&quot;generateUidIdentifierBasedOnNode&quot;</span><span class="s0">,</span><span class="s1">&quot;setupClosureParamsArgs&quot;</span><span class="s0">,</span><span class="s1">&quot;closureParams&quot;</span><span class="s0">,</span><span class="s1">&quot;closureArgs&quot;</span><span class="s0">,</span><span class="s1">&quot;arg&quot;</span><span class="s0">,</span><span class="s1">&quot;annotateAsPure&quot;</span><span class="s0">,</span><span class="s1">&quot;param&quot;</span><span class="s0">,</span><span class="s1">&quot;classTransformer&quot;</span><span class="s0">,</span><span class="s1">&quot;superClass&quot;</span><span class="s0">,</span><span class="s1">&quot;hasBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;noClassCalls&quot;</span><span class="s0">,</span><span class="s1">&quot;isStrict&quot;</span><span class="s0">,</span><span class="s1">&quot;isInStrictMode&quot;</span><span class="s0">,</span><span class="s1">&quot;constructorOnly&quot;</span><span class="s0">,</span><span class="s1">&quot;directive&quot;</span><span class="s0">,</span><span class="s1">&quot;directiveLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;arrowFunctionExpression&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../src/transformClass.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { NodePath, Scope, File } from </span><span class="s3">\&quot;</span><span class="s1">@babel/core</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import ReplaceSupers from </span><span class="s3">\&quot;</span><span class="s1">@babel/helper-replace-supers</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { template, types as t } from </span><span class="s3">\&quot;</span><span class="s1">@babel/core</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { visitors } from </span><span class="s3">\&quot;</span><span class="s1">@babel/traverse</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import annotateAsPure from </span><span class="s3">\&quot;</span><span class="s1">@babel/helper-annotate-as-pure</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">import addCallSuperHelper from </span><span class="s3">\&quot;</span><span class="s1">./inline-callSuper-helpers.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">type ClassAssumptions = {</span><span class="s3">\n  </span><span class="s1">setClassMethods: boolean;</span><span class="s3">\n  </span><span class="s1">constantSuper: boolean;</span><span class="s3">\n  </span><span class="s1">superIsCallableConstructor: boolean;</span><span class="s3">\n  </span><span class="s1">noClassCalls: boolean;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">type ClassConstructor = t.ClassMethod &amp; { kind: </span><span class="s3">\&quot;</span><span class="s1">constructor</span><span class="s3">\&quot; </span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">function buildConstructor(</span><span class="s3">\n  </span><span class="s1">classRef: t.Identifier,</span><span class="s3">\n  </span><span class="s1">constructorBody: t.BlockStatement,</span><span class="s3">\n  </span><span class="s1">node: t.Class,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const func = t.functionDeclaration(</span><span class="s3">\n    </span><span class="s1">t.cloneNode(classRef),</span><span class="s3">\n    </span><span class="s1">[],</span><span class="s3">\n    </span><span class="s1">constructorBody,</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">t.inherits(func, node);</span><span class="s3">\n  </span><span class="s1">return func;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type Descriptor = {</span><span class="s3">\n  </span><span class="s1">key: t.Expression;</span><span class="s3">\n  </span><span class="s1">get?: t.Expression | null;</span><span class="s3">\n  </span><span class="s1">set?: t.Expression | null;</span><span class="s3">\n  </span><span class="s1">value?: t.Expression | null;</span><span class="s3">\n  </span><span class="s1">constructor?: t.Expression | null;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">type State = {</span><span class="s3">\n  </span><span class="s1">parent: t.Node;</span><span class="s3">\n  </span><span class="s1">scope: Scope;</span><span class="s3">\n  </span><span class="s1">node: t.Class;</span><span class="s3">\n  </span><span class="s1">path: NodePath&lt;t.Class&gt;;</span><span class="s3">\n  </span><span class="s1">file: File;</span><span class="s3">\n\n  </span><span class="s1">classId: t.Identifier | void;</span><span class="s3">\n  </span><span class="s1">classRef: t.Identifier;</span><span class="s3">\n  </span><span class="s1">superName: t.Expression | null;</span><span class="s3">\n  </span><span class="s1">superReturns: NodePath&lt;t.ReturnStatement&gt;[];</span><span class="s3">\n  </span><span class="s1">isDerived: boolean;</span><span class="s3">\n  </span><span class="s1">extendsNative: boolean;</span><span class="s3">\n\n  </span><span class="s1">construct: t.FunctionDeclaration;</span><span class="s3">\n  </span><span class="s1">constructorBody: t.BlockStatement;</span><span class="s3">\n  </span><span class="s1">userConstructor: ClassConstructor;</span><span class="s3">\n  </span><span class="s1">userConstructorPath: NodePath&lt;ClassConstructor&gt;;</span><span class="s3">\n  </span><span class="s1">hasConstructor: boolean;</span><span class="s3">\n\n  </span><span class="s1">body: t.Statement[];</span><span class="s3">\n  </span><span class="s1">superThises: NodePath&lt;t.ThisExpression&gt;[];</span><span class="s3">\n  </span><span class="s1">pushedInherits: boolean;</span><span class="s3">\n  </span><span class="s1">pushedCreateClass: boolean;</span><span class="s3">\n  </span><span class="s1">protoAlias: t.Identifier | null;</span><span class="s3">\n  </span><span class="s1">isLoose: boolean;</span><span class="s3">\n\n  </span><span class="s1">dynamicKeys: Map&lt;string, t.Expression&gt;;</span><span class="s3">\n\n  </span><span class="s1">methods: {</span><span class="s3">\n    </span><span class="s1">// 'list' is in the same order as the elements appear in the class body.</span><span class="s3">\n    </span><span class="s1">// if there aren't computed keys, we can safely reorder class elements</span><span class="s3">\n    </span><span class="s1">// and use 'map' to merge duplicates.</span><span class="s3">\n    </span><span class="s1">instance: {</span><span class="s3">\n      </span><span class="s1">hasComputed: boolean;</span><span class="s3">\n      </span><span class="s1">list: Descriptor[];</span><span class="s3">\n      </span><span class="s1">map: Map&lt;string, Descriptor&gt;;</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">static: {</span><span class="s3">\n      </span><span class="s1">hasComputed: boolean;</span><span class="s3">\n      </span><span class="s1">list: Descriptor[];</span><span class="s3">\n      </span><span class="s1">map: Map&lt;string, Descriptor&gt;;</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">type PropertyInfo = {</span><span class="s3">\n  </span><span class="s1">instance: t.ObjectExpression[] | null;</span><span class="s3">\n  </span><span class="s1">static: t.ObjectExpression[] | null;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export default function transformClass(</span><span class="s3">\n  </span><span class="s1">path: NodePath&lt;t.Class&gt;,</span><span class="s3">\n  </span><span class="s1">file: File,</span><span class="s3">\n  </span><span class="s1">builtinClasses: ReadonlySet&lt;string&gt;,</span><span class="s3">\n  </span><span class="s1">isLoose: boolean,</span><span class="s3">\n  </span><span class="s1">assumptions: ClassAssumptions,</span><span class="s3">\n  </span><span class="s1">supportUnicodeId: boolean,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const classState: State = {</span><span class="s3">\n    </span><span class="s1">parent: undefined,</span><span class="s3">\n    </span><span class="s1">scope: undefined,</span><span class="s3">\n    </span><span class="s1">node: undefined,</span><span class="s3">\n    </span><span class="s1">path: undefined,</span><span class="s3">\n    </span><span class="s1">file: undefined,</span><span class="s3">\n\n    </span><span class="s1">classId: undefined,</span><span class="s3">\n    </span><span class="s1">classRef: undefined,</span><span class="s3">\n    </span><span class="s1">superName: null,</span><span class="s3">\n    </span><span class="s1">superReturns: [],</span><span class="s3">\n    </span><span class="s1">isDerived: false,</span><span class="s3">\n    </span><span class="s1">extendsNative: false,</span><span class="s3">\n\n    </span><span class="s1">construct: undefined,</span><span class="s3">\n    </span><span class="s1">constructorBody: undefined,</span><span class="s3">\n    </span><span class="s1">userConstructor: undefined,</span><span class="s3">\n    </span><span class="s1">userConstructorPath: undefined,</span><span class="s3">\n    </span><span class="s1">hasConstructor: false,</span><span class="s3">\n\n    </span><span class="s1">body: [],</span><span class="s3">\n    </span><span class="s1">superThises: [],</span><span class="s3">\n    </span><span class="s1">pushedInherits: false,</span><span class="s3">\n    </span><span class="s1">pushedCreateClass: false,</span><span class="s3">\n    </span><span class="s1">protoAlias: null,</span><span class="s3">\n    </span><span class="s1">isLoose: false,</span><span class="s3">\n\n    </span><span class="s1">dynamicKeys: new Map(),</span><span class="s3">\n\n    </span><span class="s1">methods: {</span><span class="s3">\n      </span><span class="s1">instance: {</span><span class="s3">\n        </span><span class="s1">hasComputed: false,</span><span class="s3">\n        </span><span class="s1">list: [],</span><span class="s3">\n        </span><span class="s1">map: new Map(),</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">static: {</span><span class="s3">\n        </span><span class="s1">hasComputed: false,</span><span class="s3">\n        </span><span class="s1">list: [],</span><span class="s3">\n        </span><span class="s1">map: new Map(),</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">const setState = (newState: Partial&lt;State&gt;) =&gt; {</span><span class="s3">\n    </span><span class="s1">Object.assign(classState, newState);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">const findThisesVisitor = visitors.environmentVisitor({</span><span class="s3">\n    </span><span class="s1">ThisExpression(path) {</span><span class="s3">\n      </span><span class="s1">classState.superThises.push(path);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">function createClassHelper(args: t.Expression[]) {</span><span class="s3">\n    </span><span class="s1">return t.callExpression(classState.file.addHelper(</span><span class="s3">\&quot;</span><span class="s1">createClass</span><span class="s3">\&quot;</span><span class="s1">), args);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Creates a class constructor or bail out if there is one</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">function maybeCreateConstructor() {</span><span class="s3">\n    </span><span class="s1">const classBodyPath = classState.path.get(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">for (const path of classBodyPath.get(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n      </span><span class="s1">if (path.isClassMethod({ kind: </span><span class="s3">\&quot;</span><span class="s1">constructor</span><span class="s3">\&quot; </span><span class="s1">})) return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">let params: t.FunctionExpression[</span><span class="s3">\&quot;</span><span class="s1">params</span><span class="s3">\&quot;</span><span class="s1">], body;</span><span class="s3">\n\n    </span><span class="s1">if (classState.isDerived) {</span><span class="s3">\n      </span><span class="s1">const constructor = template.expression.ast`</span><span class="s3">\n        </span><span class="s1">(function () {</span><span class="s3">\n          </span><span class="s1">super(...arguments);</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">` as t.FunctionExpression;</span><span class="s3">\n      </span><span class="s1">params = constructor.params;</span><span class="s3">\n      </span><span class="s1">body = constructor.body;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">params = [];</span><span class="s3">\n      </span><span class="s1">body = t.blockStatement([]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">classBodyPath.unshiftContainer(</span><span class="s3">\n      \&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">t.classMethod(</span><span class="s3">\&quot;</span><span class="s1">constructor</span><span class="s3">\&quot;</span><span class="s1">, t.identifier(</span><span class="s3">\&quot;</span><span class="s1">constructor</span><span class="s3">\&quot;</span><span class="s1">), params, body),</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function buildBody() {</span><span class="s3">\n    </span><span class="s1">maybeCreateConstructor();</span><span class="s3">\n    </span><span class="s1">pushBody();</span><span class="s3">\n    </span><span class="s1">verifyConstructor();</span><span class="s3">\n\n    </span><span class="s1">if (classState.userConstructor) {</span><span class="s3">\n      </span><span class="s1">const { constructorBody, userConstructor, construct } = classState;</span><span class="s3">\n\n      </span><span class="s1">constructorBody.body.push(...userConstructor.body.body);</span><span class="s3">\n      </span><span class="s1">t.inherits(construct, userConstructor);</span><span class="s3">\n      </span><span class="s1">t.inherits(constructorBody, userConstructor.body);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">pushDescriptors();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function pushBody() {</span><span class="s3">\n    </span><span class="s1">const classBodyPaths: Array&lt;any&gt; = classState.path.get(</span><span class="s3">\&quot;</span><span class="s1">body.body</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n    </span><span class="s1">for (const path of classBodyPaths) {</span><span class="s3">\n      </span><span class="s1">const node = path.node;</span><span class="s3">\n\n      </span><span class="s1">if (path.isClassProperty() || path.isClassPrivateProperty()) {</span><span class="s3">\n        </span><span class="s1">throw path.buildCodeFrameError(</span><span class="s3">\&quot;</span><span class="s1">Missing class properties transform.</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (node.decorators) {</span><span class="s3">\n        </span><span class="s1">throw path.buildCodeFrameError(</span><span class="s3">\n          \&quot;</span><span class="s1">Method has decorators, put the decorator plugin before the classes one.</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (t.isClassMethod(node)) {</span><span class="s3">\n        </span><span class="s1">const isConstructor = node.kind === </span><span class="s3">\&quot;</span><span class="s1">constructor</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n        </span><span class="s1">const replaceSupers = new ReplaceSupers({</span><span class="s3">\n          </span><span class="s1">methodPath: path,</span><span class="s3">\n          </span><span class="s1">objectRef: classState.classRef,</span><span class="s3">\n          </span><span class="s1">superRef: classState.superName,</span><span class="s3">\n          </span><span class="s1">constantSuper: assumptions.constantSuper,</span><span class="s3">\n          </span><span class="s1">file: classState.file,</span><span class="s3">\n          </span><span class="s1">refToPreserve: classState.classRef,</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n\n        </span><span class="s1">replaceSupers.replace();</span><span class="s3">\n\n        </span><span class="s1">const superReturns: NodePath&lt;t.ReturnStatement&gt;[] = [];</span><span class="s3">\n        </span><span class="s1">path.traverse(</span><span class="s3">\n          </span><span class="s1">visitors.environmentVisitor({</span><span class="s3">\n            </span><span class="s1">ReturnStatement(path) {</span><span class="s3">\n              </span><span class="s1">if (!path.getFunctionParent().isArrowFunctionExpression()) {</span><span class="s3">\n                </span><span class="s1">superReturns.push(path);</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n          </span><span class="s1">}),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n\n        </span><span class="s1">if (isConstructor) {</span><span class="s3">\n          </span><span class="s1">pushConstructor(superReturns, node as ClassConstructor, path);</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">if (!process.env.BABEL_8_BREAKING &amp;&amp; !USE_ESM &amp;&amp; !IS_STANDALONE) {</span><span class="s3">\n            </span><span class="s1">// polyfill when being run by an older Babel version</span><span class="s3">\n            </span><span class="s1">path.ensureFunctionName ??=</span><span class="s3">\n              </span><span class="s1">// eslint-disable-next-line no-restricted-globals</span><span class="s3">\n              </span><span class="s1">require(</span><span class="s3">\&quot;</span><span class="s1">@babel/traverse</span><span class="s3">\&quot;</span><span class="s1">).NodePath.prototype.ensureFunctionName;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">path.ensureFunctionName(supportUnicodeId);</span><span class="s3">\n          </span><span class="s1">let wrapped;</span><span class="s3">\n          </span><span class="s1">if (node !== path.node) {</span><span class="s3">\n            </span><span class="s1">wrapped = path.node;</span><span class="s3">\n            </span><span class="s1">// The node has been wrapped. Reset it to the original once, but store the wrapper.</span><span class="s3">\n            </span><span class="s1">path.replaceWith(node);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">pushMethod(node, wrapped);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function pushDescriptors() {</span><span class="s3">\n    </span><span class="s1">pushInheritsToBody();</span><span class="s3">\n\n    </span><span class="s1">const { body } = classState;</span><span class="s3">\n\n    </span><span class="s1">const props: PropertyInfo = {</span><span class="s3">\n      </span><span class="s1">instance: null,</span><span class="s3">\n      </span><span class="s1">static: null,</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n\n    </span><span class="s1">for (const placement of [</span><span class="s3">\&quot;</span><span class="s1">static</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">instance</span><span class="s3">\&quot;</span><span class="s1">] as const) {</span><span class="s3">\n      </span><span class="s1">if (classState.methods[placement].list.length) {</span><span class="s3">\n        </span><span class="s1">props[placement] = classState.methods[placement].list.map(desc =&gt; {</span><span class="s3">\n          </span><span class="s1">const obj = t.objectExpression([</span><span class="s3">\n            </span><span class="s1">t.objectProperty(t.identifier(</span><span class="s3">\&quot;</span><span class="s1">key</span><span class="s3">\&quot;</span><span class="s1">), desc.key),</span><span class="s3">\n          </span><span class="s1">]);</span><span class="s3">\n\n          </span><span class="s1">for (const kind of [</span><span class="s3">\&quot;</span><span class="s1">get</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">set</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">] as const) {</span><span class="s3">\n            </span><span class="s1">if (desc[kind] != null) {</span><span class="s3">\n              </span><span class="s1">obj.properties.push(</span><span class="s3">\n                </span><span class="s1">t.objectProperty(t.identifier(kind), desc[kind]),</span><span class="s3">\n              </span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">return obj;</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (props.instance || props.static) {</span><span class="s3">\n      </span><span class="s1">let args = [</span><span class="s3">\n        </span><span class="s1">t.cloneNode(classState.classRef), // Constructor</span><span class="s3">\n        </span><span class="s1">props.instance ? t.arrayExpression(props.instance) : t.nullLiteral(), // instanceDescriptors</span><span class="s3">\n        </span><span class="s1">props.static ? t.arrayExpression(props.static) : t.nullLiteral(), // staticDescriptors</span><span class="s3">\n      </span><span class="s1">];</span><span class="s3">\n\n      </span><span class="s1">let lastNonNullIndex = 0;</span><span class="s3">\n      </span><span class="s1">for (let i = 0; i &lt; args.length; i++) {</span><span class="s3">\n        </span><span class="s1">if (!t.isNullLiteral(args[i])) lastNonNullIndex = i;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">args = args.slice(0, lastNonNullIndex + 1);</span><span class="s3">\n\n      </span><span class="s1">body.push(t.returnStatement(createClassHelper(args)));</span><span class="s3">\n      </span><span class="s1">classState.pushedCreateClass = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function wrapSuperCall(</span><span class="s3">\n    </span><span class="s1">bareSuper: NodePath&lt;t.CallExpression&gt;,</span><span class="s3">\n    </span><span class="s1">superRef: t.Expression,</span><span class="s3">\n    </span><span class="s1">thisRef: () =&gt; t.Identifier,</span><span class="s3">\n    </span><span class="s1">body: NodePath&lt;t.BlockStatement&gt;,</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">const bareSuperNode = bareSuper.node;</span><span class="s3">\n    </span><span class="s1">let call;</span><span class="s3">\n\n    </span><span class="s1">if (assumptions.superIsCallableConstructor) {</span><span class="s3">\n      </span><span class="s1">bareSuperNode.arguments.unshift(t.thisExpression());</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">bareSuperNode.arguments.length === 2 &amp;&amp;</span><span class="s3">\n        </span><span class="s1">t.isSpreadElement(bareSuperNode.arguments[1]) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">t.isIdentifier(bareSuperNode.arguments[1].argument, {</span><span class="s3">\n          </span><span class="s1">name: </span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">// special case single arguments spread</span><span class="s3">\n        </span><span class="s1">bareSuperNode.arguments[1] = bareSuperNode.arguments[1].argument;</span><span class="s3">\n        </span><span class="s1">bareSuperNode.callee = t.memberExpression(</span><span class="s3">\n          </span><span class="s1">t.cloneNode(superRef),</span><span class="s3">\n          </span><span class="s1">t.identifier(</span><span class="s3">\&quot;</span><span class="s1">apply</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">bareSuperNode.callee = t.memberExpression(</span><span class="s3">\n          </span><span class="s1">t.cloneNode(superRef),</span><span class="s3">\n          </span><span class="s1">t.identifier(</span><span class="s3">\&quot;</span><span class="s1">call</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">call = t.logicalExpression(</span><span class="s3">\&quot;</span><span class="s1">||</span><span class="s3">\&quot;</span><span class="s1">, bareSuperNode, t.thisExpression());</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">const args: t.Expression[] = [</span><span class="s3">\n        </span><span class="s1">t.thisExpression(),</span><span class="s3">\n        </span><span class="s1">t.cloneNode(classState.classRef),</span><span class="s3">\n      </span><span class="s1">];</span><span class="s3">\n      </span><span class="s1">if (bareSuperNode.arguments?.length) {</span><span class="s3">\n        </span><span class="s1">const bareSuperNodeArguments = bareSuperNode.arguments as (</span><span class="s3">\n          </span><span class="s1">| t.Expression</span><span class="s3">\n          </span><span class="s1">| t.SpreadElement</span><span class="s3">\n        </span><span class="s1">)[];</span><span class="s3">\n\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* test262/test/language/expressions/super/call-spread-err-sngl-err-itr-get-get.js</span><span class="s3">\n         </span><span class="s1">*</span><span class="s3">\n         </span><span class="s1">* var iter = {};</span><span class="s3">\n         </span><span class="s1">* Object.defineProperty(iter, Symbol.iterator, {</span><span class="s3">\n         </span><span class="s1">*   get: function() {</span><span class="s3">\n         </span><span class="s1">*     throw new Test262Error();</span><span class="s3">\n         </span><span class="s1">*   }</span><span class="s3">\n         </span><span class="s1">* })</span><span class="s3">\n         </span><span class="s1">* super(...iter);</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n\n        </span><span class="s1">if (</span><span class="s3">\n          </span><span class="s1">bareSuperNodeArguments.length === 1 &amp;&amp;</span><span class="s3">\n          </span><span class="s1">t.isSpreadElement(bareSuperNodeArguments[0]) &amp;&amp;</span><span class="s3">\n          </span><span class="s1">t.isIdentifier(bareSuperNodeArguments[0].argument, {</span><span class="s3">\n            </span><span class="s1">name: </span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n          </span><span class="s1">})</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">args.push(bareSuperNodeArguments[0].argument);</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">args.push(t.arrayExpression(bareSuperNodeArguments));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">call = t.callExpression(addCallSuperHelper(classState.file), args);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">bareSuper.parentPath.isExpressionStatement() &amp;&amp;</span><span class="s3">\n      </span><span class="s1">bareSuper.parentPath.container === body.node.body &amp;&amp;</span><span class="s3">\n      </span><span class="s1">body.node.body.length - 1 === bareSuper.parentPath.key</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">// this super call is the last statement in the body so we can just straight up</span><span class="s3">\n      </span><span class="s1">// turn it into a return</span><span class="s3">\n\n      </span><span class="s1">if (classState.superThises.length) {</span><span class="s3">\n        </span><span class="s1">call = t.assignmentExpression(</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">, thisRef(), call);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">bareSuper.parentPath.replaceWith(t.returnStatement(call));</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">bareSuper.replaceWith(t.assignmentExpression(</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">, thisRef(), call));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function verifyConstructor() {</span><span class="s3">\n    </span><span class="s1">if (!classState.isDerived) return;</span><span class="s3">\n\n    </span><span class="s1">const path = classState.userConstructorPath;</span><span class="s3">\n    </span><span class="s1">const body = path.get(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n    </span><span class="s1">const constructorBody = path.get(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n    </span><span class="s1">let maxGuaranteedSuperBeforeIndex = constructorBody.node.body.length;</span><span class="s3">\n\n    </span><span class="s1">path.traverse(findThisesVisitor);</span><span class="s3">\n\n    </span><span class="s1">let thisRef = function () {</span><span class="s3">\n      </span><span class="s1">const ref = path.scope.generateDeclaredUidIdentifier(</span><span class="s3">\&quot;</span><span class="s1">this</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">maxGuaranteedSuperBeforeIndex++;</span><span class="s3">\n      </span><span class="s1">thisRef = () =&gt; t.cloneNode(ref);</span><span class="s3">\n      </span><span class="s1">return ref;</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n\n    </span><span class="s1">const buildAssertThisInitialized = function () {</span><span class="s3">\n      </span><span class="s1">return t.callExpression(</span><span class="s3">\n        </span><span class="s1">classState.file.addHelper(</span><span class="s3">\&quot;</span><span class="s1">assertThisInitialized</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">[thisRef()],</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n\n    </span><span class="s1">const bareSupers: NodePath&lt;t.CallExpression&gt;[] = [];</span><span class="s3">\n    </span><span class="s1">path.traverse(</span><span class="s3">\n      </span><span class="s1">visitors.environmentVisitor({</span><span class="s3">\n        </span><span class="s1">Super(path) {</span><span class="s3">\n          </span><span class="s1">const { node, parentPath } = path;</span><span class="s3">\n          </span><span class="s1">if (parentPath.isCallExpression({ callee: node })) {</span><span class="s3">\n            </span><span class="s1">bareSupers.unshift(parentPath);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">}),</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n\n    </span><span class="s1">for (const bareSuper of bareSupers) {</span><span class="s3">\n      </span><span class="s1">wrapSuperCall(bareSuper, classState.superName, thisRef, body);</span><span class="s3">\n\n      </span><span class="s1">if (maxGuaranteedSuperBeforeIndex &gt;= 0) {</span><span class="s3">\n        </span><span class="s1">let lastParentPath: NodePath;</span><span class="s3">\n        </span><span class="s1">bareSuper.find(function (parentPath) {</span><span class="s3">\n          </span><span class="s1">// hit top so short circuit</span><span class="s3">\n          </span><span class="s1">if (parentPath === constructorBody) {</span><span class="s3">\n            </span><span class="s1">maxGuaranteedSuperBeforeIndex = Math.min(</span><span class="s3">\n              </span><span class="s1">maxGuaranteedSuperBeforeIndex,</span><span class="s3">\n              </span><span class="s1">lastParentPath.key as number,</span><span class="s3">\n            </span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">const { type } = parentPath;</span><span class="s3">\n          </span><span class="s1">switch (type) {</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ExpressionStatement</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">SequenceExpression</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">AssignmentExpression</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">BinaryExpression</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">MemberExpression</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">CallExpression</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">NewExpression</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">VariableDeclarator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">VariableDeclaration</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">BlockStatement</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ArrayExpression</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ObjectExpression</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ObjectProperty</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">TemplateLiteral</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n              </span><span class="s1">lastParentPath = parentPath;</span><span class="s3">\n              </span><span class="s1">return false;</span><span class="s3">\n            </span><span class="s1">default:</span><span class="s3">\n              </span><span class="s1">if (</span><span class="s3">\n                </span><span class="s1">(type === </span><span class="s3">\&quot;</span><span class="s1">LogicalExpression</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n                  </span><span class="s1">parentPath.node.left === lastParentPath.node) ||</span><span class="s3">\n                </span><span class="s1">(parentPath.isConditional() &amp;&amp;</span><span class="s3">\n                  </span><span class="s1">parentPath.node.test === lastParentPath.node) ||</span><span class="s3">\n                </span><span class="s1">(type === </span><span class="s3">\&quot;</span><span class="s1">OptionalCallExpression</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n                  </span><span class="s1">parentPath.node.callee === lastParentPath.node) ||</span><span class="s3">\n                </span><span class="s1">(type === </span><span class="s3">\&quot;</span><span class="s1">OptionalMemberExpression</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n                  </span><span class="s1">parentPath.node.object === lastParentPath.node)</span><span class="s3">\n              </span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">lastParentPath = parentPath;</span><span class="s3">\n                </span><span class="s1">return false;</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">maxGuaranteedSuperBeforeIndex = -1;</span><span class="s3">\n          </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const guaranteedCalls = new Set&lt;NodePath&gt;();</span><span class="s3">\n\n    </span><span class="s1">for (const thisPath of classState.superThises) {</span><span class="s3">\n      </span><span class="s1">const { node, parentPath } = thisPath;</span><span class="s3">\n      </span><span class="s1">if (parentPath.isMemberExpression({ object: node })) {</span><span class="s3">\n        </span><span class="s1">thisPath.replaceWith(thisRef());</span><span class="s3">\n        </span><span class="s1">continue;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">let thisIndex: number;</span><span class="s3">\n      </span><span class="s1">thisPath.find(function (parentPath) {</span><span class="s3">\n        </span><span class="s1">if (parentPath.parentPath === constructorBody) {</span><span class="s3">\n          </span><span class="s1">thisIndex = parentPath.key as number;</span><span class="s3">\n          </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n\n      </span><span class="s1">let exprPath: NodePath = thisPath.parentPath.isSequenceExpression()</span><span class="s3">\n        </span><span class="s1">? thisPath.parentPath</span><span class="s3">\n        </span><span class="s1">: thisPath;</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">exprPath.listKey === </span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n        </span><span class="s1">(exprPath.parentPath.isCallExpression() ||</span><span class="s3">\n          </span><span class="s1">exprPath.parentPath.isOptionalCallExpression())</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">exprPath = exprPath.parentPath;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">exprPath = null;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">(maxGuaranteedSuperBeforeIndex !== -1 &amp;&amp;</span><span class="s3">\n          </span><span class="s1">thisIndex &gt; maxGuaranteedSuperBeforeIndex) ||</span><span class="s3">\n        </span><span class="s1">guaranteedCalls.has(exprPath)</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">thisPath.replaceWith(thisRef());</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">if (exprPath) {</span><span class="s3">\n          </span><span class="s1">guaranteedCalls.add(exprPath);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">thisPath.replaceWith(buildAssertThisInitialized());</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">let wrapReturn;</span><span class="s3">\n\n    </span><span class="s1">if (classState.isLoose) {</span><span class="s3">\n      </span><span class="s1">wrapReturn = (returnArg: t.Expression | void) =&gt; {</span><span class="s3">\n        </span><span class="s1">const thisExpr = buildAssertThisInitialized();</span><span class="s3">\n        </span><span class="s1">return returnArg</span><span class="s3">\n          </span><span class="s1">? t.logicalExpression(</span><span class="s3">\&quot;</span><span class="s1">||</span><span class="s3">\&quot;</span><span class="s1">, returnArg, thisExpr)</span><span class="s3">\n          </span><span class="s1">: thisExpr;</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">wrapReturn = (returnArg: t.Expression | undefined) =&gt; {</span><span class="s3">\n        </span><span class="s1">const returnParams: t.Expression[] = [thisRef()];</span><span class="s3">\n        </span><span class="s1">if (returnArg != null) {</span><span class="s3">\n          </span><span class="s1">returnParams.push(returnArg);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return t.callExpression(</span><span class="s3">\n          </span><span class="s1">classState.file.addHelper(</span><span class="s3">\&quot;</span><span class="s1">possibleConstructorReturn</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">returnParams,</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// if we have a return as the last node in the body then we've already caught that</span><span class="s3">\n    </span><span class="s1">// return</span><span class="s3">\n    </span><span class="s1">const bodyPaths = body.get(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">const guaranteedSuperBeforeFinish =</span><span class="s3">\n      </span><span class="s1">maxGuaranteedSuperBeforeIndex !== -1 &amp;&amp;</span><span class="s3">\n      </span><span class="s1">maxGuaranteedSuperBeforeIndex &lt; bodyPaths.length;</span><span class="s3">\n    </span><span class="s1">if (!bodyPaths.length || !bodyPaths.pop().isReturnStatement()) {</span><span class="s3">\n      </span><span class="s1">body.pushContainer(</span><span class="s3">\n        \&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">t.returnStatement(</span><span class="s3">\n          </span><span class="s1">guaranteedSuperBeforeFinish</span><span class="s3">\n            </span><span class="s1">? thisRef()</span><span class="s3">\n            </span><span class="s1">: buildAssertThisInitialized(),</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">for (const returnPath of classState.superReturns) {</span><span class="s3">\n      </span><span class="s1">returnPath</span><span class="s3">\n        </span><span class="s1">.get(</span><span class="s3">\&quot;</span><span class="s1">argument</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">.replaceWith(wrapReturn(returnPath.node.argument));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Push a method to its respective mutatorMap.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">function pushMethod(node: t.ClassMethod, wrapped?: t.Expression) {</span><span class="s3">\n    </span><span class="s1">if (node.kind === </span><span class="s3">\&quot;</span><span class="s1">method</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">if (processMethod(node)) return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const placement = node.static ? </span><span class="s3">\&quot;</span><span class="s1">static</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">instance</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">const methods = classState.methods[placement];</span><span class="s3">\n\n    </span><span class="s1">const descKey = node.kind === </span><span class="s3">\&quot;</span><span class="s1">method</span><span class="s3">\&quot; </span><span class="s1">? </span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot; </span><span class="s1">: node.kind;</span><span class="s3">\n    </span><span class="s1">const key =</span><span class="s3">\n      </span><span class="s1">t.isNumericLiteral(node.key) || t.isBigIntLiteral(node.key)</span><span class="s3">\n        </span><span class="s1">? t.stringLiteral(String(node.key.value))</span><span class="s3">\n        </span><span class="s1">: t.toComputedKey(node);</span><span class="s3">\n    </span><span class="s1">methods.hasComputed = !t.isStringLiteral(key);</span><span class="s3">\n\n    </span><span class="s1">const fn: t.Expression = wrapped ?? t.toExpression(node);</span><span class="s3">\n\n    </span><span class="s1">let descriptor: Descriptor;</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">!methods.hasComputed &amp;&amp;</span><span class="s3">\n      </span><span class="s1">methods.map.has((key as t.StringLiteral).value)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">descriptor = methods.map.get((key as t.StringLiteral).value);</span><span class="s3">\n      </span><span class="s1">descriptor[descKey] = fn;</span><span class="s3">\n\n      </span><span class="s1">if (descKey === </span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">descriptor.get = null;</span><span class="s3">\n        </span><span class="s1">descriptor.set = null;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">descriptor.value = null;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">descriptor = {</span><span class="s3">\n        </span><span class="s1">key:</span><span class="s3">\n          </span><span class="s1">// private name has been handled in class-properties transform</span><span class="s3">\n          </span><span class="s1">key as t.Expression,</span><span class="s3">\n        </span><span class="s1">[descKey]: fn,</span><span class="s3">\n      </span><span class="s1">} as Descriptor;</span><span class="s3">\n      </span><span class="s1">methods.list.push(descriptor);</span><span class="s3">\n\n      </span><span class="s1">if (!methods.hasComputed) {</span><span class="s3">\n        </span><span class="s1">methods.map.set((key as t.StringLiteral).value, descriptor);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function processMethod(node: t.ClassMethod) {</span><span class="s3">\n    </span><span class="s1">if (assumptions.setClassMethods &amp;&amp; !node.decorators) {</span><span class="s3">\n      </span><span class="s1">// use assignments instead of define properties for loose classes</span><span class="s3">\n      </span><span class="s1">let { classRef } = classState;</span><span class="s3">\n      </span><span class="s1">if (!node.static) {</span><span class="s3">\n        </span><span class="s1">insertProtoAliasOnce();</span><span class="s3">\n        </span><span class="s1">classRef = classState.protoAlias;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">const methodName = t.memberExpression(</span><span class="s3">\n        </span><span class="s1">t.cloneNode(classRef),</span><span class="s3">\n        </span><span class="s1">node.key,</span><span class="s3">\n        </span><span class="s1">node.computed || t.isLiteral(node.key),</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n\n      </span><span class="s1">const func: t.Expression = t.functionExpression(</span><span class="s3">\n        </span><span class="s1">// @ts-expect-error We actually set and id through .ensureFunctionName</span><span class="s3">\n        </span><span class="s1">node.id,</span><span class="s3">\n        </span><span class="s1">// @ts-expect-error Fixme: should throw when we see TSParameterProperty</span><span class="s3">\n        </span><span class="s1">node.params,</span><span class="s3">\n        </span><span class="s1">node.body,</span><span class="s3">\n        </span><span class="s1">node.generator,</span><span class="s3">\n        </span><span class="s1">node.async,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">t.inherits(func, node);</span><span class="s3">\n\n      </span><span class="s1">const expr = t.expressionStatement(</span><span class="s3">\n        </span><span class="s1">t.assignmentExpression(</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">, methodName, func),</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">t.inheritsComments(expr, node);</span><span class="s3">\n      </span><span class="s1">classState.body.push(expr);</span><span class="s3">\n      </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function insertProtoAliasOnce() {</span><span class="s3">\n    </span><span class="s1">if (classState.protoAlias === null) {</span><span class="s3">\n      </span><span class="s1">setState({ protoAlias: classState.scope.generateUidIdentifier(</span><span class="s3">\&quot;</span><span class="s1">proto</span><span class="s3">\&quot;</span><span class="s1">) });</span><span class="s3">\n      </span><span class="s1">const classProto = t.memberExpression(</span><span class="s3">\n        </span><span class="s1">classState.classRef,</span><span class="s3">\n        </span><span class="s1">t.identifier(</span><span class="s3">\&quot;</span><span class="s1">prototype</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">const protoDeclaration = t.variableDeclaration(</span><span class="s3">\&quot;</span><span class="s1">var</span><span class="s3">\&quot;</span><span class="s1">, [</span><span class="s3">\n        </span><span class="s1">t.variableDeclarator(classState.protoAlias, classProto),</span><span class="s3">\n      </span><span class="s1">]);</span><span class="s3">\n\n      </span><span class="s1">classState.body.push(protoDeclaration);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Replace the constructor body of our class.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">function pushConstructor(</span><span class="s3">\n    </span><span class="s1">superReturns: NodePath&lt;t.ReturnStatement&gt;[],</span><span class="s3">\n    </span><span class="s1">method: ClassConstructor,</span><span class="s3">\n    </span><span class="s1">path: NodePath&lt;ClassConstructor&gt;,</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">setState({</span><span class="s3">\n      </span><span class="s1">userConstructorPath: path,</span><span class="s3">\n      </span><span class="s1">userConstructor: method,</span><span class="s3">\n      </span><span class="s1">hasConstructor: true,</span><span class="s3">\n      </span><span class="s1">superReturns,</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n\n    </span><span class="s1">const { construct } = classState;</span><span class="s3">\n\n    </span><span class="s1">t.inheritsComments(construct, method);</span><span class="s3">\n\n    </span><span class="s1">// @ts-expect-error Fixme: should throw when we see TSParameterProperty</span><span class="s3">\n    </span><span class="s1">construct.params = method.params;</span><span class="s3">\n\n    </span><span class="s1">t.inherits(construct.body, method.body);</span><span class="s3">\n    </span><span class="s1">construct.body.directives = method.body.directives;</span><span class="s3">\n\n    </span><span class="s1">// we haven't pushed any descriptors yet</span><span class="s3">\n    </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts) maybe remove this block - properties from condition are not used anywhere else</span><span class="s3">\n    </span><span class="s1">if (classState.hasInstanceDescriptors || classState.hasStaticDescriptors) {</span><span class="s3">\n      </span><span class="s1">pushDescriptors();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">pushInheritsToBody();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Push inherits helper to body.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">function pushInheritsToBody() {</span><span class="s3">\n    </span><span class="s1">if (!classState.isDerived || classState.pushedInherits) return;</span><span class="s3">\n\n    </span><span class="s1">classState.pushedInherits = true;</span><span class="s3">\n\n    </span><span class="s1">// Unshift to ensure that the constructor inheritance is set up before</span><span class="s3">\n    </span><span class="s1">// any properties can be assigned to the prototype.</span><span class="s3">\n\n    </span><span class="s1">classState.body.unshift(</span><span class="s3">\n      </span><span class="s1">t.expressionStatement(</span><span class="s3">\n        </span><span class="s1">t.callExpression(</span><span class="s3">\n          </span><span class="s1">classState.file.addHelper(</span><span class="s3">\n            </span><span class="s1">classState.isLoose ? </span><span class="s3">\&quot;</span><span class="s1">inheritsLoose</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">inherits</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">[t.cloneNode(classState.classRef), t.cloneNode(classState.superName)],</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function extractDynamicKeys() {</span><span class="s3">\n    </span><span class="s1">const { dynamicKeys, node, scope } = classState;</span><span class="s3">\n\n    </span><span class="s1">for (const elem of node.body.body) {</span><span class="s3">\n      </span><span class="s1">if (!t.isClassMethod(elem) || !elem.computed) continue;</span><span class="s3">\n      </span><span class="s1">if (scope.isPure(elem.key, /* constants only*/ true)) continue;</span><span class="s3">\n\n      </span><span class="s1">const id = scope.generateUidIdentifierBasedOnNode(elem.key);</span><span class="s3">\n      </span><span class="s1">dynamicKeys.set(id.name, elem.key);</span><span class="s3">\n\n      </span><span class="s1">elem.key = id;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function setupClosureParamsArgs() {</span><span class="s3">\n    </span><span class="s1">const { superName, dynamicKeys } = classState;</span><span class="s3">\n    </span><span class="s1">const closureParams = [];</span><span class="s3">\n    </span><span class="s1">const closureArgs = [];</span><span class="s3">\n\n    </span><span class="s1">if (classState.isDerived) {</span><span class="s3">\n      </span><span class="s1">let arg = t.cloneNode(superName);</span><span class="s3">\n      </span><span class="s1">if (classState.extendsNative) {</span><span class="s3">\n        </span><span class="s1">arg = t.callExpression(classState.file.addHelper(</span><span class="s3">\&quot;</span><span class="s1">wrapNativeSuper</span><span class="s3">\&quot;</span><span class="s1">), [</span><span class="s3">\n          </span><span class="s1">arg,</span><span class="s3">\n        </span><span class="s1">]);</span><span class="s3">\n        </span><span class="s1">annotateAsPure(arg);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const param =</span><span class="s3">\n        </span><span class="s1">classState.scope.generateUidIdentifierBasedOnNode(superName);</span><span class="s3">\n\n      </span><span class="s1">closureParams.push(param);</span><span class="s3">\n      </span><span class="s1">closureArgs.push(arg);</span><span class="s3">\n\n      </span><span class="s1">setState({ superName: t.cloneNode(param) });</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">for (const [name, value] of dynamicKeys) {</span><span class="s3">\n      </span><span class="s1">closureParams.push(t.identifier(name));</span><span class="s3">\n      </span><span class="s1">closureArgs.push(value);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return { closureParams, closureArgs };</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function classTransformer(</span><span class="s3">\n    </span><span class="s1">path: NodePath&lt;t.Class&gt;,</span><span class="s3">\n    </span><span class="s1">file: File,</span><span class="s3">\n    </span><span class="s1">builtinClasses: ReadonlySet&lt;string&gt;,</span><span class="s3">\n    </span><span class="s1">isLoose: boolean,</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">setState({</span><span class="s3">\n      </span><span class="s1">parent: path.parent,</span><span class="s3">\n      </span><span class="s1">scope: path.scope,</span><span class="s3">\n      </span><span class="s1">node: path.node,</span><span class="s3">\n      </span><span class="s1">path,</span><span class="s3">\n      </span><span class="s1">file,</span><span class="s3">\n      </span><span class="s1">isLoose,</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n\n    </span><span class="s1">setState({</span><span class="s3">\n      </span><span class="s1">classId: classState.node.id,</span><span class="s3">\n      </span><span class="s1">// this is the name of the binding that will **always** reference the class we've constructed</span><span class="s3">\n      </span><span class="s1">classRef: classState.node.id</span><span class="s3">\n        </span><span class="s1">? t.identifier(classState.node.id.name)</span><span class="s3">\n        </span><span class="s1">: classState.scope.generateUidIdentifier(</span><span class="s3">\&quot;</span><span class="s1">class</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">superName: classState.node.superClass,</span><span class="s3">\n      </span><span class="s1">isDerived: !!classState.node.superClass,</span><span class="s3">\n      </span><span class="s1">constructorBody: t.blockStatement([]),</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n\n    </span><span class="s1">setState({</span><span class="s3">\n      </span><span class="s1">extendsNative:</span><span class="s3">\n        </span><span class="s1">t.isIdentifier(classState.superName) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">builtinClasses.has(classState.superName.name) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">!classState.scope.hasBinding(</span><span class="s3">\n          </span><span class="s1">classState.superName.name,</span><span class="s3">\n          </span><span class="s1">/* noGlobals */ true,</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n\n    </span><span class="s1">const { classRef, node, constructorBody } = classState;</span><span class="s3">\n\n    </span><span class="s1">setState({</span><span class="s3">\n      </span><span class="s1">construct: buildConstructor(classRef, constructorBody, node),</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n\n    </span><span class="s1">extractDynamicKeys();</span><span class="s3">\n\n    </span><span class="s1">const { body } = classState;</span><span class="s3">\n    </span><span class="s1">const { closureParams, closureArgs } = setupClosureParamsArgs();</span><span class="s3">\n\n    </span><span class="s1">buildBody();</span><span class="s3">\n\n    </span><span class="s1">// make sure this class isn't directly called (with A() instead new A())</span><span class="s3">\n    </span><span class="s1">if (!assumptions.noClassCalls) {</span><span class="s3">\n      </span><span class="s1">constructorBody.body.unshift(</span><span class="s3">\n        </span><span class="s1">t.expressionStatement(</span><span class="s3">\n          </span><span class="s1">t.callExpression(classState.file.addHelper(</span><span class="s3">\&quot;</span><span class="s1">classCallCheck</span><span class="s3">\&quot;</span><span class="s1">), [</span><span class="s3">\n            </span><span class="s1">t.thisExpression(),</span><span class="s3">\n            </span><span class="s1">t.cloneNode(classState.classRef),</span><span class="s3">\n          </span><span class="s1">]),</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const isStrict = path.isInStrictMode();</span><span class="s3">\n    </span><span class="s1">let constructorOnly = body.length === 0;</span><span class="s3">\n    </span><span class="s1">if (constructorOnly &amp;&amp; !isStrict) {</span><span class="s3">\n      </span><span class="s1">for (const param of classState.construct.params) {</span><span class="s3">\n        </span><span class="s1">// It's illegal to put a use strict directive into the body of a function</span><span class="s3">\n        </span><span class="s1">// with non-simple parameters for some reason. So, we have to use a strict</span><span class="s3">\n        </span><span class="s1">// wrapper function.</span><span class="s3">\n        </span><span class="s1">if (!t.isIdentifier(param)) {</span><span class="s3">\n          </span><span class="s1">constructorOnly = false;</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const directives = constructorOnly</span><span class="s3">\n      </span><span class="s1">? classState.construct.body.directives</span><span class="s3">\n      </span><span class="s1">: [];</span><span class="s3">\n    </span><span class="s1">if (!isStrict) {</span><span class="s3">\n      </span><span class="s1">directives.push(t.directive(t.directiveLiteral(</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">)));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (constructorOnly) {</span><span class="s3">\n      </span><span class="s1">// named class with only a constructor</span><span class="s3">\n      </span><span class="s1">const expr = t.toExpression(classState.construct);</span><span class="s3">\n      </span><span class="s1">return classState.isLoose ? expr : createClassHelper([expr]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (!classState.pushedCreateClass) {</span><span class="s3">\n      </span><span class="s1">body.push(</span><span class="s3">\n        </span><span class="s1">t.returnStatement(</span><span class="s3">\n          </span><span class="s1">classState.isLoose</span><span class="s3">\n            </span><span class="s1">? t.cloneNode(classState.classRef)</span><span class="s3">\n            </span><span class="s1">: createClassHelper([t.cloneNode(classState.classRef)]),</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">body.unshift(classState.construct);</span><span class="s3">\n\n    </span><span class="s1">const container = t.arrowFunctionExpression(</span><span class="s3">\n      </span><span class="s1">closureParams,</span><span class="s3">\n      </span><span class="s1">t.blockStatement(body, directives),</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">return t.callExpression(container, closureArgs);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return classTransformer(path, file, builtinClasses, isLoose);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[]}</span></pre>
</body>
</html>