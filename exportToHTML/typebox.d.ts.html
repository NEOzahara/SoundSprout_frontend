<html>
<head>
<title>typebox.d.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #5f826b; font-style: italic;}
.s5 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
typebox.d.ts</font>
</center></td></tr></table>
<pre><span class="s0">export </span><span class="s1">declare </span><span class="s0">const </span><span class="s1">Kind</span><span class="s2">: </span><span class="s1">unique symbol</span><span class="s2">;</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">const </span><span class="s1">Hint</span><span class="s2">: </span><span class="s1">unique symbol</span><span class="s2">;</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">const </span><span class="s1">Modifier</span><span class="s2">: </span><span class="s1">unique symbol</span><span class="s2">;</span>
<span class="s0">export </span><span class="s1">declare type TModifier </span><span class="s2">= </span><span class="s1">TReadonlyOptional</span><span class="s2">&lt;</span><span class="s1">TSchema</span><span class="s2">&gt; | </span><span class="s1">TOptional</span><span class="s2">&lt;</span><span class="s1">TSchema</span><span class="s2">&gt; | </span><span class="s1">TReadonly</span><span class="s2">&lt;</span><span class="s1">TSchema</span><span class="s2">&gt;;</span>
<span class="s0">export </span><span class="s1">declare type TReadonly</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s0">extends </span><span class="s1">TSchema</span><span class="s2">&gt; = </span><span class="s1">T </span><span class="s2">&amp; {</span>
    <span class="s2">[</span><span class="s1">Modifier</span><span class="s2">]: </span><span class="s3">'Readonly'</span><span class="s2">;</span>
<span class="s2">};</span>
<span class="s0">export </span><span class="s1">declare type TOptional</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s0">extends </span><span class="s1">TSchema</span><span class="s2">&gt; = </span><span class="s1">T </span><span class="s2">&amp; {</span>
    <span class="s2">[</span><span class="s1">Modifier</span><span class="s2">]: </span><span class="s3">'Optional'</span><span class="s2">;</span>
<span class="s2">};</span>
<span class="s0">export </span><span class="s1">declare type TReadonlyOptional</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s0">extends </span><span class="s1">TSchema</span><span class="s2">&gt; = </span><span class="s1">T </span><span class="s2">&amp; {</span>
    <span class="s2">[</span><span class="s1">Modifier</span><span class="s2">]: </span><span class="s3">'ReadonlyOptional'</span><span class="s2">;</span>
<span class="s2">};</span>
<span class="s0">export interface </span><span class="s1">SchemaOptions </span><span class="s2">{</span>
    <span class="s1">$schema</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s4">/** Id for this schema */</span>
    <span class="s1">$id</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s4">/** Title of this schema */</span>
    <span class="s1">title</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s4">/** Description of this schema */</span>
    <span class="s1">description</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s4">/** Default value for this schema */</span>
    <span class="s0">default</span><span class="s2">?: </span><span class="s1">any</span><span class="s2">;</span>
    <span class="s4">/** Example values matching this schema. */</span>
    <span class="s1">examples</span><span class="s2">?: </span><span class="s1">any</span><span class="s2">;</span>
    <span class="s2">[</span><span class="s1">prop</span><span class="s2">: </span><span class="s1">string</span><span class="s2">]: </span><span class="s1">any</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s0">export interface </span><span class="s1">TSchema </span><span class="s0">extends </span><span class="s1">SchemaOptions </span><span class="s2">{</span>
    <span class="s2">[</span><span class="s1">Kind</span><span class="s2">]: </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s2">[</span><span class="s1">Hint</span><span class="s2">]?: </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s2">[</span><span class="s1">Modifier</span><span class="s2">]?: </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s1">params</span><span class="s2">: </span><span class="s1">unknown</span><span class="s2">[];</span>
    <span class="s0">static</span><span class="s2">: </span><span class="s1">unknown</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s0">export </span><span class="s1">declare type TAnySchema </span><span class="s2">= </span><span class="s1">TSchema </span><span class="s2">| </span><span class="s1">TAny </span><span class="s2">| </span><span class="s1">TArray </span><span class="s2">| </span><span class="s1">TBoolean </span><span class="s2">| </span><span class="s1">TConstructor </span><span class="s2">| </span><span class="s1">TEnum </span><span class="s2">| </span><span class="s1">TFunction </span><span class="s2">| </span><span class="s1">TInteger </span><span class="s2">| </span><span class="s1">TLiteral </span><span class="s2">| </span><span class="s1">TNull </span><span class="s2">| </span><span class="s1">TNumber </span><span class="s2">| </span><span class="s1">TObject </span><span class="s2">| </span><span class="s1">TPromise </span><span class="s2">| </span><span class="s1">TRecord </span><span class="s2">| </span><span class="s1">TSelf </span><span class="s2">| </span><span class="s1">TRef </span><span class="s2">| </span><span class="s1">TString </span><span class="s2">| </span><span class="s1">TTuple </span><span class="s2">| </span><span class="s1">TUndefined </span><span class="s2">| </span><span class="s1">TUnion </span><span class="s2">| </span><span class="s1">TUint8Array </span><span class="s2">| </span><span class="s1">TUnknown </span><span class="s2">| </span><span class="s1">TVoid</span><span class="s2">;</span>
<span class="s0">export interface </span><span class="s1">NumericOptions </span><span class="s0">extends </span><span class="s1">SchemaOptions </span><span class="s2">{</span>
    <span class="s1">exclusiveMaximum</span><span class="s2">?: </span><span class="s1">number</span><span class="s2">;</span>
    <span class="s1">exclusiveMinimum</span><span class="s2">?: </span><span class="s1">number</span><span class="s2">;</span>
    <span class="s1">maximum</span><span class="s2">?: </span><span class="s1">number</span><span class="s2">;</span>
    <span class="s1">minimum</span><span class="s2">?: </span><span class="s1">number</span><span class="s2">;</span>
    <span class="s1">multipleOf</span><span class="s2">?: </span><span class="s1">number</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s0">export </span><span class="s1">declare type TNumeric </span><span class="s2">= </span><span class="s1">TInteger </span><span class="s2">| </span><span class="s1">TNumber</span><span class="s2">;</span>
<span class="s0">export interface </span><span class="s1">TAny </span><span class="s0">extends </span><span class="s1">TSchema </span><span class="s2">{</span>
    <span class="s2">[</span><span class="s1">Kind</span><span class="s2">]: </span><span class="s3">'Any'</span><span class="s2">;</span>
    <span class="s0">static</span><span class="s2">: </span><span class="s1">any</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s0">export interface </span><span class="s1">ArrayOptions </span><span class="s0">extends </span><span class="s1">SchemaOptions </span><span class="s2">{</span>
    <span class="s1">uniqueItems</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
    <span class="s1">minItems</span><span class="s2">?: </span><span class="s1">number</span><span class="s2">;</span>
    <span class="s1">maxItems</span><span class="s2">?: </span><span class="s1">number</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s0">export interface </span><span class="s1">TArray</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s0">extends </span><span class="s1">TSchema </span><span class="s2">= </span><span class="s1">TSchema</span><span class="s2">&gt; </span><span class="s0">extends </span><span class="s1">TSchema</span><span class="s2">, </span><span class="s1">ArrayOptions </span><span class="s2">{</span>
    <span class="s2">[</span><span class="s1">Kind</span><span class="s2">]: </span><span class="s3">'Array'</span><span class="s2">;</span>
    <span class="s0">static</span><span class="s2">: </span><span class="s1">Array</span><span class="s2">&lt;</span><span class="s1">Static</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">, </span><span class="s0">this</span><span class="s2">[</span><span class="s3">'params'</span><span class="s2">]&gt;&gt;;</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">'array'</span><span class="s2">;</span>
    <span class="s1">items</span><span class="s2">: </span><span class="s1">T</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s0">export interface </span><span class="s1">TBoolean </span><span class="s0">extends </span><span class="s1">TSchema </span><span class="s2">{</span>
    <span class="s2">[</span><span class="s1">Kind</span><span class="s2">]: </span><span class="s3">'Boolean'</span><span class="s2">;</span>
    <span class="s0">static</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">;</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">'boolean'</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s0">export </span><span class="s1">declare type TConstructorParameters</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s0">extends </span><span class="s1">TConstructor</span><span class="s2">&lt;</span><span class="s1">TSchema</span><span class="s2">[], </span><span class="s1">TSchema</span><span class="s2">&gt;&gt; = </span><span class="s1">TTuple</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">[</span><span class="s3">'parameters'</span><span class="s2">]&gt;;</span>
<span class="s0">export </span><span class="s1">declare type TInstanceType</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s0">extends </span><span class="s1">TConstructor</span><span class="s2">&lt;</span><span class="s1">TSchema</span><span class="s2">[], </span><span class="s1">TSchema</span><span class="s2">&gt;&gt; = </span><span class="s1">T</span><span class="s2">[</span><span class="s3">'returns'</span><span class="s2">];</span>
<span class="s0">export </span><span class="s1">declare type StaticContructorParameters</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s0">extends </span><span class="s1">readonly TSchema</span><span class="s2">[], </span><span class="s1">P </span><span class="s0">extends </span><span class="s1">unknown</span><span class="s2">[]&gt; = [</span><span class="s1">...</span><span class="s2">{</span>
    <span class="s2">[</span><span class="s1">K </span><span class="s0">in </span><span class="s1">keyof T</span><span class="s2">]: </span><span class="s1">T</span><span class="s2">[</span><span class="s1">K</span><span class="s2">] </span><span class="s0">extends </span><span class="s1">TSchema </span><span class="s2">? </span><span class="s1">Static</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">[</span><span class="s1">K</span><span class="s2">], </span><span class="s1">P</span><span class="s2">&gt; : </span><span class="s1">never</span><span class="s2">;</span>
<span class="s2">}];</span>
<span class="s0">export interface </span><span class="s1">TConstructor</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s0">extends </span><span class="s1">TSchema</span><span class="s2">[] = </span><span class="s1">TSchema</span><span class="s2">[], </span><span class="s1">U </span><span class="s0">extends </span><span class="s1">TSchema </span><span class="s2">= </span><span class="s1">TSchema</span><span class="s2">&gt; </span><span class="s0">extends </span><span class="s1">TSchema </span><span class="s2">{</span>
    <span class="s2">[</span><span class="s1">Kind</span><span class="s2">]: </span><span class="s3">'Constructor'</span><span class="s2">;</span>
    <span class="s0">static</span><span class="s2">: </span><span class="s0">new </span><span class="s2">(</span><span class="s1">...param</span><span class="s2">: </span><span class="s1">StaticContructorParameters</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">, </span><span class="s0">this</span><span class="s2">[</span><span class="s3">'params'</span><span class="s2">]&gt;) =&gt; </span><span class="s1">Static</span><span class="s2">&lt;</span><span class="s1">U</span><span class="s2">, </span><span class="s0">this</span><span class="s2">[</span><span class="s3">'params'</span><span class="s2">]&gt;;</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">'constructor'</span><span class="s2">;</span>
    <span class="s1">parameters</span><span class="s2">: </span><span class="s1">T</span><span class="s2">;</span>
    <span class="s1">returns</span><span class="s2">: </span><span class="s1">U</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s0">export interface </span><span class="s1">TEnumOption</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt; {</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">'number' </span><span class="s2">| </span><span class="s3">'string'</span><span class="s2">;</span>
    <span class="s0">const</span><span class="s2">: </span><span class="s1">T</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s0">export interface </span><span class="s1">TEnum</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s0">extends </span><span class="s1">Record</span><span class="s2">&lt;</span><span class="s1">string</span><span class="s2">, </span><span class="s1">string </span><span class="s2">| </span><span class="s1">number</span><span class="s2">&gt; = </span><span class="s1">Record</span><span class="s2">&lt;</span><span class="s1">string</span><span class="s2">, </span><span class="s1">string </span><span class="s2">| </span><span class="s1">number</span><span class="s2">&gt;&gt; </span><span class="s0">extends </span><span class="s1">TSchema </span><span class="s2">{</span>
    <span class="s2">[</span><span class="s1">Kind</span><span class="s2">]: </span><span class="s3">'Union'</span><span class="s2">;</span>
    <span class="s0">static</span><span class="s2">: </span><span class="s1">T</span><span class="s2">[</span><span class="s1">keyof T</span><span class="s2">];</span>
    <span class="s1">anyOf</span><span class="s2">: </span><span class="s1">TLiteral</span><span class="s2">&lt;</span><span class="s1">string </span><span class="s2">| </span><span class="s1">number</span><span class="s2">&gt;[];</span>
<span class="s2">}</span>
<span class="s0">export </span><span class="s1">declare type TParameters</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s0">extends </span><span class="s1">TFunction</span><span class="s2">&gt; = </span><span class="s1">TTuple</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">[</span><span class="s3">'parameters'</span><span class="s2">]&gt;;</span>
<span class="s0">export </span><span class="s1">declare type TReturnType</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s0">extends </span><span class="s1">TFunction</span><span class="s2">&gt; = </span><span class="s1">T</span><span class="s2">[</span><span class="s3">'returns'</span><span class="s2">];</span>
<span class="s0">export </span><span class="s1">declare type StaticFunctionParameters</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s0">extends </span><span class="s1">readonly TSchema</span><span class="s2">[], </span><span class="s1">P </span><span class="s0">extends </span><span class="s1">unknown</span><span class="s2">[]&gt; = [</span><span class="s1">...</span><span class="s2">{</span>
    <span class="s2">[</span><span class="s1">K </span><span class="s0">in </span><span class="s1">keyof T</span><span class="s2">]: </span><span class="s1">T</span><span class="s2">[</span><span class="s1">K</span><span class="s2">] </span><span class="s0">extends </span><span class="s1">TSchema </span><span class="s2">? </span><span class="s1">Static</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">[</span><span class="s1">K</span><span class="s2">], </span><span class="s1">P</span><span class="s2">&gt; : </span><span class="s1">never</span><span class="s2">;</span>
<span class="s2">}];</span>
<span class="s0">export interface </span><span class="s1">TFunction</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s0">extends </span><span class="s1">readonly TSchema</span><span class="s2">[] = </span><span class="s1">TSchema</span><span class="s2">[], </span><span class="s1">U </span><span class="s0">extends </span><span class="s1">TSchema </span><span class="s2">= </span><span class="s1">TSchema</span><span class="s2">&gt; </span><span class="s0">extends </span><span class="s1">TSchema </span><span class="s2">{</span>
    <span class="s2">[</span><span class="s1">Kind</span><span class="s2">]: </span><span class="s3">'Function'</span><span class="s2">;</span>
    <span class="s0">static</span><span class="s2">: (</span><span class="s1">...param</span><span class="s2">: </span><span class="s1">StaticFunctionParameters</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">, </span><span class="s0">this</span><span class="s2">[</span><span class="s3">'params'</span><span class="s2">]&gt;) =&gt; </span><span class="s1">Static</span><span class="s2">&lt;</span><span class="s1">U</span><span class="s2">, </span><span class="s0">this</span><span class="s2">[</span><span class="s3">'params'</span><span class="s2">]&gt;;</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">'function'</span><span class="s2">;</span>
    <span class="s1">parameters</span><span class="s2">: </span><span class="s1">T</span><span class="s2">;</span>
    <span class="s1">returns</span><span class="s2">: </span><span class="s1">U</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s0">export interface </span><span class="s1">TInteger </span><span class="s0">extends </span><span class="s1">TSchema</span><span class="s2">, </span><span class="s1">NumericOptions </span><span class="s2">{</span>
    <span class="s2">[</span><span class="s1">Kind</span><span class="s2">]: </span><span class="s3">'Integer'</span><span class="s2">;</span>
    <span class="s0">static</span><span class="s2">: </span><span class="s1">number</span><span class="s2">;</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">'integer'</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s0">export </span><span class="s1">declare type IntersectReduce</span><span class="s2">&lt;</span><span class="s1">I </span><span class="s0">extends </span><span class="s1">unknown</span><span class="s2">, </span><span class="s1">T </span><span class="s0">extends </span><span class="s1">readonly any</span><span class="s2">[]&gt; = </span><span class="s1">T </span><span class="s0">extends </span><span class="s2">[</span><span class="s1">infer A</span><span class="s2">, </span><span class="s1">...infer B</span><span class="s2">] ? </span><span class="s1">IntersectReduce</span><span class="s2">&lt;</span><span class="s1">I </span><span class="s2">&amp; </span><span class="s1">A</span><span class="s2">, </span><span class="s1">B</span><span class="s2">&gt; : </span><span class="s1">I </span><span class="s0">extends </span><span class="s1">object </span><span class="s2">? </span><span class="s1">I </span><span class="s2">: {};</span>
<span class="s0">export </span><span class="s1">declare type IntersectEvaluate</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s0">extends </span><span class="s1">readonly TSchema</span><span class="s2">[], </span><span class="s1">P </span><span class="s0">extends </span><span class="s1">unknown</span><span class="s2">[]&gt; = {</span>
    <span class="s2">[</span><span class="s1">K </span><span class="s0">in </span><span class="s1">keyof T</span><span class="s2">]: </span><span class="s1">T</span><span class="s2">[</span><span class="s1">K</span><span class="s2">] </span><span class="s0">extends </span><span class="s1">TSchema </span><span class="s2">? </span><span class="s1">Static</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">[</span><span class="s1">K</span><span class="s2">], </span><span class="s1">P</span><span class="s2">&gt; : </span><span class="s1">never</span><span class="s2">;</span>
<span class="s2">};</span>
<span class="s0">export </span><span class="s1">declare type IntersectProperties</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s0">extends </span><span class="s1">readonly TObject</span><span class="s2">[]&gt; = {</span>
    <span class="s2">[</span><span class="s1">K </span><span class="s0">in </span><span class="s1">keyof T</span><span class="s2">]: </span><span class="s1">T</span><span class="s2">[</span><span class="s1">K</span><span class="s2">] </span><span class="s0">extends </span><span class="s1">TObject</span><span class="s2">&lt;</span><span class="s1">infer P</span><span class="s2">&gt; ? </span><span class="s1">P </span><span class="s2">: {};</span>
<span class="s2">};</span>
<span class="s0">export interface </span><span class="s1">TIntersect</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s0">extends </span><span class="s1">TObject</span><span class="s2">[] = </span><span class="s1">TObject</span><span class="s2">[]&gt; </span><span class="s0">extends </span><span class="s1">TObject </span><span class="s2">{</span>
    <span class="s0">static</span><span class="s2">: </span><span class="s1">IntersectReduce</span><span class="s2">&lt;</span><span class="s1">unknown</span><span class="s2">, </span><span class="s1">IntersectEvaluate</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">, </span><span class="s0">this</span><span class="s2">[</span><span class="s3">'params'</span><span class="s2">]&gt;&gt;;</span>
    <span class="s1">properties</span><span class="s2">: </span><span class="s1">IntersectReduce</span><span class="s2">&lt;</span><span class="s1">unknown</span><span class="s2">, </span><span class="s1">IntersectProperties</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;&gt;;</span>
<span class="s2">}</span>
<span class="s0">export </span><span class="s1">declare type UnionToIntersect</span><span class="s2">&lt;</span><span class="s1">U</span><span class="s2">&gt; = (</span><span class="s1">U </span><span class="s0">extends </span><span class="s1">unknown </span><span class="s2">? (</span><span class="s1">arg</span><span class="s2">: </span><span class="s1">U</span><span class="s2">) =&gt; </span><span class="s5">0 </span><span class="s2">: </span><span class="s1">never</span><span class="s2">) </span><span class="s0">extends </span><span class="s2">(</span><span class="s1">arg</span><span class="s2">: </span><span class="s1">infer I</span><span class="s2">) =&gt; </span><span class="s5">0 </span><span class="s2">? </span><span class="s1">I </span><span class="s2">: </span><span class="s1">never</span><span class="s2">;</span>
<span class="s0">export </span><span class="s1">declare type UnionLast</span><span class="s2">&lt;</span><span class="s1">U</span><span class="s2">&gt; = </span><span class="s1">UnionToIntersect</span><span class="s2">&lt;</span><span class="s1">U </span><span class="s0">extends </span><span class="s1">unknown </span><span class="s2">? (</span><span class="s1">x</span><span class="s2">: </span><span class="s1">U</span><span class="s2">) =&gt; </span><span class="s5">0 </span><span class="s2">: </span><span class="s1">never</span><span class="s2">&gt; </span><span class="s0">extends </span><span class="s2">(</span><span class="s1">x</span><span class="s2">: </span><span class="s1">infer L</span><span class="s2">) =&gt; </span><span class="s5">0 </span><span class="s2">? </span><span class="s1">L </span><span class="s2">: </span><span class="s1">never</span><span class="s2">;</span>
<span class="s0">export </span><span class="s1">declare type UnionToTuple</span><span class="s2">&lt;</span><span class="s1">U</span><span class="s2">, </span><span class="s1">L </span><span class="s2">= </span><span class="s1">UnionLast</span><span class="s2">&lt;</span><span class="s1">U</span><span class="s2">&gt;&gt; = [</span><span class="s1">U</span><span class="s2">] </span><span class="s0">extends </span><span class="s2">[</span><span class="s1">never</span><span class="s2">] ? [] : [</span><span class="s1">...UnionToTuple</span><span class="s2">&lt;</span><span class="s1">Exclude</span><span class="s2">&lt;</span><span class="s1">U</span><span class="s2">, </span><span class="s1">L</span><span class="s2">&gt;&gt;, </span><span class="s1">L</span><span class="s2">];</span>
<span class="s0">export </span><span class="s1">declare type UnionStringLiteralToTuple</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt; = </span><span class="s1">T </span><span class="s0">extends </span><span class="s1">TUnion</span><span class="s2">&lt;</span><span class="s1">infer L</span><span class="s2">&gt; ? {</span>
    <span class="s2">[</span><span class="s1">I </span><span class="s0">in </span><span class="s1">keyof L</span><span class="s2">]: </span><span class="s1">L</span><span class="s2">[</span><span class="s1">I</span><span class="s2">] </span><span class="s0">extends </span><span class="s1">TLiteral</span><span class="s2">&lt;</span><span class="s1">infer C</span><span class="s2">&gt; ? </span><span class="s1">C </span><span class="s2">: </span><span class="s1">never</span><span class="s2">;</span>
<span class="s2">} : </span><span class="s1">never</span><span class="s2">;</span>
<span class="s0">export </span><span class="s1">declare type UnionLiteralsFromObject</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s0">extends </span><span class="s1">TObject</span><span class="s2">&gt; = {</span>
    <span class="s2">[</span><span class="s1">K </span><span class="s0">in </span><span class="s1">ObjectPropertyKeys</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;]: </span><span class="s1">TLiteral</span><span class="s2">&lt;</span><span class="s1">K</span><span class="s2">&gt;;</span>
<span class="s2">} </span><span class="s0">extends </span><span class="s1">infer R </span><span class="s2">? </span><span class="s1">UnionToTuple</span><span class="s2">&lt;</span><span class="s1">R</span><span class="s2">[</span><span class="s1">keyof R</span><span class="s2">]&gt; : </span><span class="s1">never</span><span class="s2">;</span>
<span class="s0">export interface </span><span class="s1">TKeyOf</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s0">extends </span><span class="s1">TObject</span><span class="s2">&gt; </span><span class="s0">extends </span><span class="s1">TUnion</span><span class="s2">&lt;</span><span class="s1">UnionLiteralsFromObject</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;&gt; {</span>
<span class="s2">}</span>
<span class="s0">export </span><span class="s1">declare type TLiteralValue </span><span class="s2">= </span><span class="s1">string </span><span class="s2">| </span><span class="s1">number </span><span class="s2">| </span><span class="s1">boolean</span><span class="s2">;</span>
<span class="s0">export interface </span><span class="s1">TLiteral</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s0">extends </span><span class="s1">TLiteralValue </span><span class="s2">= </span><span class="s1">TLiteralValue</span><span class="s2">&gt; </span><span class="s0">extends </span><span class="s1">TSchema </span><span class="s2">{</span>
    <span class="s2">[</span><span class="s1">Kind</span><span class="s2">]: </span><span class="s3">'Literal'</span><span class="s2">;</span>
    <span class="s0">static</span><span class="s2">: </span><span class="s1">T</span><span class="s2">;</span>
    <span class="s0">const</span><span class="s2">: </span><span class="s1">T</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s0">export interface </span><span class="s1">TNever </span><span class="s0">extends </span><span class="s1">TSchema </span><span class="s2">{</span>
    <span class="s2">[</span><span class="s1">Kind</span><span class="s2">]: </span><span class="s3">'Never'</span><span class="s2">;</span>
    <span class="s0">static</span><span class="s2">: </span><span class="s1">never</span><span class="s2">;</span>
    <span class="s1">allOf</span><span class="s2">: [{</span>
        <span class="s1">type</span><span class="s2">: </span><span class="s3">'boolean'</span><span class="s2">;</span>
        <span class="s0">const</span><span class="s2">: </span><span class="s0">false</span><span class="s2">;</span>
    <span class="s2">}, {</span>
        <span class="s1">type</span><span class="s2">: </span><span class="s3">'boolean'</span><span class="s2">;</span>
        <span class="s0">const</span><span class="s2">: </span><span class="s0">true</span><span class="s2">;</span>
    <span class="s2">}];</span>
<span class="s2">}</span>
<span class="s0">export interface </span><span class="s1">TNull </span><span class="s0">extends </span><span class="s1">TSchema </span><span class="s2">{</span>
    <span class="s2">[</span><span class="s1">Kind</span><span class="s2">]: </span><span class="s3">'Null'</span><span class="s2">;</span>
    <span class="s0">static</span><span class="s2">: </span><span class="s0">null</span><span class="s2">;</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">'null'</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s0">export interface </span><span class="s1">TNumber </span><span class="s0">extends </span><span class="s1">TSchema</span><span class="s2">, </span><span class="s1">NumericOptions </span><span class="s2">{</span>
    <span class="s2">[</span><span class="s1">Kind</span><span class="s2">]: </span><span class="s3">'Number'</span><span class="s2">;</span>
    <span class="s0">static</span><span class="s2">: </span><span class="s1">number</span><span class="s2">;</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">'number'</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s0">export </span><span class="s1">declare type ReadonlyOptionalPropertyKeys</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s0">extends </span><span class="s1">TProperties</span><span class="s2">&gt; = {</span>
    <span class="s2">[</span><span class="s1">K </span><span class="s0">in </span><span class="s1">keyof T</span><span class="s2">]: </span><span class="s1">T</span><span class="s2">[</span><span class="s1">K</span><span class="s2">] </span><span class="s0">extends </span><span class="s1">TReadonlyOptional</span><span class="s2">&lt;</span><span class="s1">TSchema</span><span class="s2">&gt; ? </span><span class="s1">K </span><span class="s2">: </span><span class="s1">never</span><span class="s2">;</span>
<span class="s2">}[</span><span class="s1">keyof T</span><span class="s2">];</span>
<span class="s0">export </span><span class="s1">declare type ReadonlyPropertyKeys</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s0">extends </span><span class="s1">TProperties</span><span class="s2">&gt; = {</span>
    <span class="s2">[</span><span class="s1">K </span><span class="s0">in </span><span class="s1">keyof T</span><span class="s2">]: </span><span class="s1">T</span><span class="s2">[</span><span class="s1">K</span><span class="s2">] </span><span class="s0">extends </span><span class="s1">TReadonly</span><span class="s2">&lt;</span><span class="s1">TSchema</span><span class="s2">&gt; ? </span><span class="s1">K </span><span class="s2">: </span><span class="s1">never</span><span class="s2">;</span>
<span class="s2">}[</span><span class="s1">keyof T</span><span class="s2">];</span>
<span class="s0">export </span><span class="s1">declare type OptionalPropertyKeys</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s0">extends </span><span class="s1">TProperties</span><span class="s2">&gt; = {</span>
    <span class="s2">[</span><span class="s1">K </span><span class="s0">in </span><span class="s1">keyof T</span><span class="s2">]: </span><span class="s1">T</span><span class="s2">[</span><span class="s1">K</span><span class="s2">] </span><span class="s0">extends </span><span class="s1">TOptional</span><span class="s2">&lt;</span><span class="s1">TSchema</span><span class="s2">&gt; ? </span><span class="s1">K </span><span class="s2">: </span><span class="s1">never</span><span class="s2">;</span>
<span class="s2">}[</span><span class="s1">keyof T</span><span class="s2">];</span>
<span class="s0">export </span><span class="s1">declare type RequiredPropertyKeys</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s0">extends </span><span class="s1">TProperties</span><span class="s2">&gt; = </span><span class="s1">keyof Omit</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">, </span><span class="s1">ReadonlyOptionalPropertyKeys</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt; | </span><span class="s1">ReadonlyPropertyKeys</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt; | </span><span class="s1">OptionalPropertyKeys</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;&gt;;</span>
<span class="s0">export </span><span class="s1">declare type PropertiesReduce</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s0">extends </span><span class="s1">TProperties</span><span class="s2">, </span><span class="s1">P </span><span class="s0">extends </span><span class="s1">unknown</span><span class="s2">[]&gt; = {</span>
    <span class="s1">readonly </span><span class="s2">[</span><span class="s1">K </span><span class="s0">in </span><span class="s1">ReadonlyOptionalPropertyKeys</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;]?: </span><span class="s1">Static</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">[</span><span class="s1">K</span><span class="s2">], </span><span class="s1">P</span><span class="s2">&gt;;</span>
<span class="s2">} &amp; {</span>
    <span class="s1">readonly </span><span class="s2">[</span><span class="s1">K </span><span class="s0">in </span><span class="s1">ReadonlyPropertyKeys</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;]: </span><span class="s1">Static</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">[</span><span class="s1">K</span><span class="s2">], </span><span class="s1">P</span><span class="s2">&gt;;</span>
<span class="s2">} &amp; {</span>
    <span class="s2">[</span><span class="s1">K </span><span class="s0">in </span><span class="s1">OptionalPropertyKeys</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;]?: </span><span class="s1">Static</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">[</span><span class="s1">K</span><span class="s2">], </span><span class="s1">P</span><span class="s2">&gt;;</span>
<span class="s2">} &amp; {</span>
    <span class="s2">[</span><span class="s1">K </span><span class="s0">in </span><span class="s1">RequiredPropertyKeys</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;]: </span><span class="s1">Static</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">[</span><span class="s1">K</span><span class="s2">], </span><span class="s1">P</span><span class="s2">&gt;;</span>
<span class="s2">} </span><span class="s0">extends </span><span class="s1">infer R </span><span class="s2">? {</span>
    <span class="s2">[</span><span class="s1">K </span><span class="s0">in </span><span class="s1">keyof R</span><span class="s2">]: </span><span class="s1">R</span><span class="s2">[</span><span class="s1">K</span><span class="s2">];</span>
<span class="s2">} : </span><span class="s1">never</span><span class="s2">;</span>
<span class="s0">export </span><span class="s1">declare type TRecordProperties</span><span class="s2">&lt;</span><span class="s1">K </span><span class="s0">extends </span><span class="s1">TUnion</span><span class="s2">&lt;</span><span class="s1">TLiteral</span><span class="s2">[]&gt;, </span><span class="s1">T </span><span class="s0">extends </span><span class="s1">TSchema</span><span class="s2">&gt; = </span><span class="s1">Static</span><span class="s2">&lt;</span><span class="s1">K</span><span class="s2">&gt; </span><span class="s0">extends </span><span class="s1">string </span><span class="s2">? {</span>
    <span class="s2">[</span><span class="s1">X </span><span class="s0">in </span><span class="s1">Static</span><span class="s2">&lt;</span><span class="s1">K</span><span class="s2">&gt;]: </span><span class="s1">T</span><span class="s2">;</span>
<span class="s2">} : </span><span class="s1">never</span><span class="s2">;</span>
<span class="s0">export interface </span><span class="s1">TProperties </span><span class="s2">{</span>
    <span class="s2">[</span><span class="s1">key</span><span class="s2">: </span><span class="s1">string</span><span class="s2">]: </span><span class="s1">TSchema</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s0">export </span><span class="s1">declare type ObjectProperties</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt; = </span><span class="s1">T </span><span class="s0">extends </span><span class="s1">TObject</span><span class="s2">&lt;</span><span class="s1">infer U</span><span class="s2">&gt; ? </span><span class="s1">U </span><span class="s2">: </span><span class="s1">never</span><span class="s2">;</span>
<span class="s0">export </span><span class="s1">declare type ObjectPropertyKeys</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt; = </span><span class="s1">T </span><span class="s0">extends </span><span class="s1">TObject</span><span class="s2">&lt;</span><span class="s1">infer U</span><span class="s2">&gt; ? </span><span class="s1">keyof U </span><span class="s2">: </span><span class="s1">never</span><span class="s2">;</span>
<span class="s0">export </span><span class="s1">declare type TAdditionalProperties </span><span class="s2">= </span><span class="s1">undefined </span><span class="s2">| </span><span class="s1">TSchema </span><span class="s2">| </span><span class="s1">boolean</span><span class="s2">;</span>
<span class="s0">export interface </span><span class="s1">ObjectOptions </span><span class="s0">extends </span><span class="s1">SchemaOptions </span><span class="s2">{</span>
    <span class="s1">additionalProperties</span><span class="s2">?: </span><span class="s1">TAdditionalProperties</span><span class="s2">;</span>
    <span class="s1">minProperties</span><span class="s2">?: </span><span class="s1">number</span><span class="s2">;</span>
    <span class="s1">maxProperties</span><span class="s2">?: </span><span class="s1">number</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s0">export interface </span><span class="s1">TObject</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s0">extends </span><span class="s1">TProperties </span><span class="s2">= </span><span class="s1">TProperties</span><span class="s2">&gt; </span><span class="s0">extends </span><span class="s1">TSchema</span><span class="s2">, </span><span class="s1">ObjectOptions </span><span class="s2">{</span>
    <span class="s2">[</span><span class="s1">Kind</span><span class="s2">]: </span><span class="s3">'Object'</span><span class="s2">;</span>
    <span class="s0">static</span><span class="s2">: </span><span class="s1">PropertiesReduce</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">, </span><span class="s0">this</span><span class="s2">[</span><span class="s3">'params'</span><span class="s2">]&gt;;</span>
    <span class="s1">additionalProperties</span><span class="s2">?: </span><span class="s1">TAdditionalProperties</span><span class="s2">;</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">'object'</span><span class="s2">;</span>
    <span class="s1">properties</span><span class="s2">: </span><span class="s1">T</span><span class="s2">;</span>
    <span class="s1">required</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">[];</span>
<span class="s2">}</span>
<span class="s0">export interface </span><span class="s1">TOmit</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s0">extends </span><span class="s1">TObject</span><span class="s2">, </span><span class="s1">Properties </span><span class="s0">extends </span><span class="s1">ObjectPropertyKeys</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;[]&gt; </span><span class="s0">extends </span><span class="s1">TObject</span><span class="s2">, </span><span class="s1">ObjectOptions </span><span class="s2">{</span>
    <span class="s0">static</span><span class="s2">: </span><span class="s1">Omit</span><span class="s2">&lt;</span><span class="s1">Static</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">, </span><span class="s0">this</span><span class="s2">[</span><span class="s3">'params'</span><span class="s2">]&gt;, </span><span class="s1">Properties</span><span class="s2">[</span><span class="s1">number</span><span class="s2">]&gt;;</span>
    <span class="s1">properties</span><span class="s2">: </span><span class="s1">T </span><span class="s0">extends </span><span class="s1">TObject </span><span class="s2">? </span><span class="s1">Omit</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">[</span><span class="s3">'properties'</span><span class="s2">], </span><span class="s1">Properties</span><span class="s2">[</span><span class="s1">number</span><span class="s2">]&gt; : </span><span class="s1">never</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s0">export interface </span><span class="s1">TPartial</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s0">extends </span><span class="s1">TObject</span><span class="s2">&gt; </span><span class="s0">extends </span><span class="s1">TObject </span><span class="s2">{</span>
    <span class="s0">static</span><span class="s2">: </span><span class="s1">Partial</span><span class="s2">&lt;</span><span class="s1">Static</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">, </span><span class="s0">this</span><span class="s2">[</span><span class="s3">'params'</span><span class="s2">]&gt;&gt;;</span>
    <span class="s1">properties</span><span class="s2">: {</span>
        <span class="s2">[</span><span class="s1">K </span><span class="s0">in </span><span class="s1">keyof T</span><span class="s2">[</span><span class="s3">'properties'</span><span class="s2">]]: </span><span class="s1">T</span><span class="s2">[</span><span class="s3">'properties'</span><span class="s2">][</span><span class="s1">K</span><span class="s2">] </span><span class="s0">extends </span><span class="s1">TReadonlyOptional</span><span class="s2">&lt;</span><span class="s1">infer U</span><span class="s2">&gt; ? </span><span class="s1">TReadonlyOptional</span><span class="s2">&lt;</span><span class="s1">U</span><span class="s2">&gt; : </span><span class="s1">T</span><span class="s2">[</span><span class="s3">'properties'</span><span class="s2">][</span><span class="s1">K</span><span class="s2">] </span><span class="s0">extends </span><span class="s1">TReadonly</span><span class="s2">&lt;</span><span class="s1">infer U</span><span class="s2">&gt; ? </span><span class="s1">TReadonlyOptional</span><span class="s2">&lt;</span><span class="s1">U</span><span class="s2">&gt; : </span><span class="s1">T</span><span class="s2">[</span><span class="s3">'properties'</span><span class="s2">][</span><span class="s1">K</span><span class="s2">] </span><span class="s0">extends </span><span class="s1">TOptional</span><span class="s2">&lt;</span><span class="s1">infer U</span><span class="s2">&gt; ? </span><span class="s1">TOptional</span><span class="s2">&lt;</span><span class="s1">U</span><span class="s2">&gt; : </span><span class="s1">TOptional</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">[</span><span class="s3">'properties'</span><span class="s2">][</span><span class="s1">K</span><span class="s2">]&gt;;</span>
    <span class="s2">};</span>
<span class="s2">}</span>
<span class="s0">export </span><span class="s1">declare type TPick</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s0">extends </span><span class="s1">TObject</span><span class="s2">, </span><span class="s1">Properties </span><span class="s0">extends </span><span class="s1">ObjectPropertyKeys</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;[]&gt; = </span><span class="s1">TObject</span><span class="s2">&lt;{</span>
    <span class="s2">[</span><span class="s1">K </span><span class="s0">in </span><span class="s1">Properties</span><span class="s2">[</span><span class="s1">number</span><span class="s2">]]: </span><span class="s1">T</span><span class="s2">[</span><span class="s3">'properties'</span><span class="s2">][</span><span class="s1">K</span><span class="s2">];</span>
<span class="s2">}&gt;;</span>
<span class="s0">export interface </span><span class="s1">TPromise</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s0">extends </span><span class="s1">TSchema </span><span class="s2">= </span><span class="s1">TSchema</span><span class="s2">&gt; </span><span class="s0">extends </span><span class="s1">TSchema </span><span class="s2">{</span>
    <span class="s2">[</span><span class="s1">Kind</span><span class="s2">]: </span><span class="s3">'Promise'</span><span class="s2">;</span>
    <span class="s0">static</span><span class="s2">: </span><span class="s1">Promise</span><span class="s2">&lt;</span><span class="s1">Static</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">, </span><span class="s0">this</span><span class="s2">[</span><span class="s3">'params'</span><span class="s2">]&gt;&gt;;</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">'promise'</span><span class="s2">;</span>
    <span class="s1">item</span><span class="s2">: </span><span class="s1">TSchema</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s0">export </span><span class="s1">declare type TRecordKey </span><span class="s2">= </span><span class="s1">TString </span><span class="s2">| </span><span class="s1">TNumeric </span><span class="s2">| </span><span class="s1">TUnion</span><span class="s2">&lt;</span><span class="s1">TLiteral</span><span class="s2">&lt;</span><span class="s1">any</span><span class="s2">&gt;[]&gt;;</span>
<span class="s0">export interface </span><span class="s1">TRecord</span><span class="s2">&lt;</span><span class="s1">K </span><span class="s0">extends </span><span class="s1">TRecordKey </span><span class="s2">= </span><span class="s1">TRecordKey</span><span class="s2">, </span><span class="s1">T </span><span class="s0">extends </span><span class="s1">TSchema </span><span class="s2">= </span><span class="s1">TSchema</span><span class="s2">&gt; </span><span class="s0">extends </span><span class="s1">TSchema </span><span class="s2">{</span>
    <span class="s2">[</span><span class="s1">Kind</span><span class="s2">]: </span><span class="s3">'Record'</span><span class="s2">;</span>
    <span class="s0">static</span><span class="s2">: </span><span class="s1">Record</span><span class="s2">&lt;</span><span class="s1">Static</span><span class="s2">&lt;</span><span class="s1">K</span><span class="s2">&gt;, </span><span class="s1">Static</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">, </span><span class="s0">this</span><span class="s2">[</span><span class="s3">'params'</span><span class="s2">]&gt;&gt;;</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">'object'</span><span class="s2">;</span>
    <span class="s1">patternProperties</span><span class="s2">: {</span>
        <span class="s2">[</span><span class="s1">pattern</span><span class="s2">: </span><span class="s1">string</span><span class="s2">]: </span><span class="s1">T</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s1">additionalProperties</span><span class="s2">: </span><span class="s0">false</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s0">export interface </span><span class="s1">TSelf </span><span class="s0">extends </span><span class="s1">TSchema </span><span class="s2">{</span>
    <span class="s2">[</span><span class="s1">Kind</span><span class="s2">]: </span><span class="s3">'Self'</span><span class="s2">;</span>
    <span class="s0">static</span><span class="s2">: </span><span class="s0">this</span><span class="s2">[</span><span class="s3">'params'</span><span class="s2">][</span><span class="s5">0</span><span class="s2">];</span>
    <span class="s1">$ref</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s0">export </span><span class="s1">declare type TRecursiveReduce</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s0">extends </span><span class="s1">TSchema</span><span class="s2">&gt; = </span><span class="s1">Static</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">, [</span><span class="s1">TRecursiveReduce</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;]&gt;;</span>
<span class="s0">export interface </span><span class="s1">TRecursive</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s0">extends </span><span class="s1">TSchema</span><span class="s2">&gt; </span><span class="s0">extends </span><span class="s1">TSchema </span><span class="s2">{</span>
    <span class="s0">static</span><span class="s2">: </span><span class="s1">TRecursiveReduce</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;;</span>
<span class="s2">}</span>
<span class="s0">export interface </span><span class="s1">TRef</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s0">extends </span><span class="s1">TSchema </span><span class="s2">= </span><span class="s1">TSchema</span><span class="s2">&gt; </span><span class="s0">extends </span><span class="s1">TSchema </span><span class="s2">{</span>
    <span class="s2">[</span><span class="s1">Kind</span><span class="s2">]: </span><span class="s3">'Ref'</span><span class="s2">;</span>
    <span class="s0">static</span><span class="s2">: </span><span class="s1">Static</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">, </span><span class="s0">this</span><span class="s2">[</span><span class="s3">'params'</span><span class="s2">]&gt;;</span>
    <span class="s1">$ref</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s0">export interface </span><span class="s1">TRequired</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s0">extends </span><span class="s1">TObject </span><span class="s2">| </span><span class="s1">TRef</span><span class="s2">&lt;</span><span class="s1">TObject</span><span class="s2">&gt;&gt; </span><span class="s0">extends </span><span class="s1">TObject </span><span class="s2">{</span>
    <span class="s0">static</span><span class="s2">: </span><span class="s1">Required</span><span class="s2">&lt;</span><span class="s1">Static</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">, </span><span class="s0">this</span><span class="s2">[</span><span class="s3">'params'</span><span class="s2">]&gt;&gt;;</span>
    <span class="s1">properties</span><span class="s2">: {</span>
        <span class="s2">[</span><span class="s1">K </span><span class="s0">in </span><span class="s1">keyof T</span><span class="s2">[</span><span class="s3">'properties'</span><span class="s2">]]: </span><span class="s1">T</span><span class="s2">[</span><span class="s3">'properties'</span><span class="s2">][</span><span class="s1">K</span><span class="s2">] </span><span class="s0">extends </span><span class="s1">TReadonlyOptional</span><span class="s2">&lt;</span><span class="s1">infer U</span><span class="s2">&gt; ? </span><span class="s1">TReadonly</span><span class="s2">&lt;</span><span class="s1">U</span><span class="s2">&gt; : </span><span class="s1">T</span><span class="s2">[</span><span class="s3">'properties'</span><span class="s2">][</span><span class="s1">K</span><span class="s2">] </span><span class="s0">extends </span><span class="s1">TReadonly</span><span class="s2">&lt;</span><span class="s1">infer U</span><span class="s2">&gt; ? </span><span class="s1">TReadonly</span><span class="s2">&lt;</span><span class="s1">U</span><span class="s2">&gt; : </span><span class="s1">T</span><span class="s2">[</span><span class="s3">'properties'</span><span class="s2">][</span><span class="s1">K</span><span class="s2">] </span><span class="s0">extends </span><span class="s1">TOptional</span><span class="s2">&lt;</span><span class="s1">infer U</span><span class="s2">&gt; ? </span><span class="s1">U </span><span class="s2">: </span><span class="s1">T</span><span class="s2">[</span><span class="s3">'properties'</span><span class="s2">][</span><span class="s1">K</span><span class="s2">];</span>
    <span class="s2">};</span>
<span class="s2">}</span>
<span class="s0">export </span><span class="s1">declare type StringFormatOption </span><span class="s2">= </span><span class="s3">'date-time' </span><span class="s2">| </span><span class="s3">'time' </span><span class="s2">| </span><span class="s3">'date' </span><span class="s2">| </span><span class="s3">'email' </span><span class="s2">| </span><span class="s3">'idn-email' </span><span class="s2">| </span><span class="s3">'hostname' </span><span class="s2">| </span><span class="s3">'idn-hostname' </span><span class="s2">| </span><span class="s3">'ipv4' </span><span class="s2">| </span><span class="s3">'ipv6' </span><span class="s2">| </span><span class="s3">'uri' </span><span class="s2">| </span><span class="s3">'uri-reference' </span><span class="s2">| </span><span class="s3">'iri' </span><span class="s2">| </span><span class="s3">'uuid' </span><span class="s2">| </span><span class="s3">'iri-reference' </span><span class="s2">| </span><span class="s3">'uri-template' </span><span class="s2">| </span><span class="s3">'json-pointer' </span><span class="s2">| </span><span class="s3">'relative-json-pointer' </span><span class="s2">| </span><span class="s3">'regex'</span><span class="s2">;</span>
<span class="s0">export interface </span><span class="s1">StringOptions</span><span class="s2">&lt;</span><span class="s1">Format </span><span class="s0">extends </span><span class="s1">string</span><span class="s2">&gt; </span><span class="s0">extends </span><span class="s1">SchemaOptions </span><span class="s2">{</span>
    <span class="s1">minLength</span><span class="s2">?: </span><span class="s1">number</span><span class="s2">;</span>
    <span class="s1">maxLength</span><span class="s2">?: </span><span class="s1">number</span><span class="s2">;</span>
    <span class="s1">pattern</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s1">format</span><span class="s2">?: </span><span class="s1">Format</span><span class="s2">;</span>
    <span class="s1">contentEncoding</span><span class="s2">?: </span><span class="s3">'7bit' </span><span class="s2">| </span><span class="s3">'8bit' </span><span class="s2">| </span><span class="s3">'binary' </span><span class="s2">| </span><span class="s3">'quoted-printable' </span><span class="s2">| </span><span class="s3">'base64'</span><span class="s2">;</span>
    <span class="s1">contentMediaType</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s0">export interface </span><span class="s1">TString</span><span class="s2">&lt;</span><span class="s1">Format </span><span class="s0">extends </span><span class="s1">string </span><span class="s2">= </span><span class="s1">string</span><span class="s2">&gt; </span><span class="s0">extends </span><span class="s1">TSchema</span><span class="s2">, </span><span class="s1">StringOptions</span><span class="s2">&lt;</span><span class="s1">Format</span><span class="s2">&gt; {</span>
    <span class="s2">[</span><span class="s1">Kind</span><span class="s2">]: </span><span class="s3">'String'</span><span class="s2">;</span>
    <span class="s0">static</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">'string'</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s0">export </span><span class="s1">declare type TupleToArray</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s0">extends </span><span class="s1">TTuple</span><span class="s2">&lt;</span><span class="s1">TSchema</span><span class="s2">[]&gt;&gt; = </span><span class="s1">T </span><span class="s0">extends </span><span class="s1">TTuple</span><span class="s2">&lt;</span><span class="s1">infer R</span><span class="s2">&gt; ? </span><span class="s1">R </span><span class="s2">: </span><span class="s1">never</span><span class="s2">;</span>
<span class="s0">export interface </span><span class="s1">TTuple</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s0">extends </span><span class="s1">TSchema</span><span class="s2">[] = </span><span class="s1">TSchema</span><span class="s2">[]&gt; </span><span class="s0">extends </span><span class="s1">TSchema </span><span class="s2">{</span>
    <span class="s2">[</span><span class="s1">Kind</span><span class="s2">]: </span><span class="s3">'Tuple'</span><span class="s2">;</span>
    <span class="s0">static</span><span class="s2">: {</span>
        <span class="s2">[</span><span class="s1">K </span><span class="s0">in </span><span class="s1">keyof T</span><span class="s2">]: </span><span class="s1">T</span><span class="s2">[</span><span class="s1">K</span><span class="s2">] </span><span class="s0">extends </span><span class="s1">TSchema </span><span class="s2">? </span><span class="s1">Static</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">[</span><span class="s1">K</span><span class="s2">], </span><span class="s0">this</span><span class="s2">[</span><span class="s3">'params'</span><span class="s2">]&gt; : </span><span class="s1">T</span><span class="s2">[</span><span class="s1">K</span><span class="s2">];</span>
    <span class="s2">};</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">'array'</span><span class="s2">;</span>
    <span class="s1">items</span><span class="s2">?: </span><span class="s1">T</span><span class="s2">;</span>
    <span class="s1">additionalItems</span><span class="s2">?: </span><span class="s0">false</span><span class="s2">;</span>
    <span class="s1">minItems</span><span class="s2">: </span><span class="s1">number</span><span class="s2">;</span>
    <span class="s1">maxItems</span><span class="s2">: </span><span class="s1">number</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s0">export interface </span><span class="s1">TUndefined </span><span class="s0">extends </span><span class="s1">TSchema </span><span class="s2">{</span>
    <span class="s2">[</span><span class="s1">Kind</span><span class="s2">]: </span><span class="s3">'Undefined'</span><span class="s2">;</span>
    <span class="s1">specialized</span><span class="s2">: </span><span class="s3">'Undefined'</span><span class="s2">;</span>
    <span class="s0">static</span><span class="s2">: </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">'object'</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s0">export interface </span><span class="s1">TUnion</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s0">extends </span><span class="s1">TSchema</span><span class="s2">[] = </span><span class="s1">TSchema</span><span class="s2">[]&gt; </span><span class="s0">extends </span><span class="s1">TSchema </span><span class="s2">{</span>
    <span class="s2">[</span><span class="s1">Kind</span><span class="s2">]: </span><span class="s3">'Union'</span><span class="s2">;</span>
    <span class="s0">static</span><span class="s2">: {</span>
        <span class="s2">[</span><span class="s1">K </span><span class="s0">in </span><span class="s1">keyof T</span><span class="s2">]: </span><span class="s1">T</span><span class="s2">[</span><span class="s1">K</span><span class="s2">] </span><span class="s0">extends </span><span class="s1">TSchema </span><span class="s2">? </span><span class="s1">Static</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">[</span><span class="s1">K</span><span class="s2">], </span><span class="s0">this</span><span class="s2">[</span><span class="s3">'params'</span><span class="s2">]&gt; : </span><span class="s1">never</span><span class="s2">;</span>
    <span class="s2">}[</span><span class="s1">number</span><span class="s2">];</span>
    <span class="s1">anyOf</span><span class="s2">: </span><span class="s1">T</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s0">export interface </span><span class="s1">Uint8ArrayOptions </span><span class="s0">extends </span><span class="s1">SchemaOptions </span><span class="s2">{</span>
    <span class="s1">maxByteLength</span><span class="s2">?: </span><span class="s1">number</span><span class="s2">;</span>
    <span class="s1">minByteLength</span><span class="s2">?: </span><span class="s1">number</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s0">export interface </span><span class="s1">TUint8Array </span><span class="s0">extends </span><span class="s1">TSchema</span><span class="s2">, </span><span class="s1">Uint8ArrayOptions </span><span class="s2">{</span>
    <span class="s2">[</span><span class="s1">Kind</span><span class="s2">]: </span><span class="s3">'Uint8Array'</span><span class="s2">;</span>
    <span class="s0">static</span><span class="s2">: </span><span class="s1">Uint8Array</span><span class="s2">;</span>
    <span class="s1">specialized</span><span class="s2">: </span><span class="s3">'Uint8Array'</span><span class="s2">;</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">'object'</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s0">export interface </span><span class="s1">TUnknown </span><span class="s0">extends </span><span class="s1">TSchema </span><span class="s2">{</span>
    <span class="s2">[</span><span class="s1">Kind</span><span class="s2">]: </span><span class="s3">'Unknown'</span><span class="s2">;</span>
    <span class="s0">static</span><span class="s2">: </span><span class="s1">unknown</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s0">export interface </span><span class="s1">UnsafeOptions </span><span class="s0">extends </span><span class="s1">SchemaOptions </span><span class="s2">{</span>
    <span class="s2">[</span><span class="s1">Kind</span><span class="s2">]?: </span><span class="s1">string</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s0">export interface </span><span class="s1">TUnsafe</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt; </span><span class="s0">extends </span><span class="s1">TSchema </span><span class="s2">{</span>
    <span class="s2">[</span><span class="s1">Kind</span><span class="s2">]: </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s0">static</span><span class="s2">: </span><span class="s1">T</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s0">export interface </span><span class="s1">TVoid </span><span class="s0">extends </span><span class="s1">TSchema </span><span class="s2">{</span>
    <span class="s2">[</span><span class="s1">Kind</span><span class="s2">]: </span><span class="s3">'Void'</span><span class="s2">;</span>
    <span class="s0">static</span><span class="s2">: </span><span class="s0">void</span><span class="s2">;</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">'null'</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">/** Creates a static type from a TypeBox type */</span>
<span class="s0">export </span><span class="s1">declare type Static</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s0">extends </span><span class="s1">TSchema</span><span class="s2">, </span><span class="s1">P </span><span class="s0">extends </span><span class="s1">unknown</span><span class="s2">[] = []&gt; = (</span><span class="s1">T </span><span class="s2">&amp; {</span>
    <span class="s1">params</span><span class="s2">: </span><span class="s1">P</span><span class="s2">;</span>
<span class="s2">})[</span><span class="s3">'static'</span><span class="s2">];</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">class </span><span class="s1">TypeBuilder </span><span class="s2">{</span>
    <span class="s4">/** Creates a readonly optional property */</span>
    <span class="s1">ReadonlyOptional</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s0">extends </span><span class="s1">TSchema</span><span class="s2">&gt;(</span><span class="s1">item</span><span class="s2">: </span><span class="s1">T</span><span class="s2">): </span><span class="s1">TReadonlyOptional</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;;</span>
    <span class="s4">/** Creates a readonly property */</span>
    <span class="s1">Readonly</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s0">extends </span><span class="s1">TSchema</span><span class="s2">&gt;(</span><span class="s1">item</span><span class="s2">: </span><span class="s1">T</span><span class="s2">): </span><span class="s1">TReadonly</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;;</span>
    <span class="s4">/** Creates a optional property */</span>
    <span class="s1">Optional</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s0">extends </span><span class="s1">TSchema</span><span class="s2">&gt;(</span><span class="s1">item</span><span class="s2">: </span><span class="s1">T</span><span class="s2">): </span><span class="s1">TOptional</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;;</span>
    <span class="s4">/** Creates a any type */</span>
    <span class="s1">Any</span><span class="s2">(</span><span class="s1">options</span><span class="s2">?: </span><span class="s1">SchemaOptions</span><span class="s2">): </span><span class="s1">TAny</span><span class="s2">;</span>
    <span class="s4">/** Creates a array type */</span>
    <span class="s1">Array</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s0">extends </span><span class="s1">TSchema</span><span class="s2">&gt;(</span><span class="s1">items</span><span class="s2">: </span><span class="s1">T</span><span class="s2">, </span><span class="s1">options</span><span class="s2">?: </span><span class="s1">ArrayOptions</span><span class="s2">): </span><span class="s1">TArray</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;;</span>
    <span class="s4">/** Creates a boolean type */</span>
    <span class="s1">Boolean</span><span class="s2">(</span><span class="s1">options</span><span class="s2">?: </span><span class="s1">SchemaOptions</span><span class="s2">): </span><span class="s1">TBoolean</span><span class="s2">;</span>
    <span class="s4">/** Creates a tuple type from this constructors parameters */</span>
    <span class="s1">ConstructorParameters</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s0">extends </span><span class="s1">TConstructor</span><span class="s2">&lt;</span><span class="s1">any</span><span class="s2">[], </span><span class="s1">any</span><span class="s2">&gt;&gt;(</span><span class="s1">schema</span><span class="s2">: </span><span class="s1">T</span><span class="s2">, </span><span class="s1">options</span><span class="s2">?: </span><span class="s1">SchemaOptions</span><span class="s2">): </span><span class="s1">TConstructorParameters</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;;</span>
    <span class="s4">/** Creates a constructor type */</span>
    <span class="s1">Constructor</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s0">extends </span><span class="s1">TTuple</span><span class="s2">&lt;</span><span class="s1">TSchema</span><span class="s2">[]&gt;, </span><span class="s1">U </span><span class="s0">extends </span><span class="s1">TSchema</span><span class="s2">&gt;(</span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">T</span><span class="s2">, </span><span class="s1">returns</span><span class="s2">: </span><span class="s1">U</span><span class="s2">, </span><span class="s1">options</span><span class="s2">?: </span><span class="s1">SchemaOptions</span><span class="s2">): </span><span class="s1">TConstructor</span><span class="s2">&lt;</span><span class="s1">TupleToArray</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;, </span><span class="s1">U</span><span class="s2">&gt;;</span>
    <span class="s4">/** Creates a constructor type */</span>
    <span class="s1">Constructor</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s0">extends </span><span class="s1">TSchema</span><span class="s2">[], </span><span class="s1">U </span><span class="s0">extends </span><span class="s1">TSchema</span><span class="s2">&gt;(</span><span class="s1">parameters</span><span class="s2">: [</span><span class="s1">...T</span><span class="s2">], </span><span class="s1">returns</span><span class="s2">: </span><span class="s1">U</span><span class="s2">, </span><span class="s1">options</span><span class="s2">?: </span><span class="s1">SchemaOptions</span><span class="s2">): </span><span class="s1">TConstructor</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">, </span><span class="s1">U</span><span class="s2">&gt;;</span>
    <span class="s4">/** Creates a enum type */</span>
    <span class="s1">Enum</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s0">extends </span><span class="s1">Record</span><span class="s2">&lt;</span><span class="s1">string</span><span class="s2">, </span><span class="s1">string </span><span class="s2">| </span><span class="s1">number</span><span class="s2">&gt;&gt;(</span><span class="s1">item</span><span class="s2">: </span><span class="s1">T</span><span class="s2">, </span><span class="s1">options</span><span class="s2">?: </span><span class="s1">SchemaOptions</span><span class="s2">): </span><span class="s1">TEnum</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;;</span>
    <span class="s4">/** Creates a function type */</span>
    <span class="s1">Function</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s0">extends </span><span class="s1">TTuple</span><span class="s2">&lt;</span><span class="s1">TSchema</span><span class="s2">[]&gt;, </span><span class="s1">U </span><span class="s0">extends </span><span class="s1">TSchema</span><span class="s2">&gt;(</span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">T</span><span class="s2">, </span><span class="s1">returns</span><span class="s2">: </span><span class="s1">U</span><span class="s2">, </span><span class="s1">options</span><span class="s2">?: </span><span class="s1">SchemaOptions</span><span class="s2">): </span><span class="s1">TFunction</span><span class="s2">&lt;</span><span class="s1">TupleToArray</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;, </span><span class="s1">U</span><span class="s2">&gt;;</span>
    <span class="s4">/** Creates a function type */</span>
    <span class="s1">Function</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s0">extends </span><span class="s1">TSchema</span><span class="s2">[], </span><span class="s1">U </span><span class="s0">extends </span><span class="s1">TSchema</span><span class="s2">&gt;(</span><span class="s1">parameters</span><span class="s2">: [</span><span class="s1">...T</span><span class="s2">], </span><span class="s1">returns</span><span class="s2">: </span><span class="s1">U</span><span class="s2">, </span><span class="s1">options</span><span class="s2">?: </span><span class="s1">SchemaOptions</span><span class="s2">): </span><span class="s1">TFunction</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">, </span><span class="s1">U</span><span class="s2">&gt;;</span>
    <span class="s4">/** Creates a type from this constructors instance type */</span>
    <span class="s1">InstanceType</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s0">extends </span><span class="s1">TConstructor</span><span class="s2">&lt;</span><span class="s1">any</span><span class="s2">[], </span><span class="s1">any</span><span class="s2">&gt;&gt;(</span><span class="s1">schema</span><span class="s2">: </span><span class="s1">T</span><span class="s2">, </span><span class="s1">options</span><span class="s2">?: </span><span class="s1">SchemaOptions</span><span class="s2">): </span><span class="s1">TInstanceType</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;;</span>
    <span class="s4">/** Creates a integer type */</span>
    <span class="s1">Integer</span><span class="s2">(</span><span class="s1">options</span><span class="s2">?: </span><span class="s1">NumericOptions</span><span class="s2">): </span><span class="s1">TInteger</span><span class="s2">;</span>
    <span class="s4">/** Creates a intersect type. */</span>
    <span class="s1">Intersect</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s0">extends </span><span class="s1">TObject</span><span class="s2">[]&gt;(</span><span class="s1">objects</span><span class="s2">: [</span><span class="s1">...T</span><span class="s2">], </span><span class="s1">options</span><span class="s2">?: </span><span class="s1">ObjectOptions</span><span class="s2">): </span><span class="s1">TIntersect</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;;</span>
    <span class="s4">/** Creates a keyof type */</span>
    <span class="s1">KeyOf</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s0">extends </span><span class="s1">TObject</span><span class="s2">&gt;(</span><span class="s1">object</span><span class="s2">: </span><span class="s1">T</span><span class="s2">, </span><span class="s1">options</span><span class="s2">?: </span><span class="s1">SchemaOptions</span><span class="s2">): </span><span class="s1">TKeyOf</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;;</span>
    <span class="s4">/** Creates a literal type. */</span>
    <span class="s1">Literal</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s0">extends </span><span class="s1">TLiteralValue</span><span class="s2">&gt;(</span><span class="s1">value</span><span class="s2">: </span><span class="s1">T</span><span class="s2">, </span><span class="s1">options</span><span class="s2">?: </span><span class="s1">SchemaOptions</span><span class="s2">): </span><span class="s1">TLiteral</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;;</span>
    <span class="s4">/** Creates a never type */</span>
    <span class="s1">Never</span><span class="s2">(</span><span class="s1">options</span><span class="s2">?: </span><span class="s1">SchemaOptions</span><span class="s2">): </span><span class="s1">TNever</span><span class="s2">;</span>
    <span class="s4">/** Creates a null type */</span>
    <span class="s1">Null</span><span class="s2">(</span><span class="s1">options</span><span class="s2">?: </span><span class="s1">SchemaOptions</span><span class="s2">): </span><span class="s1">TNull</span><span class="s2">;</span>
    <span class="s4">/** Creates a number type */</span>
    <span class="s1">Number</span><span class="s2">(</span><span class="s1">options</span><span class="s2">?: </span><span class="s1">NumericOptions</span><span class="s2">): </span><span class="s1">TNumber</span><span class="s2">;</span>
    <span class="s4">/** Creates an object type with the given properties */</span>
    <span class="s1">Object</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s0">extends </span><span class="s1">TProperties</span><span class="s2">&gt;(</span><span class="s1">properties</span><span class="s2">: </span><span class="s1">T</span><span class="s2">, </span><span class="s1">options</span><span class="s2">?: </span><span class="s1">ObjectOptions</span><span class="s2">): </span><span class="s1">TObject</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;;</span>
    <span class="s4">/** Creates a new object whose properties are omitted from the given object */</span>
    <span class="s1">Omit</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s0">extends </span><span class="s1">TObject</span><span class="s2">, </span><span class="s1">K </span><span class="s0">extends </span><span class="s1">TUnion</span><span class="s2">&lt;</span><span class="s1">TLiteral</span><span class="s2">&lt;</span><span class="s1">string</span><span class="s2">&gt;[]&gt;&gt;(</span><span class="s1">schema</span><span class="s2">: </span><span class="s1">T</span><span class="s2">, </span><span class="s1">keys</span><span class="s2">: </span><span class="s1">K</span><span class="s2">, </span><span class="s1">options</span><span class="s2">?: </span><span class="s1">ObjectOptions</span><span class="s2">): </span><span class="s1">TOmit</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">, </span><span class="s1">UnionStringLiteralToTuple</span><span class="s2">&lt;</span><span class="s1">K</span><span class="s2">&gt;&gt;;</span>
    <span class="s4">/** Creates a new object whose properties are omitted from the given object */</span>
    <span class="s1">Omit</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s0">extends </span><span class="s1">TObject</span><span class="s2">, </span><span class="s1">K </span><span class="s0">extends </span><span class="s1">ObjectPropertyKeys</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;[]&gt;(</span><span class="s1">schema</span><span class="s2">: </span><span class="s1">T</span><span class="s2">, </span><span class="s1">keys</span><span class="s2">: </span><span class="s1">readonly </span><span class="s2">[</span><span class="s1">...K</span><span class="s2">], </span><span class="s1">options</span><span class="s2">?: </span><span class="s1">ObjectOptions</span><span class="s2">): </span><span class="s1">TOmit</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">, </span><span class="s1">K</span><span class="s2">&gt;;</span>
    <span class="s4">/** Creates a tuple type from this functions parameters */</span>
    <span class="s1">Parameters</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s0">extends </span><span class="s1">TFunction</span><span class="s2">&lt;</span><span class="s1">any</span><span class="s2">[], </span><span class="s1">any</span><span class="s2">&gt;&gt;(</span><span class="s1">schema</span><span class="s2">: </span><span class="s1">T</span><span class="s2">, </span><span class="s1">options</span><span class="s2">?: </span><span class="s1">SchemaOptions</span><span class="s2">): </span><span class="s1">TParameters</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;;</span>
    <span class="s4">/** Creates an object type whose properties are all optional */</span>
    <span class="s1">Partial</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s0">extends </span><span class="s1">TObject</span><span class="s2">&gt;(</span><span class="s1">schema</span><span class="s2">: </span><span class="s1">T</span><span class="s2">, </span><span class="s1">options</span><span class="s2">?: </span><span class="s1">ObjectOptions</span><span class="s2">): </span><span class="s1">TPartial</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;;</span>
    <span class="s4">/** Creates a object whose properties are picked from the given object */</span>
    <span class="s1">Pick</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s0">extends </span><span class="s1">TObject</span><span class="s2">, </span><span class="s1">K </span><span class="s0">extends </span><span class="s1">TUnion</span><span class="s2">&lt;</span><span class="s1">TLiteral</span><span class="s2">&lt;</span><span class="s1">string</span><span class="s2">&gt;[]&gt;&gt;(</span><span class="s1">schema</span><span class="s2">: </span><span class="s1">T</span><span class="s2">, </span><span class="s1">keys</span><span class="s2">: </span><span class="s1">K</span><span class="s2">, </span><span class="s1">options</span><span class="s2">?: </span><span class="s1">ObjectOptions</span><span class="s2">): </span><span class="s1">TPick</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">, </span><span class="s1">UnionStringLiteralToTuple</span><span class="s2">&lt;</span><span class="s1">K</span><span class="s2">&gt;&gt;;</span>
    <span class="s4">/** Creates a object whose properties are picked from the given object */</span>
    <span class="s1">Pick</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s0">extends </span><span class="s1">TObject</span><span class="s2">, </span><span class="s1">K </span><span class="s0">extends </span><span class="s1">ObjectPropertyKeys</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;[]&gt;(</span><span class="s1">schema</span><span class="s2">: </span><span class="s1">T</span><span class="s2">, </span><span class="s1">keys</span><span class="s2">: </span><span class="s1">readonly </span><span class="s2">[</span><span class="s1">...K</span><span class="s2">], </span><span class="s1">options</span><span class="s2">?: </span><span class="s1">ObjectOptions</span><span class="s2">): </span><span class="s1">TPick</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">, </span><span class="s1">K</span><span class="s2">&gt;;</span>
    <span class="s4">/** Creates a promise type. This type cannot be represented in schema. */</span>
    <span class="s1">Promise</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s0">extends </span><span class="s1">TSchema</span><span class="s2">&gt;(</span><span class="s1">item</span><span class="s2">: </span><span class="s1">T</span><span class="s2">, </span><span class="s1">options</span><span class="s2">?: </span><span class="s1">SchemaOptions</span><span class="s2">): </span><span class="s1">TPromise</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;;</span>
    <span class="s4">/** Creates an object whose properties are derived from the given string literal union. */</span>
    <span class="s1">Record</span><span class="s2">&lt;</span><span class="s1">K </span><span class="s0">extends </span><span class="s1">TUnion</span><span class="s2">&lt;</span><span class="s1">TLiteral</span><span class="s2">[]&gt;, </span><span class="s1">T </span><span class="s0">extends </span><span class="s1">TSchema</span><span class="s2">&gt;(</span><span class="s1">key</span><span class="s2">: </span><span class="s1">K</span><span class="s2">, </span><span class="s1">schema</span><span class="s2">: </span><span class="s1">T</span><span class="s2">, </span><span class="s1">options</span><span class="s2">?: </span><span class="s1">ObjectOptions</span><span class="s2">): </span><span class="s1">TObject</span><span class="s2">&lt;</span><span class="s1">TRecordProperties</span><span class="s2">&lt;</span><span class="s1">K</span><span class="s2">, </span><span class="s1">T</span><span class="s2">&gt;&gt;;</span>
    <span class="s4">/** Creates a record type */</span>
    <span class="s1">Record</span><span class="s2">&lt;</span><span class="s1">K </span><span class="s0">extends </span><span class="s1">TString </span><span class="s2">| </span><span class="s1">TNumeric</span><span class="s2">, </span><span class="s1">T </span><span class="s0">extends </span><span class="s1">TSchema</span><span class="s2">&gt;(</span><span class="s1">key</span><span class="s2">: </span><span class="s1">K</span><span class="s2">, </span><span class="s1">schema</span><span class="s2">: </span><span class="s1">T</span><span class="s2">, </span><span class="s1">options</span><span class="s2">?: </span><span class="s1">ObjectOptions</span><span class="s2">): </span><span class="s1">TRecord</span><span class="s2">&lt;</span><span class="s1">K</span><span class="s2">, </span><span class="s1">T</span><span class="s2">&gt;;</span>
    <span class="s4">/** Creates a recursive object type */</span>
    <span class="s1">Recursive</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s0">extends </span><span class="s1">TSchema</span><span class="s2">&gt;(</span><span class="s1">callback</span><span class="s2">: (</span><span class="s1">self</span><span class="s2">: </span><span class="s1">TSelf</span><span class="s2">) =&gt; </span><span class="s1">T</span><span class="s2">, </span><span class="s1">options</span><span class="s2">?: </span><span class="s1">SchemaOptions</span><span class="s2">): </span><span class="s1">TRecursive</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;;</span>
    <span class="s4">/** Creates a reference schema */</span>
    <span class="s1">Ref</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s0">extends </span><span class="s1">TSchema</span><span class="s2">&gt;(</span><span class="s1">schema</span><span class="s2">: </span><span class="s1">T</span><span class="s2">, </span><span class="s1">options</span><span class="s2">?: </span><span class="s1">SchemaOptions</span><span class="s2">): </span><span class="s1">TRef</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;;</span>
    <span class="s4">/** Creates a string type from a regular expression */</span>
    <span class="s1">RegEx</span><span class="s2">(</span><span class="s1">regex</span><span class="s2">: </span><span class="s1">RegExp</span><span class="s2">, </span><span class="s1">options</span><span class="s2">?: </span><span class="s1">SchemaOptions</span><span class="s2">): </span><span class="s1">TString</span><span class="s2">;</span>
    <span class="s4">/** Creates an object type whose properties are all required */</span>
    <span class="s1">Required</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s0">extends </span><span class="s1">TObject</span><span class="s2">&gt;(</span><span class="s1">schema</span><span class="s2">: </span><span class="s1">T</span><span class="s2">, </span><span class="s1">options</span><span class="s2">?: </span><span class="s1">SchemaOptions</span><span class="s2">): </span><span class="s1">TRequired</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;;</span>
    <span class="s4">/** Creates a type from this functions return type */</span>
    <span class="s1">ReturnType</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s0">extends </span><span class="s1">TFunction</span><span class="s2">&lt;</span><span class="s1">any</span><span class="s2">[], </span><span class="s1">any</span><span class="s2">&gt;&gt;(</span><span class="s1">schema</span><span class="s2">: </span><span class="s1">T</span><span class="s2">, </span><span class="s1">options</span><span class="s2">?: </span><span class="s1">SchemaOptions</span><span class="s2">): </span><span class="s1">TReturnType</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;;</span>
    <span class="s4">/** Removes Kind and Modifier symbol property keys from this schema */</span>
    <span class="s1">Strict</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s0">extends </span><span class="s1">TSchema</span><span class="s2">&gt;(</span><span class="s1">schema</span><span class="s2">: </span><span class="s1">T</span><span class="s2">): </span><span class="s1">T</span><span class="s2">;</span>
    <span class="s4">/** Creates a string type */</span>
    <span class="s1">String</span><span class="s2">&lt;</span><span class="s1">Format </span><span class="s0">extends </span><span class="s1">string</span><span class="s2">&gt;(</span><span class="s1">options</span><span class="s2">?: </span><span class="s1">StringOptions</span><span class="s2">&lt;</span><span class="s1">StringFormatOption </span><span class="s2">| </span><span class="s1">Format</span><span class="s2">&gt;): </span><span class="s1">TString</span><span class="s2">&lt;</span><span class="s1">Format</span><span class="s2">&gt;;</span>
    <span class="s4">/** Creates a tuple type */</span>
    <span class="s1">Tuple</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s0">extends </span><span class="s1">TSchema</span><span class="s2">[]&gt;(</span><span class="s1">items</span><span class="s2">: [</span><span class="s1">...T</span><span class="s2">], </span><span class="s1">options</span><span class="s2">?: </span><span class="s1">SchemaOptions</span><span class="s2">): </span><span class="s1">TTuple</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;;</span>
    <span class="s4">/** Creates a undefined type */</span>
    <span class="s1">Undefined</span><span class="s2">(</span><span class="s1">options</span><span class="s2">?: </span><span class="s1">SchemaOptions</span><span class="s2">): </span><span class="s1">TUndefined</span><span class="s2">;</span>
    <span class="s4">/** Creates a union type */</span>
    <span class="s1">Union</span><span class="s2">(</span><span class="s1">items</span><span class="s2">: [], </span><span class="s1">options</span><span class="s2">?: </span><span class="s1">SchemaOptions</span><span class="s2">): </span><span class="s1">TNever</span><span class="s2">;</span>
    <span class="s1">Union</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s0">extends </span><span class="s1">TSchema</span><span class="s2">[]&gt;(</span><span class="s1">items</span><span class="s2">: [</span><span class="s1">...T</span><span class="s2">], </span><span class="s1">options</span><span class="s2">?: </span><span class="s1">SchemaOptions</span><span class="s2">): </span><span class="s1">TUnion</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;;</span>
    <span class="s4">/** Creates a Uint8Array type */</span>
    <span class="s1">Uint8Array</span><span class="s2">(</span><span class="s1">options</span><span class="s2">?: </span><span class="s1">Uint8ArrayOptions</span><span class="s2">): </span><span class="s1">TUint8Array</span><span class="s2">;</span>
    <span class="s4">/** Creates an unknown type */</span>
    <span class="s1">Unknown</span><span class="s2">(</span><span class="s1">options</span><span class="s2">?: </span><span class="s1">SchemaOptions</span><span class="s2">): </span><span class="s1">TUnknown</span><span class="s2">;</span>
    <span class="s4">/** Creates a user defined schema that infers as type T  */</span>
    <span class="s1">Unsafe</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;(</span><span class="s1">options</span><span class="s2">?: </span><span class="s1">UnsafeOptions</span><span class="s2">): </span><span class="s1">TUnsafe</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;;</span>
    <span class="s4">/** Creates a void type */</span>
    <span class="s1">Void</span><span class="s2">(</span><span class="s1">options</span><span class="s2">?: </span><span class="s1">SchemaOptions</span><span class="s2">): </span><span class="s1">TVoid</span><span class="s2">;</span>
    <span class="s4">/** Use this function to return TSchema with static and params omitted */</span>
    <span class="s0">protected </span><span class="s1">Create</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;(</span><span class="s1">schema</span><span class="s2">: </span><span class="s1">Omit</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">, </span><span class="s3">'static' </span><span class="s2">| </span><span class="s3">'params'</span><span class="s2">&gt;): </span><span class="s1">T</span><span class="s2">;</span>
    <span class="s4">/** Clones the given value */</span>
    <span class="s0">protected </span><span class="s1">Clone</span><span class="s2">(</span><span class="s1">value</span><span class="s2">: </span><span class="s1">any</span><span class="s2">): </span><span class="s1">any</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">/** JSON Schema Type Builder with Static Type Resolution for TypeScript */</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">const </span><span class="s1">Type</span><span class="s2">: </span><span class="s1">TypeBuilder</span><span class="s2">;</span>
</pre>
</body>
</html>