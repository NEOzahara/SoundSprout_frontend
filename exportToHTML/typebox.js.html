<html>
<head>
<title>typebox.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #6aab73;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #7a7e85;}
.s4 { color: #cf8e6d;}
.s5 { color: #2aacb8;}
.s6 { color: #5f826b; font-style: italic;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
typebox.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s3">/*-------------------------------------------------------------------------- 
 
@sinclair/typebox 
 
The MIT License (MIT) 
 
Copyright (c) 2022 Haydn Paterson (sinclair) &lt;haydn.developer@gmail.com&gt; 
 
Permission is hereby granted, free of charge, to any person obtaining a copy 
of this software and associated documentation files (the &quot;Software&quot;), to deal 
in the Software without restriction, including without limitation the rights 
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell 
copies of the Software, and to permit persons to whom the Software is 
furnished to do so, subject to the following conditions: 
 
The above copyright notice and this permission notice shall be included in 
all copies or substantial portions of the Software. 
 
THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN 
THE SOFTWARE. 
 
---------------------------------------------------------------------------*/</span>
<span class="s2">Object</span><span class="s1">.</span><span class="s2">defineProperty</span><span class="s1">(</span><span class="s2">exports</span><span class="s1">, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, { </span><span class="s2">value</span><span class="s1">: </span><span class="s4">true </span><span class="s1">});</span>
<span class="s2">exports</span><span class="s1">.</span><span class="s2">Type </span><span class="s1">= </span><span class="s2">exports</span><span class="s1">.</span><span class="s2">TypeBuilder </span><span class="s1">= </span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Modifier </span><span class="s1">= </span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Hint </span><span class="s1">= </span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Kind </span><span class="s1">= </span><span class="s4">void </span><span class="s5">0</span><span class="s1">;</span>
<span class="s3">// --------------------------------------------------------------------------</span>
<span class="s3">// Symbols</span>
<span class="s3">// --------------------------------------------------------------------------</span>
<span class="s2">exports</span><span class="s1">.</span><span class="s2">Kind </span><span class="s1">= </span><span class="s2">Symbol</span><span class="s1">.</span><span class="s2">for</span><span class="s1">(</span><span class="s0">'TypeBox.Kind'</span><span class="s1">);</span>
<span class="s2">exports</span><span class="s1">.</span><span class="s2">Hint </span><span class="s1">= </span><span class="s2">Symbol</span><span class="s1">.</span><span class="s2">for</span><span class="s1">(</span><span class="s0">'TypeBox.Hint'</span><span class="s1">);</span>
<span class="s2">exports</span><span class="s1">.</span><span class="s2">Modifier </span><span class="s1">= </span><span class="s2">Symbol</span><span class="s1">.</span><span class="s2">for</span><span class="s1">(</span><span class="s0">'TypeBox.Modifier'</span><span class="s1">);</span>
<span class="s3">// --------------------------------------------------------------------------</span>
<span class="s3">// TypeBuilder</span>
<span class="s3">// --------------------------------------------------------------------------</span>
<span class="s4">let </span><span class="s2">TypeOrdinal </span><span class="s1">= </span><span class="s5">0</span><span class="s1">;</span>
<span class="s4">class </span><span class="s2">TypeBuilder </span><span class="s1">{</span>
    <span class="s3">// ----------------------------------------------------------------------</span>
    <span class="s3">// Modifiers</span>
    <span class="s3">// ----------------------------------------------------------------------</span>
    <span class="s6">/** Creates a readonly optional property */</span>
    <span class="s2">ReadonlyOptional</span><span class="s1">(</span><span class="s2">item</span><span class="s1">) {</span>
        <span class="s4">return </span><span class="s1">{ [</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Modifier</span><span class="s1">]: </span><span class="s0">'ReadonlyOptional'</span><span class="s1">, </span><span class="s2">...item </span><span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s6">/** Creates a readonly property */</span>
    <span class="s2">Readonly</span><span class="s1">(</span><span class="s2">item</span><span class="s1">) {</span>
        <span class="s4">return </span><span class="s1">{ [</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Modifier</span><span class="s1">]: </span><span class="s0">'Readonly'</span><span class="s1">, </span><span class="s2">...item </span><span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s6">/** Creates a optional property */</span>
    <span class="s2">Optional</span><span class="s1">(</span><span class="s2">item</span><span class="s1">) {</span>
        <span class="s4">return </span><span class="s1">{ [</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Modifier</span><span class="s1">]: </span><span class="s0">'Optional'</span><span class="s1">, </span><span class="s2">...item </span><span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s3">// ----------------------------------------------------------------------</span>
    <span class="s3">// Types</span>
    <span class="s3">// ----------------------------------------------------------------------</span>
    <span class="s6">/** Creates a any type */</span>
    <span class="s2">Any</span><span class="s1">(</span><span class="s2">options </span><span class="s1">= {}) {</span>
        <span class="s4">return this</span><span class="s1">.</span><span class="s2">Create</span><span class="s1">({ </span><span class="s2">...options</span><span class="s1">, [</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Kind</span><span class="s1">]: </span><span class="s0">'Any' </span><span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s6">/** Creates a array type */</span>
    <span class="s2">Array</span><span class="s1">(</span><span class="s2">items</span><span class="s1">, </span><span class="s2">options </span><span class="s1">= {}) {</span>
        <span class="s4">return this</span><span class="s1">.</span><span class="s2">Create</span><span class="s1">({ </span><span class="s2">...options</span><span class="s1">, [</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Kind</span><span class="s1">]: </span><span class="s0">'Array'</span><span class="s1">, </span><span class="s2">type</span><span class="s1">: </span><span class="s0">'array'</span><span class="s1">, </span><span class="s2">items </span><span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s6">/** Creates a boolean type */</span>
    <span class="s2">Boolean</span><span class="s1">(</span><span class="s2">options </span><span class="s1">= {}) {</span>
        <span class="s4">return this</span><span class="s1">.</span><span class="s2">Create</span><span class="s1">({ </span><span class="s2">...options</span><span class="s1">, [</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Kind</span><span class="s1">]: </span><span class="s0">'Boolean'</span><span class="s1">, </span><span class="s2">type</span><span class="s1">: </span><span class="s0">'boolean' </span><span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s6">/** Creates a tuple type from this constructors parameters */</span>
    <span class="s2">ConstructorParameters</span><span class="s1">(</span><span class="s2">schema</span><span class="s1">, </span><span class="s2">options </span><span class="s1">= {}) {</span>
        <span class="s4">return this</span><span class="s1">.</span><span class="s2">Tuple</span><span class="s1">([</span><span class="s2">...schema</span><span class="s1">.</span><span class="s2">parameters</span><span class="s1">], { </span><span class="s2">...options </span><span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s6">/** Creates a constructor type */</span>
    <span class="s2">Constructor</span><span class="s1">(</span><span class="s2">parameters</span><span class="s1">, </span><span class="s2">returns</span><span class="s1">, </span><span class="s2">options </span><span class="s1">= {}) {</span>
        <span class="s4">if </span><span class="s1">(</span><span class="s2">parameters</span><span class="s1">[</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Kind</span><span class="s1">] === </span><span class="s0">'Tuple'</span><span class="s1">) {</span>
            <span class="s4">const </span><span class="s2">inner </span><span class="s1">= </span><span class="s2">parameters</span><span class="s1">.</span><span class="s2">items </span><span class="s1">=== </span><span class="s2">undefined </span><span class="s1">? [] : </span><span class="s2">parameters</span><span class="s1">.</span><span class="s2">items</span><span class="s1">;</span>
            <span class="s4">return this</span><span class="s1">.</span><span class="s2">Create</span><span class="s1">({ </span><span class="s2">...options</span><span class="s1">, [</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Kind</span><span class="s1">]: </span><span class="s0">'Constructor'</span><span class="s1">, </span><span class="s2">type</span><span class="s1">: </span><span class="s0">'constructor'</span><span class="s1">, </span><span class="s2">parameters</span><span class="s1">: </span><span class="s2">inner</span><span class="s1">, </span><span class="s2">returns </span><span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s4">else if </span><span class="s1">(</span><span class="s2">globalThis</span><span class="s1">.</span><span class="s2">Array</span><span class="s1">.</span><span class="s2">isArray</span><span class="s1">(</span><span class="s2">parameters</span><span class="s1">)) {</span>
            <span class="s4">return this</span><span class="s1">.</span><span class="s2">Create</span><span class="s1">({ </span><span class="s2">...options</span><span class="s1">, [</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Kind</span><span class="s1">]: </span><span class="s0">'Constructor'</span><span class="s1">, </span><span class="s2">type</span><span class="s1">: </span><span class="s0">'constructor'</span><span class="s1">, </span><span class="s2">parameters</span><span class="s1">, </span><span class="s2">returns </span><span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s4">else </span><span class="s1">{</span>
            <span class="s4">throw new </span><span class="s2">Error</span><span class="s1">(</span><span class="s0">'TypeBuilder.Constructor: Invalid parameters'</span><span class="s1">);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s6">/** Creates a enum type */</span>
    <span class="s2">Enum</span><span class="s1">(</span><span class="s2">item</span><span class="s1">, </span><span class="s2">options </span><span class="s1">= {}) {</span>
        <span class="s4">const </span><span class="s2">values </span><span class="s1">= </span><span class="s2">Object</span><span class="s1">.</span><span class="s2">keys</span><span class="s1">(</span><span class="s2">item</span><span class="s1">)</span>
            <span class="s1">.</span><span class="s2">filter</span><span class="s1">((</span><span class="s2">key</span><span class="s1">) =&gt; </span><span class="s2">isNaN</span><span class="s1">(</span><span class="s2">key</span><span class="s1">))</span>
            <span class="s1">.</span><span class="s2">map</span><span class="s1">((</span><span class="s2">key</span><span class="s1">) =&gt; </span><span class="s2">item</span><span class="s1">[</span><span class="s2">key</span><span class="s1">]);</span>
        <span class="s4">const </span><span class="s2">anyOf </span><span class="s1">= </span><span class="s2">values</span><span class="s1">.</span><span class="s2">map</span><span class="s1">((</span><span class="s2">value</span><span class="s1">) =&gt; (</span><span class="s4">typeof </span><span class="s2">value </span><span class="s1">=== </span><span class="s0">'string' </span><span class="s1">? { [</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Kind</span><span class="s1">]: </span><span class="s0">'Literal'</span><span class="s1">, </span><span class="s2">type</span><span class="s1">: </span><span class="s0">'string'</span><span class="s1">, </span><span class="s4">const</span><span class="s1">: </span><span class="s2">value </span><span class="s1">} : { [</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Kind</span><span class="s1">]: </span><span class="s0">'Literal'</span><span class="s1">, </span><span class="s2">type</span><span class="s1">: </span><span class="s0">'number'</span><span class="s1">, </span><span class="s4">const</span><span class="s1">: </span><span class="s2">value </span><span class="s1">}));</span>
        <span class="s4">return this</span><span class="s1">.</span><span class="s2">Create</span><span class="s1">({ </span><span class="s2">...options</span><span class="s1">, [</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Kind</span><span class="s1">]: </span><span class="s0">'Union'</span><span class="s1">, [</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Hint</span><span class="s1">]: </span><span class="s0">'Enum'</span><span class="s1">, </span><span class="s2">anyOf </span><span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s6">/** Creates a function type */</span>
    <span class="s2">Function</span><span class="s1">(</span><span class="s2">parameters</span><span class="s1">, </span><span class="s2">returns</span><span class="s1">, </span><span class="s2">options </span><span class="s1">= {}) {</span>
        <span class="s4">if </span><span class="s1">(</span><span class="s2">parameters</span><span class="s1">[</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Kind</span><span class="s1">] === </span><span class="s0">'Tuple'</span><span class="s1">) {</span>
            <span class="s4">const </span><span class="s2">inner </span><span class="s1">= </span><span class="s2">parameters</span><span class="s1">.</span><span class="s2">items </span><span class="s1">=== </span><span class="s2">undefined </span><span class="s1">? [] : </span><span class="s2">parameters</span><span class="s1">.</span><span class="s2">items</span><span class="s1">;</span>
            <span class="s4">return this</span><span class="s1">.</span><span class="s2">Create</span><span class="s1">({ </span><span class="s2">...options</span><span class="s1">, [</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Kind</span><span class="s1">]: </span><span class="s0">'Function'</span><span class="s1">, </span><span class="s2">type</span><span class="s1">: </span><span class="s0">'function'</span><span class="s1">, </span><span class="s2">parameters</span><span class="s1">: </span><span class="s2">inner</span><span class="s1">, </span><span class="s2">returns </span><span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s4">else if </span><span class="s1">(</span><span class="s2">globalThis</span><span class="s1">.</span><span class="s2">Array</span><span class="s1">.</span><span class="s2">isArray</span><span class="s1">(</span><span class="s2">parameters</span><span class="s1">)) {</span>
            <span class="s4">return this</span><span class="s1">.</span><span class="s2">Create</span><span class="s1">({ </span><span class="s2">...options</span><span class="s1">, [</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Kind</span><span class="s1">]: </span><span class="s0">'Function'</span><span class="s1">, </span><span class="s2">type</span><span class="s1">: </span><span class="s0">'function'</span><span class="s1">, </span><span class="s2">parameters</span><span class="s1">, </span><span class="s2">returns </span><span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s4">else </span><span class="s1">{</span>
            <span class="s4">throw new </span><span class="s2">Error</span><span class="s1">(</span><span class="s0">'TypeBuilder.Function: Invalid parameters'</span><span class="s1">);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s6">/** Creates a type from this constructors instance type */</span>
    <span class="s2">InstanceType</span><span class="s1">(</span><span class="s2">schema</span><span class="s1">, </span><span class="s2">options </span><span class="s1">= {}) {</span>
        <span class="s4">return </span><span class="s1">{ </span><span class="s2">...options</span><span class="s1">, </span><span class="s2">...</span><span class="s4">this</span><span class="s1">.</span><span class="s2">Clone</span><span class="s1">(</span><span class="s2">schema</span><span class="s1">.</span><span class="s2">returns</span><span class="s1">) };</span>
    <span class="s1">}</span>
    <span class="s6">/** Creates a integer type */</span>
    <span class="s2">Integer</span><span class="s1">(</span><span class="s2">options </span><span class="s1">= {}) {</span>
        <span class="s4">return this</span><span class="s1">.</span><span class="s2">Create</span><span class="s1">({ </span><span class="s2">...options</span><span class="s1">, [</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Kind</span><span class="s1">]: </span><span class="s0">'Integer'</span><span class="s1">, </span><span class="s2">type</span><span class="s1">: </span><span class="s0">'integer' </span><span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s6">/** Creates a intersect type. */</span>
    <span class="s2">Intersect</span><span class="s1">(</span><span class="s2">objects</span><span class="s1">, </span><span class="s2">options </span><span class="s1">= {}) {</span>
        <span class="s4">const </span><span class="s2">isOptional </span><span class="s1">= (</span><span class="s2">schema</span><span class="s1">) =&gt; (</span><span class="s2">schema</span><span class="s1">[</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Modifier</span><span class="s1">] &amp;&amp; </span><span class="s2">schema</span><span class="s1">[</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Modifier</span><span class="s1">] === </span><span class="s0">'Optional'</span><span class="s1">) || </span><span class="s2">schema</span><span class="s1">[</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Modifier</span><span class="s1">] === </span><span class="s0">'ReadonlyOptional'</span><span class="s1">;</span>
        <span class="s4">const </span><span class="s1">[</span><span class="s2">required</span><span class="s1">, </span><span class="s2">optional</span><span class="s1">] = [</span><span class="s4">new </span><span class="s2">Set</span><span class="s1">(), </span><span class="s4">new </span><span class="s2">Set</span><span class="s1">()];</span>
        <span class="s4">for </span><span class="s1">(</span><span class="s4">const </span><span class="s2">object of objects</span><span class="s1">) {</span>
            <span class="s4">for </span><span class="s1">(</span><span class="s4">const </span><span class="s1">[</span><span class="s2">key</span><span class="s1">, </span><span class="s2">schema</span><span class="s1">] </span><span class="s2">of Object</span><span class="s1">.</span><span class="s2">entries</span><span class="s1">(</span><span class="s2">object</span><span class="s1">.</span><span class="s2">properties</span><span class="s1">)) {</span>
                <span class="s4">if </span><span class="s1">(</span><span class="s2">isOptional</span><span class="s1">(</span><span class="s2">schema</span><span class="s1">))</span>
                    <span class="s2">optional</span><span class="s1">.</span><span class="s2">add</span><span class="s1">(</span><span class="s2">key</span><span class="s1">);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s4">for </span><span class="s1">(</span><span class="s4">const </span><span class="s2">object of objects</span><span class="s1">) {</span>
            <span class="s4">for </span><span class="s1">(</span><span class="s4">const </span><span class="s2">key of Object</span><span class="s1">.</span><span class="s2">keys</span><span class="s1">(</span><span class="s2">object</span><span class="s1">.</span><span class="s2">properties</span><span class="s1">)) {</span>
                <span class="s4">if </span><span class="s1">(!</span><span class="s2">optional</span><span class="s1">.</span><span class="s2">has</span><span class="s1">(</span><span class="s2">key</span><span class="s1">))</span>
                    <span class="s2">required</span><span class="s1">.</span><span class="s2">add</span><span class="s1">(</span><span class="s2">key</span><span class="s1">);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s4">const </span><span class="s2">properties </span><span class="s1">= {};</span>
        <span class="s4">for </span><span class="s1">(</span><span class="s4">const </span><span class="s2">object of objects</span><span class="s1">) {</span>
            <span class="s4">for </span><span class="s1">(</span><span class="s4">const </span><span class="s1">[</span><span class="s2">key</span><span class="s1">, </span><span class="s2">schema</span><span class="s1">] </span><span class="s2">of Object</span><span class="s1">.</span><span class="s2">entries</span><span class="s1">(</span><span class="s2">object</span><span class="s1">.</span><span class="s2">properties</span><span class="s1">)) {</span>
                <span class="s2">properties</span><span class="s1">[</span><span class="s2">key</span><span class="s1">] = </span><span class="s2">properties</span><span class="s1">[</span><span class="s2">key</span><span class="s1">] === </span><span class="s2">undefined </span><span class="s1">? </span><span class="s2">schema </span><span class="s1">: { [</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Kind</span><span class="s1">]: </span><span class="s0">'Union'</span><span class="s1">, </span><span class="s2">anyOf</span><span class="s1">: [</span><span class="s2">properties</span><span class="s1">[</span><span class="s2">key</span><span class="s1">], { </span><span class="s2">...schema </span><span class="s1">}] };</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s4">if </span><span class="s1">(</span><span class="s2">required</span><span class="s1">.</span><span class="s2">size </span><span class="s1">&gt; </span><span class="s5">0</span><span class="s1">) {</span>
            <span class="s4">return this</span><span class="s1">.</span><span class="s2">Create</span><span class="s1">({ </span><span class="s2">...options</span><span class="s1">, [</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Kind</span><span class="s1">]: </span><span class="s0">'Object'</span><span class="s1">, </span><span class="s2">type</span><span class="s1">: </span><span class="s0">'object'</span><span class="s1">, </span><span class="s2">properties</span><span class="s1">, </span><span class="s2">required</span><span class="s1">: [</span><span class="s2">...required</span><span class="s1">] });</span>
        <span class="s1">}</span>
        <span class="s4">else </span><span class="s1">{</span>
            <span class="s4">return this</span><span class="s1">.</span><span class="s2">Create</span><span class="s1">({ </span><span class="s2">...options</span><span class="s1">, [</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Kind</span><span class="s1">]: </span><span class="s0">'Object'</span><span class="s1">, </span><span class="s2">type</span><span class="s1">: </span><span class="s0">'object'</span><span class="s1">, </span><span class="s2">properties </span><span class="s1">});</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s6">/** Creates a keyof type */</span>
    <span class="s2">KeyOf</span><span class="s1">(</span><span class="s2">object</span><span class="s1">, </span><span class="s2">options </span><span class="s1">= {}) {</span>
        <span class="s4">const </span><span class="s2">items </span><span class="s1">= </span><span class="s2">Object</span><span class="s1">.</span><span class="s2">keys</span><span class="s1">(</span><span class="s2">object</span><span class="s1">.</span><span class="s2">properties</span><span class="s1">).</span><span class="s2">map</span><span class="s1">((</span><span class="s2">key</span><span class="s1">) =&gt; </span><span class="s4">this</span><span class="s1">.</span><span class="s2">Create</span><span class="s1">({ </span><span class="s2">...options</span><span class="s1">, [</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Kind</span><span class="s1">]: </span><span class="s0">'Literal'</span><span class="s1">, </span><span class="s2">type</span><span class="s1">: </span><span class="s0">'string'</span><span class="s1">, </span><span class="s4">const</span><span class="s1">: </span><span class="s2">key </span><span class="s1">}));</span>
        <span class="s4">return this</span><span class="s1">.</span><span class="s2">Create</span><span class="s1">({ </span><span class="s2">...options</span><span class="s1">, [</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Kind</span><span class="s1">]: </span><span class="s0">'Union'</span><span class="s1">, [</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Hint</span><span class="s1">]: </span><span class="s0">'KeyOf'</span><span class="s1">, </span><span class="s2">anyOf</span><span class="s1">: </span><span class="s2">items </span><span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s6">/** Creates a literal type. */</span>
    <span class="s2">Literal</span><span class="s1">(</span><span class="s2">value</span><span class="s1">, </span><span class="s2">options </span><span class="s1">= {}) {</span>
        <span class="s4">return this</span><span class="s1">.</span><span class="s2">Create</span><span class="s1">({ </span><span class="s2">...options</span><span class="s1">, [</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Kind</span><span class="s1">]: </span><span class="s0">'Literal'</span><span class="s1">, </span><span class="s4">const</span><span class="s1">: </span><span class="s2">value</span><span class="s1">, </span><span class="s2">type</span><span class="s1">: </span><span class="s4">typeof </span><span class="s2">value </span><span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s6">/** Creates a never type */</span>
    <span class="s2">Never</span><span class="s1">(</span><span class="s2">options </span><span class="s1">= {}) {</span>
        <span class="s4">return this</span><span class="s1">.</span><span class="s2">Create</span><span class="s1">({</span>
            <span class="s2">...options</span><span class="s1">,</span>
            <span class="s1">[</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Kind</span><span class="s1">]: </span><span class="s0">'Never'</span><span class="s1">,</span>
            <span class="s2">allOf</span><span class="s1">: [</span>
                <span class="s1">{ </span><span class="s2">type</span><span class="s1">: </span><span class="s0">'boolean'</span><span class="s1">, </span><span class="s4">const</span><span class="s1">: </span><span class="s4">false </span><span class="s1">},</span>
                <span class="s1">{ </span><span class="s2">type</span><span class="s1">: </span><span class="s0">'boolean'</span><span class="s1">, </span><span class="s4">const</span><span class="s1">: </span><span class="s4">true </span><span class="s1">},</span>
            <span class="s1">],</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s6">/** Creates a null type */</span>
    <span class="s2">Null</span><span class="s1">(</span><span class="s2">options </span><span class="s1">= {}) {</span>
        <span class="s4">return this</span><span class="s1">.</span><span class="s2">Create</span><span class="s1">({ </span><span class="s2">...options</span><span class="s1">, [</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Kind</span><span class="s1">]: </span><span class="s0">'Null'</span><span class="s1">, </span><span class="s2">type</span><span class="s1">: </span><span class="s0">'null' </span><span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s6">/** Creates a number type */</span>
    <span class="s2">Number</span><span class="s1">(</span><span class="s2">options </span><span class="s1">= {}) {</span>
        <span class="s4">return this</span><span class="s1">.</span><span class="s2">Create</span><span class="s1">({ </span><span class="s2">...options</span><span class="s1">, [</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Kind</span><span class="s1">]: </span><span class="s0">'Number'</span><span class="s1">, </span><span class="s2">type</span><span class="s1">: </span><span class="s0">'number' </span><span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s6">/** Creates an object type with the given properties */</span>
    <span class="s2">Object</span><span class="s1">(</span><span class="s2">properties</span><span class="s1">, </span><span class="s2">options </span><span class="s1">= {}) {</span>
        <span class="s4">const </span><span class="s2">property_names </span><span class="s1">= </span><span class="s2">Object</span><span class="s1">.</span><span class="s2">keys</span><span class="s1">(</span><span class="s2">properties</span><span class="s1">);</span>
        <span class="s4">const </span><span class="s2">optional </span><span class="s1">= </span><span class="s2">property_names</span><span class="s1">.</span><span class="s2">filter</span><span class="s1">((</span><span class="s2">name</span><span class="s1">) =&gt; {</span>
            <span class="s4">const </span><span class="s2">property </span><span class="s1">= </span><span class="s2">properties</span><span class="s1">[</span><span class="s2">name</span><span class="s1">];</span>
            <span class="s4">const </span><span class="s2">modifier </span><span class="s1">= </span><span class="s2">property</span><span class="s1">[</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Modifier</span><span class="s1">];</span>
            <span class="s4">return </span><span class="s2">modifier </span><span class="s1">&amp;&amp; (</span><span class="s2">modifier </span><span class="s1">=== </span><span class="s0">'Optional' </span><span class="s1">|| </span><span class="s2">modifier </span><span class="s1">=== </span><span class="s0">'ReadonlyOptional'</span><span class="s1">);</span>
        <span class="s1">});</span>
        <span class="s4">const </span><span class="s2">required </span><span class="s1">= </span><span class="s2">property_names</span><span class="s1">.</span><span class="s2">filter</span><span class="s1">((</span><span class="s2">name</span><span class="s1">) =&gt; !</span><span class="s2">optional</span><span class="s1">.</span><span class="s2">includes</span><span class="s1">(</span><span class="s2">name</span><span class="s1">));</span>
        <span class="s4">if </span><span class="s1">(</span><span class="s2">required</span><span class="s1">.</span><span class="s2">length </span><span class="s1">&gt; </span><span class="s5">0</span><span class="s1">) {</span>
            <span class="s4">return this</span><span class="s1">.</span><span class="s2">Create</span><span class="s1">({ </span><span class="s2">...options</span><span class="s1">, [</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Kind</span><span class="s1">]: </span><span class="s0">'Object'</span><span class="s1">, </span><span class="s2">type</span><span class="s1">: </span><span class="s0">'object'</span><span class="s1">, </span><span class="s2">properties</span><span class="s1">, </span><span class="s2">required </span><span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s4">else </span><span class="s1">{</span>
            <span class="s4">return this</span><span class="s1">.</span><span class="s2">Create</span><span class="s1">({ </span><span class="s2">...options</span><span class="s1">, [</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Kind</span><span class="s1">]: </span><span class="s0">'Object'</span><span class="s1">, </span><span class="s2">type</span><span class="s1">: </span><span class="s0">'object'</span><span class="s1">, </span><span class="s2">properties </span><span class="s1">});</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s6">/** Creates a new object whose properties are omitted from the given object */</span>
    <span class="s2">Omit</span><span class="s1">(</span><span class="s2">schema</span><span class="s1">, </span><span class="s2">keys</span><span class="s1">, </span><span class="s2">options </span><span class="s1">= {}) {</span>
        <span class="s4">const </span><span class="s2">select </span><span class="s1">= </span><span class="s2">keys</span><span class="s1">[</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Kind</span><span class="s1">] === </span><span class="s0">'Union' </span><span class="s1">? </span><span class="s2">keys</span><span class="s1">.</span><span class="s2">anyOf</span><span class="s1">.</span><span class="s2">map</span><span class="s1">((</span><span class="s2">schema</span><span class="s1">) =&gt; </span><span class="s2">schema</span><span class="s1">.</span><span class="s2">const</span><span class="s1">) : </span><span class="s2">keys</span><span class="s1">;</span>
        <span class="s4">const </span><span class="s2">next </span><span class="s1">= { </span><span class="s2">...</span><span class="s4">this</span><span class="s1">.</span><span class="s2">Clone</span><span class="s1">(</span><span class="s2">schema</span><span class="s1">), </span><span class="s2">...options</span><span class="s1">, [</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Hint</span><span class="s1">]: </span><span class="s0">'Omit' </span><span class="s1">};</span>
        <span class="s4">if </span><span class="s1">(</span><span class="s2">next</span><span class="s1">.</span><span class="s2">required</span><span class="s1">) {</span>
            <span class="s2">next</span><span class="s1">.</span><span class="s2">required </span><span class="s1">= </span><span class="s2">next</span><span class="s1">.</span><span class="s2">required</span><span class="s1">.</span><span class="s2">filter</span><span class="s1">((</span><span class="s2">key</span><span class="s1">) =&gt; !</span><span class="s2">select</span><span class="s1">.</span><span class="s2">includes</span><span class="s1">(</span><span class="s2">key</span><span class="s1">));</span>
            <span class="s4">if </span><span class="s1">(</span><span class="s2">next</span><span class="s1">.</span><span class="s2">required</span><span class="s1">.</span><span class="s2">length </span><span class="s1">=== </span><span class="s5">0</span><span class="s1">)</span>
                <span class="s4">delete </span><span class="s2">next</span><span class="s1">.</span><span class="s2">required</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s4">for </span><span class="s1">(</span><span class="s4">const </span><span class="s2">key of Object</span><span class="s1">.</span><span class="s2">keys</span><span class="s1">(</span><span class="s2">next</span><span class="s1">.</span><span class="s2">properties</span><span class="s1">)) {</span>
            <span class="s4">if </span><span class="s1">(</span><span class="s2">select</span><span class="s1">.</span><span class="s2">includes</span><span class="s1">(</span><span class="s2">key</span><span class="s1">))</span>
                <span class="s4">delete </span><span class="s2">next</span><span class="s1">.</span><span class="s2">properties</span><span class="s1">[</span><span class="s2">key</span><span class="s1">];</span>
        <span class="s1">}</span>
        <span class="s4">return this</span><span class="s1">.</span><span class="s2">Create</span><span class="s1">(</span><span class="s2">next</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s6">/** Creates a tuple type from this functions parameters */</span>
    <span class="s2">Parameters</span><span class="s1">(</span><span class="s2">schema</span><span class="s1">, </span><span class="s2">options </span><span class="s1">= {}) {</span>
        <span class="s4">return </span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Type</span><span class="s1">.</span><span class="s2">Tuple</span><span class="s1">(</span><span class="s2">schema</span><span class="s1">.</span><span class="s2">parameters</span><span class="s1">, { </span><span class="s2">...options </span><span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s6">/** Creates an object type whose properties are all optional */</span>
    <span class="s2">Partial</span><span class="s1">(</span><span class="s2">schema</span><span class="s1">, </span><span class="s2">options </span><span class="s1">= {}) {</span>
        <span class="s4">const </span><span class="s2">next </span><span class="s1">= { </span><span class="s2">...</span><span class="s4">this</span><span class="s1">.</span><span class="s2">Clone</span><span class="s1">(</span><span class="s2">schema</span><span class="s1">), </span><span class="s2">...options</span><span class="s1">, [</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Hint</span><span class="s1">]: </span><span class="s0">'Partial' </span><span class="s1">};</span>
        <span class="s4">delete </span><span class="s2">next</span><span class="s1">.</span><span class="s2">required</span><span class="s1">;</span>
        <span class="s4">for </span><span class="s1">(</span><span class="s4">const </span><span class="s2">key of Object</span><span class="s1">.</span><span class="s2">keys</span><span class="s1">(</span><span class="s2">next</span><span class="s1">.</span><span class="s2">properties</span><span class="s1">)) {</span>
            <span class="s4">const </span><span class="s2">property </span><span class="s1">= </span><span class="s2">next</span><span class="s1">.</span><span class="s2">properties</span><span class="s1">[</span><span class="s2">key</span><span class="s1">];</span>
            <span class="s4">const </span><span class="s2">modifer </span><span class="s1">= </span><span class="s2">property</span><span class="s1">[</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Modifier</span><span class="s1">];</span>
            <span class="s4">switch </span><span class="s1">(</span><span class="s2">modifer</span><span class="s1">) {</span>
                <span class="s4">case </span><span class="s0">'ReadonlyOptional'</span><span class="s1">:</span>
                    <span class="s2">property</span><span class="s1">[</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Modifier</span><span class="s1">] = </span><span class="s0">'ReadonlyOptional'</span><span class="s1">;</span>
                    <span class="s4">break</span><span class="s1">;</span>
                <span class="s4">case </span><span class="s0">'Readonly'</span><span class="s1">:</span>
                    <span class="s2">property</span><span class="s1">[</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Modifier</span><span class="s1">] = </span><span class="s0">'ReadonlyOptional'</span><span class="s1">;</span>
                    <span class="s4">break</span><span class="s1">;</span>
                <span class="s4">case </span><span class="s0">'Optional'</span><span class="s1">:</span>
                    <span class="s2">property</span><span class="s1">[</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Modifier</span><span class="s1">] = </span><span class="s0">'Optional'</span><span class="s1">;</span>
                    <span class="s4">break</span><span class="s1">;</span>
                <span class="s4">default</span><span class="s1">:</span>
                    <span class="s2">property</span><span class="s1">[</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Modifier</span><span class="s1">] = </span><span class="s0">'Optional'</span><span class="s1">;</span>
                    <span class="s4">break</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s4">return this</span><span class="s1">.</span><span class="s2">Create</span><span class="s1">(</span><span class="s2">next</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s6">/** Creates a object whose properties are picked from the given object */</span>
    <span class="s2">Pick</span><span class="s1">(</span><span class="s2">schema</span><span class="s1">, </span><span class="s2">keys</span><span class="s1">, </span><span class="s2">options </span><span class="s1">= {}) {</span>
        <span class="s4">const </span><span class="s2">select </span><span class="s1">= </span><span class="s2">keys</span><span class="s1">[</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Kind</span><span class="s1">] === </span><span class="s0">'Union' </span><span class="s1">? </span><span class="s2">keys</span><span class="s1">.</span><span class="s2">anyOf</span><span class="s1">.</span><span class="s2">map</span><span class="s1">((</span><span class="s2">schema</span><span class="s1">) =&gt; </span><span class="s2">schema</span><span class="s1">.</span><span class="s2">const</span><span class="s1">) : </span><span class="s2">keys</span><span class="s1">;</span>
        <span class="s4">const </span><span class="s2">next </span><span class="s1">= { </span><span class="s2">...</span><span class="s4">this</span><span class="s1">.</span><span class="s2">Clone</span><span class="s1">(</span><span class="s2">schema</span><span class="s1">), </span><span class="s2">...options</span><span class="s1">, [</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Hint</span><span class="s1">]: </span><span class="s0">'Pick' </span><span class="s1">};</span>
        <span class="s4">if </span><span class="s1">(</span><span class="s2">next</span><span class="s1">.</span><span class="s2">required</span><span class="s1">) {</span>
            <span class="s2">next</span><span class="s1">.</span><span class="s2">required </span><span class="s1">= </span><span class="s2">next</span><span class="s1">.</span><span class="s2">required</span><span class="s1">.</span><span class="s2">filter</span><span class="s1">((</span><span class="s2">key</span><span class="s1">) =&gt; </span><span class="s2">select</span><span class="s1">.</span><span class="s2">includes</span><span class="s1">(</span><span class="s2">key</span><span class="s1">));</span>
            <span class="s4">if </span><span class="s1">(</span><span class="s2">next</span><span class="s1">.</span><span class="s2">required</span><span class="s1">.</span><span class="s2">length </span><span class="s1">=== </span><span class="s5">0</span><span class="s1">)</span>
                <span class="s4">delete </span><span class="s2">next</span><span class="s1">.</span><span class="s2">required</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s4">for </span><span class="s1">(</span><span class="s4">const </span><span class="s2">key of Object</span><span class="s1">.</span><span class="s2">keys</span><span class="s1">(</span><span class="s2">next</span><span class="s1">.</span><span class="s2">properties</span><span class="s1">)) {</span>
            <span class="s4">if </span><span class="s1">(!</span><span class="s2">select</span><span class="s1">.</span><span class="s2">includes</span><span class="s1">(</span><span class="s2">key</span><span class="s1">))</span>
                <span class="s4">delete </span><span class="s2">next</span><span class="s1">.</span><span class="s2">properties</span><span class="s1">[</span><span class="s2">key</span><span class="s1">];</span>
        <span class="s1">}</span>
        <span class="s4">return this</span><span class="s1">.</span><span class="s2">Create</span><span class="s1">(</span><span class="s2">next</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s6">/** Creates a promise type. This type cannot be represented in schema. */</span>
    <span class="s2">Promise</span><span class="s1">(</span><span class="s2">item</span><span class="s1">, </span><span class="s2">options </span><span class="s1">= {}) {</span>
        <span class="s4">return this</span><span class="s1">.</span><span class="s2">Create</span><span class="s1">({ </span><span class="s2">...options</span><span class="s1">, [</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Kind</span><span class="s1">]: </span><span class="s0">'Promise'</span><span class="s1">, </span><span class="s2">type</span><span class="s1">: </span><span class="s0">'promise'</span><span class="s1">, </span><span class="s2">item </span><span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s6">/** Creates a record type */</span>
    <span class="s2">Record</span><span class="s1">(</span><span class="s2">key</span><span class="s1">, </span><span class="s2">value</span><span class="s1">, </span><span class="s2">options </span><span class="s1">= {}) {</span>
        <span class="s3">// If string literal union return TObject with properties extracted from union.</span>
        <span class="s4">if </span><span class="s1">(</span><span class="s2">key</span><span class="s1">[</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Kind</span><span class="s1">] === </span><span class="s0">'Union'</span><span class="s1">) {</span>
            <span class="s4">return this</span><span class="s1">.</span><span class="s2">Object</span><span class="s1">(</span><span class="s2">key</span><span class="s1">.</span><span class="s2">anyOf</span><span class="s1">.</span><span class="s2">reduce</span><span class="s1">((</span><span class="s2">acc</span><span class="s1">, </span><span class="s2">literal</span><span class="s1">) =&gt; {</span>
                <span class="s4">return </span><span class="s1">{ </span><span class="s2">...acc</span><span class="s1">, [</span><span class="s2">literal</span><span class="s1">.</span><span class="s2">const</span><span class="s1">]: </span><span class="s2">value </span><span class="s1">};</span>
            <span class="s1">}, {}), { </span><span class="s2">...options</span><span class="s1">, [</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Hint</span><span class="s1">]: </span><span class="s0">'Record' </span><span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s3">// otherwise return TRecord with patternProperties</span>
        <span class="s4">const </span><span class="s2">pattern </span><span class="s1">= [</span><span class="s0">'Integer'</span><span class="s1">, </span><span class="s0">'Number'</span><span class="s1">].</span><span class="s2">includes</span><span class="s1">(</span><span class="s2">key</span><span class="s1">[</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Kind</span><span class="s1">]) ? </span><span class="s0">'^(0|[1-9][0-9]*)$' </span><span class="s1">: </span><span class="s2">key</span><span class="s1">[</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Kind</span><span class="s1">] === </span><span class="s0">'String' </span><span class="s1">&amp;&amp; </span><span class="s2">key</span><span class="s1">.</span><span class="s2">pattern </span><span class="s1">? </span><span class="s2">key</span><span class="s1">.</span><span class="s2">pattern </span><span class="s1">: </span><span class="s0">'^.*$'</span><span class="s1">;</span>
        <span class="s4">return this</span><span class="s1">.</span><span class="s2">Create</span><span class="s1">({</span>
            <span class="s2">...options</span><span class="s1">,</span>
            <span class="s1">[</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Kind</span><span class="s1">]: </span><span class="s0">'Record'</span><span class="s1">,</span>
            <span class="s2">type</span><span class="s1">: </span><span class="s0">'object'</span><span class="s1">,</span>
            <span class="s2">patternProperties</span><span class="s1">: { [</span><span class="s2">pattern</span><span class="s1">]: </span><span class="s2">value </span><span class="s1">},</span>
            <span class="s2">additionalProperties</span><span class="s1">: </span><span class="s4">false</span><span class="s1">,</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s6">/** Creates a recursive object type */</span>
    <span class="s2">Recursive</span><span class="s1">(</span><span class="s2">callback</span><span class="s1">, </span><span class="s2">options </span><span class="s1">= {}) {</span>
        <span class="s4">if </span><span class="s1">(</span><span class="s2">options</span><span class="s1">.</span><span class="s2">$id </span><span class="s1">=== </span><span class="s2">undefined</span><span class="s1">)</span>
            <span class="s2">options</span><span class="s1">.</span><span class="s2">$id </span><span class="s1">= </span><span class="s0">`T</span><span class="s2">$</span><span class="s1">{</span><span class="s2">TypeOrdinal</span><span class="s1">++}</span><span class="s0">`</span><span class="s1">;</span>
        <span class="s4">const </span><span class="s2">self </span><span class="s1">= </span><span class="s2">callback</span><span class="s1">({ [</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Kind</span><span class="s1">]: </span><span class="s0">'Self'</span><span class="s1">, </span><span class="s2">$ref</span><span class="s1">: </span><span class="s0">`</span><span class="s2">$</span><span class="s1">{</span><span class="s2">options</span><span class="s1">.</span><span class="s2">$id</span><span class="s1">}</span><span class="s0">` </span><span class="s1">});</span>
        <span class="s2">self</span><span class="s1">.</span><span class="s2">$id </span><span class="s1">= </span><span class="s2">options</span><span class="s1">.</span><span class="s2">$id</span><span class="s1">;</span>
        <span class="s4">return this</span><span class="s1">.</span><span class="s2">Create</span><span class="s1">({ </span><span class="s2">...options</span><span class="s1">, </span><span class="s2">...self </span><span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s6">/** Creates a reference schema */</span>
    <span class="s2">Ref</span><span class="s1">(</span><span class="s2">schema</span><span class="s1">, </span><span class="s2">options </span><span class="s1">= {}) {</span>
        <span class="s4">if </span><span class="s1">(</span><span class="s2">schema</span><span class="s1">.</span><span class="s2">$id </span><span class="s1">=== </span><span class="s2">undefined</span><span class="s1">)</span>
            <span class="s4">throw </span><span class="s2">Error</span><span class="s1">(</span><span class="s0">'TypeBuilder.Ref: Referenced schema must specify an $id'</span><span class="s1">);</span>
        <span class="s4">return this</span><span class="s1">.</span><span class="s2">Create</span><span class="s1">({ </span><span class="s2">...options</span><span class="s1">, [</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Kind</span><span class="s1">]: </span><span class="s0">'Ref'</span><span class="s1">, </span><span class="s2">$ref</span><span class="s1">: </span><span class="s2">schema</span><span class="s1">.</span><span class="s2">$id </span><span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s6">/** Creates a string type from a regular expression */</span>
    <span class="s2">RegEx</span><span class="s1">(</span><span class="s2">regex</span><span class="s1">, </span><span class="s2">options </span><span class="s1">= {}) {</span>
        <span class="s4">return this</span><span class="s1">.</span><span class="s2">Create</span><span class="s1">({ </span><span class="s2">...options</span><span class="s1">, [</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Kind</span><span class="s1">]: </span><span class="s0">'String'</span><span class="s1">, </span><span class="s2">type</span><span class="s1">: </span><span class="s0">'string'</span><span class="s1">, </span><span class="s2">pattern</span><span class="s1">: </span><span class="s2">regex</span><span class="s1">.</span><span class="s2">source </span><span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s6">/** Creates an object type whose properties are all required */</span>
    <span class="s2">Required</span><span class="s1">(</span><span class="s2">schema</span><span class="s1">, </span><span class="s2">options </span><span class="s1">= {}) {</span>
        <span class="s4">const </span><span class="s2">next </span><span class="s1">= { </span><span class="s2">...</span><span class="s4">this</span><span class="s1">.</span><span class="s2">Clone</span><span class="s1">(</span><span class="s2">schema</span><span class="s1">), </span><span class="s2">...options</span><span class="s1">, [</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Hint</span><span class="s1">]: </span><span class="s0">'Required' </span><span class="s1">};</span>
        <span class="s2">next</span><span class="s1">.</span><span class="s2">required </span><span class="s1">= </span><span class="s2">Object</span><span class="s1">.</span><span class="s2">keys</span><span class="s1">(</span><span class="s2">next</span><span class="s1">.</span><span class="s2">properties</span><span class="s1">);</span>
        <span class="s4">for </span><span class="s1">(</span><span class="s4">const </span><span class="s2">key of Object</span><span class="s1">.</span><span class="s2">keys</span><span class="s1">(</span><span class="s2">next</span><span class="s1">.</span><span class="s2">properties</span><span class="s1">)) {</span>
            <span class="s4">const </span><span class="s2">property </span><span class="s1">= </span><span class="s2">next</span><span class="s1">.</span><span class="s2">properties</span><span class="s1">[</span><span class="s2">key</span><span class="s1">];</span>
            <span class="s4">const </span><span class="s2">modifier </span><span class="s1">= </span><span class="s2">property</span><span class="s1">[</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Modifier</span><span class="s1">];</span>
            <span class="s4">switch </span><span class="s1">(</span><span class="s2">modifier</span><span class="s1">) {</span>
                <span class="s4">case </span><span class="s0">'ReadonlyOptional'</span><span class="s1">:</span>
                    <span class="s2">property</span><span class="s1">[</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Modifier</span><span class="s1">] = </span><span class="s0">'Readonly'</span><span class="s1">;</span>
                    <span class="s4">break</span><span class="s1">;</span>
                <span class="s4">case </span><span class="s0">'Readonly'</span><span class="s1">:</span>
                    <span class="s2">property</span><span class="s1">[</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Modifier</span><span class="s1">] = </span><span class="s0">'Readonly'</span><span class="s1">;</span>
                    <span class="s4">break</span><span class="s1">;</span>
                <span class="s4">case </span><span class="s0">'Optional'</span><span class="s1">:</span>
                    <span class="s4">delete </span><span class="s2">property</span><span class="s1">[</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Modifier</span><span class="s1">];</span>
                    <span class="s4">break</span><span class="s1">;</span>
                <span class="s4">default</span><span class="s1">:</span>
                    <span class="s4">delete </span><span class="s2">property</span><span class="s1">[</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Modifier</span><span class="s1">];</span>
                    <span class="s4">break</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s4">return this</span><span class="s1">.</span><span class="s2">Create</span><span class="s1">(</span><span class="s2">next</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s6">/** Creates a type from this functions return type */</span>
    <span class="s2">ReturnType</span><span class="s1">(</span><span class="s2">schema</span><span class="s1">, </span><span class="s2">options </span><span class="s1">= {}) {</span>
        <span class="s4">return </span><span class="s1">{ </span><span class="s2">...options</span><span class="s1">, </span><span class="s2">...</span><span class="s4">this</span><span class="s1">.</span><span class="s2">Clone</span><span class="s1">(</span><span class="s2">schema</span><span class="s1">.</span><span class="s2">returns</span><span class="s1">) };</span>
    <span class="s1">}</span>
    <span class="s6">/** Removes Kind and Modifier symbol property keys from this schema */</span>
    <span class="s2">Strict</span><span class="s1">(</span><span class="s2">schema</span><span class="s1">) {</span>
        <span class="s4">return </span><span class="s2">JSON</span><span class="s1">.</span><span class="s2">parse</span><span class="s1">(</span><span class="s2">JSON</span><span class="s1">.</span><span class="s2">stringify</span><span class="s1">(</span><span class="s2">schema</span><span class="s1">));</span>
    <span class="s1">}</span>
    <span class="s6">/** Creates a string type */</span>
    <span class="s2">String</span><span class="s1">(</span><span class="s2">options </span><span class="s1">= {}) {</span>
        <span class="s4">return this</span><span class="s1">.</span><span class="s2">Create</span><span class="s1">({ </span><span class="s2">...options</span><span class="s1">, [</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Kind</span><span class="s1">]: </span><span class="s0">'String'</span><span class="s1">, </span><span class="s2">type</span><span class="s1">: </span><span class="s0">'string' </span><span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s6">/** Creates a tuple type */</span>
    <span class="s2">Tuple</span><span class="s1">(</span><span class="s2">items</span><span class="s1">, </span><span class="s2">options </span><span class="s1">= {}) {</span>
        <span class="s4">const </span><span class="s2">additionalItems </span><span class="s1">= </span><span class="s4">false</span><span class="s1">;</span>
        <span class="s4">const </span><span class="s2">minItems </span><span class="s1">= </span><span class="s2">items</span><span class="s1">.</span><span class="s2">length</span><span class="s1">;</span>
        <span class="s4">const </span><span class="s2">maxItems </span><span class="s1">= </span><span class="s2">items</span><span class="s1">.</span><span class="s2">length</span><span class="s1">;</span>
        <span class="s4">const </span><span class="s2">schema </span><span class="s1">= (</span><span class="s2">items</span><span class="s1">.</span><span class="s2">length </span><span class="s1">&gt; </span><span class="s5">0 </span><span class="s1">? { </span><span class="s2">...options</span><span class="s1">, [</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Kind</span><span class="s1">]: </span><span class="s0">'Tuple'</span><span class="s1">, </span><span class="s2">type</span><span class="s1">: </span><span class="s0">'array'</span><span class="s1">, </span><span class="s2">items</span><span class="s1">, </span><span class="s2">additionalItems</span><span class="s1">, </span><span class="s2">minItems</span><span class="s1">, </span><span class="s2">maxItems </span><span class="s1">} : { </span><span class="s2">...options</span><span class="s1">, [</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Kind</span><span class="s1">]: </span><span class="s0">'Tuple'</span><span class="s1">, </span><span class="s2">type</span><span class="s1">: </span><span class="s0">'array'</span><span class="s1">, </span><span class="s2">minItems</span><span class="s1">, </span><span class="s2">maxItems </span><span class="s1">});</span>
        <span class="s4">return this</span><span class="s1">.</span><span class="s2">Create</span><span class="s1">(</span><span class="s2">schema</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s6">/** Creates a undefined type */</span>
    <span class="s2">Undefined</span><span class="s1">(</span><span class="s2">options </span><span class="s1">= {}) {</span>
        <span class="s4">return this</span><span class="s1">.</span><span class="s2">Create</span><span class="s1">({ </span><span class="s2">...options</span><span class="s1">, [</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Kind</span><span class="s1">]: </span><span class="s0">'Undefined'</span><span class="s1">, </span><span class="s2">type</span><span class="s1">: </span><span class="s0">'object'</span><span class="s1">, </span><span class="s2">specialized</span><span class="s1">: </span><span class="s0">'Undefined' </span><span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">Union</span><span class="s1">(</span><span class="s2">items</span><span class="s1">, </span><span class="s2">options </span><span class="s1">= {}) {</span>
        <span class="s4">return </span><span class="s2">items</span><span class="s1">.</span><span class="s2">length </span><span class="s1">=== </span><span class="s5">0 </span><span class="s1">? </span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Type</span><span class="s1">.</span><span class="s2">Never</span><span class="s1">({ </span><span class="s2">...options </span><span class="s1">}) : </span><span class="s4">this</span><span class="s1">.</span><span class="s2">Create</span><span class="s1">({ </span><span class="s2">...options</span><span class="s1">, [</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Kind</span><span class="s1">]: </span><span class="s0">'Union'</span><span class="s1">, </span><span class="s2">anyOf</span><span class="s1">: </span><span class="s2">items </span><span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s6">/** Creates a Uint8Array type */</span>
    <span class="s2">Uint8Array</span><span class="s1">(</span><span class="s2">options </span><span class="s1">= {}) {</span>
        <span class="s4">return this</span><span class="s1">.</span><span class="s2">Create</span><span class="s1">({ </span><span class="s2">...options</span><span class="s1">, [</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Kind</span><span class="s1">]: </span><span class="s0">'Uint8Array'</span><span class="s1">, </span><span class="s2">type</span><span class="s1">: </span><span class="s0">'object'</span><span class="s1">, </span><span class="s2">specialized</span><span class="s1">: </span><span class="s0">'Uint8Array' </span><span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s6">/** Creates an unknown type */</span>
    <span class="s2">Unknown</span><span class="s1">(</span><span class="s2">options </span><span class="s1">= {}) {</span>
        <span class="s4">return this</span><span class="s1">.</span><span class="s2">Create</span><span class="s1">({ </span><span class="s2">...options</span><span class="s1">, [</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Kind</span><span class="s1">]: </span><span class="s0">'Unknown' </span><span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s6">/** Creates a user defined schema that infers as type T  */</span>
    <span class="s2">Unsafe</span><span class="s1">(</span><span class="s2">options </span><span class="s1">= {}) {</span>
        <span class="s4">return this</span><span class="s1">.</span><span class="s2">Create</span><span class="s1">({ </span><span class="s2">...options</span><span class="s1">, [</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Kind</span><span class="s1">]: </span><span class="s2">options</span><span class="s1">[</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Kind</span><span class="s1">] || </span><span class="s0">'Unsafe' </span><span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s6">/** Creates a void type */</span>
    <span class="s2">Void</span><span class="s1">(</span><span class="s2">options </span><span class="s1">= {}) {</span>
        <span class="s4">return this</span><span class="s1">.</span><span class="s2">Create</span><span class="s1">({ </span><span class="s2">...options</span><span class="s1">, [</span><span class="s2">exports</span><span class="s1">.</span><span class="s2">Kind</span><span class="s1">]: </span><span class="s0">'Void'</span><span class="s1">, </span><span class="s2">type</span><span class="s1">: </span><span class="s0">'null' </span><span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s6">/** Use this function to return TSchema with static and params omitted */</span>
    <span class="s2">Create</span><span class="s1">(</span><span class="s2">schema</span><span class="s1">) {</span>
        <span class="s4">return </span><span class="s2">schema</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s6">/** Clones the given value */</span>
    <span class="s2">Clone</span><span class="s1">(</span><span class="s2">value</span><span class="s1">) {</span>
        <span class="s4">const </span><span class="s2">isObject </span><span class="s1">= (</span><span class="s2">object</span><span class="s1">) =&gt; </span><span class="s4">typeof </span><span class="s2">object </span><span class="s1">=== </span><span class="s0">'object' </span><span class="s1">&amp;&amp; </span><span class="s2">object </span><span class="s1">!== </span><span class="s4">null </span><span class="s1">&amp;&amp; !</span><span class="s2">Array</span><span class="s1">.</span><span class="s2">isArray</span><span class="s1">(</span><span class="s2">object</span><span class="s1">);</span>
        <span class="s4">const </span><span class="s2">isArray </span><span class="s1">= (</span><span class="s2">object</span><span class="s1">) =&gt; </span><span class="s4">typeof </span><span class="s2">object </span><span class="s1">=== </span><span class="s0">'object' </span><span class="s1">&amp;&amp; </span><span class="s2">object </span><span class="s1">!== </span><span class="s4">null </span><span class="s1">&amp;&amp; </span><span class="s2">Array</span><span class="s1">.</span><span class="s2">isArray</span><span class="s1">(</span><span class="s2">object</span><span class="s1">);</span>
        <span class="s4">if </span><span class="s1">(</span><span class="s2">isObject</span><span class="s1">(</span><span class="s2">value</span><span class="s1">)) {</span>
            <span class="s4">return </span><span class="s2">Object</span><span class="s1">.</span><span class="s2">keys</span><span class="s1">(</span><span class="s2">value</span><span class="s1">).</span><span class="s2">reduce</span><span class="s1">((</span><span class="s2">acc</span><span class="s1">, </span><span class="s2">key</span><span class="s1">) =&gt; ({</span>
                <span class="s2">...acc</span><span class="s1">,</span>
                <span class="s1">[</span><span class="s2">key</span><span class="s1">]: </span><span class="s4">this</span><span class="s1">.</span><span class="s2">Clone</span><span class="s1">(</span><span class="s2">value</span><span class="s1">[</span><span class="s2">key</span><span class="s1">]),</span>
            <span class="s1">}), </span><span class="s2">Object</span><span class="s1">.</span><span class="s2">getOwnPropertySymbols</span><span class="s1">(</span><span class="s2">value</span><span class="s1">).</span><span class="s2">reduce</span><span class="s1">((</span><span class="s2">acc</span><span class="s1">, </span><span class="s2">key</span><span class="s1">) =&gt; ({</span>
                <span class="s2">...acc</span><span class="s1">,</span>
                <span class="s1">[</span><span class="s2">key</span><span class="s1">]: </span><span class="s4">this</span><span class="s1">.</span><span class="s2">Clone</span><span class="s1">(</span><span class="s2">value</span><span class="s1">[</span><span class="s2">key</span><span class="s1">]),</span>
            <span class="s1">}), {}));</span>
        <span class="s1">}</span>
        <span class="s4">else if </span><span class="s1">(</span><span class="s2">isArray</span><span class="s1">(</span><span class="s2">value</span><span class="s1">)) {</span>
            <span class="s4">return </span><span class="s2">value</span><span class="s1">.</span><span class="s2">map</span><span class="s1">((</span><span class="s2">item</span><span class="s1">) =&gt; </span><span class="s4">this</span><span class="s1">.</span><span class="s2">Clone</span><span class="s1">(</span><span class="s2">item</span><span class="s1">));</span>
        <span class="s1">}</span>
        <span class="s4">else </span><span class="s1">{</span>
            <span class="s4">return </span><span class="s2">value</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">exports</span><span class="s1">.</span><span class="s2">TypeBuilder </span><span class="s1">= </span><span class="s2">TypeBuilder</span><span class="s1">;</span>
<span class="s6">/** JSON Schema Type Builder with Static Type Resolution for TypeScript */</span>
<span class="s2">exports</span><span class="s1">.</span><span class="s2">Type </span><span class="s1">= </span><span class="s4">new </span><span class="s2">TypeBuilder</span><span class="s1">();</span>
</pre>
</body>
</html>